diff -urN flo-ElementalX-5.00/.config flo-ElementalX-5.00-patched/.config
--- flo-ElementalX-5.00/.config	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/.config	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,4130 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARM_TICKET_LOCKS=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_PHYS_OFFSET=0x80200000
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="-flo"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_TEST=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_FIOPS=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_ROW is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_SIO is not set
+# CONFIG_DEFAULT_FIOPS is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+CONFIG_ARCH_MSM=y
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# MSM SoC Type
+#
+# CONFIG_ARCH_MSM7X01A is not set
+# CONFIG_ARCH_MSM7X25 is not set
+# CONFIG_ARCH_MSM7X27 is not set
+# CONFIG_ARCH_MSM7X30 is not set
+# CONFIG_ARCH_QSD8X50 is not set
+# CONFIG_ARCH_MSM8X60 is not set
+CONFIG_ARCH_MSM8960=y
+CONFIG_ARCH_MSM8930=y
+CONFIG_ARCH_APQ8064=y
+# CONFIG_ARCH_MSM8974 is not set
+# CONFIG_ARCH_MPQ8092 is not set
+# CONFIG_ARCH_MSM8226 is not set
+# CONFIG_ARCH_FSM9XXX is not set
+# CONFIG_ARCH_MSM9615 is not set
+# CONFIG_ARCH_MSM8625 is not set
+# CONFIG_ARCH_MSM9625 is not set
+CONFIG_MSM_SOC_REV_NONE=y
+# CONFIG_MSM_SOC_REV_A is not set
+CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
+CONFIG_ARCH_MSM_KRAIT=y
+CONFIG_MSM_SMP=y
+CONFIG_ARCH_MSM_KRAITMP=y
+CONFIG_MSM_KRAIT_WFE_FIXUP=y
+CONFIG_MSM_RPM=y
+# CONFIG_MSM_RPM_SMD is not set
+CONFIG_MSM_MPM=y
+CONFIG_MSM_XO=y
+CONFIG_MSM_REMOTE_SPINLOCK_SFPB=y
+
+#
+# MSM Board Selection
+#
+# CONFIG_MACH_MSM8960_CDP is not set
+# CONFIG_MACH_MSM8960_MTP is not set
+# CONFIG_MACH_MSM8960_FLUID is not set
+# CONFIG_MACH_MSM8960_LIQUID is not set
+# CONFIG_MACH_MSM8930_CDP is not set
+# CONFIG_MACH_MSM8930_MTP is not set
+# CONFIG_MACH_MSM8930_FLUID is not set
+# CONFIG_MACH_MSM8627_CDP is not set
+# CONFIG_MACH_MSM8627_MTP is not set
+# CONFIG_MACH_APQ8064_CDP is not set
+# CONFIG_MACH_APQ8064_MTP is not set
+# CONFIG_MACH_APQ8064_LIQUID is not set
+# CONFIG_MACH_MPQ8064_CDP is not set
+# CONFIG_MACH_MPQ8064_HRD is not set
+# CONFIG_MACH_MPQ8064_DTV is not set
+# CONFIG_MACH_MSM_DUMMY is not set
+
+#
+# LGE Board Selection
+#
+CONFIG_BOARD_HEADER_FILE=""
+# CONFIG_MACH_APQ8064_MAKO is not set
+# CONFIG_MACH_LGE_DUMMY is not set
+
+#
+# LGE Specific Patches
+#
+CONFIG_UPDATE_LCDC_LUT=y
+# CONFIG_LGE_CRASH_HANDLER is not set
+CONFIG_MACH_ASUSTEK=y
+
+#
+# ASUSTek Board Selection
+#
+CONFIG_MACH_APQ8064_FLO=y
+CONFIG_MACH_APQ8064_DEB=y
+# CONFIG_MACH_ASUSTEK_DUMMY is not set
+
+#
+# ASUSTek Specific Feature
+#
+CONFIG_ASUSTEK_PCBID=y
+CONFIG_ASUSTEK_KEYPAD=y
+# CONFIG_MSM_STACKED_MEMORY is not set
+CONFIG_KERNEL_MSM_CONTIG_MEM_REGION=y
+CONFIG_MSM_AMSS_VERSION=6225
+# CONFIG_MSM_AMSS_VERSION_6210 is not set
+# CONFIG_MSM_AMSS_VERSION_6220 is not set
+CONFIG_MSM_AMSS_VERSION_6225=y
+CONFIG_MSM7X00A_USE_GP_TIMER=y
+# CONFIG_MSM7X00A_USE_DG_TIMER is not set
+CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
+# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_SLEEP_MODE=0
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
+CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
+CONFIG_MSM_IDLE_STATS=y
+CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
+CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
+CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
+CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_HTC_HEADSET is not set
+# CONFIG_HTC_PWRSINK is not set
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_SERIAL_DEBUGGER is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+# CONFIG_MSM_SMD_PKG3 is not set
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_PCIE=y
+CONFIG_MSM_SMD_DEBUG=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_N_WAY_SMD=y
+CONFIG_MSM_N_WAY_SMSM=y
+CONFIG_MSM_RESET_MODEM=y
+CONFIG_MSM_SMD_LOGGING=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_MSM_SMD_NMEA=y
+CONFIG_MSM_HSIC_TTY=y
+CONFIG_MSM_SMD_TTY=y
+CONFIG_MSM_SMD_QMI=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_MSM_DSPS=y
+# CONFIG_MSM_ONCRPCROUTER is not set
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_IPC_ROUTER_SECURITY=y
+# CONFIG_MSM_DALRPC is not set
+# CONFIG_MSM_CPU_FREQ_SET_MIN_MAX is not set
+CONFIG_MSM_SLEEPER=y
+CONFIG_CPU_VOLTAGE_TABLE=y
+CONFIG_MSM_AVS_HW=y
+# CONFIG_MSM_HW3D is not set
+CONFIG_AMSS_7X25_VERSION_2009=y
+# CONFIG_AMSS_7X25_VERSION_2008 is not set
+CONFIG_RTAC=y
+# CONFIG_MSM_VREG_SWITCH_INVERTED is not set
+CONFIG_MSM_DMA_TEST=y
+# CONFIG_WIFI_CONTROL_FUNC is not set
+CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE is not set
+CONFIG_MSM_PM_TIMEOUT_HALT=y
+# CONFIG_MSM_PM_TIMEOUT_RESET_MODEM is not set
+# CONFIG_MSM_PM_TIMEOUT_RESET_CHIP is not set
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
+CONFIG_MSM_RPM_REGULATOR=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL=y
+# CONFIG_MSM_PIL_MODEM is not set
+# CONFIG_MSM_PIL_QDSP6V3 is not set
+CONFIG_MSM_PIL_QDSP6V4=y
+# CONFIG_MSM_PIL_LPASS_QDSP6V5 is not set
+# CONFIG_MSM_PIL_MSS_QDSP6V5 is not set
+CONFIG_MSM_PIL_RIVA=y
+CONFIG_MSM_PIL_TZAPPS=y
+CONFIG_MSM_PIL_DSPS=y
+CONFIG_MSM_PIL_VIDC=y
+# CONFIG_MSM_PIL_VENUS is not set
+CONFIG_MSM_PIL_GSS=y
+# CONFIG_MSM_PIL_PRONTO is not set
+CONFIG_MSM_SCM=y
+CONFIG_MSM_MODEM_8960=y
+CONFIG_MSM_LPASS_8960=y
+CONFIG_MSM_WCNSS_SSR_8960=m
+CONFIG_MSM_GSS_SSR_8064=y
+CONFIG_MSM_BUSPM_DEV=y
+CONFIG_MSM_TZ_LOG=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_IOMMU_API=y
+CONFIG_MSM_GPIOMUX=y
+CONFIG_MSM_NATIVE_RESTART=y
+CONFIG_MSM_PM8X60=y
+CONFIG_MSM_EVENT_TIMER=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED=y
+CONFIG_MSM_WATCHDOG=y
+# CONFIG_MSM_WATCHDOG_V2 is not set
+# CONFIG_MSM_MEMORY_DUMP is not set
+CONFIG_MSM_DLOAD_MODE=y
+# CONFIG_MSM_JTAG is not set
+# CONFIG_MSM_JTAG_MM is not set
+# CONFIG_MSM_SLEEP_STATS_DEVICE is not set
+CONFIG_MSM_RUN_QUEUE_STATS=y
+# CONFIG_MSM_STANDALONE_POWER_COLLAPSE is not set
+# CONFIG_MSM_GSBI9_UART is not set
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+# CONFIG_MSM_FAKE_BATTERY is not set
+CONFIG_MSM_QDSP6_APR=y
+# CONFIG_MSM_QDSP6_APRV2 is not set
+CONFIG_MSM_QDSP6_CODECS=y
+# CONFIG_MSM_QDSP6V2_CODECS is not set
+CONFIG_MSM_AUDIO_QDSP6=y
+# CONFIG_MSM_AUDIO_QDSP6V2 is not set
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_ULTRASOUND=y
+# CONFIG_MSM_SPM_V1 is not set
+CONFIG_MSM_SPM_V2=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_MSM_MULTIMEDIA_USE_ION=y
+# CONFIG_MSM_OCMEM is not set
+# CONFIG_MSM_RTB is not set
+CONFIG_MSM_EBI_ERP=y
+CONFIG_MSM_CACHE_ERP=y
+CONFIG_MSM_L1_ERR_PANIC=y
+CONFIG_MSM_L1_ERR_LOG=y
+# CONFIG_MSM_L2_ERP_PRINT_ACCESS_ERRORS is not set
+# CONFIG_MSM_L2_ERP_1BIT_PANIC is not set
+CONFIG_MSM_L2_ERP_2BIT_PANIC=y
+CONFIG_MSM_DCVS=y
+# CONFIG_MSM_CPR is not set
+CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER=y
+CONFIG_MSM_CACHE_DUMP=y
+CONFIG_MSM_CACHE_DUMP_ON_PANIC=y
+CONFIG_MSM_HSIC_SYSMON=y
+# CONFIG_MSM_HSIC_SYSMON_TEST is not set
+CONFIG_MSM_CPU_PWRCTL=y
+# CONFIG_FORCE_FAST_CHARGE is not set
+CONFIG_LCD_KCAL=y
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_ARM_NR_BANKS=8
+# CONFIG_RESERVE_FIRST_PAGE is not set
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_KSAPI is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CLEANCACHE=y
+# CONFIG_ARCH_MEMORY_PROBE is not set
+# CONFIG_ARCH_MEMORY_REMOVE is not set
+# CONFIG_ENABLE_DMM is not set
+# CONFIG_FIX_MOVABLE_ZONE is not set
+CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0=y
+# CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG is not set
+# CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE is not set
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+CONFIG_CP_ACCESS=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+CONFIG_KEXEC_HARDBOOT=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=y
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_INTELLIDEMAND is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_FREQ_MSM=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_TCP_CONG_ILLINOIS=y
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_HYBLA is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_VENO is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_REJECT_SKERR is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=y
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+CONFIG_NET_SCH_PRIO=y
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+CONFIG_NET_CLS_FLOW=y
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_IRDA=y
+
+#
+# IrDA protocols
+#
+# CONFIG_IRLAN is not set
+# CONFIG_IRNET is not set
+# CONFIG_IRCOMM is not set
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=y
+
+#
+# Dongle support
+#
+CONFIG_DONGLE=y
+# CONFIG_ESI_DONGLE is not set
+# CONFIG_ACTISYS_DONGLE is not set
+# CONFIG_TEKRAM_DONGLE is not set
+# CONFIG_TOIM3232_DONGLE is not set
+# CONFIG_LITELINK_DONGLE is not set
+CONFIG_MA600_DONGLE=y
+# CONFIG_GIRBIL_DONGLE is not set
+# CONFIG_MCP2120_DONGLE is not set
+# CONFIG_OLD_BELKIN_DONGLE is not set
+# CONFIG_ACT200L_DONGLE is not set
+# CONFIG_KINGSUN_DONGLE is not set
+# CONFIG_KSDAZZLE_DONGLE is not set
+# CONFIG_KS959_DONGLE is not set
+
+#
+# FIR device drivers
+#
+CONFIG_USB_IRDA=y
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_VLSI_FIR is not set
+# CONFIG_MCS_FIR is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCISMD=y
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+CONFIG_BT_HCIUART_ATH3K=y
+# CONFIG_BT_HCIUART_LL is not set
+CONFIG_BT_HCIUART_IBS=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_MSM_SLEEP is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_MSM_BT_POWER=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+CONFIG_LIB80211=y
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_BCM2079X=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_GENLOCK=y
+CONFIG_GENLOCK_MISCDEVICE=y
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+# CONFIG_SW_SYNC_USER is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_TSIF is not set
+# CONFIG_TSPP is not set
+# CONFIG_HAPTIC_ISA1200 is not set
+CONFIG_PMIC8XXX_VIBRATOR=y
+# CONFIG_ANDROID_VIBRATOR is not set
+# CONFIG_TOUCHSENSE_VIBRATOR is not set
+# CONFIG_PMIC8XXX_NFC is not set
+# CONFIG_PMIC8XXX_UPL is not set
+CONFIG_QSEECOM=y
+# CONFIG_QFP_FUSE is not set
+CONFIG_USB_HSIC_SMSC_HUB=y
+# CONFIG_BU52031NVX is not set
+CONFIG_UID_CPUTIME=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=y
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_SLIMPORT_ANX7808=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+CONFIG_DUMMY=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_MSM_RMNET is not set
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_MSM_RMNET_SMUX=y
+# CONFIG_QFEC is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_NE2K_PCI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_SMC91X=y
+# CONFIG_EPIC100 is not set
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_SMSC911X_ARCH_HOOKS is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=y
+CONFIG_SLHC=y
+CONFIG_SLIP_COMPRESSED=y
+# CONFIG_SLIP_SMART is not set
+CONFIG_SLIP_MODE_SLIP6=y
+# CONFIG_TR is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=y
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_USB_SIERRA_NET=y
+# CONFIG_USB_VL600 is not set
+CONFIG_MSM_RMNET_USB=y
+CONFIG_WLAN=y
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_LIBRA_SDIOIF is not set
+# CONFIG_ATH6K_LEGACY_EXT is not set
+CONFIG_WCNSS_CORE=m
+# CONFIG_ATH_COMMON is not set
+# CONFIG_BCMDHD is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+CONFIG_INPUT_LID=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+CONFIG_KEYBOARD_MATRIX=y
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_PMIC8XXX is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_QCIKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_QCITP is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+# CONFIG_TOUCHDISC_VTD518_SHINETSU is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MAXTOUCH is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_MSM_LEGACY is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_CY8C_TS is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_I2C_QC is not set
+# CONFIG_TOUCHSCREEN_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_LGE_COMMON is not set
+# CONFIG_TOUCHSCREEN_LGE_SYNAPTICS is not set
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=y
+CONFIG_WAKE_TIMEOUT=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PM8XXX_VIBRATOR is not set
+# CONFIG_INPUT_PMIC8XXX_PWRKEY is not set
+# CONFIG_INPUT_MMA8450 is not set
+CONFIG_INPUT_MPU3050=y
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_ISA1200_FF_MEMLESS is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_BOSCH_BMA150 is not set
+CONFIG_STM_LIS3DH=y
+# CONFIG_BMP18X is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+CONFIG_N_SMUX=y
+CONFIG_N_SMUX_LOOPBACK=y
+CONFIG_SMUX_CTL=y
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_FRANDOM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MSM is not set
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+# CONFIG_SERIAL_BCM_BT_LPM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_MSM_SMD is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+
+#
+# Diag Support
+#
+CONFIG_DIAG_CHAR=y
+
+#
+# DIAG traffic over USB
+#
+CONFIG_DIAG_OVER_USB=y
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC/SMUX support for DIAG
+#
+CONFIG_DIAGFWD_BRIDGE_CODE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_MSM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_MSM_ROTATOR=y
+CONFIG_MSM_ADSPRPC=y
+# CONFIG_MMC_GENERIC_CSDIO is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_MSM is not set
+CONFIG_I2C_QUP=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_QUP=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+CONFIG_SLIMBUS=y
+CONFIG_SLIMBUS_MSM_CTRL=y
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_MSM_V1 is not set
+CONFIG_GPIO_MSM_V2=y
+# CONFIG_GPIO_MSM_V3 is not set
+# CONFIG_GPIO_FSM9XXX is not set
+# CONFIG_GPIO_VX855 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+CONFIG_GPIO_SX150X=y
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_GPIO_PM8XXX=y
+CONFIG_GPIO_PM8XXX_MPP=y
+# CONFIG_GPIO_PM8XXX_RPC is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+CONFIG_CHARGER_SMB345=y
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_BATTERY_MSM is not set
+# CONFIG_BATTERY_MSM8X60 is not set
+# CONFIG_SMB137B_CHARGER is not set
+# CONFIG_SMB349_CHARGER is not set
+# CONFIG_BATTERY_BQ27520 is not set
+# CONFIG_BATTERY_BQ27541 is not set
+# CONFIG_PM8921_CHARGER is not set
+# CONFIG_PM8XXX_CCADC is not set
+# CONFIG_LTC4088_CHARGER is not set
+# CONFIG_PM8921_BMS is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_WIRELESS_CHARGER is not set
+# CONFIG_BATTERY_TEMP_CONTROL is not set
+CONFIG_BATTERY_ASUS_BQ27541=y
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+CONFIG_SENSORS_PM8XXX_ADC=y
+CONFIG_SENSORS_EPM_ADC=y
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_SENSORS_CAP1106=y
+CONFIG_CAP_SENSOR_RMNET_CTL=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+# CONFIG_THERMAL_MSM_POPMEM is not set
+# CONFIG_THERMAL_TSENS is not set
+CONFIG_THERMAL_TSENS8960=y
+# CONFIG_THERMAL_TSENS8974 is not set
+CONFIG_THERMAL_PM8XXX=y
+CONFIG_THERMAL_MONITOR=y
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_PMIC8058 is not set
+# CONFIG_PMIC8901 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MFD_PM8XXX=y
+CONFIG_MFD_PM8921_CORE=y
+CONFIG_MFD_PM8821_CORE=y
+# CONFIG_MFD_PM8018_CORE is not set
+CONFIG_MFD_PM8038_CORE=y
+CONFIG_MFD_PM8XXX_IRQ=y
+CONFIG_MFD_PM8821_IRQ=y
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_MFD_PM8XXX_DEBUG=y
+CONFIG_MFD_PM8XXX_PWM=y
+CONFIG_MFD_PM8XXX_MISC=y
+CONFIG_MFD_PM8XXX_SPK=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+CONFIG_WCD9304_CODEC=y
+CONFIG_WCD9310_CODEC=y
+# CONFIG_WCD9320_CODEC is not set
+# CONFIG_MFD_RC5T583 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_REGULATOR_PM8XXX=y
+CONFIG_REGULATOR_MSM_GPIO=y
+# CONFIG_REGULATOR_STUB is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_USER_RC_INPUT=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+CONFIG_IR_GPIO_CIR=y
+
+#
+# Qualcomm MSM Camera And Video
+#
+# CONFIG_MSM_CAMERA is not set
+# CONFIG_MSMB_CAMERA is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_VIDEOBUF2_DMA_SG=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_MSM_VCAP=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_V4L_PCI_DRIVERS=y
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_ZORAN is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_MSM_WFD=y
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+CONFIG_RADIO_IRIS=y
+# CONFIG_RADIO_IRIS_TRANSPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_STUB_POULSBO is not set
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_MSM_KGSL=y
+# CONFIG_MSM_KGSL_CFF_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_NO_IB_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_RB_HEX is not set
+CONFIG_MSM_KGSL_2D=y
+CONFIG_MSM_KGSL_DRM=y
+CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
+# CONFIG_MSM_KGSL_MMU_PAGE_FAULT is not set
+# CONFIG_MSM_KGSL_DISABLE_SHADOW_WRITES is not set
+CONFIG_MSM_KGSL_SIMPLE_GOV=y
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+CONFIG_FB_VIRTUAL=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_MSM_VIDC=y
+CONFIG_MSM_VIDC_1080P=y
+CONFIG_MSM_VIDC_VENC=y
+CONFIG_MSM_VIDC_VDEC=y
+# CONFIG_MSM_VIDC_CONTENT_PROTECTION is not set
+CONFIG_FB_MSM=y
+CONFIG_FB_MSM_BACKLIGHT=y
+# CONFIG_FB_MSM_LOGO is not set
+CONFIG_FB_MSM_LCDC_HW=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_FB_MSM_MDP_HW=y
+# CONFIG_MDP_DEBUG_FS is not set
+# CONFIG_FB_MSM_MDP22 is not set
+# CONFIG_FB_MSM_MDP30 is not set
+# CONFIG_FB_MSM_MDP31 is not set
+CONFIG_FB_MSM_MDP40=y
+# CONFIG_FB_MSM_MDSS is not set
+# CONFIG_FB_MSM_MDP_NONE is not set
+# CONFIG_FB_MSM_EBI2 is not set
+# CONFIG_FB_MSM_MDDI is not set
+CONFIG_FB_MSM_MIPI_DSI=y
+# CONFIG_FB_MSM_LCDC is not set
+# CONFIG_FB_MSM_LVDS is not set
+CONFIG_FB_MSM_OVERLAY=y
+CONFIG_FB_MSM_DTV=y
+# CONFIG_FB_MSM_EXTMDDI is not set
+# CONFIG_FB_MSM_TVOUT is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON_VGA is not set
+# CONFIG_FB_MSM_MDDI_ORISE is not set
+# CONFIG_FB_MSM_MDDI_QUICKVX is not set
+# CONFIG_FB_MSM_MDDI_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_PANEL is not set
+# CONFIG_FB_MSM_MIPI_DSI_TOSHIBA is not set
+# CONFIG_FB_MSM_MIPI_DSI_LGIT is not set
+# CONFIG_FB_MSM_MIPI_DSI_RENESAS is not set
+# CONFIG_FB_MSM_MIPI_DSI_SIMULATOR is not set
+CONFIG_FB_MSM_MIPI_DSI_NOVATEK=y
+CONFIG_FB_MSM_MIPI_DSI_LG=y
+CONFIG_FB_MSM_MIPI_DSI_JDI=y
+# CONFIG_FB_MSM_MIPI_DSI_ORISE is not set
+# CONFIG_FB_MSM_LCDC_ST15_WXGA is not set
+# CONFIG_FB_MSM_LCDC_ST15_PANEL is not set
+# CONFIG_FB_MSM_LCDC_PRISM_WVGA is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA is not set
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA is not set
+# CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335 is not set
+# CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT is not set
+# CONFIG_FB_MSM_LCDC_NT35582_WVGA is not set
+# CONFIG_FB_MSM_LCDC_WXGA is not set
+# CONFIG_FB_MSM_MIPI_LGIT_VIDEO_WXGA_PT is not set
+# CONFIG_FB_MSM_LVDS_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT is not set
+CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT=y
+CONFIG_FB_MSM_MIPI_LG_1080_HD_PT=y
+CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT=y
+# CONFIG_FB_MSM_MIPI_ORISE_VIDEO_720P_PT is not set
+# CONFIG_FB_MSM_MIPI_ORISE_CMD_720P_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35510_CMD_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35516_VIDEO_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35516_CMD_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA is not set
+# CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO is not set
+CONFIG_FB_MSM_NO_MDP_PIPE_CTRL=y
+CONFIG_FB_MSM_OVERLAY0_WRITEBACK=y
+CONFIG_FB_MSM_OVERLAY1_WRITEBACK=y
+# CONFIG_FB_MSM_WRITEBACK_MSM_PANEL is not set
+CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE=y
+CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE=y
+CONFIG_FB_MSM_MIPI_JDI_CMD_MODE=y
+CONFIG_FB_MSM_EXT_INTERFACE_COMMON=y
+CONFIG_FB_MSM_HDMI_COMMON=y
+CONFIG_FB_MSM_HDMI_3D=y
+# CONFIG_FB_MSM_HDMI_ADV7520_PANEL is not set
+CONFIG_FB_MSM_HDMI_MSM_PANEL=y
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_DVI_SUPPORT is not set
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT is not set
+# CONFIG_FB_MSM_HDMI_MHL_9244 is not set
+# CONFIG_FB_MSM_HDMI_MHL_8334 is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_M is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_J is not set
+# CONFIG_FB_MSM_TVOUT_PAL_BDGHIN is not set
+# CONFIG_FB_MSM_TVOUT_PAL_M is not set
+# CONFIG_FB_MSM_TVOUT_PAL_N is not set
+CONFIG_FB_MSM_TVOUT_NONE=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGB565 is not set
+# CONFIG_FB_MSM_DEFAULT_DEPTH_ARGB8888 is not set
+CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888 is not set
+# CONFIG_FB_MSM_EBI2_EPSON_S1D_QVGA_PANEL is not set
+# CONFIG_FB_MSM_EBI2_PANEL_DETECT is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_LM3530 is not set
+# CONFIG_BACKLIGHT_LM3533 is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+
+#
+# MSM SoC Audio support
+#
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=y
+CONFIG_SND_SOC_MSM_QDSP6_INTF=y
+# CONFIG_SND_SOC_MSM_QDSP6V2_INTF is not set
+CONFIG_SND_SOC_VOICE=y
+CONFIG_SND_SOC_QDSP6=y
+# CONFIG_SND_SOC_QDSP6V2 is not set
+CONFIG_SND_SOC_MSM8960=y
+# CONFIG_SND_SOC_DUAL_AMIC is not set
+CONFIG_ASUSTEK_HEADSET=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WCD9304=y
+CONFIG_SND_SOC_WCD9310=y
+CONFIG_SND_SOC_CS8427=y
+CONFIG_SND_SOC_MSM_STUB=y
+# CONFIG_SND_SOC_TPA2028D is not set
+CONFIG_SOUND_CONTROL_HAX_GPL=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=y
+# CONFIG_HOLTEK_FF is not set
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+CONFIG_HID_PRIMAX=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+# CONFIG_HID_WIIMOTE is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_USB_EHCI_MSM_HOST4=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_PEHCI_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_CSVT=y
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_QCOM_DIAG_BRIDGE=y
+# CONFIG_USB_QCOM_DIAG_BRIDGE_TEST is not set
+CONFIG_USB_QCOM_MDM_BRIDGE=y
+CONFIG_USB_QCOM_KS_BRIDGE=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+CONFIG_USB_GADGET_DEBUG_FILES=y
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_CI13XXX_PCI is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_LANGWELL is not set
+# CONFIG_USB_EG20T is not set
+CONFIG_USB_CI13XXX_MSM=y
+# CONFIG_USB_CI13XXX_MSM_HSIC is not set
+# CONFIG_USB_DWC3_MSM is not set
+# CONFIG_USB_MSM_72K is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_GADGET_SUPERSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+CONFIG_USB_CSW_HACK=y
+# CONFIG_USB_MSC_PROFILING is not set
+CONFIG_MODEM_SUPPORT=y
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+# CONFIG_USB_ANDROID_CDC_ECM is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_MSM_OTG_72K is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_MSM_OTG=y
+# CONFIG_USB_MSM_ACA is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_SECDISCARD is not set
+CONFIG_MMC_BLOCK_MINORS=32
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_BLOCK_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_MSM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MMC_MSM_SDC1_SUPPORT=y
+CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT=y
+# CONFIG_MMC_MSM_SDC2_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC3_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC3_POLLING is not set
+# CONFIG_MMC_MSM_SDC4_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC5_SUPPORT is not set
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_MSM_PDM is not set
+# CONFIG_LEDS_PMIC_MPP is not set
+# CONFIG_LEDS_MSM_TRICOLOR is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CPLD is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_PM8XXX=y
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_MSM_PMIC is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+# CONFIG_LEDS_TRIGGER_SLEEP is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_SWITCH_FSA8008 is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_MSM is not set
+# CONFIG_RTC_DRV_MSM7X00A is not set
+CONFIG_RTC_DRV_PM8XXX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_CIF is not set
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_AEC is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_UIO_PCI_GENERIC is not set
+# CONFIG_UIO_NETX is not set
+CONFIG_UIO_MSM_SHAREDMEM=y
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_ET131X is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS_PSTOR is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_IIO is not set
+CONFIG_QCACHE=y
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_PERSISTENT_RAM=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+# CONFIG_ANDROID_SWITCH is not set
+# CONFIG_PHONE is not set
+# CONFIG_USB_WPAN_HCD is not set
+
+#
+# Qualcomm Atheros Prima WLAN module
+#
+CONFIG_PRIMA_WLAN=m
+# CONFIG_PRIMA_WLAN_BTAMP is not set
+CONFIG_PRIMA_WLAN_LFR=y
+CONFIG_PRIMA_WLAN_OKC=y
+# CONFIG_PRIMA_WLAN_11AC_HIGH_TP is not set
+# CONFIG_QCOM_VOWIFI_11R is not set
+CONFIG_CPUPOWER=y
+
+#
+# Qualcomm MSM specific device drivers
+#
+CONFIG_MSM_SSBI=y
+CONFIG_SPS=y
+# CONFIG_USB_BAM is not set
+CONFIG_SPS_SUPPORT_BAMDMA=y
+# CONFIG_SPS_SUPPORT_NDP_BAM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_MSM_IOMMU=y
+CONFIG_MSM_IOMMU_GPU_SYNC=y
+CONFIG_IOMMU_PGTABLES_L2=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_MOBICORE_SUPPORT is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_ACL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_CPU_FREQ_SWITCH_PROFILER is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_ENCRYPTED_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_ARM=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_LZ4=y
+CONFIG_CRYPTO_LZ4HC=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_QCRYPTO is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_QCEDEV is not set
+# CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff -urN flo-ElementalX-5.00/.version flo-ElementalX-5.00-patched/.version
--- flo-ElementalX-5.00/.version	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/.version	2016-06-03 17:56:07.000000000 +0000
@@ -0,0 +1 @@
+37
diff -urN flo-ElementalX-5.00/Documentation/ABI/testing/sysfs-power flo-ElementalX-5.00-patched/Documentation/ABI/testing/sysfs-power
--- flo-ElementalX-5.00/Documentation/ABI/testing/sysfs-power	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/ABI/testing/sysfs-power	2016-05-10 02:52:00.000000000 +0000
@@ -1,174 +0,0 @@
-What:		/sys/power/
-Date:		August 2006
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power directory will contain files that will
-		provide a unified interface to the power management
-		subsystem.
-
-What:		/sys/power/state
-Date:		August 2006
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/state file controls the system power state.
-		Reading from this file returns what states are supported,
-		which is hard-coded to 'standby' (Power-On Suspend), 'mem'
-		(Suspend-to-RAM), and 'disk' (Suspend-to-Disk).
-
-		Writing to this file one of these strings causes the system to
-		transition into that state. Please see the file
-		Documentation/power/states.txt for a description of each of
-		these states.
-
-What:		/sys/power/disk
-Date:		September 2006
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/disk file controls the operating mode of the
-		suspend-to-disk mechanism.  Reading from this file returns
-		the name of the method by which the system will be put to
-		sleep on the next suspend.  There are four methods supported:
-		'firmware' - means that the memory image will be saved to disk
-		by some firmware, in which case we also assume that the
-		firmware will handle the system suspend.
-		'platform' - the memory image will be saved by the kernel and
-		the system will be put to sleep by the platform driver (e.g.
-		ACPI or other PM registers).
-		'shutdown' - the memory image will be saved by the kernel and
-		the system will be powered off.
-		'reboot' - the memory image will be saved by the kernel and
-		the system will be rebooted.
-
-		Additionally, /sys/power/disk can be used to turn on one of the
-		two testing modes of the suspend-to-disk mechanism: 'testproc'
-		or 'test'.  If the suspend-to-disk mechanism is in the
-		'testproc' mode, writing 'disk' to /sys/power/state will cause
-		the kernel to disable nonboot CPUs and freeze tasks, wait for 5
-		seconds, unfreeze tasks and enable nonboot CPUs.  If it is in
-		the 'test' mode, writing 'disk' to /sys/power/state will cause
-		the kernel to disable nonboot CPUs and freeze tasks, shrink
-		memory, suspend devices, wait for 5 seconds, resume devices,
-		unfreeze tasks and enable nonboot CPUs.  Then, we are able to
-		look in the log messages and work out, for example, which code
-		is being slow and which device drivers are misbehaving.
-
-		The suspend-to-disk method may be chosen by writing to this
-		file one of the accepted strings:
-
-		'firmware'
-		'platform'
-		'shutdown'
-		'reboot'
-		'testproc'
-		'test'
-
-		It will only change to 'firmware' or 'platform' if the system
-		supports that.
-
-What:		/sys/power/image_size
-Date:		August 2006
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/image_size file controls the size of the image
-		created by the suspend-to-disk mechanism.  It can be written a
-		string representing a non-negative integer that will be used
-		as an upper limit of the image size, in bytes.  The kernel's
-		suspend-to-disk code will do its best to ensure the image size
-		will not exceed this number.  However, if it turns out to be
-		impossible, the kernel will try to suspend anyway using the
-		smallest image possible.  In particular, if "0" is written to
-		this file, the suspend image will be as small as possible.
-
-		Reading from this file will display the current image size
-		limit, which is set to 500 MB by default.
-
-What:		/sys/power/pm_trace
-Date:		August 2006
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/pm_trace file controls the code which saves the
-		last PM event point in the RTC across reboots, so that you can
-		debug a machine that just hangs during suspend (or more
-		commonly, during resume).  Namely, the RTC is only used to save
-		the last PM event point if this file contains '1'.  Initially
-		it contains '0' which may be changed to '1' by writing a
-		string representing a nonzero integer into it.
-
-		To use this debugging feature you should attempt to suspend
-		the machine, then reboot it and run
-
-		dmesg -s 1000000 | grep 'hash matches'
-
-		If you do not get any matches (or they appear to be false
-		positives), it is possible that the last PM event point
-		referred to a device created by a loadable kernel module.  In
-		this case cat /sys/power/pm_trace_dev_match (see below) after
-		your system is started up and the kernel modules are loaded.
-
-		CAUTION: Using it will cause your machine's real-time (CMOS)
-		clock to be set to a random invalid time after a resume.
-
-What;		/sys/power/pm_trace_dev_match
-Date:		October 2010
-Contact:	James Hogan <james@albanarts.com>
-Description:
-		The /sys/power/pm_trace_dev_match file contains the name of the
-		device associated with the last PM event point saved in the RTC
-		across reboots when pm_trace has been used.  More precisely it
-		contains the list of current devices (including those
-		registered by loadable kernel modules since boot) which match
-		the device hash in the RTC at boot, with a newline after each
-		one.
-
-		The advantage of this file over the hash matches printed to the
-		kernel log (see /sys/power/pm_trace), is that it includes
-		devices created after boot by loadable kernel modules.
-
-		Due to the small hash size necessary to fit in the RTC, it is
-		possible that more than one device matches the hash, in which
-		case further investigation is required to determine which
-		device is causing the problem.  Note that genuine RTC clock
-		values (such as when pm_trace has not been used), can still
-		match a device and output it's name here.
-
-What:		/sys/power/pm_async
-Date:		January 2009
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/pm_async file controls the switch allowing the
-		user space to enable or disable asynchronous suspend and resume
-		of devices.  If enabled, this feature will cause some device
-		drivers' suspend and resume callbacks to be executed in parallel
-		with each other and with the main suspend thread.  It is enabled
-		if this file contains "1", which is the default.  It may be
-		disabled by writing "0" to this file, in which case all devices
-		will be suspended and resumed synchronously.
-
-What:		/sys/power/wakeup_count
-Date:		July 2010
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/wakeup_count file allows user space to put the
-		system into a sleep state while taking into account the
-		concurrent arrival of wakeup events.  Reading from it returns
-		the current number of registered wakeup events and it blocks if
-		some wakeup events are being processed at the time the file is
-		read from.  Writing to it will only succeed if the current
-		number of wakeup events is equal to the written value and, if
-		successful, will make the kernel abort a subsequent transition
-		to a sleep state if any wakeup events are reported after the
-		write has returned.
-
-What:		/sys/power/reserved_size
-Date:		May 2011
-Contact:	Rafael J. Wysocki <rjw@sisk.pl>
-Description:
-		The /sys/power/reserved_size file allows user space to control
-		the amount of memory reserved for allocations made by device
-		drivers during the "device freeze" stage of hibernation.  It can
-		be written a string representing a non-negative integer that
-		will be used as the amount of memory to reserve for allocations
-		made by device drivers' "freeze" callbacks, in bytes.
-
-		Reading from this file will display the current value, which is
-		set to 1 MB by default.
diff -urN flo-ElementalX-5.00/Documentation/DocBook/libata.tmpl flo-ElementalX-5.00-patched/Documentation/DocBook/libata.tmpl
--- flo-ElementalX-5.00/Documentation/DocBook/libata.tmpl	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/DocBook/libata.tmpl	2016-05-10 02:52:00.000000000 +0000
@@ -1,1625 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
-	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
-
-<book id="libataDevGuide">
- <bookinfo>
-  <title>libATA Developer's Guide</title>
-  
-  <authorgroup>
-   <author>
-    <firstname>Jeff</firstname>
-    <surname>Garzik</surname>
-   </author>
-  </authorgroup>
-
-  <copyright>
-   <year>2003-2006</year>
-   <holder>Jeff Garzik</holder>
-  </copyright>
-
-  <legalnotice>
-   <para>
-   The contents of this file are subject to the Open
-   Software License version 1.1 that can be found at
-   <ulink url="http://fedoraproject.org/wiki/Licensing:OSL1.1">http://fedoraproject.org/wiki/Licensing:OSL1.1</ulink>
-   and is included herein by reference.
-   </para>
-
-   <para>
-   Alternatively, the contents of this file may be used under the terms
-   of the GNU General Public License version 2 (the "GPL") as distributed
-   in the kernel source COPYING file, in which case the provisions of
-   the GPL are applicable instead of the above.  If you wish to allow
-   the use of your version of this file only under the terms of the
-   GPL and not to allow others to use your version of this file under
-   the OSL, indicate your decision by deleting the provisions above and
-   replace them with the notice and other provisions required by the GPL.
-   If you do not delete the provisions above, a recipient may use your
-   version of this file under either the OSL or the GPL.
-   </para>
-
-  </legalnotice>
- </bookinfo>
-
-<toc></toc>
-
-  <chapter id="libataIntroduction">
-     <title>Introduction</title>
-  <para>
-  libATA is a library used inside the Linux kernel to support ATA host
-  controllers and devices.  libATA provides an ATA driver API, class
-  transports for ATA and ATAPI devices, and SCSI&lt;-&gt;ATA translation
-  for ATA devices according to the T10 SAT specification.
-  </para>
-  <para>
-  This Guide documents the libATA driver API, library functions, library
-  internals, and a couple sample ATA low-level drivers.
-  </para>
-  </chapter>
-
-  <chapter id="libataDriverApi">
-     <title>libata Driver API</title>
-     <para>
-     struct ata_port_operations is defined for every low-level libata
-     hardware driver, and it controls how the low-level driver
-     interfaces with the ATA and SCSI layers.
-     </para>
-     <para>
-     FIS-based drivers will hook into the system with ->qc_prep() and
-     ->qc_issue() high-level hooks.  Hardware which behaves in a manner
-     similar to PCI IDE hardware may utilize several generic helpers,
-     defining at a bare minimum the bus I/O addresses of the ATA shadow
-     register blocks.
-     </para>
-     <sect1>
-        <title>struct ata_port_operations</title>
-
-	<sect2><title>Disable ATA port</title>
-	<programlisting>
-void (*port_disable) (struct ata_port *);
-	</programlisting>
-
-	<para>
-	Called from ata_bus_probe() error path, as well as when
-	unregistering from the SCSI module (rmmod, hot unplug).
-	This function should do whatever needs to be done to take the
-	port out of use.  In most cases, ata_port_disable() can be used
-	as this hook.
-	</para>
-	<para>
-	Called from ata_bus_probe() on a failed probe.
-	Called from ata_scsi_release().
-	</para>
-
-	</sect2>
-
-	<sect2><title>Post-IDENTIFY device configuration</title>
-	<programlisting>
-void (*dev_config) (struct ata_port *, struct ata_device *);
-	</programlisting>
-
-	<para>
-	Called after IDENTIFY [PACKET] DEVICE is issued to each device
-	found.  Typically used to apply device-specific fixups prior to
-	issue of SET FEATURES - XFER MODE, and prior to operation.
-	</para>
-	<para>
-	This entry may be specified as NULL in ata_port_operations.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Set PIO/DMA mode</title>
-	<programlisting>
-void (*set_piomode) (struct ata_port *, struct ata_device *);
-void (*set_dmamode) (struct ata_port *, struct ata_device *);
-void (*post_set_mode) (struct ata_port *);
-unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);
-	</programlisting>
-
-	<para>
-	Hooks called prior to the issue of SET FEATURES - XFER MODE
-	command.  The optional ->mode_filter() hook is called when libata
-	has built a mask of the possible modes. This is passed to the 
-	->mode_filter() function which should return a mask of valid modes
-	after filtering those unsuitable due to hardware limits. It is not
-	valid to use this interface to add modes.
-	</para>
-	<para>
-	dev->pio_mode and dev->dma_mode are guaranteed to be valid when
-	->set_piomode() and when ->set_dmamode() is called. The timings for
-	any other drive sharing the cable will also be valid at this point.
-	That is the library records the decisions for the modes of each
-	drive on a channel before it attempts to set any of them.
-	</para>
-	<para>
-	->post_set_mode() is
-	called unconditionally, after the SET FEATURES - XFER MODE
-	command completes successfully.
-	</para>
-
-	<para>
-	->set_piomode() is always called (if present), but
-	->set_dma_mode() is only called if DMA is possible.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Taskfile read/write</title>
-	<programlisting>
-void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
-void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
-	</programlisting>
-
-	<para>
-	->tf_load() is called to load the given taskfile into hardware
-	registers / DMA buffers.  ->tf_read() is called to read the
-	hardware registers / DMA buffers, to obtain the current set of
-	taskfile register values.
-	Most drivers for taskfile-based hardware (PIO or MMIO) use
-	ata_sff_tf_load() and ata_sff_tf_read() for these hooks.
-	</para>
-
-	</sect2>
-
-	<sect2><title>PIO data read/write</title>
-	<programlisting>
-void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
-	</programlisting>
-
-	<para>
-All bmdma-style drivers must implement this hook.  This is the low-level
-operation that actually copies the data bytes during a PIO data
-transfer.
-Typically the driver will choose one of ata_sff_data_xfer_noirq(),
-ata_sff_data_xfer(), or ata_sff_data_xfer32().
-	</para>
-
-	</sect2>
-
-	<sect2><title>ATA command execute</title>
-	<programlisting>
-void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
-	</programlisting>
-
-	<para>
-	causes an ATA command, previously loaded with
-	->tf_load(), to be initiated in hardware.
-	Most drivers for taskfile-based hardware use ata_sff_exec_command()
-	for this hook.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Per-cmd ATAPI DMA capabilities filter</title>
-	<programlisting>
-int (*check_atapi_dma) (struct ata_queued_cmd *qc);
-	</programlisting>
-
-	<para>
-Allow low-level driver to filter ATA PACKET commands, returning a status
-indicating whether or not it is OK to use DMA for the supplied PACKET
-command.
-	</para>
-	<para>
-	This hook may be specified as NULL, in which case libata will
-	assume that atapi dma can be supported.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Read specific ATA shadow registers</title>
-	<programlisting>
-u8   (*sff_check_status)(struct ata_port *ap);
-u8   (*sff_check_altstatus)(struct ata_port *ap);
-	</programlisting>
-
-	<para>
-	Reads the Status/AltStatus ATA shadow register from
-	hardware.  On some hardware, reading the Status register has
-	the side effect of clearing the interrupt condition.
-	Most drivers for taskfile-based hardware use
-	ata_sff_check_status() for this hook.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Write specific ATA shadow register</title>
-	<programlisting>
-void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);
-	</programlisting>
-
-	<para>
-	Write the device control ATA shadow register to the hardware.
-	Most drivers don't need to define this.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Select ATA device on bus</title>
-	<programlisting>
-void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
-	</programlisting>
-
-	<para>
-	Issues the low-level hardware command(s) that causes one of N
-	hardware devices to be considered 'selected' (active and
-	available for use) on the ATA bus.  This generally has no
-	meaning on FIS-based devices.
-	</para>
-	<para>
-	Most drivers for taskfile-based hardware use
-	ata_sff_dev_select() for this hook.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Private tuning method</title>
-	<programlisting>
-void (*set_mode) (struct ata_port *ap);
-	</programlisting>
-
-	<para>
-	By default libata performs drive and controller tuning in
-	accordance with the ATA timing rules and also applies blacklists
-	and cable limits. Some controllers need special handling and have
-	custom tuning rules, typically raid controllers that use ATA
-	commands but do not actually do drive timing.
-	</para>
-
-	<warning>
-	<para>
-	This hook should not be used to replace the standard controller
-	tuning logic when a controller has quirks. Replacing the default
-	tuning logic in that case would bypass handling for drive and
-	bridge quirks that may be important to data reliability. If a
-	controller needs to filter the mode selection it should use the
-	mode_filter hook instead.
-	</para>
-	</warning>
-
-	</sect2>
-
-	<sect2><title>Control PCI IDE BMDMA engine</title>
-	<programlisting>
-void (*bmdma_setup) (struct ata_queued_cmd *qc);
-void (*bmdma_start) (struct ata_queued_cmd *qc);
-void (*bmdma_stop) (struct ata_port *ap);
-u8   (*bmdma_status) (struct ata_port *ap);
-	</programlisting>
-
-	<para>
-When setting up an IDE BMDMA transaction, these hooks arm
-(->bmdma_setup), fire (->bmdma_start), and halt (->bmdma_stop)
-the hardware's DMA engine.  ->bmdma_status is used to read the standard
-PCI IDE DMA Status register.
-	</para>
-
-	<para>
-These hooks are typically either no-ops, or simply not implemented, in
-FIS-based drivers.
-	</para>
-	<para>
-Most legacy IDE drivers use ata_bmdma_setup() for the bmdma_setup()
-hook.  ata_bmdma_setup() will write the pointer to the PRD table to
-the IDE PRD Table Address register, enable DMA in the DMA Command
-register, and call exec_command() to begin the transfer.
-	</para>
-	<para>
-Most legacy IDE drivers use ata_bmdma_start() for the bmdma_start()
-hook.  ata_bmdma_start() will write the ATA_DMA_START flag to the DMA
-Command register.
-	</para>
-	<para>
-Many legacy IDE drivers use ata_bmdma_stop() for the bmdma_stop()
-hook.  ata_bmdma_stop() clears the ATA_DMA_START flag in the DMA
-command register.
-	</para>
-	<para>
-Many legacy IDE drivers use ata_bmdma_status() as the bmdma_status() hook.
-	</para>
-
-	</sect2>
-
-	<sect2><title>High-level taskfile hooks</title>
-	<programlisting>
-void (*qc_prep) (struct ata_queued_cmd *qc);
-int (*qc_issue) (struct ata_queued_cmd *qc);
-	</programlisting>
-
-	<para>
-	Higher-level hooks, these two hooks can potentially supercede
-	several of the above taskfile/DMA engine hooks.  ->qc_prep is
-	called after the buffers have been DMA-mapped, and is typically
-	used to populate the hardware's DMA scatter-gather table.
-	Most drivers use the standard ata_qc_prep() helper function, but
-	more advanced drivers roll their own.
-	</para>
-	<para>
-	->qc_issue is used to make a command active, once the hardware
-	and S/G tables have been prepared.  IDE BMDMA drivers use the
-	helper function ata_qc_issue_prot() for taskfile protocol-based
-	dispatch.  More advanced drivers implement their own ->qc_issue.
-	</para>
-	<para>
-	ata_qc_issue_prot() calls ->tf_load(), ->bmdma_setup(), and
-	->bmdma_start() as necessary to initiate a transfer.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Exception and probe handling (EH)</title>
-	<programlisting>
-void (*eng_timeout) (struct ata_port *ap);
-void (*phy_reset) (struct ata_port *ap);
-	</programlisting>
-
-	<para>
-Deprecated.  Use ->error_handler() instead.
-	</para>
-
-	<programlisting>
-void (*freeze) (struct ata_port *ap);
-void (*thaw) (struct ata_port *ap);
-	</programlisting>
-
-	<para>
-ata_port_freeze() is called when HSM violations or some other
-condition disrupts normal operation of the port.  A frozen port
-is not allowed to perform any operation until the port is
-thawed, which usually follows a successful reset.
-	</para>
-
-	<para>
-The optional ->freeze() callback can be used for freezing the port
-hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
-port cannot be frozen hardware-wise, the interrupt handler
-must ack and clear interrupts unconditionally while the port
-is frozen.
-	</para>
-	<para>
-The optional ->thaw() callback is called to perform the opposite of ->freeze():
-prepare the port for normal operation once again.  Unmask interrupts,
-start DMA engine, etc.
-	</para>
-
-	<programlisting>
-void (*error_handler) (struct ata_port *ap);
-	</programlisting>
-
-	<para>
-->error_handler() is a driver's hook into probe, hotplug, and recovery
-and other exceptional conditions.  The primary responsibility of an
-implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set
-of EH hooks as arguments:
-	</para>
-
-	<para>
-'prereset' hook (may be NULL) is called during an EH reset, before any other actions
-are taken.
-	</para>
-
-	<para>
-'postreset' hook (may be NULL) is called after the EH reset is performed.  Based on
-existing conditions, severity of the problem, and hardware capabilities,
-	</para>
-
-	<para>
-Either 'softreset' (may be NULL) or 'hardreset' (may be NULL) will be
-called to perform the low-level EH reset.
-	</para>
-
-	<programlisting>
-void (*post_internal_cmd) (struct ata_queued_cmd *qc);
-	</programlisting>
-
-	<para>
-Perform any hardware-specific actions necessary to finish processing
-after executing a probe-time or EH-time command via ata_exec_internal().
-	</para>
-
-	</sect2>
-
-	<sect2><title>Hardware interrupt handling</title>
-	<programlisting>
-irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
-void (*irq_clear) (struct ata_port *);
-	</programlisting>
-
-	<para>
-	->irq_handler is the interrupt handling routine registered with
-	the system, by libata.  ->irq_clear is called during probe just
-	before the interrupt handler is registered, to be sure hardware
-	is quiet.
-	</para>
-	<para>
-	The second argument, dev_instance, should be cast to a pointer
-	to struct ata_host_set.
-	</para>
-	<para>
-	Most legacy IDE drivers use ata_sff_interrupt() for the
-	irq_handler hook, which scans all ports in the host_set,
-	determines which queued command was active (if any), and calls
-	ata_sff_host_intr(ap,qc).
-	</para>
-	<para>
-	Most legacy IDE drivers use ata_sff_irq_clear() for the
-	irq_clear() hook, which simply clears the interrupt and error
-	flags in the DMA status register.
-	</para>
-
-	</sect2>
-
-	<sect2><title>SATA phy read/write</title>
-	<programlisting>
-int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,
-		 u32 *val);
-int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
-                   u32 val);
-	</programlisting>
-
-	<para>
-	Read and write standard SATA phy registers.  Currently only used
-	if ->phy_reset hook called the sata_phy_reset() helper function.
-	sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.
-	</para>
-
-	</sect2>
-
-	<sect2><title>Init and shutdown</title>
-	<programlisting>
-int (*port_start) (struct ata_port *ap);
-void (*port_stop) (struct ata_port *ap);
-void (*host_stop) (struct ata_host_set *host_set);
-	</programlisting>
-
-	<para>
-	->port_start() is called just after the data structures for each
-	port are initialized.  Typically this is used to alloc per-port
-	DMA buffers / tables / rings, enable DMA engines, and similar
-	tasks.  Some drivers also use this entry point as a chance to
-	allocate driver-private memory for ap->private_data.
-	</para>
-	<para>
-	Many drivers use ata_port_start() as this hook or call
-	it from their own port_start() hooks.  ata_port_start()
-	allocates space for a legacy IDE PRD table and returns.
-	</para>
-	<para>
-	->port_stop() is called after ->host_stop().  Its sole function
-	is to release DMA/memory resources, now that they are no longer
-	actively being used.  Many drivers also free driver-private
-	data from port at this time.
-	</para>
-	<para>
-	->host_stop() is called after all ->port_stop() calls
-have completed.  The hook must finalize hardware shutdown, release DMA
-and other resources, etc.
-	This hook may be specified as NULL, in which case it is not called.
-	</para>
-
-	</sect2>
-
-     </sect1>
-  </chapter>
-
-  <chapter id="libataEH">
-        <title>Error handling</title>
-
-	<para>
-	This chapter describes how errors are handled under libata.
-	Readers are advised to read SCSI EH
-	(Documentation/scsi/scsi_eh.txt) and ATA exceptions doc first.
-	</para>
-
-	<sect1><title>Origins of commands</title>
-	<para>
-	In libata, a command is represented with struct ata_queued_cmd
-	or qc.  qc's are preallocated during port initialization and
-	repetitively used for command executions.  Currently only one
-	qc is allocated per port but yet-to-be-merged NCQ branch
-	allocates one for each tag and maps each qc to NCQ tag 1-to-1.
-	</para>
-	<para>
-	libata commands can originate from two sources - libata itself
-	and SCSI midlayer.  libata internal commands are used for
-	initialization and error handling.  All normal blk requests
-	and commands for SCSI emulation are passed as SCSI commands
-	through queuecommand callback of SCSI host template.
-	</para>
-	</sect1>
-
-	<sect1><title>How commands are issued</title>
-
-	<variablelist>
-
-	<varlistentry><term>Internal commands</term>
-	<listitem>
-	<para>
-	First, qc is allocated and initialized using
-	ata_qc_new_init().  Although ata_qc_new_init() doesn't
-	implement any wait or retry mechanism when qc is not
-	available, internal commands are currently issued only during
-	initialization and error recovery, so no other command is
-	active and allocation is guaranteed to succeed.
-	</para>
-	<para>
-	Once allocated qc's taskfile is initialized for the command to
-	be executed.  qc currently has two mechanisms to notify
-	completion.  One is via qc->complete_fn() callback and the
-	other is completion qc->waiting.  qc->complete_fn() callback
-	is the asynchronous path used by normal SCSI translated
-	commands and qc->waiting is the synchronous (issuer sleeps in
-	process context) path used by internal commands.
-	</para>
-	<para>
-	Once initialization is complete, host_set lock is acquired
-	and the qc is issued.
-	</para>
-	</listitem>
-	</varlistentry>
-
-	<varlistentry><term>SCSI commands</term>
-	<listitem>
-	<para>
-	All libata drivers use ata_scsi_queuecmd() as
-	hostt->queuecommand callback.  scmds can either be simulated
-	or translated.  No qc is involved in processing a simulated
-	scmd.  The result is computed right away and the scmd is
-	completed.
-	</para>
-	<para>
-	For a translated scmd, ata_qc_new_init() is invoked to
-	allocate a qc and the scmd is translated into the qc.  SCSI
-	midlayer's completion notification function pointer is stored
-	into qc->scsidone.
-	</para>
-	<para>
-	qc->complete_fn() callback is used for completion
-	notification.  ATA commands use ata_scsi_qc_complete() while
-	ATAPI commands use atapi_qc_complete().  Both functions end up
-	calling qc->scsidone to notify upper layer when the qc is
-	finished.  After translation is completed, the qc is issued
-	with ata_qc_issue().
-	</para>
-	<para>
-	Note that SCSI midlayer invokes hostt->queuecommand while
-	holding host_set lock, so all above occur while holding
-	host_set lock.
-	</para>
-	</listitem>
-	</varlistentry>
-
-	</variablelist>
-	</sect1>
-
-	<sect1><title>How commands are processed</title>
-	<para>
-	Depending on which protocol and which controller are used,
-	commands are processed differently.  For the purpose of
-	discussion, a controller which uses taskfile interface and all
-	standard callbacks is assumed.
-	</para>
-	<para>
-	Currently 6 ATA command protocols are used.  They can be
-	sorted into the following four categories according to how
-	they are processed.
-	</para>
-
-	<variablelist>
-	   <varlistentry><term>ATA NO DATA or DMA</term>
-	   <listitem>
-	   <para>
-	   ATA_PROT_NODATA and ATA_PROT_DMA fall into this category.
-	   These types of commands don't require any software
-	   intervention once issued.  Device will raise interrupt on
-	   completion.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>ATA PIO</term>
-	   <listitem>
-	   <para>
-	   ATA_PROT_PIO is in this category.  libata currently
-	   implements PIO with polling.  ATA_NIEN bit is set to turn
-	   off interrupt and pio_task on ata_wq performs polling and
-	   IO.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>ATAPI NODATA or DMA</term>
-	   <listitem>
-	   <para>
-	   ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this
-	   category.  packet_task is used to poll BSY bit after
-	   issuing PACKET command.  Once BSY is turned off by the
-	   device, packet_task transfers CDB and hands off processing
-	   to interrupt handler.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>ATAPI PIO</term>
-	   <listitem>
-	   <para>
-	   ATA_PROT_ATAPI is in this category.  ATA_NIEN bit is set
-	   and, as in ATAPI NODATA or DMA, packet_task submits cdb.
-	   However, after submitting cdb, further processing (data
-	   transfer) is handed off to pio_task.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-	</variablelist>
-        </sect1>
-
-	<sect1><title>How commands are completed</title>
-	<para>
-	Once issued, all qc's are either completed with
-	ata_qc_complete() or time out.  For commands which are handled
-	by interrupts, ata_host_intr() invokes ata_qc_complete(), and,
-	for PIO tasks, pio_task invokes ata_qc_complete().  In error
-	cases, packet_task may also complete commands.
-	</para>
-	<para>
-	ata_qc_complete() does the following.
-	</para>
-
-	<orderedlist>
-
-	<listitem>
-	<para>
-	DMA memory is unmapped.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	ATA_QCFLAG_ACTIVE is clared from qc->flags.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	qc->complete_fn() callback is invoked.  If the return value of
-	the callback is not zero.  Completion is short circuited and
-	ata_qc_complete() returns.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	__ata_qc_complete() is called, which does
-	   <orderedlist>
-
-	   <listitem>
-	   <para>
-	   qc->flags is cleared to zero.
-	   </para>
-	   </listitem>
-
-	   <listitem>
-	   <para>
-	   ap->active_tag and qc->tag are poisoned.
-	   </para>
-	   </listitem>
-
-	   <listitem>
-	   <para>
-	   qc->waiting is claread &amp; completed (in that order).
-	   </para>
-	   </listitem>
-
-	   <listitem>
-	   <para>
-	   qc is deallocated by clearing appropriate bit in ap->qactive.
-	   </para>
-	   </listitem>
-
-	   </orderedlist>
-	</para>
-	</listitem>
-
-	</orderedlist>
-
-	<para>
-	So, it basically notifies upper layer and deallocates qc.  One
-	exception is short-circuit path in #3 which is used by
-	atapi_qc_complete().
-	</para>
-	<para>
-	For all non-ATAPI commands, whether it fails or not, almost
-	the same code path is taken and very little error handling
-	takes place.  A qc is completed with success status if it
-	succeeded, with failed status otherwise.
-	</para>
-	<para>
-	However, failed ATAPI commands require more handling as
-	REQUEST SENSE is needed to acquire sense data.  If an ATAPI
-	command fails, ata_qc_complete() is invoked with error status,
-	which in turn invokes atapi_qc_complete() via
-	qc->complete_fn() callback.
-	</para>
-	<para>
-	This makes atapi_qc_complete() set scmd->result to
-	SAM_STAT_CHECK_CONDITION, complete the scmd and return 1.  As
-	the sense data is empty but scmd->result is CHECK CONDITION,
-	SCSI midlayer will invoke EH for the scmd, and returning 1
-	makes ata_qc_complete() to return without deallocating the qc.
-	This leads us to ata_scsi_error() with partially completed qc.
-	</para>
-
-	</sect1>
-
-	<sect1><title>ata_scsi_error()</title>
-	<para>
-	ata_scsi_error() is the current transportt->eh_strategy_handler()
-	for libata.  As discussed above, this will be entered in two
-	cases - timeout and ATAPI error completion.  This function
-	calls low level libata driver's eng_timeout() callback, the
-	standard callback for which is ata_eng_timeout().  It checks
-	if a qc is active and calls ata_qc_timeout() on the qc if so.
-	Actual error handling occurs in ata_qc_timeout().
-	</para>
-	<para>
-	If EH is invoked for timeout, ata_qc_timeout() stops BMDMA and
-	completes the qc.  Note that as we're currently in EH, we
-	cannot call scsi_done.  As described in SCSI EH doc, a
-	recovered scmd should be either retried with
-	scsi_queue_insert() or finished with scsi_finish_command().
-	Here, we override qc->scsidone with scsi_finish_command() and
-	calls ata_qc_complete().
-	</para>
-	<para>
-	If EH is invoked due to a failed ATAPI qc, the qc here is
-	completed but not deallocated.  The purpose of this
-	half-completion is to use the qc as place holder to make EH
-	code reach this place.  This is a bit hackish, but it works.
-	</para>
-	<para>
-	Once control reaches here, the qc is deallocated by invoking
-	__ata_qc_complete() explicitly.  Then, internal qc for REQUEST
-	SENSE is issued.  Once sense data is acquired, scmd is
-	finished by directly invoking scsi_finish_command() on the
-	scmd.  Note that as we already have completed and deallocated
-	the qc which was associated with the scmd, we don't need
-	to/cannot call ata_qc_complete() again.
-	</para>
-
-	</sect1>
-
-	<sect1><title>Problems with the current EH</title>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	Error representation is too crude.  Currently any and all
-	error conditions are represented with ATA STATUS and ERROR
-	registers.  Errors which aren't ATA device errors are treated
-	as ATA device errors by setting ATA_ERR bit.  Better error
-	descriptor which can properly represent ATA and other
-	errors/exceptions is needed.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	When handling timeouts, no action is taken to make device
-	forget about the timed out command and ready for new commands.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	EH handling via ata_scsi_error() is not properly protected
-	from usual command processing.  On EH entrance, the device is
-	not in quiescent state.  Timed out commands may succeed or
-	fail any time.  pio_task and atapi_task may still be running.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Too weak error recovery.  Devices / controllers causing HSM
-	mismatch errors and other errors quite often require reset to
-	return to known state.  Also, advanced error handling is
-	necessary to support features like NCQ and hotplug.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	ATA errors are directly handled in the interrupt handler and
-	PIO errors in pio_task.  This is problematic for advanced
-	error handling for the following reasons.
-	</para>
-	<para>
-	First, advanced error handling often requires context and
-	internal qc execution.
-	</para>
-	<para>
-	Second, even a simple failure (say, CRC error) needs
-	information gathering and could trigger complex error handling
-	(say, resetting &amp; reconfiguring).  Having multiple code
-	paths to gather information, enter EH and trigger actions
-	makes life painful.
-	</para>
-	<para>
-	Third, scattered EH code makes implementing low level drivers
-	difficult.  Low level drivers override libata callbacks.  If
-	EH is scattered over several places, each affected callbacks
-	should perform its part of error handling.  This can be error
-	prone and painful.
-	</para>
-	</listitem>
-
-	</itemizedlist>
-	</sect1>
-  </chapter>
-
-  <chapter id="libataExt">
-     <title>libata Library</title>
-!Edrivers/ata/libata-core.c
-  </chapter>
-
-  <chapter id="libataInt">
-     <title>libata Core Internals</title>
-!Idrivers/ata/libata-core.c
-  </chapter>
-
-  <chapter id="libataScsiInt">
-     <title>libata SCSI translation/emulation</title>
-!Edrivers/ata/libata-scsi.c
-!Idrivers/ata/libata-scsi.c
-  </chapter>
-
-  <chapter id="ataExceptions">
-     <title>ATA errors and exceptions</title>
-
-  <para>
-  This chapter tries to identify what error/exception conditions exist
-  for ATA/ATAPI devices and describe how they should be handled in
-  implementation-neutral way.
-  </para>
-
-  <para>
-  The term 'error' is used to describe conditions where either an
-  explicit error condition is reported from device or a command has
-  timed out.
-  </para>
-
-  <para>
-  The term 'exception' is either used to describe exceptional
-  conditions which are not errors (say, power or hotplug events), or
-  to describe both errors and non-error exceptional conditions.  Where
-  explicit distinction between error and exception is necessary, the
-  term 'non-error exception' is used.
-  </para>
-
-  <sect1 id="excat">
-     <title>Exception categories</title>
-     <para>
-     Exceptions are described primarily with respect to legacy
-     taskfile + bus master IDE interface.  If a controller provides
-     other better mechanism for error reporting, mapping those into
-     categories described below shouldn't be difficult.
-     </para>
-
-     <para>
-     In the following sections, two recovery actions - reset and
-     reconfiguring transport - are mentioned.  These are described
-     further in <xref linkend="exrec"/>.
-     </para>
-
-     <sect2 id="excatHSMviolation">
-        <title>HSM violation</title>
-        <para>
-        This error is indicated when STATUS value doesn't match HSM
-        requirement during issuing or excution any ATA/ATAPI command.
-        </para>
-
-	<itemizedlist>
-	<title>Examples</title>
-
-        <listitem>
-	<para>
-	ATA_STATUS doesn't contain !BSY &amp;&amp; DRDY &amp;&amp; !DRQ while trying
-	to issue a command.
-        </para>
-	</listitem>
-
-        <listitem>
-	<para>
-	!BSY &amp;&amp; !DRQ during PIO data transfer.
-        </para>
-	</listitem>
-
-        <listitem>
-	<para>
-	DRQ on command completion.
-        </para>
-	</listitem>
-
-        <listitem>
-	<para>
-	!BSY &amp;&amp; ERR after CDB transfer starts but before the
-        last byte of CDB is transferred.  ATA/ATAPI standard states
-        that &quot;The device shall not terminate the PACKET command
-        with an error before the last byte of the command packet has
-        been written&quot; in the error outputs description of PACKET
-        command and the state diagram doesn't include such
-        transitions.
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	In these cases, HSM is violated and not much information
-	regarding the error can be acquired from STATUS or ERROR
-	register.  IOW, this error can be anything - driver bug,
-	faulty device, controller and/or cable.
-	</para>
-
-	<para>
-	As HSM is violated, reset is necessary to restore known state.
-	Reconfiguring transport for lower speed might be helpful too
-	as transmission errors sometimes cause this kind of errors.
-	</para>
-     </sect2>
-     
-     <sect2 id="excatDevErr">
-        <title>ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</title>
-
-	<para>
-	These are errors detected and reported by ATA/ATAPI devices
-	indicating device problems.  For this type of errors, STATUS
-	and ERROR register values are valid and describe error
-	condition.  Note that some of ATA bus errors are detected by
-	ATA/ATAPI devices and reported using the same mechanism as
-	device errors.  Those cases are described later in this
-	section.
-	</para>
-
-	<para>
-	For ATA commands, this type of errors are indicated by !BSY
-	&amp;&amp; ERR during command execution and on completion.
-	</para>
-
-	<para>For ATAPI commands,</para>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	!BSY &amp;&amp; ERR &amp;&amp; ABRT right after issuing PACKET
-	indicates that PACKET command is not supported and falls in
-	this category.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; !ABRT after the last
-	byte of CDB is transferred indicates CHECK CONDITION and
-	doesn't fall in this category.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; ABRT after the last byte
-        of CDB is transferred *probably* indicates CHECK CONDITION and
-        doesn't fall in this category.
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	Of errors detected as above, the followings are not ATA/ATAPI
-	device errors but ATA bus errors and should be handled
-	according to <xref linkend="excatATAbusErr"/>.
-	</para>
-
-	<variablelist>
-
-	   <varlistentry>
-	   <term>CRC error during data transfer</term>
-	   <listitem>
-	   <para>
-	   This is indicated by ICRC bit in the ERROR register and
-	   means that corruption occurred during data transfer.  Up to
-	   ATA/ATAPI-7, the standard specifies that this bit is only
-	   applicable to UDMA transfers but ATA/ATAPI-8 draft revision
-	   1f says that the bit may be applicable to multiword DMA and
-	   PIO.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry>
-	   <term>ABRT error during data transfer or on completion</term>
-	   <listitem>
-	   <para>
-	   Up to ATA/ATAPI-7, the standard specifies that ABRT could be
-	   set on ICRC errors and on cases where a device is not able
-	   to complete a command.  Combined with the fact that MWDMA
-	   and PIO transfer errors aren't allowed to use ICRC bit up to
-	   ATA/ATAPI-7, it seems to imply that ABRT bit alone could
-	   indicate transfer errors.
-	   </para>
-	   <para>
-	   However, ATA/ATAPI-8 draft revision 1f removes the part
-	   that ICRC errors can turn on ABRT.  So, this is kind of
-	   gray area.  Some heuristics are needed here.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	</variablelist>
-
-	<para>
-	ATA/ATAPI device errors can be further categorized as follows.
-	</para>
-
-	<variablelist>
-
-	   <varlistentry>
-	   <term>Media errors</term>
-	   <listitem>
-	   <para>
-	   This is indicated by UNC bit in the ERROR register.  ATA
-	   devices reports UNC error only after certain number of
-	   retries cannot recover the data, so there's nothing much
-	   else to do other than notifying upper layer.
-	   </para>
-	   <para>
-	   READ and WRITE commands report CHS or LBA of the first
-	   failed sector but ATA/ATAPI standard specifies that the
-	   amount of transferred data on error completion is
-	   indeterminate, so we cannot assume that sectors preceding
-	   the failed sector have been transferred and thus cannot
-	   complete those sectors successfully as SCSI does.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry>
-	   <term>Media changed / media change requested error</term>
-	   <listitem>
-	   <para>
-	   &lt;&lt;TODO: fill here&gt;&gt;
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>Address error</term>
-	   <listitem>
-	   <para>
-	   This is indicated by IDNF bit in the ERROR register.
-	   Report to upper layer.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>Other errors</term>
-	   <listitem>
-	   <para>
-	   This can be invalid command or parameter indicated by ABRT
-	   ERROR bit or some other error condition.  Note that ABRT
-	   bit can indicate a lot of things including ICRC and Address
-	   errors.  Heuristics needed.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	</variablelist>
-
-	<para>
-	Depending on commands, not all STATUS/ERROR bits are
-	applicable.  These non-applicable bits are marked with
-	&quot;na&quot; in the output descriptions but up to ATA/ATAPI-7
-	no definition of &quot;na&quot; can be found.  However,
-	ATA/ATAPI-8 draft revision 1f describes &quot;N/A&quot; as
-	follows.
-	</para>
-
-	<blockquote>
-	<variablelist>
-	   <varlistentry><term>3.2.3.3a N/A</term>
-	   <listitem>
-	   <para>
-	   A keyword the indicates a field has no defined value in
-	   this standard and should not be checked by the host or
-	   device. N/A fields should be cleared to zero.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-	</variablelist>
-	</blockquote>
-
-	<para>
-	So, it seems reasonable to assume that &quot;na&quot; bits are
-	cleared to zero by devices and thus need no explicit masking.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatATAPIcc">
-        <title>ATAPI device CHECK CONDITION</title>
-
-	<para>
-	ATAPI device CHECK CONDITION error is indicated by set CHK bit
-	(ERR bit) in the STATUS register after the last byte of CDB is
-	transferred for a PACKET command.  For this kind of errors,
-	sense data should be acquired to gather information regarding
-	the errors.  REQUEST SENSE packet command should be used to
-	acquire sense data.
-	</para>
-
-	<para>
-	Once sense data is acquired, this type of errors can be
-	handled similary to other SCSI errors.  Note that sense data
-	may indicate ATA bus error (e.g. Sense Key 04h HARDWARE ERROR
-	&amp;&amp; ASC/ASCQ 47h/00h SCSI PARITY ERROR).  In such
-	cases, the error should be considered as an ATA bus error and
-	handled according to <xref linkend="excatATAbusErr"/>.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatNCQerr">
-        <title>ATA device error (NCQ)</title>
-
-	<para>
-	NCQ command error is indicated by cleared BSY and set ERR bit
-	during NCQ command phase (one or more NCQ commands
-	outstanding).  Although STATUS and ERROR registers will
-	contain valid values describing the error, READ LOG EXT is
-	required to clear the error condition, determine which command
-	has failed and acquire more information.
-	</para>
-
-	<para>
-	READ LOG EXT Log Page 10h reports which tag has failed and
-	taskfile register values describing the error.  With this
-	information the failed command can be handled as a normal ATA
-	command error as in <xref linkend="excatDevErr"/> and all
-	other in-flight commands must be retried.  Note that this
-	retry should not be counted - it's likely that commands
-	retried this way would have completed normally if it were not
-	for the failed command.
-	</para>
-
-	<para>
-	Note that ATA bus errors can be reported as ATA device NCQ
-	errors.  This should be handled as described in <xref
-	linkend="excatATAbusErr"/>.
-	</para>
-
-	<para>
-	If READ LOG EXT Log Page 10h fails or reports NQ, we're
-	thoroughly screwed.  This condition should be treated
-	according to <xref linkend="excatHSMviolation"/>.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatATAbusErr">
-        <title>ATA bus error</title>
-
-	<para>
-	ATA bus error means that data corruption occurred during
-	transmission over ATA bus (SATA or PATA).  This type of errors
-	can be indicated by
-	</para>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	ICRC or ABRT error as described in <xref linkend="excatDevErr"/>.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Controller-specific error completion with error information
-	indicating transmission error.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	On some controllers, command timeout.  In this case, there may
-	be a mechanism to determine that the timeout is due to
-	transmission error.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Unknown/random errors, timeouts and all sorts of weirdities.
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	As described above, transmission errors can cause wide variety
-	of symptoms ranging from device ICRC error to random device
-	lockup, and, for many cases, there is no way to tell if an
-	error condition is due to transmission error or not;
-	therefore, it's necessary to employ some kind of heuristic
-	when dealing with errors and timeouts.  For example,
-	encountering repetitive ABRT errors for known supported
-	command is likely to indicate ATA bus error.
-	</para>
-
-	<para>
-	Once it's determined that ATA bus errors have possibly
-	occurred, lowering ATA bus transmission speed is one of
-	actions which may alleviate the problem.  See <xref
-	linkend="exrecReconf"/> for more information.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatPCIbusErr">
-        <title>PCI bus error</title>
-
-	<para>
-	Data corruption or other failures during transmission over PCI
-	(or other system bus).  For standard BMDMA, this is indicated
-	by Error bit in the BMDMA Status register.  This type of
-	errors must be logged as it indicates something is very wrong
-	with the system.  Resetting host controller is recommended.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatLateCompletion">
-        <title>Late completion</title>
-
-	<para>
-	This occurs when timeout occurs and the timeout handler finds
-	out that the timed out command has completed successfully or
-	with error.  This is usually caused by lost interrupts.  This
-	type of errors must be logged.  Resetting host controller is
-	recommended.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatUnknown">
-        <title>Unknown error (timeout)</title>
-
-	<para>
-	This is when timeout occurs and the command is still
-	processing or the host and device are in unknown state.  When
-	this occurs, HSM could be in any valid or invalid state.  To
-	bring the device to known state and make it forget about the
-	timed out command, resetting is necessary.  The timed out
-	command may be retried.
-	</para>
-
-	<para>
-	Timeouts can also be caused by transmission errors.  Refer to
-	<xref linkend="excatATAbusErr"/> for more details.
-	</para>
-
-     </sect2>
-
-     <sect2 id="excatHoplugPM">
-        <title>Hotplug and power management exceptions</title>
-
-	<para>
-	&lt;&lt;TODO: fill here&gt;&gt;
-	</para>
-
-     </sect2>
-
-  </sect1>
-
-  <sect1 id="exrec">
-     <title>EH recovery actions</title>
-
-     <para>
-     This section discusses several important recovery actions.
-     </para>
-
-     <sect2 id="exrecClr">
-        <title>Clearing error condition</title>
-
-	<para>
-	Many controllers require its error registers to be cleared by
-	error handler.  Different controllers may have different
-	requirements.
-	</para>
-
-	<para>
-	For SATA, it's strongly recommended to clear at least SError
-	register during error handling.
-	</para>
-     </sect2>
-
-     <sect2 id="exrecRst">
-        <title>Reset</title>
-
-	<para>
-	During EH, resetting is necessary in the following cases.
-	</para>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	HSM is in unknown or invalid state
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	HBA is in unknown or invalid state
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	EH needs to make HBA/device forget about in-flight commands
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	HBA/device behaves weirdly
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	Resetting during EH might be a good idea regardless of error
-	condition to improve EH robustness.  Whether to reset both or
-	either one of HBA and device depends on situation but the
-	following scheme is recommended.
-	</para>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	When it's known that HBA is in ready state but ATA/ATAPI
-	device is in unknown state, reset only device.
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	If HBA is in unknown state, reset both HBA and device.
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	HBA resetting is implementation specific.  For a controller
-	complying to taskfile/BMDMA PCI IDE, stopping active DMA
-	transaction may be sufficient iff BMDMA state is the only HBA
-	context.  But even mostly taskfile/BMDMA PCI IDE complying
-	controllers may have implementation specific requirements and
-	mechanism to reset themselves.  This must be addressed by
-	specific drivers.
-	</para>
-
-	<para>
-	OTOH, ATA/ATAPI standard describes in detail ways to reset
-	ATA/ATAPI devices.
-	</para>
-
-	<variablelist>
-
-	   <varlistentry><term>PATA hardware reset</term>
-	   <listitem>
-	   <para>
-	   This is hardware initiated device reset signalled with
-	   asserted PATA RESET- signal.  There is no standard way to
-	   initiate hardware reset from software although some
-	   hardware provides registers that allow driver to directly
-	   tweak the RESET- signal.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>Software reset</term>
-	   <listitem>
-	   <para>
-	   This is achieved by turning CONTROL SRST bit on for at
-	   least 5us.  Both PATA and SATA support it but, in case of
-	   SATA, this may require controller-specific support as the
-	   second Register FIS to clear SRST should be transmitted
-	   while BSY bit is still set.  Note that on PATA, this resets
-	   both master and slave devices on a channel.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>EXECUTE DEVICE DIAGNOSTIC command</term>
-	   <listitem>
-	   <para>
-	   Although ATA/ATAPI standard doesn't describe exactly, EDD
-	   implies some level of resetting, possibly similar level
-	   with software reset.  Host-side EDD protocol can be handled
-	   with normal command processing and most SATA controllers
-	   should be able to handle EDD's just like other commands.
-	   As in software reset, EDD affects both devices on a PATA
-	   bus.
-	   </para>
-	   <para>
-	   Although EDD does reset devices, this doesn't suit error
-	   handling as EDD cannot be issued while BSY is set and it's
-	   unclear how it will act when device is in unknown/weird
-	   state.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>ATAPI DEVICE RESET command</term>
-	   <listitem>
-	   <para>
-	   This is very similar to software reset except that reset
-	   can be restricted to the selected device without affecting
-	   the other device sharing the cable.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	   <varlistentry><term>SATA phy reset</term>
-	   <listitem>
-	   <para>
-	   This is the preferred way of resetting a SATA device.  In
-	   effect, it's identical to PATA hardware reset.  Note that
-	   this can be done with the standard SCR Control register.
-	   As such, it's usually easier to implement than software
-	   reset.
-	   </para>
-	   </listitem>
-	   </varlistentry>
-
-	</variablelist>
-
-	<para>
-	One more thing to consider when resetting devices is that
-	resetting clears certain configuration parameters and they
-	need to be set to their previous or newly adjusted values
-	after reset.
-	</para>
-
-	<para>
-	Parameters affected are.
-	</para>
-
-	<itemizedlist>
-
-	<listitem>
-	<para>
-	CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Parameters set with SET FEATURES including transfer mode setting
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Block count set with SET MULTIPLE MODE
-	</para>
-	</listitem>
-
-	<listitem>
-	<para>
-	Other parameters (SET MAX, MEDIA LOCK...)
-	</para>
-	</listitem>
-
-	</itemizedlist>
-
-	<para>
-	ATA/ATAPI standard specifies that some parameters must be
-	maintained across hardware or software reset, but doesn't
-	strictly specify all of them.  Always reconfiguring needed
-	parameters after reset is required for robustness.  Note that
-	this also applies when resuming from deep sleep (power-off).
-	</para>
-
-	<para>
-	Also, ATA/ATAPI standard requires that IDENTIFY DEVICE /
-	IDENTIFY PACKET DEVICE is issued after any configuration
-	parameter is updated or a hardware reset and the result used
-	for further operation.  OS driver is required to implement
-	revalidation mechanism to support this.
-	</para>
-
-     </sect2>
-
-     <sect2 id="exrecReconf">
-        <title>Reconfigure transport</title>
-
-	<para>
-	For both PATA and SATA, a lot of corners are cut for cheap
-	connectors, cables or controllers and it's quite common to see
-	high transmission error rate.  This can be mitigated by
-	lowering transmission speed.
-	</para>
-
-	<para>
-	The following is a possible scheme Jeff Garzik suggested.
-	</para>
-
-	<blockquote>
-	<para>
-	If more than $N (3?) transmission errors happen in 15 minutes,
-	</para>	
-	<itemizedlist>
-	<listitem>
-	<para>
-	if SATA, decrease SATA PHY speed.  if speed cannot be decreased,
-	</para>
-	</listitem>
-	<listitem>
-	<para>
-	decrease UDMA xfer speed.  if at UDMA0, switch to PIO4,
-	</para>
-	</listitem>
-	<listitem>
-	<para>
-	decrease PIO xfer speed.  if at PIO3, complain, but continue
-	</para>
-	</listitem>
-	</itemizedlist>
-	</blockquote>
-
-     </sect2>
-
-  </sect1>
-
-  </chapter>
-
-  <chapter id="PiixInt">
-     <title>ata_piix Internals</title>
-!Idrivers/ata/ata_piix.c
-  </chapter>
-
-  <chapter id="SILInt">
-     <title>sata_sil Internals</title>
-!Idrivers/ata/sata_sil.c
-  </chapter>
-
-  <chapter id="libataThanks">
-     <title>Thanks</title>
-  <para>
-  The bulk of the ATA knowledge comes thanks to long conversations with
-  Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA
-  and SCSI specifications.
-  </para>
-  <para>
-  Thanks to Alan Cox for pointing out similarities 
-  between SATA and SCSI, and in general for motivation to hack on
-  libata.
-  </para>
-  <para>
-  libata's device detection
-  method, ata_pio_devchk, and in general all the early probing was
-  based on extensive study of Hale Landis's probe/reset code in his
-  ATADRVR driver (www.ata-atapi.com).
-  </para>
-  </chapter>
-
-</book>
diff -urN flo-ElementalX-5.00/Documentation/DocBook/media/v4l/func-poll.xml flo-ElementalX-5.00-patched/Documentation/DocBook/media/v4l/func-poll.xml
--- flo-ElementalX-5.00/Documentation/DocBook/media/v4l/func-poll.xml	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/DocBook/media/v4l/func-poll.xml	2016-05-10 02:52:00.000000000 +0000
@@ -1,119 +0,0 @@
-<refentry id="func-poll">
-  <refmeta>
-    <refentrytitle>V4L2 poll()</refentrytitle>
-    &manvol;
-  </refmeta>
-
-  <refnamediv>
-    <refname>v4l2-poll</refname>
-    <refpurpose>Wait for some event on a file descriptor</refpurpose>
-  </refnamediv>
-
-  <refsynopsisdiv>
-    <funcsynopsis>
-      <funcsynopsisinfo>#include &lt;sys/poll.h&gt;</funcsynopsisinfo>
-      <funcprototype>
-	<funcdef>int <function>poll</function></funcdef>
-	<paramdef>struct pollfd *<parameter>ufds</parameter></paramdef>
-	<paramdef>unsigned int <parameter>nfds</parameter></paramdef>
-	<paramdef>int <parameter>timeout</parameter></paramdef>
-      </funcprototype>
-    </funcsynopsis>
-  </refsynopsisdiv>
-
-  <refsect1>
-    <title>Description</title>
-
-    <para>With the <function>poll()</function> function applications
-can suspend execution until the driver has captured data or is ready
-to accept data for output.</para>
-
-    <para>When streaming I/O has been negotiated this function waits
-until a buffer has been filled or displayed and can be dequeued with
-the &VIDIOC-DQBUF; ioctl. When buffers are already in the outgoing
-queue of the driver the function returns immediately.</para>
-
-    <para>On success <function>poll()</function> returns the number of
-file descriptors that have been selected (that is, file descriptors
-for which the <structfield>revents</structfield> field of the
-respective <structname>pollfd</structname> structure is non-zero).
-Capture devices set the <constant>POLLIN</constant> and
-<constant>POLLRDNORM</constant> flags in the
-<structfield>revents</structfield> field, output devices the
-<constant>POLLOUT</constant> and <constant>POLLWRNORM</constant>
-flags. When the function timed out it returns a value of zero, on
-failure it returns <returnvalue>-1</returnvalue> and the
-<varname>errno</varname> variable is set appropriately. When the
-application did not call &VIDIOC-QBUF; or &VIDIOC-STREAMON; yet the
-<function>poll()</function> function succeeds, but sets the
-<constant>POLLERR</constant> flag in the
-<structfield>revents</structfield> field.</para>
-
-    <para>When use of the <function>read()</function> function has
-been negotiated and the driver does not capture yet, the
-<function>poll</function> function starts capturing. When that fails
-it returns a <constant>POLLERR</constant> as above. Otherwise it waits
-until data has been captured and can be read. When the driver captures
-continuously (as opposed to, for example, still images) the function
-may return immediately.</para>
-
-    <para>When use of the <function>write()</function> function has
-been negotiated the <function>poll</function> function just waits
-until the driver is ready for a non-blocking
-<function>write()</function> call.</para>
-
-    <para>All drivers implementing the <function>read()</function> or
-<function>write()</function> function or streaming I/O must also
-support the <function>poll()</function> function.</para>
-
-    <para>For more details see the
-<function>poll()</function> manual page.</para>
-  </refsect1>
-
-  <refsect1>
-    <title>Return Value</title>
-
-    <para>On success, <function>poll()</function> returns the number
-structures which have non-zero <structfield>revents</structfield>
-fields, or zero if the call timed out. On error
-<returnvalue>-1</returnvalue> is returned, and the
-<varname>errno</varname> variable is set appropriately:</para>
-
-    <variablelist>
-      <varlistentry>
-	<term><errorcode>EBADF</errorcode></term>
-	<listitem>
-	  <para>One or more of the <parameter>ufds</parameter> members
-specify an invalid file descriptor.</para>
-	</listitem>
-      </varlistentry>
-      <varlistentry>
-	<term><errorcode>EBUSY</errorcode></term>
-	<listitem>
-	  <para>The driver does not support multiple read or write
-streams and the device is already in use.</para>
-	</listitem>
-      </varlistentry>
-      <varlistentry>
-	<term><errorcode>EFAULT</errorcode></term>
-	<listitem>
-	  <para><parameter>ufds</parameter> references an inaccessible
-memory area.</para>
-	</listitem>
-      </varlistentry>
-      <varlistentry>
-	<term><errorcode>EINTR</errorcode></term>
-	<listitem>
-	  <para>The call was interrupted by a signal.</para>
-	</listitem>
-      </varlistentry>
-      <varlistentry>
-	<term><errorcode>EINVAL</errorcode></term>
-	<listitem>
-	  <para>The <parameter>nfds</parameter> argument is greater
-than <constant>OPEN_MAX</constant>.</para>
-	</listitem>
-      </varlistentry>
-    </variablelist>
-  </refsect1>
-</refentry>
diff -urN flo-ElementalX-5.00/Documentation/IPMI.txt flo-ElementalX-5.00-patched/Documentation/IPMI.txt
--- flo-ElementalX-5.00/Documentation/IPMI.txt	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/IPMI.txt	2016-05-10 02:52:00.000000000 +0000
@@ -1,704 +0,0 @@
-
-                          The Linux IPMI Driver
-			  ---------------------
-			      Corey Minyard
-			  <minyard@mvista.com>
-			    <minyard@acm.org>
-
-The Intelligent Platform Management Interface, or IPMI, is a
-standard for controlling intelligent devices that monitor a system.
-It provides for dynamic discovery of sensors in the system and the
-ability to monitor the sensors and be informed when the sensor's
-values change or go outside certain boundaries.  It also has a
-standardized database for field-replaceable units (FRUs) and a watchdog
-timer.
-
-To use this, you need an interface to an IPMI controller in your
-system (called a Baseboard Management Controller, or BMC) and
-management software that can use the IPMI system.
-
-This document describes how to use the IPMI driver for Linux.  If you
-are not familiar with IPMI itself, see the web site at
-http://www.intel.com/design/servers/ipmi/index.htm.  IPMI is a big
-subject and I can't cover it all here!
-
-Configuration
--------------
-
-The Linux IPMI driver is modular, which means you have to pick several
-things to have it work right depending on your hardware.  Most of
-these are available in the 'Character Devices' menu then the IPMI
-menu.
-
-No matter what, you must pick 'IPMI top-level message handler' to use
-IPMI.  What you do beyond that depends on your needs and hardware.
-
-The message handler does not provide any user-level interfaces.
-Kernel code (like the watchdog) can still use it.  If you need access
-from userland, you need to select 'Device interface for IPMI' if you
-want access through a device driver.
-
-The driver interface depends on your hardware.  If your system
-properly provides the SMBIOS info for IPMI, the driver will detect it
-and just work.  If you have a board with a standard interface (These
-will generally be either "KCS", "SMIC", or "BT", consult your hardware
-manual), choose the 'IPMI SI handler' option.  A driver also exists
-for direct I2C access to the IPMI management controller.  Some boards
-support this, but it is unknown if it will work on every board.  For
-this, choose 'IPMI SMBus handler', but be ready to try to do some
-figuring to see if it will work on your system if the SMBIOS/APCI
-information is wrong or not present.  It is fairly safe to have both
-these enabled and let the drivers auto-detect what is present.
-
-You should generally enable ACPI on your system, as systems with IPMI
-can have ACPI tables describing them.
-
-If you have a standard interface and the board manufacturer has done
-their job correctly, the IPMI controller should be automatically
-detected (via ACPI or SMBIOS tables) and should just work.  Sadly,
-many boards do not have this information.  The driver attempts
-standard defaults, but they may not work.  If you fall into this
-situation, you need to read the section below named 'The SI Driver' or
-"The SMBus Driver" on how to hand-configure your system.
-
-IPMI defines a standard watchdog timer.  You can enable this with the
-'IPMI Watchdog Timer' config option.  If you compile the driver into
-the kernel, then via a kernel command-line option you can have the
-watchdog timer start as soon as it initializes.  It also have a lot
-of other options, see the 'Watchdog' section below for more details.
-Note that you can also have the watchdog continue to run if it is
-closed (by default it is disabled on close).  Go into the 'Watchdog
-Cards' menu, enable 'Watchdog Timer Support', and enable the option
-'Disable watchdog shutdown on close'.
-
-IPMI systems can often be powered off using IPMI commands.  Select
-'IPMI Poweroff' to do this.  The driver will auto-detect if the system
-can be powered off by IPMI.  It is safe to enable this even if your
-system doesn't support this option.  This works on ATCA systems, the
-Radisys CPI1 card, and any IPMI system that supports standard chassis
-management commands.
-
-If you want the driver to put an event into the event log on a panic,
-enable the 'Generate a panic event to all BMCs on a panic' option.  If
-you want the whole panic string put into the event log using OEM
-events, enable the 'Generate OEM events containing the panic string'
-option.
-
-Basic Design
-------------
-
-The Linux IPMI driver is designed to be very modular and flexible, you
-only need to take the pieces you need and you can use it in many
-different ways.  Because of that, it's broken into many chunks of
-code.  These chunks (by module name) are:
-
-ipmi_msghandler - This is the central piece of software for the IPMI
-system.  It handles all messages, message timing, and responses.  The
-IPMI users tie into this, and the IPMI physical interfaces (called
-System Management Interfaces, or SMIs) also tie in here.  This
-provides the kernelland interface for IPMI, but does not provide an
-interface for use by application processes.
-
-ipmi_devintf - This provides a userland IOCTL interface for the IPMI
-driver, each open file for this device ties in to the message handler
-as an IPMI user.
-
-ipmi_si - A driver for various system interfaces.  This supports KCS,
-SMIC, and BT interfaces.  Unless you have an SMBus interface or your
-own custom interface, you probably need to use this.
-
-ipmi_smb - A driver for accessing BMCs on the SMBus. It uses the
-I2C kernel driver's SMBus interfaces to send and receive IPMI messages
-over the SMBus.
-
-ipmi_watchdog - IPMI requires systems to have a very capable watchdog
-timer.  This driver implements the standard Linux watchdog timer
-interface on top of the IPMI message handler.
-
-ipmi_poweroff - Some systems support the ability to be turned off via
-IPMI commands.
-
-These are all individually selectable via configuration options.
-
-Note that the KCS-only interface has been removed.  The af_ipmi driver
-is no longer supported and has been removed because it was impossible
-to do 32 bit emulation on 64-bit kernels with it.
-
-Much documentation for the interface is in the include files.  The
-IPMI include files are:
-
-net/af_ipmi.h - Contains the socket interface.
-
-linux/ipmi.h - Contains the user interface and IOCTL interface for IPMI.
-
-linux/ipmi_smi.h - Contains the interface for system management interfaces
-(things that interface to IPMI controllers) to use.
-
-linux/ipmi_msgdefs.h - General definitions for base IPMI messaging.
-
-
-Addressing
-----------
-
-The IPMI addressing works much like IP addresses, you have an overlay
-to handle the different address types.  The overlay is:
-
-  struct ipmi_addr
-  {
-	int   addr_type;
-	short channel;
-	char  data[IPMI_MAX_ADDR_SIZE];
-  };
-
-The addr_type determines what the address really is.  The driver
-currently understands two different types of addresses.
-
-"System Interface" addresses are defined as:
-
-  struct ipmi_system_interface_addr
-  {
-	int   addr_type;
-	short channel;
-  };
-
-and the type is IPMI_SYSTEM_INTERFACE_ADDR_TYPE.  This is used for talking
-straight to the BMC on the current card.  The channel must be
-IPMI_BMC_CHANNEL.
-
-Messages that are destined to go out on the IPMB bus use the
-IPMI_IPMB_ADDR_TYPE address type.  The format is
-
-  struct ipmi_ipmb_addr
-  {
-	int           addr_type;
-	short         channel;
-	unsigned char slave_addr;
-	unsigned char lun;
-  };
-
-The "channel" here is generally zero, but some devices support more
-than one channel, it corresponds to the channel as defined in the IPMI
-spec.
-
-
-Messages
---------
-
-Messages are defined as:
-
-struct ipmi_msg
-{
-	unsigned char netfn;
-	unsigned char lun;
-	unsigned char cmd;
-	unsigned char *data;
-	int           data_len;
-};
-
-The driver takes care of adding/stripping the header information.  The
-data portion is just the data to be send (do NOT put addressing info
-here) or the response.  Note that the completion code of a response is
-the first item in "data", it is not stripped out because that is how
-all the messages are defined in the spec (and thus makes counting the
-offsets a little easier :-).
-
-When using the IOCTL interface from userland, you must provide a block
-of data for "data", fill it, and set data_len to the length of the
-block of data, even when receiving messages.  Otherwise the driver
-will have no place to put the message.
-
-Messages coming up from the message handler in kernelland will come in
-as:
-
-  struct ipmi_recv_msg
-  {
-	struct list_head link;
-
-	/* The type of message as defined in the "Receive Types"
-           defines above. */
-	int         recv_type;
-
-	ipmi_user_t      *user;
-	struct ipmi_addr addr;
-	long             msgid;
-	struct ipmi_msg  msg;
-
-	/* Call this when done with the message.  It will presumably free
-	   the message and do any other necessary cleanup. */
-	void (*done)(struct ipmi_recv_msg *msg);
-
-	/* Place-holder for the data, don't make any assumptions about
-	   the size or existence of this, since it may change. */
-	unsigned char   msg_data[IPMI_MAX_MSG_LENGTH];
-  };
-
-You should look at the receive type and handle the message
-appropriately.
-
-
-The Upper Layer Interface (Message Handler)
--------------------------------------------
-
-The upper layer of the interface provides the users with a consistent
-view of the IPMI interfaces.  It allows multiple SMI interfaces to be
-addressed (because some boards actually have multiple BMCs on them)
-and the user should not have to care what type of SMI is below them.
-
-
-Creating the User
-
-To user the message handler, you must first create a user using
-ipmi_create_user.  The interface number specifies which SMI you want
-to connect to, and you must supply callback functions to be called
-when data comes in.  The callback function can run at interrupt level,
-so be careful using the callbacks.  This also allows to you pass in a
-piece of data, the handler_data, that will be passed back to you on
-all calls.
-
-Once you are done, call ipmi_destroy_user() to get rid of the user.
-
-From userland, opening the device automatically creates a user, and
-closing the device automatically destroys the user.
-
-
-Messaging
-
-To send a message from kernel-land, the ipmi_request() call does
-pretty much all message handling.  Most of the parameter are
-self-explanatory.  However, it takes a "msgid" parameter.  This is NOT
-the sequence number of messages.  It is simply a long value that is
-passed back when the response for the message is returned.  You may
-use it for anything you like.
-
-Responses come back in the function pointed to by the ipmi_recv_hndl
-field of the "handler" that you passed in to ipmi_create_user().
-Remember again, these may be running at interrupt level.  Remember to
-look at the receive type, too.
-
-From userland, you fill out an ipmi_req_t structure and use the
-IPMICTL_SEND_COMMAND ioctl.  For incoming stuff, you can use select()
-or poll() to wait for messages to come in.  However, you cannot use
-read() to get them, you must call the IPMICTL_RECEIVE_MSG with the
-ipmi_recv_t structure to actually get the message.  Remember that you
-must supply a pointer to a block of data in the msg.data field, and
-you must fill in the msg.data_len field with the size of the data.
-This gives the receiver a place to actually put the message.
-
-If the message cannot fit into the data you provide, you will get an
-EMSGSIZE error and the driver will leave the data in the receive
-queue.  If you want to get it and have it truncate the message, us
-the IPMICTL_RECEIVE_MSG_TRUNC ioctl.
-
-When you send a command (which is defined by the lowest-order bit of
-the netfn per the IPMI spec) on the IPMB bus, the driver will
-automatically assign the sequence number to the command and save the
-command.  If the response is not receive in the IPMI-specified 5
-seconds, it will generate a response automatically saying the command
-timed out.  If an unsolicited response comes in (if it was after 5
-seconds, for instance), that response will be ignored.
-
-In kernelland, after you receive a message and are done with it, you
-MUST call ipmi_free_recv_msg() on it, or you will leak messages.  Note
-that you should NEVER mess with the "done" field of a message, that is
-required to properly clean up the message.
-
-Note that when sending, there is an ipmi_request_supply_msgs() call
-that lets you supply the smi and receive message.  This is useful for
-pieces of code that need to work even if the system is out of buffers
-(the watchdog timer uses this, for instance).  You supply your own
-buffer and own free routines.  This is not recommended for normal use,
-though, since it is tricky to manage your own buffers.
-
-
-Events and Incoming Commands
-
-The driver takes care of polling for IPMI events and receiving
-commands (commands are messages that are not responses, they are
-commands that other things on the IPMB bus have sent you).  To receive
-these, you must register for them, they will not automatically be sent
-to you.
-
-To receive events, you must call ipmi_set_gets_events() and set the
-"val" to non-zero.  Any events that have been received by the driver
-since startup will immediately be delivered to the first user that
-registers for events.  After that, if multiple users are registered
-for events, they will all receive all events that come in.
-
-For receiving commands, you have to individually register commands you
-want to receive.  Call ipmi_register_for_cmd() and supply the netfn
-and command name for each command you want to receive.  You also
-specify a bitmask of the channels you want to receive the command from
-(or use IPMI_CHAN_ALL for all channels if you don't care).  Only one
-user may be registered for each netfn/cmd/channel, but different users
-may register for different commands, or the same command if the
-channel bitmasks do not overlap.
-
-From userland, equivalent IOCTLs are provided to do these functions.
-
-
-The Lower Layer (SMI) Interface
--------------------------------
-
-As mentioned before, multiple SMI interfaces may be registered to the
-message handler, each of these is assigned an interface number when
-they register with the message handler.  They are generally assigned
-in the order they register, although if an SMI unregisters and then
-another one registers, all bets are off.
-
-The ipmi_smi.h defines the interface for management interfaces, see
-that for more details.
-
-
-The SI Driver
--------------
-
-The SI driver allows up to 4 KCS or SMIC interfaces to be configured
-in the system.  By default, scan the ACPI tables for interfaces, and
-if it doesn't find any the driver will attempt to register one KCS
-interface at the spec-specified I/O port 0xca2 without interrupts.
-You can change this at module load time (for a module) with:
-
-  modprobe ipmi_si.o type=<type1>,<type2>....
-       ports=<port1>,<port2>... addrs=<addr1>,<addr2>...
-       irqs=<irq1>,<irq2>... trydefaults=[0|1]
-       regspacings=<sp1>,<sp2>,... regsizes=<size1>,<size2>,...
-       regshifts=<shift1>,<shift2>,...
-       slave_addrs=<addr1>,<addr2>,...
-       force_kipmid=<enable1>,<enable2>,...
-       kipmid_max_busy_us=<ustime1>,<ustime2>,...
-       unload_when_empty=[0|1]
-
-Each of these except si_trydefaults is a list, the first item for the
-first interface, second item for the second interface, etc.
-
-The si_type may be either "kcs", "smic", or "bt".  If you leave it blank, it
-defaults to "kcs".
-
-If you specify si_addrs as non-zero for an interface, the driver will
-use the memory address given as the address of the device.  This
-overrides si_ports.
-
-If you specify si_ports as non-zero for an interface, the driver will
-use the I/O port given as the device address.
-
-If you specify si_irqs as non-zero for an interface, the driver will
-attempt to use the given interrupt for the device.
-
-si_trydefaults sets whether the standard IPMI interface at 0xca2 and
-any interfaces specified by ACPE are tried.  By default, the driver
-tries it, set this value to zero to turn this off.
-
-The next three parameters have to do with register layout.  The
-registers used by the interfaces may not appear at successive
-locations and they may not be in 8-bit registers.  These parameters
-allow the layout of the data in the registers to be more precisely
-specified.
-
-The regspacings parameter give the number of bytes between successive
-register start addresses.  For instance, if the regspacing is set to 4
-and the start address is 0xca2, then the address for the second
-register would be 0xca6.  This defaults to 1.
-
-The regsizes parameter gives the size of a register, in bytes.  The
-data used by IPMI is 8-bits wide, but it may be inside a larger
-register.  This parameter allows the read and write type to specified.
-It may be 1, 2, 4, or 8.  The default is 1.
-
-Since the register size may be larger than 32 bits, the IPMI data may not
-be in the lower 8 bits.  The regshifts parameter give the amount to shift
-the data to get to the actual IPMI data.
-
-The slave_addrs specifies the IPMI address of the local BMC.  This is
-usually 0x20 and the driver defaults to that, but in case it's not, it
-can be specified when the driver starts up.
-
-The force_ipmid parameter forcefully enables (if set to 1) or disables
-(if set to 0) the kernel IPMI daemon.  Normally this is auto-detected
-by the driver, but systems with broken interrupts might need an enable,
-or users that don't want the daemon (don't need the performance, don't
-want the CPU hit) can disable it.
-
-If unload_when_empty is set to 1, the driver will be unloaded if it
-doesn't find any interfaces or all the interfaces fail to work.  The
-default is one.  Setting to 0 is useful with the hotmod, but is
-obviously only useful for modules.
-
-When compiled into the kernel, the parameters can be specified on the
-kernel command line as:
-
-  ipmi_si.type=<type1>,<type2>...
-       ipmi_si.ports=<port1>,<port2>... ipmi_si.addrs=<addr1>,<addr2>...
-       ipmi_si.irqs=<irq1>,<irq2>... ipmi_si.trydefaults=[0|1]
-       ipmi_si.regspacings=<sp1>,<sp2>,...
-       ipmi_si.regsizes=<size1>,<size2>,...
-       ipmi_si.regshifts=<shift1>,<shift2>,...
-       ipmi_si.slave_addrs=<addr1>,<addr2>,...
-       ipmi_si.force_kipmid=<enable1>,<enable2>,...
-       ipmi_si.kipmid_max_busy_us=<ustime1>,<ustime2>,...
-
-It works the same as the module parameters of the same names.
-
-By default, the driver will attempt to detect any device specified by
-ACPI, and if none of those then a KCS device at the spec-specified
-0xca2.  If you want to turn this off, set the "trydefaults" option to
-false.
-
-If your IPMI interface does not support interrupts and is a KCS or
-SMIC interface, the IPMI driver will start a kernel thread for the
-interface to help speed things up.  This is a low-priority kernel
-thread that constantly polls the IPMI driver while an IPMI operation
-is in progress.  The force_kipmid module parameter will all the user to
-force this thread on or off.  If you force it off and don't have
-interrupts, the driver will run VERY slowly.  Don't blame me,
-these interfaces suck.
-
-Unfortunately, this thread can use a lot of CPU depending on the
-interface's performance.  This can waste a lot of CPU and cause
-various issues with detecting idle CPU and using extra power.  To
-avoid this, the kipmid_max_busy_us sets the maximum amount of time, in
-microseconds, that kipmid will spin before sleeping for a tick.  This
-value sets a balance between performance and CPU waste and needs to be
-tuned to your needs.  Maybe, someday, auto-tuning will be added, but
-that's not a simple thing and even the auto-tuning would need to be
-tuned to the user's desired performance.
-
-The driver supports a hot add and remove of interfaces.  This way,
-interfaces can be added or removed after the kernel is up and running.
-This is done using /sys/modules/ipmi_si/parameters/hotmod, which is a
-write-only parameter.  You write a string to this interface.  The string
-has the format:
-   <op1>[:op2[:op3...]]
-The "op"s are:
-   add|remove,kcs|bt|smic,mem|i/o,<address>[,<opt1>[,<opt2>[,...]]]
-You can specify more than one interface on the line.  The "opt"s are:
-   rsp=<regspacing>
-   rsi=<regsize>
-   rsh=<regshift>
-   irq=<irq>
-   ipmb=<ipmb slave addr>
-and these have the same meanings as discussed above.  Note that you
-can also use this on the kernel command line for a more compact format
-for specifying an interface.  Note that when removing an interface,
-only the first three parameters (si type, address type, and address)
-are used for the comparison.  Any options are ignored for removing.
-
-The SMBus Driver
-----------------
-
-The SMBus driver allows up to 4 SMBus devices to be configured in the
-system.  By default, the driver will register any SMBus interfaces it finds
-in the I2C address range of 0x20 to 0x4f on any adapter.  You can change this
-at module load time (for a module) with:
-
-  modprobe ipmi_smb.o
-	addr=<adapter1>,<i2caddr1>[,<adapter2>,<i2caddr2>[,...]]
-	dbg=<flags1>,<flags2>...
-	[defaultprobe=1] [dbg_probe=1]
-
-The addresses are specified in pairs, the first is the adapter ID and the
-second is the I2C address on that adapter.
-
-The debug flags are bit flags for each BMC found, they are:
-IPMI messages: 1, driver state: 2, timing: 4, I2C probe: 8
-
-Setting smb_defaultprobe to zero disabled the default probing of SMBus
-interfaces at address range 0x20 to 0x4f.  This means that only the
-BMCs specified on the smb_addr line will be detected.
-
-Setting smb_dbg_probe to 1 will enable debugging of the probing and
-detection process for BMCs on the SMBusses.
-
-Discovering the IPMI compliant BMC on the SMBus can cause devices
-on the I2C bus to fail. The SMBus driver writes a "Get Device ID" IPMI
-message as a block write to the I2C bus and waits for a response.
-This action can be detrimental to some I2C devices. It is highly recommended
-that the known I2c address be given to the SMBus driver in the smb_addr
-parameter. The default address range will not be used when a smb_addr
-parameter is provided.
-
-When compiled into the kernel, the addresses can be specified on the
-kernel command line as:
-
-  ipmb_smb.addr=<adapter1>,<i2caddr1>[,<adapter2>,<i2caddr2>[,...]]
-	ipmi_smb.dbg=<flags1>,<flags2>...
-	ipmi_smb.defaultprobe=0 ipmi_smb.dbg_probe=1
-
-These are the same options as on the module command line.
-
-Note that you might need some I2C changes if CONFIG_IPMI_PANIC_EVENT
-is enabled along with this, so the I2C driver knows to run to
-completion during sending a panic event.
-
-
-Other Pieces
-------------
-
-Get the detailed info related with the IPMI device
---------------------------------------------------
-
-Some users need more detailed information about a device, like where
-the address came from or the raw base device for the IPMI interface.
-You can use the IPMI smi_watcher to catch the IPMI interfaces as they
-come or go, and to grab the information, you can use the function
-ipmi_get_smi_info(), which returns the following structure:
-
-struct ipmi_smi_info {
-	enum ipmi_addr_src addr_src;
-	struct device *dev;
-	union {
-		struct {
-			void *acpi_handle;
-		} acpi_info;
-	} addr_info;
-};
-
-Currently special info for only for SI_ACPI address sources is
-returned.  Others may be added as necessary.
-
-Note that the dev pointer is included in the above structure, and
-assuming ipmi_smi_get_info returns success, you must call put_device
-on the dev pointer.
-
-
-Watchdog
---------
-
-A watchdog timer is provided that implements the Linux-standard
-watchdog timer interface.  It has three module parameters that can be
-used to control it:
-
-  modprobe ipmi_watchdog timeout=<t> pretimeout=<t> action=<action type>
-      preaction=<preaction type> preop=<preop type> start_now=x
-      nowayout=x ifnum_to_use=n
-
-ifnum_to_use specifies which interface the watchdog timer should use.
-The default is -1, which means to pick the first one registered.
-
-The timeout is the number of seconds to the action, and the pretimeout
-is the amount of seconds before the reset that the pre-timeout panic will
-occur (if pretimeout is zero, then pretimeout will not be enabled).  Note
-that the pretimeout is the time before the final timeout.  So if the
-timeout is 50 seconds and the pretimeout is 10 seconds, then the pretimeout
-will occur in 40 second (10 seconds before the timeout).
-
-The action may be "reset", "power_cycle", or "power_off", and
-specifies what to do when the timer times out, and defaults to
-"reset".
-
-The preaction may be "pre_smi" for an indication through the SMI
-interface, "pre_int" for an indication through the SMI with an
-interrupts, and "pre_nmi" for a NMI on a preaction.  This is how
-the driver is informed of the pretimeout.
-
-The preop may be set to "preop_none" for no operation on a pretimeout,
-"preop_panic" to set the preoperation to panic, or "preop_give_data"
-to provide data to read from the watchdog device when the pretimeout
-occurs.  A "pre_nmi" setting CANNOT be used with "preop_give_data"
-because you can't do data operations from an NMI.
-
-When preop is set to "preop_give_data", one byte comes ready to read
-on the device when the pretimeout occurs.  Select and fasync work on
-the device, as well.
-
-If start_now is set to 1, the watchdog timer will start running as
-soon as the driver is loaded.
-
-If nowayout is set to 1, the watchdog timer will not stop when the
-watchdog device is closed.  The default value of nowayout is true
-if the CONFIG_WATCHDOG_NOWAYOUT option is enabled, or false if not.
-
-When compiled into the kernel, the kernel command line is available
-for configuring the watchdog:
-
-  ipmi_watchdog.timeout=<t> ipmi_watchdog.pretimeout=<t>
-	ipmi_watchdog.action=<action type>
-	ipmi_watchdog.preaction=<preaction type>
-	ipmi_watchdog.preop=<preop type>
-	ipmi_watchdog.start_now=x
-	ipmi_watchdog.nowayout=x
-
-The options are the same as the module parameter options.
-
-The watchdog will panic and start a 120 second reset timeout if it
-gets a pre-action.  During a panic or a reboot, the watchdog will
-start a 120 timer if it is running to make sure the reboot occurs.
-
-Note that if you use the NMI preaction for the watchdog, you MUST NOT
-use the nmi watchdog.  There is no reasonable way to tell if an NMI
-comes from the IPMI controller, so it must assume that if it gets an
-otherwise unhandled NMI, it must be from IPMI and it will panic
-immediately.
-
-Once you open the watchdog timer, you must write a 'V' character to the
-device to close it, or the timer will not stop.  This is a new semantic
-for the driver, but makes it consistent with the rest of the watchdog
-drivers in Linux.
-
-
-Panic Timeouts
---------------
-
-The OpenIPMI driver supports the ability to put semi-custom and custom
-events in the system event log if a panic occurs.  if you enable the
-'Generate a panic event to all BMCs on a panic' option, you will get
-one event on a panic in a standard IPMI event format.  If you enable
-the 'Generate OEM events containing the panic string' option, you will
-also get a bunch of OEM events holding the panic string.
-
-
-The field settings of the events are:
-* Generator ID: 0x21 (kernel)
-* EvM Rev: 0x03 (this event is formatting in IPMI 1.0 format)
-* Sensor Type: 0x20 (OS critical stop sensor)
-* Sensor #: The first byte of the panic string (0 if no panic string)
-* Event Dir | Event Type: 0x6f (Assertion, sensor-specific event info)
-* Event Data 1: 0xa1 (Runtime stop in OEM bytes 2 and 3)
-* Event data 2: second byte of panic string
-* Event data 3: third byte of panic string
-See the IPMI spec for the details of the event layout.  This event is
-always sent to the local management controller.  It will handle routing
-the message to the right place
-
-Other OEM events have the following format:
-Record ID (bytes 0-1): Set by the SEL.
-Record type (byte 2): 0xf0 (OEM non-timestamped)
-byte 3: The slave address of the card saving the panic
-byte 4: A sequence number (starting at zero)
-The rest of the bytes (11 bytes) are the panic string.  If the panic string
-is longer than 11 bytes, multiple messages will be sent with increasing
-sequence numbers.
-
-Because you cannot send OEM events using the standard interface, this
-function will attempt to find an SEL and add the events there.  It
-will first query the capabilities of the local management controller.
-If it has an SEL, then they will be stored in the SEL of the local
-management controller.  If not, and the local management controller is
-an event generator, the event receiver from the local management
-controller will be queried and the events sent to the SEL on that
-device.  Otherwise, the events go nowhere since there is nowhere to
-send them.
-
-
-Poweroff
---------
-
-If the poweroff capability is selected, the IPMI driver will install
-a shutdown function into the standard poweroff function pointer.  This
-is in the ipmi_poweroff module.  When the system requests a powerdown,
-it will send the proper IPMI commands to do this.  This is supported on
-several platforms.
-
-There is a module parameter named "poweroff_powercycle" that may
-either be zero (do a power down) or non-zero (do a power cycle, power
-the system off, then power it on in a few seconds).  Setting
-ipmi_poweroff.poweroff_control=x will do the same thing on the kernel
-command line.  The parameter is also available via the proc filesystem
-in /proc/sys/dev/ipmi/poweroff_powercycle.  Note that if the system
-does not support power cycling, it will always do the power off.
-
-The "ifnum_to_use" parameter specifies which interface the poweroff
-code should use.  The default is -1, which means to pick the first one
-registered.
-
-Note that if you have ACPI enabled, the system will prefer using ACPI to
-power off.
diff -urN flo-ElementalX-5.00/Documentation/firmware_class/README flo-ElementalX-5.00-patched/Documentation/firmware_class/README
--- flo-ElementalX-5.00/Documentation/firmware_class/README	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/firmware_class/README	2016-06-01 15:47:50.000000000 +0000
@@ -106,3 +106,10 @@
    on the setup, so I think that the choice on what firmware to make
    persistent should be left to userspace.
 
+ about firmware cache:
+ --------------------
+ After firmware cache mechanism is introduced during system sleep,
+ request_firmware can be called safely inside device's suspend and
+ resume callback, and callers need't cache the firmware by
+ themselves any more for dealing with firmware loss during system
+ resume.
diff -urN flo-ElementalX-5.00/Makefile flo-ElementalX-5.00-patched/Makefile
--- flo-ElementalX-5.00/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Makefile	2016-06-01 15:49:10.000000000 +0000
@@ -245,7 +245,7 @@
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS   = -O2 -fomit-frame-pointer
 HOSTCXXFLAGS = -O2
 
 # Decide whether to build built-in, modular, or both.
@@ -351,10 +351,10 @@
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
 		  -Wbitwise -Wno-return-void $(CF)
-CFLAGS_MODULE   =
+CFLAGS_MODULE   = -fno-pic -fno-common
 AFLAGS_MODULE   =
 LDFLAGS_MODULE  =
-CFLAGS_KERNEL	= -munaligned-access -fgcse-lm -fgcse-sm -fsched-spec-load -ffast-math -fsingle-precision-constant -mtune=cortex-a15 -mtune=cortex-a15 -marm -mfpu=neon-vfpv4 -funroll-loops
+CFLAGS_KERNEL	= -fgcse-lm -fgcse-sm -fsched-spec-load -ffast-math -fsingle-precision-constant -mtune=cortex-a15 -mtune=cortex-a15 -marm -mfpu=neon-vfpv4 -funroll-loops
 AFLAGS_KERNEL	=
 CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
 
@@ -368,11 +368,7 @@
 
 KBUILD_CPPFLAGS := -D__KERNEL__
 
-KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-		   -fno-strict-aliasing -fno-common \
-		   -Werror-implicit-function-declaration \
-		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+KBUILD_CFLAGS   := -fno-strict-aliasing -fno-common -fno-delete-null-pointer-checks
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
diff -urN flo-ElementalX-5.00/Module.symvers flo-ElementalX-5.00-patched/Module.symvers
--- flo-ElementalX-5.00/Module.symvers	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/Module.symvers	2016-06-03 17:56:14.000000000 +0000
@@ -0,0 +1,7292 @@
+0x00000000	cfg80211_send_rx_assoc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_allocate_contiguous_memory_nomap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_invalidate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_page_cache_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_platform_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_put_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	FsMountVol	vmlinux	EXPORT_SYMBOL
+0x00000000	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	register_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_read	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_session_find_by_ifname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_of_parse_audio_routing	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	decode_rs8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_event_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drain_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_get_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_grab	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_write_bulk_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_validate_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x00000000	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	g_token_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_graft_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_get_bpp_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	subsystem_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	put_ashmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_put_device	vmlinux	EXPORT_SYMBOL
+0x00000000	input_handler_for_each_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_videomode_to_var	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_clean	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	mount_subtree	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_put_enum_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_enum_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_keyring	vmlinux	EXPORT_SYMBOL
+0x00000000	_clear_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_handle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_keyup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_get_device_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_decode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_power_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reset_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_dma_free_bam_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_app_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bus_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_last	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_string	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_iommu_map_contig_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	memmove	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_d_lookup_sb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x00000000	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_crypto_ahash_setkey	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_add_pins	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_cdc_unbind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_subsystem_check_iova_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	return_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_codec_stream_event	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_map_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_find_ltk_by_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_put_meminfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fmem_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x00000000	register_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_fill_dv_preset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_gpio_request	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_quick_get_max	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_retry_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_lock_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	__krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	prof_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_fini	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_gadget_map_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_drop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_unprep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_map_attachment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_class	vmlinux	EXPORT_SYMBOL
+0x00000000	load_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x00000000	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_use_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_detach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_compress_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_open	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pppox_proto	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_set_autosuspend_delay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_group_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoull_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_init_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_new_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_remove_bad_delegation	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_load	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_set_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_rcv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	private_AES_set_decrypt_key	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l4proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dapm_mark_dirty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_deregister_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fill_in_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x00000000	task_handoff_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_tun_dev_create	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_route_child_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_stop_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_iter_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_try_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_buf_from_iov	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pre_hwaccess	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_default_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_new_subdev_board	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_read_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_notify_new_peer_candidate	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__ashrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__lshrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_states	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_rfree	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_map_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_long	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_usbmidi_create	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_takedown	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_msi_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_rs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsSyncVol	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pgprot_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_set_num_threads	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_parse_nat_setup_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_do_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wake_lock_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	walk_stackframe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_force_enable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial_copy_nocheck	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	register_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_test_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_interrupt_hpi	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	init_request_from_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_wait_for_buffer_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arpt_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_queryctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	free_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_get_by_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_sync_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_master_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_global_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_it_nexus_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_allocate_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	key_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_reserve_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_wifi_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_suspend_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	backlight_force_update	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_reset_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	mktime	vmlinux	EXPORT_SYMBOL
+0x00000000	system_state	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_ioctl_0	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_query_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_info	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mem_entry_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_diag_bc_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__qdisc_calculate_pkt_len	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_xfer_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_unmap_attachment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_power_restore_host	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_force_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_find_continuous	vmlinux	EXPORT_SYMBOL
+0x00000000	__next_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	keyring_search	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_remove_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_register_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_nowake_buffer_unlock_commit_regs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_calc_bclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_insert_addr_table_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_pptp_hook_expectfn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_wait_for_req	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_init_spi	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_init_i2c	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_lasr	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_llsr	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_next	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflate	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_get_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drain_output	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_set_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_request_send_background	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__ftrace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_delete_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_any	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_nrt_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_inq_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_conntrack_confirm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_dev_fop_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_use_dummy_regulator	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_register_core	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_enable_read_intr	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_end_reset_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_reinject	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_add_host	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_remote_mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_set_boot_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	__csum_ipv6_magic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_unregister_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_msglevel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_msglevel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_alloc_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_pages_exact_nid	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_create_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_prepare_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	rps_may_expire_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_unmap_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_unload_default_node	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_gss_principal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_unlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_discovery_request	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_set_pll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_in_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	module_refcount	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_destroy_cache_detail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_create_from_cmdline_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_store_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_edge_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pm_set_max_sleep_time	vmlinux	EXPORT_SYMBOL
+0x00000000	get_ashmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_threshold_set	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_new	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_match_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	strsep	vmlinux	EXPORT_SYMBOL
+0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cleancache_invalidate_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_add	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_get_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0x00000000	end_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_create	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_conflicting_framebuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__ablkcipher_walk_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_get_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_deferrable_timer_on_stack_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ipc_router_security_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_unregister_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_input_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_get_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	__kernel_param_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_invert_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_unsigned	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockd_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_default_writable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x00000000	migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_note_context_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_map_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_do_cache_op	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commit_release_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_new	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_assume_removable	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_thaw_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_dev_find	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_list	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_put_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_data_from_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_restore_msi_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_disable_read_intr	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_extract_all	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_info_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reserve_pmu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_get_by_OID	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_create	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_bulk_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_physpages	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_unregister_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_pipeline_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_get_ch_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_str	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_vpd_find_info_keyword	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_mpp_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_symbols_seq_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_reason	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_update_classid	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lzo1x_1_compress	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_check_for_modem_crash	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_limit_volume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_read_arg_group	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_handle_create	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_cleanup_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_dmov_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_sched_scan_results	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_device_release	vmlinux	EXPORT_SYMBOL
+0x00000000	FsTruncateFile	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_rule_noresample	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_querymenu	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_pci_free	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_get_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_hdrlen_from_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_module_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_dealloc_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i2c_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	textsearch_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_contiguous_ebi_nomap	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_msbits	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register_subdev_nodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qseecom_send_command	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secmark_relabel_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pci_quirk_lookup_id	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_create	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_create_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_leave	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_put_decimal_ull	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_next_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_string_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_idlelock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_init	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rotator_imem_allocate	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msleep	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_open	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
+0x00000000	__audit_inode_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_reserve_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_h225_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_map_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_destroy_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_unthrottle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pppox_proto	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_set_mmutype	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_get_mmutype	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_activate_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_submit_read_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_sync_region	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_allow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_secure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_option	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_vpd_find_tag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_augment_erase_end	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_attach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_apcs_set_phase	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_ablkcipher_request_free	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_size	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_activate	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_detachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	task_free_register	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_user_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	thread_notify_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_get_platform_device	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	irttp_data_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_data_request	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	list_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_wait_for_all_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup	vmlinux	EXPORT_SYMBOL
+0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_vpd_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_is_call_available	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	xc4000_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	xc5000_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	_kstrtol	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_cmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	sound_class	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_close_slim_sch_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_close_slim_sch_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_setsize	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	system_nrt_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svcauth_gss_flavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svcauth_gss_register_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_busy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_set_algo_params	vmlinux	EXPORT_SYMBOL
+0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_scope	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_nway_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_comm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_bint	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	task_free_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_global_item_unref	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	would_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_usbmidi_input_start	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_get_name	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_max_seg_size	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_batch	vmlinux	EXPORT_SYMBOL
+0x00000000	d_path	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_free_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cmdbatch_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	igrab	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_set_runtime_hwparams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_open_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_secure_erase_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unmap_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_get_slaveport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3protos	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	sweep2wake_setdev	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_optimum_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_get_video_format_from_drv_data	vmlinux	EXPORT_SYMBOL
+0x00000000	__rcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_read_line	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_debugfs_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_slot_state	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_readl	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_queue_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_subdev_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_subdev_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	AES_decrypt	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_default_rule_pref	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_period_elapsed	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_av_sync_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_domain_xlate_twocell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_domain_xlate_onecell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_iommu_get_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_interface_reg_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_request_and_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_start	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_cluster	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sget	vmlinux	EXPORT_SYMBOL
+0x00000000	memset	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_send_sco	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_pkts_acked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_calc_frame_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_event_pending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sw_hweight8	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_event	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_setstate	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	d_set_d_op	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_integer_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_update_netprioidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_drain	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_erase_group_aligned	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_disable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_try_attach_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_logging_level	vmlinux	EXPORT_SYMBOL
+0x00000000	regcache_mark_dirty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in	vmlinux	EXPORT_SYMBOL
+0x00000000	hwrng_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_idle_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__css_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_need_gre	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_hs_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_mmc_packing_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_close	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_end_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_put_sb_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mac_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_cache_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	slimport_read_edid_block	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_put	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_restore_state	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_enable_xhci_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_unreg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_std	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_it_nexus_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_claim_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_register_net_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_control_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_video_std_frame_period	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_select_eld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_add_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_wake_pending_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_accept_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_unregister_action	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_wait_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_parse_opts_str	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_lcd_type	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_close	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_detach_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_prev	vmlinux	EXPORT_SYMBOL
+0x00000000	user_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key_async_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_unlink_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_handoff_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_print_regs32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_ramdump_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_ignore_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	leds_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_postmortem_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_tw_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_flags_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_sysrq	vmlinux	EXPORT_SYMBOL
+0x00000000	_kstrtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_weak_routes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_queue_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_gpuaddr_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_err	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_owner_or_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_confirm	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super_thawed	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_get_security_rule	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_tx_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_add_zones	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_param_first	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_select_bars	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_subsystem_map_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create_pooled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_vibrator_config	vmlinux	EXPORT_SYMBOL
+0x00000000	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_dai_substream	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_snd_pcm_lib_alloc_vmalloc_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_create_kernel_counter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_idle_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_invert_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_s_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_mode_to_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_set_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	FsLookupFile	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_delete_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dput	vmlinux	EXPORT_SYMBOL
+0x00000000	try_module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	is_container_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_delay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_bulk_write_raw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fill_inquiry_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_uidivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_free_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_pre_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_hdrlen	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_norm_to_name	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_valid_only_mem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irias_new_integer_value	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_enum_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_flush_dcache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_idlelock_take	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_vddrange_to_ocrmask	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_suspended	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	sha1_update_arm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_push	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_f0_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_run_queue_async	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
+0x00000000	free_task	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_del_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_min_io	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_disconnect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_disconnect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_release_host	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_put_task_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_set_cbits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_untracked_status_or	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_jack_set_key	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_common_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_phy_device	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mh_intrcallback	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight32	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight16	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight64	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_prealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_skip_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_user	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_exit_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_set_adcmap_ntcg_104ef_104fb	vmlinux	EXPORT_SYMBOL
+0x00000000	external_common_state_hpd_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_rpc_get_sym	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_start	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_getvaluebyclass_request	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_reg_access	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_clkdiv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_blink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memchr_inv	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_modify_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_preload_dVdd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_class_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_destroy_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ion_secure_heap_2_0	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_tryget	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gtf_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_count_voltages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_find_any_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_event_reg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_attach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_detach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrstate_to_str	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	unload_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_set_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_rtp_rtcp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_repeat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_run_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	mhl_connect_api	vmlinux	EXPORT_SYMBOL
+0x00000000	bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memset_io	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_get_mapinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_register_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_process_call	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iput	vmlinux	EXPORT_SYMBOL
+0x00000000	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_complete_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_low	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_sync_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_open	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alter_reply	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_update_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_prime_destroy_file_private	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_firmware_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_change	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_blocks_per_page	vmlinux	EXPORT_SYMBOL
+0x00000000	iterate_supers_type	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_handle_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	genericbl_limit_intensity	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_unlink_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_change_features	vmlinux	EXPORT_SYMBOL
+0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_resize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_drvinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_msi	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_write_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_is_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_get_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_set_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_params_to_frame_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_store_edge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	suspend_set_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pil_force_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timerqueue_iterate_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_iosched_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_put_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_audio_packet_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	in4_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfb_copyarea	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_unmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mh_start	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_to_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_write	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_next_chunk	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	do_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_handler_data	vmlinux	EXPORT_SYMBOL
+0x00000000	yield_to	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_channel_to_frequency	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_media	vmlinux	EXPORT_SYMBOL
+0x00000000	user_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	test_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	__udivsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_info_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus_parented	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_init_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_check_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_context_init	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_insert_node	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_term	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aes_expand_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_map	vmlinux	EXPORT_SYMBOL
+0x00000000	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_reg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_release_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_wait_for_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_round_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_encoder_name	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_taskset_cur_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cad_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	cacheid	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou8	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_component_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_ebimem_user	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pp_interrupt_out_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6t_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tuner_count	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsWriteFile	vmlinux	EXPORT_SYMBOL
+0x00000000	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_axi_porthalt	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_min_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_high	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_unique_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_mangle_udp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_get_pin_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_get_contig_userptr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_add_target_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	follow_down_one	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_init_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_iprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create_memless	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_unprep_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_get_monotonic_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_shift_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_options_rcv_srr	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_add_numbered_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_early_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tasklet_init	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_setup_info	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_rtd_stream_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_undo_access	vmlinux	EXPORT_SYMBOL
+0x00000000	stop_machine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_unlink_expect_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_register_pm_ops	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xt_unregister_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_cancel	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_register_bam_device	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_remove_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_get_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_authenticate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_register_service	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_new	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_cdc_wdm_register	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	complete	vmlinux	EXPORT_SYMBOL
+0x00000000	downgrade_write	vmlinux	EXPORT_SYMBOL
+0x00000000	get_mem_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_check_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_mmap_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_response_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_lookup_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_xmit_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_new_stream	vmlinux	EXPORT_SYMBOL
+0x00000000	otg_state_string	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_update_name_case	vmlinux	EXPORT_SYMBOL
+0x00000000	high_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_call_function_many	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_l2_set_low_power_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_check_arch	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_free_gpios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_get_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	mc44s803_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_link	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_bh_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidinput_find_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_put_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clkdev_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_cvt_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_section	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig_info	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	show_class_attr_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	allow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_info_select	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_register	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_frame_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_set_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_connect_response	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_connect_response	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_delete_from_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_platform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_output_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_buf_subsegment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_err	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_put_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_idle_time_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_alt_setting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_encrypted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_pipe_buf_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_steal	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_find	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_printk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_put	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_reset_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0x00000000	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_put_vma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_port_get_xfer_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	div64_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_merge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	d_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_coincell_chg_config	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	mntget	vmlinux	EXPORT_SYMBOL
+0x00000000	mntput	vmlinux	EXPORT_SYMBOL
+0x00000000	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcookie_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_table_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_dump_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_dump	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__request_module	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_deactivate	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_platform_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	avs_set_avsdscr	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_get_avsdscr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_spi_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_unlock_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_unregister_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__first_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_force_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_peek_r	vmlinux	EXPORT_SYMBOL
+0x00000000	print_ssid	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4hc_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsReadStat	vmlinux	EXPORT_SYMBOL
+0x00000000	__rpc_wait_for_completion_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_start	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dirty_info_property	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_free_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_regulator_set_ocr	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_mhl_get_supported_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	event_storage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_wrap_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	rename_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_usb_id_pullup	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_hsed_bias_control	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_inode_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_contiguous_ebi	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_set_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_blink_set	vmlinux	EXPORT_SYMBOL
+0x00000000	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_check_and_unmask_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_remain_on_channel_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_change_link_key	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_ext_add	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_prot_clear_portaddr_nulls	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_find_nth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_unregister_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_volatile_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_cpuinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_async_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_ptpool_init	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_krait_need_wfe_fixup	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_get_fd_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	__readwrite_bug	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_register_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_link	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_alloc_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dynamic_pr_debug	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_policy_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_dump_one_icsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_report_raw_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tea5761_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_begin_cpu_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmclnt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fd_install	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_alloc_ahash	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	wcnss_reset_intr	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_nat_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_used_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_free	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_audio_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_put	vmlinux	EXPORT_SYMBOL
+0x00000000	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_put_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_irq_uninstall	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_set_clr_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sock_graft	vmlinux	EXPORT_SYMBOL
+0x00000000	key_reject_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_finish_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_recvmsg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsens_get_temp	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_master_put	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_check_send_permissions	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	regcache_cache_bypass	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_cpufreq_set_freq_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_ctrl_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlap_open	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_open	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlap_close	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_close	vmlinux	EXPORT_SYMBOL
+0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_step	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_unregister_entity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_busnum_to_ctrl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_hard_reset_config	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_framebuffer_init	vmlinux	EXPORT_SYMBOL
+0x00000000	register_early_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_find_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_pseudoflavor_to_service	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_pptp_hook_inbound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l4proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_grow	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_ion_status	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_simple_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfulnl_log_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_find_device_by_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_commit_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__per_cpu_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_sig_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_virt_to_phys	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcg_get_weight	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	event_storage_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_plane_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0x00000000	d_clear_need_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read	vmlinux	EXPORT_SYMBOL
+0x00000000	km_report	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x00000000	d_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_close	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_mhl_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	path_is_under	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_hook_unlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_set_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_quick_get	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_underlying_device_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	smb345_charger_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_sample_rate_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_set	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_physical_width	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_platform_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_clock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_dcache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_querymenu	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_to_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_add_numbered_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	filter_current_check_discard	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_seq_adjust_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_hold_time_set	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_search_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_enable_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_change_overwrite	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_put_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	async_unwrap_char	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_pll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremapfree	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_install	vmlinux	EXPORT_SYMBOL
+0x00000000	__kunmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipefs_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_del_global	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add_global	vmlinux	EXPORT_SYMBOL
+0x00000000	videobuf2_pmem_contig_mmap_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_global_item_ref	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_framebuffer_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fifo_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mfd_cell_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_count_and_time	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_virt_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_proto_nlattr_to_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inetpeer_invalidate_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_powers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_preallocate_pages_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_free_req	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_remove_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_remove_item	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_off	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_state_notfound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidinput_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	baswap	vmlinux	EXPORT_SYMBOL
+0x00000000	tun_get_socket	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_noflush_suspending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_hs_set_mctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_ltr_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	up_write	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_release	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_open	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_cpu_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_cpu_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_remember	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_put_block	vmlinux	EXPORT_SYMBOL
+0x00000000	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	fget	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_io_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_boolean_mono_info	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_log_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_apcs_set_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_info_free	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_of_parse_card_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_get_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_put_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	match_token	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_abort	vmlinux	EXPORT_SYMBOL
+0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x00000000	__ftrace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_write	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_change_intr_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_frequency_to_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_add_card_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_pages_to_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	key_type_logon	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_remove_expectations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_cache_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc16	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_on_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_power	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_tproxy_assign_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_unicast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_iova_to_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_hide_latency_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_get_last_vbltimestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_intx_mask_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bsearch	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_set_test_result	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x00000000	FsRemoveDir	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_throttle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_ebimem	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_in	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_free_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_flow_off	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_map_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_register_board_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_setbufsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbhid_set_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_purge_paused_rxq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	color_table	vmlinux	EXPORT_SYMBOL
+0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_find_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_cpu_rmap_add	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_split	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_invalidate_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_tiocmset_from_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_add_modes_noedid	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_ref_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_enqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_set_iommu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sitar_hs_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_mmap_pfn_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_target_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_peek	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_request_find_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	microtune_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_add_blkio_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_nr_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_duplicate	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_ahash_digest	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	drm_mm_get_block_range_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	vt_get_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	save_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_set_hashsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_qbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_usercopy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	free_contiguous_memory_by_paddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_socket_getpeersec_dgram	vmlinux	EXPORT_SYMBOL
+0x00000000	set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	set_timer_slack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_alloc_endpoint	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_alloc_req	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_notifysecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_info_init	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_nat_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdio_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_common_supported_video_mode_lut	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_uart_gpio_mux_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	pwm_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_timer_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_unlock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_dma_seg_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_ethernet_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_resume_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_wake_up_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_tdkntcg_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_otg_id_pin_irq_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_init_64k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_64k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	FsReadFile	vmlinux	EXPORT_SYMBOL
+0x00000000	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_get_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_match	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_platform_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_var_to_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_stop_and_remove_behind_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_io_merged_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_module_init_notifier_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_find_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_stacked_transfer_operstate	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_set_id	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_start	vmlinux	EXPORT_SYMBOL
+0x00000000	key_set_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_bulk_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_encoder_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_get_memory_map	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x00000000	crc_ccitt	vmlinux	EXPORT_SYMBOL
+0x00000000	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
+0x00000000	set_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_is_intel_switchable_xhci	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_free	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_unexpect_related	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uuid_be_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_update_io_add_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_assign_unassigned_bridge_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_put_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratdens	vmlinux	EXPORT_SYMBOL
+0x00000000	release_and_free_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_tree_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_invert_cmaps	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_alloc_ablkcipher	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_net_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_put_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__init_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readb_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_graph_walk_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reconfig_AICL	vmlinux	EXPORT_SYMBOL
+0x00000000	uncache_firmware	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_dealloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x00000000	strndup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_update_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_reinsert_req_sup	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_symbols_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	idle_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_get_status	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_received	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	uio_event_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_schedule_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_bytes_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	audit_log_task_context	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_write_then_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_cfg_slim_sch_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_cfg_slim_sch_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sb_clone_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x00000000	css_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_spurious_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_page_alloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_gpio_config	vmlinux	EXPORT_SYMBOL
+0x00000000	crc16_table	vmlinux	EXPORT_SYMBOL
+0x00000000	init_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_ts_and_drops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_subscribe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_just_insert_please	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_driver_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0x00000000	pil_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_find_region	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_has_full_constraints	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_export	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_set_expiry	vmlinux	EXPORT_SYMBOL
+0x00000000	use_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	nfsd_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_cancel_async	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_putpagetable	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_forbid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_disable_deferred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__twofish_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_put_decimal_ll	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_iommu_unmap_contig_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_ntop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_pton	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_clk_get	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	des_ekey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_raw_event_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_irq_install	vmlinux	EXPORT_SYMBOL
+0x00000000	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_completed	vmlinux	EXPORT_SYMBOL
+0x00000000	key_link	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_auth_and_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_scan_fixups	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_get_mem_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_page	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_dispatch_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	keyring_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_pc	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_service_to_auth_domain_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_resolution	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_wipe	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_var	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	strnstr	vmlinux	EXPORT_SYMBOL
+0x00000000	__css_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_sock_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_diag_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_elf_read_implies_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_phy2h	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	add_device_randomness	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_nearest_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_crypto_free_ahash	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	snd_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_file_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_phy_id	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_getsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memcpy_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_ratnum	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unmap_urb_setup_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_set_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	membank0_size	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_rmdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_blocklen	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5761_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_enqueue_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_hold_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_protocol_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_default_ttl	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_stay_on	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flex_array_get	vmlinux	EXPORT_SYMBOL
+0x00000000	key_task_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_protocol_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_find_vendor_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_recv_common	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hwdep_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_mmss	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_resource_n	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_request_done	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_get_ptname_from_ptbase	vmlinux	EXPORT_SYMBOL
+0x00000000	ewma_add	vmlinux	EXPORT_SYMBOL
+0x00000000	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_boolean_stereo_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_blk_init_packed_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writew	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_default_readable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_port_xfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_request_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_is_pkt_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_flow_on	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_custom	vmlinux	EXPORT_SYMBOL
+0x00000000	tda829x_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_amd_dev_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_pwrlevel_change	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_write	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_fpu	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_link_rwlock	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_is_hotpluggable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_read_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_exec_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	pingv6_prot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_reqbufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slimbus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_amanda_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_probe_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	check_permissions	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_create_bufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_assign_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_cluster_pm_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_num_counters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_get_serial_number	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_notify_peers	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
+0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_get_init_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
+0x00000000	console_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_pm_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_req	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_timer_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_qdss_ctrl_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ready_on_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_process_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_dai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda18271_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface_no_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_edid_to_eld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_remove_spawns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_empty_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_prevent_suspend	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	lib80211_unregister_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_replace_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_assign_laddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__percpu_counter_init	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_affinity_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_dispatch_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_pointer_emulation	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_transfer_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	set_cpus_allowed_ptr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_notif_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_plane_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_initialize_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cache_range_op	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_calc_vbltimestamp_from_scanoutpos	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_shash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_init_ahash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_timers_register_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_update_bufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_new_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_request_array	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkio_policy_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_turn_on_cpu_rail	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_net_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_master_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_free_array	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_unregister_inet_compat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_global_kobject	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_voltage_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_gifconf	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_sys	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_validate_clocks	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	gpiochip_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_inode_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_classify8021d	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_platform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_pipeline_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_register_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init_scan_with_range	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_xo_get	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_xo_put	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_have_object	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmalloc_caches	vmlinux	EXPORT_SYMBOL
+0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_malloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_release_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_pause_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache_range	vmlinux	EXPORT_SYMBOL
+0x00000000	put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_nowake_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecounter_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_lookup_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_classdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_reset_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_setsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_interrupt_in_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_release	vmlinux	EXPORT_SYMBOL
+0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nla_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_dai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_set_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	up	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_set_ds_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_get	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_is_primary_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuset_mem_spread_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pid_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hashbin_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_open	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_sock_fast	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_cards	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_create_of_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_dcvs_freq_sink_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	nat_q931_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_free	vmlinux	EXPORT_SYMBOL
+0x00000000	qseecom_shutdown_app	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5767_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_dev_name	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_mode_cvt	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fput	vmlinux	EXPORT_SYMBOL
+0x00000000	_change_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_delete_value	vmlinux	EXPORT_SYMBOL
+0x00000000	clkdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_map_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_handler_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	get_restart_level	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_lookup_quirk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_scale_pmic_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_block_bio_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_pmem_contig_user_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_pmem_contig_user_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_handle_vblank	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	strnicmp	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	fbcon_set_bitops	drivers/video/console/bitblit	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_signed	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_find_item	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sock_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_cache_read	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sw_sync_timeline_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_gem_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_fb_v4l2_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	user_instantiate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_icmp_reply_translation	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_attach_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_debugfs_create_files	vmlinux	EXPORT_SYMBOL
+0x00000000	crc_ccitt_table	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_proc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x00000000	phys_mem_access_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x00000000	unlink_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_add	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_sum	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_init	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_4k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_4k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_set_max_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsl	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_cdc_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	system_unbound_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_reconfigure_now	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_free	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_get_state	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elementalx_boost_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_unregister_compressor	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_add_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_edid_add_monspecs	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_active	vmlinux	EXPORT_SYMBOL
+0x00000000	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsCreateFile	vmlinux	EXPORT_SYMBOL
+0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_lut_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_free_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mdp_preset_lut_update_lcdc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_start	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_read_bulk_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_attachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_close	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0x00000000	net_cls_subsys_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_wakeup_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_build_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_new_index	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_msg_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_color_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_set_debounce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_get_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_chmod	vmlinux	EXPORT_SYMBOL
+0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_idiv	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_service_to_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_endpoint	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_map_global	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracepoint_probe_update_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_clear_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_codec_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_define_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_read_mapping_page_gfp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_flush_delayed_boot_votes	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hid_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_file_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_register_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sk_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_link_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_decode_string_inplace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uuid_le_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_seq_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_register	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_cell_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_unsubscribe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_charge_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	external_common_state_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_verify_blk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_copyarea	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_attach_task_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__div0	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_priority_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_new_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dqbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0x00000000	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_skb_features	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_unregister_dais	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_pci_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_pci_init	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_add_unique_test_req	vmlinux	EXPORT_SYMBOL
+0x00000000	work_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_dev_probe2	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	lcd_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_pin_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_update_nr_prod	vmlinux	EXPORT_SYMBOL
+0x00000000	usleep_range	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_check	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_cqm_rssi_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_register_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcie_set_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_bus_configure_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	exportfs_encode_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
+0x00000000	rcutorture_record_progress	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_freq_sink_start	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_reserve_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_batt_scaler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_unplug_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_put	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_get	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_pipe_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_check_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_queue_rcv_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_connect_sink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_get_property	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_property	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x00000000	have_submounts	vmlinux	EXPORT_SYMBOL
+0x00000000	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_init_max_qos_capabilies	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_queue_err_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_add_device_sysfs_file	vmlinux	EXPORT_SYMBOL
+0x00000000	key_create_or_update	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_adjust_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irias_find_object	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_load	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_keydown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_add_page	vmlinux	EXPORT_SYMBOL
+0x00000000	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__memzero	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_buffer_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_bl_default_curve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_init	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_blanked	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_is_singular	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	allocate_contiguous_memory_nomap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_enter_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev32	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cleancache_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_speed_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_resume_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_connect_result	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9310_codec	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_start_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pm_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_set_features	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0x00000000	filter_match_preds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_change_state	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unlock_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_raw_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_sysfs_set_active_low	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_add_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_event	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_sysrq_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_direct_output	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_resource_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	prandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_next	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_dirtied	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes_arch	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	asustek_get_tp_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_codec_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_check_gmii_support	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	__video_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_cpustat	vmlinux	EXPORT_SYMBOL
+0x00000000	ipc_log_context_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_roamed	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_octseq_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	get_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_mkdir_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	tag_pages_for_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_destroy_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_tsk_mgmt_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bread	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ssbi_write	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_s_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_g_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_udata_request	vmlinux	EXPORT_SYMBOL
+0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_register	vmlinux	EXPORT_SYMBOL
+0x00000000	cfb_imageblit	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_cpu_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_base	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_irc_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_ftp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_send	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_iff_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_getfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_remove_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_pt_create	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_suspend_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_set_scratch_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_suspend_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_deliver_cached_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_change	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_release_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_find_chipset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_table_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_master_send	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_free_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inc_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_new1	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_fdget	vmlinux	EXPORT_SYMBOL
+0x00000000	security_task_getsecid	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_uaddr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_local_reserved_ports	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_tiocmset	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_tiocmget	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__umodsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_max_syn_backlog	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_delay_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secid_to_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_mgmt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_read_status	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dithering_property	vmlinux	EXPORT_SYMBOL
+0x00000000	redraw_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reenable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_change	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0x00000000	memdup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	del_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_open	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcie_update_link_speed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_rcu_gp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_suspend_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_close	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memory_pool_node_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_named_open_on_edge	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_socket_put_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_nc_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_field_names	vmlinux	EXPORT_SYMBOL
+0x00000000	tda9887_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_encode_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_tlmm_set_hdrive	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_brk	vmlinux	EXPORT_SYMBOL
+0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_peeraddr2str	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_scale_batt_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_pwm_config_period	vmlinux	EXPORT_SYMBOL
+0x00000000	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	subsystem_restart_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_vreg_set_frequency	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_channel_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_get_channel_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_irq_type	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drop_output	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_unregister_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	__lru_cache_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_execve	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_reset_function_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_read_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_rs_non_canonical	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_event_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_sha1_update	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	system_long_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_common_get_supported_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_resume_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writesb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lzo1x_decompress_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_unmount	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_transform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	roccat_common_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_query_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_prime_add_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	random32	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_lock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_set_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_read_arg	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_handle_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_add_routes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs4_schedule_lease_recovery	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_max	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_resetkey_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	panic_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_tiocmset	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_tiocmget	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic3	vmlinux	EXPORT_SYMBOL
+0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	md5_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ibss_joined	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_count_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_destroy_pipe_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tea5767_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	putname	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_client_update_request	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter_release_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_remove_id	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_report_finger_count	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_disconnect_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pmem_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_num_of_clients	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0x00000000	sha_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	ksize	vmlinux	EXPORT_SYMBOL
+0x00000000	kstat	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_vreg_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_uidiv	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_security	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_del_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_stop_bus_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_truncate_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_iter_peek	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elf_platform	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_debugfs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_remote_source	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smb345_float_volt_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_unregister_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_pause	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_blink	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_register_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__ring_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_use_client	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_redirty	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_normalize_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_expect_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_tx_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_free_64k	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	preempt_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_thaw_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_activate	vmlinux	EXPORT_SYMBOL
+0x00000000	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_brightness_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_tuner_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_get_ion_client	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	on_each_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_set_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock_live_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_pmu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ihold	vmlinux	EXPORT_SYMBOL
+0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qword_addhex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_create_card_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unmap_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_path_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x00000000	videobuf2_to_pmem_contig	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_put	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_add_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_open	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open	vmlinux	EXPORT_SYMBOL
+0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_check_condition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_request_card	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	register_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_tdls_oper_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockd_down	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_reserve_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_register_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_prio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	otg_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	hex2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsWriteStat	vmlinux	EXPORT_SYMBOL
+0x00000000	d_make_root	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_reinit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_update_bits_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_free	vmlinux	EXPORT_SYMBOL
+0x00000000	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_destroy_chain	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_register_patch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_region_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_64k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_64k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_read	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_register	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_single	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_get_intr_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_set_silence	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_dma_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_notify_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_timeline_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	register_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	io_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cfb_fillrect	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_roamed_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regmap_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_register_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__clocksource_updatefreq_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_rfkill_stop_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_netdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcutorture_record_test_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wireless_spy_update	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_destroy_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_present	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_get_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_set_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_write	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_features	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_release	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_accept_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	yield	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_napi_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_claim_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_destroy_modedb	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_init_replay	vmlinux	EXPORT_SYMBOL
+0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_try_assign_helper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_report	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_sb_list_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_init_always	vmlinux	EXPORT_SYMBOL
+0x00000000	d_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_task	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_int32_read	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_page	vmlinux	EXPORT_SYMBOL
+0x00000000	set_h245_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_print_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_class_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	monotonic_to_bootbased	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_queue_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_int32_write	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lz4_decompress	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_del_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
+0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_timeline_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_group_init_legacy_group	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	no_pci_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	init_rs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncmp	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_pageio_reset_read_mds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_anon_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_event_length	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_flow_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_little_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_access_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_le	vmlinux	EXPORT_SYMBOL
+0x00000000	lcm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	empty_aops	vmlinux	EXPORT_SYMBOL
+0x00000000	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_try_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_handle_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_alloc_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlm_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netdevice_notifiers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_usbmidi_input_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_nway_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_add_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_create_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_freezable	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_reclassify_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_width	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_destroy_modelist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writeb_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_crtc_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	d_move	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_idivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_common_sendmsg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_unthrottle_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	request_key_async	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_set_wakeup_capable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_4k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_4k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_configure_link	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_writable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_get_slave_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strstr	vmlinux	EXPORT_SYMBOL
+0x00000000	strchr	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_channel_index	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_new_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	usermodehelper_read_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memcpy_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_get_next	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_set_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_noop	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_get_io_base	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_hwcap	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_release_client	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_gain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_interface_reg_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	take_over_console	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_sanitize	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_do_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsw	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_export	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_mark_declared_memory_occupied	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_ioremap_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_buf_read_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_localaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_set_power_params	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_pptp_hook_exp_gre	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x00000000	FsMoveFile	vmlinux	EXPORT_SYMBOL
+0x00000000	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_global_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_free_clusters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_do_cache_op	vmlinux	EXPORT_SYMBOL
+0x00000000	scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_refresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_register_action	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_autosuspend_expiration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_add_request_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_enable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_debug	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_dreadlock	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_timeline_create	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	task_blkio_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_create_access	vmlinux	EXPORT_SYMBOL
+0x00000000	no_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_set_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_videomode_to_modelist	vmlinux	EXPORT_SYMBOL
+0x00000000	register_resetkey_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_trace_issueibcmds	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_finalize_current_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	capable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_can_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_tv_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	selinux_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_swevent_get_recursion_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_find_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_tuple_to_nlattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	give_up_console	vmlinux	EXPORT_SYMBOL
+0x00000000	getname	vmlinux	EXPORT_SYMBOL
+0x00000000	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_helper_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_platform_widget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_root	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_find_dmt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_regset32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_raw_handler_register	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_unexport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_response_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	batostr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_merge	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_policy_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_big_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	in_lock_functions	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_cqm_pktloss_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_graph_walk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_init_panel_info	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_complete_wifi_ack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_to_bin	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_clock_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_platform_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_smsm_init_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	__muldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_create_data	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_string	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_register_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ecards_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x00000000	FsUmountVol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_set_bond_master	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_request_clock_on	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_givcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pil_force_boot	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_tree_decrease_qlen	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_algo	vmlinux	EXPORT_SYMBOL
+0x00000000	input_scancode_to_scalar	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_get_next_queued_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rq_flush_dcache_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_streams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_get_irq_stat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_cache_only	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_seek	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_host	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_alloc_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_show_logo	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_pan_display	vmlinux	EXPORT_SYMBOL
+0x00000000	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoll_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_new	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_pci_problems	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_get_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_do_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_alloc_size	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_bus_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_sched_scan_stopped	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_poweroff_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_release	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_add_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	printk	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_add_enum	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_lookup_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_switch_role	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_add	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commitdata_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracing_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_policy_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_get_pt_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iw_handler_get_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_single_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtol_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_gtk_rekey_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_has_cap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_fb_v4l2_update	vmlinux	EXPORT_SYMBOL
+0x00000000	setattr_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_probe_status	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_line	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_auto_cluster	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_dequeue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	security_tun_dev_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_ulcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_cold_boot_done	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	dns_query	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_digital_mute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ipc_config_sec_rules	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_calc_rto	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_width	vmlinux	EXPORT_SYMBOL
+0x00000000	fg_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_find	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_read	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	local_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sunrpc_cache_unregister_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_resume_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	__div64_32	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	rawv6_mh_filter_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_unregister_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_coherent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_dbg_commit_data	vmlinux	EXPORT_SYMBOL
+0x00000000	core_get_adsp_version	vmlinux	EXPORT_SYMBOL
+0x00000000	rawv6_mh_filter_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_register_event	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_update_completion_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l4proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_unused_desc_num	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_dummy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_ctrl_clk_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_sync_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsv_pointer_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_smpl_control	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_put_gpuaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_release_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_tunnel_find_nth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_put	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_tuner_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_sys_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_long	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_report_no_dapm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_strdup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_free_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpm_regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_supply_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bsg_register_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_get_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_path_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_disconnect_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_port_softint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_lookup_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_set_low_power_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_wait_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fifo_set_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_pcm_runtime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_device_snapshot_init	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_recseq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ethtool_get_settings	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_resume_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_del_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i2c_encoder_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	css_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_request_find_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_kill_unmapped_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_querybuf	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	device_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_handle_cts_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_handle_dcd_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x00000000	free_inode_nonrcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_pci_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_name	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_open	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_alloc_blkg_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_regulator_get_ocrmask	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_release_kernel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_default_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_decode_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_save_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_and_free_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsMapCluster	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x00000000	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	do_ramdump	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_request_clock_off	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
+0x00000000	release_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_sleep_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_stream_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	bq27541_battery_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_resume_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_calculate_bitrate	vmlinux	EXPORT_SYMBOL
+0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_list_del	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create	vmlinux	EXPORT_SYMBOL
+0x00000000	get_option	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_to_blkio_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unbind_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read	vmlinux	EXPORT_SYMBOL
+0x00000000	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_subsys_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_free_vmalloc_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_transfer_one	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_free	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0x00000000	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_le_ltk_reply	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_dev_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_storage_usb_ids	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_export_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	abort	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_unprot_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_drop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_x_ble	vmlinux	EXPORT_SYMBOL
+0x00000000	FsSetAttr	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_forget	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_free_ablkcipher	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	cfg80211_get_mesh	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	qseecom_start_app	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_insert_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_display	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_process_read_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_dio_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pil_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_card	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_get_logical_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_udp_encap_recv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_find_ltk	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_check_keys_pressed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_bulk_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strtobool	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_private	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_trace_buf_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_core_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_start_reset_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readsb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_set_device_power	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_used_features	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_plane_vaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	write_to_strongly_ordered_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_detect_change	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_debugfs_remove_files	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_timeslice_used	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_get_net	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_freq_attr_scaling_available_freqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_work_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_edid_header_is_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gtf_mode_complex	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__rcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	touch_softlockup_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_subscribe_event	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_input	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_alloc_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ecryptfs_fill_auth_tok	vmlinux	EXPORT_SYMBOL
+0x00000000	register_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_confirm_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_getsarea	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	system_freezing_cnt	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	hidraw_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eeprom_93cx6_multiread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_crtc_set_gamma_size	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addbufs_pci	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_exclusive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek_size	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_update_client	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mangle_path	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_domain_bus_and_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	slhc_toss	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_vm_close	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_conn_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_mkpipe_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda829x_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_axi_portunhalt	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_free_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x00000000	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_alloc_pages_fallback	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_reset_modem	vmlinux	EXPORT_SYMBOL
+0x00000000	membank1_start	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_change_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_insert_item	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_fill_output_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_skb_read_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_putpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_h245_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_register_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_adapter_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_reset_comm	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_keydown_notimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rmnet_netdev_cmp	vmlinux	EXPORT_SYMBOL
+0x00000000	device_init_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	avenrun	vmlinux	EXPORT_SYMBOL
+0x00000000	system_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__arm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_extend_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_calc_max_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_type_names	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_sk_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_get_reserved_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_output_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__do_div64	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_update_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_hsync	vmlinux	EXPORT_SYMBOL
+0x00000000	external_common_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_blank	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_path	vmlinux	EXPORT_SYMBOL
+0x00000000	open_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_find_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_write	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_unsecure_heap_2_0	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_state_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_irda	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_qdisc_flow_control	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	div_s64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	put_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_copy_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_kill_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_is_pipe_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_free_req	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_unlink_rx_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_debugfs_tests_root	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_pending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lg_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_set_noirq	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0x00000000	timed_output_dev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_get_rq_mapinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_set_adcmap_btm_threshold	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_release	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_transparent_scsi_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_order	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_write_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_iris_xo_mode	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_init_file_private	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_plane_init	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_create	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_recv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_default_volatile_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create_enum	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_connector_name	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_tlmm_set_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_task	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_task_reset_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	video_devdata	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_resource_to_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_verify_client	vmlinux	EXPORT_SYMBOL
+0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x00000000	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	getboottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	revert_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_rmap_add	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	__stack_chk_fail	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_proc_new	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_fb_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_bus_dbg_client_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_init_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_can_beacon_sec_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_unregister_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	key_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_amsdu_to_8023s	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_search_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_path	vmlinux	EXPORT_SYMBOL
+0x00000000	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_cl_clear_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	g_verify_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_reset_pwr_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_init_table	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_new_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_info_multi_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_update_link	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic4_3	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_queue_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_scan_remove_block	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_loaded	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_module_init_notifier_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_restart_call	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_load_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_master	vmlinux	EXPORT_SYMBOL
+0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_create	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	free_irq_cpu_rmap	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sysctl	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_status_read	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_deregister_bam_device	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_submit_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	backlight_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_write	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read_from_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic2	vmlinux	EXPORT_SYMBOL
+0x00000000	slimport_is_connected	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_fixed_flag	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_stats_to_stats64	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_dma_sg_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_qdss_alloc_req	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_active_count_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_put_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_vm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_info_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_list_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_set_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__gpio_get_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	percpu_counter_compare	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_put_req	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesw	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesl	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesb	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_wait_for_app_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	msg_encode_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_rename_id	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qseecom_set_bandwidth	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_irq_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_private_object_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_alloc_new_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_iowait_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsb	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_init_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_mc_rejoin_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_update_features	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_imageblit	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_call_function	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_is_supported_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	llist_del_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	int_sqrt	vmlinux	EXPORT_SYMBOL
+0x00000000	dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	system_rev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_syn_flood_action	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_max	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	smb345_config_thermal_charging	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write_file	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ucmpdi2	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_check_secure	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_readable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_check	vmlinux	EXPORT_SYMBOL
+0x00000000	video_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_minor	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_parselist_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_simple_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_del_blkio_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_register_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_map_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_dispose_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	usermodehelper_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_usbmidi_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_continue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	kvfree	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_close	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_find_next_zero_area_off	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_hw_revision	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_file_add	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_unregister_service	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_short	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_tftp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_h225_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	menu_hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	strim	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_write	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_widgets	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_info_create_module_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ecryptfs_get_auth_tok_key	vmlinux	EXPORT_SYMBOL
+0x00000000	vfree	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_open_tsap	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_open_lsap	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_detect_card_removed	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_page_alloc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	exportfs_decode_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	g_make_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_release_rqst_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_match_id	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_run_wake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_alloc_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_action_dump_1	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_get_vmalloc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_lock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_direct_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_setattr	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	cred_to_ucred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_put	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	delayacct_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_clear_noirq	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dma_contig_init_ctx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	sscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_unlock_all_by_ip	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmsvc_unlock_all_by_sb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__breadahead	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_bind_new_program	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pfifo_fast_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_integer	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_raw_read	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_register_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_gpio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_to_xdr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dpcm_can_be_free_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	bstr_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	___ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_nat_mangle_tcp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_dump_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_rpccred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_init_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_state_replay_overflow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_hw_reset_check	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_create_mmap_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_dais	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_unregister_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_g_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_helper_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_request_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_put_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_page_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_buffer_requirements	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_buffer_requirements	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_start_test	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_init_security	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_lmul	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	global_cursor_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_socket_get4_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_socket_get6_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_write	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_start_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sched_get_nr_running_avg	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tuners	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_del_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sw_sync_timeline_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_writel	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_rename_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	write_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_entries_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_free_device	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_edge_to_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_set_retrans_timeout_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_consume_args	vmlinux	EXPORT_SYMBOL
+0x00000000	pppox_unbind_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__modsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__divsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sk_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out	vmlinux	EXPORT_SYMBOL
+0x00000000	get_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__stack_chk_guard	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_clone_cell	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x00000000	security_req_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	get_dcookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_event_raw_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast_filtered	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_cd_gpio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strspn	vmlinux	EXPORT_SYMBOL
+0x00000000	strlen	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_recv_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_configure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_pool_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_common_vm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_enable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_request_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_tp_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_int	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_setup_and_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_generic_bind_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_kernel_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_v7_dcache_clean_area	vmlinux	EXPORT_SYMBOL
+0x00000000	bridge_tunnel_header	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_free_when_closed	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_get_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_edid_block_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_partial_copy_from_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_request_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in_r	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	verify_mem_not_deleted	vmlinux	EXPORT_SYMBOL
+0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pci_quirk_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_simple_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_free_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_prime_fd_to_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_get_config	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_set_config	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cmdbatch_destroy_object	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_release	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nlattr_to_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_unmap_iommu	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_list_concat	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_get_block_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_put_stab	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_printf	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setfns	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_free_host	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_validate_size	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_l2_reinit	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_power_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_dev_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	cleancache_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_cookie_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_flush_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_deflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_trylock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	pfn_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_key_construction	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_set_triggers	vmlinux	EXPORT_SYMBOL
+0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_hoplimit	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_sanitize	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_bus_cl_get_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_seconds	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_fillrect	vmlinux	EXPORT_SYMBOL
+0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_max_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsRemoveFile	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_close_tsap	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_remove_this	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_close_lsap	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_search	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	unuse_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_pwm_rate_set	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_affinity_hint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_handle_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_set_stacking_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clk_set_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_recv_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_global_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_choose_state	vmlinux	EXPORT_SYMBOL
+0x00000000	delete_from_page_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_assoc_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_insert_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree_call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_device_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_get_serial	vmlinux	EXPORT_SYMBOL
+0x00000000	map_page_strongly_ordered	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_close_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_awake	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_attach_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_next_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_change_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_from_user_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_attach_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_kcopyd_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_dcd_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_srb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_streams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_init	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8821_get_irq_stat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_ptpool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_platform_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rotator_imem_free	vmlinux	EXPORT_SYMBOL
+0x00000000	update_region	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_get_route	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_can_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_g_keycode_from_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x00000000	kcrypto_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_vprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_add_global_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_scheduler_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_path_create	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_terminate_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_net_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_scaling_mode_property	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	audit_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_config_pwm_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_alloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_pid_to_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_broadcast_help	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	vzalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_detect_hdmi_monitor	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_wait_async	vmlinux	EXPORT_SYMBOL
+0x00000000	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_register	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_get_first	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_dai_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_read_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_last	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_pool_node_paddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_find_by_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_query_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_format_2string	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_msi_block	vmlinux	EXPORT_SYMBOL
+0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_op_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_register_entity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_add_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_socket_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dma_contig_cleanup_ctx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sw_sync_pt_create	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_print_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_extend_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_get_light	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open_size	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_end_cpu_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_signal_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_snapshot_close	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_share_dma_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_mkpipe_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_warn_nonwc	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpio_install_direct_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_queryctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_lookup_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dio_end_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_check_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_log_status	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_ktime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_check_addressable	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_read_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__refrigerator	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_down	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_hw_rev	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_pointer_write	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_refcnt_read	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_init_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_parse_command_line_for_connector	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_read_object	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_alloc_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_set_value	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_get_value	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ns_type_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_log_fault_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addmap	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_set	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_tdm_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_pci_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	encode_rs8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	enable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	enable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_fd_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create	vmlinux	EXPORT_SYMBOL
+0x00000000	memchr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_hsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_request_add_commit_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_record_enable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_list_pseudoflavors	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_deflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	on_each_cpu_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_update_dst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_valid_rtt_meas	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dev_info_list_del_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoul_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_find_nearest_format	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_write_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_endpoints	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_read_dev_vendor_id	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_le_conn_update	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_kernel_range_noflush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_options_compile	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_alloc_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_bus_to_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	aio_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	unix_outq_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_read_bkops_status	vmlinux	EXPORT_SYMBOL
+0x00000000	slhc_free	vmlinux	EXPORT_SYMBOL
+0x00000000	device_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_add_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_recv_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_prepare_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_coherent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	allocate_contiguous_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_flush_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_clients_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_init_image	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_reservemsg_bw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_process_remove_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_state_cb_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_auth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_data_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_bound_align_image	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_autopm_get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_autopm_put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_cons	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_lcd_pwm_type	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_std_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_add_edid_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_rmap_update	vmlinux	EXPORT_SYMBOL
+0x00000000	strncat	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcat	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_erase_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_set_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_delete_object	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_break	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_scan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_object_change_attribute	vmlinux	EXPORT_SYMBOL
+0x00000000	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_start_head_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcf_em_tree_match	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_Bulk_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	security_release_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_available_features	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timekeeping_inject_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	do_trace_rcu_torture_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_link_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commitdata_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_rpm_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	modem_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_unregister_thermal_mitigation	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_blk_get_packed_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stop_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	locate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_pageio_reset_write_mds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_device_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_memcpy_toio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratnums	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_process_events	vmlinux	EXPORT_SYMBOL
+0x00000000	strcspn	vmlinux	EXPORT_SYMBOL
+0x00000000	twofish_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_signal_events	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_extend	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_parse_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_write_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	pmem_cache_maint	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ut_debug_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_svc_to_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_find_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_force_rebind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_ios	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_skb_return	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_killall_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_iterate_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	buffer_migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_read_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	external_common_state_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_domain_simple_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	armpmu_get_pmu_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_defrag_ipv6_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_defrag_ipv4_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_install	vmlinux	EXPORT_SYMBOL
+0x00000000	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0x00000000	default_red	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_edid_to_monspecs	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_free_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_power_save_host	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_timestamp_write	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_probed_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_complete_power_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_page_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_spi_new_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_mute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	may_umount	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_detach_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_params_to_bclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_hw_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_map_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_find	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_free_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_raw_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_bulk_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_ack_err	vmlinux	EXPORT_SYMBOL
+0x00000000	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_input_params	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0x00000000	net_prio_subsys_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bq27541_wireless_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock_is_held	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_pool_avail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
+0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_shift_arg	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_address	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_fixup_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_probe_func_quick_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_create_bundle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	icq_get_changed	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_free	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_xprt_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_for_each_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_check_link_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_set_block_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_event_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_conntrack_helper_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_unit_number	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_input_error	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_get_ioaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_generic_pg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_init	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_add_virt	vmlinux	EXPORT_SYMBOL
+0x00000000	user_describe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_unregister_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_fmt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_get_val_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_idle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_begin_ordered_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_trans_will_send_data_barrier	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_lookup_machine_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_init	vmlinux	EXPORT_SYMBOL
+0x00000000	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_super	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	__machine_arch_type	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dvi_i_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_create	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_inherit_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_direction_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_disconnected	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_rx_auth	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x00000000	find_font	drivers/video/console/font	EXPORT_SYMBOL
+0x00000000	irda_notify_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_kunmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_cpu_rmap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nlattr_tuple_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_probed_add	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
+0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_hook_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlmsg_put	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_send_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_anon_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rps_sock_flow_table	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_compress_new	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_watchdog_reset_control	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	request_any_context_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pgprot_user	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_table	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	uio_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_lookup_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_unmap_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_buffer_free	vmlinux	EXPORT_SYMBOL
+0x00000000	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_file_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_put	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_streamon	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_claim_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_read	vmlinux	EXPORT_SYMBOL
+0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	key_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_sleep_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_silence_64	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_connect_direct	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_connector_update_edid_property	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	address_space_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_hex_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_replay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_action_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_height	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_mask_receive_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_unplug_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_walk_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_overruns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_load_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_pcm_hw_param_setempty	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_close	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_get_feat_version	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic1	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_clflush_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commit_clear_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ft_event	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_clone_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_device_set_media_busy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_icvfail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_fold_field64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_get_led_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_resolv_usage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_f0_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_ratelimit_state	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_try_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_alloc_mgrports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_register_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_read	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_get_version	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_unprepare	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_l4proto_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_get_subsys_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_put_subsys_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_prune_invalid	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	private_AES_set_encrypt_key	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xc2028_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_default_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_set_ignore_round	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_monotonic_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_text_write_kernel_word	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_set_seq_adjust	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_open	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x00000000	ioc_lookup_icq	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_puts	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_ssr_boot_notify	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_last	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_shared_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_genocide	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_generic_entry_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_report_obss_beacon	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_vegas_cwnd_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_enum_info	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_batt_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crc32c_le	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	d_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	file_open_root	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ashldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmc_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_class	vmlinux	EXPORT_SYMBOL
+0x00000000	__bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_write	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_set_device_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kthread_worker_fn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iw_handler_set_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_set_restart_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	reciprocal_value	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_get_sb_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_get_interface_no_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_init_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_txq	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_register_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cleancache_init_shared_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	set_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_load_default_node	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_generic_walker	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_register_inet_compat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dst_set_noref	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	debug_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ablkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ablkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_queue_pmem_contig_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_chip_data	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_scan_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_set_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_io	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	ecryptfs_get_versions	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getbyhwaddr_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_flow_dissect	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_lut_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_enqueue_cmd_ext	vmlinux	EXPORT_SYMBOL
+0x00000000	wireless_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_put_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_alloc_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_queued_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_nlsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fauxsound_codec_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_driver_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_req_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_remove_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_reinsert_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_cluster_pm_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_completion_killable_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	need_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x00000000	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_to_user_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_dev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_change_mtu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_count	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_set_host_pm_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_ctrl_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_add_wr_rd_test_req	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_streamoff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_share_dma_buf_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_pci_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read_user_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	__dynamic_dev_dbg	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	down	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_add	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	xts_crypt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_llsl	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_dump_icsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_put	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_open	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_in_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_hash_rnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnl_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_set_avscsr	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_get_avscsr	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_unregister_pm_ops	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strnchr	vmlinux	EXPORT_SYMBOL
+0x00000000	dcookie_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_dma_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	strrchr	vmlinux	EXPORT_SYMBOL
+0x00000000	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pingv6_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	dapm_reg_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_constraint_pow2	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_free_mmap_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kernel_param_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dynamic_netdev_dbg	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0x00000000	memscan	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x00000000	write_bytes_to_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_handler_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inet_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtos8	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_current_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	socinfo_get_msm_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_master_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kd_mksound	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_format	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cookie_generator	vmlinux	EXPORT_SYMBOL
+0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	loop_register_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	device_set_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnl_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_set_real_num_tx_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_set_real_num_rx_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_group	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_event	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_insert_node_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	rfc1042_header	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_get_host_pm_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_rpcb_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_stop_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_consume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_free_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_unload_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_print_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_rpcb_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpumask_next_and	vmlinux	EXPORT_SYMBOL
+0x00000000	set_ras_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_hook_slow	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_ident_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4_decompress_unknownoutputsize	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_limit_hw_rates	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_client_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_notfound_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_detect_monitor_audio	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_range_tag_if_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	console_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_match	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrctrl_request_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_check_and_mask_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_domain_xlate_onetwocell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_codec_set_cache_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_system_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_aux_clk_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_expose_latency_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_net_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__trace_bprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_hash_check_insert	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	unix_peer_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_resume_host	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_spi_subdev_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_root_buses	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_syn_ack_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_alloc_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_pad_unaligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_xo_mode_vote	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drain_input	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_register_device_for_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	input_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwrange	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_set_retrans_timeout_def	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_map	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	vzalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_resume_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_poweroff_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_timestamp_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_shutdown_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pppox_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_freezable_should_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_len_r	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_xprt_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_pm_cmpxchg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	div64_s64	vmlinux	EXPORT_SYMBOL
+0x00000000	memparse	vmlinux	EXPORT_SYMBOL
+0x00000000	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_pmksa_candidate_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_shutdown_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	fmem_get_info	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_firmware	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_ext_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_align_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_register_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_get_intf_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_byte_array_write	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_get_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x00000000	default_blu	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
+0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	video_ioctl2	vmlinux	EXPORT_SYMBOL
+0x00000000	input_alloc_absinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_urgent_request	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_preempt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	each_symbol_section	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_query_menu_valid_items	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_pt_free	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_msi_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_connect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_connect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_encode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_process	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_refresh_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_count_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	free_css_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	pwm_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol_no_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_clear_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_get_next	vmlinux	EXPORT_SYMBOL
+0x00000000	fail_migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_suppress_info_printing	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skip_spaces	vmlinux	EXPORT_SYMBOL
+0x00000000	__delay	vmlinux	EXPORT_SYMBOL
+0x00000000	add_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_power_off	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_busnum_to_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_get_gpuaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	user_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdput	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_untracked	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_usual_ignore_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_policy_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_cancel_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos16	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_prepare_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_register	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_get_md	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_cmd_to_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_smpl_set_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bad_xchg	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_delayed_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_debug_printmodeline	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_ablkcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dirty_writeback_interval	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_enable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_no_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_root_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	on_each_cpu_cond	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_mgmt_tx_status	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_make_writable	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_major	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_vcalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0x00000000	__dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_abs_params	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_register_compressor	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_bus_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_edid_is_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_pause_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_le_start_enc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_cable_type_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_map_iommu	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_congested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_alloc2	vmlinux	EXPORT_SYMBOL
+0x00000000	freq_reg_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wake_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_pa_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_secmark_refcount_dec	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secmark_refcount_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_bint	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_null	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_netdevice_many	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_mpp_config_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_platform_init	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_platform_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sunrpc_cache_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_cpu_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	processor_id	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque_fixed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	initialize_memory_pool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_get_event	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regmap_init_spi	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regmap_init_i2c	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_master_get	vmlinux	EXPORT_SYMBOL
+0x00000000	css_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_add_gpios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_dev_fop_read	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_add_event	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x00000000	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_conntrack_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nlmsg_put	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_disable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mmc_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_dump_table	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_remove_node	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_iosched_mark_test_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_security_override	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_subsys_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_cow_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_store_with_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_wren	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_reclaim_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_del	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsReleaseCache	vmlinux	EXPORT_SYMBOL
+0x00000000	kmalloc_order_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	smem_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nat_callforwarding_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_numid	vmlinux	EXPORT_SYMBOL
+0x00000000	tsens_get_sensor_temp	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_get_vma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_offdelay	vmlinux	EXPORT_SYMBOL
+0x00000000	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_last_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_dio_done	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_current_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_ext_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_update_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sort	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_may_send	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_reset_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_work_run	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clockevents_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	req_riva_power_on_lock	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	hci_recv_stream_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_dealloc_mgrports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ddebug_remove_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_tun_dev_post_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_path	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_tristate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_alloc_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	FsReadDir	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_init_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_int	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_suspend_finish	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	data_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_init	vmlinux	EXPORT_SYMBOL
+0x00000000	find_inode_number	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_short	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_byte_array_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_init_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcb_getport_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_unregister_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_input_common	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_unmap_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_uncompress	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	FsGetVolInfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_to_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	softnet_data	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_disconnect_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_fb_info	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipefs_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_memcpy_fromio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_set	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_hotplug_event	vmlinux	EXPORT_SYMBOL
+0x00000000	lcd_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free_parts	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_auth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_save_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_info_register	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	free_contiguous_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_log_wait_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_pcm_hw_params_any	vmlinux	EXPORT_SYMBOL
+0x00000000	user_path_at	vmlinux	EXPORT_SYMBOL
+0x00000000	module_put	vmlinux	EXPORT_SYMBOL
+0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_debug_table	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_new_object	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_helper_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_get_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	llist_add_batch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vbin_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_cd_gpio_request	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_prime_handle_to_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipe_generic_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_unregister_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_search_free_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dget_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_new	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_mmap_data	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_requeue_unmapped_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_ioctl_1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	iunique	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_cancel_events	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fb_phys_info	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_schedule_stateid_recovery	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_mpd_scm_set_algo_params	vmlinux	EXPORT_SYMBOL
+0x00000000	apr_get_q6_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	apr_set_q6_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_card	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_for_each_chunk	vmlinux	EXPORT_SYMBOL
+0x00000000	get_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_current_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_subsystem_unmap_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_bss_get_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_connector_attach_property	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_post_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_renumber_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_pm_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_locked_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usermodehelper_read_lock_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_stop_and_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock_active	vmlinux	EXPORT_SYMBOL
+0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_tuple_taken	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	evict_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipc_log_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_init_cache_detail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	auth_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_phys	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_get_wlan_config	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	rpc_restart_call_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_id	vmlinux	EXPORT_SYMBOL
+0x00000000	__uio_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_end	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_run	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_free	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_err	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_suspend_host	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	add_deserialization_func	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_release_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_indexed_registers	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_release_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_register_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sb_copy_data	vmlinux	EXPORT_SYMBOL
+0x00000000	user_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_define_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	read_bytes_from_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_handle_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_root_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdev_del	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	soft_cursor	drivers/video/console/softcursor	EXPORT_SYMBOL
+0x00000000	tcp_seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_alloc_dma_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_get	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_addsock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_expect_related_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pskb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_transfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_io	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x00000000	__clocksource_register_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timed_output_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_dev_present	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_cmd_blk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_old_inode_init_security	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hashbin_lock_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit	vmlinux	EXPORT_SYMBOL
+0x00000000	strcat	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_release	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	msg_encode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_log_status	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kunmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_pt_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_prepare_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_dma_contig_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0x00000000	__trace_printk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_video_std_construct	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_defer_kevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ewma_init	vmlinux	EXPORT_SYMBOL
+0x00000000	key_put	vmlinux	EXPORT_SYMBOL
+0x00000000	bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kmemdup	vmlinux	EXPORT_SYMBOL
+0x00000000	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_copy_from_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_disable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slimport_get_link_bw	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_snapshot_get_object	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_vrefresh	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_set_crtcinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda827x_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_setup_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_fd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_list	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_align_data_size	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_connect_src	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	save_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_compress_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_set_fault_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_unregister_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_register_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_alloc_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_snapshot	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_timestamp_precision	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cnew	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x00000000	default_grn	vmlinux	EXPORT_SYMBOL
+0x00000000	ioc_cgroup_changed	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_update_bits_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_linear	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create_range	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_get_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_dma_get_bam_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ablkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fget_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_unprot_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	backlight_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_blocked	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_flush_queueable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpm_regulator_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_riva_power_on_lock	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xdr_init_decode_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_ktime_to_tm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_pre_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_bulk_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_clock_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_default_font	drivers/video/console/font	EXPORT_SYMBOL
+0x00000000	wcnss_register_thermal_mitigation	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	regulator_bulk_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_getavg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_pm_wait_for_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ion_secure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_setup_bam2bam_fifo	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_alloc_aligned	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_io_remove_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_suspend_all	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_unsecure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_request_change_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_parse_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_write	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smb345_otg_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_data_to_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_accept_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_startup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_protocol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_is_requested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_allocated_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_equiv_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_lock_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_set_adcmap_pa_therm	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_debugfs_utils_root	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_get_cbits_tohost	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcg_socket_limit_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_mhl_supported_video_mode_lut	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_idle_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_hash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_pad_aligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_handle_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new_soc_be	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_unsubscribe_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_cur_packet_size	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_queue_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_request_clear_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_sys_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_prio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_find_cea_extension	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_request_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_online	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vprintk	vmlinux	EXPORT_SYMBOL
+0x00000000	__udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ssbi_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vsprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	adreno_dump_fields	vmlinux	EXPORT_SYMBOL
+0x00000000	ddebug_add_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_task_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_output_params	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_htable_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_end	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_reset_modem_cont	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_dxe_tx_irq	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_dxe_rx_irq	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	need_ipv4_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_scan_add_block	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__timecompare_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_dma_in_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_register_core	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_insert_object	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_trace_regwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pm_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x00000000	free_user_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	clkdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	strcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_unlock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_sense_invalidCDB	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_buffer_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	key_payload_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pet_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_insert_dying_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_abort_conn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	node_states	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_sched_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_lookup_minor_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_add_ancestor_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_auth_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x00000000	regulatory_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_start_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_mixer_update_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gspca_auto_gain_n_exposure	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_link	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_unsecure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	full_name_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_release	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_destroy_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_free_resource_list	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_apply_custom_regulatory	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_get_md	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_getattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_lookup_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_lookup_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_check	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	pil_get	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_unmerge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracepoint_probe_unregister_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_put_minor	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_calc_timestamping_constants	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secctx_to_secid	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_peer_xrlim_allow	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_put	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_decode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_list_update	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_get_sample_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	textsearch_register	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_is_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_max_cpus	vmlinux	EXPORT_SYMBOL
+0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	create_ctx_debugfs	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_get_discoveries	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_expect_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_generic_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_get_rxhash	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_find_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsCreateDir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_map	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_dirty_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_sg_table	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_core_ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pil_register	vmlinux	EXPORT_SYMBOL
+0x00000000	_set_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_start_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_copy_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	freezing_slow_path	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_qos_bits_to_value	vmlinux	EXPORT_SYMBOL
+0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	key_update	vmlinux	EXPORT_SYMBOL
+0x00000000	socinfo_get_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_mux_update_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_init_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_free_one	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_free_count	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_send_ext_csd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_set_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_commit_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_read_finish	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ftrace_print_flags_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	km_query	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rwsem_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	check_and_create_debugfs	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_create	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_get_memory_usage	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoint	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_raw_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_return_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_pool_stats_open	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_pid_info_as_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_rate_to_rate_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_load_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_device	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	pci_lost_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_queue_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_dma_out_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_unexpected_4addr_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_vmalloc_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	totalhigh_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	soc_dpcm_be_dai_trigger	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_get_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_standard_install	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_michael_mic_failure	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_get_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_allow_suspend	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_object_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_request_remove_commit_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_queue_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pptp_msg_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_codec_widget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_event_states	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
+0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_value	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_asc	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_time_unix2fat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_state_cb_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_follow_master	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_dev_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_oldest_event_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_import_dma_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_delayed_deinit	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_peeraddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_put_instance	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_get_instance	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_cacheline_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_bam_debug_info	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_tlmm_config	vmlinux	EXPORT_SYMBOL
+0x00000000	crc32c	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_freewait	vmlinux	EXPORT_SYMBOL
+0x00000000	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_create_on_node	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_v7_set_pte_ext	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_pause	vmlinux	EXPORT_SYMBOL
+0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ref_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_pptp_hook_outbound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_legacy_fb_format	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wakeup_notification	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_hits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_t120_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_config_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_send_acl	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_irdadev	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sk_diag_fill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arpt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_direction_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x00000000	vmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmap_atomic_idx	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	AES_encrypt	vmlinux	EXPORT_SYMBOL
diff -urN flo-ElementalX-5.00/arch/alpha/kernel/smc37c669.c flo-ElementalX-5.00-patched/arch/alpha/kernel/smc37c669.c
--- flo-ElementalX-5.00/arch/alpha/kernel/smc37c669.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/alpha/kernel/smc37c669.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,2553 +0,0 @@
-/*
- * SMC 37C669 initialization code
- */
-#include <linux/kernel.h>
-
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-
-#include <asm/hwrpb.h>
-#include <asm/io.h>
-#include <asm/segment.h>
-
-#if 0
-# define DBG_DEVS(args)         printk args
-#else
-# define DBG_DEVS(args)
-#endif
-
-#define KB              1024
-#define MB              (1024*KB)
-#define GB              (1024*MB)
-
-#define SMC_DEBUG   0
-
-/* File:	smcc669_def.h
- *
- * Copyright (C) 1997 by
- * Digital Equipment Corporation, Maynard, Massachusetts.
- * All rights reserved.
- *
- * This software is furnished under a license and may be used and copied
- * only  in  accordance  of  the  terms  of  such  license  and with the
- * inclusion of the above copyright notice. This software or  any  other
- * copies thereof may not be provided or otherwise made available to any
- * other person.  No title to and  ownership of the  software is  hereby
- * transferred.
- *
- * The information in this software is  subject to change without notice
- * and  should  not  be  construed  as a commitment by Digital Equipment
- * Corporation.
- *
- * Digital assumes no responsibility for the use  or  reliability of its
- * software on equipment which is not supplied by Digital.
- *
- *
- * Abstract:	
- *
- *	This file contains header definitions for the SMC37c669 
- *	Super I/O controller. 
- *
- * Author:	
- *
- *	Eric Rasmussen
- *
- * Modification History:
- *
- *	er	28-Jan-1997	Initial Entry
- */
-
-#ifndef __SMC37c669_H
-#define __SMC37c669_H
-
-/*
-** Macros for handling device IRQs
-**
-** The mask acts as a flag used in mapping actual ISA IRQs (0 - 15) 
-** to device IRQs (A - H).
-*/
-#define SMC37c669_DEVICE_IRQ_MASK	0x80000000
-#define SMC37c669_DEVICE_IRQ( __i )	\
-	((SMC37c669_DEVICE_IRQ_MASK) | (__i))
-#define SMC37c669_IS_DEVICE_IRQ(__i)	\
-	(((__i) & (SMC37c669_DEVICE_IRQ_MASK)) == (SMC37c669_DEVICE_IRQ_MASK))
-#define SMC37c669_RAW_DEVICE_IRQ(__i)	\
-	((__i) & ~(SMC37c669_DEVICE_IRQ_MASK))
-
-/*
-** Macros for handling device DRQs
-**
-** The mask acts as a flag used in mapping actual ISA DMA
-** channels to device DMA channels (A - C).
-*/
-#define SMC37c669_DEVICE_DRQ_MASK	0x80000000
-#define SMC37c669_DEVICE_DRQ(__d)	\
-	((SMC37c669_DEVICE_DRQ_MASK) | (__d))
-#define SMC37c669_IS_DEVICE_DRQ(__d)	\
-	(((__d) & (SMC37c669_DEVICE_DRQ_MASK)) == (SMC37c669_DEVICE_DRQ_MASK))
-#define SMC37c669_RAW_DEVICE_DRQ(__d)	\
-	((__d) & ~(SMC37c669_DEVICE_DRQ_MASK))
-
-#define SMC37c669_DEVICE_ID	0x3
-
-/*
-** SMC37c669 Device Function Definitions
-*/
-#define SERIAL_0	0
-#define SERIAL_1	1
-#define PARALLEL_0	2
-#define FLOPPY_0	3
-#define IDE_0		4
-#define NUM_FUNCS	5
-
-/*
-** Default Device Function Mappings
-*/
-#define COM1_BASE	0x3F8
-#define COM1_IRQ	4
-#define COM2_BASE	0x2F8
-#define COM2_IRQ	3
-#define PARP_BASE	0x3BC
-#define PARP_IRQ	7
-#define PARP_DRQ	3
-#define FDC_BASE	0x3F0
-#define FDC_IRQ		6
-#define FDC_DRQ		2
-
-/*
-** Configuration On/Off Key Definitions
-*/
-#define SMC37c669_CONFIG_ON_KEY		0x55
-#define SMC37c669_CONFIG_OFF_KEY	0xAA
-
-/*
-** SMC 37c669 Device IRQs
-*/
-#define SMC37c669_DEVICE_IRQ_A	    ( SMC37c669_DEVICE_IRQ( 0x01 ) )
-#define SMC37c669_DEVICE_IRQ_B	    ( SMC37c669_DEVICE_IRQ( 0x02 ) )
-#define SMC37c669_DEVICE_IRQ_C	    ( SMC37c669_DEVICE_IRQ( 0x03 ) )
-#define SMC37c669_DEVICE_IRQ_D	    ( SMC37c669_DEVICE_IRQ( 0x04 ) )
-#define SMC37c669_DEVICE_IRQ_E	    ( SMC37c669_DEVICE_IRQ( 0x05 ) )
-#define SMC37c669_DEVICE_IRQ_F	    ( SMC37c669_DEVICE_IRQ( 0x06 ) )
-/*      SMC37c669_DEVICE_IRQ_G	    *** RESERVED ***/
-#define SMC37c669_DEVICE_IRQ_H	    ( SMC37c669_DEVICE_IRQ( 0x08 ) )
-
-/*
-** SMC 37c669 Device DMA Channel Definitions
-*/
-#define SMC37c669_DEVICE_DRQ_A		    ( SMC37c669_DEVICE_DRQ( 0x01 ) )
-#define SMC37c669_DEVICE_DRQ_B		    ( SMC37c669_DEVICE_DRQ( 0x02 ) )
-#define SMC37c669_DEVICE_DRQ_C		    ( SMC37c669_DEVICE_DRQ( 0x03 ) )
-
-/*
-** Configuration Register Index Definitions
-*/
-#define SMC37c669_CR00_INDEX	    0x00
-#define SMC37c669_CR01_INDEX	    0x01
-#define SMC37c669_CR02_INDEX	    0x02
-#define SMC37c669_CR03_INDEX	    0x03
-#define SMC37c669_CR04_INDEX	    0x04
-#define SMC37c669_CR05_INDEX	    0x05
-#define SMC37c669_CR06_INDEX	    0x06
-#define SMC37c669_CR07_INDEX	    0x07
-#define SMC37c669_CR08_INDEX	    0x08
-#define SMC37c669_CR09_INDEX	    0x09
-#define SMC37c669_CR0A_INDEX	    0x0A
-#define SMC37c669_CR0B_INDEX	    0x0B
-#define SMC37c669_CR0C_INDEX	    0x0C
-#define SMC37c669_CR0D_INDEX	    0x0D
-#define SMC37c669_CR0E_INDEX	    0x0E
-#define SMC37c669_CR0F_INDEX	    0x0F
-#define SMC37c669_CR10_INDEX	    0x10
-#define SMC37c669_CR11_INDEX	    0x11
-#define SMC37c669_CR12_INDEX	    0x12
-#define SMC37c669_CR13_INDEX	    0x13
-#define SMC37c669_CR14_INDEX	    0x14
-#define SMC37c669_CR15_INDEX	    0x15
-#define SMC37c669_CR16_INDEX	    0x16
-#define SMC37c669_CR17_INDEX	    0x17
-#define SMC37c669_CR18_INDEX	    0x18
-#define SMC37c669_CR19_INDEX	    0x19
-#define SMC37c669_CR1A_INDEX	    0x1A
-#define SMC37c669_CR1B_INDEX	    0x1B
-#define SMC37c669_CR1C_INDEX	    0x1C
-#define SMC37c669_CR1D_INDEX	    0x1D
-#define SMC37c669_CR1E_INDEX	    0x1E
-#define SMC37c669_CR1F_INDEX	    0x1F
-#define SMC37c669_CR20_INDEX	    0x20
-#define SMC37c669_CR21_INDEX	    0x21
-#define SMC37c669_CR22_INDEX	    0x22
-#define SMC37c669_CR23_INDEX	    0x23
-#define SMC37c669_CR24_INDEX	    0x24
-#define SMC37c669_CR25_INDEX	    0x25
-#define SMC37c669_CR26_INDEX	    0x26
-#define SMC37c669_CR27_INDEX	    0x27
-#define SMC37c669_CR28_INDEX	    0x28
-#define SMC37c669_CR29_INDEX	    0x29
-
-/*
-** Configuration Register Alias Definitions
-*/
-#define SMC37c669_DEVICE_ID_INDEX		    SMC37c669_CR0D_INDEX
-#define SMC37c669_DEVICE_REVISION_INDEX		    SMC37c669_CR0E_INDEX
-#define SMC37c669_FDC_BASE_ADDRESS_INDEX	    SMC37c669_CR20_INDEX
-#define SMC37c669_IDE_BASE_ADDRESS_INDEX	    SMC37c669_CR21_INDEX
-#define SMC37c669_IDE_ALTERNATE_ADDRESS_INDEX	    SMC37c669_CR22_INDEX
-#define SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX	    SMC37c669_CR23_INDEX
-#define SMC37c669_SERIAL0_BASE_ADDRESS_INDEX	    SMC37c669_CR24_INDEX
-#define SMC37c669_SERIAL1_BASE_ADDRESS_INDEX	    SMC37c669_CR25_INDEX
-#define SMC37c669_PARALLEL_FDC_DRQ_INDEX	    SMC37c669_CR26_INDEX
-#define SMC37c669_PARALLEL_FDC_IRQ_INDEX	    SMC37c669_CR27_INDEX
-#define SMC37c669_SERIAL_IRQ_INDEX		    SMC37c669_CR28_INDEX
-
-/*
-** Configuration Register Definitions
-**
-** The INDEX (write only) and DATA (read/write) ports are effective 
-** only when the chip is in the Configuration State.
-*/
-typedef struct _SMC37c669_CONFIG_REGS {
-    unsigned char index_port;
-    unsigned char data_port;
-} SMC37c669_CONFIG_REGS;
-
-/*
-** CR00 - default value 0x28
-**
-**  IDE_EN (CR00<1:0>):
-**	0x - 30ua pull-ups on nIDEEN, nHDCS0, NHDCS1
-**	11 - IRQ_H available as IRQ output,
-**	     IRRX2, IRTX2 available as alternate IR pins
-**	10 - nIDEEN, nHDCS0, nHDCS1 used to control IDE
-**
-**  VALID (CR00<7>):
-**	A high level on this software controlled bit can
-**	be used to indicate that a valid configuration
-**	cycle has occurred.  The control software must
-**	take care to set this bit at the appropriate times.
-**	Set to zero after power up.  This bit has no
-**	effect on any other hardware in the chip.
-**
-*/
-typedef union _SMC37c669_CR00 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ide_en : 2;	    /* See note above		*/
-	unsigned reserved1 : 1;	    /* RAZ			*/
-	unsigned fdc_pwr : 1;	    /* 1 = supply power to FDC  */
-	unsigned reserved2 : 3;	    /* Read as 010b		*/
-	unsigned valid : 1;	    /* See note above		*/
-    }	by_field;
-} SMC37c669_CR00;
-
-/*
-** CR01 - default value 0x9C
-*/
-typedef union _SMC37c669_CR01 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned reserved1 : 2;	    /* RAZ			    */
-	unsigned ppt_pwr : 1;	    /* 1 = supply power to PPT	    */
-	unsigned ppt_mode : 1;	    /* 1 = Printer mode, 0 = EPP    */
-	unsigned reserved2 : 1;	    /* Read as 1		    */
-	unsigned reserved3 : 2;	    /* RAZ			    */
-	unsigned lock_crx: 1;	    /* Lock CR00 - CR18		    */
-    }	by_field;
-} SMC37c669_CR01;
-
-/*
-** CR02 - default value 0x88
-*/
-typedef union _SMC37c669_CR02 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned reserved1 : 3;	    /* RAZ			    */
-	unsigned uart1_pwr : 1;	    /* 1 = supply power to UART1    */
-	unsigned reserved2 : 3;	    /* RAZ			    */
-	unsigned uart2_pwr : 1;	    /* 1 = supply power to UART2    */
-    }	by_field;
-} SMC37c669_CR02;
-
-/*
-** CR03 - default value 0x78
-**
-**  CR03<7>	CR03<2>	    Pin 94
-**  -------	-------	    ------
-**     0	   X	    DRV2 (input)
-**     1	   0	    ADRX
-**     1	   1	    IRQ_B
-**
-**  CR03<6>	CR03<5>	    Op Mode
-**  -------	-------	    -------
-**     0	   0	    Model 30
-**     0	   1	    PS/2
-**     1	   0	    Reserved
-**     1	   1	    AT Mode
-*/
-typedef union _SMC37c669_CR03 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned pwrgd_gamecs : 1;  /* 1 = PWRGD, 0 = GAMECS	    */
-	unsigned fdc_mode2 : 1;	    /* 1 = Enhanced Mode 2	    */
-	unsigned pin94_0 : 1;	    /* See note above		    */
-	unsigned reserved1 : 1;	    /* RAZ			    */
-	unsigned drvden : 1;	    /* 1 = high, 0 - output	    */
-	unsigned op_mode : 2;	    /* See note above		    */
-	unsigned pin94_1 : 1;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR03;
-
-/*
-** CR04 - default value 0x00
-**
-**  PP_EXT_MODE:
-**	If CR01<PP_MODE> = 0 and PP_EXT_MODE =
-**	    00 - Standard and Bidirectional
-**	    01 - EPP mode and SPP
-**	    10 - ECP mode
-**		 In this mode, 2 drives can be supported
-**		 directly, 3 or 4 drives must use external
-**		 4 drive support.  SPP can be selected
-**		 through the ECR register of ECP as mode 000.
-**	    11 - ECP mode and EPP mode
-**		 In this mode, 2 drives can be supported
-**		 directly, 3 or 4 drives must use external
-**		 4 drive support.  SPP can be selected
-**		 through the ECR register of ECP as mode 000.
-**		 In this mode, EPP can be selected through
-**		 the ECR register of ECP as mode 100.
-**
-**  PP_FDC:
-**	00 - Normal
-**	01 - PPFD1
-**	10 - PPFD2
-**	11 - Reserved
-**
-**  MIDI1:
-**	Serial Clock Select: 
-**	    A low level on this bit disables MIDI support,
-**	    clock = divide by 13.  A high level on this 
-**	    bit enables MIDI support, clock = divide by 12.
-**
-**	MIDI operates at 31.25 Kbps which can be derived 
-**	from 125 KHz (24 MHz / 12 = 2 MHz, 2 MHz / 16 = 125 KHz)
-**
-**  ALT_IO:
-**	0 - Use pins IRRX, IRTX
-**	1 - Use pins IRRX2, IRTX2
-**
-**	If this bit is set, the IR receive and transmit
-**	functions will not be available on pins 25 and 26
-**	unless CR00<IDE_EN> = 11.
-*/
-typedef union _SMC37c669_CR04 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ppt_ext_mode : 2;  /* See note above		    */
-	unsigned ppt_fdc : 2;	    /* See note above		    */
-	unsigned midi1 : 1;	    /* See note above		    */
-	unsigned midi2 : 1;	    /* See note above		    */
-	unsigned epp_type : 1;	    /* 0 = EPP 1.9, 1 = EPP 1.7	    */
-	unsigned alt_io : 1;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR04;
-
-/*
-** CR05 - default value 0x00
-**
-**  DEN_SEL:
-**	00 - Densel output normal
-**	01 - Reserved
-**	10 - Densel output 1
-**	11 - Densel output 0
-**
-*/
-typedef union _SMC37c669_CR05 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned reserved1 : 2;	    /* RAZ					*/
-	unsigned fdc_dma_mode : 1;  /* 0 = burst, 1 = non-burst			*/
-	unsigned den_sel : 2;	    /* See note above				*/
-	unsigned swap_drv : 1;	    /* Swap the FDC motor selects		*/
-	unsigned extx4 : 1;	    /* 0 = 2 drive, 1 = external 4 drive decode	*/
-	unsigned reserved2 : 1;	    /* RAZ					*/
-    }	by_field;
-} SMC37c669_CR05;
-
-/*
-** CR06 - default value 0xFF
-*/
-typedef union _SMC37c669_CR06 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned floppy_a : 2;	    /* Type of floppy drive A	    */
-	unsigned floppy_b : 2;	    /* Type of floppy drive B	    */
-	unsigned floppy_c : 2;	    /* Type of floppy drive C	    */
-	unsigned floppy_d : 2;	    /* Type of floppy drive D	    */
-    }	by_field;
-} SMC37c669_CR06;
-
-/*
-** CR07 - default value 0x00
-**
-**  Auto Power Management CR07<7:4>:
-**	0 - Auto Powerdown disabled (default)
-**	1 - Auto Powerdown enabled
-**
-**	This bit is reset to the default state by POR or
-**	a hardware reset.
-**
-*/
-typedef union _SMC37c669_CR07 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned floppy_boot : 2;   /* 0 = A:, 1 = B:		    */
-	unsigned reserved1 : 2;	    /* RAZ			    */
-	unsigned ppt_en : 1;	    /* See note above		    */
-	unsigned uart1_en : 1;	    /* See note above		    */
-	unsigned uart2_en : 1;	    /* See note above		    */
-	unsigned fdc_en : 1;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR07;
-
-/*
-** CR08 - default value 0x00
-*/
-typedef union _SMC37c669_CR08 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 4;	    /* 0			    */
-	unsigned addrx7_4 : 4;	    /* ADR<7:3> for ADRx decode	    */
-    }	by_field;
-} SMC37c669_CR08;
-
-/*
-** CR09 - default value 0x00
-**
-**  ADRx_CONFIG:
-**	00 - ADRx disabled
-**	01 - 1 byte decode A<3:0> = 0000b
-**	10 - 8 byte block decode A<3:0> = 0XXXb
-**	11 - 16 byte block decode A<3:0> = XXXXb
-**
-*/
-typedef union _SMC37c669_CR09 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned adra8 : 3;	    /* ADR<10:8> for ADRx decode    */
-	unsigned reserved1 : 3;
-	unsigned adrx_config : 2;   /* See note above		    */
-    }	by_field;
-} SMC37c669_CR09;
-
-/*
-** CR0A - default value 0x00
-*/
-typedef union _SMC37c669_CR0A {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ecp_fifo_threshold : 4;
-	unsigned reserved1 : 4;
-    }	by_field;
-} SMC37c669_CR0A;
-
-/*
-** CR0B - default value 0x00
-*/
-typedef union _SMC37c669_CR0B {
-    unsigned char as_uchar;
-    struct {
-    	unsigned fdd0_drtx : 2;	    /* FDD0 Data Rate Table	    */
-	unsigned fdd1_drtx : 2;	    /* FDD1 Data Rate Table	    */
-	unsigned fdd2_drtx : 2;	    /* FDD2 Data Rate Table	    */
-	unsigned fdd3_drtx : 2;	    /* FDD3 Data Rate Table	    */
-    }	by_field;
-} SMC37c669_CR0B;
-
-/*
-** CR0C - default value 0x00
-**
-**  UART2_MODE:
-**	000 - Standard (default)
-**	001 - IrDA (HPSIR)
-**	010 - Amplitude Shift Keyed IR @500 KHz
-**	011 - Reserved
-**	1xx - Reserved
-**
-*/
-typedef union _SMC37c669_CR0C {
-    unsigned char as_uchar;
-    struct {
-    	unsigned uart2_rcv_polarity : 1;    /* 1 = invert RX		*/
-	unsigned uart2_xmit_polarity : 1;   /* 1 = invert TX		*/
-	unsigned uart2_duplex : 1;	    /* 1 = full, 0 = half	*/
-	unsigned uart2_mode : 3;	    /* See note above		*/
-	unsigned uart1_speed : 1;	    /* 1 = high speed enabled	*/
-	unsigned uart2_speed : 1;	    /* 1 = high speed enabled	*/
-    }	by_field;
-} SMC37c669_CR0C;
-
-/*
-** CR0D - default value 0x03
-**
-**  Device ID Register - read only
-*/
-typedef union _SMC37c669_CR0D {
-    unsigned char as_uchar;
-    struct {
-    	unsigned device_id : 8;	    /* Returns 0x3 in this field    */
-    }	by_field;
-} SMC37c669_CR0D;
-
-/*
-** CR0E - default value 0x02
-**
-**  Device Revision Register - read only
-*/
-typedef union _SMC37c669_CR0E {
-    unsigned char as_uchar;
-    struct {
-    	unsigned device_rev : 8;    /* Returns 0x2 in this field    */
-    }	by_field;
-} SMC37c669_CR0E;
-
-/*
-** CR0F - default value 0x00
-*/
-typedef union _SMC37c669_CR0F {
-    unsigned char as_uchar;
-    struct {
-    	unsigned test0 : 1;	    /* Reserved - set to 0	    */
-	unsigned test1 : 1;	    /* Reserved - set to 0	    */
-	unsigned test2 : 1;	    /* Reserved - set to 0	    */
-	unsigned test3 : 1;	    /* Reserved - set t0 0	    */
-	unsigned test4 : 1;	    /* Reserved - set to 0	    */
-	unsigned test5 : 1;	    /* Reserved - set t0 0	    */
-	unsigned test6 : 1;	    /* Reserved - set t0 0	    */
-	unsigned test7 : 1;	    /* Reserved - set to 0	    */
-    }	by_field;
-} SMC37c669_CR0F;
-
-/*
-** CR10 - default value 0x00
-*/
-typedef union _SMC37c669_CR10 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned reserved1 : 3;	     /* RAZ			    */
-	unsigned pll_gain : 1;	     /* 1 = 3V, 2 = 5V operation    */
-	unsigned pll_stop : 1;	     /* 1 = stop PLLs		    */
-	unsigned ace_stop : 1;	     /* 1 = stop UART clocks	    */
-	unsigned pll_clock_ctrl : 1; /* 0 = 14.318 MHz, 1 = 24 MHz  */
-	unsigned ir_test : 1;	     /* Enable IR test mode	    */
-    }	by_field;
-} SMC37c669_CR10;
-
-/*
-** CR11 - default value 0x00
-*/
-typedef union _SMC37c669_CR11 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ir_loopback : 1;   /* Internal IR loop back		    */
-	unsigned test_10ms : 1;	    /* Test 10ms autopowerdown FDC timeout  */
-	unsigned reserved1 : 6;	    /* RAZ				    */
-    }	by_field;
-} SMC37c669_CR11;
-
-/*
-** CR12 - CR1D are reserved registers
-*/
-
-/*
-** CR1E - default value 0x80
-**
-**  GAMECS:
-**	00 - GAMECS disabled
-**	01 - 1 byte decode ADR<3:0> = 0001b
-**	10 - 8 byte block decode ADR<3:0> = 0XXXb
-**	11 - 16 byte block decode ADR<3:0> = XXXXb
-**
-*/
-typedef union _SMC37c66_CR1E {
-    unsigned char as_uchar;
-    struct {
-    	unsigned gamecs_config: 2;   /* See note above		    */
-	unsigned gamecs_addr9_4 : 6; /* GAMECS Addr<9:4>	    */
-    }	by_field;
-} SMC37c669_CR1E;
-
-/*
-** CR1F - default value 0x00
-**
-**  DT0 DT1 DRVDEN0 DRVDEN1 Drive Type
-**  --- --- ------- ------- ----------
-**   0   0  DENSEL  DRATE0  4/2/1 MB 3.5"
-**                          2/1 MB 5.25"
-**                          2/1.6/1 MB 3.5" (3-mode)
-**   0   1  DRATE1  DRATE0
-**   1   0  nDENSEL DRATE0  PS/2
-**   1   1  DRATE0  DRATE1
-**
-**  Note: DENSEL, DRATE1, and DRATE0 map onto two output
-**	  pins - DRVDEN0 and DRVDEN1.
-**
-*/
-typedef union _SMC37c669_CR1F {
-    unsigned char as_uchar;
-    struct {
-    	unsigned fdd0_drive_type : 2;	/* FDD0 drive type	    */
-	unsigned fdd1_drive_type : 2;	/* FDD1 drive type	    */
-	unsigned fdd2_drive_type : 2;	/* FDD2 drive type	    */
-	unsigned fdd3_drive_type : 2;	/* FDD3 drive type	    */
-    }	by_field;
-} SMC37c669_CR1F;
-
-/*
-** CR20 - default value 0x3C
-**
-**  FDC Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0, A<3:0> = 0XXXb to access.
-**
-*/
-typedef union _SMC37c669_CR20 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 2;	    /* 0			    */
-	unsigned addr9_4 : 6;	    /* FDC Addr<9:4>		    */
-    }	by_field;
-} SMC37c669_CR20;
-
-/*
-** CR21 - default value 0x3C
-**
-**  IDE Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0, A<3:0> = 0XXXb to access.
-**
-*/
-typedef union _SMC37c669_CR21 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 2;	    /* 0			    */
-	unsigned addr9_4 : 6;	    /* IDE Addr<9:4>		    */
-    }	by_field;
-} SMC37c669_CR21;
-
-/*
-** CR22 - default value 0x3D
-**
-**  IDE Alternate Status Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0, A<3:0> = 0110b to access.
-**
-*/
-typedef union _SMC37c669_CR22 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 2;	    /* 0			    */
-	unsigned addr9_4 : 6;	    /* IDE Alt Status Addr<9:4>	    */
-    }	by_field;
-} SMC37c669_CR22;
-
-/*
-** CR23 - default value 0x00
-**
-**  Parallel Port Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0 to access.
-**	- If EPP is enabled, A<2:0> = XXXb to access.
-**	  If EPP is NOT enabled, A<1:0> = XXb to access
-**
-*/
-typedef union _SMC37c669_CR23 {
-    unsigned char as_uchar;
-    struct {
-	unsigned addr9_2 : 8;	    /* Parallel Port Addr<9:2>	    */
-    }	by_field;
-} SMC37c669_CR23;
-
-/*
-** CR24 - default value 0x00
-**
-**  UART1 Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0, A<2:0> = XXXb to access.
-**
-*/
-typedef union _SMC37c669_CR24 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 1;	    /* 0			    */
-	unsigned addr9_3 : 7;	    /* UART1 Addr<9:3>		    */
-    }	by_field;
-} SMC37c669_CR24;
-
-/*
-** CR25 - default value 0x00
-**
-**  UART2 Base Address Register
-**	- To disable this decode set Addr<9:8> = 0
-**	- A<10> = 0, A<2:0> = XXXb to access.
-**
-*/
-typedef union _SMC37c669_CR25 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned zero : 1;	    /* 0			    */
-	unsigned addr9_3 : 7;	    /* UART2 Addr<9:3>		    */
-    }	by_field;
-} SMC37c669_CR25;
-
-/*
-** CR26 - default value 0x00
-**
-**  Parallel Port / FDC DMA Select Register
-**
-**  D3 - D0	  DMA
-**  D7 - D4	Selected
-**  -------	--------
-**   0000	 None
-**   0001	 DMA_A
-**   0010	 DMA_B
-**   0011	 DMA_C
-**
-*/
-typedef union _SMC37c669_CR26 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ppt_drq : 4;	    /* See note above		    */
-	unsigned fdc_drq : 4;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR26;
-
-/*
-** CR27 - default value 0x00
-**
-**  Parallel Port / FDC IRQ Select Register
-**
-**  D3 - D0	  IRQ
-**  D7 - D4	Selected
-**  -------	--------
-**   0000	 None
-**   0001	 IRQ_A
-**   0010	 IRQ_B
-**   0011	 IRQ_C
-**   0100	 IRQ_D
-**   0101	 IRQ_E
-**   0110	 IRQ_F
-**   0111	 Reserved
-**   1000	 IRQ_H
-**
-**  Any unselected IRQ REQ is in tristate
-**
-*/
-typedef union _SMC37c669_CR27 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned ppt_irq : 4;	    /* See note above		    */
-	unsigned fdc_irq : 4;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR27;
-
-/*
-** CR28 - default value 0x00
-**
-**  UART IRQ Select Register
-**
-**  D3 - D0	  IRQ
-**  D7 - D4	Selected
-**  -------	--------
-**   0000	 None
-**   0001	 IRQ_A
-**   0010	 IRQ_B
-**   0011	 IRQ_C
-**   0100	 IRQ_D
-**   0101	 IRQ_E
-**   0110	 IRQ_F
-**   0111	 Reserved
-**   1000	 IRQ_H
-**   1111	 share with UART1 (only for UART2)
-**
-**  Any unselected IRQ REQ is in tristate
-**
-**  To share an IRQ between UART1 and UART2, set
-**  UART1 to use the desired IRQ and set UART2 to
-**  0xF to enable sharing mechanism.
-**
-*/
-typedef union _SMC37c669_CR28 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned uart2_irq : 4;	    /* See note above		    */
-	unsigned uart1_irq : 4;	    /* See note above		    */
-    }	by_field;
-} SMC37c669_CR28;
-
-/*
-** CR29 - default value 0x00
-**
-**  IRQIN IRQ Select Register
-**
-**  D3 - D0	  IRQ
-**  D7 - D4	Selected
-**  -------	--------
-**   0000	 None
-**   0001	 IRQ_A
-**   0010	 IRQ_B
-**   0011	 IRQ_C
-**   0100	 IRQ_D
-**   0101	 IRQ_E
-**   0110	 IRQ_F
-**   0111	 Reserved
-**   1000	 IRQ_H
-**
-**  Any unselected IRQ REQ is in tristate
-**
-*/
-typedef union _SMC37c669_CR29 {
-    unsigned char as_uchar;
-    struct {
-    	unsigned irqin_irq : 4;	    /* See note above		    */
-	unsigned reserved1 : 4;	    /* RAZ			    */
-    }	by_field;
-} SMC37c669_CR29;
-
-/*
-** Aliases of Configuration Register formats (should match
-** the set of index aliases).
-**
-** Note that CR24 and CR25 have the same format and are the
-** base address registers for UART1 and UART2.  Because of
-** this we only define 1 alias here - for CR24 - as the serial
-** base address register.
-**
-** Note that CR21 and CR22 have the same format and are the
-** base address and alternate status address registers for
-** the IDE controller.  Because of this we only define 1 alias
-** here - for CR21 - as the IDE address register.
-**
-*/
-typedef SMC37c669_CR0D SMC37c669_DEVICE_ID_REGISTER;
-typedef SMC37c669_CR0E SMC37c669_DEVICE_REVISION_REGISTER;
-typedef SMC37c669_CR20 SMC37c669_FDC_BASE_ADDRESS_REGISTER;
-typedef SMC37c669_CR21 SMC37c669_IDE_ADDRESS_REGISTER;
-typedef SMC37c669_CR23 SMC37c669_PARALLEL_BASE_ADDRESS_REGISTER;
-typedef SMC37c669_CR24 SMC37c669_SERIAL_BASE_ADDRESS_REGISTER;
-typedef SMC37c669_CR26 SMC37c669_PARALLEL_FDC_DRQ_REGISTER;
-typedef SMC37c669_CR27 SMC37c669_PARALLEL_FDC_IRQ_REGISTER;
-typedef SMC37c669_CR28 SMC37c669_SERIAL_IRQ_REGISTER;
-
-/*
-** ISA/Device IRQ Translation Table Entry Definition
-*/
-typedef struct _SMC37c669_IRQ_TRANSLATION_ENTRY {
-    int device_irq;
-    int isa_irq;
-} SMC37c669_IRQ_TRANSLATION_ENTRY;
-
-/*
-** ISA/Device DMA Translation Table Entry Definition
-*/
-typedef struct _SMC37c669_DRQ_TRANSLATION_ENTRY {
-    int device_drq;
-    int isa_drq;
-} SMC37c669_DRQ_TRANSLATION_ENTRY;
-
-/*
-** External Interface Function Prototype Declarations
-*/
-
-SMC37c669_CONFIG_REGS *SMC37c669_detect( 
-    int
-);
-
-unsigned int SMC37c669_enable_device( 
-    unsigned int func 
-);
-
-unsigned int SMC37c669_disable_device( 
-    unsigned int func 
-);
-
-unsigned int SMC37c669_configure_device( 
-    unsigned int func, 
-    int port, 
-    int irq, 
-    int drq 
-);
-
-void SMC37c669_display_device_info( 
-    void 
-);
-
-#endif	/* __SMC37c669_H */
-
-/* file:	smcc669.c
- *
- * Copyright (C) 1997 by
- * Digital Equipment Corporation, Maynard, Massachusetts.
- * All rights reserved.
- *
- * This software is furnished under a license and may be used and copied
- * only  in  accordance  of  the  terms  of  such  license  and with the
- * inclusion of the above copyright notice. This software or  any  other
- * copies thereof may not be provided or otherwise made available to any
- * other person.  No title to and  ownership of the  software is  hereby
- * transferred.
- *
- * The information in this software is  subject to change without notice
- * and  should  not  be  construed  as a commitment by digital equipment
- * corporation.
- *
- * Digital assumes no responsibility for the use  or  reliability of its
- * software on equipment which is not supplied by digital.
- */
-
-/*
- *++
- *  FACILITY:
- *
- *      Alpha SRM Console Firmware
- *
- *  MODULE DESCRIPTION:
- *
- *	SMC37c669 Super I/O controller configuration routines.
- *
- *  AUTHORS:
- *
- *	Eric Rasmussen
- *
- *  CREATION DATE:
- *  
- *	28-Jan-1997
- *
- *  MODIFICATION HISTORY:
- *	
- *	er	01-May-1997	Fixed pointer conversion errors in 
- *				SMC37c669_get_device_config().
- *      er	28-Jan-1997	Initial version.
- *
- *--
- */
-#if 0
-/* $INCLUDE_OPTIONS$ */
-#include    "cp$inc:platform_io.h"
-/* $INCLUDE_OPTIONS_END$ */
-#include    "cp$src:common.h"
-#include    "cp$inc:prototypes.h"
-#include    "cp$src:kernel_def.h"
-#include    "cp$src:msg_def.h"
-#include    "cp$src:smcc669_def.h"
-/* Platform-specific includes */
-#include    "cp$src:platform.h"
-#endif
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#define wb( _x_, _y_ )	outb( _y_, (unsigned int)((unsigned long)_x_) )
-#define rb( _x_ )	inb( (unsigned int)((unsigned long)_x_) )
-
-/*
-** Local storage for device configuration information.
-**
-** Since the SMC37c669 does not provide an explicit
-** mechanism for enabling/disabling individual device 
-** functions, other than unmapping the device, local 
-** storage for device configuration information is 
-** allocated here for use in implementing our own 
-** function enable/disable scheme.
-*/
-static struct DEVICE_CONFIG {
-    unsigned int port1;
-    unsigned int port2;
-    int irq;
-    int drq;
-} local_config [NUM_FUNCS];
-
-/*
-** List of all possible addresses for the Super I/O chip
-*/
-static unsigned long SMC37c669_Addresses[] __initdata =
-    {
-	0x3F0UL,	    /* Primary address	    */
-	0x370UL,	    /* Secondary address    */
-	0UL		    /* End of list	    */
-    };
-
-/*
-** Global Pointer to the Super I/O device
-*/
-static SMC37c669_CONFIG_REGS *SMC37c669 __initdata = NULL;
-
-/*
-** IRQ Translation Table
-**
-** The IRQ translation table is a list of SMC37c669 device 
-** and standard ISA IRQs.
-**
-*/
-static SMC37c669_IRQ_TRANSLATION_ENTRY *SMC37c669_irq_table __initdata; 
-
-/*
-** The following definition is for the default IRQ 
-** translation table.
-*/
-static SMC37c669_IRQ_TRANSLATION_ENTRY SMC37c669_default_irq_table[]
-__initdata = 
-    { 
-	{ SMC37c669_DEVICE_IRQ_A, -1 }, 
-	{ SMC37c669_DEVICE_IRQ_B, -1 }, 
-	{ SMC37c669_DEVICE_IRQ_C, 7 }, 
-	{ SMC37c669_DEVICE_IRQ_D, 6 }, 
-	{ SMC37c669_DEVICE_IRQ_E, 4 }, 
-	{ SMC37c669_DEVICE_IRQ_F, 3 }, 
-	{ SMC37c669_DEVICE_IRQ_H, -1 }, 
-	{ -1, -1 } /* End of table */
-    };
-
-/*
-** The following definition is for the MONET (XP1000) IRQ 
-** translation table.
-*/
-static SMC37c669_IRQ_TRANSLATION_ENTRY SMC37c669_monet_irq_table[]
-__initdata = 
-    { 
-	{ SMC37c669_DEVICE_IRQ_A, -1 }, 
-	{ SMC37c669_DEVICE_IRQ_B, -1 }, 
-	{ SMC37c669_DEVICE_IRQ_C, 6 }, 
-	{ SMC37c669_DEVICE_IRQ_D, 7 }, 
-	{ SMC37c669_DEVICE_IRQ_E, 4 }, 
-	{ SMC37c669_DEVICE_IRQ_F, 3 }, 
-	{ SMC37c669_DEVICE_IRQ_H, -1 }, 
-	{ -1, -1 } /* End of table */
-    };
-
-static SMC37c669_IRQ_TRANSLATION_ENTRY *SMC37c669_irq_tables[] __initdata =
-    {
-	SMC37c669_default_irq_table,
-	SMC37c669_monet_irq_table
-    }; 
-
-/*
-** DRQ Translation Table
-**
-** The DRQ translation table is a list of SMC37c669 device and
-** ISA DMA channels.
-**
-*/
-static SMC37c669_DRQ_TRANSLATION_ENTRY *SMC37c669_drq_table __initdata;
-
-/*
-** The following definition is the default DRQ
-** translation table.
-*/
-static SMC37c669_DRQ_TRANSLATION_ENTRY SMC37c669_default_drq_table[]
-__initdata = 
-    { 
-	{ SMC37c669_DEVICE_DRQ_A, 2 }, 
-	{ SMC37c669_DEVICE_DRQ_B, 3 }, 
-	{ SMC37c669_DEVICE_DRQ_C, -1 }, 
-	{ -1, -1 } /* End of table */
-    };
-
-/*
-** Local Function Prototype Declarations
-*/
-
-static unsigned int SMC37c669_is_device_enabled( 
-    unsigned int func 
-);
-
-#if 0
-static unsigned int SMC37c669_get_device_config( 
-    unsigned int func, 
-    int *port, 
-    int *irq, 
-    int *drq 
-);
-#endif
-
-static void SMC37c669_config_mode( 
-    unsigned int enable 
-);
-
-static unsigned char SMC37c669_read_config( 
-    unsigned char index 
-);
-
-static void SMC37c669_write_config( 
-    unsigned char index, 
-    unsigned char data 
-);
-
-static void SMC37c669_init_local_config( void );
-
-static struct DEVICE_CONFIG *SMC37c669_get_config(
-    unsigned int func
-);
-
-static int SMC37c669_xlate_irq(
-    int irq 
-);
-
-static int SMC37c669_xlate_drq(
-    int drq 
-);
-
-static  __cacheline_aligned DEFINE_SPINLOCK(smc_lock);
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function detects the presence of an SMC37c669 Super I/O
-**	controller.
-**
-**  FORMAL PARAMETERS:
-**
-**	None
-**
-**  RETURN VALUE:
-**
-**      Returns a pointer to the device if found, otherwise,
-**	the NULL pointer is returned.
-**
-**  SIDE EFFECTS:
-**
-**      None
-**
-**--
-*/
-SMC37c669_CONFIG_REGS * __init SMC37c669_detect( int index )
-{
-    int i;
-    SMC37c669_DEVICE_ID_REGISTER id;
-
-    for ( i = 0;  SMC37c669_Addresses[i] != 0;  i++ ) {
-/*
-** Initialize the device pointer even though we don't yet know if
-** the controller is at this address.  The support functions access
-** the controller through this device pointer so we need to set it
-** even when we are looking ...
-*/
-    	SMC37c669 = ( SMC37c669_CONFIG_REGS * )SMC37c669_Addresses[i];
-/*
-** Enter configuration mode
-*/
-	SMC37c669_config_mode( TRUE );
-/*
-** Read the device id
-*/
-	id.as_uchar = SMC37c669_read_config( SMC37c669_DEVICE_ID_INDEX );
-/*
-** Exit configuration mode
-*/
-	SMC37c669_config_mode( FALSE );
-/*
-** Does the device id match?  If so, assume we have found an
-** SMC37c669 controller at this address.
-*/
-	if ( id.by_field.device_id == SMC37c669_DEVICE_ID ) {
-/*
-** Initialize the IRQ and DRQ translation tables.
-*/
-    	    SMC37c669_irq_table = SMC37c669_irq_tables[ index ];
-	    SMC37c669_drq_table = SMC37c669_default_drq_table;
-/*
-** erfix
-**
-** If the platform can't use the IRQ and DRQ defaults set up in this 
-** file, it should call a platform-specific external routine at this 
-** point to reset the IRQ and DRQ translation table pointers to point 
-** at the appropriate tables for the platform.  If the defaults are 
-** acceptable, then the external routine should do nothing.
-*/
-
-/*
-** Put the chip back into configuration mode
-*/
-	    SMC37c669_config_mode( TRUE );
-/*
-** Initialize local storage for configuration information
-*/
-	    SMC37c669_init_local_config( );
-/*
-** Exit configuration mode
-*/
-	    SMC37c669_config_mode( FALSE );
-/*
-** SMC37c669 controller found, break out of search loop
-*/
-	    break;
-	}
-	else {
-/*
-** Otherwise, we did not find an SMC37c669 controller at this
-** address so set the device pointer to NULL.
-*/
-	    SMC37c669 = NULL;
-	}
-    }
-    return SMC37c669;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function enables an SMC37c669 device function.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which device function to enable
-**
-**  RETURN VALUE:
-**
-**      Returns TRUE is the device function was enabled, otherwise, FALSE
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**  DESIGN:
-**
-**      Enabling a device function in the SMC37c669 controller involves
-**	setting all of its mappings (port, irq, drq ...).  A local 
-**	"shadow" copy of the device configuration is kept so we can
-**	just set each mapping to what the local copy says.
-**
-**	This function ALWAYS updates the local shadow configuration of
-**	the device function being enabled, even if the device is always
-**	enabled.  To avoid replication of code, functions such as
-**	configure_device set up the local copy and then call this 
-**	function to the update the real device.
-**
-**--
-*/
-unsigned int __init SMC37c669_enable_device ( unsigned int func )
-{
-    unsigned int ret_val = FALSE;
-/*
-** Put the device into configuration mode
-*/
-    SMC37c669_config_mode( TRUE );
-    switch ( func ) {
-    	case SERIAL_0:
-	    {
-	    	SMC37c669_SERIAL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_SERIAL_IRQ_REGISTER irq;
-/*
-** Enable the serial 1 IRQ mapping
-*/
-	    	irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );
-
-		irq.by_field.uart1_irq =
-		    SMC37c669_RAW_DEVICE_IRQ(
-			SMC37c669_xlate_irq( local_config[ func ].irq )
-		    );
-
-		SMC37c669_write_config( SMC37c669_SERIAL_IRQ_INDEX, irq.as_uchar );
-/*
-** Enable the serial 1 port base address mapping
-*/
-		base_addr.as_uchar = 0;
-		base_addr.by_field.addr9_3 = local_config[ func ].port1 >> 3;
-
-		SMC37c669_write_config( 
-		    SMC37c669_SERIAL0_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case SERIAL_1:
-	    {
-	    	SMC37c669_SERIAL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_SERIAL_IRQ_REGISTER irq;
-/*
-** Enable the serial 2 IRQ mapping
-*/
-	    	irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );
-
-		irq.by_field.uart2_irq =
-		    SMC37c669_RAW_DEVICE_IRQ(
-			SMC37c669_xlate_irq( local_config[ func ].irq )
-		    );
-
-		SMC37c669_write_config( SMC37c669_SERIAL_IRQ_INDEX, irq.as_uchar );
-/*
-** Enable the serial 2 port base address mapping
-*/
-		base_addr.as_uchar = 0;
-		base_addr.by_field.addr9_3 = local_config[ func ].port1 >> 3;
-
-		SMC37c669_write_config( 
-		    SMC37c669_SERIAL1_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case PARALLEL_0:
-	    {
-	    	SMC37c669_PARALLEL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_PARALLEL_FDC_IRQ_REGISTER irq;
-		SMC37c669_PARALLEL_FDC_DRQ_REGISTER drq;
-/*
-** Enable the parallel port DMA channel mapping
-*/
-	    	drq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );
-
-		drq.by_field.ppt_drq = 
-		    SMC37c669_RAW_DEVICE_DRQ(
-			SMC37c669_xlate_drq( local_config[ func ].drq )
-		    );
-
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL_FDC_DRQ_INDEX,
-		    drq.as_uchar
-		);
-/*
-** Enable the parallel port IRQ mapping
-*/
-		irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );
-
-		irq.by_field.ppt_irq =
-		    SMC37c669_RAW_DEVICE_IRQ(
-			SMC37c669_xlate_irq( local_config[ func ].irq )
-		    );
-
-		SMC37c669_write_config( 
-		    SMC37c669_PARALLEL_FDC_IRQ_INDEX,
-		    irq.as_uchar
-		);
-/*
-** Enable the parallel port base address mapping
-*/
-		base_addr.as_uchar = 0;
-		base_addr.by_field.addr9_2 = local_config[ func ].port1 >> 2;
-
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case FLOPPY_0:
-	    {
-	    	SMC37c669_FDC_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_PARALLEL_FDC_IRQ_REGISTER irq;
-		SMC37c669_PARALLEL_FDC_DRQ_REGISTER drq;
-/*
-** Enable the floppy controller DMA channel mapping
-*/
-	    	drq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );
-		 
-		drq.by_field.fdc_drq =
-		    SMC37c669_RAW_DEVICE_DRQ(
-			SMC37c669_xlate_drq( local_config[ func ].drq )
-		    );
-		 
-		SMC37c669_write_config( 
-		    SMC37c669_PARALLEL_FDC_DRQ_INDEX,
-		    drq.as_uchar
-		);
-/*
-** Enable the floppy controller IRQ mapping
-*/
-		irq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );
-		 
-		irq.by_field.fdc_irq =
-		    SMC37c669_RAW_DEVICE_IRQ(
-			SMC37c669_xlate_irq( local_config[ func ].irq )
-		    );
-		 
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL_FDC_IRQ_INDEX,
-		    irq.as_uchar
-		);
-/*
-** Enable the floppy controller base address mapping
-*/
-		base_addr.as_uchar = 0;
-		base_addr.by_field.addr9_4 = local_config[ func ].port1 >> 4;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_FDC_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case IDE_0:
-	    {
-	    	SMC37c669_IDE_ADDRESS_REGISTER ide_addr;
-/*
-** Enable the IDE alternate status base address mapping
-*/
-	    	ide_addr.as_uchar = 0;
-		ide_addr.by_field.addr9_4 = local_config[ func ].port2 >> 4;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_IDE_ALTERNATE_ADDRESS_INDEX,
-		    ide_addr.as_uchar
-		);
-/*
-** Enable the IDE controller base address mapping
-*/
-		ide_addr.as_uchar = 0;
-		ide_addr.by_field.addr9_4 = local_config[ func ].port1 >> 4;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_IDE_BASE_ADDRESS_INDEX,
-		    ide_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-    }
-/*
-** Exit configuration mode and return
-*/
-    SMC37c669_config_mode( FALSE );
-
-    return ret_val;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function disables a device function within the
-**	SMC37c669 Super I/O controller.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which function to disable
-**
-**  RETURN VALUE:
-**
-**      Return TRUE if the device function was disabled, otherwise, FALSE
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**  DESIGN:
-**
-**      Disabling a function in the SMC37c669 device involves
-**	disabling all the function's mappings (port, irq, drq ...).
-**	A shadow copy of the device configuration is maintained
-**	in local storage so we won't worry aboving saving the
-**	current configuration information.
-**
-**--
-*/
-unsigned int __init SMC37c669_disable_device ( unsigned int func )
-{
-    unsigned int ret_val = FALSE;
-
-/*
-** Put the device into configuration mode
-*/
-    SMC37c669_config_mode( TRUE );
-    switch ( func ) {
-    	case SERIAL_0:
-	    {
-	    	SMC37c669_SERIAL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_SERIAL_IRQ_REGISTER irq;
-/*
-** Disable the serial 1 IRQ mapping
-*/
-	    	irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );
-
-		irq.by_field.uart1_irq = 0;
-
-		SMC37c669_write_config( SMC37c669_SERIAL_IRQ_INDEX, irq.as_uchar );
-/*
-** Disable the serial 1 port base address mapping
-*/
-		base_addr.as_uchar = 0;
-		SMC37c669_write_config( 
-		    SMC37c669_SERIAL0_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case SERIAL_1:
-	    {
-	    	SMC37c669_SERIAL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_SERIAL_IRQ_REGISTER irq;
-/*
-** Disable the serial 2 IRQ mapping
-*/
-	    	irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );
-
-		irq.by_field.uart2_irq = 0;
-
-		SMC37c669_write_config( SMC37c669_SERIAL_IRQ_INDEX, irq.as_uchar );
-/*
-** Disable the serial 2 port base address mapping
-*/
-		base_addr.as_uchar = 0;
-
-		SMC37c669_write_config( 
-		    SMC37c669_SERIAL1_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case PARALLEL_0:
-	    {
-	    	SMC37c669_PARALLEL_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_PARALLEL_FDC_IRQ_REGISTER irq;
-		SMC37c669_PARALLEL_FDC_DRQ_REGISTER drq;
-/*
-** Disable the parallel port DMA channel mapping
-*/
-	    	drq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );
-
-		drq.by_field.ppt_drq = 0;
-
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL_FDC_DRQ_INDEX,
-		    drq.as_uchar
-		);
-/*
-** Disable the parallel port IRQ mapping
-*/
-		irq.as_uchar = 
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );
-
-		irq.by_field.ppt_irq = 0;
-
-		SMC37c669_write_config( 
-		    SMC37c669_PARALLEL_FDC_IRQ_INDEX,
-		    irq.as_uchar
-		);
-/*
-** Disable the parallel port base address mapping
-*/
-		base_addr.as_uchar = 0;
-
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case FLOPPY_0:
-	    {
-	    	SMC37c669_FDC_BASE_ADDRESS_REGISTER base_addr;
-		SMC37c669_PARALLEL_FDC_IRQ_REGISTER irq;
-		SMC37c669_PARALLEL_FDC_DRQ_REGISTER drq;
-/*
-** Disable the floppy controller DMA channel mapping
-*/
-	    	drq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );
-		 
-		drq.by_field.fdc_drq = 0;
-		 
-		SMC37c669_write_config( 
-		    SMC37c669_PARALLEL_FDC_DRQ_INDEX,
-		    drq.as_uchar
-		);
-/*
-** Disable the floppy controller IRQ mapping
-*/
-		irq.as_uchar =
-		    SMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );
-		 
-		irq.by_field.fdc_irq = 0;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_PARALLEL_FDC_IRQ_INDEX,
-		    irq.as_uchar
-		);
-/*
-** Disable the floppy controller base address mapping
-*/
-		base_addr.as_uchar = 0;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_FDC_BASE_ADDRESS_INDEX,
-		    base_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-	case IDE_0:
-	    {
-	    	SMC37c669_IDE_ADDRESS_REGISTER ide_addr;
-/*
-** Disable the IDE alternate status base address mapping
-*/
-	    	ide_addr.as_uchar = 0;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_IDE_ALTERNATE_ADDRESS_INDEX,
-		    ide_addr.as_uchar
-		);
-/*
-** Disable the IDE controller base address mapping
-*/
-		ide_addr.as_uchar = 0;
-		 
-		SMC37c669_write_config(
-		    SMC37c669_IDE_BASE_ADDRESS_INDEX,
-		    ide_addr.as_uchar
-		);
-		ret_val = TRUE;
-		break;
-	    }
-    }
-/*
-** Exit configuration mode and return
-*/
-    SMC37c669_config_mode( FALSE );
-
-    return ret_val;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function configures a device function within the 
-**	SMC37c669 Super I/O controller.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which device function
-**       
-**      port:
-**          I/O port for the function to use
-**	 
-**      irq:
-**          IRQ for the device function to use
-**	 
-**      drq:
-**          DMA channel for the device function to use
-**
-**  RETURN VALUE:
-**
-**      Returns TRUE if the device function was configured, 
-**	otherwise, FALSE.
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**  DESIGN:
-**
-**	If this function returns TRUE, the local shadow copy of
-**	the configuration is also updated.  If the device function
-**	is currently disabled, only the local shadow copy is 
-**	updated and the actual device function will be updated
-**	if/when it is enabled.
-**
-**--
-*/
-unsigned int __init SMC37c669_configure_device (
-    unsigned int func,
-    int port,
-    int irq,
-    int drq )
-{
-    struct DEVICE_CONFIG *cp;
-
-/*
-** Check for a valid configuration
-*/
-    if ( ( cp = SMC37c669_get_config ( func ) ) != NULL ) {
-/*
-** Configuration is valid, update the local shadow copy
-*/
-    	if ( ( drq & ~0xFF ) == 0 ) {
-	    cp->drq = drq;
-	}
-	if ( ( irq & ~0xFF ) == 0 ) {
-	    cp->irq = irq;
-	}
-	if ( ( port & ~0xFFFF ) == 0 ) {
-	    cp->port1 = port;
-	}
-/*
-** If the device function is enabled, update the actual
-** device configuration.
-*/
-	if ( SMC37c669_is_device_enabled( func ) ) {
-	    SMC37c669_enable_device( func );
-	}
-	return TRUE;
-    }
-    return FALSE;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function determines whether a device function
-**	within the SMC37c669 controller is enabled.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which device function
-**
-**  RETURN VALUE:
-**
-**      Returns TRUE if the device function is enabled, otherwise, FALSE
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**  DESIGN:
-**
-**      To check whether a device is enabled we will only look at 
-**	the port base address mapping.  According to the SMC37c669
-**	specification, all of the port base address mappings are
-**	disabled if the addr<9:8> (bits <7:6> of the register) are
-**	zero.
-**
-**--
-*/
-static unsigned int __init SMC37c669_is_device_enabled ( unsigned int func )
-{
-    unsigned char base_addr = 0;
-    unsigned int dev_ok = FALSE;
-    unsigned int ret_val = FALSE;
-/*
-** Enter configuration mode
-*/
-    SMC37c669_config_mode( TRUE );
-     
-    switch ( func ) {
-    	case SERIAL_0:
-	    base_addr =
-		SMC37c669_read_config( SMC37c669_SERIAL0_BASE_ADDRESS_INDEX );
-	    dev_ok = TRUE;
-	    break;
-	case SERIAL_1:
-	    base_addr =
-		SMC37c669_read_config( SMC37c669_SERIAL1_BASE_ADDRESS_INDEX );
-	    dev_ok = TRUE;
-	    break;
-	case PARALLEL_0:
-	    base_addr =
-		SMC37c669_read_config( SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX );
-	    dev_ok = TRUE;
-	    break;
-	case FLOPPY_0:
-	    base_addr =
-		SMC37c669_read_config( SMC37c669_FDC_BASE_ADDRESS_INDEX );
-	    dev_ok = TRUE;
-	    break;
-	case IDE_0:
-	    base_addr =
-		SMC37c669_read_config( SMC37c669_IDE_BASE_ADDRESS_INDEX );
-	    dev_ok = TRUE;
-	    break;
-    }
-/*
-** If we have a valid device, check base_addr<7:6> to see if the
-** device is enabled (mapped).
-*/
-    if ( ( dev_ok ) && ( ( base_addr & 0xC0 ) != 0 ) ) {
-/*
-** The mapping is not disabled, so assume that the function is 
-** enabled.
-*/
-    	ret_val = TRUE;
-    }
-/*
-** Exit configuration mode 
-*/
-    SMC37c669_config_mode( FALSE );
-
-    return ret_val;
-}
-
-
-#if 0
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function retrieves the configuration information of a 
-**	device function within the SMC37c699 Super I/O controller.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which device function
-**       
-**      port:
-**          I/O port returned
-**	 
-**      irq:
-**          IRQ returned
-**	 
-**      drq:
-**          DMA channel returned
-**
-**  RETURN VALUE:
-**
-**      Returns TRUE if the device configuration was successfully
-**	retrieved, otherwise, FALSE.
-**
-**  SIDE EFFECTS:
-**
-**      The data pointed to by the port, irq, and drq parameters
-**	my be modified even if the configuration is not successfully
-**	retrieved.
-**
-**  DESIGN:
-**
-**      The device configuration is fetched from the local shadow
-**	copy.  Any unused parameters will be set to -1.  Any
-**	parameter which is not desired can specify the NULL
-**	pointer.
-**
-**--
-*/
-static unsigned int __init SMC37c669_get_device_config (
-    unsigned int func,
-    int *port,
-    int *irq,
-    int *drq )
-{
-    struct DEVICE_CONFIG *cp;
-    unsigned int ret_val = FALSE;
-/*
-** Check for a valid device configuration
-*/
-    if ( ( cp = SMC37c669_get_config( func ) ) != NULL ) {
-    	if ( drq != NULL ) {
-	    *drq = cp->drq;
-	    ret_val = TRUE;
-	}
-	if ( irq != NULL ) {
-	    *irq = cp->irq;
-	    ret_val = TRUE;
-	}
-	if ( port != NULL ) {
-	    *port = cp->port1;
-	    ret_val = TRUE;
-	}
-    }
-    return ret_val;
-}
-#endif
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function displays the current state of the SMC37c699
-**	Super I/O controller's device functions.
-**
-**  FORMAL PARAMETERS:
-**
-**      None
-**
-**  RETURN VALUE:
-**
-**      None
-**
-**  SIDE EFFECTS:
-**
-**      None
-**
-**--
-*/
-void __init SMC37c669_display_device_info ( void )
-{
-    if ( SMC37c669_is_device_enabled( SERIAL_0 ) ) {
-    	printk( "  Serial 0:    Enabled [ Port 0x%x, IRQ %d ]\n",
-		 local_config[ SERIAL_0 ].port1,
-		 local_config[ SERIAL_0 ].irq
-	);
-    }
-    else {
-    	printk( "  Serial 0:    Disabled\n" );
-    }
-
-    if ( SMC37c669_is_device_enabled( SERIAL_1 ) ) {
-    	printk( "  Serial 1:    Enabled [ Port 0x%x, IRQ %d ]\n",
-		 local_config[ SERIAL_1 ].port1,
-		 local_config[ SERIAL_1 ].irq
-	);
-    }
-    else {
-    	printk( "  Serial 1:    Disabled\n" );
-    }
-
-    if ( SMC37c669_is_device_enabled( PARALLEL_0 ) ) {
-    	printk( "  Parallel:    Enabled [ Port 0x%x, IRQ %d/%d ]\n",
-		 local_config[ PARALLEL_0 ].port1,
-		 local_config[ PARALLEL_0 ].irq,
-		 local_config[ PARALLEL_0 ].drq
-	);
-    }
-    else {
-    	printk( "  Parallel:    Disabled\n" );
-    }
-
-    if ( SMC37c669_is_device_enabled( FLOPPY_0 ) ) {
-    	printk( "  Floppy Ctrl: Enabled [ Port 0x%x, IRQ %d/%d ]\n",
-		 local_config[ FLOPPY_0 ].port1,
-		 local_config[ FLOPPY_0 ].irq,
-		 local_config[ FLOPPY_0 ].drq
-	);
-    }
-    else {
-    	printk( "  Floppy Ctrl: Disabled\n" );
-    }
-
-    if ( SMC37c669_is_device_enabled( IDE_0 ) ) {
-    	printk( "  IDE 0:       Enabled [ Port 0x%x, IRQ %d ]\n",
-		 local_config[ IDE_0 ].port1,
-		 local_config[ IDE_0 ].irq
-	);
-    }
-    else {
-    	printk( "  IDE 0:       Disabled\n" );
-    }
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function puts the SMC37c669 Super I/O controller into,
-**	and takes it out of, configuration mode.
-**
-**  FORMAL PARAMETERS:
-**
-**      enable:
-**          TRUE to enter configuration mode, FALSE to exit.
-**
-**  RETURN VALUE:
-**
-**      None
-**
-**  SIDE EFFECTS:
-**
-**      The SMC37c669 controller may be left in configuration mode.
-**
-**--
-*/
-static void __init SMC37c669_config_mode( 
-    unsigned int enable )
-{
-    if ( enable ) {
-/*
-** To enter configuration mode, two writes in succession to the index
-** port are required.  If a write to another address or port occurs
-** between these two writes, the chip does not enter configuration
-** mode.  Therefore, a spinlock is placed around the two writes to 
-** guarantee that they complete uninterrupted.
-*/
-	spin_lock(&smc_lock);
-    	wb( &SMC37c669->index_port, SMC37c669_CONFIG_ON_KEY );
-    	wb( &SMC37c669->index_port, SMC37c669_CONFIG_ON_KEY );
-	spin_unlock(&smc_lock);
-    }
-    else {
-    	wb( &SMC37c669->index_port, SMC37c669_CONFIG_OFF_KEY );
-    }
-}
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function reads an SMC37c669 Super I/O controller
-**	configuration register.  This function assumes that the
-**	device is already in configuration mode.
-**
-**  FORMAL PARAMETERS:
-**
-**      index:
-**          Index value of configuration register to read
-**
-**  RETURN VALUE:
-**
-**      Data read from configuration register
-**
-**  SIDE EFFECTS:
-**
-**      None
-**
-**--
-*/
-static unsigned char __init SMC37c669_read_config( 
-    unsigned char index )
-{
-    unsigned char data;
-
-    wb( &SMC37c669->index_port, index );
-    data = rb( &SMC37c669->data_port );
-    return data;
-}
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function writes an SMC37c669 Super I/O controller
-**	configuration register.  This function assumes that the
-**	device is already in configuration mode.
-**
-**  FORMAL PARAMETERS:
-**
-**      index:
-**          Index of configuration register to write
-**       
-**      data:
-**          Data to be written
-**
-**  RETURN VALUE:
-**
-**      None
-**
-**  SIDE EFFECTS:
-**
-**      None
-**
-**--
-*/
-static void __init SMC37c669_write_config( 
-    unsigned char index, 
-    unsigned char data )
-{
-    wb( &SMC37c669->index_port, index );
-    wb( &SMC37c669->data_port, data );
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function initializes the local device
-**	configuration storage.  This function assumes
-**	that the device is already in configuration
-**	mode.
-**
-**  FORMAL PARAMETERS:
-**
-**      None
-**
-**  RETURN VALUE:
-**
-**      None
-**
-**  SIDE EFFECTS:
-**
-**      Local storage for device configuration information
-**	is initialized.
-**
-**--
-*/
-static void __init SMC37c669_init_local_config ( void )
-{
-    SMC37c669_SERIAL_BASE_ADDRESS_REGISTER uart_base;
-    SMC37c669_SERIAL_IRQ_REGISTER uart_irqs;
-    SMC37c669_PARALLEL_BASE_ADDRESS_REGISTER ppt_base;
-    SMC37c669_PARALLEL_FDC_IRQ_REGISTER ppt_fdc_irqs;
-    SMC37c669_PARALLEL_FDC_DRQ_REGISTER ppt_fdc_drqs;
-    SMC37c669_FDC_BASE_ADDRESS_REGISTER fdc_base;
-    SMC37c669_IDE_ADDRESS_REGISTER ide_base;
-    SMC37c669_IDE_ADDRESS_REGISTER ide_alt;
-
-/*
-** Get serial port 1 base address 
-*/
-    uart_base.as_uchar = 
-	SMC37c669_read_config( SMC37c669_SERIAL0_BASE_ADDRESS_INDEX );
-/*
-** Get IRQs for serial ports 1 & 2
-*/
-    uart_irqs.as_uchar = 
-	SMC37c669_read_config( SMC37c669_SERIAL_IRQ_INDEX );
-/*
-** Store local configuration information for serial port 1
-*/
-    local_config[SERIAL_0].port1 = uart_base.by_field.addr9_3 << 3;
-    local_config[SERIAL_0].irq = 
-	SMC37c669_xlate_irq( 
-	    SMC37c669_DEVICE_IRQ( uart_irqs.by_field.uart1_irq ) 
-	);
-/*
-** Get serial port 2 base address
-*/
-    uart_base.as_uchar = 
-	SMC37c669_read_config( SMC37c669_SERIAL1_BASE_ADDRESS_INDEX );
-/*
-** Store local configuration information for serial port 2
-*/
-    local_config[SERIAL_1].port1 = uart_base.by_field.addr9_3 << 3;
-    local_config[SERIAL_1].irq = 
-	SMC37c669_xlate_irq( 
-	    SMC37c669_DEVICE_IRQ( uart_irqs.by_field.uart2_irq ) 
-	);
-/*
-** Get parallel port base address
-*/
-    ppt_base.as_uchar =
-	SMC37c669_read_config( SMC37c669_PARALLEL0_BASE_ADDRESS_INDEX );
-/*
-** Get IRQs for parallel port and floppy controller
-*/
-    ppt_fdc_irqs.as_uchar =
-	SMC37c669_read_config( SMC37c669_PARALLEL_FDC_IRQ_INDEX );
-/*
-** Get DRQs for parallel port and floppy controller
-*/
-    ppt_fdc_drqs.as_uchar =
-	SMC37c669_read_config( SMC37c669_PARALLEL_FDC_DRQ_INDEX );
-/*
-** Store local configuration information for parallel port
-*/
-    local_config[PARALLEL_0].port1 = ppt_base.by_field.addr9_2 << 2;
-    local_config[PARALLEL_0].irq =
-	SMC37c669_xlate_irq(
-	    SMC37c669_DEVICE_IRQ( ppt_fdc_irqs.by_field.ppt_irq )
-	);
-    local_config[PARALLEL_0].drq =
-	SMC37c669_xlate_drq(
-	    SMC37c669_DEVICE_DRQ( ppt_fdc_drqs.by_field.ppt_drq )
-	);
-/*
-** Get floppy controller base address
-*/
-    fdc_base.as_uchar = 
-	SMC37c669_read_config( SMC37c669_FDC_BASE_ADDRESS_INDEX );
-/*
-** Store local configuration information for floppy controller
-*/
-    local_config[FLOPPY_0].port1 = fdc_base.by_field.addr9_4 << 4;
-    local_config[FLOPPY_0].irq =
-	SMC37c669_xlate_irq(
-	    SMC37c669_DEVICE_IRQ( ppt_fdc_irqs.by_field.fdc_irq )
-	);
-    local_config[FLOPPY_0].drq =
-	SMC37c669_xlate_drq(
-	    SMC37c669_DEVICE_DRQ( ppt_fdc_drqs.by_field.fdc_drq )
-	);
-/*
-** Get IDE controller base address
-*/
-    ide_base.as_uchar =
-	SMC37c669_read_config( SMC37c669_IDE_BASE_ADDRESS_INDEX );
-/*
-** Get IDE alternate status base address
-*/
-    ide_alt.as_uchar =
-	SMC37c669_read_config( SMC37c669_IDE_ALTERNATE_ADDRESS_INDEX );
-/*
-** Store local configuration information for IDE controller
-*/
-    local_config[IDE_0].port1 = ide_base.by_field.addr9_4 << 4;
-    local_config[IDE_0].port2 = ide_alt.by_field.addr9_4 << 4;
-    local_config[IDE_0].irq = 14;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function returns a pointer to the local shadow
-**	configuration of the requested device function.
-**
-**  FORMAL PARAMETERS:
-**
-**      func:
-**          Which device function
-**
-**  RETURN VALUE:
-**
-**      Returns a pointer to the DEVICE_CONFIG structure for the
-**	requested function, otherwise, NULL.
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**--
-*/
-static struct DEVICE_CONFIG * __init SMC37c669_get_config( unsigned int func )
-{
-    struct DEVICE_CONFIG *cp = NULL;
-
-    switch ( func ) {
-    	case SERIAL_0:
-	    cp = &local_config[ SERIAL_0 ];
-	    break;
-	case SERIAL_1:
-	    cp = &local_config[ SERIAL_1 ];
-	    break;
-	case PARALLEL_0:
-	    cp = &local_config[ PARALLEL_0 ];
-	    break;
-	case FLOPPY_0:
-	    cp = &local_config[ FLOPPY_0 ];
-	    break;
-	case IDE_0:
-	    cp = &local_config[ IDE_0 ];
-	    break;
-    }
-    return cp;
-}
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function translates IRQs back and forth between ISA
-**	IRQs and SMC37c669 device IRQs.
-**
-**  FORMAL PARAMETERS:
-**
-**      irq:
-**          The IRQ to translate
-**
-**  RETURN VALUE:
-**
-**      Returns the translated IRQ, otherwise, returns -1.
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**--
-*/
-static int __init SMC37c669_xlate_irq ( int irq )
-{
-    int i, translated_irq = -1;
-
-    if ( SMC37c669_IS_DEVICE_IRQ( irq ) ) {
-/*
-** We are translating a device IRQ to an ISA IRQ
-*/
-    	for ( i = 0; ( SMC37c669_irq_table[i].device_irq != -1 ) || ( SMC37c669_irq_table[i].isa_irq != -1 ); i++ ) {
-	    if ( irq == SMC37c669_irq_table[i].device_irq ) {
-	    	translated_irq = SMC37c669_irq_table[i].isa_irq;
-		break;
-	    }
-	}
-    }
-    else {
-/*
-** We are translating an ISA IRQ to a device IRQ
-*/
-    	for ( i = 0; ( SMC37c669_irq_table[i].isa_irq != -1 ) || ( SMC37c669_irq_table[i].device_irq != -1 ); i++ ) {
-	    if ( irq == SMC37c669_irq_table[i].isa_irq ) {
-	    	translated_irq = SMC37c669_irq_table[i].device_irq;
-		break;
-	    }
-	}
-    }
-    return translated_irq;
-}
-
-
-/*
-**++
-**  FUNCTIONAL DESCRIPTION:
-**
-**      This function translates DMA channels back and forth between
-**	ISA DMA channels and SMC37c669 device DMA channels.
-**
-**  FORMAL PARAMETERS:
-**
-**      drq:
-**          The DMA channel to translate
-**
-**  RETURN VALUE:
-**
-**      Returns the translated DMA channel, otherwise, returns -1
-**
-**  SIDE EFFECTS:
-**
-**      {@description or none@}
-**
-**--
-*/
-static int __init SMC37c669_xlate_drq ( int drq )
-{
-    int i, translated_drq = -1;
-
-    if ( SMC37c669_IS_DEVICE_DRQ( drq ) ) {
-/*
-** We are translating a device DMA channel to an ISA DMA channel
-*/
-    	for ( i = 0; ( SMC37c669_drq_table[i].device_drq != -1 ) || ( SMC37c669_drq_table[i].isa_drq != -1 ); i++ ) {
-	    if ( drq == SMC37c669_drq_table[i].device_drq ) {
-	    	translated_drq = SMC37c669_drq_table[i].isa_drq;
-		break;
-	    }
-	}
-    }
-    else {
-/*
-** We are translating an ISA DMA channel to a device DMA channel
-*/
-    	for ( i = 0; ( SMC37c669_drq_table[i].isa_drq != -1 ) || ( SMC37c669_drq_table[i].device_drq != -1 ); i++ ) {
-	    if ( drq == SMC37c669_drq_table[i].isa_drq ) {
-	    	translated_drq = SMC37c669_drq_table[i].device_drq;
-		break;
-	    }
-	}
-    }
-    return translated_drq;
-}
-
-#if 0
-int __init smcc669_init ( void )
-{
-    struct INODE *ip;
-
-    allocinode( smc_ddb.name, 1, &ip );
-    ip->dva = &smc_ddb;
-    ip->attr = ATTR$M_WRITE | ATTR$M_READ;
-    ip->len[0] = 0x30;
-    ip->misc = 0;
-    INODE_UNLOCK( ip );
-
-    return msg_success;
-}
-
-int __init smcc669_open( struct FILE *fp, char *info, char *next, char *mode )
-{
-    struct INODE *ip;
-/*
-** Allow multiple readers but only one writer.  ip->misc keeps track
-** of the number of writers
-*/
-    ip = fp->ip;
-    INODE_LOCK( ip );
-    if ( fp->mode & ATTR$M_WRITE ) {
-	if ( ip->misc ) {
-	    INODE_UNLOCK( ip );
-	    return msg_failure;	    /* too many writers */
-	}
-	ip->misc++;
-    }
-/*
-** Treat the information field as a byte offset
-*/
-    *fp->offset = xtoi( info );
-    INODE_UNLOCK( ip );
-
-    return msg_success;
-}
-
-int __init smcc669_close( struct FILE *fp )
-{
-    struct INODE *ip;
-
-    ip = fp->ip;
-    if ( fp->mode & ATTR$M_WRITE ) {
-	INODE_LOCK( ip );
-	ip->misc--;
-	INODE_UNLOCK( ip );
-    }
-    return msg_success;
-}
-
-int __init smcc669_read( struct FILE *fp, int size, int number, unsigned char *buf )
-{
-    int i;
-    int length;
-    int nbytes;
-    struct INODE *ip;
-
-/*
-** Always access a byte at a time
-*/
-    ip = fp->ip;
-    length = size * number;
-    nbytes = 0;
-
-    SMC37c669_config_mode( TRUE );
-    for ( i = 0; i < length; i++ ) {
-	if ( !inrange( *fp->offset, 0, ip->len[0] ) ) 
-	    break;
-	*buf++ = SMC37c669_read_config( *fp->offset );
-	*fp->offset += 1;
-	nbytes++;
-    }
-    SMC37c669_config_mode( FALSE );
-    return nbytes;
-}
-
-int __init smcc669_write( struct FILE *fp, int size, int number, unsigned char *buf )
-{
-    int i;
-    int length;
-    int nbytes;
-    struct INODE *ip;
-/*
-** Always access a byte at a time
-*/
-    ip = fp->ip;
-    length = size * number;
-    nbytes = 0;
-
-    SMC37c669_config_mode( TRUE );
-    for ( i = 0; i < length; i++ ) {
-	if ( !inrange( *fp->offset, 0, ip->len[0] ) ) 
-	    break;
-	SMC37c669_write_config( *fp->offset, *buf );
-	*fp->offset += 1;
-	buf++;
-	nbytes++;
-    }
-    SMC37c669_config_mode( FALSE );
-    return nbytes;
-}
-#endif
-
-void __init
-SMC37c669_dump_registers(void)
-{
-  int i;
-  for (i = 0; i <= 0x29; i++)
-    printk("-- CR%02x : %02x\n", i, SMC37c669_read_config(i));
-}
-/*+
- * ============================================================================
- * = SMC_init - SMC37c669 Super I/O controller initialization                 =
- * ============================================================================
- *
- * OVERVIEW:
- *
- *      This routine configures and enables device functions on the
- *      SMC37c669 Super I/O controller.
- *
- * FORM OF CALL:
- *
- *      SMC_init( );
- *
- * RETURNS:
- *
- *      Nothing
- *
- * ARGUMENTS:
- *
- *      None
- *
- * SIDE EFFECTS:
- *
- *      None
- *
- */
-void __init SMC669_Init ( int index )
-{
-    SMC37c669_CONFIG_REGS *SMC_base;
-    unsigned long flags;
-
-    local_irq_save(flags);
-    if ( ( SMC_base = SMC37c669_detect( index ) ) != NULL ) {
-#if SMC_DEBUG
-	SMC37c669_config_mode( TRUE );
-	SMC37c669_dump_registers( );
-	SMC37c669_config_mode( FALSE );
-        SMC37c669_display_device_info( );
-#endif
-        SMC37c669_disable_device( SERIAL_0 );
-        SMC37c669_configure_device(
-            SERIAL_0,
-            COM1_BASE,
-            COM1_IRQ,
-            -1
-        );
-        SMC37c669_enable_device( SERIAL_0 );
-
-        SMC37c669_disable_device( SERIAL_1 );
-        SMC37c669_configure_device(
-            SERIAL_1,
-            COM2_BASE,
-            COM2_IRQ,
-            -1
-        );
-        SMC37c669_enable_device( SERIAL_1 );
-
-        SMC37c669_disable_device( PARALLEL_0 );
-        SMC37c669_configure_device(
-            PARALLEL_0,
-            PARP_BASE,
-            PARP_IRQ,
-            PARP_DRQ
-        );
-        SMC37c669_enable_device( PARALLEL_0 );
-
-        SMC37c669_disable_device( FLOPPY_0 );
-        SMC37c669_configure_device(
-            FLOPPY_0,
-            FDC_BASE,
-            FDC_IRQ,
-            FDC_DRQ
-        );
-        SMC37c669_enable_device( FLOPPY_0 );
-          
-	/* Wake up sometimes forgotten floppy, especially on DP264. */
-	outb(0xc, 0x3f2);
-
-        SMC37c669_disable_device( IDE_0 );
-
-#if SMC_DEBUG
-	SMC37c669_config_mode( TRUE );
-	SMC37c669_dump_registers( );
-	SMC37c669_config_mode( FALSE );
-        SMC37c669_display_device_info( );
-#endif
-	local_irq_restore(flags);
-        printk( "SMC37c669 Super I/O Controller found @ 0x%p\n",
-		SMC_base );
-    }
-    else {
-	local_irq_restore(flags);
-#if SMC_DEBUG
-        printk( "No SMC37c669 Super I/O Controller found\n" );
-#endif
-    }
-}
diff -urN flo-ElementalX-5.00/arch/alpha/kernel/sys_titan.c flo-ElementalX-5.00-patched/arch/alpha/kernel/sys_titan.c
--- flo-ElementalX-5.00/arch/alpha/kernel/sys_titan.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/alpha/kernel/sys_titan.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,419 +0,0 @@
-/*
- *	linux/arch/alpha/kernel/sys_titan.c
- *
- *	Copyright (C) 1995 David A Rusling
- *	Copyright (C) 1996, 1999 Jay A Estabrook
- *	Copyright (C) 1998, 1999 Richard Henderson
- *      Copyright (C) 1999, 2000 Jeff Wiedemeier
- *
- * Code supporting TITAN systems (EV6+TITAN), currently:
- *      Privateer
- *	Falcon
- *	Granite
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/sched.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/bitops.h>
-
-#include <asm/ptrace.h>
-#include <asm/dma.h>
-#include <asm/irq.h>
-#include <asm/mmu_context.h>
-#include <asm/io.h>
-#include <asm/pgtable.h>
-#include <asm/core_titan.h>
-#include <asm/hwrpb.h>
-#include <asm/tlbflush.h>
-
-#include "proto.h"
-#include "irq_impl.h"
-#include "pci_impl.h"
-#include "machvec_impl.h"
-#include "err_impl.h"
-
-
-/*
- * Titan generic
- */
-
-/*
- * Titan supports up to 4 CPUs
- */
-static unsigned long titan_cpu_irq_affinity[4] = { ~0UL, ~0UL, ~0UL, ~0UL };
-
-/*
- * Mask is set (1) if enabled
- */
-static unsigned long titan_cached_irq_mask;
-
-/*
- * Need SMP-safe access to interrupt CSRs
- */
-DEFINE_SPINLOCK(titan_irq_lock);
-
-static void
-titan_update_irq_hw(unsigned long mask)
-{
-	register titan_cchip *cchip = TITAN_cchip;
-	unsigned long isa_enable = 1UL << 55;
-	register int bcpu = boot_cpuid;
-
-#ifdef CONFIG_SMP
-	cpumask_t cpm;
-	volatile unsigned long *dim0, *dim1, *dim2, *dim3;
-	unsigned long mask0, mask1, mask2, mask3, dummy;
-
-	cpumask_copy(&cpm, cpu_present_mask);
-	mask &= ~isa_enable;
-	mask0 = mask & titan_cpu_irq_affinity[0];
-	mask1 = mask & titan_cpu_irq_affinity[1];
-	mask2 = mask & titan_cpu_irq_affinity[2];
-	mask3 = mask & titan_cpu_irq_affinity[3];
-
-	if (bcpu == 0) mask0 |= isa_enable;
-	else if (bcpu == 1) mask1 |= isa_enable;
-	else if (bcpu == 2) mask2 |= isa_enable;
-	else mask3 |= isa_enable;
-
-	dim0 = &cchip->dim0.csr;
-	dim1 = &cchip->dim1.csr;
-	dim2 = &cchip->dim2.csr;
-	dim3 = &cchip->dim3.csr;
-	if (!cpumask_test_cpu(0, &cpm)) dim0 = &dummy;
-	if (!cpumask_test_cpu(1, &cpm)) dim1 = &dummy;
-	if (!cpumask_test_cpu(2, &cpm)) dim2 = &dummy;
-	if (!cpumask_test_cpu(3, &cpm)) dim3 = &dummy;
-
-	*dim0 = mask0;
-	*dim1 = mask1;
-	*dim2 = mask2;
-	*dim3 = mask3;
-	mb();
-	*dim0;
-	*dim1;
-	*dim2;
-	*dim3;
-#else
-	volatile unsigned long *dimB;
-	dimB = &cchip->dim0.csr;
-	if (bcpu == 1) dimB = &cchip->dim1.csr;
-	else if (bcpu == 2) dimB = &cchip->dim2.csr;
-	else if (bcpu == 3) dimB = &cchip->dim3.csr;
-
-	*dimB = mask | isa_enable;
-	mb();
-	*dimB;
-#endif
-}
-
-static inline void
-titan_enable_irq(struct irq_data *d)
-{
-	unsigned int irq = d->irq;
-	spin_lock(&titan_irq_lock);
-	titan_cached_irq_mask |= 1UL << (irq - 16);
-	titan_update_irq_hw(titan_cached_irq_mask);
-	spin_unlock(&titan_irq_lock);
-}
-
-static inline void
-titan_disable_irq(struct irq_data *d)
-{
-	unsigned int irq = d->irq;
-	spin_lock(&titan_irq_lock);
-	titan_cached_irq_mask &= ~(1UL << (irq - 16));
-	titan_update_irq_hw(titan_cached_irq_mask);
-	spin_unlock(&titan_irq_lock);
-}
-
-static void
-titan_cpu_set_irq_affinity(unsigned int irq, cpumask_t affinity)
-{
-	int cpu;
-
-	for (cpu = 0; cpu < 4; cpu++) {
-		if (cpumask_test_cpu(cpu, &affinity))
-			titan_cpu_irq_affinity[cpu] |= 1UL << irq;
-		else
-			titan_cpu_irq_affinity[cpu] &= ~(1UL << irq);
-	}
-
-}
-
-static int
-titan_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,
-		       bool force)
-{ 
-	unsigned int irq = d->irq;
-	spin_lock(&titan_irq_lock);
-	titan_cpu_set_irq_affinity(irq - 16, *affinity);
-	titan_update_irq_hw(titan_cached_irq_mask);
-	spin_unlock(&titan_irq_lock);
-
-	return 0;
-}
-
-static void
-titan_device_interrupt(unsigned long vector)
-{
-	printk("titan_device_interrupt: NOT IMPLEMENTED YET!!\n");
-}
-
-static void 
-titan_srm_device_interrupt(unsigned long vector)
-{
-	int irq;
-
-	irq = (vector - 0x800) >> 4;
-	handle_irq(irq);
-}
-
-
-static void __init
-init_titan_irqs(struct irq_chip * ops, int imin, int imax)
-{
-	long i;
-	for (i = imin; i <= imax; ++i) {
-		irq_set_chip_and_handler(i, ops, handle_level_irq);
-		irq_set_status_flags(i, IRQ_LEVEL);
-	}
-}
-
-static struct irq_chip titan_irq_type = {
-       .name			= "TITAN",
-       .irq_unmask		= titan_enable_irq,
-       .irq_mask		= titan_disable_irq,
-       .irq_mask_ack		= titan_disable_irq,
-       .irq_set_affinity	= titan_set_irq_affinity,
-};
-
-static irqreturn_t
-titan_intr_nop(int irq, void *dev_id)
-{
-      /*
-       * This is a NOP interrupt handler for the purposes of
-       * event counting -- just return.
-       */                                                                     
-       return IRQ_HANDLED;
-}
-
-static void __init
-titan_init_irq(void)
-{
-	if (alpha_using_srm && !alpha_mv.device_interrupt)
-		alpha_mv.device_interrupt = titan_srm_device_interrupt;
-	if (!alpha_mv.device_interrupt)
-		alpha_mv.device_interrupt = titan_device_interrupt;
-
-	titan_update_irq_hw(0);
-
-	init_titan_irqs(&titan_irq_type, 16, 63 + 16);
-}
-  
-static void __init
-titan_legacy_init_irq(void)
-{
-	/* init the legacy dma controller */
-	outb(0, DMA1_RESET_REG);
-	outb(0, DMA2_RESET_REG);
-	outb(DMA_MODE_CASCADE, DMA2_MODE_REG);
-	outb(0, DMA2_MASK_REG);
-
-	/* init the legacy irq controller */
-	init_i8259a_irqs();
-
-	/* init the titan irqs */
-	titan_init_irq();
-}
-
-void
-titan_dispatch_irqs(u64 mask)
-{
-	unsigned long vector;
-
-	/*
-	 * Mask down to those interrupts which are enable on this processor
-	 */
-	mask &= titan_cpu_irq_affinity[smp_processor_id()];
-
-	/*
-	 * Dispatch all requested interrupts 
-	 */
-	while (mask) {
-		/* convert to SRM vector... priority is <63> -> <0> */
-		vector = 63 - __kernel_ctlz(mask);
-		mask &= ~(1UL << vector);	/* clear it out 	 */
-		vector = 0x900 + (vector << 4);	/* convert to SRM vector */
-		
-		/* dispatch it */
-		alpha_mv.device_interrupt(vector);
-	}
-}
-  
-
-/*
- * Titan Family
- */
-static void __init
-titan_request_irq(unsigned int irq, irq_handler_t handler,
-		  unsigned long irqflags, const char *devname,
-		  void *dev_id)
-{
-	int err;
-	err = request_irq(irq, handler, irqflags, devname, dev_id);
-	if (err) {
-		printk("titan_request_irq for IRQ %d returned %d; ignoring\n",
-		       irq, err);
-	}
-}
-
-static void __init
-titan_late_init(void)
-{
-	/*
-	 * Enable the system error interrupts. These interrupts are 
-	 * all reported to the kernel as machine checks, so the handler
-	 * is a nop so it can be called to count the individual events.
-	 */
-	titan_request_irq(63+16, titan_intr_nop, IRQF_DISABLED,
-		    "CChip Error", NULL);
-	titan_request_irq(62+16, titan_intr_nop, IRQF_DISABLED,
-		    "PChip 0 H_Error", NULL);
-	titan_request_irq(61+16, titan_intr_nop, IRQF_DISABLED,
-		    "PChip 1 H_Error", NULL);
-	titan_request_irq(60+16, titan_intr_nop, IRQF_DISABLED,
-		    "PChip 0 C_Error", NULL);
-	titan_request_irq(59+16, titan_intr_nop, IRQF_DISABLED,
-		    "PChip 1 C_Error", NULL);
-
-	/* 
-	 * Register our error handlers.
-	 */
-	titan_register_error_handlers();
-
-	/*
-	 * Check if the console left us any error logs.
-	 */
-	cdl_check_console_data_log();
-
-}
-
-static int __devinit
-titan_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	u8 intline;
-	int irq;
-
- 	/* Get the current intline.  */
-	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &intline);
-	irq = intline;
-
- 	/* Is it explicitly routed through ISA?  */
- 	if ((irq & 0xF0) == 0xE0)
- 		return irq;
- 
- 	/* Offset by 16 to make room for ISA interrupts 0 - 15.  */
- 	return irq + 16;
-}
-
-static void __init
-titan_init_pci(void)
-{
- 	/*
- 	 * This isn't really the right place, but there's some init
- 	 * that needs to be done after everything is basically up.
- 	 */
- 	titan_late_init();
- 
-	/* Indicate that we trust the console to configure things properly */
-	pci_set_flags(PCI_PROBE_ONLY);
-	common_init_pci();
-	SMC669_Init(0);
-	locate_and_init_vga(NULL);
-}
-
-
-/*
- * Privateer
- */
-static void __init
-privateer_init_pci(void)
-{
-	/*
-	 * Hook a couple of extra err interrupts that the
-	 * common titan code won't.
-	 */
-	titan_request_irq(53+16, titan_intr_nop, IRQF_DISABLED,
-		    "NMI", NULL);
-	titan_request_irq(50+16, titan_intr_nop, IRQF_DISABLED,
-		    "Temperature Warning", NULL);
-
-	/*
-	 * Finish with the common version.
-	 */
-	return titan_init_pci();
-}
-
-
-/*
- * The System Vectors.
- */
-struct alpha_machine_vector titan_mv __initmv = {
-	.vector_name		= "TITAN",
-	DO_EV6_MMU,
-	DO_DEFAULT_RTC,
-	DO_TITAN_IO,
-	.machine_check		= titan_machine_check,
-	.max_isa_dma_address	= ALPHA_MAX_ISA_DMA_ADDRESS,
-	.min_io_address		= DEFAULT_IO_BASE,
-	.min_mem_address	= DEFAULT_MEM_BASE,
-	.pci_dac_offset		= TITAN_DAC_OFFSET,
-
-	.nr_irqs		= 80,	/* 64 + 16 */
-	/* device_interrupt will be filled in by titan_init_irq */
-
-	.agp_info		= titan_agp_info,
-
-	.init_arch		= titan_init_arch,
-	.init_irq		= titan_legacy_init_irq,
-	.init_rtc		= common_init_rtc,
-	.init_pci		= titan_init_pci,
-
-	.kill_arch		= titan_kill_arch,
-	.pci_map_irq		= titan_map_irq,
-	.pci_swizzle		= common_swizzle,
-};
-ALIAS_MV(titan)
-
-struct alpha_machine_vector privateer_mv __initmv = {
-	.vector_name		= "PRIVATEER",
-	DO_EV6_MMU,
-	DO_DEFAULT_RTC,
-	DO_TITAN_IO,
-	.machine_check		= privateer_machine_check,
-	.max_isa_dma_address	= ALPHA_MAX_ISA_DMA_ADDRESS,
-	.min_io_address		= DEFAULT_IO_BASE,
-	.min_mem_address	= DEFAULT_MEM_BASE,
-	.pci_dac_offset		= TITAN_DAC_OFFSET,
-
-	.nr_irqs		= 80,	/* 64 + 16 */
-	/* device_interrupt will be filled in by titan_init_irq */
-
-	.agp_info		= titan_agp_info,
-
-	.init_arch		= titan_init_arch,
-	.init_irq		= titan_legacy_init_irq,
-	.init_rtc		= common_init_rtc,
-	.init_pci		= privateer_init_pci,
-
-	.kill_arch		= titan_kill_arch,
-	.pci_map_irq		= titan_map_irq,
-	.pci_swizzle		= common_swizzle,
-};
-/* No alpha_mv alias for privateer since we compile it 
-   in unconditionally with titan; setup_arch knows how to cope. */
diff -urN flo-ElementalX-5.00/arch/arm/boot/compressed/ashldi3.S flo-ElementalX-5.00-patched/arch/arm/boot/compressed/ashldi3.S
--- flo-ElementalX-5.00/arch/arm/boot/compressed/ashldi3.S	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/boot/compressed/ashldi3.S	2016-06-03 17:56:14.000000000 +0000
@@ -0,0 +1,53 @@
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+
+#include <linux/linkage.h>
+
+#ifdef __ARMEB__
+#define al r1
+#define ah r0
+#else
+#define al r0
+#define ah r1
+#endif
+
+ENTRY(__ashldi3)
+ENTRY(__aeabi_llsl)
+
+	subs	r3, r2, #32
+	rsb	ip, r2, #32
+	movmi	ah, ah, lsl r2
+	movpl	ah, al, lsl r3
+ ARM(	orrmi	ah, ah, al, lsr ip	)
+ THUMB(	lsrmi	r3, al, ip		)
+ THUMB(	orrmi	ah, ah, r3		)
+	mov	al, al, lsl r2
+	mov	pc, lr
+
+ENDPROC(__ashldi3)
+ENDPROC(__aeabi_llsl)
Binary files flo-ElementalX-5.00/arch/arm/boot/vmlinuz and flo-ElementalX-5.00-patched/arch/arm/boot/vmlinuz differ
diff -urN flo-ElementalX-5.00/arch/arm/configs/elementalx_defconfig flo-ElementalX-5.00-patched/arch/arm/configs/elementalx_defconfig
--- flo-ElementalX-5.00/arch/arm/configs/elementalx_defconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/configs/elementalx_defconfig	2016-05-10 02:52:00.000000000 +0000
@@ -40,7 +40,7 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION="-ElementalX-N7-5.14"
+CONFIG_LOCALVERSION="-ElementalX-N7-5.12"
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
@@ -2849,7 +2849,6 @@
 CONFIG_FB_MSM_LCDC_HW=y
 CONFIG_FB_MSM_TRIPLE_BUFFER=y
 CONFIG_FB_MSM_MDP_HW=y
-# CONFIG_MDP_DEBUG_FS is not set
 # CONFIG_FB_MSM_MDP22 is not set
 # CONFIG_FB_MSM_MDP30 is not set
 # CONFIG_FB_MSM_MDP31 is not set
@@ -3769,7 +3768,7 @@
 CONFIG_NTFS_FS=y
 # CONFIG_NTFS_DEBUG is not set
 CONFIG_NTFS_RW=y
-CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_FS=m
 CONFIG_EXFAT_DEFAULT_CODEPAGE=437
 CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
 
diff -urN flo-ElementalX-5.00/arch/arm/mach-iop33x/include/mach/hardware.h flo-ElementalX-5.00-patched/arch/arm/mach-iop33x/include/mach/hardware.h
--- flo-ElementalX-5.00/arch/arm/mach-iop33x/include/mach/hardware.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-iop33x/include/mach/hardware.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,43 +0,0 @@
-/*
- * arch/arm/mach-iop33x/include/mach/hardware.h
- */
-
-#ifndef __HARDWARE_H
-#define __HARDWARE_H
-
-#include <asm/types.h>
-
-/*
- * Note about PCI IO space mappings
- *
- * To make IO space accesses efficient, we store virtual addresses in
- * the IO resources.
- *
- * The PCI IO space is located at virtual 0xfe000000 from physical
- * 0x90000000.  The PCI BARs must be programmed with physical addresses,
- * but when we read them, we convert them to virtual addresses.  See
- * arch/arm/mach-iop3xx/iop3xx-pci.c
- */
-
-#ifndef __ASSEMBLY__
-void iop33x_init_irq(void);
-
-extern struct platform_device iop33x_uart0_device;
-extern struct platform_device iop33x_uart1_device;
-#endif
-
-
-/*
- * Generic chipset bits
- *
- */
-#include "iop33x.h"
-
-/*
- * Board specific bits
- */
-#include "iq80331.h"
-#include "iq80332.h"
-
-
-#endif
diff -urN flo-ElementalX-5.00/arch/arm/mach-msm/lge/lge_panic_handler.c flo-ElementalX-5.00-patched/arch/arm/mach-msm/lge/lge_panic_handler.c
--- flo-ElementalX-5.00/arch/arm/mach-msm/lge/lge_panic_handler.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-msm/lge/lge_panic_handler.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,317 +0,0 @@
-/*
- * arch/arm/mach-msm/lge/lge_panic_handler.c
- *
- * Copyright (C) 2010 LGE, Inc
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/reboot.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/persistent_ram.h>
-#include <asm/setup.h>
-#include <mach/board_lge.h>
-
-#include <mach/subsystem_restart.h>
-#ifdef CONFIG_CPU_CP15_MMU
-#include <linux/ptrace.h>
-#endif
-
-#define PANIC_HANDLER_NAME "panic-handler"
-#define PANIC_DUMP_CONSOLE 0
-#define PANIC_MAGIC_KEY    0x12345678
-#define NORMAL_MAGIC_KEY   0x4E4F524D
-#define CRASH_ARM9         0x87654321
-#define CRASH_REBOOT       0x618E1000
-
-struct crash_log_dump {
-	unsigned int magic_key;
-	unsigned int size;
-	unsigned char buffer[0];
-};
-
-static struct crash_log_dump *crash_dump_log;
-static unsigned int crash_buf_size = 0;
-static int crash_store_flag = 0;
-
-#ifdef CONFIG_CPU_CP15_MMU
-unsigned long *cpu_crash_ctx=NULL;
-#endif
-
-unsigned int msm_mmuctrl;
-unsigned int msm_mmudac;
-
-void store_ctrl(void)
-{
-	asm("mrc p15, 0, %0, c1, c0, 0\n"
-			: "=r" (msm_mmuctrl));
-}
-
-void store_dac(void)
-{
-	asm("mrc p15, 0, %0, c3, c0, 0\n"
-			: "=r" (msm_mmudac));
-}
-static DEFINE_SPINLOCK(panic_lock);
-
-static int dummy_arg;
-static int gen_bug(const char *val, struct kernel_param *kp)
-{
-	BUG();
-	return 0;
-}
-module_param_call(gen_bug, gen_bug, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_panic(const char *val, struct kernel_param *kp)
-{
-	panic("generate test-panic");
-	return 0;
-}
-module_param_call(gen_panic, gen_panic, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_mdm_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("external_modem");
-	return 0;
-}
-module_param_call(gen_mdm_ssr, gen_mdm_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_modem_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("modem");
-	return 0;
-}
-module_param_call(gen_modem_ssr, gen_modem_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_riva_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("riva");
-	return 0;
-}
-module_param_call(gen_riva_ssr, gen_riva_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_dsps_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("dsps");
-	return 0;
-}
-module_param_call(gen_dsps_ssr, gen_dsps_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_lpass_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("lpass");
-	return 0;
-}
-module_param_call(gen_lpass_ssr, gen_lpass_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-#define WDT0_RST        0x38
-#define WDT0_EN         0x40
-#define WDT0_BARK_TIME  0x4C
-#define WDT0_BITE_TIME  0x5C
-
-extern void __iomem *msm_timer_get_timer0_base(void);
-
-static int gen_wdt_bark(const char *val, struct kernel_param *kp)
-{
-	static void __iomem *msm_tmr0_base;
-	msm_tmr0_base = msm_timer_get_timer0_base();
-	__raw_writel(0, msm_tmr0_base + WDT0_EN);
-	__raw_writel(1, msm_tmr0_base + WDT0_RST);
-	__raw_writel(0x31F3, msm_tmr0_base + WDT0_BARK_TIME);
-	__raw_writel(5 * 0x31F3, msm_tmr0_base + WDT0_BITE_TIME);
-	__raw_writel(1, msm_tmr0_base + WDT0_EN);
-	return 0;
-}
-module_param_call(gen_wdt_bark, gen_wdt_bark, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_hw_reset(const char *val, struct kernel_param *kp)
-{
-	static void __iomem *msm_tmr0_base;
-	msm_tmr0_base = msm_timer_get_timer0_base();
-	__raw_writel(0, msm_tmr0_base + WDT0_EN);
-	__raw_writel(1, msm_tmr0_base + WDT0_RST);
-	__raw_writel(5 * 0x31F3, msm_tmr0_base + WDT0_BARK_TIME);
-	__raw_writel(0x31F3, msm_tmr0_base + WDT0_BITE_TIME);
-	__raw_writel(1, msm_tmr0_base + WDT0_EN);
-	return 0;
-}
-module_param_call(gen_hw_reset, gen_hw_reset, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-void set_crash_store_enable(void)
-{
-	if (crash_dump_log->magic_key == NORMAL_MAGIC_KEY)
-		crash_store_flag = 1;
-	return;
-}
-
-void set_crash_store_disable(void)
-{
-	crash_store_flag = 0;
-	return;
-}
-
-void store_crash_log(char *p)
-{
-	if (!crash_dump_log)
-		return;
-
-	if (!crash_store_flag)
-		return;
-
-	if (crash_dump_log->size == crash_buf_size)
-		return;
-
-	for ( ; *p; p++) {
-		if (*p == '[') {
-			for ( ; *p != ']'; p++)
-				;
-			p++;
-			if (*p == ' ')
-				p++;
-		}
-		if (*p == '<') {
-			for ( ; *p != '>'; p++)
-				;
-			p++;
-		}
-
-		crash_dump_log->buffer[crash_dump_log->size++] = *p;
-
-		/* check the buffer size */
-		if (crash_dump_log->size == crash_buf_size)
-			break;
-	}
-	crash_dump_log->buffer[crash_dump_log->size] = 0;
-
-	return;
-}
-
-#ifdef CONFIG_CPU_CP15_MMU
-void lge_save_ctx(struct pt_regs* regs, unsigned int ctrl,
-		unsigned int transbase, unsigned int dac)
-{
-	/* save cpu register for simulation */
-	cpu_crash_ctx[0] = regs->ARM_r0;
-	cpu_crash_ctx[1] = regs->ARM_r1;
-	cpu_crash_ctx[2] = regs->ARM_r2;
-	cpu_crash_ctx[3] = regs->ARM_r3;
-	cpu_crash_ctx[4] = regs->ARM_r4;
-	cpu_crash_ctx[5] = regs->ARM_r5;
-	cpu_crash_ctx[6] = regs->ARM_r6;
-	cpu_crash_ctx[7] = regs->ARM_r7;
-	cpu_crash_ctx[8] = regs->ARM_r8;
-	cpu_crash_ctx[9] = regs->ARM_r9;
-	cpu_crash_ctx[10] = regs->ARM_r10;
-	cpu_crash_ctx[11] = regs->ARM_fp;
-	cpu_crash_ctx[12] = regs->ARM_ip;
-	cpu_crash_ctx[13] = regs->ARM_sp;
-	cpu_crash_ctx[14] = regs->ARM_lr;
-	cpu_crash_ctx[15] = regs->ARM_pc;
-	cpu_crash_ctx[16] = regs->ARM_cpsr;
-	/* save mmu register for simulation */
-	cpu_crash_ctx[17] = ctrl;
-	cpu_crash_ctx[18] = transbase;
-	cpu_crash_ctx[19] = dac;
-}
-#endif
-
-static int restore_crash_log(struct notifier_block *this,
-		unsigned long event, void *ptr)
-{
-	unsigned long flags;
-	crash_store_flag = 0;
-	spin_lock_irqsave(&panic_lock, flags);
-	crash_dump_log->magic_key = PANIC_MAGIC_KEY;
-	spin_unlock_irqrestore(&panic_lock, flags);
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block panic_handler_block = {
-	.notifier_call = restore_crash_log,
-};
-
-static int __init panic_handler_probe(struct platform_device *pdev)
-{
-	struct persistent_ram_zone *prz;
-	size_t buffer_size;
-	void *buffer;
-	int ret = 0;
-#ifdef CONFIG_CPU_CP15_MMU
-	void *ctx_buf;
-#endif
-
-	prz = persistent_ram_init_ringbuffer(&pdev->dev, false);
-	if (IS_ERR(prz))
-		return PTR_ERR(prz);
-
-	buffer_size = prz->buffer_size - SZ_1K;
-	buffer = (void *)prz->buffer;;
-
-	crash_dump_log = (struct crash_log_dump *)buffer;
-	memset(crash_dump_log, 0, buffer_size);
-	crash_dump_log->magic_key = NORMAL_MAGIC_KEY;
-	crash_dump_log->size = 0;
-	crash_buf_size =
-		buffer_size - offsetof(struct crash_log_dump, buffer) - 1;
-#ifdef CONFIG_CPU_CP15_MMU
-	ctx_buf = (void *)(buffer + buffer_size);
-	cpu_crash_ctx = (unsigned long *)ctx_buf;
-#endif
-	atomic_notifier_chain_register(&panic_notifier_list,
-			&panic_handler_block);
-	return ret;
-}
-
-static int __devexit panic_handler_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver panic_handler_driver __refdata = {
-	.probe = panic_handler_probe,
-	.remove = __devexit_p(panic_handler_remove),
-	.driver = {
-		.name = PANIC_HANDLER_NAME,
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init lge_panic_handler_init(void)
-{
-	return platform_driver_register(&panic_handler_driver);
-}
-
-static void __exit lge_panic_handler_exit(void)
-{
-	platform_driver_unregister(&panic_handler_driver);
-}
-
-module_init(lge_panic_handler_init);
-module_exit(lge_panic_handler_exit);
-
-MODULE_DESCRIPTION("LGE panic handler driver");
-MODULE_AUTHOR("SungEun Kim <cleaneye.kim@lge.com>");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/arch/arm/mach-msm/msm_watchdog.c flo-ElementalX-5.00-patched/arch/arm/mach-msm/msm_watchdog.c
--- flo-ElementalX-5.00/arch/arm/mach-msm/msm_watchdog.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-msm/msm_watchdog.c	2016-05-12 18:51:09.000000000 +0000
@@ -270,6 +270,8 @@
 		min_slack_ns = slack_ns;
 	last_pet = time_ns;
 }
+EXPORT_SYMBOL(pet_watchdog);
+
 
 static void pet_watchdog_work(struct work_struct *work)
 {
diff -urN flo-ElementalX-5.00/arch/arm/mach-msm/ramdump.c flo-ElementalX-5.00-patched/arch/arm/mach-msm/ramdump.c
--- flo-ElementalX-5.00/arch/arm/mach-msm/ramdump.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-msm/ramdump.c	2016-05-12 18:52:04.000000000 +0000
@@ -247,6 +247,7 @@
 
 	return (void *)rd_dev;
 }
+EXPORT_SYMBOL(create_ramdump_device);
 
 void destroy_ramdump_device(void *dev)
 {
@@ -298,3 +299,4 @@
 	rd_dev->data_ready = 0;
 	return ret;
 }
+EXPORT_SYMBOL(do_ramdump);
\ No newline at end of file
diff -urN flo-ElementalX-5.00/arch/arm/mach-omap2/omap_opp_data.h flo-ElementalX-5.00-patched/arch/arm/mach-omap2/omap_opp_data.h
--- flo-ElementalX-5.00/arch/arm/mach-omap2/omap_opp_data.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-omap2/omap_opp_data.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,96 +0,0 @@
-/*
- * OMAP SoC specific OPP Data helpers
- *
- * Copyright (C) 2009-2010 Texas Instruments Incorporated - http://www.ti.com/
- *	Nishanth Menon
- *	Kevin Hilman
- * Copyright (C) 2010 Nokia Corporation.
- *      Eduardo Valentin
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#ifndef __ARCH_ARM_MACH_OMAP2_OMAP_OPP_DATA_H
-#define __ARCH_ARM_MACH_OMAP2_OMAP_OPP_DATA_H
-
-#include <plat/omap_hwmod.h>
-
-#include "voltage.h"
-
-/*
- * *BIG FAT WARNING*:
- * USE the following ONLY in opp data initialization common to an SoC.
- * DO NOT USE these in board files/pm core etc.
- */
-
-/**
- * struct omap_opp_def - OMAP OPP Definition
- * @hwmod_name:	Name of the hwmod for this domain
- * @freq:	Frequency in hertz corresponding to this OPP
- * @u_volt:	Nominal voltage in microvolts corresponding to this OPP
- * @default_available:	True/false - is this OPP available by default
- *
- * OMAP SOCs have a standard set of tuples consisting of frequency and voltage
- * pairs that the device will support per voltage domain. This is called
- * Operating Points or OPP. The actual definitions of OMAP Operating Points
- * varies over silicon within the same family of devices. For a specific
- * domain, you can have a set of {frequency, voltage} pairs and this is denoted
- * by an array of omap_opp_def. As the kernel boots and more information is
- * available, a set of these are activated based on the precise nature of
- * device the kernel boots up on. It is interesting to remember that each IP
- * which belongs to a voltage domain may define their own set of OPPs on top
- * of this - but this is handled by the appropriate driver.
- */
-struct omap_opp_def {
-	char *hwmod_name;
-
-	unsigned long freq;
-	unsigned long u_volt;
-
-	bool default_available;
-};
-
-/*
- * Initialization wrapper used to define an OPP for OMAP variants.
- */
-#define OPP_INITIALIZER(_hwmod_name, _enabled, _freq, _uv)	\
-{								\
-	.hwmod_name	= _hwmod_name,				\
-	.default_available	= _enabled,			\
-	.freq		= _freq,				\
-	.u_volt		= _uv,					\
-}
-
-/*
- * Initialization wrapper used to define SmartReflex process data
- * XXX Is this needed?  Just use C99 initializers in data files?
- */
-#define VOLT_DATA_DEFINE(_v_nom, _efuse_offs, _errminlimit, _errgain)  \
-{								       \
-	.volt_nominal	= _v_nom,				       \
-	.sr_efuse_offs	= _efuse_offs,				       \
-	.sr_errminlimit = _errminlimit,				       \
-	.vp_errgain	= _errgain				       \
-}
-
-/* Use this to initialize the default table */
-extern int __init omap_init_opp_table(struct omap_opp_def *opp_def,
-		u32 opp_def_size);
-
-
-extern struct omap_volt_data omap34xx_vddmpu_volt_data[];
-extern struct omap_volt_data omap34xx_vddcore_volt_data[];
-extern struct omap_volt_data omap36xx_vddmpu_volt_data[];
-extern struct omap_volt_data omap36xx_vddcore_volt_data[];
-
-extern struct omap_volt_data omap44xx_vdd_mpu_volt_data[];
-extern struct omap_volt_data omap44xx_vdd_iva_volt_data[];
-extern struct omap_volt_data omap44xx_vdd_core_volt_data[];
-
-#endif		/* __ARCH_ARM_MACH_OMAP2_OMAP_OPP_DATA_H */
diff -urN flo-ElementalX-5.00/arch/arm/mach-pxa/include/mach/regs-ac97.h flo-ElementalX-5.00-patched/arch/arm/mach-pxa/include/mach/regs-ac97.h
--- flo-ElementalX-5.00/arch/arm/mach-pxa/include/mach/regs-ac97.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-pxa/include/mach/regs-ac97.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,101 +0,0 @@
-#ifndef __ASM_ARCH_REGS_AC97_H
-#define __ASM_ARCH_REGS_AC97_H
-
-#include <mach/hardware.h>
-
-/*
- * AC97 Controller registers
- */
-
-#define POCR		__REG(0x40500000)  /* PCM Out Control Register */
-#define POCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define POCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define PICR		__REG(0x40500004)  /* PCM In Control Register */
-#define PICR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define PICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MCCR		__REG(0x40500008)  /* Mic In Control Register */
-#define MCCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define MCCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define GCR		__REG(0x4050000C)  /* Global Control Register */
-#ifdef CONFIG_PXA3xx
-#define GCR_CLKBPB	(1 << 31)	/* Internal clock enable */
-#endif
-#define GCR_nDMAEN	(1 << 24)	/* non DMA Enable */
-#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
-#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
-#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
-#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
-#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
-#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
-#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
-#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
-#define GCR_COLD_RST	(1 << 1)	/* AC'97 Cold Reset (0 = active) */
-#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
-
-#define POSR		__REG(0x40500010)  /* PCM Out Status Register */
-#define POSR_FIFOE	(1 << 4)	/* FIFO error */
-#define POSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define PISR		__REG(0x40500014)  /* PCM In Status Register */
-#define PISR_FIFOE	(1 << 4)	/* FIFO error */
-#define PISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define PISR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MCSR		__REG(0x40500018)  /* Mic In Status Register */
-#define MCSR_FIFOE	(1 << 4)	/* FIFO error */
-#define MCSR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define MCSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define GSR		__REG(0x4050001C)  /* Global Status Register */
-#define GSR_CDONE	(1 << 19)	/* Command Done */
-#define GSR_SDONE	(1 << 18)	/* Status Done */
-#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
-#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
-#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
-#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
-#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
-#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
-#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
-#define GSR_PCR		(1 << 8)	/*  Primary Codec Ready */
-#define GSR_MCINT	(1 << 7)	/* Mic In Interrupt */
-#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
-#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
-#define GSR_ACOFFD	(1 << 3)	/* AC-link Shut Off Done */
-#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
-#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
-#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
-
-#define CAR		__REG(0x40500020)  /* CODEC Access Register */
-#define CAR_CAIP	(1 << 0)	/* Codec Access In Progress */
-
-#define PCDR		__REG(0x40500040)  /* PCM FIFO Data Register */
-#define MCDR		__REG(0x40500060)  /* Mic-in FIFO Data Register */
-
-#define MOCR		__REG(0x40500100)  /* Modem Out Control Register */
-#define MOCR_FEIE	(1 << 3)	/* FIFO Error */
-#define MOCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MICR		__REG(0x40500108)  /* Modem In Control Register */
-#define MICR_FEIE	(1 << 3)	/* FIFO Error */
-#define MICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MOSR		__REG(0x40500110)  /* Modem Out Status Register */
-#define MOSR_FIFOE	(1 << 4)	/* FIFO error */
-#define MOSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MISR		__REG(0x40500118)  /* Modem In Status Register */
-#define MISR_FIFOE	(1 << 4)	/* FIFO error */
-#define MISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define MISR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MODR		__REG(0x40500140)  /* Modem FIFO Data Register */
-
-#define PAC_REG_BASE	__REG(0x40500200)  /* Primary Audio Codec */
-#define SAC_REG_BASE	__REG(0x40500300)  /* Secondary Audio Codec */
-#define PMC_REG_BASE	__REG(0x40500400)  /* Primary Modem Codec */
-#define SMC_REG_BASE	__REG(0x40500500)  /* Secondary Modem Codec */
-
-#endif /* __ASM_ARCH_REGS_AC97_H */
diff -urN flo-ElementalX-5.00/arch/arm/mach-sa1100/include/mach/nanoengine.h flo-ElementalX-5.00-patched/arch/arm/mach-sa1100/include/mach/nanoengine.h
--- flo-ElementalX-5.00/arch/arm/mach-sa1100/include/mach/nanoengine.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-sa1100/include/mach/nanoengine.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,52 +0,0 @@
-/*
- * arch/arm/mach-sa1100/include/mach/nanoengine.h
- *
- * This file contains the hardware specific definitions for nanoEngine.
- * Only include this file from SA1100-specific files.
- *
- * Copyright (C) 2010 Marcelo Roberto Jimenez <mroberto@cpti.cetuc.puc-rio.br>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-#ifndef __ASM_ARCH_NANOENGINE_H
-#define __ASM_ARCH_NANOENGINE_H
-
-#include <mach/irqs.h>
-
-#define GPIO_PC_READY0	11 /* ready for socket 0 (active high)*/
-#define GPIO_PC_READY1	12 /* ready for socket 1 (active high) */
-#define GPIO_PC_CD0	13 /* detect for socket 0 (active low) */
-#define GPIO_PC_CD1	14 /* detect for socket 1 (active low) */
-#define GPIO_PC_RESET0	15 /* reset socket 0 */
-#define GPIO_PC_RESET1	16 /* reset socket 1 */
-
-#define NANOENGINE_IRQ_GPIO_PCI		IRQ_GPIO0
-#define NANOENGINE_IRQ_GPIO_PC_READY0	IRQ_GPIO11
-#define NANOENGINE_IRQ_GPIO_PC_READY1	IRQ_GPIO12
-#define NANOENGINE_IRQ_GPIO_PC_CD0	IRQ_GPIO13
-#define NANOENGINE_IRQ_GPIO_PC_CD1	IRQ_GPIO14
-
-/*
- * nanoEngine Memory Map:
- *
- * 0000.0000 - 003F.0000 -   4 MB Flash
- * C000.0000 - C1FF.FFFF -  32 MB SDRAM
- * 1860.0000 - 186F.FFFF -   1 MB Internal PCI Memory Read/Write
- * 18A1.0000 - 18A1.FFFF -  64 KB Internal PCI Config Space
- * 4000.0000 - 47FF.FFFF - 128 MB External Bus I/O - Multiplexed Mode
- * 4800.0000 - 4FFF.FFFF - 128 MB External Bus I/O - Non-Multiplexed Mode
- *
- */
-
-#define NANO_PCI_MEM_RW_PHYS		0x18600000
-#define NANO_PCI_MEM_RW_VIRT		0xf1000000
-#define NANO_PCI_MEM_RW_SIZE		SZ_1M
-#define NANO_PCI_CONFIG_SPACE_PHYS	0x18A10000
-#define NANO_PCI_CONFIG_SPACE_VIRT	0xf2000000
-#define NANO_PCI_CONFIG_SPACE_SIZE	SZ_64K
-
-#endif
-
diff -urN flo-ElementalX-5.00/arch/arm/mach-shmobile/board-bonito.c flo-ElementalX-5.00-patched/arch/arm/mach-shmobile/board-bonito.c
--- flo-ElementalX-5.00/arch/arm/mach-shmobile/board-bonito.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-shmobile/board-bonito.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,504 +0,0 @@
-/*
- * bonito board support
- *
- * Copyright (C) 2011 Renesas Solutions Corp.
- * Copyright (C) 2011 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-#include <linux/smsc911x.h>
-#include <linux/videodev2.h>
-#include <mach/common.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/time.h>
-#include <asm/hardware/cache-l2x0.h>
-#include <mach/r8a7740.h>
-#include <mach/irqs.h>
-#include <video/sh_mobile_lcdc.h>
-
-/*
- * CS	Address		device			note
- *----------------------------------------------------------------
- * 0	0x0000_0000	NOR Flash (64MB)	SW12 : bit3 = OFF
- * 2	0x0800_0000	ExtNOR (64MB)		SW12 : bit3 = OFF
- * 4			-
- * 5A			-
- * 5B	0x1600_0000	SRAM (8MB)
- * 6	0x1800_0000	FPGA (64K)
- *	0x1801_0000	Ether (4KB)
- *	0x1801_1000	USB (4KB)
- */
-
-/*
- * SW12
- *
- *	bit1			bit2			bit3
- *----------------------------------------------------------------------------
- * ON	NOR WriteProtect	NAND WriteProtect	CS0 ExtNOR / CS2 NOR
- * OFF	NOR Not WriteProtect	NAND Not WriteProtect	CS0 NOR    / CS2 ExtNOR
- */
-
-/*
- * SCIFA5 (CN42)
- *
- * S38.3 = ON
- * S39.6 = ON
- * S43.1 = ON
- */
-
-/*
- * LCDC0 (CN3/CN4/CN7)
- *
- * S38.1 = OFF
- * S38.2 = OFF
- */
-
-/*
- * FPGA
- */
-#define IRQSR0		0x0020
-#define IRQSR1		0x0022
-#define IRQMR0		0x0030
-#define IRQMR1		0x0032
-#define BUSSWMR1	0x0070
-#define BUSSWMR2	0x0072
-#define BUSSWMR3	0x0074
-#define BUSSWMR4	0x0076
-
-#define LCDCR		0x10B4
-#define DEVRSTCR1	0x10D0
-#define DEVRSTCR2	0x10D2
-#define A1MDSR		0x10E0
-#define BVERR		0x1100
-
-/* FPGA IRQ */
-#define FPGA_IRQ_BASE		(512)
-#define FPGA_IRQ0		(FPGA_IRQ_BASE)
-#define FPGA_IRQ1		(FPGA_IRQ_BASE + 16)
-#define FPGA_ETH_IRQ		(FPGA_IRQ0 + 15)
-static u16 bonito_fpga_read(u32 offset)
-{
-	return __raw_readw(0xf0003000 + offset);
-}
-
-static void bonito_fpga_write(u32 offset, u16 val)
-{
-	__raw_writew(val, 0xf0003000 + offset);
-}
-
-static void bonito_fpga_irq_disable(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	u32 addr = (irq < 1016) ? IRQMR0 : IRQMR1;
-	int shift = irq % 16;
-
-	bonito_fpga_write(addr, bonito_fpga_read(addr) | (1 << shift));
-}
-
-static void bonito_fpga_irq_enable(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	u32 addr = (irq < 1016) ? IRQMR0 : IRQMR1;
-	int shift = irq % 16;
-
-	bonito_fpga_write(addr, bonito_fpga_read(addr) & ~(1 << shift));
-}
-
-static struct irq_chip bonito_fpga_irq_chip __read_mostly = {
-	.name		= "bonito FPGA",
-	.irq_mask	= bonito_fpga_irq_disable,
-	.irq_unmask	= bonito_fpga_irq_enable,
-};
-
-static void bonito_fpga_irq_demux(unsigned int irq, struct irq_desc *desc)
-{
-	u32 val =  bonito_fpga_read(IRQSR1) << 16 |
-		   bonito_fpga_read(IRQSR0);
-	u32 mask = bonito_fpga_read(IRQMR1) << 16 |
-		   bonito_fpga_read(IRQMR0);
-
-	int i;
-
-	val &= ~mask;
-
-	for (i = 0; i < 32; i++) {
-		if (!(val & (1 << i)))
-			continue;
-
-		generic_handle_irq(FPGA_IRQ_BASE + i);
-	}
-}
-
-static void bonito_fpga_init(void)
-{
-	int i;
-
-	bonito_fpga_write(IRQMR0, 0xffff); /* mask all */
-	bonito_fpga_write(IRQMR1, 0xffff); /* mask all */
-
-	/* Device reset */
-	bonito_fpga_write(DEVRSTCR1,
-		   (1 << 2));	/* Eth */
-
-	/* FPGA irq require special handling */
-	for (i = FPGA_IRQ_BASE; i < FPGA_IRQ_BASE + 32; i++) {
-		irq_set_chip_and_handler_name(i, &bonito_fpga_irq_chip,
-					      handle_level_irq, "level");
-		set_irq_flags(i, IRQF_VALID); /* yuck */
-	}
-
-	irq_set_chained_handler(evt2irq(0x0340), bonito_fpga_irq_demux);
-	irq_set_irq_type(evt2irq(0x0340), IRQ_TYPE_LEVEL_LOW);
-}
-
-/*
-* PMIC settings
-*
-* FIXME
-*
-* bonito board needs some settings by pmic which use i2c access.
-* pmic settings use device_initcall() here for use it.
-*/
-static __u8 *pmic_settings = NULL;
-static __u8 pmic_do_2A[] = {
-	0x1C, 0x09,
-	0x1A, 0x80,
-	0xff, 0xff,
-};
-
-static int __init pmic_init(void)
-{
-	struct i2c_adapter *a = i2c_get_adapter(0);
-	struct i2c_msg msg;
-	__u8 buf[2];
-	int i, ret;
-
-	if (!pmic_settings)
-		return 0;
-	if (!a)
-		return 0;
-
-	msg.addr	= 0x46;
-	msg.buf		= buf;
-	msg.len		= 2;
-	msg.flags	= 0;
-
-	for (i = 0; ; i += 2) {
-		buf[0] = pmic_settings[i + 0];
-		buf[1] = pmic_settings[i + 1];
-
-		if ((0xff == buf[0]) && (0xff == buf[1]))
-			break;
-
-		ret = i2c_transfer(a, &msg, 1);
-		if (ret < 0) {
-			pr_err("i2c transfer fail\n");
-			break;
-		}
-	}
-
-	return 0;
-}
-device_initcall(pmic_init);
-
-/*
- * LCDC0
- */
-static const struct fb_videomode lcdc0_mode = {
-	.name		= "WVGA Panel",
-	.xres		= 800,
-	.yres		= 480,
-	.left_margin	= 88,
-	.right_margin	= 40,
-	.hsync_len	= 128,
-	.upper_margin	= 20,
-	.lower_margin	= 5,
-	.vsync_len	= 5,
-	.sync		= 0,
-};
-
-static struct sh_mobile_lcdc_info lcdc0_info = {
-	.clock_source	= LCDC_CLK_BUS,
-	.ch[0] = {
-		.chan			= LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.interface_type		= RGB24,
-		.clock_divider		= 5,
-		.flags			= 0,
-		.lcd_modes		= &lcdc0_mode,
-		.num_modes		= 1,
-		.panel_cfg = {
-			.width	= 152,
-			.height = 91,
-		},
-	},
-};
-
-static struct resource lcdc0_resources[] = {
-	[0] = {
-		.name	= "LCDC0",
-		.start	= 0xfe940000,
-		.end	= 0xfe943fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= intcs_evt2irq(0x0580),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device lcdc0_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.id		= 0,
-	.resource	= lcdc0_resources,
-	.num_resources	= ARRAY_SIZE(lcdc0_resources),
-	.dev	= {
-		.platform_data	= &lcdc0_info,
-		.coherent_dma_mask = ~0,
-	},
-};
-
-/*
- * SMSC 9221
- */
-static struct resource smsc_resources[] = {
-	[0] = {
-		.start		= 0x18010000,
-		.end		= 0x18011000 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= FPGA_ETH_IRQ,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc_platdata = {
-	.flags		= SMSC911X_USE_16BIT,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-};
-
-static struct platform_device smsc_device = {
-	.name		= "smsc911x",
-	.dev  = {
-		.platform_data = &smsc_platdata,
-	},
-	.resource	= smsc_resources,
-	.num_resources	= ARRAY_SIZE(smsc_resources),
-};
-
-/*
- * core board devices
- */
-static struct platform_device *bonito_core_devices[] __initdata = {
-};
-
-/*
- * base board devices
- */
-static struct platform_device *bonito_base_devices[] __initdata = {
-	&lcdc0_device,
-	&smsc_device,
-};
-
-/*
- * map I/O
- */
-static struct map_desc bonito_io_desc[] __initdata = {
-	/*
-	 * for FPGA (0x1800000-0x19ffffff)
-	 * 0x18000000-0x18002000 -> 0xf0003000-0xf0005000
-	 */
-	{
-		.virtual	= 0xf0003000,
-		.pfn		= __phys_to_pfn(0x18000000),
-		.length		= PAGE_SIZE * 2,
-		.type		= MT_DEVICE_NONSHARED
-	}
-};
-
-static void __init bonito_map_io(void)
-{
-	r8a7740_map_io();
-	iotable_init(bonito_io_desc, ARRAY_SIZE(bonito_io_desc));
-}
-
-/*
- * board init
- */
-#define BIT_ON(sw, bit)		(sw & (1 << bit))
-#define BIT_OFF(sw, bit)	(!(sw & (1 << bit)))
-
-#define VCCQ1CR		0xE6058140
-#define VCCQ1LCDCR	0xE6058186
-
-static void __init bonito_init(void)
-{
-	u16 val;
-
-	r8a7740_pinmux_init();
-	bonito_fpga_init();
-
-	pmic_settings = pmic_do_2A;
-
-	/*
-	 * core board settings
-	 */
-
-#ifdef CONFIG_CACHE_L2X0
-	/* Early BRESP enable, Shared attribute override enable, 32K*8way */
-	l2x0_init(IOMEM(0xf0002000), 0x40440000, 0x82000fff);
-#endif
-
-	r8a7740_add_standard_devices();
-
-	platform_add_devices(bonito_core_devices,
-			     ARRAY_SIZE(bonito_core_devices));
-
-	/*
-	 * base board settings
-	 */
-	gpio_request(GPIO_PORT176, NULL);
-	gpio_direction_input(GPIO_PORT176);
-	if (!gpio_get_value(GPIO_PORT176)) {
-		u16 bsw2;
-		u16 bsw3;
-		u16 bsw4;
-
-		/*
-		 * FPGA
-		 */
-		gpio_request(GPIO_FN_CS5B,		NULL);
-		gpio_request(GPIO_FN_CS6A,		NULL);
-		gpio_request(GPIO_FN_CS5A_PORT105,	NULL);
-		gpio_request(GPIO_FN_IRQ10,		NULL);
-
-		val = bonito_fpga_read(BVERR);
-		pr_info("bonito version: cpu %02x, base %02x\n",
-			((val >> 8) & 0xFF),
-			((val >> 0) & 0xFF));
-
-		bsw2 = bonito_fpga_read(BUSSWMR2);
-		bsw3 = bonito_fpga_read(BUSSWMR3);
-		bsw4 = bonito_fpga_read(BUSSWMR4);
-
-		/*
-		 * SCIFA5 (CN42)
-		 */
-		if (BIT_OFF(bsw2, 1) &&	/* S38.3 = ON */
-		    BIT_OFF(bsw3, 9) &&	/* S39.6 = ON */
-		    BIT_OFF(bsw4, 4)) {	/* S43.1 = ON */
-			gpio_request(GPIO_FN_SCIFA5_TXD_PORT91,	NULL);
-			gpio_request(GPIO_FN_SCIFA5_RXD_PORT92,	NULL);
-		}
-
-		/*
-		 * LCDC0 (CN3)
-		 */
-		if (BIT_ON(bsw2, 3) &&	/* S38.1 = OFF */
-		    BIT_ON(bsw2, 2)) {	/* S38.2 = OFF */
-			gpio_request(GPIO_FN_LCDC0_SELECT,	NULL);
-			gpio_request(GPIO_FN_LCD0_D0,		NULL);
-			gpio_request(GPIO_FN_LCD0_D1,		NULL);
-			gpio_request(GPIO_FN_LCD0_D2,		NULL);
-			gpio_request(GPIO_FN_LCD0_D3,		NULL);
-			gpio_request(GPIO_FN_LCD0_D4,		NULL);
-			gpio_request(GPIO_FN_LCD0_D5,		NULL);
-			gpio_request(GPIO_FN_LCD0_D6,		NULL);
-			gpio_request(GPIO_FN_LCD0_D7,		NULL);
-			gpio_request(GPIO_FN_LCD0_D8,		NULL);
-			gpio_request(GPIO_FN_LCD0_D9,		NULL);
-			gpio_request(GPIO_FN_LCD0_D10,		NULL);
-			gpio_request(GPIO_FN_LCD0_D11,		NULL);
-			gpio_request(GPIO_FN_LCD0_D12,		NULL);
-			gpio_request(GPIO_FN_LCD0_D13,		NULL);
-			gpio_request(GPIO_FN_LCD0_D14,		NULL);
-			gpio_request(GPIO_FN_LCD0_D15,		NULL);
-			gpio_request(GPIO_FN_LCD0_D16,		NULL);
-			gpio_request(GPIO_FN_LCD0_D17,		NULL);
-			gpio_request(GPIO_FN_LCD0_D18_PORT163,	NULL);
-			gpio_request(GPIO_FN_LCD0_D19_PORT162,	NULL);
-			gpio_request(GPIO_FN_LCD0_D20_PORT161,	NULL);
-			gpio_request(GPIO_FN_LCD0_D21_PORT158,	NULL);
-			gpio_request(GPIO_FN_LCD0_D22_PORT160,	NULL);
-			gpio_request(GPIO_FN_LCD0_D23_PORT159,	NULL);
-			gpio_request(GPIO_FN_LCD0_DCK,		NULL);
-			gpio_request(GPIO_FN_LCD0_VSYN,		NULL);
-			gpio_request(GPIO_FN_LCD0_HSYN,		NULL);
-			gpio_request(GPIO_FN_LCD0_DISP,		NULL);
-			gpio_request(GPIO_FN_LCD0_LCLK_PORT165,	NULL);
-
-			gpio_request(GPIO_PORT61, NULL); /* LCDDON */
-			gpio_direction_output(GPIO_PORT61, 1);
-
-			/* backlight on */
-			bonito_fpga_write(LCDCR, 1);
-
-			/*  drivability Max */
-			__raw_writew(0x00FF , VCCQ1LCDCR);
-			__raw_writew(0xFFFF , VCCQ1CR);
-		}
-
-		platform_add_devices(bonito_base_devices,
-				     ARRAY_SIZE(bonito_base_devices));
-	}
-}
-
-static void __init bonito_earlytimer_init(void)
-{
-	u16 val;
-	u8 md_ck = 0;
-
-	/* read MD_CK value */
-	val = bonito_fpga_read(A1MDSR);
-	if (val & (1 << 10))
-		md_ck |= MD_CK2;
-	if (val & (1 << 9))
-		md_ck |= MD_CK1;
-	if (val & (1 << 8))
-		md_ck |= MD_CK0;
-
-	r8a7740_clock_init(md_ck);
-	shmobile_earlytimer_init();
-}
-
-void __init bonito_add_early_devices(void)
-{
-	r8a7740_add_early_devices();
-
-	/* override timer setup with board-specific code */
-	shmobile_timer.init = bonito_earlytimer_init;
-}
-
-MACHINE_START(BONITO, "bonito")
-	.map_io		= bonito_map_io,
-	.init_early	= bonito_add_early_devices,
-	.init_irq	= r8a7740_init_irq,
-	.handle_irq	= shmobile_handle_irq_intc,
-	.init_machine	= bonito_init,
-	.timer		= &shmobile_timer,
-MACHINE_END
diff -urN flo-ElementalX-5.00/arch/arm/plat-mxc/include/mach/iomux-mx35.h flo-ElementalX-5.00-patched/arch/arm/plat-mxc/include/mach/iomux-mx35.h
--- flo-ElementalX-5.00/arch/arm/plat-mxc/include/mach/iomux-mx35.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/plat-mxc/include/mach/iomux-mx35.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,1267 +0,0 @@
-/*
- * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH <armlinux@phytec.de>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option, NO_PAD_CTRL) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- */
-
-#ifndef __MACH_IOMUX_MX35_H__
-#define __MACH_IOMUX_MX35_H__
-
-#include <mach/iomux-v3.h>
-
-/*
- * The naming convention for the pad modes is MX35_PAD_<padname>__<padmode>
- * If <padname> or <padmode> refers to a GPIO, it is named
- * GPIO_<unit>_<num> see also iomux-v3.h
- */
-
-/*									  PAD    MUX   ALT INPSE PATH */
-#define MX35_PAD_CAPTURE__GPT_CAPIN1				IOMUX_PAD(0x328, 0x004, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CAPTURE__GPT_CMPOUT2				IOMUX_PAD(0x328, 0x004, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CAPTURE__CSPI2_SS1				IOMUX_PAD(0x328, 0x004, 2, 0x7f4, 0, NO_PAD_CTRL)
-#define MX35_PAD_CAPTURE__EPIT1_EPITO				IOMUX_PAD(0x328, 0x004, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CAPTURE__CCM_CLK32K				IOMUX_PAD(0x328, 0x004, 4, 0x7d0, 0, NO_PAD_CTRL)
-#define MX35_PAD_CAPTURE__GPIO1_4				IOMUX_PAD(0x328, 0x004, 5, 0x850, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_COMPARE__GPT_CMPOUT1				IOMUX_PAD(0x32c, 0x008, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_COMPARE__GPT_CAPIN2				IOMUX_PAD(0x32c, 0x008, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_COMPARE__GPT_CMPOUT3				IOMUX_PAD(0x32c, 0x008, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_COMPARE__EPIT2_EPITO				IOMUX_PAD(0x32c, 0x008, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_COMPARE__GPIO1_5				IOMUX_PAD(0x32c, 0x008, 5, 0x854, 0, NO_PAD_CTRL)
-#define MX35_PAD_COMPARE__SDMA_EXTDMA_2				IOMUX_PAD(0x32c, 0x008, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_WDOG_RST__WDOG_WDOG_B				IOMUX_PAD(0x330, 0x00c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_WDOG_RST__IPU_FLASH_STROBE			IOMUX_PAD(0x330, 0x00c, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_WDOG_RST__GPIO1_6				IOMUX_PAD(0x330, 0x00c, 5, 0x858, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_GPIO1_0__GPIO1_0				IOMUX_PAD(0x334, 0x010, 0, 0x82c, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_0__CCM_PMIC_RDY				IOMUX_PAD(0x334, 0x010, 1, 0x7d4, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_0__OWIRE_LINE				IOMUX_PAD(0x334, 0x010, 2, 0x990, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_0__SDMA_EXTDMA_0				IOMUX_PAD(0x334, 0x010, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_GPIO1_1__GPIO1_1				IOMUX_PAD(0x338, 0x014, 0, 0x838, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_1__PWM_PWMO				IOMUX_PAD(0x338, 0x014, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_1__CSPI1_SS2				IOMUX_PAD(0x338, 0x014, 3, 0x7d8, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_1__SCC_TAMPER_DETECT			IOMUX_PAD(0x338, 0x014, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO1_1__SDMA_EXTDMA_1				IOMUX_PAD(0x338, 0x014, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_GPIO2_0__GPIO2_0				IOMUX_PAD(0x33c, 0x018, 0, 0x868, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO2_0__USB_TOP_USBOTG_CLK			IOMUX_PAD(0x33c, 0x018, 1, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_GPIO3_0__GPIO3_0				IOMUX_PAD(0x340, 0x01c, 0, 0x8e8, 0, NO_PAD_CTRL)
-#define MX35_PAD_GPIO3_0__USB_TOP_USBH2_CLK			IOMUX_PAD(0x340, 0x01c, 1, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RESET_IN_B__CCM_RESET_IN_B			IOMUX_PAD(0x344, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_POR_B__CCM_POR_B				IOMUX_PAD(0x348, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CLKO__CCM_CLKO					IOMUX_PAD(0x34c, 0x020, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CLKO__GPIO1_8					IOMUX_PAD(0x34c, 0x020, 5, 0x860, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_BOOT_MODE0__CCM_BOOT_MODE_0			IOMUX_PAD(0x350, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_BOOT_MODE1__CCM_BOOT_MODE_1			IOMUX_PAD(0x354, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CLK_MODE0__CCM_CLK_MODE_0			IOMUX_PAD(0x358, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CLK_MODE1__CCM_CLK_MODE_1			IOMUX_PAD(0x35c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_POWER_FAIL__CCM_DSM_WAKEUP_INT_26		IOMUX_PAD(0x360, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_VSTBY__CCM_VSTBY				IOMUX_PAD(0x364, 0x024, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_VSTBY__GPIO1_7					IOMUX_PAD(0x364, 0x024, 5, 0x85c, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_A0__EMI_EIM_DA_L_0				IOMUX_PAD(0x368, 0x028, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A1__EMI_EIM_DA_L_1				IOMUX_PAD(0x36c, 0x02c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A2__EMI_EIM_DA_L_2				IOMUX_PAD(0x370, 0x030, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A3__EMI_EIM_DA_L_3				IOMUX_PAD(0x374, 0x034, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A4__EMI_EIM_DA_L_4				IOMUX_PAD(0x378, 0x038, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A5__EMI_EIM_DA_L_5				IOMUX_PAD(0x37c, 0x03c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A6__EMI_EIM_DA_L_6				IOMUX_PAD(0x380, 0x040, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A7__EMI_EIM_DA_L_7				IOMUX_PAD(0x384, 0x044, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A8__EMI_EIM_DA_H_8				IOMUX_PAD(0x388, 0x048, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A9__EMI_EIM_DA_H_9				IOMUX_PAD(0x38c, 0x04c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A10__EMI_EIM_DA_H_10				IOMUX_PAD(0x390, 0x050, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_MA10__EMI_MA10					IOMUX_PAD(0x394, 0x054, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A11__EMI_EIM_DA_H_11				IOMUX_PAD(0x398, 0x058, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A12__EMI_EIM_DA_H_12				IOMUX_PAD(0x39c, 0x05c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A13__EMI_EIM_DA_H_13				IOMUX_PAD(0x3a0, 0x060, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A14__EMI_EIM_DA_H2_14				IOMUX_PAD(0x3a4, 0x064, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A15__EMI_EIM_DA_H2_15				IOMUX_PAD(0x3a8, 0x068, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A16__EMI_EIM_A_16				IOMUX_PAD(0x3ac, 0x06c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A17__EMI_EIM_A_17				IOMUX_PAD(0x3b0, 0x070, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A18__EMI_EIM_A_18				IOMUX_PAD(0x3b4, 0x074, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A19__EMI_EIM_A_19				IOMUX_PAD(0x3b8, 0x078, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A20__EMI_EIM_A_20				IOMUX_PAD(0x3bc, 0x07c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A21__EMI_EIM_A_21				IOMUX_PAD(0x3c0, 0x080, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A22__EMI_EIM_A_22				IOMUX_PAD(0x3c4, 0x084, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A23__EMI_EIM_A_23				IOMUX_PAD(0x3c8, 0x088, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A24__EMI_EIM_A_24				IOMUX_PAD(0x3cc, 0x08c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_A25__EMI_EIM_A_25				IOMUX_PAD(0x3d0, 0x090, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDBA1__EMI_EIM_SDBA1				IOMUX_PAD(0x3d4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDBA0__EMI_EIM_SDBA0				IOMUX_PAD(0x3d8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD0__EMI_DRAM_D_0				IOMUX_PAD(0x3dc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1__EMI_DRAM_D_1				IOMUX_PAD(0x3e0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2__EMI_DRAM_D_2				IOMUX_PAD(0x3e4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD3__EMI_DRAM_D_3				IOMUX_PAD(0x3e8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD4__EMI_DRAM_D_4				IOMUX_PAD(0x3ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD5__EMI_DRAM_D_5				IOMUX_PAD(0x3f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD6__EMI_DRAM_D_6				IOMUX_PAD(0x3f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD7__EMI_DRAM_D_7				IOMUX_PAD(0x3f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD8__EMI_DRAM_D_8				IOMUX_PAD(0x3fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD9__EMI_DRAM_D_9				IOMUX_PAD(0x400, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD10__EMI_DRAM_D_10				IOMUX_PAD(0x404, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD11__EMI_DRAM_D_11				IOMUX_PAD(0x408, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD12__EMI_DRAM_D_12				IOMUX_PAD(0x40c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD13__EMI_DRAM_D_13				IOMUX_PAD(0x410, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD14__EMI_DRAM_D_14				IOMUX_PAD(0x414, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD15__EMI_DRAM_D_15				IOMUX_PAD(0x418, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD16__EMI_DRAM_D_16				IOMUX_PAD(0x41c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD17__EMI_DRAM_D_17				IOMUX_PAD(0x420, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD18__EMI_DRAM_D_18				IOMUX_PAD(0x424, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD19__EMI_DRAM_D_19				IOMUX_PAD(0x428, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD20__EMI_DRAM_D_20				IOMUX_PAD(0x42c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD21__EMI_DRAM_D_21				IOMUX_PAD(0x430, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD22__EMI_DRAM_D_22				IOMUX_PAD(0x434, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD23__EMI_DRAM_D_23				IOMUX_PAD(0x438, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD24__EMI_DRAM_D_24				IOMUX_PAD(0x43c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD25__EMI_DRAM_D_25				IOMUX_PAD(0x440, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD26__EMI_DRAM_D_26				IOMUX_PAD(0x444, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD27__EMI_DRAM_D_27				IOMUX_PAD(0x448, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD28__EMI_DRAM_D_28				IOMUX_PAD(0x44c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD29__EMI_DRAM_D_29				IOMUX_PAD(0x450, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD30__EMI_DRAM_D_30				IOMUX_PAD(0x454, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD31__EMI_DRAM_D_31				IOMUX_PAD(0x458, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_DQM0__EMI_DRAM_DQM_0				IOMUX_PAD(0x45c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_DQM1__EMI_DRAM_DQM_1				IOMUX_PAD(0x460, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_DQM2__EMI_DRAM_DQM_2				IOMUX_PAD(0x464, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_DQM3__EMI_DRAM_DQM_3				IOMUX_PAD(0x468, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_EB0__EMI_EIM_EB0_B				IOMUX_PAD(0x46c, 0x094, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_EB1__EMI_EIM_EB1_B				IOMUX_PAD(0x470, 0x098, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_OE__EMI_EIM_OE					IOMUX_PAD(0x474, 0x09c, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS0__EMI_EIM_CS0				IOMUX_PAD(0x478, 0x0a0, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS1__EMI_EIM_CS1				IOMUX_PAD(0x47c, 0x0a4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CS1__EMI_NANDF_CE3				IOMUX_PAD(0x47c, 0x0a4, 3, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS2__EMI_EIM_CS2				IOMUX_PAD(0x480, 0x0a8, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS3__EMI_EIM_CS3				IOMUX_PAD(0x484, 0x0ac, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS4__EMI_EIM_CS4				IOMUX_PAD(0x488, 0x0b0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CS4__EMI_DTACK_B				IOMUX_PAD(0x488, 0x0b0, 1, 0x800, 0, NO_PAD_CTRL)
-#define MX35_PAD_CS4__EMI_NANDF_CE1				IOMUX_PAD(0x488, 0x0b0, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CS4__GPIO1_20					IOMUX_PAD(0x488, 0x0b0, 5, 0x83c, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_CS5__EMI_EIM_CS5				IOMUX_PAD(0x48c, 0x0b4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CS5__CSPI2_SS2					IOMUX_PAD(0x48c, 0x0b4, 1, 0x7f8, 0, NO_PAD_CTRL)
-#define MX35_PAD_CS5__CSPI1_SS2					IOMUX_PAD(0x48c, 0x0b4, 2, 0x7d8, 1, NO_PAD_CTRL)
-#define MX35_PAD_CS5__EMI_NANDF_CE2				IOMUX_PAD(0x48c, 0x0b4, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CS5__GPIO1_21					IOMUX_PAD(0x48c, 0x0b4, 5, 0x840, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_NF_CE0__EMI_NANDF_CE0				IOMUX_PAD(0x490, 0x0b8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NF_CE0__GPIO1_22				IOMUX_PAD(0x490, 0x0b8, 5, 0x844, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_ECB__EMI_EIM_ECB				IOMUX_PAD(0x494, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LBA__EMI_EIM_LBA				IOMUX_PAD(0x498, 0x0bc, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_BCLK__EMI_EIM_BCLK				IOMUX_PAD(0x49c, 0x0c0, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RW__EMI_EIM_RW					IOMUX_PAD(0x4a0, 0x0c4, 0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RAS__EMI_DRAM_RAS				IOMUX_PAD(0x4a4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CAS__EMI_DRAM_CAS				IOMUX_PAD(0x4a8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDWE__EMI_DRAM_SDWE				IOMUX_PAD(0x4ac, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDCKE0__EMI_DRAM_SDCKE_0			IOMUX_PAD(0x4b0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDCKE1__EMI_DRAM_SDCKE_1			IOMUX_PAD(0x4b4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDCLK__EMI_DRAM_SDCLK				IOMUX_PAD(0x4b8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDQS0__EMI_DRAM_SDQS_0				IOMUX_PAD(0x4bc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDQS1__EMI_DRAM_SDQS_1				IOMUX_PAD(0x4c0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDQS2__EMI_DRAM_SDQS_2				IOMUX_PAD(0x4c4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SDQS3__EMI_DRAM_SDQS_3				IOMUX_PAD(0x4c8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFWE_B__EMI_NANDF_WE_B				IOMUX_PAD(0x4cc, 0x0c8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFWE_B__USB_TOP_USBH2_DATA_3			IOMUX_PAD(0x4cc, 0x0c8, 1, 0x9d8, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFWE_B__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x4cc, 0x0c8, 2, 0x924, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFWE_B__GPIO2_18				IOMUX_PAD(0x4cc, 0x0c8, 5, 0x88c, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFWE_B__ARM11P_TOP_TRACE_0			IOMUX_PAD(0x4cc, 0x0c8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFRE_B__EMI_NANDF_RE_B				IOMUX_PAD(0x4d0, 0x0cc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFRE_B__USB_TOP_USBH2_DIR			IOMUX_PAD(0x4d0, 0x0cc, 1, 0x9ec, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFRE_B__IPU_DISPB_BCLK				IOMUX_PAD(0x4d0, 0x0cc, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFRE_B__GPIO2_19				IOMUX_PAD(0x4d0, 0x0cc, 5, 0x890, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFRE_B__ARM11P_TOP_TRACE_1			IOMUX_PAD(0x4d0, 0x0cc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFALE__EMI_NANDF_ALE				IOMUX_PAD(0x4d4, 0x0d0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFALE__USB_TOP_USBH2_STP			IOMUX_PAD(0x4d4, 0x0d0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFALE__IPU_DISPB_CS0				IOMUX_PAD(0x4d4, 0x0d0, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFALE__GPIO2_20				IOMUX_PAD(0x4d4, 0x0d0, 5, 0x898, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFALE__ARM11P_TOP_TRACE_2			IOMUX_PAD(0x4d4, 0x0d0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFCLE__EMI_NANDF_CLE				IOMUX_PAD(0x4d8, 0x0d4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFCLE__USB_TOP_USBH2_NXT			IOMUX_PAD(0x4d8, 0x0d4, 1, 0x9f0, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFCLE__IPU_DISPB_PAR_RS			IOMUX_PAD(0x4d8, 0x0d4, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFCLE__GPIO2_21				IOMUX_PAD(0x4d8, 0x0d4, 5, 0x89c, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFCLE__ARM11P_TOP_TRACE_3			IOMUX_PAD(0x4d8, 0x0d4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFWP_B__EMI_NANDF_WP_B				IOMUX_PAD(0x4dc, 0x0d8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFWP_B__USB_TOP_USBH2_DATA_7			IOMUX_PAD(0x4dc, 0x0d8, 1, 0x9e8, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFWP_B__IPU_DISPB_WR				IOMUX_PAD(0x4dc, 0x0d8, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFWP_B__GPIO2_22				IOMUX_PAD(0x4dc, 0x0d8, 5, 0x8a0, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFWP_B__ARM11P_TOP_TRCTL			IOMUX_PAD(0x4dc, 0x0d8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_NFRB__EMI_NANDF_RB				IOMUX_PAD(0x4e0, 0x0dc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFRB__IPU_DISPB_RD				IOMUX_PAD(0x4e0, 0x0dc, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_NFRB__GPIO2_23					IOMUX_PAD(0x4e0, 0x0dc, 5, 0x8a4, 0, NO_PAD_CTRL)
-#define MX35_PAD_NFRB__ARM11P_TOP_TRCLK				IOMUX_PAD(0x4e0, 0x0dc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D15__EMI_EIM_D_15				IOMUX_PAD(0x4e4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D14__EMI_EIM_D_14				IOMUX_PAD(0x4e8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D13__EMI_EIM_D_13				IOMUX_PAD(0x4ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D12__EMI_EIM_D_12				IOMUX_PAD(0x4f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D11__EMI_EIM_D_11				IOMUX_PAD(0x4f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D10__EMI_EIM_D_10				IOMUX_PAD(0x4f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D9__EMI_EIM_D_9				IOMUX_PAD(0x4fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D8__EMI_EIM_D_8				IOMUX_PAD(0x500, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D7__EMI_EIM_D_7				IOMUX_PAD(0x504, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D6__EMI_EIM_D_6				IOMUX_PAD(0x508, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D5__EMI_EIM_D_5				IOMUX_PAD(0x50c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D4__EMI_EIM_D_4				IOMUX_PAD(0x510, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3__EMI_EIM_D_3				IOMUX_PAD(0x514, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D2__EMI_EIM_D_2				IOMUX_PAD(0x518, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D1__EMI_EIM_D_1				IOMUX_PAD(0x51c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D0__EMI_EIM_D_0				IOMUX_PAD(0x520, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D8__IPU_CSI_D_8				IOMUX_PAD(0x524, 0x0e0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D8__KPP_COL_0				IOMUX_PAD(0x524, 0x0e0, 1, 0x950, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D8__GPIO1_20				IOMUX_PAD(0x524, 0x0e0, 5, 0x83c, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D8__ARM11P_TOP_EVNTBUS_13			IOMUX_PAD(0x524, 0x0e0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D9__IPU_CSI_D_9				IOMUX_PAD(0x528, 0x0e4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D9__KPP_COL_1				IOMUX_PAD(0x528, 0x0e4, 1, 0x954, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D9__GPIO1_21				IOMUX_PAD(0x528, 0x0e4, 5, 0x840, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D9__ARM11P_TOP_EVNTBUS_14			IOMUX_PAD(0x528, 0x0e4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D10__IPU_CSI_D_10				IOMUX_PAD(0x52c, 0x0e8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D10__KPP_COL_2				IOMUX_PAD(0x52c, 0x0e8, 1, 0x958, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D10__GPIO1_22				IOMUX_PAD(0x52c, 0x0e8, 5, 0x844, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D10__ARM11P_TOP_EVNTBUS_15			IOMUX_PAD(0x52c, 0x0e8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D11__IPU_CSI_D_11				IOMUX_PAD(0x530, 0x0ec, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D11__KPP_COL_3				IOMUX_PAD(0x530, 0x0ec, 1, 0x95c, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D11__GPIO1_23				IOMUX_PAD(0x530, 0x0ec, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D12__IPU_CSI_D_12				IOMUX_PAD(0x534, 0x0f0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D12__KPP_ROW_0				IOMUX_PAD(0x534, 0x0f0, 1, 0x970, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D12__GPIO1_24				IOMUX_PAD(0x534, 0x0f0, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D13__IPU_CSI_D_13				IOMUX_PAD(0x538, 0x0f4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D13__KPP_ROW_1				IOMUX_PAD(0x538, 0x0f4, 1, 0x974, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D13__GPIO1_25				IOMUX_PAD(0x538, 0x0f4, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D14__IPU_CSI_D_14				IOMUX_PAD(0x53c, 0x0f8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D14__KPP_ROW_2				IOMUX_PAD(0x53c, 0x0f8, 1, 0x978, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D14__GPIO1_26				IOMUX_PAD(0x53c, 0x0f8, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_D15__IPU_CSI_D_15				IOMUX_PAD(0x540, 0x0fc, 0, 0x97c, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D15__KPP_ROW_3				IOMUX_PAD(0x540, 0x0fc, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_D15__GPIO1_27				IOMUX_PAD(0x540, 0x0fc, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_MCLK__IPU_CSI_MCLK				IOMUX_PAD(0x544, 0x100, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_MCLK__GPIO1_28				IOMUX_PAD(0x544, 0x100, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_VSYNC__IPU_CSI_VSYNC			IOMUX_PAD(0x548, 0x104, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_VSYNC__GPIO1_29				IOMUX_PAD(0x548, 0x104, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_HSYNC__IPU_CSI_HSYNC			IOMUX_PAD(0x54c, 0x108, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_HSYNC__GPIO1_30				IOMUX_PAD(0x54c, 0x108, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSI_PIXCLK__IPU_CSI_PIXCLK			IOMUX_PAD(0x550, 0x10c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSI_PIXCLK__GPIO1_31				IOMUX_PAD(0x550, 0x10c, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_I2C1_CLK__I2C1_SCL				IOMUX_PAD(0x554, 0x110, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C1_CLK__GPIO2_24				IOMUX_PAD(0x554, 0x110, 5, 0x8a8, 0, NO_PAD_CTRL)
-#define MX35_PAD_I2C1_CLK__CCM_USB_BYP_CLK			IOMUX_PAD(0x554, 0x110, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_I2C1_DAT__I2C1_SDA				IOMUX_PAD(0x558, 0x114, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C1_DAT__GPIO2_25				IOMUX_PAD(0x558, 0x114, 5, 0x8ac, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_I2C2_CLK__I2C2_SCL				IOMUX_PAD(0x55c, 0x118, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_CLK__CAN1_TXCAN				IOMUX_PAD(0x55c, 0x118, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_CLK__USB_TOP_USBH2_PWR			IOMUX_PAD(0x55c, 0x118, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_CLK__GPIO2_26				IOMUX_PAD(0x55c, 0x118, 5, 0x8b0, 0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_CLK__SDMA_DEBUG_BUS_DEVICE_2		IOMUX_PAD(0x55c, 0x118, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_I2C2_DAT__I2C2_SDA				IOMUX_PAD(0x560, 0x11c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_DAT__CAN1_RXCAN				IOMUX_PAD(0x560, 0x11c, 1, 0x7c8, 0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_DAT__USB_TOP_USBH2_OC			IOMUX_PAD(0x560, 0x11c, 2, 0x9f4, 0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_DAT__GPIO2_27				IOMUX_PAD(0x560, 0x11c, 5, 0x8b4, 0, NO_PAD_CTRL)
-#define MX35_PAD_I2C2_DAT__SDMA_DEBUG_BUS_DEVICE_3		IOMUX_PAD(0x560, 0x11c, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_STXD4__AUDMUX_AUD4_TXD				IOMUX_PAD(0x564, 0x120, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_STXD4__GPIO2_28				IOMUX_PAD(0x564, 0x120, 5, 0x8b8, 0, NO_PAD_CTRL)
-#define MX35_PAD_STXD4__ARM11P_TOP_ARM_COREASID0		IOMUX_PAD(0x564, 0x120, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SRXD4__AUDMUX_AUD4_RXD				IOMUX_PAD(0x568, 0x124, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SRXD4__GPIO2_29				IOMUX_PAD(0x568, 0x124, 5, 0x8bc, 0, NO_PAD_CTRL)
-#define MX35_PAD_SRXD4__ARM11P_TOP_ARM_COREASID1		IOMUX_PAD(0x568, 0x124, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SCK4__AUDMUX_AUD4_TXC				IOMUX_PAD(0x56c, 0x128, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SCK4__GPIO2_30					IOMUX_PAD(0x56c, 0x128, 5, 0x8c4, 0, NO_PAD_CTRL)
-#define MX35_PAD_SCK4__ARM11P_TOP_ARM_COREASID2			IOMUX_PAD(0x56c, 0x128, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS			IOMUX_PAD(0x570, 0x12c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_STXFS4__GPIO2_31				IOMUX_PAD(0x570, 0x12c, 5, 0x8c8, 0, NO_PAD_CTRL)
-#define MX35_PAD_STXFS4__ARM11P_TOP_ARM_COREASID3		IOMUX_PAD(0x570, 0x12c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_STXD5__AUDMUX_AUD5_TXD				IOMUX_PAD(0x574, 0x130, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_STXD5__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x574, 0x130, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_STXD5__CSPI2_MOSI				IOMUX_PAD(0x574, 0x130, 2, 0x7ec, 0, NO_PAD_CTRL)
-#define MX35_PAD_STXD5__GPIO1_0					IOMUX_PAD(0x574, 0x130, 5, 0x82c, 1, NO_PAD_CTRL)
-#define MX35_PAD_STXD5__ARM11P_TOP_ARM_COREASID4		IOMUX_PAD(0x574, 0x130, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SRXD5__AUDMUX_AUD5_RXD				IOMUX_PAD(0x578, 0x134, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SRXD5__SPDIF_SPDIF_IN1				IOMUX_PAD(0x578, 0x134, 1, 0x998, 0, NO_PAD_CTRL)
-#define MX35_PAD_SRXD5__CSPI2_MISO				IOMUX_PAD(0x578, 0x134, 2, 0x7e8, 0, NO_PAD_CTRL)
-#define MX35_PAD_SRXD5__GPIO1_1					IOMUX_PAD(0x578, 0x134, 5, 0x838, 1, NO_PAD_CTRL)
-#define MX35_PAD_SRXD5__ARM11P_TOP_ARM_COREASID5		IOMUX_PAD(0x578, 0x134, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SCK5__AUDMUX_AUD5_TXC				IOMUX_PAD(0x57c, 0x138, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SCK5__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x57c, 0x138, 1, 0x994, 0, NO_PAD_CTRL)
-#define MX35_PAD_SCK5__CSPI2_SCLK				IOMUX_PAD(0x57c, 0x138, 2, 0x7e0, 0, NO_PAD_CTRL)
-#define MX35_PAD_SCK5__GPIO1_2					IOMUX_PAD(0x57c, 0x138, 5, 0x848, 0, NO_PAD_CTRL)
-#define MX35_PAD_SCK5__ARM11P_TOP_ARM_COREASID6			IOMUX_PAD(0x57c, 0x138, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_STXFS5__AUDMUX_AUD5_TXFS			IOMUX_PAD(0x580, 0x13c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_STXFS5__CSPI2_RDY				IOMUX_PAD(0x580, 0x13c, 2, 0x7e4, 0, NO_PAD_CTRL)
-#define MX35_PAD_STXFS5__GPIO1_3				IOMUX_PAD(0x580, 0x13c, 5, 0x84c, 0, NO_PAD_CTRL)
-#define MX35_PAD_STXFS5__ARM11P_TOP_ARM_COREASID7		IOMUX_PAD(0x580, 0x13c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SCKR__ESAI_SCKR				IOMUX_PAD(0x584, 0x140, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SCKR__GPIO1_4					IOMUX_PAD(0x584, 0x140, 5, 0x850, 1, NO_PAD_CTRL)
-#define MX35_PAD_SCKR__ARM11P_TOP_EVNTBUS_10			IOMUX_PAD(0x584, 0x140, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FSR__ESAI_FSR					IOMUX_PAD(0x588, 0x144, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FSR__GPIO1_5					IOMUX_PAD(0x588, 0x144, 5, 0x854, 1, NO_PAD_CTRL)
-#define MX35_PAD_FSR__ARM11P_TOP_EVNTBUS_11			IOMUX_PAD(0x588, 0x144, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_HCKR__ESAI_HCKR				IOMUX_PAD(0x58c, 0x148, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_HCKR__AUDMUX_AUD5_RXFS				IOMUX_PAD(0x58c, 0x148, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_HCKR__CSPI2_SS0				IOMUX_PAD(0x58c, 0x148, 2, 0x7f0, 0, NO_PAD_CTRL)
-#define MX35_PAD_HCKR__IPU_FLASH_STROBE				IOMUX_PAD(0x58c, 0x148, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_HCKR__GPIO1_6					IOMUX_PAD(0x58c, 0x148, 5, 0x858, 1, NO_PAD_CTRL)
-#define MX35_PAD_HCKR__ARM11P_TOP_EVNTBUS_12			IOMUX_PAD(0x58c, 0x148, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SCKT__ESAI_SCKT				IOMUX_PAD(0x590, 0x14c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SCKT__GPIO1_7					IOMUX_PAD(0x590, 0x14c, 5, 0x85c, 1, NO_PAD_CTRL)
-#define MX35_PAD_SCKT__IPU_CSI_D_0				IOMUX_PAD(0x590, 0x14c, 6, 0x930, 0, NO_PAD_CTRL)
-#define MX35_PAD_SCKT__KPP_ROW_2				IOMUX_PAD(0x590, 0x14c, 7, 0x978, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_FST__ESAI_FST					IOMUX_PAD(0x594, 0x150, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FST__GPIO1_8					IOMUX_PAD(0x594, 0x150, 5, 0x860, 1, NO_PAD_CTRL)
-#define MX35_PAD_FST__IPU_CSI_D_1				IOMUX_PAD(0x594, 0x150, 6, 0x934, 0, NO_PAD_CTRL)
-#define MX35_PAD_FST__KPP_ROW_3					IOMUX_PAD(0x594, 0x150, 7, 0x97c, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_HCKT__ESAI_HCKT				IOMUX_PAD(0x598, 0x154, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_HCKT__AUDMUX_AUD5_RXC				IOMUX_PAD(0x598, 0x154, 1, 0x7a8, 0, NO_PAD_CTRL)
-#define MX35_PAD_HCKT__GPIO1_9					IOMUX_PAD(0x598, 0x154, 5, 0x864, 0, NO_PAD_CTRL)
-#define MX35_PAD_HCKT__IPU_CSI_D_2				IOMUX_PAD(0x598, 0x154, 6, 0x938, 0, NO_PAD_CTRL)
-#define MX35_PAD_HCKT__KPP_COL_3				IOMUX_PAD(0x598, 0x154, 7, 0x95c, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_TX5_RX0__ESAI_TX5_RX0				IOMUX_PAD(0x59c, 0x158, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__AUDMUX_AUD4_RXC			IOMUX_PAD(0x59c, 0x158, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__CSPI2_SS2				IOMUX_PAD(0x59c, 0x158, 2, 0x7f8, 1, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__CAN2_TXCAN				IOMUX_PAD(0x59c, 0x158, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__UART2_DTR				IOMUX_PAD(0x59c, 0x158, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__GPIO1_10				IOMUX_PAD(0x59c, 0x158, 5, 0x830, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX5_RX0__EMI_M3IF_CHOSEN_MASTER_0		IOMUX_PAD(0x59c, 0x158, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TX4_RX1__ESAI_TX4_RX1				IOMUX_PAD(0x5a0, 0x15c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__AUDMUX_AUD4_RXFS			IOMUX_PAD(0x5a0, 0x15c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__CSPI2_SS3				IOMUX_PAD(0x5a0, 0x15c, 2, 0x7fc, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__CAN2_RXCAN				IOMUX_PAD(0x5a0, 0x15c, 3, 0x7cc, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__UART2_DSR				IOMUX_PAD(0x5a0, 0x15c, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__GPIO1_11				IOMUX_PAD(0x5a0, 0x15c, 5, 0x834, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__IPU_CSI_D_3				IOMUX_PAD(0x5a0, 0x15c, 6, 0x93c, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX4_RX1__KPP_ROW_0				IOMUX_PAD(0x5a0, 0x15c, 7, 0x970, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_TX3_RX2__ESAI_TX3_RX2				IOMUX_PAD(0x5a4, 0x160, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX3_RX2__I2C3_SCL				IOMUX_PAD(0x5a4, 0x160, 1, 0x91c, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX3_RX2__EMI_NANDF_CE1				IOMUX_PAD(0x5a4, 0x160, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX3_RX2__GPIO1_12				IOMUX_PAD(0x5a4, 0x160, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX3_RX2__IPU_CSI_D_4				IOMUX_PAD(0x5a4, 0x160, 6, 0x940, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX3_RX2__KPP_ROW_1				IOMUX_PAD(0x5a4, 0x160, 7, 0x974, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_TX2_RX3__ESAI_TX2_RX3				IOMUX_PAD(0x5a8, 0x164, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX2_RX3__I2C3_SDA				IOMUX_PAD(0x5a8, 0x164, 1, 0x920, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX2_RX3__EMI_NANDF_CE2				IOMUX_PAD(0x5a8, 0x164, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX2_RX3__GPIO1_13				IOMUX_PAD(0x5a8, 0x164, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX2_RX3__IPU_CSI_D_5				IOMUX_PAD(0x5a8, 0x164, 6, 0x944, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX2_RX3__KPP_COL_0				IOMUX_PAD(0x5a8, 0x164, 7, 0x950, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_TX1__ESAI_TX1					IOMUX_PAD(0x5ac, 0x168, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX1__CCM_PMIC_RDY				IOMUX_PAD(0x5ac, 0x168, 1, 0x7d4, 1, NO_PAD_CTRL)
-#define MX35_PAD_TX1__CSPI1_SS2					IOMUX_PAD(0x5ac, 0x168, 2, 0x7d8, 2, NO_PAD_CTRL)
-#define MX35_PAD_TX1__EMI_NANDF_CE3				IOMUX_PAD(0x5ac, 0x168, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX1__UART2_RI					IOMUX_PAD(0x5ac, 0x168, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX1__GPIO1_14					IOMUX_PAD(0x5ac, 0x168, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX1__IPU_CSI_D_6				IOMUX_PAD(0x5ac, 0x168, 6, 0x948, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX1__KPP_COL_1					IOMUX_PAD(0x5ac, 0x168, 7, 0x954, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_TX0__ESAI_TX0					IOMUX_PAD(0x5b0, 0x16c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX0__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x5b0, 0x16c, 1, 0x994, 1, NO_PAD_CTRL)
-#define MX35_PAD_TX0__CSPI1_SS3					IOMUX_PAD(0x5b0, 0x16c, 2, 0x7dc, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX0__EMI_DTACK_B				IOMUX_PAD(0x5b0, 0x16c, 3, 0x800, 1, NO_PAD_CTRL)
-#define MX35_PAD_TX0__UART2_DCD					IOMUX_PAD(0x5b0, 0x16c, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX0__GPIO1_15					IOMUX_PAD(0x5b0, 0x16c, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TX0__IPU_CSI_D_7				IOMUX_PAD(0x5b0, 0x16c, 6, 0x94c, 0, NO_PAD_CTRL)
-#define MX35_PAD_TX0__KPP_COL_2					IOMUX_PAD(0x5b0, 0x16c, 7, 0x958, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_MOSI__CSPI1_MOSI				IOMUX_PAD(0x5b4, 0x170, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_MOSI__GPIO1_16				IOMUX_PAD(0x5b4, 0x170, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_MOSI__ECT_CTI_TRIG_OUT1_2		IOMUX_PAD(0x5b4, 0x170, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_MISO__CSPI1_MISO				IOMUX_PAD(0x5b8, 0x174, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_MISO__GPIO1_17				IOMUX_PAD(0x5b8, 0x174, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_MISO__ECT_CTI_TRIG_OUT1_3		IOMUX_PAD(0x5b8, 0x174, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_SS0__CSPI1_SS0				IOMUX_PAD(0x5bc, 0x178, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS0__OWIRE_LINE				IOMUX_PAD(0x5bc, 0x178, 1, 0x990, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS0__CSPI2_SS3				IOMUX_PAD(0x5bc, 0x178, 2, 0x7fc, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS0__GPIO1_18				IOMUX_PAD(0x5bc, 0x178, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS0__ECT_CTI_TRIG_OUT1_4			IOMUX_PAD(0x5bc, 0x178, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_SS1__CSPI1_SS1				IOMUX_PAD(0x5c0, 0x17c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS1__PWM_PWMO				IOMUX_PAD(0x5c0, 0x17c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS1__CCM_CLK32K				IOMUX_PAD(0x5c0, 0x17c, 2, 0x7d0, 1, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS1__GPIO1_19				IOMUX_PAD(0x5c0, 0x17c, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS1__IPU_DIAGB_29			IOMUX_PAD(0x5c0, 0x17c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SS1__ECT_CTI_TRIG_OUT1_5			IOMUX_PAD(0x5c0, 0x17c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_SCLK__CSPI1_SCLK				IOMUX_PAD(0x5c4, 0x180, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SCLK__GPIO3_4				IOMUX_PAD(0x5c4, 0x180, 5, 0x904, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SCLK__IPU_DIAGB_30			IOMUX_PAD(0x5c4, 0x180, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SCLK__EMI_M3IF_CHOSEN_MASTER_1		IOMUX_PAD(0x5c4, 0x180, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CSPI1_SPI_RDY__CSPI1_RDY			IOMUX_PAD(0x5c8, 0x184, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SPI_RDY__GPIO3_5				IOMUX_PAD(0x5c8, 0x184, 5, 0x908, 0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SPI_RDY__IPU_DIAGB_31			IOMUX_PAD(0x5c8, 0x184, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CSPI1_SPI_RDY__EMI_M3IF_CHOSEN_MASTER_2	IOMUX_PAD(0x5c8, 0x184, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RXD1__UART1_RXD_MUX				IOMUX_PAD(0x5cc, 0x188, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RXD1__CSPI2_MOSI				IOMUX_PAD(0x5cc, 0x188, 1, 0x7ec, 1, NO_PAD_CTRL)
-#define MX35_PAD_RXD1__KPP_COL_4				IOMUX_PAD(0x5cc, 0x188, 4, 0x960, 0, NO_PAD_CTRL)
-#define MX35_PAD_RXD1__GPIO3_6					IOMUX_PAD(0x5cc, 0x188, 5, 0x90c, 0, NO_PAD_CTRL)
-#define MX35_PAD_RXD1__ARM11P_TOP_EVNTBUS_16			IOMUX_PAD(0x5cc, 0x188, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TXD1__UART1_TXD_MUX				IOMUX_PAD(0x5d0, 0x18c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TXD1__CSPI2_MISO				IOMUX_PAD(0x5d0, 0x18c, 1, 0x7e8, 1, NO_PAD_CTRL)
-#define MX35_PAD_TXD1__KPP_COL_5				IOMUX_PAD(0x5d0, 0x18c, 4, 0x964, 0, NO_PAD_CTRL)
-#define MX35_PAD_TXD1__GPIO3_7					IOMUX_PAD(0x5d0, 0x18c, 5, 0x910, 0, NO_PAD_CTRL)
-#define MX35_PAD_TXD1__ARM11P_TOP_EVNTBUS_17			IOMUX_PAD(0x5d0, 0x18c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RTS1__UART1_RTS				IOMUX_PAD(0x5d4, 0x190, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__CSPI2_SCLK				IOMUX_PAD(0x5d4, 0x190, 1, 0x7e0, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__I2C3_SCL					IOMUX_PAD(0x5d4, 0x190, 2, 0x91c, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__IPU_CSI_D_0				IOMUX_PAD(0x5d4, 0x190, 3, 0x930, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__KPP_COL_6				IOMUX_PAD(0x5d4, 0x190, 4, 0x968, 0, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__GPIO3_8					IOMUX_PAD(0x5d4, 0x190, 5, 0x914, 0, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__EMI_NANDF_CE1				IOMUX_PAD(0x5d4, 0x190, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RTS1__ARM11P_TOP_EVNTBUS_18			IOMUX_PAD(0x5d4, 0x190, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CTS1__UART1_CTS				IOMUX_PAD(0x5d8, 0x194, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__CSPI2_RDY				IOMUX_PAD(0x5d8, 0x194, 1, 0x7e4, 1, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__I2C3_SDA					IOMUX_PAD(0x5d8, 0x194, 2, 0x920, 1, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__IPU_CSI_D_1				IOMUX_PAD(0x5d8, 0x194, 3, 0x934, 1, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__KPP_COL_7				IOMUX_PAD(0x5d8, 0x194, 4, 0x96c, 0, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__GPIO3_9					IOMUX_PAD(0x5d8, 0x194, 5, 0x918, 0, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__EMI_NANDF_CE2				IOMUX_PAD(0x5d8, 0x194, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS1__ARM11P_TOP_EVNTBUS_19			IOMUX_PAD(0x5d8, 0x194, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RXD2__UART2_RXD_MUX				IOMUX_PAD(0x5dc, 0x198, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RXD2__KPP_ROW_4				IOMUX_PAD(0x5dc, 0x198, 4, 0x980, 0, NO_PAD_CTRL)
-#define MX35_PAD_RXD2__GPIO3_10					IOMUX_PAD(0x5dc, 0x198, 5, 0x8ec, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_TXD2__UART2_TXD_MUX				IOMUX_PAD(0x5e0, 0x19c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_TXD2__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x5e0, 0x19c, 1, 0x994, 2, NO_PAD_CTRL)
-#define MX35_PAD_TXD2__KPP_ROW_5				IOMUX_PAD(0x5e0, 0x19c, 4, 0x984, 0, NO_PAD_CTRL)
-#define MX35_PAD_TXD2__GPIO3_11					IOMUX_PAD(0x5e0, 0x19c, 5, 0x8f0, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_RTS2__UART2_RTS				IOMUX_PAD(0x5e4, 0x1a0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__SPDIF_SPDIF_IN1				IOMUX_PAD(0x5e4, 0x1a0, 1, 0x998, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__CAN2_RXCAN				IOMUX_PAD(0x5e4, 0x1a0, 2, 0x7cc, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__IPU_CSI_D_2				IOMUX_PAD(0x5e4, 0x1a0, 3, 0x938, 1, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__KPP_ROW_6				IOMUX_PAD(0x5e4, 0x1a0, 4, 0x988, 0, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__GPIO3_12					IOMUX_PAD(0x5e4, 0x1a0, 5, 0x8f4, 0, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__AUDMUX_AUD5_RXC				IOMUX_PAD(0x5e4, 0x1a0, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_RTS2__UART3_RXD_MUX				IOMUX_PAD(0x5e4, 0x1a0, 7, 0x9a0, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_CTS2__UART2_CTS				IOMUX_PAD(0x5e8, 0x1a4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__SPDIF_SPDIF_OUT1				IOMUX_PAD(0x5e8, 0x1a4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__CAN2_TXCAN				IOMUX_PAD(0x5e8, 0x1a4, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__IPU_CSI_D_3				IOMUX_PAD(0x5e8, 0x1a4, 3, 0x93c, 1, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__KPP_ROW_7				IOMUX_PAD(0x5e8, 0x1a4, 4, 0x98c, 0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__GPIO3_13					IOMUX_PAD(0x5e8, 0x1a4, 5, 0x8f8, 0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__AUDMUX_AUD5_RXFS				IOMUX_PAD(0x5e8, 0x1a4, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CTS2__UART3_TXD_MUX				IOMUX_PAD(0x5e8, 0x1a4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_RTCK__ARM11P_TOP_RTCK				IOMUX_PAD(0x5ec, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TCK__SJC_TCK					IOMUX_PAD(0x5f0, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TMS__SJC_TMS					IOMUX_PAD(0x5f4, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TDI__SJC_TDI					IOMUX_PAD(0x5f8, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TDO__SJC_TDO					IOMUX_PAD(0x5fc, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TRSTB__SJC_TRSTB				IOMUX_PAD(0x600, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_DE_B__SJC_DE_B					IOMUX_PAD(0x604, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SJC_MOD__SJC_MOD				IOMUX_PAD(0x608, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_USBOTG_PWR__USB_TOP_USBOTG_PWR			IOMUX_PAD(0x60c, 0x1a8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_USBOTG_PWR__USB_TOP_USBH2_PWR			IOMUX_PAD(0x60c, 0x1a8, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_USBOTG_PWR__GPIO3_14				IOMUX_PAD(0x60c, 0x1a8, 5, 0x8fc, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_USBOTG_OC__USB_TOP_USBOTG_OC			IOMUX_PAD(0x610, 0x1ac, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_USBOTG_OC__USB_TOP_USBH2_OC			IOMUX_PAD(0x610, 0x1ac, 1, 0x9f4, 1, NO_PAD_CTRL)
-#define MX35_PAD_USBOTG_OC__GPIO3_15				IOMUX_PAD(0x610, 0x1ac, 5, 0x900, 0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD0__IPU_DISPB_DAT_0				IOMUX_PAD(0x614, 0x1b0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD0__GPIO2_0					IOMUX_PAD(0x614, 0x1b0, 5, 0x868, 1, NO_PAD_CTRL)
-#define MX35_PAD_LD0__SDMA_SDMA_DEBUG_PC_0			IOMUX_PAD(0x614, 0x1b0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD1__IPU_DISPB_DAT_1				IOMUX_PAD(0x618, 0x1b4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD1__GPIO2_1					IOMUX_PAD(0x618, 0x1b4, 5, 0x894, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD1__SDMA_SDMA_DEBUG_PC_1			IOMUX_PAD(0x618, 0x1b4, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD2__IPU_DISPB_DAT_2				IOMUX_PAD(0x61c, 0x1b8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD2__GPIO2_2					IOMUX_PAD(0x61c, 0x1b8, 5, 0x8c0, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD2__SDMA_SDMA_DEBUG_PC_2			IOMUX_PAD(0x61c, 0x1b8, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD3__IPU_DISPB_DAT_3				IOMUX_PAD(0x620, 0x1bc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD3__GPIO2_3					IOMUX_PAD(0x620, 0x1bc, 5, 0x8cc, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD3__SDMA_SDMA_DEBUG_PC_3			IOMUX_PAD(0x620, 0x1bc, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD4__IPU_DISPB_DAT_4				IOMUX_PAD(0x624, 0x1c0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD4__GPIO2_4					IOMUX_PAD(0x624, 0x1c0, 5, 0x8d0, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD4__SDMA_SDMA_DEBUG_PC_4			IOMUX_PAD(0x624, 0x1c0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD5__IPU_DISPB_DAT_5				IOMUX_PAD(0x628, 0x1c4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD5__GPIO2_5					IOMUX_PAD(0x628, 0x1c4, 5, 0x8d4, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD5__SDMA_SDMA_DEBUG_PC_5			IOMUX_PAD(0x628, 0x1c4, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD6__IPU_DISPB_DAT_6				IOMUX_PAD(0x62c, 0x1c8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD6__GPIO2_6					IOMUX_PAD(0x62c, 0x1c8, 5, 0x8d8, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD6__SDMA_SDMA_DEBUG_PC_6			IOMUX_PAD(0x62c, 0x1c8, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD7__IPU_DISPB_DAT_7				IOMUX_PAD(0x630, 0x1cc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD7__GPIO2_7					IOMUX_PAD(0x630, 0x1cc, 5, 0x8dc, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD7__SDMA_SDMA_DEBUG_PC_7			IOMUX_PAD(0x630, 0x1cc, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD8__IPU_DISPB_DAT_8				IOMUX_PAD(0x634, 0x1d0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD8__GPIO2_8					IOMUX_PAD(0x634, 0x1d0, 5, 0x8e0, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD8__SDMA_SDMA_DEBUG_PC_8			IOMUX_PAD(0x634, 0x1d0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD9__IPU_DISPB_DAT_9				IOMUX_PAD(0x638, 0x1d4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD9__GPIO2_9					IOMUX_PAD(0x638, 0x1d4, 5, 0x8e4, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD9__SDMA_SDMA_DEBUG_PC_9			IOMUX_PAD(0x638, 0x1d4, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD10__IPU_DISPB_DAT_10				IOMUX_PAD(0x63c, 0x1d8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD10__GPIO2_10					IOMUX_PAD(0x63c, 0x1d8, 5, 0x86c, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD10__SDMA_SDMA_DEBUG_PC_10			IOMUX_PAD(0x63c, 0x1d8, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD11__IPU_DISPB_DAT_11				IOMUX_PAD(0x640, 0x1dc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD11__GPIO2_11					IOMUX_PAD(0x640, 0x1dc, 5, 0x870, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD11__SDMA_SDMA_DEBUG_PC_11			IOMUX_PAD(0x640, 0x1dc, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD11__ARM11P_TOP_TRACE_4			IOMUX_PAD(0x640, 0x1dc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD12__IPU_DISPB_DAT_12				IOMUX_PAD(0x644, 0x1e0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD12__GPIO2_12					IOMUX_PAD(0x644, 0x1e0, 5, 0x874, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD12__SDMA_SDMA_DEBUG_PC_12			IOMUX_PAD(0x644, 0x1e0, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD12__ARM11P_TOP_TRACE_5			IOMUX_PAD(0x644, 0x1e0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD13__IPU_DISPB_DAT_13				IOMUX_PAD(0x648, 0x1e4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD13__GPIO2_13					IOMUX_PAD(0x648, 0x1e4, 5, 0x878, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD13__SDMA_SDMA_DEBUG_PC_13			IOMUX_PAD(0x648, 0x1e4, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD13__ARM11P_TOP_TRACE_6			IOMUX_PAD(0x648, 0x1e4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD14__IPU_DISPB_DAT_14				IOMUX_PAD(0x64c, 0x1e8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD14__GPIO2_14					IOMUX_PAD(0x64c, 0x1e8, 5, 0x87c, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD14__SDMA_SDMA_DEBUG_EVENT_CHANNEL_0		IOMUX_PAD(0x64c, 0x1e8, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD14__ARM11P_TOP_TRACE_7			IOMUX_PAD(0x64c, 0x1e8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD15__IPU_DISPB_DAT_15				IOMUX_PAD(0x650, 0x1ec, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD15__GPIO2_15					IOMUX_PAD(0x650, 0x1ec, 5, 0x880, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD15__SDMA_SDMA_DEBUG_EVENT_CHANNEL_1		IOMUX_PAD(0x650, 0x1ec, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD15__ARM11P_TOP_TRACE_8			IOMUX_PAD(0x650, 0x1ec, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD16__IPU_DISPB_DAT_16				IOMUX_PAD(0x654, 0x1f0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD16__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x654, 0x1f0, 2, 0x928, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD16__GPIO2_16					IOMUX_PAD(0x654, 0x1f0, 5, 0x884, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD16__SDMA_SDMA_DEBUG_EVENT_CHANNEL_2		IOMUX_PAD(0x654, 0x1f0, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD16__ARM11P_TOP_TRACE_9			IOMUX_PAD(0x654, 0x1f0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD17__IPU_DISPB_DAT_17				IOMUX_PAD(0x658, 0x1f4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD17__IPU_DISPB_CS2				IOMUX_PAD(0x658, 0x1f4, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD17__GPIO2_17					IOMUX_PAD(0x658, 0x1f4, 5, 0x888, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD17__SDMA_SDMA_DEBUG_EVENT_CHANNEL_3		IOMUX_PAD(0x658, 0x1f4, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD17__ARM11P_TOP_TRACE_10			IOMUX_PAD(0x658, 0x1f4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD18__IPU_DISPB_DAT_18				IOMUX_PAD(0x65c, 0x1f8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD18__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x65c, 0x1f8, 1, 0x924, 1, NO_PAD_CTRL)
-#define MX35_PAD_LD18__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x65c, 0x1f8, 2, 0x928, 1, NO_PAD_CTRL)
-#define MX35_PAD_LD18__ESDHC3_CMD				IOMUX_PAD(0x65c, 0x1f8, 3, 0x818, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD18__USB_TOP_USBOTG_DATA_3			IOMUX_PAD(0x65c, 0x1f8, 4, 0x9b0, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD18__GPIO3_24					IOMUX_PAD(0x65c, 0x1f8, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD18__SDMA_SDMA_DEBUG_EVENT_CHANNEL_4		IOMUX_PAD(0x65c, 0x1f8, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD18__ARM11P_TOP_TRACE_11			IOMUX_PAD(0x65c, 0x1f8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD19__IPU_DISPB_DAT_19				IOMUX_PAD(0x660, 0x1fc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__IPU_DISPB_BCLK				IOMUX_PAD(0x660, 0x1fc, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__IPU_DISPB_CS1				IOMUX_PAD(0x660, 0x1fc, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__ESDHC3_CLK				IOMUX_PAD(0x660, 0x1fc, 3, 0x814, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__USB_TOP_USBOTG_DIR			IOMUX_PAD(0x660, 0x1fc, 4, 0x9c4, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__GPIO3_25					IOMUX_PAD(0x660, 0x1fc, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__SDMA_SDMA_DEBUG_EVENT_CHANNEL_5		IOMUX_PAD(0x660, 0x1fc, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD19__ARM11P_TOP_TRACE_12			IOMUX_PAD(0x660, 0x1fc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD20__IPU_DISPB_DAT_20				IOMUX_PAD(0x664, 0x200, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__IPU_DISPB_CS0				IOMUX_PAD(0x664, 0x200, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__IPU_DISPB_SD_CLK				IOMUX_PAD(0x664, 0x200, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__ESDHC3_DAT0				IOMUX_PAD(0x664, 0x200, 3, 0x81c, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__GPIO3_26					IOMUX_PAD(0x664, 0x200, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__SDMA_SDMA_DEBUG_CORE_STATUS_3		IOMUX_PAD(0x664, 0x200, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD20__ARM11P_TOP_TRACE_13			IOMUX_PAD(0x664, 0x200, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD21__IPU_DISPB_DAT_21				IOMUX_PAD(0x668, 0x204, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__IPU_DISPB_PAR_RS				IOMUX_PAD(0x668, 0x204, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__IPU_DISPB_SER_RS				IOMUX_PAD(0x668, 0x204, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__ESDHC3_DAT1				IOMUX_PAD(0x668, 0x204, 3, 0x820, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__USB_TOP_USBOTG_STP			IOMUX_PAD(0x668, 0x204, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__GPIO3_27					IOMUX_PAD(0x668, 0x204, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__SDMA_DEBUG_EVENT_CHANNEL_SEL		IOMUX_PAD(0x668, 0x204, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD21__ARM11P_TOP_TRACE_14			IOMUX_PAD(0x668, 0x204, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD22__IPU_DISPB_DAT_22				IOMUX_PAD(0x66c, 0x208, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__IPU_DISPB_WR				IOMUX_PAD(0x66c, 0x208, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__IPU_DISPB_SD_D_I				IOMUX_PAD(0x66c, 0x208, 2, 0x92c, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__ESDHC3_DAT2				IOMUX_PAD(0x66c, 0x208, 3, 0x824, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__USB_TOP_USBOTG_NXT			IOMUX_PAD(0x66c, 0x208, 4, 0x9c8, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__GPIO3_28					IOMUX_PAD(0x66c, 0x208, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__SDMA_DEBUG_BUS_ERROR			IOMUX_PAD(0x66c, 0x208, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD22__ARM11P_TOP_TRCTL				IOMUX_PAD(0x66c, 0x208, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_LD23__IPU_DISPB_DAT_23				IOMUX_PAD(0x670, 0x20c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__IPU_DISPB_RD				IOMUX_PAD(0x670, 0x20c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x670, 0x20c, 2, 0x92c, 1, NO_PAD_CTRL)
-#define MX35_PAD_LD23__ESDHC3_DAT3				IOMUX_PAD(0x670, 0x20c, 3, 0x828, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__USB_TOP_USBOTG_DATA_7			IOMUX_PAD(0x670, 0x20c, 4, 0x9c0, 0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__GPIO3_29					IOMUX_PAD(0x670, 0x20c, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__SDMA_DEBUG_MATCHED_DMBUS			IOMUX_PAD(0x670, 0x20c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_LD23__ARM11P_TOP_TRCLK				IOMUX_PAD(0x670, 0x20c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_HSYNC__IPU_DISPB_D3_HSYNC			IOMUX_PAD(0x674, 0x210, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_HSYNC__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x674, 0x210, 2, 0x92c, 2, NO_PAD_CTRL)
-#define MX35_PAD_D3_HSYNC__GPIO3_30				IOMUX_PAD(0x674, 0x210, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_HSYNC__SDMA_DEBUG_RTBUFFER_WRITE		IOMUX_PAD(0x674, 0x210, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_HSYNC__ARM11P_TOP_TRACE_15			IOMUX_PAD(0x674, 0x210, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_FPSHIFT__IPU_DISPB_D3_CLK			IOMUX_PAD(0x678, 0x214, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_FPSHIFT__IPU_DISPB_SD_CLK			IOMUX_PAD(0x678, 0x214, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_FPSHIFT__GPIO3_31				IOMUX_PAD(0x678, 0x214, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_FPSHIFT__SDMA_SDMA_DEBUG_CORE_STATUS_0	IOMUX_PAD(0x678, 0x214, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_FPSHIFT__ARM11P_TOP_TRACE_16		IOMUX_PAD(0x678, 0x214, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_DRDY__IPU_DISPB_D3_DRDY			IOMUX_PAD(0x67c, 0x218, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_DRDY__IPU_DISPB_SD_D_O			IOMUX_PAD(0x67c, 0x218, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_DRDY__GPIO1_0				IOMUX_PAD(0x67c, 0x218, 5, 0x82c, 2, NO_PAD_CTRL)
-#define MX35_PAD_D3_DRDY__SDMA_SDMA_DEBUG_CORE_STATUS_1		IOMUX_PAD(0x67c, 0x218, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_DRDY__ARM11P_TOP_TRACE_17			IOMUX_PAD(0x67c, 0x218, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_CONTRAST__IPU_DISPB_CONTR			IOMUX_PAD(0x680, 0x21c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CONTRAST__GPIO1_1				IOMUX_PAD(0x680, 0x21c, 5, 0x838, 2, NO_PAD_CTRL)
-#define MX35_PAD_CONTRAST__SDMA_SDMA_DEBUG_CORE_STATUS_2	IOMUX_PAD(0x680, 0x21c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_CONTRAST__ARM11P_TOP_TRACE_18			IOMUX_PAD(0x680, 0x21c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_VSYNC__IPU_DISPB_D3_VSYNC			IOMUX_PAD(0x684, 0x220, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_VSYNC__IPU_DISPB_CS1			IOMUX_PAD(0x684, 0x220, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_VSYNC__GPIO1_2				IOMUX_PAD(0x684, 0x220, 5, 0x848, 1, NO_PAD_CTRL)
-#define MX35_PAD_D3_VSYNC__SDMA_DEBUG_YIELD			IOMUX_PAD(0x684, 0x220, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_VSYNC__ARM11P_TOP_TRACE_19			IOMUX_PAD(0x684, 0x220, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_REV__IPU_DISPB_D3_REV			IOMUX_PAD(0x688, 0x224, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_REV__IPU_DISPB_SER_RS			IOMUX_PAD(0x688, 0x224, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_REV__GPIO1_3				IOMUX_PAD(0x688, 0x224, 5, 0x84c, 1, NO_PAD_CTRL)
-#define MX35_PAD_D3_REV__SDMA_DEBUG_BUS_RWB			IOMUX_PAD(0x688, 0x224, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_REV__ARM11P_TOP_TRACE_20			IOMUX_PAD(0x688, 0x224, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_CLS__IPU_DISPB_D3_CLS			IOMUX_PAD(0x68c, 0x228, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_CLS__IPU_DISPB_CS2				IOMUX_PAD(0x68c, 0x228, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_CLS__GPIO1_4				IOMUX_PAD(0x68c, 0x228, 5, 0x850, 2, NO_PAD_CTRL)
-#define MX35_PAD_D3_CLS__SDMA_DEBUG_BUS_DEVICE_0		IOMUX_PAD(0x68c, 0x228, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_CLS__ARM11P_TOP_TRACE_21			IOMUX_PAD(0x68c, 0x228, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_D3_SPL__IPU_DISPB_D3_SPL			IOMUX_PAD(0x690, 0x22c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_SPL__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x690, 0x22c, 2, 0x928, 2, NO_PAD_CTRL)
-#define MX35_PAD_D3_SPL__GPIO1_5				IOMUX_PAD(0x690, 0x22c, 5, 0x854, 2, NO_PAD_CTRL)
-#define MX35_PAD_D3_SPL__SDMA_DEBUG_BUS_DEVICE_1		IOMUX_PAD(0x690, 0x22c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_D3_SPL__ARM11P_TOP_TRACE_22			IOMUX_PAD(0x690, 0x22c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_CMD__ESDHC1_CMD				IOMUX_PAD(0x694, 0x230, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CMD__MSHC_SCLK				IOMUX_PAD(0x694, 0x230, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CMD__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x694, 0x230, 3, 0x924, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CMD__USB_TOP_USBOTG_DATA_4			IOMUX_PAD(0x694, 0x230, 4, 0x9b4, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CMD__GPIO1_6				IOMUX_PAD(0x694, 0x230, 5, 0x858, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CMD__ARM11P_TOP_TRCTL			IOMUX_PAD(0x694, 0x230, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_CLK__ESDHC1_CLK				IOMUX_PAD(0x698, 0x234, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CLK__MSHC_BS				IOMUX_PAD(0x698, 0x234, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CLK__IPU_DISPB_BCLK			IOMUX_PAD(0x698, 0x234, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CLK__USB_TOP_USBOTG_DATA_5			IOMUX_PAD(0x698, 0x234, 4, 0x9b8, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CLK__GPIO1_7				IOMUX_PAD(0x698, 0x234, 5, 0x85c, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD1_CLK__ARM11P_TOP_TRCLK			IOMUX_PAD(0x698, 0x234, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_DATA0__ESDHC1_DAT0				IOMUX_PAD(0x69c, 0x238, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA0__MSHC_DATA_0				IOMUX_PAD(0x69c, 0x238, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA0__IPU_DISPB_CS0			IOMUX_PAD(0x69c, 0x238, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA0__USB_TOP_USBOTG_DATA_6		IOMUX_PAD(0x69c, 0x238, 4, 0x9bc, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA0__GPIO1_8				IOMUX_PAD(0x69c, 0x238, 5, 0x860, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA0__ARM11P_TOP_TRACE_23			IOMUX_PAD(0x69c, 0x238, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_DATA1__ESDHC1_DAT1				IOMUX_PAD(0x6a0, 0x23c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA1__MSHC_DATA_1				IOMUX_PAD(0x6a0, 0x23c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA1__IPU_DISPB_PAR_RS			IOMUX_PAD(0x6a0, 0x23c, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA1__USB_TOP_USBOTG_DATA_0		IOMUX_PAD(0x6a0, 0x23c, 4, 0x9a4, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA1__GPIO1_9				IOMUX_PAD(0x6a0, 0x23c, 5, 0x864, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA1__ARM11P_TOP_TRACE_24			IOMUX_PAD(0x6a0, 0x23c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_DATA2__ESDHC1_DAT2				IOMUX_PAD(0x6a4, 0x240, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA2__MSHC_DATA_2				IOMUX_PAD(0x6a4, 0x240, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA2__IPU_DISPB_WR			IOMUX_PAD(0x6a4, 0x240, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA2__USB_TOP_USBOTG_DATA_1		IOMUX_PAD(0x6a4, 0x240, 4, 0x9a8, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA2__GPIO1_10				IOMUX_PAD(0x6a4, 0x240, 5, 0x830, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA2__ARM11P_TOP_TRACE_25			IOMUX_PAD(0x6a4, 0x240, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD1_DATA3__ESDHC1_DAT3				IOMUX_PAD(0x6a8, 0x244, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA3__MSHC_DATA_3				IOMUX_PAD(0x6a8, 0x244, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA3__IPU_DISPB_RD			IOMUX_PAD(0x6a8, 0x244, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA3__USB_TOP_USBOTG_DATA_2		IOMUX_PAD(0x6a8, 0x244, 4, 0x9ac, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA3__GPIO1_11				IOMUX_PAD(0x6a8, 0x244, 5, 0x834, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD1_DATA3__ARM11P_TOP_TRACE_26			IOMUX_PAD(0x6a8, 0x244, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_CMD__ESDHC2_CMD				IOMUX_PAD(0x6ac, 0x248, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__I2C3_SCL				IOMUX_PAD(0x6ac, 0x248, 1, 0x91c, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__ESDHC1_DAT4				IOMUX_PAD(0x6ac, 0x248, 2, 0x804, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__IPU_CSI_D_2				IOMUX_PAD(0x6ac, 0x248, 3, 0x938, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__USB_TOP_USBH2_DATA_4			IOMUX_PAD(0x6ac, 0x248, 4, 0x9dc, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__GPIO2_0				IOMUX_PAD(0x6ac, 0x248, 5, 0x868, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x6ac, 0x248, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CMD__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x6ac, 0x248, 7, 0x928, 3, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_CLK__ESDHC2_CLK				IOMUX_PAD(0x6b0, 0x24c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__I2C3_SDA				IOMUX_PAD(0x6b0, 0x24c, 1, 0x920, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__ESDHC1_DAT5				IOMUX_PAD(0x6b0, 0x24c, 2, 0x808, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__IPU_CSI_D_3				IOMUX_PAD(0x6b0, 0x24c, 3, 0x93c, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__USB_TOP_USBH2_DATA_5			IOMUX_PAD(0x6b0, 0x24c, 4, 0x9e0, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__GPIO2_1				IOMUX_PAD(0x6b0, 0x24c, 5, 0x894, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__SPDIF_SPDIF_IN1			IOMUX_PAD(0x6b0, 0x24c, 6, 0x998, 2, NO_PAD_CTRL)
-#define MX35_PAD_SD2_CLK__IPU_DISPB_CS2				IOMUX_PAD(0x6b0, 0x24c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_DATA0__ESDHC2_DAT0				IOMUX_PAD(0x6b4, 0x250, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__UART3_RXD_MUX			IOMUX_PAD(0x6b4, 0x250, 1, 0x9a0, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__ESDHC1_DAT6				IOMUX_PAD(0x6b4, 0x250, 2, 0x80c, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__IPU_CSI_D_4				IOMUX_PAD(0x6b4, 0x250, 3, 0x940, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__USB_TOP_USBH2_DATA_6		IOMUX_PAD(0x6b4, 0x250, 4, 0x9e4, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__GPIO2_2				IOMUX_PAD(0x6b4, 0x250, 5, 0x8c0, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA0__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x6b4, 0x250, 6, 0x994, 3, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_DATA1__ESDHC2_DAT1				IOMUX_PAD(0x6b8, 0x254, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA1__UART3_TXD_MUX			IOMUX_PAD(0x6b8, 0x254, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA1__ESDHC1_DAT7				IOMUX_PAD(0x6b8, 0x254, 2, 0x810, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA1__IPU_CSI_D_5				IOMUX_PAD(0x6b8, 0x254, 3, 0x944, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA1__USB_TOP_USBH2_DATA_0		IOMUX_PAD(0x6b8, 0x254, 4, 0x9cc, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA1__GPIO2_3				IOMUX_PAD(0x6b8, 0x254, 5, 0x8cc, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_DATA2__ESDHC2_DAT2				IOMUX_PAD(0x6bc, 0x258, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA2__UART3_RTS				IOMUX_PAD(0x6bc, 0x258, 1, 0x99c, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA2__CAN1_RXCAN				IOMUX_PAD(0x6bc, 0x258, 2, 0x7c8, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA2__IPU_CSI_D_6				IOMUX_PAD(0x6bc, 0x258, 3, 0x948, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA2__USB_TOP_USBH2_DATA_1		IOMUX_PAD(0x6bc, 0x258, 4, 0x9d0, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA2__GPIO2_4				IOMUX_PAD(0x6bc, 0x258, 5, 0x8d0, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_SD2_DATA3__ESDHC2_DAT3				IOMUX_PAD(0x6c0, 0x25c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA3__UART3_CTS				IOMUX_PAD(0x6c0, 0x25c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA3__CAN1_TXCAN				IOMUX_PAD(0x6c0, 0x25c, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA3__IPU_CSI_D_7				IOMUX_PAD(0x6c0, 0x25c, 3, 0x94c, 1, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA3__USB_TOP_USBH2_DATA_2		IOMUX_PAD(0x6c0, 0x25c, 4, 0x9d4, 0, NO_PAD_CTRL)
-#define MX35_PAD_SD2_DATA3__GPIO2_5				IOMUX_PAD(0x6c0, 0x25c, 5, 0x8d4, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_CS0__ATA_CS0				IOMUX_PAD(0x6c4, 0x260, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS0__CSPI1_SS3				IOMUX_PAD(0x6c4, 0x260, 1, 0x7dc, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS0__IPU_DISPB_CS1				IOMUX_PAD(0x6c4, 0x260, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS0__GPIO2_6				IOMUX_PAD(0x6c4, 0x260, 5, 0x8d8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS0__IPU_DIAGB_0				IOMUX_PAD(0x6c4, 0x260, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS0__ARM11P_TOP_MAX1_HMASTER_0		IOMUX_PAD(0x6c4, 0x260, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_CS1__ATA_CS1				IOMUX_PAD(0x6c8, 0x264, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS1__IPU_DISPB_CS2				IOMUX_PAD(0x6c8, 0x264, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS1__CSPI2_SS0				IOMUX_PAD(0x6c8, 0x264, 4, 0x7f0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS1__GPIO2_7				IOMUX_PAD(0x6c8, 0x264, 5, 0x8dc, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS1__IPU_DIAGB_1				IOMUX_PAD(0x6c8, 0x264, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_CS1__ARM11P_TOP_MAX1_HMASTER_1		IOMUX_PAD(0x6c8, 0x264, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DIOR__ATA_DIOR				IOMUX_PAD(0x6cc, 0x268, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__ESDHC3_DAT0				IOMUX_PAD(0x6cc, 0x268, 1, 0x81c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__USB_TOP_USBOTG_DIR			IOMUX_PAD(0x6cc, 0x268, 2, 0x9c4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__IPU_DISPB_BE0			IOMUX_PAD(0x6cc, 0x268, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__CSPI2_SS1				IOMUX_PAD(0x6cc, 0x268, 4, 0x7f4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__GPIO2_8				IOMUX_PAD(0x6cc, 0x268, 5, 0x8e0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__IPU_DIAGB_2				IOMUX_PAD(0x6cc, 0x268, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOR__ARM11P_TOP_MAX1_HMASTER_2		IOMUX_PAD(0x6cc, 0x268, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DIOW__ATA_DIOW				IOMUX_PAD(0x6d0, 0x26c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__ESDHC3_DAT1				IOMUX_PAD(0x6d0, 0x26c, 1, 0x820, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__USB_TOP_USBOTG_STP			IOMUX_PAD(0x6d0, 0x26c, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__IPU_DISPB_BE1			IOMUX_PAD(0x6d0, 0x26c, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__CSPI2_MOSI				IOMUX_PAD(0x6d0, 0x26c, 4, 0x7ec, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__GPIO2_9				IOMUX_PAD(0x6d0, 0x26c, 5, 0x8e4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__IPU_DIAGB_3				IOMUX_PAD(0x6d0, 0x26c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DIOW__ARM11P_TOP_MAX1_HMASTER_3		IOMUX_PAD(0x6d0, 0x26c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DMACK__ATA_DMACK				IOMUX_PAD(0x6d4, 0x270, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__ESDHC3_DAT2				IOMUX_PAD(0x6d4, 0x270, 1, 0x824, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__USB_TOP_USBOTG_NXT			IOMUX_PAD(0x6d4, 0x270, 2, 0x9c8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__CSPI2_MISO				IOMUX_PAD(0x6d4, 0x270, 4, 0x7e8, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__GPIO2_10				IOMUX_PAD(0x6d4, 0x270, 5, 0x86c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__IPU_DIAGB_4				IOMUX_PAD(0x6d4, 0x270, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMACK__ARM11P_TOP_MAX0_HMASTER_0		IOMUX_PAD(0x6d4, 0x270, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_RESET_B__ATA_RESET_B			IOMUX_PAD(0x6d8, 0x274, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__ESDHC3_DAT3			IOMUX_PAD(0x6d8, 0x274, 1, 0x828, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__USB_TOP_USBOTG_DATA_0		IOMUX_PAD(0x6d8, 0x274, 2, 0x9a4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__IPU_DISPB_SD_D_O			IOMUX_PAD(0x6d8, 0x274, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__CSPI2_RDY				IOMUX_PAD(0x6d8, 0x274, 4, 0x7e4, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__GPIO2_11				IOMUX_PAD(0x6d8, 0x274, 5, 0x870, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__IPU_DIAGB_5			IOMUX_PAD(0x6d8, 0x274, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_RESET_B__ARM11P_TOP_MAX0_HMASTER_1		IOMUX_PAD(0x6d8, 0x274, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_IORDY__ATA_IORDY				IOMUX_PAD(0x6dc, 0x278, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__ESDHC3_DAT4				IOMUX_PAD(0x6dc, 0x278, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__USB_TOP_USBOTG_DATA_1		IOMUX_PAD(0x6dc, 0x278, 2, 0x9a8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x6dc, 0x278, 3, 0x92c, 3, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__ESDHC2_DAT4				IOMUX_PAD(0x6dc, 0x278, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__GPIO2_12				IOMUX_PAD(0x6dc, 0x278, 5, 0x874, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__IPU_DIAGB_6				IOMUX_PAD(0x6dc, 0x278, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_IORDY__ARM11P_TOP_MAX0_HMASTER_2		IOMUX_PAD(0x6dc, 0x278, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA0__ATA_DATA_0				IOMUX_PAD(0x6e0, 0x27c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__ESDHC3_DAT5				IOMUX_PAD(0x6e0, 0x27c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__USB_TOP_USBOTG_DATA_2		IOMUX_PAD(0x6e0, 0x27c, 2, 0x9ac, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__IPU_DISPB_D12_VSYNC			IOMUX_PAD(0x6e0, 0x27c, 3, 0x928, 4, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__ESDHC2_DAT5				IOMUX_PAD(0x6e0, 0x27c, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__GPIO2_13				IOMUX_PAD(0x6e0, 0x27c, 5, 0x878, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__IPU_DIAGB_7				IOMUX_PAD(0x6e0, 0x27c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA0__ARM11P_TOP_MAX0_HMASTER_3		IOMUX_PAD(0x6e0, 0x27c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA1__ATA_DATA_1				IOMUX_PAD(0x6e4, 0x280, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__ESDHC3_DAT6				IOMUX_PAD(0x6e4, 0x280, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__USB_TOP_USBOTG_DATA_3		IOMUX_PAD(0x6e4, 0x280, 2, 0x9b0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__IPU_DISPB_SD_CLK			IOMUX_PAD(0x6e4, 0x280, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__ESDHC2_DAT6				IOMUX_PAD(0x6e4, 0x280, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__GPIO2_14				IOMUX_PAD(0x6e4, 0x280, 5, 0x87c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__IPU_DIAGB_8				IOMUX_PAD(0x6e4, 0x280, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA1__ARM11P_TOP_TRACE_27			IOMUX_PAD(0x6e4, 0x280, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA2__ATA_DATA_2				IOMUX_PAD(0x6e8, 0x284, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__ESDHC3_DAT7				IOMUX_PAD(0x6e8, 0x284, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__USB_TOP_USBOTG_DATA_4		IOMUX_PAD(0x6e8, 0x284, 2, 0x9b4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__IPU_DISPB_SER_RS			IOMUX_PAD(0x6e8, 0x284, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__ESDHC2_DAT7				IOMUX_PAD(0x6e8, 0x284, 4, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__GPIO2_15				IOMUX_PAD(0x6e8, 0x284, 5, 0x880, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__IPU_DIAGB_9				IOMUX_PAD(0x6e8, 0x284, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA2__ARM11P_TOP_TRACE_28			IOMUX_PAD(0x6e8, 0x284, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA3__ATA_DATA_3				IOMUX_PAD(0x6ec, 0x288, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__ESDHC3_CLK				IOMUX_PAD(0x6ec, 0x288, 1, 0x814, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__USB_TOP_USBOTG_DATA_5		IOMUX_PAD(0x6ec, 0x288, 2, 0x9b8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__CSPI2_SCLK				IOMUX_PAD(0x6ec, 0x288, 4, 0x7e0, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__GPIO2_16				IOMUX_PAD(0x6ec, 0x288, 5, 0x884, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__IPU_DIAGB_10			IOMUX_PAD(0x6ec, 0x288, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA3__ARM11P_TOP_TRACE_29			IOMUX_PAD(0x6ec, 0x288, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA4__ATA_DATA_4				IOMUX_PAD(0x6f0, 0x28c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA4__ESDHC3_CMD				IOMUX_PAD(0x6f0, 0x28c, 1, 0x818, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA4__USB_TOP_USBOTG_DATA_6		IOMUX_PAD(0x6f0, 0x28c, 2, 0x9bc, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA4__GPIO2_17				IOMUX_PAD(0x6f0, 0x28c, 5, 0x888, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA4__IPU_DIAGB_11			IOMUX_PAD(0x6f0, 0x28c, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA4__ARM11P_TOP_TRACE_30			IOMUX_PAD(0x6f0, 0x28c, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA5__ATA_DATA_5				IOMUX_PAD(0x6f4, 0x290, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA5__USB_TOP_USBOTG_DATA_7		IOMUX_PAD(0x6f4, 0x290, 2, 0x9c0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA5__GPIO2_18				IOMUX_PAD(0x6f4, 0x290, 5, 0x88c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA5__IPU_DIAGB_12			IOMUX_PAD(0x6f4, 0x290, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA5__ARM11P_TOP_TRACE_31			IOMUX_PAD(0x6f4, 0x290, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA6__ATA_DATA_6				IOMUX_PAD(0x6f8, 0x294, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA6__CAN1_TXCAN				IOMUX_PAD(0x6f8, 0x294, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA6__UART1_DTR				IOMUX_PAD(0x6f8, 0x294, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA6__AUDMUX_AUD6_TXD			IOMUX_PAD(0x6f8, 0x294, 3, 0x7b4, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA6__GPIO2_19				IOMUX_PAD(0x6f8, 0x294, 5, 0x890, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA6__IPU_DIAGB_13			IOMUX_PAD(0x6f8, 0x294, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA7__ATA_DATA_7				IOMUX_PAD(0x6fc, 0x298, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA7__CAN1_RXCAN				IOMUX_PAD(0x6fc, 0x298, 1, 0x7c8, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA7__UART1_DSR				IOMUX_PAD(0x6fc, 0x298, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA7__AUDMUX_AUD6_RXD			IOMUX_PAD(0x6fc, 0x298, 3, 0x7b0, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA7__GPIO2_20				IOMUX_PAD(0x6fc, 0x298, 5, 0x898, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA7__IPU_DIAGB_14			IOMUX_PAD(0x6fc, 0x298, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA8__ATA_DATA_8				IOMUX_PAD(0x700, 0x29c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA8__UART3_RTS				IOMUX_PAD(0x700, 0x29c, 1, 0x99c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA8__UART1_RI				IOMUX_PAD(0x700, 0x29c, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA8__AUDMUX_AUD6_TXC			IOMUX_PAD(0x700, 0x29c, 3, 0x7c0, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA8__GPIO2_21				IOMUX_PAD(0x700, 0x29c, 5, 0x89c, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA8__IPU_DIAGB_15			IOMUX_PAD(0x700, 0x29c, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA9__ATA_DATA_9				IOMUX_PAD(0x704, 0x2a0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA9__UART3_CTS				IOMUX_PAD(0x704, 0x2a0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA9__UART1_DCD				IOMUX_PAD(0x704, 0x2a0, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA9__AUDMUX_AUD6_TXFS			IOMUX_PAD(0x704, 0x2a0, 3, 0x7c4, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA9__GPIO2_22				IOMUX_PAD(0x704, 0x2a0, 5, 0x8a0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA9__IPU_DIAGB_16			IOMUX_PAD(0x704, 0x2a0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA10__ATA_DATA_10			IOMUX_PAD(0x708, 0x2a4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA10__UART3_RXD_MUX			IOMUX_PAD(0x708, 0x2a4, 1, 0x9a0, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA10__AUDMUX_AUD6_RXC			IOMUX_PAD(0x708, 0x2a4, 3, 0x7b8, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA10__GPIO2_23				IOMUX_PAD(0x708, 0x2a4, 5, 0x8a4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA10__IPU_DIAGB_17			IOMUX_PAD(0x708, 0x2a4, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA11__ATA_DATA_11			IOMUX_PAD(0x70c, 0x2a8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA11__UART3_TXD_MUX			IOMUX_PAD(0x70c, 0x2a8, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA11__AUDMUX_AUD6_RXFS			IOMUX_PAD(0x70c, 0x2a8, 3, 0x7bc, 0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA11__GPIO2_24				IOMUX_PAD(0x70c, 0x2a8, 5, 0x8a8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA11__IPU_DIAGB_18			IOMUX_PAD(0x70c, 0x2a8, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA12__ATA_DATA_12			IOMUX_PAD(0x710, 0x2ac, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA12__I2C3_SCL				IOMUX_PAD(0x710, 0x2ac, 1, 0x91c, 3, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA12__GPIO2_25				IOMUX_PAD(0x710, 0x2ac, 5, 0x8ac, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA12__IPU_DIAGB_19			IOMUX_PAD(0x710, 0x2ac, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA13__ATA_DATA_13			IOMUX_PAD(0x714, 0x2b0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA13__I2C3_SDA				IOMUX_PAD(0x714, 0x2b0, 1, 0x920, 3, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA13__GPIO2_26				IOMUX_PAD(0x714, 0x2b0, 5, 0x8b0, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA13__IPU_DIAGB_20			IOMUX_PAD(0x714, 0x2b0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA14__ATA_DATA_14			IOMUX_PAD(0x718, 0x2b4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA14__IPU_CSI_D_0			IOMUX_PAD(0x718, 0x2b4, 1, 0x930, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA14__KPP_ROW_0				IOMUX_PAD(0x718, 0x2b4, 3, 0x970, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA14__GPIO2_27				IOMUX_PAD(0x718, 0x2b4, 5, 0x8b4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA14__IPU_DIAGB_21			IOMUX_PAD(0x718, 0x2b4, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DATA15__ATA_DATA_15			IOMUX_PAD(0x71c, 0x2b8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA15__IPU_CSI_D_1			IOMUX_PAD(0x71c, 0x2b8, 1, 0x934, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA15__KPP_ROW_1				IOMUX_PAD(0x71c, 0x2b8, 3, 0x974, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA15__GPIO2_28				IOMUX_PAD(0x71c, 0x2b8, 5, 0x8b8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DATA15__IPU_DIAGB_22			IOMUX_PAD(0x71c, 0x2b8, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_INTRQ__ATA_INTRQ				IOMUX_PAD(0x720, 0x2bc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_INTRQ__IPU_CSI_D_2				IOMUX_PAD(0x720, 0x2bc, 1, 0x938, 3, NO_PAD_CTRL)
-#define MX35_PAD_ATA_INTRQ__KPP_ROW_2				IOMUX_PAD(0x720, 0x2bc, 3, 0x978, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_INTRQ__GPIO2_29				IOMUX_PAD(0x720, 0x2bc, 5, 0x8bc, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_INTRQ__IPU_DIAGB_23			IOMUX_PAD(0x720, 0x2bc, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_BUFF_EN__ATA_BUFFER_EN			IOMUX_PAD(0x724, 0x2c0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_BUFF_EN__IPU_CSI_D_3			IOMUX_PAD(0x724, 0x2c0, 1, 0x93c, 3, NO_PAD_CTRL)
-#define MX35_PAD_ATA_BUFF_EN__KPP_ROW_3				IOMUX_PAD(0x724, 0x2c0, 3, 0x97c, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_BUFF_EN__GPIO2_30				IOMUX_PAD(0x724, 0x2c0, 5, 0x8c4, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_BUFF_EN__IPU_DIAGB_24			IOMUX_PAD(0x724, 0x2c0, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DMARQ__ATA_DMARQ				IOMUX_PAD(0x728, 0x2c4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMARQ__IPU_CSI_D_4				IOMUX_PAD(0x728, 0x2c4, 1, 0x940, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMARQ__KPP_COL_0				IOMUX_PAD(0x728, 0x2c4, 3, 0x950, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMARQ__GPIO2_31				IOMUX_PAD(0x728, 0x2c4, 5, 0x8c8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMARQ__IPU_DIAGB_25			IOMUX_PAD(0x728, 0x2c4, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DMARQ__ECT_CTI_TRIG_IN1_4			IOMUX_PAD(0x728, 0x2c4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DA0__ATA_DA_0				IOMUX_PAD(0x72c, 0x2c8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA0__IPU_CSI_D_5				IOMUX_PAD(0x72c, 0x2c8, 1, 0x944, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA0__KPP_COL_1				IOMUX_PAD(0x72c, 0x2c8, 3, 0x954, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA0__GPIO3_0				IOMUX_PAD(0x72c, 0x2c8, 5, 0x8e8, 1, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA0__IPU_DIAGB_26				IOMUX_PAD(0x72c, 0x2c8, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA0__ECT_CTI_TRIG_IN1_5			IOMUX_PAD(0x72c, 0x2c8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DA1__ATA_DA_1				IOMUX_PAD(0x730, 0x2cc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA1__IPU_CSI_D_6				IOMUX_PAD(0x730, 0x2cc, 1, 0x948, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA1__KPP_COL_2				IOMUX_PAD(0x730, 0x2cc, 3, 0x958, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA1__GPIO3_1				IOMUX_PAD(0x730, 0x2cc, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA1__IPU_DIAGB_27				IOMUX_PAD(0x730, 0x2cc, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA1__ECT_CTI_TRIG_IN1_6			IOMUX_PAD(0x730, 0x2cc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_ATA_DA2__ATA_DA_2				IOMUX_PAD(0x734, 0x2d0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA2__IPU_CSI_D_7				IOMUX_PAD(0x734, 0x2d0, 1, 0x94c, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA2__KPP_COL_3				IOMUX_PAD(0x734, 0x2d0, 3, 0x95c, 2, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA2__GPIO3_2				IOMUX_PAD(0x734, 0x2d0, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA2__IPU_DIAGB_28				IOMUX_PAD(0x734, 0x2d0, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_ATA_DA2__ECT_CTI_TRIG_IN1_7			IOMUX_PAD(0x734, 0x2d0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_MLB_CLK__MLB_MLBCLK				IOMUX_PAD(0x738, 0x2d4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_MLB_CLK__GPIO3_3				IOMUX_PAD(0x738, 0x2d4, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_MLB_DAT__MLB_MLBDAT				IOMUX_PAD(0x73c, 0x2d8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_MLB_DAT__GPIO3_4				IOMUX_PAD(0x73c, 0x2d8, 5, 0x904, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_MLB_SIG__MLB_MLBSIG				IOMUX_PAD(0x740, 0x2dc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_MLB_SIG__GPIO3_5				IOMUX_PAD(0x740, 0x2dc, 5, 0x908, 1, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TX_CLK__FEC_TX_CLK				IOMUX_PAD(0x744, 0x2e0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__ESDHC1_DAT4			IOMUX_PAD(0x744, 0x2e0, 1, 0x804, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__UART3_RXD_MUX			IOMUX_PAD(0x744, 0x2e0, 2, 0x9a0, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__USB_TOP_USBH2_DIR			IOMUX_PAD(0x744, 0x2e0, 3, 0x9ec, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__CSPI2_MOSI				IOMUX_PAD(0x744, 0x2e0, 4, 0x7ec, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__GPIO3_6				IOMUX_PAD(0x744, 0x2e0, 5, 0x90c, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__IPU_DISPB_D12_VSYNC		IOMUX_PAD(0x744, 0x2e0, 6, 0x928, 5, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_CLK__ARM11P_TOP_EVNTBUS_0		IOMUX_PAD(0x744, 0x2e0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RX_CLK__FEC_RX_CLK				IOMUX_PAD(0x748, 0x2e4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__ESDHC1_DAT5			IOMUX_PAD(0x748, 0x2e4, 1, 0x808, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__UART3_TXD_MUX			IOMUX_PAD(0x748, 0x2e4, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__USB_TOP_USBH2_STP			IOMUX_PAD(0x748, 0x2e4, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__CSPI2_MISO				IOMUX_PAD(0x748, 0x2e4, 4, 0x7e8, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__GPIO3_7				IOMUX_PAD(0x748, 0x2e4, 5, 0x910, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__IPU_DISPB_SD_D_I			IOMUX_PAD(0x748, 0x2e4, 6, 0x92c, 4, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_CLK__ARM11P_TOP_EVNTBUS_1		IOMUX_PAD(0x748, 0x2e4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RX_DV__FEC_RX_DV				IOMUX_PAD(0x74c, 0x2e8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__ESDHC1_DAT6				IOMUX_PAD(0x74c, 0x2e8, 1, 0x80c, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__UART3_RTS				IOMUX_PAD(0x74c, 0x2e8, 2, 0x99c, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__USB_TOP_USBH2_NXT			IOMUX_PAD(0x74c, 0x2e8, 3, 0x9f0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__CSPI2_SCLK				IOMUX_PAD(0x74c, 0x2e8, 4, 0x7e0, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__GPIO3_8				IOMUX_PAD(0x74c, 0x2e8, 5, 0x914, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__IPU_DISPB_SD_CLK			IOMUX_PAD(0x74c, 0x2e8, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_DV__ARM11P_TOP_EVNTBUS_2		IOMUX_PAD(0x74c, 0x2e8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_COL__FEC_COL				IOMUX_PAD(0x750, 0x2ec, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__ESDHC1_DAT7				IOMUX_PAD(0x750, 0x2ec, 1, 0x810, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__UART3_CTS				IOMUX_PAD(0x750, 0x2ec, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__USB_TOP_USBH2_DATA_0			IOMUX_PAD(0x750, 0x2ec, 3, 0x9cc, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__CSPI2_RDY				IOMUX_PAD(0x750, 0x2ec, 4, 0x7e4, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__GPIO3_9				IOMUX_PAD(0x750, 0x2ec, 5, 0x918, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__IPU_DISPB_SER_RS			IOMUX_PAD(0x750, 0x2ec, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_COL__ARM11P_TOP_EVNTBUS_3			IOMUX_PAD(0x750, 0x2ec, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RDATA0__FEC_RDATA_0			IOMUX_PAD(0x754, 0x2f0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__PWM_PWMO				IOMUX_PAD(0x754, 0x2f0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__UART3_DTR				IOMUX_PAD(0x754, 0x2f0, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__USB_TOP_USBH2_DATA_1		IOMUX_PAD(0x754, 0x2f0, 3, 0x9d0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__CSPI2_SS0				IOMUX_PAD(0x754, 0x2f0, 4, 0x7f0, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__GPIO3_10				IOMUX_PAD(0x754, 0x2f0, 5, 0x8ec, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__IPU_DISPB_CS1			IOMUX_PAD(0x754, 0x2f0, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA0__ARM11P_TOP_EVNTBUS_4		IOMUX_PAD(0x754, 0x2f0, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TDATA0__FEC_TDATA_0			IOMUX_PAD(0x758, 0x2f4, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__SPDIF_SPDIF_OUT1			IOMUX_PAD(0x758, 0x2f4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__UART3_DSR				IOMUX_PAD(0x758, 0x2f4, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__USB_TOP_USBH2_DATA_2		IOMUX_PAD(0x758, 0x2f4, 3, 0x9d4, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__CSPI2_SS1				IOMUX_PAD(0x758, 0x2f4, 4, 0x7f4, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__GPIO3_11				IOMUX_PAD(0x758, 0x2f4, 5, 0x8f0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__IPU_DISPB_CS0			IOMUX_PAD(0x758, 0x2f4, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA0__ARM11P_TOP_EVNTBUS_5		IOMUX_PAD(0x758, 0x2f4, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TX_EN__FEC_TX_EN				IOMUX_PAD(0x75c, 0x2f8, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__SPDIF_SPDIF_IN1			IOMUX_PAD(0x75c, 0x2f8, 1, 0x998, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__UART3_RI				IOMUX_PAD(0x75c, 0x2f8, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__USB_TOP_USBH2_DATA_3		IOMUX_PAD(0x75c, 0x2f8, 3, 0x9d8, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__GPIO3_12				IOMUX_PAD(0x75c, 0x2f8, 5, 0x8f4, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__IPU_DISPB_PAR_RS			IOMUX_PAD(0x75c, 0x2f8, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_EN__ARM11P_TOP_EVNTBUS_6		IOMUX_PAD(0x75c, 0x2f8, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_MDC__FEC_MDC				IOMUX_PAD(0x760, 0x2fc, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__CAN2_TXCAN				IOMUX_PAD(0x760, 0x2fc, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__UART3_DCD				IOMUX_PAD(0x760, 0x2fc, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__USB_TOP_USBH2_DATA_4			IOMUX_PAD(0x760, 0x2fc, 3, 0x9dc, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__GPIO3_13				IOMUX_PAD(0x760, 0x2fc, 5, 0x8f8, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__IPU_DISPB_WR				IOMUX_PAD(0x760, 0x2fc, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDC__ARM11P_TOP_EVNTBUS_7			IOMUX_PAD(0x760, 0x2fc, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_MDIO__FEC_MDIO				IOMUX_PAD(0x764, 0x300, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDIO__CAN2_RXCAN				IOMUX_PAD(0x764, 0x300, 1, 0x7cc, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDIO__USB_TOP_USBH2_DATA_5			IOMUX_PAD(0x764, 0x300, 3, 0x9e0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDIO__GPIO3_14				IOMUX_PAD(0x764, 0x300, 5, 0x8fc, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDIO__IPU_DISPB_RD				IOMUX_PAD(0x764, 0x300, 6, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_MDIO__ARM11P_TOP_EVNTBUS_8			IOMUX_PAD(0x764, 0x300, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TX_ERR__FEC_TX_ERR				IOMUX_PAD(0x768, 0x304, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__OWIRE_LINE				IOMUX_PAD(0x768, 0x304, 1, 0x990, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__SPDIF_SPDIF_EXTCLK			IOMUX_PAD(0x768, 0x304, 2, 0x994, 4, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__USB_TOP_USBH2_DATA_6		IOMUX_PAD(0x768, 0x304, 3, 0x9e4, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__GPIO3_15				IOMUX_PAD(0x768, 0x304, 5, 0x900, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__IPU_DISPB_D0_VSYNC			IOMUX_PAD(0x768, 0x304, 6, 0x924, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TX_ERR__ARM11P_TOP_EVNTBUS_9		IOMUX_PAD(0x768, 0x304, 7, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RX_ERR__FEC_RX_ERR				IOMUX_PAD(0x76c, 0x308, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_ERR__IPU_CSI_D_0			IOMUX_PAD(0x76c, 0x308, 1, 0x930, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_ERR__USB_TOP_USBH2_DATA_7		IOMUX_PAD(0x76c, 0x308, 3, 0x9e8, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_ERR__KPP_COL_4				IOMUX_PAD(0x76c, 0x308, 4, 0x960, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_ERR__GPIO3_16				IOMUX_PAD(0x76c, 0x308, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RX_ERR__IPU_DISPB_SD_D_IO			IOMUX_PAD(0x76c, 0x308, 6, 0x92c, 5, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_CRS__FEC_CRS				IOMUX_PAD(0x770, 0x30c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_CRS__IPU_CSI_D_1				IOMUX_PAD(0x770, 0x30c, 1, 0x934, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_CRS__USB_TOP_USBH2_PWR			IOMUX_PAD(0x770, 0x30c, 3, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_CRS__KPP_COL_5				IOMUX_PAD(0x770, 0x30c, 4, 0x964, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_CRS__GPIO3_17				IOMUX_PAD(0x770, 0x30c, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_CRS__IPU_FLASH_STROBE			IOMUX_PAD(0x770, 0x30c, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RDATA1__FEC_RDATA_1			IOMUX_PAD(0x774, 0x310, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__IPU_CSI_D_2			IOMUX_PAD(0x774, 0x310, 1, 0x938, 4, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__AUDMUX_AUD6_RXC			IOMUX_PAD(0x774, 0x310, 2, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__USB_TOP_USBH2_OC			IOMUX_PAD(0x774, 0x310, 3, 0x9f4, 2, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__KPP_COL_6				IOMUX_PAD(0x774, 0x310, 4, 0x968, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__GPIO3_18				IOMUX_PAD(0x774, 0x310, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA1__IPU_DISPB_BE0			IOMUX_PAD(0x774, 0x310, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TDATA1__FEC_TDATA_1			IOMUX_PAD(0x778, 0x314, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA1__IPU_CSI_D_3			IOMUX_PAD(0x778, 0x314, 1, 0x93c, 4, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA1__AUDMUX_AUD6_RXFS			IOMUX_PAD(0x778, 0x314, 2, 0x7bc, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA1__KPP_COL_7				IOMUX_PAD(0x778, 0x314, 4, 0x96c, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA1__GPIO3_19				IOMUX_PAD(0x778, 0x314, 5, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA1__IPU_DISPB_BE1			IOMUX_PAD(0x778, 0x314, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RDATA2__FEC_RDATA_2			IOMUX_PAD(0x77c, 0x318, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA2__IPU_CSI_D_4			IOMUX_PAD(0x77c, 0x318, 1, 0x940, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA2__AUDMUX_AUD6_TXD			IOMUX_PAD(0x77c, 0x318, 2, 0x7b4, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA2__KPP_ROW_4				IOMUX_PAD(0x77c, 0x318, 4, 0x980, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA2__GPIO3_20				IOMUX_PAD(0x77c, 0x318, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TDATA2__FEC_TDATA_2			IOMUX_PAD(0x780, 0x31c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA2__IPU_CSI_D_5			IOMUX_PAD(0x780, 0x31c, 1, 0x944, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA2__AUDMUX_AUD6_RXD			IOMUX_PAD(0x780, 0x31c, 2, 0x7b0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA2__KPP_ROW_5				IOMUX_PAD(0x780, 0x31c, 4, 0x984, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA2__GPIO3_21				IOMUX_PAD(0x780, 0x31c, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_RDATA3__FEC_RDATA_3			IOMUX_PAD(0x784, 0x320, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA3__IPU_CSI_D_6			IOMUX_PAD(0x784, 0x320, 1, 0x948, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA3__AUDMUX_AUD6_TXC			IOMUX_PAD(0x784, 0x320, 2, 0x7c0, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA3__KPP_ROW_6				IOMUX_PAD(0x784, 0x320, 4, 0x988, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_RDATA3__GPIO3_22				IOMUX_PAD(0x784, 0x320, 6, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_FEC_TDATA3__FEC_TDATA_3			IOMUX_PAD(0x788, 0x324, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA3__IPU_CSI_D_7			IOMUX_PAD(0x788, 0x324, 1, 0x94c, 3, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA3__AUDMUX_AUD6_TXFS			IOMUX_PAD(0x788, 0x324, 2, 0x7c4, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA3__KPP_ROW_7				IOMUX_PAD(0x788, 0x324, 4, 0x98c, 1, NO_PAD_CTRL)
-#define MX35_PAD_FEC_TDATA3__GPIO3_23				IOMUX_PAD(0x788, 0x324, 5, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_EXT_ARMCLK__CCM_EXT_ARMCLK			IOMUX_PAD(0x78c, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-#define MX35_PAD_TEST_MODE__TCU_TEST_MODE			IOMUX_PAD(0x790, 0x0,   0, 0x0,   0, NO_PAD_CTRL)
-
-
-#endif /* __MACH_IOMUX_MX35_H__ */
diff -urN flo-ElementalX-5.00/arch/m32r/platforms/mappi2/setup.c flo-ElementalX-5.00-patched/arch/m32r/platforms/mappi2/setup.c
--- flo-ElementalX-5.00/arch/m32r/platforms/mappi2/setup.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/m32r/platforms/mappi2/setup.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,171 +0,0 @@
-/*
- *  linux/arch/m32r/platforms/mappi2/setup.c
- *
- *  Setup routines for Renesas MAPPI-II(M3A-ZA36) Board
- *
- *  Copyright (c) 2001-2005  Hiroyuki Kondo, Hirokazu Takata,
- *                           Hitoshi Yamamoto, Mamoru Sakugawa
- */
-
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-
-#include <asm/m32r.h>
-#include <asm/io.h>
-
-#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
-
-icu_data_t icu_data[NR_IRQS];
-
-static void disable_mappi2_irq(unsigned int irq)
-{
-	unsigned long port, data;
-
-	if ((irq == 0) ||(irq >= NR_IRQS))  {
-		printk("bad irq 0x%08x\n", irq);
-		return;
-	}
-	port = irq2port(irq);
-	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
-	outl(data, port);
-}
-
-static void enable_mappi2_irq(unsigned int irq)
-{
-	unsigned long port, data;
-
-	if ((irq == 0) ||(irq >= NR_IRQS))  {
-		printk("bad irq 0x%08x\n", irq);
-		return;
-	}
-	port = irq2port(irq);
-	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
-	outl(data, port);
-}
-
-static void mask_mappi2(struct irq_data *data)
-{
-	disable_mappi2_irq(data->irq);
-}
-
-static void unmask_mappi2(struct irq_data *data)
-{
-	enable_mappi2_irq(data->irq);
-}
-
-static void shutdown_mappi2(struct irq_data *data)
-{
-	unsigned long port;
-
-	port = irq2port(data->irq);
-	outl(M32R_ICUCR_ILEVEL7, port);
-}
-
-static struct irq_chip mappi2_irq_type =
-{
-	.name		= "MAPPI2-IRQ",
-	.irq_shutdown	= shutdown_mappi2,
-	.irq_mask	= mask_mappi2,
-	.irq_unmask	= unmask_mappi2,
-};
-
-void __init init_IRQ(void)
-{
-#if defined(CONFIG_SMC91X)
-	/* INT0 : LAN controller (SMC91111) */
-	irq_set_chip_and_handler(M32R_IRQ_INT0, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_INT0].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
-	disable_mappi2_irq(M32R_IRQ_INT0);
-#endif  /* CONFIG_SMC91X */
-
-	/* MFT2 : system timer */
-	irq_set_chip_and_handler(M32R_IRQ_MFT2, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
-	disable_mappi2_irq(M32R_IRQ_MFT2);
-
-#ifdef CONFIG_SERIAL_M32R_SIO
-	/* SIO0_R : uart receive data */
-	irq_set_chip_and_handler(M32R_IRQ_SIO0_R, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
-	disable_mappi2_irq(M32R_IRQ_SIO0_R);
-
-	/* SIO0_S : uart send data */
-	irq_set_chip_and_handler(M32R_IRQ_SIO0_S, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
-	disable_mappi2_irq(M32R_IRQ_SIO0_S);
-	/* SIO1_R : uart receive data */
-	irq_set_chip_and_handler(M32R_IRQ_SIO1_R, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
-	disable_mappi2_irq(M32R_IRQ_SIO1_R);
-
-	/* SIO1_S : uart send data */
-	irq_set_chip_and_handler(M32R_IRQ_SIO1_S, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
-	disable_mappi2_irq(M32R_IRQ_SIO1_S);
-#endif  /* CONFIG_M32R_USE_DBG_CONSOLE */
-
-#if defined(CONFIG_USB)
-	/* INT1 : USB Host controller interrupt */
-	irq_set_chip_and_handler(M32R_IRQ_INT1, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_ISMOD01;
-	disable_mappi2_irq(M32R_IRQ_INT1);
-#endif /* CONFIG_USB */
-
-	/* ICUCR40: CFC IREQ */
-	irq_set_chip_and_handler(PLD_IRQ_CFIREQ, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[PLD_IRQ_CFIREQ].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD01;
-	disable_mappi2_irq(PLD_IRQ_CFIREQ);
-
-#if defined(CONFIG_M32R_CFC)
-	/* ICUCR41: CFC Insert */
-	irq_set_chip_and_handler(PLD_IRQ_CFC_INSERT, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[PLD_IRQ_CFC_INSERT].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD00;
-	disable_mappi2_irq(PLD_IRQ_CFC_INSERT);
-
-	/* ICUCR42: CFC Eject */
-	irq_set_chip_and_handler(PLD_IRQ_CFC_EJECT, &mappi2_irq_type,
-				 handle_level_irq);
-	icu_data[PLD_IRQ_CFC_EJECT].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
-	disable_mappi2_irq(PLD_IRQ_CFC_EJECT);
-#endif /* CONFIG_MAPPI2_CFC */
-}
-
-#define LAN_IOSTART     0x300
-#define LAN_IOEND       0x320
-static struct resource smc91x_resources[] = {
-	[0] = {
-		.start  = (LAN_IOSTART),
-		.end    = (LAN_IOEND),
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = M32R_IRQ_INT0,
-		.end    = M32R_IRQ_INT0,
-		.flags  = IORESOURCE_IRQ,
-	}
-};
-
-static struct platform_device smc91x_device = {
-	.name		= "smc91x",
-	.id		= 0,
-	.num_resources  = ARRAY_SIZE(smc91x_resources),
-	.resource       = smc91x_resources,
-};
-
-static int __init platform_init(void)
-{
-	platform_device_register(&smc91x_device);
-	return 0;
-}
-arch_initcall(platform_init);
diff -urN flo-ElementalX-5.00/arch/mips/include/asm/mach-rc32434/timer.h flo-ElementalX-5.00-patched/arch/mips/include/asm/mach-rc32434/timer.h
--- flo-ElementalX-5.00/arch/mips/include/asm/mach-rc32434/timer.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/mips/include/asm/mach-rc32434/timer.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,65 +0,0 @@
-/*
- *  Definitions for timer registers
- *
- *  Copyright 2004 Philip Rischel <rischelp@idt.com>
- *  Copyright 2008 Florian Fainelli <florian@openwrt.org>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifndef __ASM_RC32434_TIMER_H
-#define __ASM_RC32434_TIMER_H
-
-#include <asm/mach-rc32434/rb.h>
-
-#define TIMER0_BASE_ADDR		0x18028000
-#define TIMER_COUNT			3
-
-struct timer_counter {
-	u32 count;
-	u32 compare;
-	u32 ctc;		/*use CTC_ */
-};
-
-struct timer {
-	struct timer_counter tim[TIMER_COUNT];
-	u32 rcount;	/* use RCOUNT_ */
-	u32 rcompare;	/* use RCOMPARE_ */
-	u32 rtc;	/* use RTC_ */
-};
-
-#define RC32434_CTC_EN_BIT		0
-#define RC32434_CTC_TO_BIT		1
-
-/* Real time clock registers */
-#define RC32434_RTC_MSK(x)              BIT_TO_MASK(x)
-#define RC32434_RTC_CE_BIT              0
-#define RC32434_RTC_TO_BIT              1
-#define RC32434_RTC_RQE_BIT             2
-
-/* Counter registers */
-#define RC32434_RCOUNT_BIT              0
-#define RC32434_RCOUNT_MSK              0x0000ffff
-#define RC32434_RCOMP_BIT               0
-#define RC32434_RCOMP_MSK               0x0000ffff
-
-#endif  /* __ASM_RC32434_TIMER_H */
diff -urN flo-ElementalX-5.00/arch/mips/include/asm/r4kcache.h flo-ElementalX-5.00-patched/arch/mips/include/asm/r4kcache.h
--- flo-ElementalX-5.00/arch/mips/include/asm/r4kcache.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/mips/include/asm/r4kcache.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,444 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Inline assembly cache operations.
- *
- * Copyright (C) 1996 David S. Miller (davem@davemloft.net)
- * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-#ifndef _ASM_R4KCACHE_H
-#define _ASM_R4KCACHE_H
-
-#include <asm/asm.h>
-#include <asm/cacheops.h>
-#include <asm/cpu-features.h>
-#include <asm/mipsmtregs.h>
-
-/*
- * This macro return a properly sign-extended address suitable as base address
- * for indexed cache operations.  Two issues here:
- *
- *  - The MIPS32 and MIPS64 specs permit an implementation to directly derive
- *    the index bits from the virtual address.  This breaks with tradition
- *    set by the R4000.  To keep unpleasant surprises from happening we pick
- *    an address in KSEG0 / CKSEG0.
- *  - We need a properly sign extended address for 64-bit code.  To get away
- *    without ifdefs we let the compiler do it by a type cast.
- */
-#define INDEX_BASE	CKSEG0
-
-#define cache_op(op,addr)						\
-	__asm__ __volatile__(						\
-	"	.set	push					\n"	\
-	"	.set	noreorder				\n"	\
-	"	.set	mips3\n\t				\n"	\
-	"	cache	%0, %1					\n"	\
-	"	.set	pop					\n"	\
-	:								\
-	: "i" (op), "R" (*(unsigned char *)(addr)))
-
-#ifdef CONFIG_MIPS_MT
-/*
- * Temporary hacks for SMTC debug. Optionally force single-threaded
- * execution during I-cache flushes.
- */
-
-#define PROTECT_CACHE_FLUSHES 1
-
-#ifdef PROTECT_CACHE_FLUSHES
-
-extern int mt_protiflush;
-extern int mt_protdflush;
-extern void mt_cflush_lockdown(void);
-extern void mt_cflush_release(void);
-
-#define BEGIN_MT_IPROT \
-	unsigned long flags = 0;			\
-	unsigned long mtflags = 0;			\
-	if(mt_protiflush) {				\
-		local_irq_save(flags);			\
-		ehb();					\
-		mtflags = dvpe();			\
-		mt_cflush_lockdown();			\
-	}
-
-#define END_MT_IPROT \
-	if(mt_protiflush) {				\
-		mt_cflush_release();			\
-		evpe(mtflags);				\
-		local_irq_restore(flags);		\
-	}
-
-#define BEGIN_MT_DPROT \
-	unsigned long flags = 0;			\
-	unsigned long mtflags = 0;			\
-	if(mt_protdflush) {				\
-		local_irq_save(flags);			\
-		ehb();					\
-		mtflags = dvpe();			\
-		mt_cflush_lockdown();			\
-	}
-
-#define END_MT_DPROT \
-	if(mt_protdflush) {				\
-		mt_cflush_release();			\
-		evpe(mtflags);				\
-		local_irq_restore(flags);		\
-	}
-
-#else
-
-#define BEGIN_MT_IPROT
-#define BEGIN_MT_DPROT
-#define END_MT_IPROT
-#define END_MT_DPROT
-
-#endif /* PROTECT_CACHE_FLUSHES */
-
-#define __iflush_prologue						\
-	unsigned long redundance;					\
-	extern int mt_n_iflushes;					\
-	BEGIN_MT_IPROT							\
-	for (redundance = 0; redundance < mt_n_iflushes; redundance++) {
-
-#define __iflush_epilogue						\
-	END_MT_IPROT							\
-	}
-
-#define __dflush_prologue						\
-	unsigned long redundance;					\
-	extern int mt_n_dflushes;					\
-	BEGIN_MT_DPROT							\
-	for (redundance = 0; redundance < mt_n_dflushes; redundance++) {
-
-#define __dflush_epilogue \
-	END_MT_DPROT	 \
-	}
-
-#define __inv_dflush_prologue __dflush_prologue
-#define __inv_dflush_epilogue __dflush_epilogue
-#define __sflush_prologue {
-#define __sflush_epilogue }
-#define __inv_sflush_prologue __sflush_prologue
-#define __inv_sflush_epilogue __sflush_epilogue
-
-#else /* CONFIG_MIPS_MT */
-
-#define __iflush_prologue {
-#define __iflush_epilogue }
-#define __dflush_prologue {
-#define __dflush_epilogue }
-#define __inv_dflush_prologue {
-#define __inv_dflush_epilogue }
-#define __sflush_prologue {
-#define __sflush_epilogue }
-#define __inv_sflush_prologue {
-#define __inv_sflush_epilogue }
-
-#endif /* CONFIG_MIPS_MT */
-
-static inline void flush_icache_line_indexed(unsigned long addr)
-{
-	__iflush_prologue
-	cache_op(Index_Invalidate_I, addr);
-	__iflush_epilogue
-}
-
-static inline void flush_dcache_line_indexed(unsigned long addr)
-{
-	__dflush_prologue
-	cache_op(Index_Writeback_Inv_D, addr);
-	__dflush_epilogue
-}
-
-static inline void flush_scache_line_indexed(unsigned long addr)
-{
-	cache_op(Index_Writeback_Inv_SD, addr);
-}
-
-static inline void flush_icache_line(unsigned long addr)
-{
-	__iflush_prologue
-	cache_op(Hit_Invalidate_I, addr);
-	__iflush_epilogue
-}
-
-static inline void flush_dcache_line(unsigned long addr)
-{
-	__dflush_prologue
-	cache_op(Hit_Writeback_Inv_D, addr);
-	__dflush_epilogue
-}
-
-static inline void invalidate_dcache_line(unsigned long addr)
-{
-	__dflush_prologue
-	cache_op(Hit_Invalidate_D, addr);
-	__dflush_epilogue
-}
-
-static inline void invalidate_scache_line(unsigned long addr)
-{
-	cache_op(Hit_Invalidate_SD, addr);
-}
-
-static inline void flush_scache_line(unsigned long addr)
-{
-	cache_op(Hit_Writeback_Inv_SD, addr);
-}
-
-#define protected_cache_op(op,addr)				\
-	__asm__ __volatile__(					\
-	"	.set	push			\n"		\
-	"	.set	noreorder		\n"		\
-	"	.set	mips3			\n"		\
-	"1:	cache	%0, (%1)		\n"		\
-	"2:	.set	pop			\n"		\
-	"	.section __ex_table,\"a\"	\n"		\
-	"	"STR(PTR)" 1b, 2b		\n"		\
-	"	.previous"					\
-	:							\
-	: "i" (op), "r" (addr))
-
-/*
- * The next two are for badland addresses like signal trampolines.
- */
-static inline void protected_flush_icache_line(unsigned long addr)
-{
-	protected_cache_op(Hit_Invalidate_I, addr);
-}
-
-/*
- * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
- * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
- * caches.  We're talking about one cacheline unnecessarily getting invalidated
- * here so the penalty isn't overly hard.
- */
-static inline void protected_writeback_dcache_line(unsigned long addr)
-{
-	protected_cache_op(Hit_Writeback_Inv_D, addr);
-}
-
-static inline void protected_writeback_scache_line(unsigned long addr)
-{
-	protected_cache_op(Hit_Writeback_Inv_SD, addr);
-}
-
-/*
- * This one is RM7000-specific
- */
-static inline void invalidate_tcache_page(unsigned long addr)
-{
-	cache_op(Page_Invalidate_T, addr);
-}
-
-#define cache16_unroll32(base,op)					\
-	__asm__ __volatile__(						\
-	"	.set push					\n"	\
-	"	.set noreorder					\n"	\
-	"	.set mips3					\n"	\
-	"	cache %1, 0x000(%0); cache %1, 0x010(%0)	\n"	\
-	"	cache %1, 0x020(%0); cache %1, 0x030(%0)	\n"	\
-	"	cache %1, 0x040(%0); cache %1, 0x050(%0)	\n"	\
-	"	cache %1, 0x060(%0); cache %1, 0x070(%0)	\n"	\
-	"	cache %1, 0x080(%0); cache %1, 0x090(%0)	\n"	\
-	"	cache %1, 0x0a0(%0); cache %1, 0x0b0(%0)	\n"	\
-	"	cache %1, 0x0c0(%0); cache %1, 0x0d0(%0)	\n"	\
-	"	cache %1, 0x0e0(%0); cache %1, 0x0f0(%0)	\n"	\
-	"	cache %1, 0x100(%0); cache %1, 0x110(%0)	\n"	\
-	"	cache %1, 0x120(%0); cache %1, 0x130(%0)	\n"	\
-	"	cache %1, 0x140(%0); cache %1, 0x150(%0)	\n"	\
-	"	cache %1, 0x160(%0); cache %1, 0x170(%0)	\n"	\
-	"	cache %1, 0x180(%0); cache %1, 0x190(%0)	\n"	\
-	"	cache %1, 0x1a0(%0); cache %1, 0x1b0(%0)	\n"	\
-	"	cache %1, 0x1c0(%0); cache %1, 0x1d0(%0)	\n"	\
-	"	cache %1, 0x1e0(%0); cache %1, 0x1f0(%0)	\n"	\
-	"	.set pop					\n"	\
-		:							\
-		: "r" (base),						\
-		  "i" (op));
-
-#define cache32_unroll32(base,op)					\
-	__asm__ __volatile__(						\
-	"	.set push					\n"	\
-	"	.set noreorder					\n"	\
-	"	.set mips3					\n"	\
-	"	cache %1, 0x000(%0); cache %1, 0x020(%0)	\n"	\
-	"	cache %1, 0x040(%0); cache %1, 0x060(%0)	\n"	\
-	"	cache %1, 0x080(%0); cache %1, 0x0a0(%0)	\n"	\
-	"	cache %1, 0x0c0(%0); cache %1, 0x0e0(%0)	\n"	\
-	"	cache %1, 0x100(%0); cache %1, 0x120(%0)	\n"	\
-	"	cache %1, 0x140(%0); cache %1, 0x160(%0)	\n"	\
-	"	cache %1, 0x180(%0); cache %1, 0x1a0(%0)	\n"	\
-	"	cache %1, 0x1c0(%0); cache %1, 0x1e0(%0)	\n"	\
-	"	cache %1, 0x200(%0); cache %1, 0x220(%0)	\n"	\
-	"	cache %1, 0x240(%0); cache %1, 0x260(%0)	\n"	\
-	"	cache %1, 0x280(%0); cache %1, 0x2a0(%0)	\n"	\
-	"	cache %1, 0x2c0(%0); cache %1, 0x2e0(%0)	\n"	\
-	"	cache %1, 0x300(%0); cache %1, 0x320(%0)	\n"	\
-	"	cache %1, 0x340(%0); cache %1, 0x360(%0)	\n"	\
-	"	cache %1, 0x380(%0); cache %1, 0x3a0(%0)	\n"	\
-	"	cache %1, 0x3c0(%0); cache %1, 0x3e0(%0)	\n"	\
-	"	.set pop					\n"	\
-		:							\
-		: "r" (base),						\
-		  "i" (op));
-
-#define cache64_unroll32(base,op)					\
-	__asm__ __volatile__(						\
-	"	.set push					\n"	\
-	"	.set noreorder					\n"	\
-	"	.set mips3					\n"	\
-	"	cache %1, 0x000(%0); cache %1, 0x040(%0)	\n"	\
-	"	cache %1, 0x080(%0); cache %1, 0x0c0(%0)	\n"	\
-	"	cache %1, 0x100(%0); cache %1, 0x140(%0)	\n"	\
-	"	cache %1, 0x180(%0); cache %1, 0x1c0(%0)	\n"	\
-	"	cache %1, 0x200(%0); cache %1, 0x240(%0)	\n"	\
-	"	cache %1, 0x280(%0); cache %1, 0x2c0(%0)	\n"	\
-	"	cache %1, 0x300(%0); cache %1, 0x340(%0)	\n"	\
-	"	cache %1, 0x380(%0); cache %1, 0x3c0(%0)	\n"	\
-	"	cache %1, 0x400(%0); cache %1, 0x440(%0)	\n"	\
-	"	cache %1, 0x480(%0); cache %1, 0x4c0(%0)	\n"	\
-	"	cache %1, 0x500(%0); cache %1, 0x540(%0)	\n"	\
-	"	cache %1, 0x580(%0); cache %1, 0x5c0(%0)	\n"	\
-	"	cache %1, 0x600(%0); cache %1, 0x640(%0)	\n"	\
-	"	cache %1, 0x680(%0); cache %1, 0x6c0(%0)	\n"	\
-	"	cache %1, 0x700(%0); cache %1, 0x740(%0)	\n"	\
-	"	cache %1, 0x780(%0); cache %1, 0x7c0(%0)	\n"	\
-	"	.set pop					\n"	\
-		:							\
-		: "r" (base),						\
-		  "i" (op));
-
-#define cache128_unroll32(base,op)					\
-	__asm__ __volatile__(						\
-	"	.set push					\n"	\
-	"	.set noreorder					\n"	\
-	"	.set mips3					\n"	\
-	"	cache %1, 0x000(%0); cache %1, 0x080(%0)	\n"	\
-	"	cache %1, 0x100(%0); cache %1, 0x180(%0)	\n"	\
-	"	cache %1, 0x200(%0); cache %1, 0x280(%0)	\n"	\
-	"	cache %1, 0x300(%0); cache %1, 0x380(%0)	\n"	\
-	"	cache %1, 0x400(%0); cache %1, 0x480(%0)	\n"	\
-	"	cache %1, 0x500(%0); cache %1, 0x580(%0)	\n"	\
-	"	cache %1, 0x600(%0); cache %1, 0x680(%0)	\n"	\
-	"	cache %1, 0x700(%0); cache %1, 0x780(%0)	\n"	\
-	"	cache %1, 0x800(%0); cache %1, 0x880(%0)	\n"	\
-	"	cache %1, 0x900(%0); cache %1, 0x980(%0)	\n"	\
-	"	cache %1, 0xa00(%0); cache %1, 0xa80(%0)	\n"	\
-	"	cache %1, 0xb00(%0); cache %1, 0xb80(%0)	\n"	\
-	"	cache %1, 0xc00(%0); cache %1, 0xc80(%0)	\n"	\
-	"	cache %1, 0xd00(%0); cache %1, 0xd80(%0)	\n"	\
-	"	cache %1, 0xe00(%0); cache %1, 0xe80(%0)	\n"	\
-	"	cache %1, 0xf00(%0); cache %1, 0xf80(%0)	\n"	\
-	"	.set pop					\n"	\
-		:							\
-		: "r" (base),						\
-		  "i" (op));
-
-/* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
-#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
-static inline void blast_##pfx##cache##lsize(void)			\
-{									\
-	unsigned long start = INDEX_BASE;				\
-	unsigned long end = start + current_cpu_data.desc.waysize;	\
-	unsigned long ws_inc = 1UL << current_cpu_data.desc.waybit;	\
-	unsigned long ws_end = current_cpu_data.desc.ways <<		\
-	                       current_cpu_data.desc.waybit;		\
-	unsigned long ws, addr;						\
-									\
-	__##pfx##flush_prologue						\
-									\
-	for (ws = 0; ws < ws_end; ws += ws_inc)				\
-		for (addr = start; addr < end; addr += lsize * 32)	\
-			cache##lsize##_unroll32(addr|ws, indexop);	\
-									\
-	__##pfx##flush_epilogue						\
-}									\
-									\
-static inline void blast_##pfx##cache##lsize##_page(unsigned long page)	\
-{									\
-	unsigned long start = page;					\
-	unsigned long end = page + PAGE_SIZE;				\
-									\
-	__##pfx##flush_prologue						\
-									\
-	do {								\
-		cache##lsize##_unroll32(start, hitop);			\
-		start += lsize * 32;					\
-	} while (start < end);						\
-									\
-	__##pfx##flush_epilogue						\
-}									\
-									\
-static inline void blast_##pfx##cache##lsize##_page_indexed(unsigned long page) \
-{									\
-	unsigned long indexmask = current_cpu_data.desc.waysize - 1;	\
-	unsigned long start = INDEX_BASE + (page & indexmask);		\
-	unsigned long end = start + PAGE_SIZE;				\
-	unsigned long ws_inc = 1UL << current_cpu_data.desc.waybit;	\
-	unsigned long ws_end = current_cpu_data.desc.ways <<		\
-	                       current_cpu_data.desc.waybit;		\
-	unsigned long ws, addr;						\
-									\
-	__##pfx##flush_prologue						\
-									\
-	for (ws = 0; ws < ws_end; ws += ws_inc)				\
-		for (addr = start; addr < end; addr += lsize * 32)	\
-			cache##lsize##_unroll32(addr|ws, indexop);	\
-									\
-	__##pfx##flush_epilogue						\
-}
-
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
-
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16)
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
-
-/* build blast_xxx_range, protected_blast_xxx_range */
-#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
-static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
-						    unsigned long end)	\
-{									\
-	unsigned long lsize = cpu_##desc##_line_size();			\
-	unsigned long addr = start & ~(lsize - 1);			\
-	unsigned long aend = (end - 1) & ~(lsize - 1);			\
-									\
-	__##pfx##flush_prologue						\
-									\
-	while (1) {							\
-		prot##cache_op(hitop, addr);				\
-		if (addr == aend)					\
-			break;						\
-		addr += lsize;						\
-	}								\
-									\
-	__##pfx##flush_epilogue						\
-}
-
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
-__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
-/* blast_inv_dcache_range */
-__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
-__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
-
-#endif /* _ASM_R4KCACHE_H */
diff -urN flo-ElementalX-5.00/arch/mips/kernel/asm-offsets.c flo-ElementalX-5.00-patched/arch/mips/kernel/asm-offsets.c
--- flo-ElementalX-5.00/arch/mips/kernel/asm-offsets.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/mips/kernel/asm-offsets.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,341 +0,0 @@
-/*
- * offset.c: Calculate pt_regs and task_struct offsets.
- *
- * Copyright (C) 1996 David S. Miller
- * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Ralf Baechle
- * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
- *
- * Kevin Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.
- */
-#include <linux/compat.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/kbuild.h>
-#include <linux/suspend.h>
-#include <asm/ptrace.h>
-#include <asm/processor.h>
-
-void output_ptreg_defines(void)
-{
-	COMMENT("MIPS pt_regs offsets.");
-	OFFSET(PT_R0, pt_regs, regs[0]);
-	OFFSET(PT_R1, pt_regs, regs[1]);
-	OFFSET(PT_R2, pt_regs, regs[2]);
-	OFFSET(PT_R3, pt_regs, regs[3]);
-	OFFSET(PT_R4, pt_regs, regs[4]);
-	OFFSET(PT_R5, pt_regs, regs[5]);
-	OFFSET(PT_R6, pt_regs, regs[6]);
-	OFFSET(PT_R7, pt_regs, regs[7]);
-	OFFSET(PT_R8, pt_regs, regs[8]);
-	OFFSET(PT_R9, pt_regs, regs[9]);
-	OFFSET(PT_R10, pt_regs, regs[10]);
-	OFFSET(PT_R11, pt_regs, regs[11]);
-	OFFSET(PT_R12, pt_regs, regs[12]);
-	OFFSET(PT_R13, pt_regs, regs[13]);
-	OFFSET(PT_R14, pt_regs, regs[14]);
-	OFFSET(PT_R15, pt_regs, regs[15]);
-	OFFSET(PT_R16, pt_regs, regs[16]);
-	OFFSET(PT_R17, pt_regs, regs[17]);
-	OFFSET(PT_R18, pt_regs, regs[18]);
-	OFFSET(PT_R19, pt_regs, regs[19]);
-	OFFSET(PT_R20, pt_regs, regs[20]);
-	OFFSET(PT_R21, pt_regs, regs[21]);
-	OFFSET(PT_R22, pt_regs, regs[22]);
-	OFFSET(PT_R23, pt_regs, regs[23]);
-	OFFSET(PT_R24, pt_regs, regs[24]);
-	OFFSET(PT_R25, pt_regs, regs[25]);
-	OFFSET(PT_R26, pt_regs, regs[26]);
-	OFFSET(PT_R27, pt_regs, regs[27]);
-	OFFSET(PT_R28, pt_regs, regs[28]);
-	OFFSET(PT_R29, pt_regs, regs[29]);
-	OFFSET(PT_R30, pt_regs, regs[30]);
-	OFFSET(PT_R31, pt_regs, regs[31]);
-	OFFSET(PT_LO, pt_regs, lo);
-	OFFSET(PT_HI, pt_regs, hi);
-#ifdef CONFIG_CPU_HAS_SMARTMIPS
-	OFFSET(PT_ACX, pt_regs, acx);
-#endif
-	OFFSET(PT_EPC, pt_regs, cp0_epc);
-	OFFSET(PT_BVADDR, pt_regs, cp0_badvaddr);
-	OFFSET(PT_STATUS, pt_regs, cp0_status);
-	OFFSET(PT_CAUSE, pt_regs, cp0_cause);
-#ifdef CONFIG_MIPS_MT_SMTC
-	OFFSET(PT_TCSTATUS, pt_regs, cp0_tcstatus);
-#endif /* CONFIG_MIPS_MT_SMTC */
-#ifdef CONFIG_CPU_CAVIUM_OCTEON
-	OFFSET(PT_MPL, pt_regs, mpl);
-	OFFSET(PT_MTP, pt_regs, mtp);
-#endif /* CONFIG_CPU_CAVIUM_OCTEON */
-	DEFINE(PT_SIZE, sizeof(struct pt_regs));
-	BLANK();
-}
-
-void output_task_defines(void)
-{
-	COMMENT("MIPS task_struct offsets.");
-	OFFSET(TASK_STATE, task_struct, state);
-	OFFSET(TASK_THREAD_INFO, task_struct, stack);
-	OFFSET(TASK_FLAGS, task_struct, flags);
-	OFFSET(TASK_MM, task_struct, mm);
-	OFFSET(TASK_PID, task_struct, pid);
-	DEFINE(TASK_STRUCT_SIZE, sizeof(struct task_struct));
-	BLANK();
-}
-
-void output_thread_info_defines(void)
-{
-	COMMENT("MIPS thread_info offsets.");
-	OFFSET(TI_TASK, thread_info, task);
-	OFFSET(TI_EXEC_DOMAIN, thread_info, exec_domain);
-	OFFSET(TI_FLAGS, thread_info, flags);
-	OFFSET(TI_TP_VALUE, thread_info, tp_value);
-	OFFSET(TI_CPU, thread_info, cpu);
-	OFFSET(TI_PRE_COUNT, thread_info, preempt_count);
-	OFFSET(TI_ADDR_LIMIT, thread_info, addr_limit);
-	OFFSET(TI_RESTART_BLOCK, thread_info, restart_block);
-	OFFSET(TI_REGS, thread_info, regs);
-	DEFINE(_THREAD_SIZE, THREAD_SIZE);
-	DEFINE(_THREAD_MASK, THREAD_MASK);
-	BLANK();
-}
-
-void output_thread_defines(void)
-{
-	COMMENT("MIPS specific thread_struct offsets.");
-	OFFSET(THREAD_REG16, task_struct, thread.reg16);
-	OFFSET(THREAD_REG17, task_struct, thread.reg17);
-	OFFSET(THREAD_REG18, task_struct, thread.reg18);
-	OFFSET(THREAD_REG19, task_struct, thread.reg19);
-	OFFSET(THREAD_REG20, task_struct, thread.reg20);
-	OFFSET(THREAD_REG21, task_struct, thread.reg21);
-	OFFSET(THREAD_REG22, task_struct, thread.reg22);
-	OFFSET(THREAD_REG23, task_struct, thread.reg23);
-	OFFSET(THREAD_REG29, task_struct, thread.reg29);
-	OFFSET(THREAD_REG30, task_struct, thread.reg30);
-	OFFSET(THREAD_REG31, task_struct, thread.reg31);
-	OFFSET(THREAD_STATUS, task_struct,
-	       thread.cp0_status);
-	OFFSET(THREAD_FPU, task_struct, thread.fpu);
-
-	OFFSET(THREAD_BVADDR, task_struct, \
-	       thread.cp0_badvaddr);
-	OFFSET(THREAD_BUADDR, task_struct, \
-	       thread.cp0_baduaddr);
-	OFFSET(THREAD_ECODE, task_struct, \
-	       thread.error_code);
-	OFFSET(THREAD_TRAMP, task_struct, \
-	       thread.irix_trampoline);
-	OFFSET(THREAD_OLDCTX, task_struct, \
-	       thread.irix_oldctx);
-	BLANK();
-}
-
-void output_thread_fpu_defines(void)
-{
-	OFFSET(THREAD_FPR0, task_struct, thread.fpu.fpr[0]);
-	OFFSET(THREAD_FPR1, task_struct, thread.fpu.fpr[1]);
-	OFFSET(THREAD_FPR2, task_struct, thread.fpu.fpr[2]);
-	OFFSET(THREAD_FPR3, task_struct, thread.fpu.fpr[3]);
-	OFFSET(THREAD_FPR4, task_struct, thread.fpu.fpr[4]);
-	OFFSET(THREAD_FPR5, task_struct, thread.fpu.fpr[5]);
-	OFFSET(THREAD_FPR6, task_struct, thread.fpu.fpr[6]);
-	OFFSET(THREAD_FPR7, task_struct, thread.fpu.fpr[7]);
-	OFFSET(THREAD_FPR8, task_struct, thread.fpu.fpr[8]);
-	OFFSET(THREAD_FPR9, task_struct, thread.fpu.fpr[9]);
-	OFFSET(THREAD_FPR10, task_struct, thread.fpu.fpr[10]);
-	OFFSET(THREAD_FPR11, task_struct, thread.fpu.fpr[11]);
-	OFFSET(THREAD_FPR12, task_struct, thread.fpu.fpr[12]);
-	OFFSET(THREAD_FPR13, task_struct, thread.fpu.fpr[13]);
-	OFFSET(THREAD_FPR14, task_struct, thread.fpu.fpr[14]);
-	OFFSET(THREAD_FPR15, task_struct, thread.fpu.fpr[15]);
-	OFFSET(THREAD_FPR16, task_struct, thread.fpu.fpr[16]);
-	OFFSET(THREAD_FPR17, task_struct, thread.fpu.fpr[17]);
-	OFFSET(THREAD_FPR18, task_struct, thread.fpu.fpr[18]);
-	OFFSET(THREAD_FPR19, task_struct, thread.fpu.fpr[19]);
-	OFFSET(THREAD_FPR20, task_struct, thread.fpu.fpr[20]);
-	OFFSET(THREAD_FPR21, task_struct, thread.fpu.fpr[21]);
-	OFFSET(THREAD_FPR22, task_struct, thread.fpu.fpr[22]);
-	OFFSET(THREAD_FPR23, task_struct, thread.fpu.fpr[23]);
-	OFFSET(THREAD_FPR24, task_struct, thread.fpu.fpr[24]);
-	OFFSET(THREAD_FPR25, task_struct, thread.fpu.fpr[25]);
-	OFFSET(THREAD_FPR26, task_struct, thread.fpu.fpr[26]);
-	OFFSET(THREAD_FPR27, task_struct, thread.fpu.fpr[27]);
-	OFFSET(THREAD_FPR28, task_struct, thread.fpu.fpr[28]);
-	OFFSET(THREAD_FPR29, task_struct, thread.fpu.fpr[29]);
-	OFFSET(THREAD_FPR30, task_struct, thread.fpu.fpr[30]);
-	OFFSET(THREAD_FPR31, task_struct, thread.fpu.fpr[31]);
-
-	OFFSET(THREAD_FCR31, task_struct, thread.fpu.fcr31);
-	BLANK();
-}
-
-void output_mm_defines(void)
-{
-	COMMENT("Size of struct page");
-	DEFINE(STRUCT_PAGE_SIZE, sizeof(struct page));
-	BLANK();
-	COMMENT("Linux mm_struct offsets.");
-	OFFSET(MM_USERS, mm_struct, mm_users);
-	OFFSET(MM_PGD, mm_struct, pgd);
-	OFFSET(MM_CONTEXT, mm_struct, context);
-	BLANK();
-	DEFINE(_PGD_T_SIZE, sizeof(pgd_t));
-	DEFINE(_PMD_T_SIZE, sizeof(pmd_t));
-	DEFINE(_PTE_T_SIZE, sizeof(pte_t));
-	BLANK();
-	DEFINE(_PGD_T_LOG2, PGD_T_LOG2);
-#ifndef __PAGETABLE_PMD_FOLDED
-	DEFINE(_PMD_T_LOG2, PMD_T_LOG2);
-#endif
-	DEFINE(_PTE_T_LOG2, PTE_T_LOG2);
-	BLANK();
-	DEFINE(_PGD_ORDER, PGD_ORDER);
-#ifndef __PAGETABLE_PMD_FOLDED
-	DEFINE(_PMD_ORDER, PMD_ORDER);
-#endif
-	DEFINE(_PTE_ORDER, PTE_ORDER);
-	BLANK();
-	DEFINE(_PMD_SHIFT, PMD_SHIFT);
-	DEFINE(_PGDIR_SHIFT, PGDIR_SHIFT);
-	BLANK();
-	DEFINE(_PTRS_PER_PGD, PTRS_PER_PGD);
-	DEFINE(_PTRS_PER_PMD, PTRS_PER_PMD);
-	DEFINE(_PTRS_PER_PTE, PTRS_PER_PTE);
-	BLANK();
-}
-
-#ifdef CONFIG_32BIT
-void output_sc_defines(void)
-{
-	COMMENT("Linux sigcontext offsets.");
-	OFFSET(SC_REGS, sigcontext, sc_regs);
-	OFFSET(SC_FPREGS, sigcontext, sc_fpregs);
-	OFFSET(SC_ACX, sigcontext, sc_acx);
-	OFFSET(SC_MDHI, sigcontext, sc_mdhi);
-	OFFSET(SC_MDLO, sigcontext, sc_mdlo);
-	OFFSET(SC_PC, sigcontext, sc_pc);
-	OFFSET(SC_FPC_CSR, sigcontext, sc_fpc_csr);
-	OFFSET(SC_FPC_EIR, sigcontext, sc_fpc_eir);
-	OFFSET(SC_HI1, sigcontext, sc_hi1);
-	OFFSET(SC_LO1, sigcontext, sc_lo1);
-	OFFSET(SC_HI2, sigcontext, sc_hi2);
-	OFFSET(SC_LO2, sigcontext, sc_lo2);
-	OFFSET(SC_HI3, sigcontext, sc_hi3);
-	OFFSET(SC_LO3, sigcontext, sc_lo3);
-	BLANK();
-}
-#endif
-
-#ifdef CONFIG_64BIT
-void output_sc_defines(void)
-{
-	COMMENT("Linux sigcontext offsets.");
-	OFFSET(SC_REGS, sigcontext, sc_regs);
-	OFFSET(SC_FPREGS, sigcontext, sc_fpregs);
-	OFFSET(SC_MDHI, sigcontext, sc_mdhi);
-	OFFSET(SC_MDLO, sigcontext, sc_mdlo);
-	OFFSET(SC_PC, sigcontext, sc_pc);
-	OFFSET(SC_FPC_CSR, sigcontext, sc_fpc_csr);
-	BLANK();
-}
-#endif
-
-#ifdef CONFIG_MIPS32_COMPAT
-void output_sc32_defines(void)
-{
-	COMMENT("Linux 32-bit sigcontext offsets.");
-	OFFSET(SC32_FPREGS, sigcontext32, sc_fpregs);
-	OFFSET(SC32_FPC_CSR, sigcontext32, sc_fpc_csr);
-	OFFSET(SC32_FPC_EIR, sigcontext32, sc_fpc_eir);
-	BLANK();
-}
-#endif
-
-void output_signal_defined(void)
-{
-	COMMENT("Linux signal numbers.");
-	DEFINE(_SIGHUP, SIGHUP);
-	DEFINE(_SIGINT, SIGINT);
-	DEFINE(_SIGQUIT, SIGQUIT);
-	DEFINE(_SIGILL, SIGILL);
-	DEFINE(_SIGTRAP, SIGTRAP);
-	DEFINE(_SIGIOT, SIGIOT);
-	DEFINE(_SIGABRT, SIGABRT);
-	DEFINE(_SIGEMT, SIGEMT);
-	DEFINE(_SIGFPE, SIGFPE);
-	DEFINE(_SIGKILL, SIGKILL);
-	DEFINE(_SIGBUS, SIGBUS);
-	DEFINE(_SIGSEGV, SIGSEGV);
-	DEFINE(_SIGSYS, SIGSYS);
-	DEFINE(_SIGPIPE, SIGPIPE);
-	DEFINE(_SIGALRM, SIGALRM);
-	DEFINE(_SIGTERM, SIGTERM);
-	DEFINE(_SIGUSR1, SIGUSR1);
-	DEFINE(_SIGUSR2, SIGUSR2);
-	DEFINE(_SIGCHLD, SIGCHLD);
-	DEFINE(_SIGPWR, SIGPWR);
-	DEFINE(_SIGWINCH, SIGWINCH);
-	DEFINE(_SIGURG, SIGURG);
-	DEFINE(_SIGIO, SIGIO);
-	DEFINE(_SIGSTOP, SIGSTOP);
-	DEFINE(_SIGTSTP, SIGTSTP);
-	DEFINE(_SIGCONT, SIGCONT);
-	DEFINE(_SIGTTIN, SIGTTIN);
-	DEFINE(_SIGTTOU, SIGTTOU);
-	DEFINE(_SIGVTALRM, SIGVTALRM);
-	DEFINE(_SIGPROF, SIGPROF);
-	DEFINE(_SIGXCPU, SIGXCPU);
-	DEFINE(_SIGXFSZ, SIGXFSZ);
-	BLANK();
-}
-
-void output_irq_cpustat_t_defines(void)
-{
-	COMMENT("Linux irq_cpustat_t offsets.");
-	DEFINE(IC_SOFTIRQ_PENDING,
-			offsetof(irq_cpustat_t, __softirq_pending));
-	DEFINE(IC_IRQ_CPUSTAT_T, sizeof(irq_cpustat_t));
-	BLANK();
-}
-
-#ifdef CONFIG_CPU_CAVIUM_OCTEON
-void output_octeon_cop2_state_defines(void)
-{
-	COMMENT("Octeon specific octeon_cop2_state offsets.");
-	OFFSET(OCTEON_CP2_CRC_IV,	octeon_cop2_state, cop2_crc_iv);
-	OFFSET(OCTEON_CP2_CRC_LENGTH,	octeon_cop2_state, cop2_crc_length);
-	OFFSET(OCTEON_CP2_CRC_POLY,	octeon_cop2_state, cop2_crc_poly);
-	OFFSET(OCTEON_CP2_LLM_DAT,	octeon_cop2_state, cop2_llm_dat);
-	OFFSET(OCTEON_CP2_3DES_IV,	octeon_cop2_state, cop2_3des_iv);
-	OFFSET(OCTEON_CP2_3DES_KEY,	octeon_cop2_state, cop2_3des_key);
-	OFFSET(OCTEON_CP2_3DES_RESULT,	octeon_cop2_state, cop2_3des_result);
-	OFFSET(OCTEON_CP2_AES_INP0,	octeon_cop2_state, cop2_aes_inp0);
-	OFFSET(OCTEON_CP2_AES_IV,	octeon_cop2_state, cop2_aes_iv);
-	OFFSET(OCTEON_CP2_AES_KEY,	octeon_cop2_state, cop2_aes_key);
-	OFFSET(OCTEON_CP2_AES_KEYLEN,	octeon_cop2_state, cop2_aes_keylen);
-	OFFSET(OCTEON_CP2_AES_RESULT,	octeon_cop2_state, cop2_aes_result);
-	OFFSET(OCTEON_CP2_GFM_MULT,	octeon_cop2_state, cop2_gfm_mult);
-	OFFSET(OCTEON_CP2_GFM_POLY,	octeon_cop2_state, cop2_gfm_poly);
-	OFFSET(OCTEON_CP2_GFM_RESULT,	octeon_cop2_state, cop2_gfm_result);
-	OFFSET(OCTEON_CP2_HSH_DATW,	octeon_cop2_state, cop2_hsh_datw);
-	OFFSET(OCTEON_CP2_HSH_IVW,	octeon_cop2_state, cop2_hsh_ivw);
-	OFFSET(THREAD_CP2,	task_struct, thread.cp2);
-	OFFSET(THREAD_CVMSEG,	task_struct, thread.cvmseg.cvmseg);
-	BLANK();
-}
-#endif
-
-#ifdef CONFIG_HIBERNATION
-void output_pbe_defines(void)
-{
-	COMMENT(" Linux struct pbe offsets. ");
-	OFFSET(PBE_ADDRESS, pbe, address);
-	OFFSET(PBE_ORIG_ADDRESS, pbe, orig_address);
-	OFFSET(PBE_NEXT, pbe, next);
-	DEFINE(PBE_SIZE, sizeof(struct pbe));
-	BLANK();
-}
-#endif
diff -urN flo-ElementalX-5.00/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h flo-ElementalX-5.00-patched/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h
--- flo-ElementalX-5.00/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,67 +0,0 @@
-/*
- *  arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.c
- *
- *  Copyright (C) 2003 PMC-Sierra Inc.
- *  Author: Manish Lachwani (lachwani@pmc-sierra.com)
- *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * Header file for atmel_read_eeprom.c
- */
-
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <asm/pci.h>
-#include <asm/io.h>
-#include <linux/init.h>
-#include <asm/termios.h>
-#include <asm/ioctls.h>
-#include <linux/ioctl.h>
-#include <linux/fcntl.h>
-
-#define	DEFAULT_PORT 	"/dev/ttyS0"	/* Port to open */
-#define	TXX		0 		/* Dummy loop for spinning */
-
-#define	BLOCK_SEL	0x00
-#define	SLAVE_ADDR	0xa0
-#define	READ_BIT	0x01
-#define	WRITE_BIT	0x00
-#define	R_HEADER	SLAVE_ADDR + BLOCK_SEL + READ_BIT
-#define	W_HEADER	SLAVE_ADDR + BLOCK_SEL + WRITE_BIT
-
-/*
- * Clock, Voltages and Data
- */
-#define	vcc_off		(ioctl(fd, TIOCSBRK, 0))
-#define	vcc_on		(ioctl(fd, TIOCCBRK, 0))
-#define	sda_hi		(ioctl(fd, TIOCMBIS, &dtr))
-#define	sda_lo		(ioctl(fd, TIOCMBIC, &dtr))
-#define	scl_lo		(ioctl(fd, TIOCMBIC, &rts))
-#define	scl_hi		(ioctl(fd, TIOCMBIS, &rts))
-
-const char rts = TIOCM_RTS;
-const char dtr = TIOCM_DTR;
-int fd;
diff -urN flo-ElementalX-5.00/arch/mn10300/mm/extable.c flo-ElementalX-5.00-patched/arch/mn10300/mm/extable.c
--- flo-ElementalX-5.00/arch/mn10300/mm/extable.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/mn10300/mm/extable.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,26 +0,0 @@
-/* MN10300 In-kernel exception handling
- *
- * Copyright (C) 2007 Matsushita Electric Industrial Co., Ltd.
- * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
- */
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <asm/uaccess.h>
-
-int fixup_exception(struct pt_regs *regs)
-{
-	const struct exception_table_entry *fixup;
-
-	fixup = search_exception_tables(regs->pc);
-	if (fixup) {
-		regs->pc = fixup->fixup;
-		return 1;
-	}
-
-	return 0;
-}
diff -urN flo-ElementalX-5.00/arch/powerpc/boot/dts/acadia.dts flo-ElementalX-5.00-patched/arch/powerpc/boot/dts/acadia.dts
--- flo-ElementalX-5.00/arch/powerpc/boot/dts/acadia.dts	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/powerpc/boot/dts/acadia.dts	2016-05-10 02:52:00.000000000 +0000
@@ -1,224 +0,0 @@
-/*
- * Device Tree Source for AMCC Acadia (405EZ)
- *
- * Copyright IBM Corp. 2008
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-/dts-v1/;
-
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	model = "amcc,acadia";
-	compatible = "amcc,acadia";
-	dcr-parent = <&{/cpus/cpu@0}>;
-
-	aliases {
-		ethernet0 = &EMAC0;
-		serial0 = &UART0;
-		serial1 = &UART1;
-	};
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@0 {
-			device_type = "cpu";
-			model = "PowerPC,405EZ";
-			reg = <0x0>;
-			clock-frequency = <0>; /* Filled in by wrapper */
-			timebase-frequency = <0>; /* Filled in by wrapper */
-			i-cache-line-size = <32>;
-			d-cache-line-size = <32>;
-			i-cache-size = <16384>;
-			d-cache-size = <16384>;
-			dcr-controller;
-			dcr-access-method = "native";
-		};
-	};
-
-	memory {
-		device_type = "memory";
-		reg = <0x0 0x0>; /* Filled in by wrapper */
-	};
-
-	UIC0: interrupt-controller {
-		compatible = "ibm,uic-405ez", "ibm,uic";
-		interrupt-controller;
-		dcr-reg = <0x0c0 0x009>;
-		cell-index = <0>;
-		#address-cells = <0>;
-		#size-cells = <0>;
-		#interrupt-cells = <2>;
-	};
-
-	plb {
-		compatible = "ibm,plb-405ez", "ibm,plb3";
-		#address-cells = <1>;
-		#size-cells = <1>;
-		ranges;
-		clock-frequency = <0>; /* Filled in by wrapper */
-
-		MAL0: mcmal {
-			compatible = "ibm,mcmal-405ez", "ibm,mcmal";
-			dcr-reg = <0x380 0x62>;
-			num-tx-chans = <1>;
-			num-rx-chans = <1>;
-			interrupt-parent = <&UIC0>;
-			/* 405EZ has only 3 interrupts to the UIC, as
-			 * SERR, TXDE, and RXDE are or'd together into
-			 * one UIC bit
-			 */
-			interrupts = <
-				0x13 0x4 /* TXEOB */
-				0x15 0x4 /* RXEOB */
-				0x12 0x4 /* SERR, TXDE, RXDE */>;
-		};
-
-		POB0: opb {
-			compatible = "ibm,opb-405ez", "ibm,opb";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges;
-			dcr-reg = <0x0a 0x05>;
-			clock-frequency = <0>; /* Filled in by wrapper */
-
-			UART0: serial@ef600300 {
-				device_type = "serial";
-				compatible = "ns16550";
-				reg = <0xef600300 0x8>;
-				virtual-reg = <0xef600300>;
-				clock-frequency = <0>; /* Filled in by wrapper */
-				current-speed = <115200>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x5 0x4>;
-			};
-
-			UART1: serial@ef600400 {
-				device_type = "serial";
-				compatible = "ns16550";
-				reg = <0xef600400 0x8>;
-				clock-frequency = <0>; /* Filled in by wrapper */
-				current-speed = <115200>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x6 0x4>;
-			};
-
-			IIC: i2c@ef600500 {
-				compatible = "ibm,iic-405ez", "ibm,iic";
-				reg = <0xef600500 0x11>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0xa 0x4>;
-			};
-
-			GPIO0: gpio@ef600700 {
-				compatible = "ibm,gpio-405ez";
-				reg = <0xef600700 0x20>;
-			};
-
-			GPIO1: gpio@ef600800 {
-				compatible = "ibm,gpio-405ez";
-				reg = <0xef600800 0x20>;
-			};
-
-			EMAC0: ethernet@ef600900 {
-				device_type = "network";
-				compatible = "ibm,emac-405ez", "ibm,emac";
-				interrupt-parent = <&UIC0>;
-				interrupts = <
-					0x10 0x4 /* Ethernet */
-					0x11 0x4 /* Ethernet Wake up */>;
-				local-mac-address = [000000000000]; /* Filled in by wrapper */
-				reg = <0xef600900 0x70>;
-				mal-device = <&MAL0>;
-				mal-tx-channel = <0>;
-				mal-rx-channel = <0>;
-				cell-index = <0>;
-				max-frame-size = <1500>;
-				rx-fifo-size = <4096>;
-				tx-fifo-size = <2048>;
-				phy-mode = "mii";
-				phy-map = <0x0>;
-			};
-
-			CAN0: can@ef601000 {
-				compatible = "amcc,can-405ez";
-				reg = <0xef601000 0x620>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x7 0x4>;
-			};
-
-			CAN1: can@ef601800 {
-				compatible = "amcc,can-405ez";
-				reg = <0xef601800 0x620>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x8 0x4>;
-			};
-
-			cameleon@ef602000 {
-				compatible = "amcc,cameleon-405ez";
-				reg = <0xef602000 0x800>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0xb 0x4 0xc 0x4>;
-			};
-
-			ieee1588@ef602800 {
-				compatible = "amcc,ieee1588-405ez";
-				reg = <0xef602800 0x60>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x4 0x4>;
-				/* This thing is a bit weird.  It has it's own UIC
-				 * that it uses to generate snapshot triggers.  We
-				 * don't really support this device yet, and it needs
-				 * work to figure this out.
-				 */
-				dcr-reg = <0xe0 0x9>;
-			};
-
-			usb@ef603000 {
-				compatible = "ohci-be";
-				reg = <0xef603000 0x80>;
-				interrupts-parent = <&UIC0>;
-				interrupts = <0xd 0x4 0xe 0x4>;
-			};
-
-			dac@ef603300 {
-				compatible = "amcc,dac-405ez";
-				reg = <0xef603300 0x40>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x18 0x4>;
-			};
-
-			adc@ef603400 {
-				compatible = "amcc,adc-405ez";
-				reg = <0xef603400 0x40>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x17 0x4>;
-			};
-
-			spi@ef603500 {
-				compatible = "amcc,spi-405ez";
-				reg = <0xef603500 0x100>;
-				interrupt-parent = <&UIC0>;
-				interrupts = <0x9 0x4>;
-			};
-		};
-
-		EBC0: ebc {
-			compatible = "ibm,ebc-405ez", "ibm,ebc";
-			dcr-reg = <0x12 0x2>;
-			#address-cells = <2>;
-			#size-cells = <1>;
-			clock-frequency = <0>; /* Filled in by wrapper */
-		};
-	};
-
-	chosen {
-		linux,stdout-path = "/plb/opb/serial@ef600300";
-	};
-};
diff -urN flo-ElementalX-5.00/arch/powerpc/platforms/85xx/sbc8560.c flo-ElementalX-5.00-patched/arch/powerpc/platforms/85xx/sbc8560.c
--- flo-ElementalX-5.00/arch/powerpc/platforms/85xx/sbc8560.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/powerpc/platforms/85xx/sbc8560.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,254 +0,0 @@
-/*
- * Wind River SBC8560 setup and early boot code.
- *
- * Copyright 2007 Wind River Systems Inc.
- *
- * By Paul Gortmaker (see MAINTAINERS for contact information)
- *
- * Based largely on the MPC8560ADS support - Copyright 2005 Freescale Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/stddef.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/kdev_t.h>
-#include <linux/delay.h>
-#include <linux/seq_file.h>
-#include <linux/of_platform.h>
-
-#include <asm/time.h>
-#include <asm/machdep.h>
-#include <asm/pci-bridge.h>
-#include <asm/mpic.h>
-#include <mm/mmu_decl.h>
-#include <asm/udbg.h>
-
-#include <sysdev/fsl_soc.h>
-#include <sysdev/fsl_pci.h>
-
-#include "mpc85xx.h"
-
-#ifdef CONFIG_CPM2
-#include <asm/cpm2.h>
-#include <sysdev/cpm2_pic.h>
-#endif
-
-static void __init sbc8560_pic_init(void)
-{
-	struct mpic *mpic = mpic_alloc(NULL, 0, MPIC_BIG_ENDIAN,
-			0, 256, " OpenPIC  ");
-	BUG_ON(mpic == NULL);
-	mpic_init(mpic);
-
-	mpc85xx_cpm2_pic_init();
-}
-
-/*
- * Setup the architecture
- */
-#ifdef CONFIG_CPM2
-struct cpm_pin {
-	int port, pin, flags;
-};
-
-static const struct cpm_pin sbc8560_pins[] = {
-	/* SCC1 */
-	{3, 29, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{3, 30, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
-	{3, 31, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-
-	/* SCC2 */
-	{3, 26, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{3, 27, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{3, 28, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-
-	/* FCC2 */
-	{1, 18, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 19, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 20, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 21, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 22, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 23, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 24, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 25, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 26, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 27, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 28, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 29, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
-	{1, 30, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 31, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{2, 18, CPM_PIN_INPUT | CPM_PIN_PRIMARY}, /* CLK14 */
-	{2, 19, CPM_PIN_INPUT | CPM_PIN_PRIMARY}, /* CLK13 */
-
-	/* FCC3 */
-	{1, 4, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 5, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 6, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 7, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 8, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 9, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 10, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 11, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 12, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 13, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 14, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 15, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
-	{1, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{1, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
-	{2, 16, CPM_PIN_INPUT | CPM_PIN_SECONDARY}, /* CLK16 */
-	{2, 17, CPM_PIN_INPUT | CPM_PIN_SECONDARY}, /* CLK15 */
-};
-
-static void __init init_ioports(void)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sbc8560_pins); i++) {
-		const struct cpm_pin *pin = &sbc8560_pins[i];
-		cpm2_set_pin(pin->port, pin->pin, pin->flags);
-	}
-
-	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_TX);
-	cpm2_clk_setup(CPM_CLK_SCC2, CPM_BRG2, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_SCC2, CPM_BRG2, CPM_CLK_TX);
-	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK13, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK14, CPM_CLK_TX);
-	cpm2_clk_setup(CPM_CLK_FCC3, CPM_CLK15, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_FCC3, CPM_CLK16, CPM_CLK_TX);
-}
-#endif
-
-static void __init sbc8560_setup_arch(void)
-{
-#ifdef CONFIG_PCI
-	struct device_node *np;
-#endif
-
-	if (ppc_md.progress)
-		ppc_md.progress("sbc8560_setup_arch()", 0);
-
-#ifdef CONFIG_CPM2
-	cpm2_reset();
-	init_ioports();
-#endif
-
-#ifdef CONFIG_PCI
-	for_each_compatible_node(np, "pci", "fsl,mpc8540-pci")
-		fsl_add_bridge(np, 1);
-#endif
-}
-
-static void sbc8560_show_cpuinfo(struct seq_file *m)
-{
-	uint pvid, svid, phid1;
-
-	pvid = mfspr(SPRN_PVR);
-	svid = mfspr(SPRN_SVR);
-
-	seq_printf(m, "Vendor\t\t: Wind River\n");
-	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
-	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
-
-	/* Display cpu Pll setting */
-	phid1 = mfspr(SPRN_HID1);
-	seq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));
-}
-
-machine_device_initcall(sbc8560, mpc85xx_common_publish_devices);
-
-/*
- * Called very early, device-tree isn't unflattened
- */
-static int __init sbc8560_probe(void)
-{
-        unsigned long root = of_get_flat_dt_root();
-
-        return of_flat_dt_is_compatible(root, "SBC8560");
-}
-
-#ifdef CONFIG_RTC_DRV_M48T59
-static int __init sbc8560_rtc_init(void)
-{
-	struct device_node *np;
-	struct resource res;
-	struct platform_device *rtc_dev;
-
-	np = of_find_compatible_node(NULL, NULL, "m48t59");
-	if (np == NULL) {
-		printk("No RTC in DTB. Has it been eaten by wild dogs?\n");
-		return -ENODEV;
-	}
-
-	of_address_to_resource(np, 0, &res);
-	of_node_put(np);
-
-	printk("Found RTC (m48t59) at i/o 0x%x\n", res.start);
-
-	rtc_dev = platform_device_register_simple("rtc-m48t59", 0, &res, 1);
-
-	if (IS_ERR(rtc_dev)) {
-		printk("Registering sbc8560 RTC device failed\n");
-		return PTR_ERR(rtc_dev);
-	}
-
-	return 0;
-}
-
-arch_initcall(sbc8560_rtc_init);
-
-#endif	/* M48T59 */
-
-static __u8 __iomem *brstcr;
-
-static int __init sbc8560_bdrstcr_init(void)
-{
-	struct device_node *np;
-	struct resource res;
-
-	np = of_find_compatible_node(NULL, NULL, "wrs,sbc8560-brstcr");
-	if (np == NULL) {
-		printk(KERN_WARNING "sbc8560: No board specific RSTCR in DTB.\n");
-		return -ENODEV;
-	}
-
-	of_address_to_resource(np, 0, &res);
-
-	printk(KERN_INFO "sbc8560: Found BRSTCR at %pR\n", &res);
-
-	brstcr = ioremap(res.start, resource_size(&res));
-	if(!brstcr)
-		printk(KERN_WARNING "sbc8560: ioremap of brstcr failed.\n");
-
-	of_node_put(np);
-
-	return 0;
-}
-
-arch_initcall(sbc8560_bdrstcr_init);
-
-void sbc8560_rstcr_restart(char * cmd)
-{
-	local_irq_disable();
-	if(brstcr)
-		clrbits8(brstcr, 0x80);
-
-	while(1);
-}
-
-define_machine(sbc8560) {
-	.name			= "SBC8560",
-	.probe			= sbc8560_probe,
-	.setup_arch		= sbc8560_setup_arch,
-	.init_IRQ		= sbc8560_pic_init,
-	.show_cpuinfo		= sbc8560_show_cpuinfo,
-	.get_irq		= mpic_get_irq,
-	.restart		= sbc8560_rstcr_restart,
-	.calibrate_decr		= generic_calibrate_decr,
-	.progress		= udbg_progress,
-};
diff -urN flo-ElementalX-5.00/arch/powerpc/platforms/8xx/Kconfig flo-ElementalX-5.00-patched/arch/powerpc/platforms/8xx/Kconfig
--- flo-ElementalX-5.00/arch/powerpc/platforms/8xx/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/powerpc/platforms/8xx/Kconfig	2016-05-10 02:52:00.000000000 +0000
@@ -1,184 +0,0 @@
-config FADS
-	bool
-
-config CPM1
-	bool
-	select CPM
-
-choice
-	prompt "8xx Machine Type"
-	depends on PPC_8xx
-	depends on 8xx
-	default MPC885ADS
-
-config MPC8XXFADS
-	bool "FADS"
-	select FADS
-
-config MPC86XADS
-	bool "MPC86XADS"
-	select CPM1
-	help
-	  MPC86x Application Development System by Freescale Semiconductor.
-	  The MPC86xADS is meant to serve as a platform for s/w and h/w
-	  development around the MPC86X processor families.
-
-config MPC885ADS
-	bool "MPC885ADS"
-	select CPM1
-	select OF_DYNAMIC
-	help
-	  Freescale Semiconductor MPC885 Application Development System (ADS).
-	  Also known as DUET.
-	  The MPC885ADS is meant to serve as a platform for s/w and h/w
-	  development around the MPC885 processor family.
-
-config PPC_EP88XC
-	bool "Embedded Planet EP88xC (a.k.a. CWH-PPC-885XN-VE)"
-	select CPM1
-	help
-	  This enables support for the Embedded Planet EP88xC board.
-
-	  This board is also resold by Freescale as the QUICCStart
-	  MPC885 Evaluation System and/or the CWH-PPC-885XN-VE.
-
-config PPC_ADDER875
-	bool "Analogue & Micro Adder 875"
-	select CPM1
-	select REDBOOT
-	help
-	  This enables support for the Analogue & Micro Adder 875
-	  board.
-
-config TQM8XX
-	bool "TQM8XX"
-	select CPM1
-	help
-	  support for the mpc8xx based boards from TQM.
-
-endchoice
-
-menu "Freescale Ethernet driver platform-specific options"
-	depends on (FS_ENET && MPC885ADS)
-
-	config MPC8xx_SECOND_ETH
-	bool "Second Ethernet channel"
-	depends on MPC885ADS
-	default y
-	help
-	  This enables support for second Ethernet on MPC885ADS and MPC86xADS boards.
-	  The latter will use SCC1, for 885ADS you can select it below.
-
-	choice
-		prompt "Second Ethernet channel"
-		depends on MPC8xx_SECOND_ETH
-		default MPC8xx_SECOND_ETH_FEC2
-
-		config MPC8xx_SECOND_ETH_FEC2
-		bool "FEC2"
-		depends on MPC885ADS
-		help
-		  Enable FEC2 to serve as 2-nd Ethernet channel. Note that SMC2
-		  (often 2-nd UART) will not work if this is enabled.
-
-		config MPC8xx_SECOND_ETH_SCC3
-		bool "SCC3"
-		depends on MPC885ADS
-		help
-		  Enable SCC3 to serve as 2-nd Ethernet channel. Note that SMC1
-		  (often 1-nd UART) will not work if this is enabled.
-
-	endchoice
-
-endmenu
-
-#
-# MPC8xx Communication options
-#
-
-menu "MPC8xx CPM Options"
-	depends on 8xx
-
-# This doesn't really belong here, but it is convenient to ask
-# 8xx specific questions.
-comment "Generic MPC8xx Options"
-
-config 8xx_COPYBACK
-	bool "Copy-Back Data Cache (else Writethrough)"
-	help
-	  Saying Y here will cause the cache on an MPC8xx processor to be used
-	  in Copy-Back mode.  If you say N here, it is used in Writethrough
-	  mode.
-
-	  If in doubt, say Y here.
-
-config 8xx_GPIO
-	bool "GPIO API Support"
-	select GENERIC_GPIO
-	select ARCH_REQUIRE_GPIOLIB
-	help
-	  Saying Y here will cause the ports on an MPC8xx processor to be used
-	  with the GPIO API.  If you say N here, the kernel needs less memory.
-
-	  If in doubt, say Y here.
-
-config 8xx_CPU6
-	bool "CPU6 Silicon Errata (860 Pre Rev. C)"
-	help
-	  MPC860 CPUs, prior to Rev C have some bugs in the silicon, which
-	  require workarounds for Linux (and most other OSes to work).  If you
-	  get a BUG() very early in boot, this might fix the problem.  For
-	  more details read the document entitled "MPC860 Family Device Errata
-	  Reference" on Freescale's website.  This option also incurs a
-	  performance hit.
-
-	  If in doubt, say N here.
-
-config 8xx_CPU15
-	bool "CPU15 Silicon Errata"
-	default y
-	help
-	  This enables a workaround for erratum CPU15 on MPC8xx chips.
-	  This bug can cause incorrect code execution under certain
-	  circumstances.  This workaround adds some overhead (a TLB miss
-	  every time execution crosses a page boundary), and you may wish
-	  to disable it if you have worked around the bug in the compiler
-	  (by not placing conditional branches or branches to LR or CTR
-	  in the last word of a page, with a target of the last cache
-	  line in the next page), or if you have used some other
-	  workaround.
-
-	  If in doubt, say Y here.
-
-choice
-	prompt "Microcode patch selection"
-	default NO_UCODE_PATCH
-	help
-	  Help not implemented yet, coming soon.
-
-config NO_UCODE_PATCH
-	bool "None"
-
-config USB_SOF_UCODE_PATCH
-	bool "USB SOF patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_UCODE_PATCH
-	bool "I2C/SPI relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_SMC1_UCODE_PATCH
-	bool "I2C/SPI/SMC1 relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-endchoice
-
-config UCODE_PATCH
-	bool
-	default y
-	depends on !NO_UCODE_PATCH
-
-endmenu
diff -urN flo-ElementalX-5.00/arch/s390/kernel/processor.c flo-ElementalX-5.00-patched/arch/s390/kernel/processor.c
--- flo-ElementalX-5.00/arch/s390/kernel/processor.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/s390/kernel/processor.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,96 +0,0 @@
-/*
- *  arch/s390/kernel/processor.c
- *
- *  Copyright IBM Corp. 2008
- *  Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
- */
-
-#define KMSG_COMPONENT "cpu"
-#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/seq_file.h>
-#include <linux/delay.h>
-#include <linux/cpu.h>
-#include <asm/elf.h>
-#include <asm/lowcore.h>
-#include <asm/param.h>
-
-static DEFINE_PER_CPU(struct cpuid, cpu_id);
-
-/*
- * cpu_init - initializes state that is per-CPU.
- */
-void __cpuinit cpu_init(void)
-{
-	struct cpuid *id = &per_cpu(cpu_id, smp_processor_id());
-
-	get_cpu_id(id);
-	atomic_inc(&init_mm.mm_count);
-	current->active_mm = &init_mm;
-	BUG_ON(current->mm);
-	enter_lazy_tlb(&init_mm, current);
-}
-
-/*
- * show_cpuinfo - Get information on one CPU for use by procfs.
- */
-static int show_cpuinfo(struct seq_file *m, void *v)
-{
-	static const char *hwcap_str[10] = {
-		"esan3", "zarch", "stfle", "msa", "ldisp", "eimm", "dfp",
-		"edat", "etf3eh", "highgprs"
-	};
-	unsigned long n = (unsigned long) v - 1;
-	int i;
-
-	if (!n) {
-		s390_adjust_jiffies();
-		seq_printf(m, "vendor_id       : IBM/S390\n"
-			   "# processors    : %i\n"
-			   "bogomips per cpu: %lu.%02lu\n",
-			   num_online_cpus(), loops_per_jiffy/(500000/HZ),
-			   (loops_per_jiffy/(5000/HZ))%100);
-		seq_puts(m, "features\t: ");
-		for (i = 0; i < 10; i++)
-			if (hwcap_str[i] && (elf_hwcap & (1UL << i)))
-				seq_printf(m, "%s ", hwcap_str[i]);
-		seq_puts(m, "\n");
-	}
-	get_online_cpus();
-	if (cpu_online(n)) {
-		struct cpuid *id = &per_cpu(cpu_id, n);
-		seq_printf(m, "processor %li: "
-			   "version = %02X,  "
-			   "identification = %06X,  "
-			   "machine = %04X\n",
-			   n, id->version, id->ident, id->machine);
-	}
-	put_online_cpus();
-	return 0;
-}
-
-static void *c_start(struct seq_file *m, loff_t *pos)
-{
-	return *pos < nr_cpu_ids ? (void *)((unsigned long) *pos + 1) : NULL;
-}
-
-static void *c_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return c_start(m, pos);
-}
-
-static void c_stop(struct seq_file *m, void *v)
-{
-}
-
-const struct seq_operations cpuinfo_op = {
-	.start	= c_start,
-	.next	= c_next,
-	.stop	= c_stop,
-	.show	= show_cpuinfo,
-};
-
diff -urN flo-ElementalX-5.00/arch/sh/include/asm/user.h flo-ElementalX-5.00-patched/arch/sh/include/asm/user.h
--- flo-ElementalX-5.00/arch/sh/include/asm/user.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/sh/include/asm/user.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,67 +0,0 @@
-#ifndef __ASM_SH_USER_H
-#define __ASM_SH_USER_H
-
-#include <asm/ptrace.h>
-#include <asm/page.h>
-
-/*
- * Core file format: The core file is written in such a way that gdb
- * can understand it and provide useful information to the user (under
- * linux we use the `trad-core' bfd).  The file contents are as follows:
- *
- *  upage: 1 page consisting of a user struct that tells gdb
- *	what is present in the file.  Directly after this is a
- *	copy of the task_struct, which is currently not used by gdb,
- *	but it may come in handy at some point.  All of the registers
- *	are stored as part of the upage.  The upage should always be
- *	only one page long.
- *  data: The data segment follows next.  We use current->end_text to
- *	current->brk to pick up all of the user variables, plus any memory
- *	that may have been sbrk'ed.  No attempt is made to determine if a
- *	page is demand-zero or if a page is totally unused, we just cover
- *	the entire range.  All of the addresses are rounded in such a way
- *	that an integral number of pages is written.
- *  stack: We need the stack information in order to get a meaningful
- *	backtrace.  We need to write the data from usp to
- *	current->start_stack, so we round each of these in order to be able
- *	to write an integer number of pages.
- */
-
-#if defined(__SH5__) || defined(CONFIG_CPU_SH5)
-struct user_fpu_struct {
-	unsigned long fp_regs[32];
-	unsigned int fpscr;
-};
-#else
-struct user_fpu_struct {
-	unsigned long fp_regs[16];
-	unsigned long xfp_regs[16];
-	unsigned long fpscr;
-	unsigned long fpul;
-};
-#endif
-
-struct user {
-	struct pt_regs	regs;			/* entire machine state */
-	struct user_fpu_struct fpu;	/* Math Co-processor registers  */
-	int u_fpvalid;		/* True if math co-processor being used */
-	size_t		u_tsize;		/* text size (pages) */
-	size_t		u_dsize;		/* data size (pages) */
-	size_t		u_ssize;		/* stack size (pages) */
-	unsigned long	start_code;		/* text starting address */
-	unsigned long	start_data;		/* data starting address */
-	unsigned long	start_stack;		/* stack starting address */
-	long int	signal;			/* signal causing core dump */
-	unsigned long	u_ar0;			/* help gdb find registers */
-	struct user_fpu_struct* u_fpstate;	/* Math Co-processor pointer */
-	unsigned long	magic;			/* identifies a core file */
-	char		u_comm[32];		/* user command name */
-};
-
-#define NBPG			PAGE_SIZE
-#define UPAGES			1
-#define HOST_TEXT_START_ADDR	(u.start_code)
-#define HOST_DATA_START_ADDR	(u.start_data)
-#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
-
-#endif /* __ASM_SH_USER_H */
diff -urN flo-ElementalX-5.00/arch/sparc/include/asm/atomic_64.h flo-ElementalX-5.00-patched/arch/sparc/include/asm/atomic_64.h
--- flo-ElementalX-5.00/arch/sparc/include/asm/atomic_64.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/sparc/include/asm/atomic_64.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,115 +0,0 @@
-/* atomic.h: Thankfully the V9 is at least reasonable for this
- *           stuff.
- *
- * Copyright (C) 1996, 1997, 2000 David S. Miller (davem@redhat.com)
- */
-
-#ifndef __ARCH_SPARC64_ATOMIC__
-#define __ARCH_SPARC64_ATOMIC__
-
-#include <linux/types.h>
-#include <asm/cmpxchg.h>
-
-#define ATOMIC_INIT(i)		{ (i) }
-#define ATOMIC64_INIT(i)	{ (i) }
-
-#define atomic_read(v)		(*(volatile int *)&(v)->counter)
-#define atomic64_read(v)	(*(volatile long *)&(v)->counter)
-
-#define atomic_set(v, i)	(((v)->counter) = i)
-#define atomic64_set(v, i)	(((v)->counter) = i)
-
-extern void atomic_add(int, atomic_t *);
-extern void atomic64_add(long, atomic64_t *);
-extern void atomic_sub(int, atomic_t *);
-extern void atomic64_sub(long, atomic64_t *);
-
-extern int atomic_add_ret(int, atomic_t *);
-extern long atomic64_add_ret(long, atomic64_t *);
-extern int atomic_sub_ret(int, atomic_t *);
-extern long atomic64_sub_ret(long, atomic64_t *);
-
-#define atomic_dec_return(v) atomic_sub_ret(1, v)
-#define atomic64_dec_return(v) atomic64_sub_ret(1, v)
-
-#define atomic_inc_return(v) atomic_add_ret(1, v)
-#define atomic64_inc_return(v) atomic64_add_ret(1, v)
-
-#define atomic_sub_return(i, v) atomic_sub_ret(i, v)
-#define atomic64_sub_return(i, v) atomic64_sub_ret(i, v)
-
-#define atomic_add_return(i, v) atomic_add_ret(i, v)
-#define atomic64_add_return(i, v) atomic64_add_ret(i, v)
-
-/*
- * atomic_inc_and_test - increment and test
- * @v: pointer of type atomic_t
- *
- * Atomically increments @v by 1
- * and returns true if the result is zero, or false for all
- * other cases.
- */
-#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
-#define atomic64_inc_and_test(v) (atomic64_inc_return(v) == 0)
-
-#define atomic_sub_and_test(i, v) (atomic_sub_ret(i, v) == 0)
-#define atomic64_sub_and_test(i, v) (atomic64_sub_ret(i, v) == 0)
-
-#define atomic_dec_and_test(v) (atomic_sub_ret(1, v) == 0)
-#define atomic64_dec_and_test(v) (atomic64_sub_ret(1, v) == 0)
-
-#define atomic_inc(v) atomic_add(1, v)
-#define atomic64_inc(v) atomic64_add(1, v)
-
-#define atomic_dec(v) atomic_sub(1, v)
-#define atomic64_dec(v) atomic64_sub(1, v)
-
-#define atomic_add_negative(i, v) (atomic_add_ret(i, v) < 0)
-#define atomic64_add_negative(i, v) (atomic64_add_ret(i, v) < 0)
-
-#define atomic_cmpxchg(v, o, n) (cmpxchg(&((v)->counter), (o), (n)))
-#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
-
-static inline int __atomic_add_unless(atomic_t *v, int a, int u)
-{
-	int c, old;
-	c = atomic_read(v);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = atomic_cmpxchg((v), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c;
-}
-
-#define atomic64_cmpxchg(v, o, n) \
-	((__typeof__((v)->counter))cmpxchg(&((v)->counter), (o), (n)))
-#define atomic64_xchg(v, new) (xchg(&((v)->counter), new))
-
-static inline long atomic64_add_unless(atomic64_t *v, long a, long u)
-{
-	long c, old;
-	c = atomic64_read(v);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = atomic64_cmpxchg((v), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c != (u);
-}
-
-#define atomic64_inc_not_zero(v) atomic64_add_unless((v), 1, 0)
-
-/* Atomic operations are already serializing */
-#define smp_mb__before_atomic_dec()	barrier()
-#define smp_mb__after_atomic_dec()	barrier()
-#define smp_mb__before_atomic_inc()	barrier()
-#define smp_mb__after_atomic_inc()	barrier()
-
-#endif /* !(__ARCH_SPARC64_ATOMIC__) */
diff -urN flo-ElementalX-5.00/arch/sparc/kernel/pci_common.c flo-ElementalX-5.00-patched/arch/sparc/kernel/pci_common.c
--- flo-ElementalX-5.00/arch/sparc/kernel/pci_common.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/sparc/kernel/pci_common.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,554 +0,0 @@
-/* pci_common.c: PCI controller common support.
- *
- * Copyright (C) 1999, 2007 David S. Miller (davem@davemloft.net)
- */
-
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/device.h>
-#include <linux/of_device.h>
-
-#include <asm/prom.h>
-#include <asm/oplib.h>
-
-#include "pci_impl.h"
-#include "pci_sun4v.h"
-
-static int config_out_of_range(struct pci_pbm_info *pbm,
-			       unsigned long bus,
-			       unsigned long devfn,
-			       unsigned long reg)
-{
-	if (bus < pbm->pci_first_busno ||
-	    bus > pbm->pci_last_busno)
-		return 1;
-	return 0;
-}
-
-static void *sun4u_config_mkaddr(struct pci_pbm_info *pbm,
-				 unsigned long bus,
-				 unsigned long devfn,
-				 unsigned long reg)
-{
-	unsigned long rbits = pbm->config_space_reg_bits;
-
-	if (config_out_of_range(pbm, bus, devfn, reg))
-		return NULL;
-
-	reg = (reg & ((1 << rbits) - 1));
-	devfn <<= rbits;
-	bus <<= rbits + 8;
-
-	return (void *)	(pbm->config_space | bus | devfn | reg);
-}
-
-/* At least on Sabre, it is necessary to access all PCI host controller
- * registers at their natural size, otherwise zeros are returned.
- * Strange but true, and I see no language in the UltraSPARC-IIi
- * programmer's manual that mentions this even indirectly.
- */
-static int sun4u_read_pci_cfg_host(struct pci_pbm_info *pbm,
-				   unsigned char bus, unsigned int devfn,
-				   int where, int size, u32 *value)
-{
-	u32 tmp32, *addr;
-	u16 tmp16;
-	u8 tmp8;
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		if (where < 8) {
-			unsigned long align = (unsigned long) addr;
-
-			align &= ~1;
-			pci_config_read16((u16 *)align, &tmp16);
-			if (where & 1)
-				*value = tmp16 >> 8;
-			else
-				*value = tmp16 & 0xff;
-		} else {
-			pci_config_read8((u8 *)addr, &tmp8);
-			*value = (u32) tmp8;
-		}
-		break;
-
-	case 2:
-		if (where < 8) {
-			pci_config_read16((u16 *)addr, &tmp16);
-			*value = (u32) tmp16;
-		} else {
-			pci_config_read8((u8 *)addr, &tmp8);
-			*value = (u32) tmp8;
-			pci_config_read8(((u8 *)addr) + 1, &tmp8);
-			*value |= ((u32) tmp8) << 8;
-		}
-		break;
-
-	case 4:
-		tmp32 = 0xffffffff;
-		sun4u_read_pci_cfg_host(pbm, bus, devfn,
-					where, 2, &tmp32);
-		*value = tmp32;
-
-		tmp32 = 0xffffffff;
-		sun4u_read_pci_cfg_host(pbm, bus, devfn,
-					where + 2, 2, &tmp32);
-		*value |= tmp32 << 16;
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			      int where, int size, u32 *value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	unsigned char bus = bus_dev->number;
-	u32 *addr;
-	u16 tmp16;
-	u8 tmp8;
-
-	switch (size) {
-	case 1:
-		*value = 0xff;
-		break;
-	case 2:
-		*value = 0xffff;
-		break;
-	case 4:
-		*value = 0xffffffff;
-		break;
-	}
-
-	if (!bus_dev->number && !PCI_SLOT(devfn))
-		return sun4u_read_pci_cfg_host(pbm, bus, devfn, where,
-					       size, value);
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		pci_config_read8((u8 *)addr, &tmp8);
-		*value = (u32) tmp8;
-		break;
-
-	case 2:
-		if (where & 0x01) {
-			printk("pci_read_config_word: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_read16((u16 *)addr, &tmp16);
-		*value = (u32) tmp16;
-		break;
-
-	case 4:
-		if (where & 0x03) {
-			printk("pci_read_config_dword: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_read32(addr, value);
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_write_pci_cfg_host(struct pci_pbm_info *pbm,
-				    unsigned char bus, unsigned int devfn,
-				    int where, int size, u32 value)
-{
-	u32 *addr;
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		if (where < 8) {
-			unsigned long align = (unsigned long) addr;
-			u16 tmp16;
-
-			align &= ~1;
-			pci_config_read16((u16 *)align, &tmp16);
-			if (where & 1) {
-				tmp16 &= 0x00ff;
-				tmp16 |= value << 8;
-			} else {
-				tmp16 &= 0xff00;
-				tmp16 |= value;
-			}
-			pci_config_write16((u16 *)align, tmp16);
-		} else
-			pci_config_write8((u8 *)addr, value);
-		break;
-	case 2:
-		if (where < 8) {
-			pci_config_write16((u16 *)addr, value);
-		} else {
-			pci_config_write8((u8 *)addr, value & 0xff);
-			pci_config_write8(((u8 *)addr) + 1, value >> 8);
-		}
-		break;
-	case 4:
-		sun4u_write_pci_cfg_host(pbm, bus, devfn,
-					 where, 2, value & 0xffff);
-		sun4u_write_pci_cfg_host(pbm, bus, devfn,
-					 where + 2, 2, value >> 16);
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			       int where, int size, u32 value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	unsigned char bus = bus_dev->number;
-	u32 *addr;
-
-	if (!bus_dev->number && !PCI_SLOT(devfn))
-		return sun4u_write_pci_cfg_host(pbm, bus, devfn, where,
-						size, value);
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		pci_config_write8((u8 *)addr, value);
-		break;
-
-	case 2:
-		if (where & 0x01) {
-			printk("pci_write_config_word: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_write16((u16 *)addr, value);
-		break;
-
-	case 4:
-		if (where & 0x03) {
-			printk("pci_write_config_dword: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_write32(addr, value);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops sun4u_pci_ops = {
-	.read =		sun4u_read_pci_cfg,
-	.write =	sun4u_write_pci_cfg,
-};
-
-static int sun4v_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			      int where, int size, u32 *value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	u32 devhandle = pbm->devhandle;
-	unsigned int bus = bus_dev->number;
-	unsigned int device = PCI_SLOT(devfn);
-	unsigned int func = PCI_FUNC(devfn);
-	unsigned long ret;
-
-	if (config_out_of_range(pbm, bus, devfn, where)) {
-		ret = ~0UL;
-	} else {
-		ret = pci_sun4v_config_get(devhandle,
-				HV_PCI_DEVICE_BUILD(bus, device, func),
-				where, size);
-	}
-	switch (size) {
-	case 1:
-		*value = ret & 0xff;
-		break;
-	case 2:
-		*value = ret & 0xffff;
-		break;
-	case 4:
-		*value = ret & 0xffffffff;
-		break;
-	}
-
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4v_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			       int where, int size, u32 value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	u32 devhandle = pbm->devhandle;
-	unsigned int bus = bus_dev->number;
-	unsigned int device = PCI_SLOT(devfn);
-	unsigned int func = PCI_FUNC(devfn);
-
-	if (config_out_of_range(pbm, bus, devfn, where)) {
-		/* Do nothing. */
-	} else {
-		/* We don't check for hypervisor errors here, but perhaps
-		 * we should and influence our return value depending upon
-		 * what kind of error is thrown.
-		 */
-		pci_sun4v_config_put(devhandle,
-				     HV_PCI_DEVICE_BUILD(bus, device, func),
-				     where, size, value);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops sun4v_pci_ops = {
-	.read =		sun4v_read_pci_cfg,
-	.write =	sun4v_write_pci_cfg,
-};
-
-void pci_get_pbm_props(struct pci_pbm_info *pbm)
-{
-	const u32 *val = of_get_property(pbm->op->dev.of_node, "bus-range", NULL);
-
-	pbm->pci_first_busno = val[0];
-	pbm->pci_last_busno = val[1];
-
-	val = of_get_property(pbm->op->dev.of_node, "ino-bitmap", NULL);
-	if (val) {
-		pbm->ino_bitmap = (((u64)val[1] << 32UL) |
-				   ((u64)val[0] <<  0UL));
-	}
-}
-
-static void pci_register_legacy_regions(struct resource *io_res,
-					struct resource *mem_res)
-{
-	struct resource *p;
-
-	/* VGA Video RAM. */
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "Video RAM area";
-	p->start = mem_res->start + 0xa0000UL;
-	p->end = p->start + 0x1ffffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "System ROM";
-	p->start = mem_res->start + 0xf0000UL;
-	p->end = p->start + 0xffffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "Video ROM";
-	p->start = mem_res->start + 0xc0000UL;
-	p->end = p->start + 0x7fffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-}
-
-static void pci_register_iommu_region(struct pci_pbm_info *pbm)
-{
-	const u32 *vdma = of_get_property(pbm->op->dev.of_node, "virtual-dma",
-					  NULL);
-
-	if (vdma) {
-		struct resource *rp = kzalloc(sizeof(*rp), GFP_KERNEL);
-
-		if (!rp) {
-			pr_info("%s: Cannot allocate IOMMU resource.\n",
-				pbm->name);
-			return;
-		}
-		rp->name = "IOMMU";
-		rp->start = pbm->mem_space.start + (unsigned long) vdma[0];
-		rp->end = rp->start + (unsigned long) vdma[1] - 1UL;
-		rp->flags = IORESOURCE_BUSY;
-		if (request_resource(&pbm->mem_space, rp)) {
-			pr_info("%s: Unable to request IOMMU resource.\n",
-				pbm->name);
-			kfree(rp);
-		}
-	}
-}
-
-void pci_determine_mem_io_space(struct pci_pbm_info *pbm)
-{
-	const struct linux_prom_pci_ranges *pbm_ranges;
-	int i, saw_mem, saw_io;
-	int num_pbm_ranges;
-
-	saw_mem = saw_io = 0;
-	pbm_ranges = of_get_property(pbm->op->dev.of_node, "ranges", &i);
-	if (!pbm_ranges) {
-		prom_printf("PCI: Fatal error, missing PBM ranges property "
-			    " for %s\n",
-			    pbm->name);
-		prom_halt();
-	}
-
-	num_pbm_ranges = i / sizeof(*pbm_ranges);
-
-	for (i = 0; i < num_pbm_ranges; i++) {
-		const struct linux_prom_pci_ranges *pr = &pbm_ranges[i];
-		unsigned long a, size;
-		u32 parent_phys_hi, parent_phys_lo;
-		u32 size_hi, size_lo;
-		int type;
-
-		parent_phys_hi = pr->parent_phys_hi;
-		parent_phys_lo = pr->parent_phys_lo;
-		if (tlb_type == hypervisor)
-			parent_phys_hi &= 0x0fffffff;
-
-		size_hi = pr->size_hi;
-		size_lo = pr->size_lo;
-
-		type = (pr->child_phys_hi >> 24) & 0x3;
-		a = (((unsigned long)parent_phys_hi << 32UL) |
-		     ((unsigned long)parent_phys_lo  <<  0UL));
-		size = (((unsigned long)size_hi << 32UL) |
-			((unsigned long)size_lo  <<  0UL));
-
-		switch (type) {
-		case 0:
-			/* PCI config space, 16MB */
-			pbm->config_space = a;
-			break;
-
-		case 1:
-			/* 16-bit IO space, 16MB */
-			pbm->io_space.start = a;
-			pbm->io_space.end = a + size - 1UL;
-			pbm->io_space.flags = IORESOURCE_IO;
-			saw_io = 1;
-			break;
-
-		case 2:
-			/* 32-bit MEM space, 2GB */
-			pbm->mem_space.start = a;
-			pbm->mem_space.end = a + size - 1UL;
-			pbm->mem_space.flags = IORESOURCE_MEM;
-			saw_mem = 1;
-			break;
-
-		case 3:
-			/* XXX 64-bit MEM handling XXX */
-
-		default:
-			break;
-		}
-	}
-
-	if (!saw_io || !saw_mem) {
-		prom_printf("%s: Fatal error, missing %s PBM range.\n",
-			    pbm->name,
-			    (!saw_io ? "IO" : "MEM"));
-		prom_halt();
-	}
-
-	printk("%s: PCI IO[%llx] MEM[%llx]\n",
-	       pbm->name,
-	       pbm->io_space.start,
-	       pbm->mem_space.start);
-
-	pbm->io_space.name = pbm->mem_space.name = pbm->name;
-
-	request_resource(&ioport_resource, &pbm->io_space);
-	request_resource(&iomem_resource, &pbm->mem_space);
-
-	pci_register_legacy_regions(&pbm->io_space,
-				    &pbm->mem_space);
-	pci_register_iommu_region(pbm);
-}
-
-/* Generic helper routines for PCI error reporting. */
-void pci_scan_for_target_abort(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_SIG_TARGET_ABORT |
-				   PCI_STATUS_REC_TARGET_ABORT));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s saw Target Abort [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_target_abort(pbm, bus);
-}
-
-void pci_scan_for_master_abort(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_REC_MASTER_ABORT));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s received Master Abort [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_master_abort(pbm, bus);
-}
-
-void pci_scan_for_parity_error(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_PARITY |
-				   PCI_STATUS_DETECTED_PARITY));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s saw Parity Error [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_parity_error(pbm, bus);
-}
diff -urN flo-ElementalX-5.00/drivers/base/Kconfig flo-ElementalX-5.00-patched/drivers/base/Kconfig
--- flo-ElementalX-5.00/drivers/base/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/Kconfig	2016-06-01 15:47:50.000000000 +0000
@@ -145,6 +145,17 @@
 	  this option you can point it elsewhere, such as /lib/firmware/ or
 	  some other directory containing the firmware files.
 
+config FW_LOADER_USER_HELPER
+	bool "Fallback user-helper invocation for firmware loading"
+	depends on FW_LOADER
+	default y
+	help
+	  This option enables / disables the invocation of user-helper
+	  (e.g. udev) for loading firmware files as a fallback after the
+	  direct file loading in kernel fails.  The user-mode helper is
+	  no longer required unless you have a special firmware file that
+	  resides in a non-standard path.
+
 config DEBUG_DRIVER
 	bool "Driver Core verbose debug messages"
 	depends on DEBUG_KERNEL
diff -urN flo-ElementalX-5.00/drivers/base/core.c flo-ElementalX-5.00-patched/drivers/base/core.c
--- flo-ElementalX-5.00/drivers/base/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/core.c	2016-06-01 15:47:50.000000000 +0000
@@ -84,14 +84,13 @@
 }
 EXPORT_SYMBOL(dev_driver_string);
 
-#define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
 static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 			     char *buf)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
@@ -107,7 +106,7 @@
 			      const char *buf, size_t count)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
@@ -181,7 +180,7 @@
  */
 static void device_release(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct device_private *p = dev->p;
 
 	if (dev->release)
@@ -199,7 +198,7 @@
 
 static const void *device_namespace(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	const void *ns = NULL;
 
 	if (dev->class && dev->class->ns_type)
@@ -220,7 +219,7 @@
 	struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &device_ktype) {
-		struct device *dev = to_dev(kobj);
+		struct device *dev = kobj_to_dev(kobj);
 		if (dev->bus)
 			return 1;
 		if (dev->class)
@@ -231,7 +230,7 @@
 
 static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 
 	if (dev->bus)
 		return dev->bus->name;
@@ -243,7 +242,7 @@
 static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		      struct kobj_uevent_env *env)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	int retval = 0;
 
 	/* add device node properties if present */
@@ -1131,7 +1130,7 @@
  */
 struct device *get_device(struct device *dev)
 {
-	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
+	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
 }
 
 /**
diff -urN flo-ElementalX-5.00/drivers/base/devres.c flo-ElementalX-5.00-patched/drivers/base/devres.c
--- flo-ElementalX-5.00/drivers/base/devres.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/devres.c	2016-06-01 15:47:50.000000000 +0000
@@ -144,6 +144,48 @@
 #endif
 
 /**
+ * devres_for_each_res - Resource iterator
+ * @dev: Device to iterate resource from
+ * @release: Look for resources associated with this release function
+ * @match: Match function (optional)
+ * @match_data: Data for the match function
+ * @fn: Function to be called for each matched resource.
+ * @data: Data for @fn, the 3rd parameter of @fn
+ *
+ * Call @fn for each devres of @dev which is associated with @release
+ * and for which @match returns 1.
+ *
+ * RETURNS:
+ * 	void
+ */
+void devres_for_each_res(struct device *dev, dr_release_t release,
+			dr_match_t match, void *match_data,
+			void (*fn)(struct device *, void *, void *),
+			void *data)
+{
+	struct devres_node *node;
+	struct devres_node *tmp;
+	unsigned long flags;
+
+	if (!fn)
+		return;
+
+	spin_lock_irqsave(&dev->devres_lock, flags);
+	list_for_each_entry_safe_reverse(node, tmp,
+			&dev->devres_head, entry) {
+		struct devres *dr = container_of(node, struct devres, node);
+
+		if (node->release != release)
+			continue;
+		if (match && !match(dev, dr->data, match_data))
+			continue;
+		fn(dev, dr->data, data);
+	}
+	spin_unlock_irqrestore(&dev->devres_lock, flags);
+}
+EXPORT_SYMBOL_GPL(devres_for_each_res);
+
+/**
  * devres_free - Free device resource data
  * @res: Pointer to devres data to free
  *
@@ -309,6 +351,10 @@
  * which @match returns 1.  If @match is NULL, it's considered to
  * match all.  If found, the resource is removed atomically and freed.
  *
+ * Note that the release function for the resource will not be called,
+ * only the devres-allocated data will be freed.  The caller becomes
+ * responsible for freeing any other data.
+ *
  * RETURNS:
  * 0 if devres is found and freed, -ENOENT if not found.
  */
@@ -326,6 +372,37 @@
 }
 EXPORT_SYMBOL_GPL(devres_destroy);
 
+
+/**
+ * devres_release - Find a device resource and destroy it, calling release
+ * @dev: Device to find resource from
+ * @release: Look for resources associated with this release function
+ * @match: Match function (optional)
+ * @match_data: Data for the match function
+ *
+ * Find the latest devres of @dev associated with @release and for
+ * which @match returns 1.  If @match is NULL, it's considered to
+ * match all.  If found, the resource is removed atomically, the
+ * release function called and the resource freed.
+ *
+ * RETURNS:
+ * 0 if devres is found and freed, -ENOENT if not found.
+ */
+int devres_release(struct device *dev, dr_release_t release,
+		   dr_match_t match, void *match_data)
+{
+	void *res;
+
+	res = devres_remove(dev, release, match, match_data);
+	if (unlikely(!res))
+		return -ENOENT;
+
+	(*release)(dev, res);
+	devres_free(res);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devres_release);
+
 static int remove_nodes(struct device *dev,
 			struct list_head *first, struct list_head *end,
 			struct list_head *todo)
diff -urN flo-ElementalX-5.00/drivers/base/firmware_class.c flo-ElementalX-5.00-patched/drivers/base/firmware_class.c
--- flo-ElementalX-5.00/drivers/base/firmware_class.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/firmware_class.c	2016-06-08 14:18:15.277000100 +0000
@@ -21,8 +21,16 @@
 #include <linux/firmware.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/list.h>
+#include <linux/async.h>
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
 
-#define to_dev(obj) container_of(obj, struct device, kobj)
+#include <generated/utsrelease.h>
+
+#include "base.h"
 
 MODULE_AUTHOR("Manuel Estrada Sainz");
 MODULE_DESCRIPTION("Multi purpose firmware loading support");
@@ -87,23 +95,354 @@
 	return loading_timeout > 0 ? loading_timeout * HZ : MAX_SCHEDULE_TIMEOUT;
 }
 
-/* fw_lock could be moved to 'struct firmware_priv' but since it is just
- * guarding for corner cases a global lock should be OK */
-static DEFINE_MUTEX(fw_lock);
+struct firmware_cache {
+	/* firmware_buf instance will be added into the below list */
+	spinlock_t lock;
+	struct list_head head;
+	int state;
+
+#ifdef CONFIG_PM_SLEEP
+	/*
+	 * Names of firmware images which have been cached successfully
+	 * will be added into the below list so that device uncache
+	 * helper can trace which firmware images have been cached
+	 * before.
+	 */
+	spinlock_t name_lock;
+	struct list_head fw_names;
+
+	wait_queue_head_t wait_queue;
+	int cnt;
+	struct delayed_work work;
 
-struct firmware_priv {
+	struct notifier_block   pm_notify;
+#endif
+};
+
+struct firmware_buf {
+	struct kref ref;
+	struct list_head list;
 	struct completion completion;
-	struct firmware *fw;
+	struct firmware_cache *fwc;
 	unsigned long status;
+	void *data;
+	size_t size;
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	bool is_paged_buf;
 	struct page **pages;
 	int nr_pages;
 	int page_array_size;
-	struct timer_list timeout;
-	struct device dev;
-	bool nowait;
+#endif
 	char fw_id[];
 };
 
+struct fw_cache_entry {
+	struct list_head list;
+	char name[];
+};
+
+struct fw_name_devm {
+	unsigned long magic;
+	char name[];
+};
+
+#define to_fwbuf(d) container_of(d, struct firmware_buf, ref)
+
+#define	FW_LOADER_NO_CACHE	0
+#define	FW_LOADER_START_CACHE	1
+
+static int fw_cache_piggyback_on_request(const char *name);
+
+/* fw_lock could be moved to 'struct firmware_priv' but since it is just
+ * guarding for corner cases a global lock should be OK */
+static DEFINE_MUTEX(fw_lock);
+
+static struct firmware_cache fw_cache;
+
+static struct firmware_buf *__allocate_fw_buf(const char *fw_name,
+					      struct firmware_cache *fwc)
+{
+	struct firmware_buf *buf;
+
+	buf = kzalloc(sizeof(*buf) + strlen(fw_name) + 1 , GFP_ATOMIC);
+
+	if (!buf)
+		return buf;
+
+	kref_init(&buf->ref);
+	strcpy(buf->fw_id, fw_name);
+	buf->fwc = fwc;
+	init_completion(&buf->completion);
+
+	pr_debug("%s: fw-%s buf=%p\n", __func__, fw_name, buf);
+
+	return buf;
+}
+
+static struct firmware_buf *__fw_lookup_buf(const char *fw_name)
+{
+	struct firmware_buf *tmp;
+	struct firmware_cache *fwc = &fw_cache;
+
+	list_for_each_entry(tmp, &fwc->head, list)
+		if (!strcmp(tmp->fw_id, fw_name))
+			return tmp;
+	return NULL;
+}
+
+static int fw_lookup_and_allocate_buf(const char *fw_name,
+				      struct firmware_cache *fwc,
+				      struct firmware_buf **buf)
+{
+	struct firmware_buf *tmp;
+
+	spin_lock(&fwc->lock);
+	tmp = __fw_lookup_buf(fw_name);
+	if (tmp) {
+		kref_get(&tmp->ref);
+		spin_unlock(&fwc->lock);
+		*buf = tmp;
+		return 1;
+	}
+	tmp = __allocate_fw_buf(fw_name, fwc);
+	if (tmp)
+		list_add(&tmp->list, &fwc->head);
+	spin_unlock(&fwc->lock);
+
+	*buf = tmp;
+
+	return tmp ? 0 : -ENOMEM;
+}
+
+static struct firmware_buf *fw_lookup_buf(const char *fw_name)
+{
+	struct firmware_buf *tmp;
+	struct firmware_cache *fwc = &fw_cache;
+
+	spin_lock(&fwc->lock);
+	tmp = __fw_lookup_buf(fw_name);
+	spin_unlock(&fwc->lock);
+
+	return tmp;
+}
+
+static void __fw_free_buf(struct kref *ref)
+{
+	struct firmware_buf *buf = to_fwbuf(ref);
+	struct firmware_cache *fwc = buf->fwc;
+
+	pr_debug("%s: fw-%s buf=%p data=%p size=%u\n",
+		 __func__, buf->fw_id, buf, buf->data,
+		 (unsigned int)buf->size);
+
+	list_del(&buf->list);
+	spin_unlock(&fwc->lock);
+
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	if (buf->is_paged_buf) {
+		int i;
+		vunmap(buf->data);
+		for (i = 0; i < buf->nr_pages; i++)
+			__free_page(buf->pages[i]);
+		kfree(buf->pages);
+	} else
+#endif
+		vfree(buf->data);
+	kfree(buf);
+}
+
+static void fw_free_buf(struct firmware_buf *buf)
+{
+	struct firmware_cache *fwc = buf->fwc;
+	spin_lock(&fwc->lock);
+	if (!kref_put(&buf->ref, __fw_free_buf))
+		spin_unlock(&fwc->lock);
+}
+
+/* direct firmware loading support */
+static char fw_path_para[256];
+static const char * const fw_path[] = {
+	fw_path_para,
+	"/lib/firmware/updates/" UTS_RELEASE,
+	"/lib/firmware/updates",
+	"/lib/firmware/" UTS_RELEASE,
+	"/lib/firmware"
+};
+
+/*
+ * Typical usage is that passing 'firmware_class.path=$CUSTOMIZED_PATH'
+ * from kernel command line because firmware_class is generally built in
+ * kernel instead of module.
+ */
+module_param_string(path, fw_path_para, sizeof(fw_path_para), 0644);
+MODULE_PARM_DESC(path, "customized firmware image search path with a higher priority than default path");
+
+/* Don't inline this: 'struct kstat' is biggish */
+static noinline_for_stack long fw_file_size(struct file *file)
+{
+	struct kstat st;
+	if (vfs_getattr(file->f_path.mnt, file->f_path.dentry, &st))
+		return -1;
+	if (!S_ISREG(st.mode))
+		return -1;
+	if (st.size != (long)st.size)
+		return -1;
+	return st.size;
+}
+
+static bool fw_read_file_contents(struct file *file, struct firmware_buf *fw_buf)
+{
+	long size;
+	char *buf;
+
+	size = fw_file_size(file);
+	if (size <= 0)
+		return false;
+	buf = vmalloc(size);
+	if (!buf)
+		return false;
+	if (kernel_read(file, 0, buf, size) != size) {
+		vfree(buf);
+		return false;
+	}
+	fw_buf->data = buf;
+	fw_buf->size = size;
+	return true;
+}
+
+static bool fw_get_filesystem_firmware(struct device *device,
+				       struct firmware_buf *buf)
+{
+	int i;
+	bool success = false;
+	char *path = __getname();
+
+	for (i = 0; i < ARRAY_SIZE(fw_path); i++) {
+		struct file *file;
+
+		/* skip the unset customized path */
+		if (!fw_path[i][0])
+			continue;
+
+		snprintf(path, PATH_MAX, "%s/%s", fw_path[i], buf->fw_id);
+
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file))
+			continue;
+		success = fw_read_file_contents(file, buf);
+		fput(file);
+		if (success)
+			break;
+	}
+	__putname(path);
+
+	if (success) {
+		dev_dbg(device, "firmware: direct-loading firmware %s\n",
+			buf->fw_id);
+		mutex_lock(&fw_lock);
+		set_bit(FW_STATUS_DONE, &buf->status);
+		complete_all(&buf->completion);
+		mutex_unlock(&fw_lock);
+	}
+
+	return success;
+}
+
+/* firmware holds the ownership of pages */
+static void firmware_free_data(const struct firmware *fw)
+{
+	/* Loaded directly? */
+	if (!fw->priv) {
+		vfree(fw->data);
+		return;
+	}
+	fw_free_buf(fw->priv);
+}
+
+/* store the pages buffer info firmware from buf */
+static void fw_set_page_data(struct firmware_buf *buf, struct firmware *fw)
+{
+	fw->priv = buf;
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	fw->pages = buf->pages;
+#endif
+	fw->size = buf->size;
+	fw->data = buf->data;
+
+	pr_debug("%s: fw-%s buf=%p data=%p size=%u\n",
+		 __func__, buf->fw_id, buf, buf->data,
+		 (unsigned int)buf->size);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void fw_name_devm_release(struct device *dev, void *res)
+{
+	struct fw_name_devm *fwn = res;
+
+	if (fwn->magic == (unsigned long)&fw_cache)
+		pr_debug("%s: fw_name-%s devm-%p released\n",
+				__func__, fwn->name, res);
+}
+
+static int fw_devm_match(struct device *dev, void *res,
+		void *match_data)
+{
+	struct fw_name_devm *fwn = res;
+
+	return (fwn->magic == (unsigned long)&fw_cache) &&
+		!strcmp(fwn->name, match_data);
+}
+
+static struct fw_name_devm *fw_find_devm_name(struct device *dev,
+		const char *name)
+{
+	struct fw_name_devm *fwn;
+
+	fwn = devres_find(dev, fw_name_devm_release,
+			  fw_devm_match, (void *)name);
+	return fwn;
+}
+
+/* add firmware name into devres list */
+static int fw_add_devm_name(struct device *dev, const char *name)
+{
+	struct fw_name_devm *fwn;
+
+	fwn = fw_find_devm_name(dev, name);
+	if (fwn)
+		return 1;
+
+	fwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm) +
+			   strlen(name) + 1, GFP_KERNEL);
+	if (!fwn)
+		return -ENOMEM;
+
+	fwn->magic = (unsigned long)&fw_cache;
+	strcpy(fwn->name, name);
+	devres_add(dev, fwn);
+
+	return 0;
+}
+#else
+static int fw_add_devm_name(struct device *dev, const char *name)
+{
+	return 0;
+}
+#endif
+
+
+/*
+ * user-mode helper code
+ */
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+struct firmware_priv {
+	struct delayed_work timeout_work;
+	bool nowait;
+	struct device dev;
+	struct firmware_buf *buf;
+	struct firmware *fw;
+};
+
 static struct firmware_priv *to_firmware_priv(struct device *dev)
 {
 	return container_of(dev, struct firmware_priv, dev);
@@ -111,11 +450,15 @@
 
 static void fw_load_abort(struct firmware_priv *fw_priv)
 {
-	set_bit(FW_STATUS_ABORT, &fw_priv->status);
-	wmb();
-	complete(&fw_priv->completion);
+	struct firmware_buf *buf = fw_priv->buf;
+
+	set_bit(FW_STATUS_ABORT, &buf->status);
+	complete_all(&buf->completion);
 }
 
+#define is_fw_load_aborted(buf)	\
+	test_bit(FW_STATUS_ABORT, &(buf)->status)
+
 static ssize_t firmware_timeout_show(struct class *class,
 				     struct class_attribute *attr,
 				     char *buf)
@@ -156,11 +499,7 @@
 static void fw_dev_release(struct device *dev)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	int i;
 
-	for (i = 0; i < fw_priv->nr_pages; i++)
-		__free_page(fw_priv->pages[i]);
-	kfree(fw_priv->pages);
 	kfree(fw_priv);
 
 	module_put(THIS_MODULE);
@@ -170,7 +509,7 @@
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
 
-	if (add_uevent_var(env, "FIRMWARE=%s", fw_priv->fw_id))
+	if (add_uevent_var(env, "FIRMWARE=%s", fw_priv->buf->fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, "TIMEOUT=%i", loading_timeout))
 		return -ENOMEM;
@@ -191,26 +530,30 @@
 				     struct device_attribute *attr, char *buf)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	int loading = test_bit(FW_STATUS_LOADING, &fw_priv->status);
+	int loading = test_bit(FW_STATUS_LOADING, &fw_priv->buf->status);
 
 	return sprintf(buf, "%d\n", loading);
 }
 
-static void firmware_free_data(const struct firmware *fw)
-{
-	int i;
-	vunmap(fw->data);
-	if (fw->pages) {
-		for (i = 0; i < PFN_UP(fw->size); i++)
-			__free_page(fw->pages[i]);
-		kfree(fw->pages);
-	}
-}
-
 /* Some architectures don't have PAGE_KERNEL_RO */
 #ifndef PAGE_KERNEL_RO
 #define PAGE_KERNEL_RO PAGE_KERNEL
 #endif
+
+/* one pages buffer should be mapped/unmapped only once */
+static int fw_map_pages_buf(struct firmware_buf *buf)
+{
+	if (!buf->is_paged_buf)
+		return 0;
+
+	if (buf->data)
+		vunmap(buf->data);
+	buf->data = vmap(buf->pages, buf->nr_pages, 0, PAGE_KERNEL_RO);
+	if (!buf->data)
+		return -ENOMEM;
+	return 0;
+}
+
 /**
  * firmware_loading_store - set value in the 'loading' control file
  * @dev: device pointer
@@ -229,45 +572,41 @@
 				      const char *buf, size_t count)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
+	struct firmware_buf *fw_buf = fw_priv->buf;
 	int loading = simple_strtol(buf, NULL, 10);
 	int i;
 
 	mutex_lock(&fw_lock);
 
-	if (!fw_priv->fw)
+	if (!fw_buf)
 		goto out;
 
 	switch (loading) {
 	case 1:
-		firmware_free_data(fw_priv->fw);
-		memset(fw_priv->fw, 0, sizeof(struct firmware));
-		/* If the pages are not owned by 'struct firmware' */
-		for (i = 0; i < fw_priv->nr_pages; i++)
-			__free_page(fw_priv->pages[i]);
-		kfree(fw_priv->pages);
-		fw_priv->pages = NULL;
-		fw_priv->page_array_size = 0;
-		fw_priv->nr_pages = 0;
-		set_bit(FW_STATUS_LOADING, &fw_priv->status);
+		/* discarding any previous partial load */
+		if (!test_bit(FW_STATUS_DONE, &fw_buf->status)) {
+			for (i = 0; i < fw_buf->nr_pages; i++)
+				__free_page(fw_buf->pages[i]);
+			kfree(fw_buf->pages);
+			fw_buf->pages = NULL;
+			fw_buf->page_array_size = 0;
+			fw_buf->nr_pages = 0;
+			set_bit(FW_STATUS_LOADING, &fw_buf->status);
+		}
 		break;
 	case 0:
-		if (test_bit(FW_STATUS_LOADING, &fw_priv->status)) {
-			vunmap(fw_priv->fw->data);
-			fw_priv->fw->data = vmap(fw_priv->pages,
-						 fw_priv->nr_pages,
-						 0, PAGE_KERNEL_RO);
-			if (!fw_priv->fw->data) {
-				dev_err(dev, "%s: vmap() failed\n", __func__);
-				goto err;
-			}
-			/* Pages are now owned by 'struct firmware' */
-			fw_priv->fw->pages = fw_priv->pages;
-			fw_priv->pages = NULL;
-
-			fw_priv->page_array_size = 0;
-			fw_priv->nr_pages = 0;
-			complete(&fw_priv->completion);
-			clear_bit(FW_STATUS_LOADING, &fw_priv->status);
+		if (test_bit(FW_STATUS_LOADING, &fw_buf->status)) {
+			set_bit(FW_STATUS_DONE, &fw_buf->status);
+			clear_bit(FW_STATUS_LOADING, &fw_buf->status);
+
+			/*
+			 * Several loading requests may be pending on
+			 * one same firmware buf, so let all requests
+			 * see the mapped 'buf->data' once the loading
+			 * is completed.
+			 * */
+			fw_map_pages_buf(fw_buf);
+			complete_all(&fw_buf->completion);
 			break;
 		}
 		/* fallthrough */
@@ -275,7 +614,6 @@
 		dev_err(dev, "%s: unexpected value (%d)\n", __func__, loading);
 		/* fallthrough */
 	case -1:
-	err:
 		fw_load_abort(fw_priv);
 		break;
 	}
@@ -290,23 +628,23 @@
 				  struct bin_attribute *bin_attr,
 				  char *buffer, loff_t offset, size_t count)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	struct firmware *fw;
+	struct firmware_buf *buf;
 	ssize_t ret_count;
 
 	mutex_lock(&fw_lock);
-	fw = fw_priv->fw;
-	if (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {
+	buf = fw_priv->buf;
+	if (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {
 		ret_count = -ENODEV;
 		goto out;
 	}
-	if (offset > fw->size) {
+	if (offset > buf->size) {
 		ret_count = 0;
 		goto out;
 	}
-	if (count > fw->size - offset)
-		count = fw->size - offset;
+	if (count > buf->size - offset)
+		count = buf->size - offset;
 
 	ret_count = count;
 
@@ -316,11 +654,11 @@
 		int page_ofs = offset & (PAGE_SIZE-1);
 		int page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);
 
-		page_data = kmap(fw_priv->pages[page_nr]);
+		page_data = kmap(buf->pages[page_nr]);
 
 		memcpy(buffer, page_data + page_ofs, page_cnt);
 
-		kunmap(fw_priv->pages[page_nr]);
+		kunmap(buf->pages[page_nr]);
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
@@ -332,12 +670,13 @@
 
 static int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)
 {
+	struct firmware_buf *buf = fw_priv->buf;
 	int pages_needed = ALIGN(min_size, PAGE_SIZE) >> PAGE_SHIFT;
 
 	/* If the array of pages is too small, grow it... */
-	if (fw_priv->page_array_size < pages_needed) {
+	if (buf->page_array_size < pages_needed) {
 		int new_array_size = max(pages_needed,
-					 fw_priv->page_array_size * 2);
+					 buf->page_array_size * 2);
 		struct page **new_pages;
 
 		new_pages = kmalloc(new_array_size * sizeof(void *),
@@ -346,24 +685,24 @@
 			fw_load_abort(fw_priv);
 			return -ENOMEM;
 		}
-		memcpy(new_pages, fw_priv->pages,
-		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
-		       (new_array_size - fw_priv->page_array_size));
-		kfree(fw_priv->pages);
-		fw_priv->pages = new_pages;
-		fw_priv->page_array_size = new_array_size;
+		memcpy(new_pages, buf->pages,
+		       buf->page_array_size * sizeof(void *));
+		memset(&new_pages[buf->page_array_size], 0, sizeof(void *) *
+		       (new_array_size - buf->page_array_size));
+		kfree(buf->pages);
+		buf->pages = new_pages;
+		buf->page_array_size = new_array_size;
 	}
 
-	while (fw_priv->nr_pages < pages_needed) {
-		fw_priv->pages[fw_priv->nr_pages] =
+	while (buf->nr_pages < pages_needed) {
+		buf->pages[buf->nr_pages] =
 			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
 
-		if (!fw_priv->pages[fw_priv->nr_pages]) {
+		if (!buf->pages[buf->nr_pages]) {
 			fw_load_abort(fw_priv);
 			return -ENOMEM;
 		}
-		fw_priv->nr_pages++;
+		buf->nr_pages++;
 	}
 	return 0;
 }
@@ -384,20 +723,21 @@
 				   struct bin_attribute *bin_attr,
 				   char *buffer, loff_t offset, size_t count)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	struct firmware *fw;
+	struct firmware_buf *buf;
 	ssize_t retval;
 
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
 	mutex_lock(&fw_lock);
-	fw = fw_priv->fw;
-	if (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {
+	buf = fw_priv->buf;
+	if (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {
 		retval = -ENODEV;
 		goto out;
 	}
+
 	retval = fw_realloc_buffer(fw_priv, offset + count);
 	if (retval)
 		goto out;
@@ -410,17 +750,17 @@
 		int page_ofs = offset & (PAGE_SIZE - 1);
 		int page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);
 
-		page_data = kmap(fw_priv->pages[page_nr]);
+		page_data = kmap(buf->pages[page_nr]);
 
 		memcpy(page_data + page_ofs, buffer, page_cnt);
 
-		kunmap(fw_priv->pages[page_nr]);
+		kunmap(buf->pages[page_nr]);
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
 	}
 
-	fw->size = max_t(size_t, offset, fw->size);
+	buf->size = max_t(size_t, offset, buf->size);
 out:
 	mutex_unlock(&fw_lock);
 	return retval;
@@ -433,11 +773,18 @@
 	.write = firmware_data_write,
 };
 
-static void firmware_class_timeout(u_long data)
+static void firmware_class_timeout_work(struct work_struct *work)
 {
-	struct firmware_priv *fw_priv = (struct firmware_priv *) data;
+	struct firmware_priv *fw_priv = container_of(work,
+			struct firmware_priv, timeout_work.work);
 
+	mutex_lock(&fw_lock);
+	if (test_bit(FW_STATUS_DONE, &(fw_priv->buf->status))) {
+		mutex_unlock(&fw_lock);
+		return;
+	}
 	fw_load_abort(fw_priv);
+	mutex_unlock(&fw_lock);
 }
 
 static struct firmware_priv *
@@ -447,70 +794,38 @@
 	struct firmware_priv *fw_priv;
 	struct device *f_dev;
 
-	fw_priv = kzalloc(sizeof(*fw_priv) + strlen(fw_name) + 1 , GFP_KERNEL);
+	fw_priv = kzalloc(sizeof(*fw_priv), GFP_KERNEL);
 	if (!fw_priv) {
 		dev_err(device, "%s: kmalloc failed\n", __func__);
-		return ERR_PTR(-ENOMEM);
+		fw_priv = ERR_PTR(-ENOMEM);
+		goto exit;
 	}
 
-	fw_priv->fw = firmware;
 	fw_priv->nowait = nowait;
-	strcpy(fw_priv->fw_id, fw_name);
-	init_completion(&fw_priv->completion);
-	setup_timer(&fw_priv->timeout,
-		    firmware_class_timeout, (u_long) fw_priv);
+	fw_priv->fw = firmware;
+	INIT_DELAYED_WORK(&fw_priv->timeout_work,
+		firmware_class_timeout_work);
 
 	f_dev = &fw_priv->dev;
 
 	device_initialize(f_dev);
-	dev_set_name(f_dev, "%s", dev_name(device));
+	dev_set_name(f_dev, "%s", fw_name);
 	f_dev->parent = device;
 	f_dev->class = &firmware_class;
-
-	return fw_priv;
-}
-
-static struct firmware_priv *
-_request_firmware_prepare(const struct firmware **firmware_p, const char *name,
-			  struct device *device, bool uevent, bool nowait)
-{
-	struct firmware *firmware;
-	struct firmware_priv *fw_priv;
-
-	if (!firmware_p)
-		return ERR_PTR(-EINVAL);
-
-	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
-	if (!firmware) {
-		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
-			__func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	if (fw_get_builtin_firmware(firmware, name)) {
-		dev_dbg(device, "firmware: using built-in firmware %s\n", name);
-		return NULL;
-	}
-
-	fw_priv = fw_create_instance(firmware, name, device, uevent, nowait);
-	if (IS_ERR(fw_priv)) {
-		release_firmware(firmware);
-		*firmware_p = NULL;
-	}
+exit:
 	return fw_priv;
 }
 
-static void _request_firmware_cleanup(const struct firmware **firmware_p)
-{
-	release_firmware(*firmware_p);
-	*firmware_p = NULL;
-}
-
+/* load a firmware via user helper */
 static int _request_firmware_load(struct firmware_priv *fw_priv, bool uevent,
 				  long timeout)
 {
 	int retval = 0;
 	struct device *f_dev = &fw_priv->dev;
+	struct firmware_buf *buf = fw_priv->buf;
+
+	/* fall back on userspace loading */
+	buf->is_paged_buf = true;
 
 	dev_set_uevent_suppress(f_dev, true);
 
@@ -537,24 +852,18 @@
 
 	if (uevent) {
 		dev_set_uevent_suppress(f_dev, false);
-		dev_dbg(f_dev, "firmware: requesting %s\n", fw_priv->fw_id);
+		dev_dbg(f_dev, "firmware: requesting %s\n", buf->fw_id);
 		if (timeout != MAX_SCHEDULE_TIMEOUT)
-			mod_timer(&fw_priv->timeout,
-				  round_jiffies_up(jiffies + timeout));
+			schedule_delayed_work(&fw_priv->timeout_work, timeout);
 
 		kobject_uevent(&fw_priv->dev.kobj, KOBJ_ADD);
 	}
 
-	wait_for_completion(&fw_priv->completion);
+	wait_for_completion(&buf->completion);
 
-	set_bit(FW_STATUS_DONE, &fw_priv->status);
-	del_timer_sync(&fw_priv->timeout);
+	cancel_delayed_work_sync(&fw_priv->timeout_work);
 
-	mutex_lock(&fw_lock);
-	if (!fw_priv->fw->size || test_bit(FW_STATUS_ABORT, &fw_priv->status))
-		retval = -ENOENT;
-	fw_priv->fw = NULL;
-	mutex_unlock(&fw_lock);
+	fw_priv->buf = NULL;
 
 	device_remove_file(f_dev, &dev_attr_loading);
 err_del_bin_attr:
@@ -566,6 +875,186 @@
 	return retval;
 }
 
+static int fw_load_from_user_helper(struct firmware *firmware,
+				    const char *name, struct device *device,
+				    bool uevent, bool nowait, long timeout)
+{
+	struct firmware_priv *fw_priv;
+
+	fw_priv = fw_create_instance(firmware, name, device, uevent, nowait);
+	if (IS_ERR(fw_priv))
+		return PTR_ERR(fw_priv);
+
+	fw_priv->buf = firmware->priv;
+	return _request_firmware_load(fw_priv, uevent, timeout);
+}
+#else /* CONFIG_FW_LOADER_USER_HELPER */
+static inline int
+fw_load_from_user_helper(struct firmware *firmware, const char *name,
+			 struct device *device, bool uevent, bool nowait,
+			 long timeout)
+{
+	return -ENOENT;
+}
+
+/* No abort during direct loading */
+#define is_fw_load_aborted(buf) false
+
+#endif /* CONFIG_FW_LOADER_USER_HELPER */
+
+
+/* wait until the shared firmware_buf becomes ready (or error) */
+static int sync_cached_firmware_buf(struct firmware_buf *buf)
+{
+	int ret = 0;
+
+	mutex_lock(&fw_lock);
+	while (!test_bit(FW_STATUS_DONE, &buf->status)) {
+		if (is_fw_load_aborted(buf)) {
+			ret = -ENOENT;
+			break;
+		}
+		mutex_unlock(&fw_lock);
+		wait_for_completion(&buf->completion);
+		mutex_lock(&fw_lock);
+	}
+	mutex_unlock(&fw_lock);
+	return ret;
+}
+
+/* prepare firmware and firmware_buf structs;
+ * return 0 if a firmware is already assigned, 1 if need to load one,
+ * or a negative error code
+ */
+static int
+_request_firmware_prepare(struct firmware **firmware_p, const char *name,
+			  struct device *device)
+{
+	struct firmware *firmware;
+	struct firmware_buf *buf;
+	int ret;
+
+	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
+	if (!firmware) {
+		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	if (fw_get_builtin_firmware(firmware, name)) {
+		dev_dbg(device, "firmware: using built-in firmware %s\n", name);
+		return 0; /* assigned */
+	}
+
+	ret = fw_lookup_and_allocate_buf(name, &fw_cache, &buf);
+
+	/*
+	 * bind with 'buf' now to avoid warning in failure path
+	 * of requesting firmware.
+	 */
+	firmware->priv = buf;
+
+	if (ret > 0) {
+		ret = sync_cached_firmware_buf(buf);
+		if (!ret) {
+			fw_set_page_data(buf, firmware);
+			return 0; /* assigned */
+		}
+	}
+
+	if (ret < 0)
+		return ret;
+	return 1; /* need to load */
+}
+
+static int assign_firmware_buf(struct firmware *fw, struct device *device)
+{
+	struct firmware_buf *buf = fw->priv;
+
+	mutex_lock(&fw_lock);
+	if (!buf->size || is_fw_load_aborted(buf)) {
+		mutex_unlock(&fw_lock);
+		return -ENOENT;
+	}
+
+	/*
+	 * add firmware name into devres list so that we can auto cache
+	 * and uncache firmware for device.
+	 *
+	 * device may has been deleted already, but the problem
+	 * should be fixed in devres or driver core.
+	 */
+	if (device)
+		fw_add_devm_name(device, buf->fw_id);
+
+	/*
+	 * After caching firmware image is started, let it piggyback
+	 * on request firmware.
+	 */
+	if (buf->fwc->state == FW_LOADER_START_CACHE) {
+		if (fw_cache_piggyback_on_request(buf->fw_id))
+			kref_get(&buf->ref);
+	}
+
+	/* pass the pages buffer to driver at the last minute */
+	fw_set_page_data(buf, fw);
+	mutex_unlock(&fw_lock);
+	return 0;
+}
+
+/* called from request_firmware() and request_firmware_work_func() */
+static int
+_request_firmware(const struct firmware **firmware_p, const char *name,
+		  struct device *device, bool uevent, bool nowait)
+{
+	struct firmware *fw;
+	long timeout;
+	int ret;
+
+	if (!firmware_p)
+		return -EINVAL;
+
+	ret = _request_firmware_prepare(&fw, name, device);
+	if (ret <= 0) /* error or already assigned */
+		goto out;
+
+	ret = 0;
+	timeout = firmware_loading_timeout();
+	if (nowait) {
+		timeout = usermodehelper_read_lock_wait(timeout);
+		if (!timeout) {
+			dev_dbg(device, "firmware: %s loading timed out\n",
+				name);
+			ret = -EBUSY;
+			goto out;
+		}
+	} else {
+		ret = usermodehelper_read_trylock();
+		if (WARN_ON(ret)) {
+			dev_err(device, "firmware: %s will not be loaded\n",
+				name);
+			goto out;
+		}
+	}
+
+	if (!fw_get_filesystem_firmware(device, fw->priv))
+		ret = fw_load_from_user_helper(fw, name, device,
+					       uevent, nowait, timeout);
+	if (!ret)
+		ret = assign_firmware_buf(fw, device);
+
+	usermodehelper_read_unlock();
+
+ out:
+	if (ret < 0) {
+		release_firmware(fw);
+		fw = NULL;
+	}
+
+	*firmware_p = fw;
+	return ret;
+}
+
 /**
  * request_firmware: - send firmware request and wait for it
  * @firmware_p: pointer to firmware image
@@ -580,31 +1069,17 @@
  *      @name will be used as $FIRMWARE in the uevent environment and
  *      should be distinctive enough not to be confused with any other
  *      firmware image for this or any other device.
+ *
+ *	Caller must hold the reference count of @device.
+ *
+ *	The function can be called safely inside device's suspend and
+ *	resume callback.
  **/
 int
 request_firmware(const struct firmware **firmware_p, const char *name,
                  struct device *device)
 {
-	struct firmware_priv *fw_priv;
-	int ret;
-
-	fw_priv = _request_firmware_prepare(firmware_p, name, device, true,
-					    false);
-	if (IS_ERR_OR_NULL(fw_priv))
-		return PTR_RET(fw_priv);
-
-	ret = usermodehelper_read_trylock();
-	if (WARN_ON(ret)) {
-		dev_err(device, "firmware: %s will not be loaded\n", name);
-	} else {
-		ret = _request_firmware_load(fw_priv, true,
-					firmware_loading_timeout());
-		usermodehelper_read_unlock();
-	}
-	if (ret)
-		_request_firmware_cleanup(firmware_p);
-
-	return ret;
+	return _request_firmware(firmware_p, name, device, true, false);
 }
 
 /**
@@ -635,32 +1110,13 @@
 {
 	struct firmware_work *fw_work;
 	const struct firmware *fw;
-	struct firmware_priv *fw_priv;
-	long timeout;
-	int ret;
 
 	fw_work = container_of(work, struct firmware_work, work);
-	fw_priv = _request_firmware_prepare(&fw, fw_work->name, fw_work->device,
-			fw_work->uevent, true);
-	if (IS_ERR_OR_NULL(fw_priv)) {
-		ret = PTR_RET(fw_priv);
-		goto out;
-	}
-
-	timeout = usermodehelper_read_lock_wait(firmware_loading_timeout());
-	if (timeout) {
-		ret = _request_firmware_load(fw_priv, fw_work->uevent, timeout);
-		usermodehelper_read_unlock();
-	} else {
-		dev_dbg(fw_work->device, "firmware: %s loading timed out\n",
-			fw_work->name);
-		ret = -EAGAIN;
-	}
-	if (ret)
-		_request_firmware_cleanup(&fw);
 
- out:
+	_request_firmware(&fw, fw_work->name, fw_work->device,
+			  fw_work->uevent, true);
 	fw_work->cont(fw, fw_work->context);
+	put_device(fw_work->device); /* taken in request_firmware_nowait() */
 
 	module_put(fw_work->module);
 	kfree(fw_work);
@@ -679,9 +1135,15 @@
  * @cont: function will be called asynchronously when the firmware
  *	request is over.
  *
- *	Asynchronous variant of request_firmware() for user contexts where
- *	it is not possible to sleep for long time. It can't be called
- *	in atomic contexts.
+ *	Caller must hold the reference count of @device.
+ *
+ *	Asynchronous variant of request_firmware() for user contexts:
+ *		- sleep for as small periods as possible since it may
+ *		increase kernel boot time of built-in device drivers
+ *		requesting firmware in their ->probe() methods, if
+ *		@gfp is GFP_KERNEL.
+ *
+ *		- can't sleep at all if @gfp is GFP_ATOMIC.
  **/
 int
 request_firmware_nowait(
@@ -707,19 +1169,391 @@
 		return -EFAULT;
 	}
 
+	get_device(fw_work->device);
 	INIT_WORK(&fw_work->work, request_firmware_work_func);
 	schedule_work(&fw_work->work);
 	return 0;
 }
 
+/**
+ * cache_firmware - cache one firmware image in kernel memory space
+ * @fw_name: the firmware image name
+ *
+ * Cache firmware in kernel memory so that drivers can use it when
+ * system isn't ready for them to request firmware image from userspace.
+ * Once it returns successfully, driver can use request_firmware or its
+ * nowait version to get the cached firmware without any interacting
+ * with userspace
+ *
+ * Return 0 if the firmware image has been cached successfully
+ * Return !0 otherwise
+ *
+ */
+int cache_firmware(const char *fw_name)
+{
+	int ret;
+	const struct firmware *fw;
+
+	pr_debug("%s: %s\n", __func__, fw_name);
+
+	ret = request_firmware(&fw, fw_name, NULL);
+	if (!ret)
+		kfree(fw);
+
+	pr_debug("%s: %s ret=%d\n", __func__, fw_name, ret);
+
+	return ret;
+}
+
+/**
+ * uncache_firmware - remove one cached firmware image
+ * @fw_name: the firmware image name
+ *
+ * Uncache one firmware image which has been cached successfully
+ * before.
+ *
+ * Return 0 if the firmware cache has been removed successfully
+ * Return !0 otherwise
+ *
+ */
+int uncache_firmware(const char *fw_name)
+{
+	struct firmware_buf *buf;
+	struct firmware fw;
+
+	pr_debug("%s: %s\n", __func__, fw_name);
+
+	if (fw_get_builtin_firmware(&fw, fw_name))
+		return 0;
+
+	buf = fw_lookup_buf(fw_name);
+	if (buf) {
+		fw_free_buf(buf);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static struct fw_cache_entry *alloc_fw_cache_entry(const char *name)
+{
+	struct fw_cache_entry *fce;
+
+	fce = kzalloc(sizeof(*fce) + strlen(name) + 1, GFP_ATOMIC);
+	if (!fce)
+		goto exit;
+
+	strcpy(fce->name, name);
+exit:
+	return fce;
+}
+
+static int __fw_entry_found(const char *name)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+
+	list_for_each_entry(fce, &fwc->fw_names, list) {
+		if (!strcmp(fce->name, name))
+			return 1;
+	}
+	return 0;
+}
+
+static int fw_cache_piggyback_on_request(const char *name)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+	int ret = 0;
+
+	spin_lock(&fwc->name_lock);
+	if (__fw_entry_found(name))
+		goto found;
+
+	fce = alloc_fw_cache_entry(name);
+	if (fce) {
+		ret = 1;
+		list_add(&fce->list, &fwc->fw_names);
+		pr_debug("%s: fw: %s\n", __func__, name);
+	}
+found:
+	spin_unlock(&fwc->name_lock);
+	return ret;
+}
+
+static void free_fw_cache_entry(struct fw_cache_entry *fce)
+{
+	kfree(fce);
+}
+
+static void __async_dev_cache_fw_image(void *fw_entry,
+				       async_cookie_t cookie)
+{
+	struct fw_cache_entry *fce = fw_entry;
+	struct firmware_cache *fwc = &fw_cache;
+	int ret;
+
+	ret = cache_firmware(fce->name);
+	if (ret) {
+		spin_lock(&fwc->name_lock);
+		list_del(&fce->list);
+		spin_unlock(&fwc->name_lock);
+
+		free_fw_cache_entry(fce);
+	}
+
+	spin_lock(&fwc->name_lock);
+	fwc->cnt--;
+	spin_unlock(&fwc->name_lock);
+
+	wake_up(&fwc->wait_queue);
+}
+
+/* called with dev->devres_lock held */
+static void dev_create_fw_entry(struct device *dev, void *res,
+				void *data)
+{
+	struct fw_name_devm *fwn = res;
+	const char *fw_name = fwn->name;
+	struct list_head *head = data;
+	struct fw_cache_entry *fce;
+
+	fce = alloc_fw_cache_entry(fw_name);
+	if (fce)
+		list_add(&fce->list, head);
+}
+
+static int devm_name_match(struct device *dev, void *res,
+			   void *match_data)
+{
+	struct fw_name_devm *fwn = res;
+	return (fwn->magic == (unsigned long)match_data);
+}
+
+static void dev_cache_fw_image(struct device *dev, void *data)
+{
+	LIST_HEAD(todo);
+	struct fw_cache_entry *fce;
+	struct fw_cache_entry *fce_next;
+	struct firmware_cache *fwc = &fw_cache;
+
+	devres_for_each_res(dev, fw_name_devm_release,
+			    devm_name_match, &fw_cache,
+			    dev_create_fw_entry, &todo);
+
+	list_for_each_entry_safe(fce, fce_next, &todo, list) {
+		list_del(&fce->list);
+
+		spin_lock(&fwc->name_lock);
+		/* only one cache entry for one firmware */
+		if (!__fw_entry_found(fce->name)) {
+			fwc->cnt++;
+			list_add(&fce->list, &fwc->fw_names);
+		} else {
+			free_fw_cache_entry(fce);
+			fce = NULL;
+		}
+		spin_unlock(&fwc->name_lock);
+
+		if (fce)
+			async_schedule(__async_dev_cache_fw_image,
+				       (void *)fce);
+	}
+}
+
+static void __device_uncache_fw_images(void)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+
+	spin_lock(&fwc->name_lock);
+	while (!list_empty(&fwc->fw_names)) {
+		fce = list_entry(fwc->fw_names.next,
+				struct fw_cache_entry, list);
+		list_del(&fce->list);
+		spin_unlock(&fwc->name_lock);
+
+		uncache_firmware(fce->name);
+		free_fw_cache_entry(fce);
+
+		spin_lock(&fwc->name_lock);
+	}
+	spin_unlock(&fwc->name_lock);
+}
+
+/**
+ * device_cache_fw_images - cache devices' firmware
+ *
+ * If one device called request_firmware or its nowait version
+ * successfully before, the firmware names are recored into the
+ * device's devres link list, so device_cache_fw_images can call
+ * cache_firmware() to cache these firmwares for the device,
+ * then the device driver can load its firmwares easily at
+ * time when system is not ready to complete loading firmware.
+ */
+static void device_cache_fw_images(void)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	int old_timeout;
+	DEFINE_WAIT(wait);
+
+	pr_debug("%s\n", __func__);
+
+	/* cancel uncache work */
+	cancel_delayed_work_sync(&fwc->work);
+
+	/*
+	 * use small loading timeout for caching devices' firmware
+	 * because all these firmware images have been loaded
+	 * successfully at lease once, also system is ready for
+	 * completing firmware loading now. The maximum size of
+	 * firmware in current distributions is about 2M bytes,
+	 * so 10 secs should be enough.
+	 */
+	old_timeout = loading_timeout;
+	loading_timeout = 10;
+
+	mutex_lock(&fw_lock);
+	fwc->state = FW_LOADER_START_CACHE;
+	dpm_for_each_dev(NULL, dev_cache_fw_image);
+	mutex_unlock(&fw_lock);
+
+	/* wait for completion of caching firmware for all devices */
+	spin_lock(&fwc->name_lock);
+	for (;;) {
+		prepare_to_wait(&fwc->wait_queue, &wait,
+				TASK_UNINTERRUPTIBLE);
+		if (!fwc->cnt)
+			break;
+
+		spin_unlock(&fwc->name_lock);
+
+		schedule();
+
+		spin_lock(&fwc->name_lock);
+	}
+	spin_unlock(&fwc->name_lock);
+	finish_wait(&fwc->wait_queue, &wait);
+
+	loading_timeout = old_timeout;
+}
+
+/**
+ * device_uncache_fw_images - uncache devices' firmware
+ *
+ * uncache all firmwares which have been cached successfully
+ * by device_uncache_fw_images earlier
+ */
+static void device_uncache_fw_images(void)
+{
+	pr_debug("%s\n", __func__);
+	__device_uncache_fw_images();
+}
+
+static void device_uncache_fw_images_work(struct work_struct *work)
+{
+	device_uncache_fw_images();
+}
+
+/**
+ * device_uncache_fw_images_delay - uncache devices firmwares
+ * @delay: number of milliseconds to delay uncache device firmwares
+ *
+ * uncache all devices's firmwares which has been cached successfully
+ * by device_cache_fw_images after @delay milliseconds.
+ */
+static void device_uncache_fw_images_delay(unsigned long delay)
+{
+	schedule_delayed_work(&fw_cache.work,
+			msecs_to_jiffies(delay));
+}
+
+static int fw_pm_notify(struct notifier_block *notify_block,
+			unsigned long mode, void *unused)
+{
+	switch (mode) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		device_cache_fw_images();
+		break;
+
+	case PM_POST_SUSPEND:
+	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
+		/*
+		 * In case that system sleep failed and syscore_suspend is
+		 * not called.
+		 */
+		mutex_lock(&fw_lock);
+		fw_cache.state = FW_LOADER_NO_CACHE;
+		mutex_unlock(&fw_lock);
+
+		device_uncache_fw_images_delay(10 * MSEC_PER_SEC);
+		break;
+	}
+
+	return 0;
+}
+
+/* stop caching firmware once syscore_suspend is reached */
+static int fw_suspend(void)
+{
+	fw_cache.state = FW_LOADER_NO_CACHE;
+	return 0;
+}
+
+static struct syscore_ops fw_syscore_ops = {
+	.suspend = fw_suspend,
+};
+#else
+static int fw_cache_piggyback_on_request(const char *name)
+{
+	return 0;
+}
+#endif
+
+static void __init fw_cache_init(void)
+{
+	spin_lock_init(&fw_cache.lock);
+	INIT_LIST_HEAD(&fw_cache.head);
+	fw_cache.state = FW_LOADER_NO_CACHE;
+
+#ifdef CONFIG_PM_SLEEP
+	spin_lock_init(&fw_cache.name_lock);
+	INIT_LIST_HEAD(&fw_cache.fw_names);
+	fw_cache.cnt = 0;
+
+	init_waitqueue_head(&fw_cache.wait_queue);
+	INIT_DELAYED_WORK(&fw_cache.work,
+			  device_uncache_fw_images_work);
+
+	fw_cache.pm_notify.notifier_call = fw_pm_notify;
+	register_pm_notifier(&fw_cache.pm_notify);
+
+	register_syscore_ops(&fw_syscore_ops);
+#endif
+}
+
 static int __init firmware_class_init(void)
 {
+	fw_cache_init();
+#ifdef CONFIG_FW_LOADER_USER_HELPER
 	return class_register(&firmware_class);
+#else
+	return 0;
+#endif
 }
 
 static void __exit firmware_class_exit(void)
 {
+#ifdef CONFIG_PM_SLEEP
+	unregister_syscore_ops(&fw_syscore_ops);
+	unregister_pm_notifier(&fw_cache.pm_notify);
+#endif
+#ifdef CONFIG_FW_LOADER_USER_HELPER
 	class_unregister(&firmware_class);
+#endif
 }
 
 fs_initcall(firmware_class_init);
@@ -728,3 +1562,5 @@
 EXPORT_SYMBOL(release_firmware);
 EXPORT_SYMBOL(request_firmware);
 EXPORT_SYMBOL(request_firmware_nowait);
+EXPORT_SYMBOL_GPL(cache_firmware);
+EXPORT_SYMBOL_GPL(uncache_firmware);
diff -urN flo-ElementalX-5.00/drivers/base/genlock.c flo-ElementalX-5.00-patched/drivers/base/genlock.c
--- flo-ElementalX-5.00/drivers/base/genlock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/genlock.c	2016-06-03 17:13:57.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -712,6 +712,50 @@
 }
 EXPORT_SYMBOL(genlock_get_handle_fd);
 
+/*
+ * Get a file descriptor reference to a lock suitable for sharing with
+ * other processes
+ */
+
+int genlock_get_fd_handle(struct genlock_handle *handle)
+{
+	int ret;
+	struct genlock *lock;
+
+	if (IS_ERR_OR_NULL(handle))
+		return -EINVAL;
+
+	lock = handle->lock;
+
+	if (IS_ERR(lock))
+		return PTR_ERR(lock);
+
+	if (!lock->file) {
+		GENLOCK_LOG_ERR("No file attached to the lock\n");
+		return -EINVAL;
+	}
+
+	ret = get_unused_fd_flags(0);
+
+	if (ret < 0)
+		return ret;
+
+	fd_install(ret, lock->file);
+
+	/*
+	 * Taking a reference for lock file.
+	 * This is required as now we have two file descriptor
+	 * pointing to same file. If one FD is closed, lock file
+	 * will be closed. Taking this reference will make sure
+	 * that file doesn't get close. This refrence will go
+	 * when client will call close on this FD.
+	 */
+	fget(ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(genlock_get_fd_handle);
+
 #ifdef CONFIG_GENLOCK_MISCDEVICE
 
 static long genlock_dev_ioctl(struct file *filep, unsigned int cmd,
diff -urN flo-ElementalX-5.00/drivers/base/power/main.c flo-ElementalX-5.00-patched/drivers/base/power/main.c
--- flo-ElementalX-5.00/drivers/base/power/main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/power/main.c	2016-06-01 15:47:50.000000000 +0000
@@ -1370,3 +1370,25 @@
 	return async_error;
 }
 EXPORT_SYMBOL_GPL(device_pm_wait_for_dev);
+
+/**
+ * dpm_for_each_dev - device iterator.
+ * @data: data for the callback.
+ * @fn: function to be called for each device.
+ *
+ * Iterate over devices in dpm_list, and call @fn for each device,
+ * passing it @data.
+ */
+void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))
+{
+	struct device *dev;
+
+	if (!fn)
+		return;
+
+	device_pm_lock();
+	list_for_each_entry(dev, &dpm_list, power.entry)
+		fn(dev, data);
+	device_pm_unlock();
+}
+EXPORT_SYMBOL_GPL(dpm_for_each_dev);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/ath3k.c flo-ElementalX-5.00-patched/drivers/bluetooth/ath3k.c
--- flo-ElementalX-5.00/drivers/bluetooth/ath3k.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/ath3k.c	2016-06-02 00:28:55.000000000 +0000
@@ -30,6 +30,7 @@
 #include <net/bluetooth/bluetooth.h>
 
 #define VERSION "1.0"
+#define ATH3K_FIRMWARE	"ath3k-1.fw"
 
 #define ATH3K_DNLOAD				0x01
 #define ATH3K_GETSTATE				0x05
@@ -62,12 +63,23 @@
 
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0CF3, 0x3002) },
+	{ USB_DEVICE(0x13d3, 0x3304) },
+	{ USB_DEVICE(0x0930, 0x0215) },
+	{ USB_DEVICE(0x0489, 0xE03D) },
+	{ USB_DEVICE(0x0489, 0xE027) },
 
 	/* Atheros AR9285 Malbec with sflash firmware */
 	{ USB_DEVICE(0x03F0, 0x311D) },
 
 	/* Atheros AR3012 with sflash firmware*/
+	{ USB_DEVICE(0x0CF3, 0x0036) },
 	{ USB_DEVICE(0x0CF3, 0x3004) },
+	{ USB_DEVICE(0x0CF3, 0x311D) },
+	{ USB_DEVICE(0x0CF3, 0x817a) },
+	{ USB_DEVICE(0x13d3, 0x3375) },
+	{ USB_DEVICE(0x04CA, 0x3005) },
+	{ USB_DEVICE(0x13d3, 0x3362) },
+	{ USB_DEVICE(0x0CF3, 0xE004) },
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
@@ -83,7 +95,14 @@
 static struct usb_device_id ath3k_blist_tbl[] = {
 
 	/* Atheros AR3012 with sflash firmware*/
+	{ USB_DEVICE(0x0CF3, 0x0036), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311D), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0CF3, 0x817a), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 
 	{ }	/* Terminating entry */
 };
@@ -103,7 +122,7 @@
 
 	pipe = usb_sndctrlpipe(udev, 0);
 
-	send_buf = kmalloc(BULK_SIZE, GFP_ATOMIC);
+	send_buf = kmalloc(BULK_SIZE, GFP_KERNEL);
 	if (!send_buf) {
 		BT_ERR("Can't allocate memory chunk for firmware");
 		return -ENOMEM;
@@ -174,7 +193,7 @@
 
 	count = firmware->size;
 
-	send_buf = kmalloc(BULK_SIZE, GFP_ATOMIC);
+	send_buf = kmalloc(BULK_SIZE, GFP_KERNEL);
 	if (!send_buf) {
 		BT_ERR("Can't allocate memory chunk for firmware");
 		return -ENOMEM;
@@ -398,9 +417,15 @@
 		return 0;
 	}
 
-	if (request_firmware(&firmware, "ath3k-1.fw", &udev->dev) < 0) {
-		BT_ERR("Error loading firmware");
-		return -EIO;
+	ret = request_firmware(&firmware, ATH3K_FIRMWARE, &udev->dev);
+	if (ret < 0) {
+		if (ret == -ENOENT)
+			BT_ERR("Firmware file \"%s\" not found",
+							ATH3K_FIRMWARE);
+		else
+			BT_ERR("Firmware file \"%s\" request failed (err=%d)",
+							ATH3K_FIRMWARE, ret);
+		return ret;
 	}
 
 	ret = ath3k_load_firmware(udev, firmware);
@@ -421,22 +446,10 @@
 	.id_table	= ath3k_table,
 };
 
-static int __init ath3k_init(void)
-{
-	BT_INFO("Atheros AR30xx firmware driver ver %s", VERSION);
-	return usb_register(&ath3k_driver);
-}
-
-static void __exit ath3k_exit(void)
-{
-	usb_deregister(&ath3k_driver);
-}
-
-module_init(ath3k_init);
-module_exit(ath3k_exit);
+module_usb_driver(ath3k_driver);
 
 MODULE_AUTHOR("Atheros Communications");
 MODULE_DESCRIPTION("Atheros AR30xx firmware driver");
 MODULE_VERSION(VERSION);
 MODULE_LICENSE("GPL");
-MODULE_FIRMWARE("ath3k-1.fw");
+MODULE_FIRMWARE(ATH3K_FIRMWARE);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bcm203x.c flo-ElementalX-5.00-patched/drivers/bluetooth/bcm203x.c
--- flo-ElementalX-5.00/drivers/bluetooth/bcm203x.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bcm203x.c	2016-06-02 00:28:55.000000000 +0000
@@ -24,6 +24,7 @@
 
 #include <linux/module.h>
 
+#include <linux/atomic.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -65,6 +66,7 @@
 	unsigned long		state;
 
 	struct work_struct	work;
+	atomic_t		shutdown;
 
 	struct urb		*urb;
 	unsigned char		*buffer;
@@ -97,6 +99,7 @@
 
 		data->state = BCM203X_SELECT_MEMORY;
 
+		/* use workqueue to have a small delay */
 		schedule_work(&data->work);
 		break;
 
@@ -155,7 +158,10 @@
 	struct bcm203x_data *data =
 		container_of(work, struct bcm203x_data, work);
 
-	if (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)
+	if (atomic_read(&data->shutdown))
+		return;
+
+	if (usb_submit_urb(data->urb, GFP_KERNEL) < 0)
 		BT_ERR("Can't submit URB");
 }
 
@@ -243,6 +249,7 @@
 
 	usb_set_intfdata(intf, data);
 
+	/* use workqueue to have a small delay */
 	schedule_work(&data->work);
 
 	return 0;
@@ -254,6 +261,9 @@
 
 	BT_DBG("intf %p", intf);
 
+	atomic_inc(&data->shutdown);
+	cancel_work_sync(&data->work);
+
 	usb_kill_urb(data->urb);
 
 	usb_set_intfdata(intf, NULL);
@@ -271,26 +281,7 @@
 	.id_table	= bcm203x_table,
 };
 
-static int __init bcm203x_init(void)
-{
-	int err;
-
-	BT_INFO("Broadcom Blutonium firmware driver ver %s", VERSION);
-
-	err = usb_register(&bcm203x_driver);
-	if (err < 0)
-		BT_ERR("Failed to register USB driver");
-
-	return err;
-}
-
-static void __exit bcm203x_exit(void)
-{
-	usb_deregister(&bcm203x_driver);
-}
-
-module_init(bcm203x_init);
-module_exit(bcm203x_exit);
+module_usb_driver(bcm203x_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Broadcom Blutonium firmware driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bfusb.c flo-ElementalX-5.00-patched/drivers/bluetooth/bfusb.c
--- flo-ElementalX-5.00/drivers/bluetooth/bfusb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bfusb.c	2016-06-02 00:28:55.000000000 +0000
@@ -411,7 +411,7 @@
 
 static int bfusb_open(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 	unsigned long flags;
 	int i, err;
 
@@ -437,7 +437,7 @@
 
 static int bfusb_flush(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("hdev %p bfusb %p", hdev, data);
 
@@ -448,7 +448,7 @@
 
 static int bfusb_close(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 	unsigned long flags;
 
 	BT_DBG("hdev %p bfusb %p", hdev, data);
@@ -483,7 +483,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	data = hdev->driver_data;
+	data = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -544,15 +544,6 @@
 	return 0;
 }
 
-static void bfusb_destruct(struct hci_dev *hdev)
-{
-	struct bfusb_data *data = hdev->driver_data;
-
-	BT_DBG("hdev %p bfusb %p", hdev, data);
-
-	kfree(data);
-}
-
 static int bfusb_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -568,22 +559,23 @@
 
 	BT_INFO("BlueFRITZ! USB loading firmware");
 
+	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_KERNEL);
+	if (!buf) {
+		BT_ERR("Can't allocate memory chunk for firmware");
+		return -ENOMEM;
+	}
+
 	pipe = usb_sndctrlpipe(data->udev, 0);
 
 	if (usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,
 				0, 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT) < 0) {
 		BT_ERR("Can't change to loading configuration");
+		kfree(buf);
 		return -EBUSY;
 	}
 
 	data->udev->toggle[0] = data->udev->toggle[1] = 0;
 
-	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_ATOMIC);
-	if (!buf) {
-		BT_ERR("Can't allocate memory chunk for firmware");
-		return -ENOMEM;
-	}
-
 	pipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);
 
 	while (count) {
@@ -704,18 +696,15 @@
 	data->hdev = hdev;
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 	SET_HCIDEV_DEV(hdev, &intf->dev);
 
 	hdev->open     = bfusb_open;
 	hdev->close    = bfusb_close;
 	hdev->flush    = bfusb_flush;
 	hdev->send     = bfusb_send_frame;
-	hdev->destruct = bfusb_destruct;
 	hdev->ioctl    = bfusb_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
@@ -750,10 +739,9 @@
 
 	bfusb_close(hdev);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 static struct usb_driver bfusb_driver = {
@@ -763,26 +751,7 @@
 	.id_table	= bfusb_table,
 };
 
-static int __init bfusb_init(void)
-{
-	int err;
-
-	BT_INFO("BlueFRITZ! USB driver ver %s", VERSION);
-
-	err = usb_register(&bfusb_driver);
-	if (err < 0)
-		BT_ERR("Failed to register BlueFRITZ! USB driver");
-
-	return err;
-}
-
-static void __exit bfusb_exit(void)
-{
-	usb_deregister(&bfusb_driver);
-}
-
-module_init(bfusb_init);
-module_exit(bfusb_exit);
+module_usb_driver(bfusb_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("BlueFRITZ! USB driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bluecard_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/bluecard_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/bluecard_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bluecard_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -561,7 +561,7 @@
 
 static int bluecard_hci_set_baud_rate(struct hci_dev *hdev, int baud)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	struct sk_buff *skb;
 
 	/* Ericsson baud rate command */
@@ -609,7 +609,7 @@
 
 static int bluecard_hci_flush(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -620,7 +620,7 @@
 
 static int bluecard_hci_open(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	unsigned int iobase = info->p_dev->resource[0]->start;
 
 	if (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))
@@ -640,7 +640,7 @@
 
 static int bluecard_hci_close(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	unsigned int iobase = info->p_dev->resource[0]->start;
 
 	if (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))
@@ -667,7 +667,7 @@
 		return -ENODEV;
 	}
 
-	info = (bluecard_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -691,11 +691,6 @@
 }
 
 
-static void bluecard_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int bluecard_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -734,18 +729,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = bluecard_hci_open;
 	hdev->close    = bluecard_hci_close;
 	hdev->flush    = bluecard_hci_flush;
 	hdev->send     = bluecard_hci_send_frame;
-	hdev->destruct = bluecard_hci_destruct;
 	hdev->ioctl    = bluecard_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	id = inb(iobase + 0x30);
 
 	if ((id & 0x0f) == 0x02)
@@ -844,9 +836,7 @@
 	/* Turn FPGA off */
 	outb(0x80, iobase + 0x30);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -930,7 +920,7 @@
 	pcmcia_disable_device(link);
 }
 
-static struct pcmcia_device_id bluecard_ids[] = {
+static const struct pcmcia_device_id bluecard_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("BlueCard", "LSE041", 0xbaf16fbf, 0x657cc15e),
 	PCMCIA_DEVICE_PROD_ID12("BTCFCARD", "LSE139", 0xe3987764, 0x2524b59c),
 	PCMCIA_DEVICE_PROD_ID12("WSS", "LSE039", 0x0a0736ec, 0x24e6dfab),
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bluesleep.c flo-ElementalX-5.00-patched/drivers/bluetooth/bluesleep.c
--- flo-ElementalX-5.00/drivers/bluetooth/bluesleep.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bluesleep.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,757 +0,0 @@
-/*
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 as
-   published by the Free Software Foundation.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-   This program is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-
-   Copyright (C) 2006-2007 - Motorola
-   Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
-
-   Date         Author           Comment
-   -----------  --------------   --------------------------------
-   2006-Apr-28	Motorola	 The kernel module for running the Bluetooth(R)
-				 Sleep-Mode Protocol from the Host side
-   2006-Sep-08  Motorola         Added workqueue for handling sleep work.
-   2007-Jan-24  Motorola         Added mbm_handle_ioi() call to ISR.
-
-*/
-
-#include <linux/module.h>	/* kernel module definitions */
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/notifier.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-#include <linux/uaccess.h>
-#include <linux/version.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-
-#include <linux/irq.h>
-#include <linux/param.h>
-#include <linux/bitops.h>
-#include <linux/termios.h>
-#include <mach/gpio.h>
-#include <mach/msm_serial_hs.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h> /* event notifications */
-#include "hci_uart.h"
-
-#define BT_SLEEP_DBG
-#ifndef BT_SLEEP_DBG
-#define BT_DBG(fmt, arg...)
-#endif
-/*
- * Defines
- */
-
-#define VERSION		"1.1"
-#define PROC_DIR	"bluetooth/sleep"
-
-struct bluesleep_info {
-	unsigned host_wake;
-	unsigned ext_wake;
-	unsigned host_wake_irq;
-	struct uart_port *uport;
-};
-
-/* work function */
-static void bluesleep_sleep_work(struct work_struct *work);
-
-/* work queue */
-DECLARE_DELAYED_WORK(sleep_workqueue, bluesleep_sleep_work);
-
-/* Macros for handling sleep work */
-#define bluesleep_rx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_tx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_rx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
-
-/* 1 second timeout */
-#define TX_TIMER_INTERVAL	1
-
-/* state variable names and bit positions */
-#define BT_PROTO	0x01
-#define BT_TXDATA	0x02
-#define BT_ASLEEP	0x04
-
-/* global pointer to a single hci device. */
-static struct hci_dev *bluesleep_hdev;
-
-static struct bluesleep_info *bsi;
-
-/* module usage */
-static atomic_t open_count = ATOMIC_INIT(1);
-
-/*
- * Local function prototypes
- */
-
-static int bluesleep_hci_event(struct notifier_block *this,
-			    unsigned long event, void *data);
-
-/*
- * Global variables
- */
-
-/** Global state flags */
-static unsigned long flags;
-
-/** Tasklet to respond to change in hostwake line */
-static struct tasklet_struct hostwake_task;
-
-/** Transmission timer */
-static struct timer_list tx_timer;
-
-/** Lock for state transitions */
-static spinlock_t rw_lock;
-
-/** Notifier block for HCI events */
-struct notifier_block hci_event_nblock = {
-	.notifier_call = bluesleep_hci_event,
-};
-
-struct proc_dir_entry *bluetooth_dir, *sleep_dir;
-
-/*
- * Local functions
- */
-
-static void hsuart_power(int on)
-{
-	if (on) {
-		msm_hs_request_clock_on(bsi->uport);
-		msm_hs_set_mctrl(bsi->uport, TIOCM_RTS);
-	} else {
-		msm_hs_set_mctrl(bsi->uport, 0);
-		msm_hs_request_clock_off(bsi->uport);
-	}
-}
-
-
-/**
- * @return 1 if the Host can go to sleep, 0 otherwise.
- */
-static inline int bluesleep_can_sleep(void)
-{
-	/* check if MSM_WAKE_BT_GPIO and BT_WAKE_MSM_GPIO are both deasserted */
-	return gpio_get_value(bsi->ext_wake) &&
-		gpio_get_value(bsi->host_wake) &&
-		(bsi->uport != NULL);
-}
-
-void bluesleep_sleep_wakeup(void)
-{
-	if (test_bit(BT_ASLEEP, &flags)) {
-		BT_DBG("waking up...");
-		/* Start the timer */
-		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-		gpio_set_value(bsi->ext_wake, 0);
-		clear_bit(BT_ASLEEP, &flags);
-		/*Activating UART */
-		hsuart_power(1);
-	}
-}
-
-/**
- * @brief@  main sleep work handling function which update the flags
- * and activate and deactivate UART ,check FIFO.
- */
-static void bluesleep_sleep_work(struct work_struct *work)
-{
-	if (bluesleep_can_sleep()) {
-		/* already asleep, this is an error case */
-		if (test_bit(BT_ASLEEP, &flags)) {
-			BT_DBG("already asleep");
-			return;
-		}
-
-		if (msm_hs_tx_empty(bsi->uport)) {
-			BT_DBG("going to sleep...");
-			set_bit(BT_ASLEEP, &flags);
-			/*Deactivating UART */
-			hsuart_power(0);
-		} else {
-
-		  mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-			return;
-		}
-	} else {
-		bluesleep_sleep_wakeup();
-	}
-}
-
-/**
- * A tasklet function that runs in tasklet context and reads the value
- * of the HOST_WAKE GPIO pin and further defer the work.
- * @param data Not used.
- */
-static void bluesleep_hostwake_task(unsigned long data)
-{
-	BT_DBG("hostwake line change");
-
-	spin_lock(&rw_lock);
-
-	if (gpio_get_value(bsi->host_wake))
-		bluesleep_rx_busy();
-	else
-		bluesleep_rx_idle();
-
-	spin_unlock(&rw_lock);
-}
-
-/**
- * Handles proper timer action when outgoing data is delivered to the
- * HCI line discipline. Sets BT_TXDATA.
- */
-static void bluesleep_outgoing_data(void)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	/* log data passing by */
-	set_bit(BT_TXDATA, &flags);
-
-	/* if the tx side is sleeping... */
-	if (gpio_get_value(bsi->ext_wake)) {
-
-		BT_DBG("tx was sleeping");
-		bluesleep_sleep_wakeup();
-	}
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-}
-
-/**
- * Handles HCI device events.
- * @param this Not used.
- * @param event The event that occurred.
- * @param data The HCI device associated with the event.
- * @return <code>NOTIFY_DONE</code>.
- */
-static int bluesleep_hci_event(struct notifier_block *this,
-				unsigned long event, void *data)
-{
-	struct hci_dev *hdev = (struct hci_dev *) data;
-	struct hci_uart *hu;
-	struct uart_state *state;
-
-	if (!hdev)
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case HCI_DEV_REG:
-		if (!bluesleep_hdev) {
-			bluesleep_hdev = hdev;
-			hu  = (struct hci_uart *) hdev->driver_data;
-			state = (struct uart_state *) hu->tty->driver_data;
-			bsi->uport = state->uart_port;
-		}
-		break;
-	case HCI_DEV_UNREG:
-		bluesleep_hdev = NULL;
-		bsi->uport = NULL;
-		break;
-	case HCI_DEV_WRITE:
-		bluesleep_outgoing_data();
-		break;
-	}
-
-	return NOTIFY_DONE;
-}
-
-/**
- * Handles transmission timer expiration.
- * @param data Not used.
- */
-static void bluesleep_tx_timer_expire(unsigned long data)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	BT_DBG("Tx timer expired");
-
-	/* were we silent during the last timeout? */
-	if (!test_bit(BT_TXDATA, &flags)) {
-		BT_DBG("Tx has been idle");
-		gpio_set_value(bsi->ext_wake, 1);
-		bluesleep_tx_idle();
-	} else {
-		BT_DBG("Tx data during last period");
-		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
-	}
-
-	/* clear the incoming data flag */
-	clear_bit(BT_TXDATA, &flags);
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-}
-
-/**
- * Schedules a tasklet to run when receiving an interrupt on the
- * <code>HOST_WAKE</code> GPIO pin.
- * @param irq Not used.
- * @param dev_id Not used.
- */
-static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
-{
-	/* schedule a tasklet to handle the change in the host wake line */
-	tasklet_schedule(&hostwake_task);
-	return IRQ_HANDLED;
-}
-
-/**
- * Starts the Sleep-Mode Protocol on the Host.
- * @return On success, 0. On error, -1, and <code>errno</code> is set
- * appropriately.
- */
-static int bluesleep_start(void)
-{
-	int retval;
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	if (test_bit(BT_PROTO, &flags)) {
-		spin_unlock_irqrestore(&rw_lock, irq_flags);
-		return 0;
-	}
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-
-	if (!atomic_dec_and_test(&open_count)) {
-		atomic_inc(&open_count);
-		return -EBUSY;
-	}
-
-	/* start the timer */
-
-	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
-
-	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
-	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-				"bluetooth hostwake", NULL);
-	if (retval  < 0) {
-		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
-		goto fail;
-	}
-
-	retval = enable_irq_wake(bsi->host_wake_irq);
-	if (retval < 0) {
-		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
-		free_irq(bsi->host_wake_irq, NULL);
-		goto fail;
-	}
-
-	set_bit(BT_PROTO, &flags);
-	return 0;
-fail:
-	del_timer(&tx_timer);
-	atomic_inc(&open_count);
-
-	return retval;
-}
-
-/**
- * Stops the Sleep-Mode Protocol on the Host.
- */
-static void bluesleep_stop(void)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	if (!test_bit(BT_PROTO, &flags)) {
-		spin_unlock_irqrestore(&rw_lock, irq_flags);
-		return;
-	}
-
-	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
-	del_timer(&tx_timer);
-	clear_bit(BT_PROTO, &flags);
-
-	if (test_bit(BT_ASLEEP, &flags)) {
-		clear_bit(BT_ASLEEP, &flags);
-		hsuart_power(1);
-	}
-
-	atomic_inc(&open_count);
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-	if (disable_irq_wake(bsi->host_wake_irq))
-		BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-	free_irq(bsi->host_wake_irq, NULL);
-}
-/**
- * Read the <code>BT_WAKE</code> GPIO pin value via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the
- * pin is high, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	*eof = 1;
-	return sprintf(page, "btwake:%u\n", gpio_get_value(bsi->ext_wake));
-}
-
-/**
- * Write the <code>BT_WAKE</code> GPIO pin value via the proc interface.
- * @param file Not used.
- * @param buffer The buffer to read from.
- * @param count The number of bytes to be written.
- * @param data Not used.
- * @return On success, the number of bytes written. On error, -1, and
- * <code>errno</code> is set appropriately.
- */
-static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
-					unsigned long count, void *data)
-{
-	char *buf;
-
-	if (count < 1)
-		return -EINVAL;
-
-	buf = kmalloc(count, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (copy_from_user(buf, buffer, count)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-
-	if (buf[0] == '0') {
-		gpio_set_value(bsi->ext_wake, 0);
-	} else if (buf[0] == '1') {
-		gpio_set_value(bsi->ext_wake, 1);
-	} else {
-		kfree(buf);
-		return -EINVAL;
-	}
-
-	kfree(buf);
-	return count;
-}
-
-/**
- * Read the <code>BT_HOST_WAKE</code> GPIO pin value via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the pin
- * is high, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluepower_read_proc_hostwake(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	*eof = 1;
-	return sprintf(page, "hostwake: %u \n", gpio_get_value(bsi->host_wake));
-}
-
-
-/**
- * Read the low-power status of the Host via the proc interface.
- * When this function returns, <code>page</code> contains a 1 if the Host
- * is asleep, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluesleep_read_proc_asleep(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	unsigned int asleep;
-
-	asleep = test_bit(BT_ASLEEP, &flags) ? 1 : 0;
-	*eof = 1;
-	return sprintf(page, "asleep: %u\n", asleep);
-}
-
-/**
- * Read the low-power protocol being used by the Host via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the Host
- * is using the Sleep Mode Protocol, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluesleep_read_proc_proto(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	unsigned int proto;
-
-	proto = test_bit(BT_PROTO, &flags) ? 1 : 0;
-	*eof = 1;
-	return sprintf(page, "proto: %u\n", proto);
-}
-
-/**
- * Modify the low-power protocol used by the Host via the proc interface.
- * @param file Not used.
- * @param buffer The buffer to read from.
- * @param count The number of bytes to be written.
- * @param data Not used.
- * @return On success, the number of bytes written. On error, -1, and
- * <code>errno</code> is set appropriately.
- */
-static int bluesleep_write_proc_proto(struct file *file, const char *buffer,
-					unsigned long count, void *data)
-{
-	char proto;
-
-	if (count < 1)
-		return -EINVAL;
-
-	if (copy_from_user(&proto, buffer, 1))
-		return -EFAULT;
-
-	if (proto == '0')
-		bluesleep_stop();
-	else
-		bluesleep_start();
-
-	/* claim that we wrote everything */
-	return count;
-}
-
-static int __init bluesleep_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-
-	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
-	if (!bsi)
-		return -ENOMEM;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-				"gpio_host_wake");
-	if (!res) {
-		BT_ERR("couldn't find host_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->host_wake = res->start;
-
-	ret = gpio_request(bsi->host_wake, "bt_host_wake");
-	if (ret)
-		goto free_bsi;
-	ret = gpio_direction_input(bsi->host_wake);
-	if (ret)
-		goto free_bt_host_wake;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-				"gpio_ext_wake");
-	if (!res) {
-		BT_ERR("couldn't find ext_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bt_host_wake;
-	}
-	bsi->ext_wake = res->start;
-
-	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
-	if (ret)
-		goto free_bt_host_wake;
-	/* assert bt wake */
-	ret = gpio_direction_output(bsi->ext_wake, 0);
-	if (ret)
-		goto free_bt_ext_wake;
-
-	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
-	if (bsi->host_wake_irq < 0) {
-		BT_ERR("couldn't find host_wake irq\n");
-		ret = -ENODEV;
-		goto free_bt_ext_wake;
-	}
-
-
-	return 0;
-
-free_bt_ext_wake:
-	gpio_free(bsi->ext_wake);
-free_bt_host_wake:
-	gpio_free(bsi->host_wake);
-free_bsi:
-	kfree(bsi);
-	return ret;
-}
-
-static int bluesleep_remove(struct platform_device *pdev)
-{
-	/* assert bt wake */
-	gpio_set_value(bsi->ext_wake, 0);
-	if (test_bit(BT_PROTO, &flags)) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode \n");
-		free_irq(bsi->host_wake_irq, NULL);
-		del_timer(&tx_timer);
-		if (test_bit(BT_ASLEEP, &flags))
-			hsuart_power(1);
-	}
-
-	gpio_free(bsi->host_wake);
-	gpio_free(bsi->ext_wake);
-	kfree(bsi);
-	return 0;
-}
-
-static struct platform_driver bluesleep_driver = {
-	.remove = bluesleep_remove,
-	.driver = {
-		.name = "bluesleep",
-		.owner = THIS_MODULE,
-	},
-};
-/**
- * Initializes the module.
- * @return On success, 0. On error, -1, and <code>errno</code> is set
- * appropriately.
- */
-static int __init bluesleep_init(void)
-{
-	int retval;
-	struct proc_dir_entry *ent;
-
-	BT_INFO("MSM Sleep Mode Driver Ver %s", VERSION);
-
-	retval = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
-	if (retval)
-		return retval;
-
-	bluesleep_hdev = NULL;
-
-	bluetooth_dir = proc_mkdir("bluetooth", NULL);
-	if (bluetooth_dir == NULL) {
-		BT_ERR("Unable to create /proc/bluetooth directory");
-		return -ENOMEM;
-	}
-
-	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
-	if (sleep_dir == NULL) {
-		BT_ERR("Unable to create /proc/%s directory", PROC_DIR);
-		return -ENOMEM;
-	}
-
-	/* Creating read/write "btwake" entry */
-	ent = create_proc_entry("btwake", 0, sleep_dir);
-	if (ent == NULL) {
-		BT_ERR("Unable to create /proc/%s/btwake entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-	ent->read_proc = bluepower_read_proc_btwake;
-	ent->write_proc = bluepower_write_proc_btwake;
-
-	/* read only proc entries */
-	if (create_proc_read_entry("hostwake", 0, sleep_dir,
-				bluepower_read_proc_hostwake, NULL) == NULL) {
-		BT_ERR("Unable to create /proc/%s/hostwake entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-
-	/* read/write proc entries */
-	ent = create_proc_entry("proto", 0, sleep_dir);
-	if (ent == NULL) {
-		BT_ERR("Unable to create /proc/%s/proto entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-	ent->read_proc = bluesleep_read_proc_proto;
-	ent->write_proc = bluesleep_write_proc_proto;
-
-	/* read only proc entries */
-	if (create_proc_read_entry("asleep", 0,
-			sleep_dir, bluesleep_read_proc_asleep, NULL) == NULL) {
-		BT_ERR("Unable to create /proc/%s/asleep entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-
-	flags = 0; /* clear all status bits */
-
-	/* Initialize spinlock. */
-	spin_lock_init(&rw_lock);
-
-	/* Initialize timer */
-	init_timer(&tx_timer);
-	tx_timer.function = bluesleep_tx_timer_expire;
-	tx_timer.data = 0;
-
-	/* initialize host wake tasklet */
-	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
-
-	hci_register_notifier(&hci_event_nblock);
-
-	return 0;
-
-fail:
-	remove_proc_entry("asleep", sleep_dir);
-	remove_proc_entry("proto", sleep_dir);
-	remove_proc_entry("hostwake", sleep_dir);
-	remove_proc_entry("btwake", sleep_dir);
-	remove_proc_entry("sleep", bluetooth_dir);
-	remove_proc_entry("bluetooth", 0);
-	return retval;
-}
-
-/**
- * Cleans up the module.
- */
-static void __exit bluesleep_exit(void)
-{
-	hci_unregister_notifier(&hci_event_nblock);
-	platform_driver_unregister(&bluesleep_driver);
-
-	remove_proc_entry("asleep", sleep_dir);
-	remove_proc_entry("proto", sleep_dir);
-	remove_proc_entry("hostwake", sleep_dir);
-	remove_proc_entry("btwake", sleep_dir);
-	remove_proc_entry("sleep", bluetooth_dir);
-	remove_proc_entry("bluetooth", 0);
-}
-
-module_init(bluesleep_init);
-module_exit(bluesleep_exit);
-
-MODULE_DESCRIPTION("Bluetooth Sleep Mode Driver ver %s " VERSION);
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("GPL");
-#endif
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bpa10x.c flo-ElementalX-5.00-patched/drivers/bluetooth/bpa10x.c
--- flo-ElementalX-5.00/drivers/bluetooth/bpa10x.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bpa10x.c	2016-06-02 00:28:55.000000000 +0000
@@ -66,7 +66,7 @@
 
 static int bpa10x_recv(struct hci_dev *hdev, int queue, void *buf, int count)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s queue %d buffer %p count %d", hdev->name,
 							queue, buf, count);
@@ -189,7 +189,7 @@
 static void bpa10x_rx_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -219,7 +219,7 @@
 
 static inline int bpa10x_submit_intr_urb(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -260,7 +260,7 @@
 
 static inline int bpa10x_submit_bulk_urb(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -301,7 +301,7 @@
 
 static int bpa10x_open(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -329,7 +329,7 @@
 
 static int bpa10x_close(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -343,7 +343,7 @@
 
 static int bpa10x_flush(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -355,7 +355,7 @@
 static int bpa10x_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct usb_ctrlrequest *dr;
 	struct urb *urb;
 	unsigned int pipe;
@@ -432,17 +432,6 @@
 	return 0;
 }
 
-static void bpa10x_destruct(struct hci_dev *hdev)
-{
-	struct bpa10x_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree_skb(data->rx_skb[0]);
-	kfree_skb(data->rx_skb[1]);
-	kfree(data);
-}
-
 static int bpa10x_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct bpa10x_data *data;
@@ -470,7 +459,7 @@
 	}
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	data->hdev = hdev;
 
@@ -480,9 +469,6 @@
 	hdev->close    = bpa10x_close;
 	hdev->flush    = bpa10x_flush;
 	hdev->send     = bpa10x_send_frame;
-	hdev->destruct = bpa10x_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	set_bit(HCI_QUIRK_NO_RESET, &hdev->quirks);
 
@@ -512,6 +498,9 @@
 	hci_unregister_dev(data->hdev);
 
 	hci_free_dev(data->hdev);
+	kfree_skb(data->rx_skb[0]);
+	kfree_skb(data->rx_skb[1]);
+	kfree(data);
 }
 
 static struct usb_driver bpa10x_driver = {
@@ -521,20 +510,7 @@
 	.id_table	= bpa10x_table,
 };
 
-static int __init bpa10x_init(void)
-{
-	BT_INFO("Digianswer Bluetooth USB driver ver %s", VERSION);
-
-	return usb_register(&bpa10x_driver);
-}
-
-static void __exit bpa10x_exit(void)
-{
-	usb_deregister(&bpa10x_driver);
-}
-
-module_init(bpa10x_init);
-module_exit(bpa10x_exit);
+module_usb_driver(bpa10x_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Digianswer Bluetooth USB driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bt3c_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/bt3c_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/bt3c_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bt3c_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -39,7 +39,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <linux/device.h>
@@ -389,7 +388,7 @@
 
 static int bt3c_hci_flush(struct hci_dev *hdev)
 {
-	bt3c_info_t *info = (bt3c_info_t *)(hdev->driver_data);
+	bt3c_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -428,7 +427,7 @@
 		return -ENODEV;
 	}
 
-	info = (bt3c_info_t *) (hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -456,11 +455,6 @@
 }
 
 
-static void bt3c_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int bt3c_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -580,18 +574,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = bt3c_hci_open;
 	hdev->close    = bt3c_hci_close;
 	hdev->flush    = bt3c_hci_flush;
 	hdev->send     = bt3c_hci_send_frame;
-	hdev->destruct = bt3c_hci_destruct;
 	hdev->ioctl    = bt3c_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	/* Load firmware */
 	err = request_firmware(&firmware, "BT3CPCC.bin", &info->p_dev->dev);
 	if (err < 0) {
@@ -636,9 +627,7 @@
 
 	bt3c_hci_close(hdev);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -761,7 +750,7 @@
 }
 
 
-static struct pcmcia_device_id bt3c_ids[] = {
+static const struct pcmcia_device_id bt3c_ids[] = {
 	PCMCIA_DEVICE_PROD_ID13("3COM", "Bluetooth PC Card", 0xefce0a31, 0xd4ce9b02),
 	PCMCIA_DEVICE_NULL
 };
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_debugfs.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_debugfs.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_debugfs.c	2016-06-02 00:28:55.000000000 +0000
@@ -45,12 +45,6 @@
 	struct dentry *txdnldready;
 };
 
-static int btmrvl_open_generic(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
 static ssize_t btmrvl_hscfgcmd_write(struct file *file,
 			const char __user *ubuf, size_t count, loff_t *ppos)
 {
@@ -64,6 +58,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hscfgcmd = result;
 
@@ -91,7 +87,7 @@
 static const struct file_operations btmrvl_hscfgcmd_fops = {
 	.read	= btmrvl_hscfgcmd_read,
 	.write	= btmrvl_hscfgcmd_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -108,6 +104,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.psmode = result;
 
@@ -130,7 +128,7 @@
 static const struct file_operations btmrvl_psmode_fops = {
 	.read	= btmrvl_psmode_read,
 	.write	= btmrvl_psmode_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -147,6 +145,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.pscmd = result;
 
@@ -174,7 +174,7 @@
 static const struct file_operations btmrvl_pscmd_fops = {
 	.read = btmrvl_pscmd_read,
 	.write = btmrvl_pscmd_write,
-	.open = btmrvl_open_generic,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -191,6 +191,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 16, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.gpio_gap = result;
 
@@ -213,7 +215,7 @@
 static const struct file_operations btmrvl_gpiogap_fops = {
 	.read	= btmrvl_gpiogap_read,
 	.write	= btmrvl_gpiogap_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -230,6 +232,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hscmd = result;
 	if (priv->btmrvl_dev.hscmd) {
@@ -255,7 +259,7 @@
 static const struct file_operations btmrvl_hscmd_fops = {
 	.read	= btmrvl_hscmd_read,
 	.write	= btmrvl_hscmd_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -272,6 +276,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hsmode = result;
 
@@ -293,7 +299,7 @@
 static const struct file_operations btmrvl_hsmode_fops = {
 	.read	= btmrvl_hsmode_read,
 	.write	= btmrvl_hsmode_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -311,7 +317,7 @@
 
 static const struct file_operations btmrvl_curpsmode_fops = {
 	.read	= btmrvl_curpsmode_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -329,7 +335,7 @@
 
 static const struct file_operations btmrvl_psstate_fops = {
 	.read	= btmrvl_psstate_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -347,7 +353,7 @@
 
 static const struct file_operations btmrvl_hsstate_fops = {
 	.read	= btmrvl_hsstate_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -366,13 +372,13 @@
 
 static const struct file_operations btmrvl_txdnldready_fops = {
 	.read	= btmrvl_txdnldready_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
 void btmrvl_debugfs_init(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 	struct btmrvl_debugfs_data *dbg;
 
 	if (!hdev->debugfs)
@@ -389,36 +395,34 @@
 	dbg->config_dir = debugfs_create_dir("config", hdev->debugfs);
 
 	dbg->psmode = debugfs_create_file("psmode", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_psmode_fops);
+					  priv, &btmrvl_psmode_fops);
 	dbg->pscmd = debugfs_create_file("pscmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_pscmd_fops);
+					 priv, &btmrvl_pscmd_fops);
 	dbg->gpiogap = debugfs_create_file("gpiogap", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_gpiogap_fops);
+					   priv, &btmrvl_gpiogap_fops);
 	dbg->hsmode =  debugfs_create_file("hsmode", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hsmode_fops);
+					   priv, &btmrvl_hsmode_fops);
 	dbg->hscmd = debugfs_create_file("hscmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hscmd_fops);
+					 priv, &btmrvl_hscmd_fops);
 	dbg->hscfgcmd = debugfs_create_file("hscfgcmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hscfgcmd_fops);
+					    priv, &btmrvl_hscfgcmd_fops);
 
 	dbg->status_dir = debugfs_create_dir("status", hdev->debugfs);
 	dbg->curpsmode = debugfs_create_file("curpsmode", 0444,
-						dbg->status_dir,
-						hdev->driver_data,
-						&btmrvl_curpsmode_fops);
+					     dbg->status_dir, priv,
+					     &btmrvl_curpsmode_fops);
 	dbg->psstate = debugfs_create_file("psstate", 0444, dbg->status_dir,
-				hdev->driver_data, &btmrvl_psstate_fops);
+					   priv, &btmrvl_psstate_fops);
 	dbg->hsstate = debugfs_create_file("hsstate", 0444, dbg->status_dir,
-				hdev->driver_data, &btmrvl_hsstate_fops);
+					   priv, &btmrvl_hsstate_fops);
 	dbg->txdnldready = debugfs_create_file("txdnldready", 0444,
-						dbg->status_dir,
-						hdev->driver_data,
-						&btmrvl_txdnldready_fops);
+					       dbg->status_dir, priv,
+					       &btmrvl_txdnldready_fops);
 }
 
 void btmrvl_debugfs_remove(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 	struct btmrvl_debugfs_data *dbg = priv->debugfs_data;
 
 	if (!dbg)
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_main.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_main.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_main.c	2016-06-02 00:28:55.000000000 +0000
@@ -18,6 +18,8 @@
  * this warranty disclaimer.
  **/
 
+#include <linux/module.h>
+
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
@@ -385,10 +387,6 @@
 	return -ENOIOCTLCMD;
 }
 
-static void btmrvl_destruct(struct hci_dev *hdev)
-{
-}
-
 static int btmrvl_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
@@ -396,12 +394,13 @@
 
 	BT_DBG("type=%d, len=%d", skb->pkt_type, skb->len);
 
-	if (!hdev || !hdev->driver_data) {
+	if (!hdev) {
 		BT_ERR("Frame for unknown HCI device");
 		return -ENODEV;
 	}
 
-	priv = (struct btmrvl_private *) hdev->driver_data;
+	priv = hci_get_drvdata(hdev);
+
 	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
 		BT_ERR("Failed testing HCI_RUNING, flags=%lx", hdev->flags);
 		print_hex_dump_bytes("data: ", DUMP_PREFIX_OFFSET,
@@ -432,7 +431,7 @@
 
 static int btmrvl_flush(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 
 	skb_queue_purge(&priv->adapter->tx_queue);
 
@@ -441,7 +440,7 @@
 
 static int btmrvl_close(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
@@ -473,8 +472,6 @@
 
 	init_waitqueue_entry(&wait, current);
 
-	current->flags |= PF_NOFREEZE;
-
 	for (;;) {
 		add_wait_queue(&thread->wait_q, &wait);
 
@@ -546,16 +543,14 @@
 	}
 
 	priv->btmrvl_dev.hcidev = hdev;
-	hdev->driver_data = priv;
+	hci_set_drvdata(hdev, priv);
 
 	hdev->bus = HCI_SDIO;
 	hdev->open = btmrvl_open;
 	hdev->close = btmrvl_close;
 	hdev->flush = btmrvl_flush;
 	hdev->send = btmrvl_send_frame;
-	hdev->destruct = btmrvl_destruct;
 	hdev->ioctl = btmrvl_ioctl;
-	hdev->owner = THIS_MODULE;
 
 	btmrvl_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_sdio.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_sdio.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_sdio.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_sdio.c	2016-06-02 00:28:55.000000000 +0000
@@ -23,6 +23,7 @@
 
 #include <linux/mmc/sdio_ids.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -64,7 +65,7 @@
 	.io_port_1 = 0x01,
 	.io_port_2 = 0x02,
 };
-static const struct btmrvl_sdio_card_reg btmrvl_reg_8787 = {
+static const struct btmrvl_sdio_card_reg btmrvl_reg_87xx = {
 	.cfg = 0x00,
 	.host_int_mask = 0x02,
 	.host_intstatus = 0x03,
@@ -81,7 +82,7 @@
 	.io_port_2 = 0x7a,
 };
 
-static const struct btmrvl_sdio_device btmrvl_sdio_sd6888 = {
+static const struct btmrvl_sdio_device btmrvl_sdio_sd8688 = {
 	.helper		= "sd8688_helper.bin",
 	.firmware	= "sd8688.bin",
 	.reg		= &btmrvl_reg_8688,
@@ -91,17 +92,27 @@
 static const struct btmrvl_sdio_device btmrvl_sdio_sd8787 = {
 	.helper		= NULL,
 	.firmware	= "mrvl/sd8787_uapsta.bin",
-	.reg		= &btmrvl_reg_8787,
+	.reg		= &btmrvl_reg_87xx,
+	.sd_blksz_fw_dl	= 256,
+};
+
+static const struct btmrvl_sdio_device btmrvl_sdio_sd8797 = {
+	.helper		= NULL,
+	.firmware	= "mrvl/sd8797_uapsta.bin",
+	.reg		= &btmrvl_reg_87xx,
 	.sd_blksz_fw_dl	= 256,
 };
 
 static const struct sdio_device_id btmrvl_sdio_ids[] = {
 	/* Marvell SD8688 Bluetooth device */
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x9105),
-			.driver_data = (unsigned long) &btmrvl_sdio_sd6888 },
+			.driver_data = (unsigned long) &btmrvl_sdio_sd8688 },
 	/* Marvell SD8787 Bluetooth device */
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x911A),
 			.driver_data = (unsigned long) &btmrvl_sdio_sd8787 },
+	/* Marvell SD8797 Bluetooth device */
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x912A),
+			.driver_data = (unsigned long) &btmrvl_sdio_sd8797 },
 
 	{ }	/* Terminating entry */
 };
@@ -1075,3 +1086,4 @@
 MODULE_FIRMWARE("sd8688_helper.bin");
 MODULE_FIRMWARE("sd8688.bin");
 MODULE_FIRMWARE("mrvl/sd8787_uapsta.bin");
+MODULE_FIRMWARE("mrvl/sd8797_uapsta.bin");
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btsdio.c flo-ElementalX-5.00-patched/drivers/bluetooth/btsdio.c
--- flo-ElementalX-5.00/drivers/bluetooth/btsdio.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btsdio.c	2016-06-02 00:28:55.000000000 +0000
@@ -189,7 +189,7 @@
 
 static int btsdio_open(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -225,7 +225,7 @@
 
 static int btsdio_close(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -246,7 +246,7 @@
 
 static int btsdio_flush(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -258,7 +258,7 @@
 static int btsdio_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -289,15 +289,6 @@
 	return 0;
 }
 
-static void btsdio_destruct(struct hci_dev *hdev)
-{
-	struct btsdio_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree(data);
-}
-
 static int btsdio_probe(struct sdio_func *func,
 				const struct sdio_device_id *id)
 {
@@ -330,7 +321,7 @@
 	}
 
 	hdev->bus = HCI_SDIO;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	if (id->class == SDIO_CLASS_BT_AMP)
 		hdev->dev_type = HCI_AMP;
@@ -345,9 +336,6 @@
 	hdev->close    = btsdio_close;
 	hdev->flush    = btsdio_flush;
 	hdev->send     = btsdio_send_frame;
-	hdev->destruct = btsdio_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	err = hci_register_dev(hdev);
 	if (err < 0) {
@@ -378,6 +366,7 @@
 	hci_unregister_dev(hdev);
 
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 static struct sdio_driver btsdio_driver = {
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btuart_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/btuart_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/btuart_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btuart_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -38,7 +38,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <pcmcia/cistpl.h>
@@ -397,7 +396,7 @@
 
 static int btuart_hci_flush(struct hci_dev *hdev)
 {
-	btuart_info_t *info = (btuart_info_t *)(hdev->driver_data);
+	btuart_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -435,7 +434,7 @@
 		return -ENODEV;
 	}
 
-	info = (btuart_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -459,11 +458,6 @@
 }
 
 
-static void btuart_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int btuart_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -498,18 +492,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = btuart_hci_open;
 	hdev->close    = btuart_hci_close;
 	hdev->flush    = btuart_hci_flush;
 	hdev->send     = btuart_hci_send_frame;
-	hdev->destruct = btuart_hci_destruct;
 	hdev->ioctl    = btuart_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -565,9 +556,7 @@
 
 	spin_unlock_irqrestore(&(info->lock), flags);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -689,7 +678,7 @@
 	pcmcia_disable_device(link);
 }
 
-static struct pcmcia_device_id btuart_ids[] = {
+static const struct pcmcia_device_id btuart_ids[] = {
 	/* don't use this driver. Use serial_cs + hci_uart instead */
 	PCMCIA_DEVICE_NULL
 };
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btusb.c flo-ElementalX-5.00-patched/drivers/bluetooth/btusb.c
--- flo-ElementalX-5.00/drivers/bluetooth/btusb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btusb.c	2016-06-02 00:28:55.000000000 +0000
@@ -37,13 +37,13 @@
 
 #define VERSION "0.6"
 
-static int ignore_dga;
-static int ignore_csr;
-static int ignore_sniffer;
-static int disable_scofix;
-static int force_scofix;
+static bool ignore_dga;
+static bool ignore_csr;
+static bool ignore_sniffer;
+static bool disable_scofix;
+static bool force_scofix;
 
-static int reset = 1;
+static bool reset = 1;
 
 static struct usb_driver btusb_driver;
 
@@ -60,8 +60,11 @@
 	/* Generic Bluetooth USB device */
 	{ USB_DEVICE_INFO(0xe0, 0x01, 0x01) },
 
+	/* Apple-specific (Broadcom) devices */
+	{ USB_VENDOR_AND_INTERFACE_INFO(0x05ac, 0xff, 0x01, 0x01) },
+
 	/* Broadcom SoftSailing reporting vendor specific */
-	{ USB_DEVICE(0x05ac, 0x21e1) },
+	{ USB_DEVICE(0x0a5c, 0x21e1) },
 
 	/* Apple MacBookPro 7,1 */
 	{ USB_DEVICE(0x05ac, 0x8213) },
@@ -100,6 +103,16 @@
 	/* Canyon CN-BTU1 with HID interfaces */
 	{ USB_DEVICE(0x0c10, 0x0000) },
 
+	/* Broadcom BCM20702A0 */
+	{ USB_DEVICE(0x0489, 0xe042) },
+	{ USB_DEVICE(0x413c, 0x8197) },
+
+	/* Foxconn - Hon Hai */
+	{ USB_DEVICE(0x0489, 0xe033) },
+
+	/*Broadcom devices with vendor specific id */
+	{ USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01) },
+
 	{ }	/* Terminating entry */
 };
 
@@ -114,12 +127,23 @@
 
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x13d3, 0x3304), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 
 	/* Atheros AR9285 Malbec with sflash firmware */
 	{ USB_DEVICE(0x03f0, 0x311d), .driver_info = BTUSB_IGNORE },
 
 	/* Atheros 3012 with sflash firmware */
+	{ USB_DEVICE(0x0cf3, 0x0036), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311d), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x817a), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
@@ -236,7 +260,7 @@
 static void btusb_intr_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -264,7 +288,9 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
@@ -273,7 +299,7 @@
 
 static int btusb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -308,7 +334,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -321,7 +348,7 @@
 static void btusb_bulk_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -349,7 +376,9 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
@@ -358,7 +387,7 @@
 
 static int btusb_submit_bulk_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -391,7 +420,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -404,7 +434,7 @@
 static void btusb_isoc_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int i, err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -439,14 +469,16 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
 }
 
-static void inline __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
+static inline void __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
 {
 	int i, offset = 0;
 
@@ -469,7 +501,7 @@
 
 static int btusb_submit_isoc_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -495,15 +527,10 @@
 
 	pipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);
 
-	urb->dev      = data->udev;
-	urb->pipe     = pipe;
-	urb->context  = hdev;
-	urb->complete = btusb_isoc_complete;
-	urb->interval = data->isoc_rx_ep->bInterval;
+	usb_fill_int_urb(urb, data->udev, pipe, buf, size, btusb_isoc_complete,
+				hdev, data->isoc_rx_ep->bInterval);
 
 	urb->transfer_flags  = URB_FREE_BUFFER | URB_ISO_ASAP;
-	urb->transfer_buffer = buf;
-	urb->transfer_buffer_length = size;
 
 	__fill_isoc_descriptor(urb, size,
 			le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));
@@ -512,7 +539,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -526,7 +554,7 @@
 {
 	struct sk_buff *skb = urb->context;
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
 					urb, urb->status, urb->actual_length);
@@ -573,7 +601,7 @@
 
 static int btusb_open(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -623,7 +651,7 @@
 
 static int btusb_close(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -653,7 +681,7 @@
 
 static int btusb_flush(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -665,7 +693,7 @@
 static int btusb_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct usb_ctrlrequest *dr;
 	struct urb *urb;
 	unsigned int pipe;
@@ -759,31 +787,23 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed", hdev->name, urb);
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
+						hdev->name, urb, -err);
 		kfree(urb->setup_packet);
 		usb_unanchor_urb(urb);
 	} else {
 		usb_mark_last_busy(data->udev);
 	}
 
-	usb_free_urb(urb);
-
 done:
+	usb_free_urb(urb);
 	return err;
 }
 
-static void btusb_destruct(struct hci_dev *hdev)
-{
-	struct btusb_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree(data);
-}
-
 static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s evt %d", hdev->name, evt);
 
@@ -793,9 +813,9 @@
 	}
 }
 
-static int inline __set_isoc_interface(struct hci_dev *hdev, int altsetting)
+static inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct usb_interface *intf = data->isoc;
 	struct usb_endpoint_descriptor *ep_desc;
 	int i, err;
@@ -983,7 +1003,7 @@
 	}
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	data->hdev = hdev;
 
@@ -993,11 +1013,8 @@
 	hdev->close    = btusb_close;
 	hdev->flush    = btusb_flush;
 	hdev->send     = btusb_send_frame;
-	hdev->destruct = btusb_destruct;
 	hdev->notify   = btusb_notify;
 
-	hdev->owner = THIS_MODULE;
-
 	/* Interface numbers are hardcoded in the specification */
 	data->isoc = usb_ifnum_to_if(data->udev, 1);
 
@@ -1079,9 +1096,6 @@
 		return;
 
 	hdev = data->hdev;
-
-	__hci_dev_hold(hdev);
-
 	usb_set_intfdata(data->intf, NULL);
 
 	if (data->isoc)
@@ -1094,9 +1108,8 @@
 	else if (data->isoc)
 		usb_driver_release_interface(&btusb_driver, data->isoc);
 
-	__hci_dev_put(hdev);
-
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 #ifdef CONFIG_PM
@@ -1110,7 +1123,7 @@
 		return 0;
 
 	spin_lock_irq(&data->txlock);
-	if (!((message.event & PM_EVENT_AUTO) && data->tx_in_flight)) {
+	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
 		spin_unlock_irq(&data->txlock);
 	} else {
@@ -1212,20 +1225,7 @@
 	.supports_autosuspend = 1,
 };
 
-static int __init btusb_init(void)
-{
-	BT_INFO("Generic Bluetooth USB driver ver %s", VERSION);
-
-	return usb_register(&btusb_driver);
-}
-
-static void __exit btusb_exit(void)
-{
-	usb_deregister(&btusb_driver);
-}
-
-module_init(btusb_init);
-module_exit(btusb_exit);
+module_usb_driver(btusb_driver);
 
 module_param(ignore_dga, bool, 0644);
 MODULE_PARM_DESC(ignore_dga, "Ignore devices with id 08fd:0001");
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btwilink.c flo-ElementalX-5.00-patched/drivers/bluetooth/btwilink.c
--- flo-ElementalX-5.00/drivers/bluetooth/btwilink.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btwilink.c	2016-06-02 00:28:55.000000000 +0000
@@ -29,6 +29,7 @@
 #include <net/bluetooth/hci.h>
 
 #include <linux/ti_wilink_st.h>
+#include <linux/module.h>
 
 /* Bluetooth Driver Version */
 #define VERSION               "1.0"
@@ -125,6 +126,13 @@
 /* protocol structure registered with shared transport */
 static struct st_proto_s ti_st_proto[MAX_BT_CHNL_IDS] = {
 	{
+		.chnl_id = HCI_EVENT_PKT, /* HCI Events */
+		.hdr_len = sizeof(struct hci_event_hdr),
+		.offset_len_in_hdr = offsetof(struct hci_event_hdr, plen),
+		.len_size = 1, /* sizeof(plen) in struct hci_event_hdr */
+		.reserve = 8,
+	},
+	{
 		.chnl_id = HCI_ACLDATA_PKT, /* ACL */
 		.hdr_len = sizeof(struct hci_acl_hdr),
 		.offset_len_in_hdr = offsetof(struct hci_acl_hdr, dlen),
@@ -138,13 +146,6 @@
 		.len_size = 1, /* sizeof(dlen) in struct hci_sco_hdr */
 		.reserve = 8,
 	},
-	{
-		.chnl_id = HCI_EVENT_PKT, /* HCI Events */
-		.hdr_len = sizeof(struct hci_event_hdr),
-		.offset_len_in_hdr = offsetof(struct hci_event_hdr, plen),
-		.len_size = 1, /* sizeof(plen) in struct hci_event_hdr */
-		.reserve = 8,
-	},
 };
 
 /* Called from HCI core to initialize the device */
@@ -160,7 +161,7 @@
 		return -EBUSY;
 
 	/* provide contexts for callbacks from ST */
-	hst = hdev->driver_data;
+	hst = hci_get_drvdata(hdev);
 
 	for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
 		ti_st_proto[i].priv_data = hst;
@@ -235,12 +236,12 @@
 static int ti_st_close(struct hci_dev *hdev)
 {
 	int err, i;
-	struct ti_st *hst = hdev->driver_data;
+	struct ti_st *hst = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
 
-	for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
+	for (i = MAX_BT_CHNL_IDS-1; i >= 0; i--) {
 		err = st_unregister(&ti_st_proto[i]);
 		if (err)
 			BT_ERR("st_unregister(%d) failed with error %d",
@@ -263,7 +264,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	hst = hdev->driver_data;
+	hst = hci_get_drvdata(hdev);
 
 	/* Prepend skb with frame type */
 	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
@@ -290,14 +291,6 @@
 	return 0;
 }
 
-static void ti_st_destruct(struct hci_dev *hdev)
-{
-	BT_DBG("%s", hdev->name);
-	/* do nothing here, since platform remove
-	 * would free the hdev->driver_data
-	 */
-}
-
 static int bt_ti_probe(struct platform_device *pdev)
 {
 	static struct ti_st *hst;
@@ -319,13 +312,11 @@
 
 	hst->hdev = hdev;
 	hdev->bus = HCI_UART;
-	hdev->driver_data = hst;
+	hci_set_drvdata(hdev, hst);
 	hdev->open = ti_st_open;
 	hdev->close = ti_st_close;
 	hdev->flush = NULL;
 	hdev->send = ti_st_send_frame;
-	hdev->destruct = ti_st_destruct;
-	hdev->owner = THIS_MODULE;
 
 	err = hci_register_dev(hdev);
 	if (err < 0) {
diff -urN flo-ElementalX-5.00/drivers/bluetooth/dtl1_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/dtl1_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/dtl1_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/dtl1_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -38,7 +38,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <pcmcia/cistpl.h>
@@ -83,9 +82,6 @@
 
 
 static int dtl1_config(struct pcmcia_device *link);
-static void dtl1_release(struct pcmcia_device *link);
-
-static void dtl1_detach(struct pcmcia_device *p_dev);
 
 
 /* Transmit states  */
@@ -367,7 +363,7 @@
 
 static int dtl1_hci_flush(struct hci_dev *hdev)
 {
-	dtl1_info_t *info = (dtl1_info_t *)(hdev->driver_data);
+	dtl1_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -399,7 +395,7 @@
 		return -ENODEV;
 	}
 
-	info = (dtl1_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -442,11 +438,6 @@
 }
 
 
-static void dtl1_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int dtl1_hci_ioctl(struct hci_dev *hdev, unsigned int cmd,  unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -483,18 +474,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = dtl1_hci_open;
 	hdev->close    = dtl1_hci_close;
 	hdev->flush    = dtl1_hci_flush;
 	hdev->send     = dtl1_hci_send_frame;
-	hdev->destruct = dtl1_hci_destruct;
 	hdev->ioctl    = dtl1_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -551,9 +539,7 @@
 
 	spin_unlock_irqrestore(&(info->lock), flags);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -581,8 +567,8 @@
 {
 	dtl1_info_t *info = link->priv;
 
-	dtl1_release(link);
-
+	dtl1_close(info);
+	pcmcia_disable_device(link);
 	kfree(info);
 }
 
@@ -621,22 +607,11 @@
 	return 0;
 
 failed:
-	dtl1_release(link);
+	dtl1_detach(link);
 	return -ENODEV;
 }
 
-
-static void dtl1_release(struct pcmcia_device *link)
-{
-	dtl1_info_t *info = link->priv;
-
-	dtl1_close(info);
-
-	pcmcia_disable_device(link);
-}
-
-
-static struct pcmcia_device_id dtl1_ids[] = {
+static const struct pcmcia_device_id dtl1_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-1", 0xe1bfdd64, 0xe168480d),
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-4", 0xe1bfdd64, 0x9102bc82),
 	PCMCIA_DEVICE_PROD_ID12("Socket", "CF", 0xb38bcc2e, 0x44ebf863),
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ath.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ath.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ath.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ath.c	2016-06-02 00:28:55.000000000 +0000
@@ -5,7 +5,6 @@
  *  power management protocol extension to H4 to support AR300x Bluetooth Chip.
  *
  *  Copyright (c) 2009-2010 Atheros Communications Inc.
- *  Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  *  Acknowledgements:
  *  This file is based on hci_h4.c, which was written
@@ -36,53 +35,12 @@
 #include <linux/errno.h>
 #include <linux/ioctl.h>
 #include <linux/skbuff.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
 #include "hci_uart.h"
 
-unsigned int enableuartsleep = 1;
-module_param(enableuartsleep, uint, 0644);
-/*
- * Global variables
- */
-/** Global state flags */
-static unsigned long flags;
-
-/** Tasklet to respond to change in hostwake line */
-static struct tasklet_struct hostwake_task;
-
-/** Transmission timer */
-static void bluesleep_tx_timer_expire(unsigned long data);
-static DEFINE_TIMER(tx_timer, bluesleep_tx_timer_expire, 0, 0);
-
-/** Lock for state transitions */
-static spinlock_t rw_lock;
-
-#define POLARITY_LOW 0
-#define POLARITY_HIGH 1
-
-struct bluesleep_info {
-	unsigned host_wake;			/* wake up host */
-	unsigned ext_wake;			/* wake up device */
-	unsigned host_wake_irq;
-	int irq_polarity;
-};
-
-/* 1 second timeout */
-#define TX_TIMER_INTERVAL  1
-
-/* state variable names and bit positions */
-#define BT_TXEXPIRED    0x01
-#define BT_SLEEPENABLE  0x02
-#define BT_SLEEPCMD	0x03
-
-/* global pointer to a single hci device. */
-static struct bluesleep_info *bsi;
-
 struct ath_struct {
 	struct hci_uart *hu;
 	unsigned int cur_sleep;
@@ -91,30 +49,35 @@
 	struct work_struct ctxtsw;
 };
 
-static void hostwake_interrupt(unsigned long data)
+static int ath_wakeup_ar3k(struct tty_struct *tty)
 {
-	BT_INFO(" wakeup host\n");
-}
+	struct ktermios ktermios;
+	int status = tty->driver->ops->tiocmget(tty);
 
-static void modify_timer_task(void)
-{
-	spin_lock(&rw_lock);
-	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-	clear_bit(BT_TXEXPIRED, &flags);
-	spin_unlock(&rw_lock);
+	if (status & TIOCM_CTS)
+		return status;
 
-}
+	/* Disable Automatic RTSCTS */
+	memcpy(&ktermios, tty->termios, sizeof(ktermios));
+	ktermios.c_cflag &= ~CRTSCTS;
+	tty_set_termios(tty, &ktermios);
+
+	/* Clear RTS first */
+	status = tty->driver->ops->tiocmget(tty);
+	tty->driver->ops->tiocmset(tty, 0x00, TIOCM_RTS);
+	mdelay(20);
+
+	/* Set RTS, wake up board */
+	status = tty->driver->ops->tiocmget(tty);
+	tty->driver->ops->tiocmset(tty, TIOCM_RTS, 0x00);
+	mdelay(20);
+
+	status = tty->driver->ops->tiocmget(tty);
+
+	/* Disable Automatic RTSCTS */
+	ktermios.c_cflag |= CRTSCTS;
+	status = tty_set_termios(tty, &ktermios);
 
-static int ath_wakeup_ar3k(struct tty_struct *tty)
-{
-	int status = 0;
-	if (test_bit(BT_TXEXPIRED, &flags)) {
-		BT_INFO("wakeup device\n");
-		gpio_set_value(bsi->ext_wake, 0);
-		msleep(20);
-		gpio_set_value(bsi->ext_wake, 1);
-	}
-	modify_timer_task();
 	return status;
 }
 
@@ -131,123 +94,25 @@
 	tty = hu->tty;
 
 	/* verify and wake up controller */
-	if (test_bit(BT_SLEEPENABLE, &flags))
+	if (ath->cur_sleep) {
 		status = ath_wakeup_ar3k(tty);
+		if (!(status & TIOCM_CTS))
+			return;
+	}
+
 	/* Ready to send Data */
 	clear_bit(HCI_UART_SENDING, &hu->tx_state);
 	hci_uart_tx_wakeup(hu);
 }
 
-static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
-{
-	/* schedule a tasklet to handle the change in the host wake line */
-	tasklet_schedule(&hostwake_task);
-	return IRQ_HANDLED;
-}
-
-static int ath_bluesleep_gpio_config(int on)
-{
-	int ret = 0;
-
-	BT_INFO("%s config: %d", __func__, on);
-	if (!on) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-		goto free_host_wake_irq;
-	}
-
-	ret = gpio_request(bsi->host_wake, "bt_host_wake");
-	if (ret < 0) {
-		BT_ERR("failed to request gpio pin %d, error %d\n",
-			bsi->host_wake, ret);
-		goto gpio_config_failed;
-	}
-
-	/* configure host_wake as input */
-	ret = gpio_direction_input(bsi->host_wake);
-	if (ret < 0) {
-		BT_ERR("failed to config GPIO %d as input pin, err %d\n",
-			bsi->host_wake, ret);
-		goto gpio_host_wake;
-	}
-
-	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
-	if (ret < 0) {
-		BT_ERR("failed to request gpio pin %d, error %d\n",
-			bsi->ext_wake, ret);
-		goto gpio_host_wake;
-	}
-
-	ret = gpio_direction_output(bsi->ext_wake, 1);
-	if (ret < 0) {
-		BT_ERR("failed to config GPIO %d as output pin, err %d\n",
-			bsi->ext_wake, ret);
-		goto gpio_ext_wake;
-	}
-
-	gpio_set_value(bsi->ext_wake, 1);
-
-	/* Initialize spinlock. */
-	spin_lock_init(&rw_lock);
-
-	/* Initialize timer */
-	init_timer(&tx_timer);
-	tx_timer.function = bluesleep_tx_timer_expire;
-	tx_timer.data = 0;
-
-	/* initialize host wake tasklet */
-	tasklet_init(&hostwake_task, hostwake_interrupt, 0);
-
-	if (bsi->irq_polarity == POLARITY_LOW) {
-		ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-				"bluetooth hostwake", NULL);
-	} else  {
-		ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_RISING,
-				"bluetooth hostwake", NULL);
-	}
-	if (ret  < 0) {
-		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
-		goto delete_timer;
-	}
-
-	ret = enable_irq_wake(bsi->host_wake_irq);
-	if (ret < 0) {
-		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
-		goto free_host_wake_irq;
-	}
-
-	return 0;
-
-free_host_wake_irq:
-	free_irq(bsi->host_wake_irq, NULL);
-delete_timer:
-	del_timer(&tx_timer);
-gpio_ext_wake:
-	gpio_free(bsi->ext_wake);
-gpio_host_wake:
-	gpio_free(bsi->host_wake);
-gpio_config_failed:
-	return ret;
-}
-
 /* Initialize protocol */
 static int ath_open(struct hci_uart *hu)
 {
 	struct ath_struct *ath;
 
-	BT_DBG("hu %p, bsi %p", hu, bsi);
-
-	if (!bsi)
-		return -EIO;
-
-	if (ath_bluesleep_gpio_config(1) < 0) {
-		BT_ERR("HCIATH3K GPIO Config failed");
-		return -EIO;
-	}
+	BT_DBG("hu %p", hu);
 
-	ath = kzalloc(sizeof(*ath), GFP_ATOMIC);
+	ath = kzalloc(sizeof(*ath), GFP_KERNEL);
 	if (!ath)
 		return -ENOMEM;
 
@@ -256,11 +121,6 @@
 	hu->priv = ath;
 	ath->hu = hu;
 
-	ath->cur_sleep = enableuartsleep;
-	if (ath->cur_sleep == 1) {
-		set_bit(BT_SLEEPENABLE, &flags);
-		modify_timer_task();
-	}
 	INIT_WORK(&ath->ctxtsw, ath_hci_uart_work);
 
 	return 0;
@@ -292,9 +152,6 @@
 	hu->priv = NULL;
 	kfree(ath);
 
-	if (bsi)
-		ath_bluesleep_gpio_config(0);
-
 	return 0;
 }
 
@@ -305,8 +162,6 @@
 {
 	struct ath_struct *ath = hu->priv;
 
-	BT_DBG("");
-
 	if (bt_cb(skb)->pkt_type == HCI_SCODATA_PKT) {
 		kfree_skb(skb);
 		return 0;
@@ -318,10 +173,9 @@
 	 */
 	if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {
 		struct hci_command_hdr *hdr = (void *)skb->data;
-		if (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP) {
-			set_bit(BT_SLEEPCMD, &flags);
+
+		if (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP)
 			ath->cur_sleep = skb->data[HCI_COMMAND_HDR_SIZE];
-		}
 	}
 
 	BT_DBG("hu %p skb %p", hu, skb);
@@ -347,47 +201,15 @@
 /* Recv data */
 static int ath_recv(struct hci_uart *hu, void *data, int count)
 {
-	struct ath_struct *ath = hu->priv;
-	unsigned int type;
-
-	BT_DBG("");
+	int ret;
 
-	if (hci_recv_stream_fragment(hu->hdev, data, count) < 0)
+	ret = hci_recv_stream_fragment(hu->hdev, data, count);
+	if (ret < 0) {
 		BT_ERR("Frame Reassembly Failed");
-
-	if (count & test_bit(BT_SLEEPCMD, &flags)) {
-		struct sk_buff *skb = hu->hdev->reassembly[0];
-
-		if (!skb) {
-			struct { char type; } *pkt;
-
-			/* Start of the frame */
-			pkt = data;
-			type = pkt->type;
-		} else
-			type = bt_cb(skb)->pkt_type;
-
-		if (type == HCI_EVENT_PKT) {
-			clear_bit(BT_SLEEPCMD, &flags);
-			BT_INFO("cur_sleep:%d\n", ath->cur_sleep);
-			if (ath->cur_sleep == 1)
-				set_bit(BT_SLEEPENABLE, &flags);
-			else
-				clear_bit(BT_SLEEPENABLE, &flags);
-		}
-		if (test_bit(BT_SLEEPENABLE, &flags))
-			modify_timer_task();
+		return ret;
 	}
-	return count;
-}
 
-static void bluesleep_tx_timer_expire(unsigned long data)
-{
-	if (!test_bit(BT_SLEEPENABLE, &flags))
-		return;
-	BT_INFO("Tx timer expired\n");
-
-	set_bit(BT_TXEXPIRED, &flags);
+	return count;
 }
 
 static struct hci_uart_proto athp = {
@@ -400,89 +222,19 @@
 	.flush = ath_flush,
 };
 
-static int __init bluesleep_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-
-	BT_DBG("");
-
-	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
-	if (!bsi) {
-		ret = -ENOMEM;
-		goto failed;
-	}
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-						"gpio_host_wake");
-	if (!res) {
-		BT_ERR("couldn't find host_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->host_wake = res->start;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-						"gpio_ext_wake");
-	if (!res) {
-		BT_ERR("couldn't find ext_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->ext_wake = res->start;
-
-	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
-	if (bsi->host_wake_irq < 0) {
-		BT_ERR("couldn't find host_wake irq\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-
-	bsi->irq_polarity = POLARITY_LOW;	/* low edge (falling edge) */
-
-	return 0;
-
-free_bsi:
-	kfree(bsi);
-	bsi = NULL;
-failed:
-	return ret;
-}
-
-static int bluesleep_remove(struct platform_device *pdev)
-{
-	kfree(bsi);
-	return 0;
-}
-
-static struct platform_driver bluesleep_driver = {
-	.remove = bluesleep_remove,
-	.driver = {
-		.name = "bluesleep",
-		.owner = THIS_MODULE,
-	},
-};
-
 int __init ath_init(void)
 {
-	int ret;
+	int err = hci_uart_register_proto(&athp);
 
-	ret = hci_uart_register_proto(&athp);
-
-	if (!ret)
+	if (!err)
 		BT_INFO("HCIATH3K protocol initialized");
-	else {
+	else
 		BT_ERR("HCIATH3K protocol registration failed");
-		return ret;
-	}
-	ret = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
-	if (ret)
-		return ret;
-	return 0;
+
+	return err;
 }
 
 int __exit ath_deinit(void)
 {
-	platform_driver_unregister(&bluesleep_driver);
 	return hci_uart_unregister_proto(&athp);
 }
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_bcsp.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_bcsp.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_bcsp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_bcsp.c	2016-06-02 00:28:55.000000000 +0000
@@ -49,8 +49,8 @@
 
 #define VERSION "0.3"
 
-static int txcrc = 1;
-static int hciextn = 1;
+static bool txcrc = 1;
+static bool hciextn = 1;
 
 #define BCSP_TXWINSIZE	4
 
@@ -692,7 +692,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	bcsp = kzalloc(sizeof(*bcsp), GFP_ATOMIC);
+	bcsp = kzalloc(sizeof(*bcsp), GFP_KERNEL);
 	if (!bcsp)
 		return -ENOMEM;
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_h4.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_h4.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_h4.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_h4.c	2016-06-02 00:28:55.000000000 +0000
@@ -69,7 +69,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	h4 = kzalloc(sizeof(*h4), GFP_ATOMIC);
+	h4 = kzalloc(sizeof(*h4), GFP_KERNEL);
 	if (!h4)
 		return -ENOMEM;
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ldisc.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ldisc.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ldisc.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ldisc.c	2016-06-02 00:28:55.000000000 +0000
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
- *  Copyright (c) 2000-2001, 2010-2012, The Linux Foundation. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -48,10 +48,7 @@
 
 #define VERSION "2.2"
 
-static bool reset = 0;
-
 static struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];
-static void hci_uart_tty_wakeup_action(unsigned long data);
 
 int hci_uart_register_proto(struct hci_uart_proto *p)
 {
@@ -175,7 +172,7 @@
 /* Reset device */
 static int hci_uart_flush(struct hci_dev *hdev)
 {
-	struct hci_uart *hu  = (struct hci_uart *) hdev->driver_data;
+	struct hci_uart *hu  = hci_get_drvdata(hdev);
 	struct tty_struct *tty = hu->tty;
 
 	BT_DBG("hdev %p tty %p", hdev, tty);
@@ -221,7 +218,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	hu = (struct hci_uart *) hdev->driver_data;
+	hu = hci_get_drvdata(hdev);
 
 	BT_DBG("%s: type %d len %d", hdev->name, bt_cb(skb)->pkt_type, skb->len);
 
@@ -232,15 +229,6 @@
 	return 0;
 }
 
-static void hci_uart_destruct(struct hci_dev *hdev)
-{
-	if (!hdev)
-		return;
-
-	BT_DBG("%s", hdev->name);
-	kfree(hdev->driver_data);
-}
-
 /* ------ LDISC part ------ */
 /* hci_uart_tty_open
  * 
@@ -277,8 +265,6 @@
 	tty->receive_room = 65536;
 
 	spin_lock_init(&hu->rx_lock);
-	tasklet_init(&hu->tty_wakeup_task, hci_uart_tty_wakeup_action,
-			 (unsigned long)hu);
 
 	/* Flush any pending characters in the driver and line discipline. */
 
@@ -312,15 +298,15 @@
 		if (hdev)
 			hci_uart_close(hdev);
 
-		tasklet_kill(&hu->tty_wakeup_task);
-
 		if (test_and_clear_bit(HCI_UART_PROTO_SET, &hu->flags)) {
-			hu->proto->close(hu);
 			if (hdev) {
 				hci_unregister_dev(hdev);
 				hci_free_dev(hdev);
 			}
+			hu->proto->close(hu);
 		}
+
+		kfree(hu);
 	}
 }
 
@@ -328,8 +314,6 @@
  *
  *    Callback for transmit wakeup. Called when low level
  *    device driver can accept more send data.
- *    This callback gets called from the isr context so
- *    schedule the send data operation to tasklet.
  *
  * Arguments:        tty    pointer to associated tty instance data
  * Return Value:    None
@@ -337,26 +321,12 @@
 static void hci_uart_tty_wakeup(struct tty_struct *tty)
 {
 	struct hci_uart *hu = (void *)tty->disc_data;
-	tasklet_schedule(&hu->tty_wakeup_task);
-}
-
-/* hci_uart_tty_wakeup_action()
- *
- * Scheduled action to transmit data when low level device
- * driver can accept more data.
- */
-static void hci_uart_tty_wakeup_action(unsigned long data)
-{
-	struct hci_uart *hu = (struct hci_uart *)data;
-	struct tty_struct *tty;
 
 	BT_DBG("");
 
 	if (!hu)
 		return;
 
-	tty = hu->tty;
-
 	clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
 
 	if (tty != hu->tty)
@@ -380,7 +350,6 @@
  */
 static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *flags, int count)
 {
-	int ret;
 	struct hci_uart *hu = (void *)tty->disc_data;
 
 	if (!hu || tty != hu->tty)
@@ -390,9 +359,8 @@
 		return;
 
 	spin_lock(&hu->rx_lock);
-	ret = hu->proto->recv(hu, (void *) data, count);
-	if (ret > 0)
-		hu->hdev->stat.byte_rx += count;
+	hu->proto->recv(hu, (void *) data, count);
+	hu->hdev->stat.byte_rx += count;
 	spin_unlock(&hu->rx_lock);
 
 	tty_unthrottle(tty);
@@ -414,22 +382,24 @@
 	hu->hdev = hdev;
 
 	hdev->bus = HCI_UART;
-	hdev->driver_data = hu;
+	hci_set_drvdata(hdev, hu);
 
 	hdev->open  = hci_uart_open;
 	hdev->close = hci_uart_close;
 	hdev->flush = hci_uart_flush;
 	hdev->send  = hci_uart_send_frame;
-	hdev->destruct = hci_uart_destruct;
 	hdev->parent = hu->tty->dev;
 
-	hdev->owner = THIS_MODULE;
+	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
+		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
 
-	if (!reset)
+	if (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))
 		set_bit(HCI_QUIRK_NO_RESET, &hdev->quirks);
 
-	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
-		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
+	if (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))
+		hdev->dev_type = HCI_AMP;
+	else
+		hdev->dev_type = HCI_BREDR;
 
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
@@ -491,18 +461,11 @@
 
 	switch (cmd) {
 	case HCIUARTSETPROTO:
-		if (!test_and_set_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-			&hu->flags) && !test_bit(HCI_UART_PROTO_SET,
-				&hu->flags)) {
+		if (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {
 			err = hci_uart_set_proto(hu, arg);
 			if (err) {
-				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-						&hu->flags);
+				clear_bit(HCI_UART_PROTO_SET, &hu->flags);
 				return err;
-			} else {
-				set_bit(HCI_UART_PROTO_SET, &hu->flags);
-				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-						&hu->flags);
 			}
 		} else
 			return -EBUSY;
@@ -595,9 +558,6 @@
 #ifdef CONFIG_BT_HCIUART_ATH3K
 	ath_init();
 #endif
-#ifdef CONFIG_BT_HCIUART_IBS
-	ibs_init();
-#endif
 
 	return 0;
 }
@@ -618,9 +578,6 @@
 #ifdef CONFIG_BT_HCIUART_ATH3K
 	ath_deinit();
 #endif
-#ifdef CONFIG_BT_HCIUART_IBS
-	ibs_deinit();
-#endif
 
 	/* Release tty registration of line discipline */
 	if ((err = tty_unregister_ldisc(N_HCI)))
@@ -630,9 +587,6 @@
 module_init(hci_uart_init);
 module_exit(hci_uart_exit);
 
-module_param(reset, bool, 0644);
-MODULE_PARM_DESC(reset, "Send HCI reset command on initialization");
-
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Bluetooth HCI UART driver ver " VERSION);
 MODULE_VERSION(VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ll.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ll.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ll.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ll.c	2016-06-02 00:28:55.000000000 +0000
@@ -125,7 +125,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	ll = kzalloc(sizeof(*ll), GFP_ATOMIC);
+	ll = kzalloc(sizeof(*ll), GFP_KERNEL);
 	if (!ll)
 		return -ENOMEM;
 
@@ -207,7 +207,7 @@
 		/*
 		 * This state means that both the host and the BRF chip
 		 * have simultaneously sent a wake-up-indication packet.
-		 * Traditionaly, in this case, receiving a wake-up-indication
+		 * Traditionally, in this case, receiving a wake-up-indication
 		 * was enough and an additional wake-up-ack wasn't needed.
 		 * This has changed with the BRF6350, which does require an
 		 * explicit wake-up-ack. Other BRF versions, which do not
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_smd.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_smd.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_smd.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_smd.c	2016-06-02 00:28:55.000000000 +0000
@@ -148,12 +148,6 @@
 }
 
 
-static void hci_smd_destruct(struct hci_dev *hdev)
-{
-	if (NULL != hdev->driver_data)
-		kfree(hdev->driver_data);
-}
-
 static void hci_smd_recv_data(void)
 {
 	int len = 0;
@@ -486,12 +480,9 @@
 
 	hsmd->hdev = hdev;
 	hdev->bus = HCI_SMD;
-	hdev->driver_data = NULL;
 	hdev->open  = hci_smd_open;
 	hdev->close = hci_smd_close;
 	hdev->send  = hci_smd_send_frame;
-	hdev->destruct = hci_smd_destruct;
-	hdev->owner = THIS_MODULE;
 
 
 	tasklet_init(&hsmd->rx_task,
@@ -545,9 +536,7 @@
 		BT_INFO("HCI device un-registration going on");
 
 		if (hsmd->hdev) {
-			if (hci_unregister_dev(hsmd->hdev) < 0)
-				BT_ERR("Can't unregister HCI device %s",
-					hsmd->hdev->name);
+			hci_unregister_dev(hsmd->hdev);
 
 			hci_free_dev(hsmd->hdev);
 			hsmd->hdev = NULL;
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_uart.h flo-ElementalX-5.00-patched/drivers/bluetooth/hci_uart.h
--- flo-ElementalX-5.00/drivers/bluetooth/hci_uart.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_uart.h	2016-06-02 00:28:55.000000000 +0000
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
- *  Copyright (c) 2000-2001, 2010, 2012 The Linux Foundation. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -42,10 +42,12 @@
 #define HCI_UART_3WIRE	2
 #define HCI_UART_H4DS	3
 #define HCI_UART_LL	4
-#define HCI_UART_IBS	5
-#define HCI_UART_ATH3K	6
+#define HCI_UART_ATH3K	5
+#define HCI_UART_IBS   6
 
 #define HCI_UART_RAW_DEVICE	0
+#define HCI_UART_RESET_ON_INIT	1
+#define HCI_UART_CREATE_AMP	2
 
 struct hci_uart;
 
@@ -66,7 +68,6 @@
 	unsigned long		hdev_flags;
 
 	struct hci_uart_proto	*proto;
-	struct tasklet_struct	tty_wakeup_task;
 	void			*priv;
 
 	struct sk_buff		*tx_skb;
@@ -75,8 +76,7 @@
 };
 
 /* HCI_UART proto flag bits */
-#define HCI_UART_PROTO_SET			0
-#define HCI_UART_PROTO_SET_IN_PROGRESS		1
+#define HCI_UART_PROTO_SET	0
 
 /* TX states  */
 #define HCI_UART_SENDING	1
@@ -105,8 +105,3 @@
 int ath_init(void);
 int ath_deinit(void);
 #endif
-
-#ifdef CONFIG_BT_HCIUART_IBS
-int ibs_init(void);
-int ibs_deinit(void);
-#endif
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_vhci.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_vhci.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_vhci.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_vhci.c	2016-06-02 00:28:55.000000000 +0000
@@ -41,6 +41,8 @@
 
 #define VERSION "1.3"
 
+static bool amp;
+
 struct vhci_data {
 	struct hci_dev *hdev;
 
@@ -59,7 +61,7 @@
 
 static int vhci_close_dev(struct hci_dev *hdev)
 {
-	struct vhci_data *data = hdev->driver_data;
+	struct vhci_data *data = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
@@ -71,7 +73,7 @@
 
 static int vhci_flush(struct hci_dev *hdev)
 {
-	struct vhci_data *data = hdev->driver_data;
+	struct vhci_data *data = hci_get_drvdata(hdev);
 
 	skb_queue_purge(&data->readq);
 
@@ -91,7 +93,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	data = hdev->driver_data;
+	data = hci_get_drvdata(hdev);
 
 	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
 	skb_queue_tail(&data->readq, skb);
@@ -101,11 +103,6 @@
 	return 0;
 }
 
-static void vhci_destruct(struct hci_dev *hdev)
-{
-	kfree(hdev->driver_data);
-}
-
 static inline ssize_t vhci_get_user(struct vhci_data *data,
 					const char __user *buf, size_t count)
 {
@@ -237,15 +234,15 @@
 	data->hdev = hdev;
 
 	hdev->bus = HCI_VIRTUAL;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
+
+	if (amp)
+		hdev->dev_type = HCI_AMP;
 
 	hdev->open     = vhci_open_dev;
 	hdev->close    = vhci_close_dev;
 	hdev->flush    = vhci_flush;
 	hdev->send     = vhci_send_frame;
-	hdev->destruct = vhci_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
@@ -264,13 +261,11 @@
 	struct vhci_data *data = file->private_data;
 	struct hci_dev *hdev = data->hdev;
 
-	if (hci_unregister_dev(hdev) < 0) {
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-	}
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	file->private_data = NULL;
+	kfree(data);
 
 	return 0;
 }
@@ -306,6 +301,9 @@
 module_init(vhci_init);
 module_exit(vhci_exit);
 
+module_param(amp, bool, 0644);
+MODULE_PARM_DESC(amp, "Create AMP controller device");
+
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Bluetooth virtual HCI driver ver " VERSION);
 MODULE_VERSION(VERSION);
diff -urN flo-ElementalX-5.00/drivers/char/msm_rotator.c flo-ElementalX-5.00-patched/drivers/char/msm_rotator.c
--- flo-ElementalX-5.00/drivers/char/msm_rotator.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/char/msm_rotator.c	2014-12-03 11:07:31.000000000 +0000
@@ -319,7 +319,7 @@
 		rc = 1;
 #endif
 	if (rc == 1) {
-		cancel_delayed_work_sync(&msm_rotator_dev->imem_clk_work);
+		cancel_delayed_work(&msm_rotator_dev->imem_clk_work);
 		if (msm_rotator_dev->imem_clk_state != CLK_EN
 			&& msm_rotator_dev->imem_clk) {
 			clk_prepare_enable(msm_rotator_dev->imem_clk);
@@ -735,7 +735,6 @@
 uint32_t fast_yuv_invalid_size_checker(unsigned char rot_mode,
 						uint32_t src_width,
 						uint32_t dst_width,
-						uint32_t src_height,
 						uint32_t dst_height,
 						uint32_t dstp0_ystride,
 						uint32_t is_planar420)
@@ -750,9 +749,6 @@
 
 	if (rot_mode & MDP_ROT_90) {
 
-		if ((src_height % 128) == 8)
-			return -EINVAL;
-
 		/* if rotation 90 degree on fast yuv
 		 * rotator image input width has to be multiple of 8
 		 * rotator image input height has to be multiple of 8
@@ -805,9 +801,9 @@
 	} else {
 		/* if NOT applying rotation 90 degree on fast yuv,
 		 * rotator image input width has to be multiple of 8
-		 * rotator image input height has to be multiple of 8
+		 * rotator image input height has to be multiple of 2
 		*/
-		if (((dst_width % 8) != 0) || ((dst_height % 8) != 0))
+		if (((dst_width % 8) != 0) || ((dst_height % 2) != 0))
 			return -EINVAL;
 	}
 
@@ -1560,7 +1556,7 @@
 	msm_rotator_wait_for_fence(commit_info->acq_fen);
 	commit_info->acq_fen = NULL;
 
-	cancel_delayed_work_sync(&msm_rotator_dev->rot_clk_work);
+	cancel_delayed_work(&msm_rotator_dev->rot_clk_work);
 	if (msm_rotator_dev->rot_clk_state != CLK_EN) {
 		enable_rot_clks();
 		msm_rotator_dev->rot_clk_state = CLK_EN;
@@ -1658,8 +1654,10 @@
 
 	msm_rotator_dev->processing = 1;
 	iowrite32(0x1, MSM_ROTATOR_START);
+	mutex_unlock(&msm_rotator_dev->rotator_lock);
 	wait_event(msm_rotator_dev->wq,
 		   (msm_rotator_dev->processing == 0));
+	mutex_lock(&msm_rotator_dev->rotator_lock);
 	status = (unsigned char)ioread32(MSM_ROTATOR_INTR_STATUS);
 	if ((status & 0x03) != 0x01) {
 		pr_err("%s(): AXI Bus Error, issuing SW_RESET\n", __func__);
@@ -1959,7 +1957,6 @@
 			fast_yuv_en = !fast_yuv_invalid_size_checker(
 						info.rotations,
 						info.src.width,
-						info.src.height,
 						dst_w,
 						dst_h,
 						dst_w,
@@ -2104,7 +2101,6 @@
 	if (copy_from_user(&session_id, (void __user *)arg, sizeof(s)))
 		return -EFAULT;
 
-	rot_wait_for_commit_queue(true);
 	mutex_lock(&msm_rotator_dev->rotator_lock);
 	for (s = 0; s < MAX_SESSIONS; s++) {
 		if ((msm_rotator_dev->rot_session[s] != NULL) &&
diff -urN flo-ElementalX-5.00/drivers/cpufreq/cpufreq_elementalx.c flo-ElementalX-5.00-patched/drivers/cpufreq/cpufreq_elementalx.c
--- flo-ElementalX-5.00/drivers/cpufreq/cpufreq_elementalx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/cpufreq/cpufreq_elementalx.c	2016-06-03 17:55:17.000000000 +0000
@@ -35,7 +35,7 @@
 #include <mach/kgsl.h>
 static int old_up_threshold;
 static int g_count = 0;
-
+int graphics_boost = 0;
 #define DEF_SAMPLING_RATE			(30000)
 #define DEF_FREQUENCY_DOWN_DIFFERENTIAL		(10)
 #define DEF_FREQUENCY_UP_THRESHOLD		(90)
diff -urN flo-ElementalX-5.00/drivers/gpu/ion/ion.c flo-ElementalX-5.00-patched/drivers/gpu/ion/ion.c
--- flo-ElementalX-5.00/drivers/gpu/ion/ion.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/ion/ion.c	2016-06-03 17:04:41.000000000 +0000
@@ -1248,19 +1248,19 @@
 }
 
 
-int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle)
+struct dma_buf *ion_share_dma_buf(struct ion_client *client,
+						struct ion_handle *handle)
 {
 	struct ion_buffer *buffer;
 	struct dma_buf *dmabuf;
 	bool valid_handle;
-	int fd;
 
 	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
 	mutex_unlock(&client->lock);
 	if (!valid_handle) {
 		WARN(1, "%s: invalid handle passed to share.\n", __func__);
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
 	buffer = handle->buffer;
@@ -1268,15 +1268,29 @@
 	dmabuf = dma_buf_export(buffer, &dma_buf_ops, buffer->size, O_RDWR);
 	if (IS_ERR(dmabuf)) {
 		ion_buffer_put(buffer);
-		return PTR_ERR(dmabuf);
+		return dmabuf;
 	}
+
+	return dmabuf;
+}
+EXPORT_SYMBOL(ion_share_dma_buf);
+
+int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle)
+{
+	struct dma_buf *dmabuf;
+	int fd;
+
+	dmabuf = ion_share_dma_buf(client, handle);
+	if (IS_ERR(dmabuf))
+		return PTR_ERR(dmabuf);
+
 	fd = dma_buf_fd(dmabuf, O_CLOEXEC);
 	if (fd < 0)
 		dma_buf_put(dmabuf);
 
 	return fd;
 }
-EXPORT_SYMBOL(ion_share_dma_buf);
+EXPORT_SYMBOL(ion_share_dma_buf_fd);
 
 struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd)
 {
@@ -1366,7 +1380,7 @@
 		if (ret)
 			return ret;
 
-		data.fd = ion_share_dma_buf(client, data.handle);
+		data.fd = ion_share_dma_buf_fd(client, data.handle);
 		if (copy_to_user((void __user *)arg, &data, sizeof(data)))
 			return -EFAULT;
 		if (data.fd < 0)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/Kconfig flo-ElementalX-5.00-patched/drivers/gpu/msm/Kconfig
--- flo-ElementalX-5.00/drivers/gpu/msm/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/Kconfig	2014-09-21 01:02:11.000000000 +0000
@@ -96,11 +96,3 @@
 	bool "Disable register shadow writes for context switches"
 	default n
 	depends on MSM_KGSL
-
-config MSM_KGSL_SIMPLE_GOV
-	bool "Simple KGSL GPU govenor for Qualcomm Adreno xxx devices"
-	default n
-	depends on MSM_KGSL
-	---help---
-	  A simple KGSL GPU govenor for Qualcom Adreno XXX devices
-
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/Makefile flo-ElementalX-5.00-patched/drivers/gpu/msm/Makefile
--- flo-ElementalX-5.00/drivers/gpu/msm/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/Makefile	2014-09-21 01:02:11.000000000 +0000
@@ -25,8 +25,8 @@
 	adreno_dispatch.o \
 	adreno_postmortem.o \
 	adreno_snapshot.o \
-	adreno_coresight.o \
 	adreno_trace.o \
+	adreno_coresight.o \
 	adreno_a2xx.o \
 	adreno_a2xx_trace.o \
 	adreno_a2xx_snapshot.o \
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a2xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a2xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a2xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a2xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -252,15 +252,7 @@
 #define REG_CP_CSQ_IB1_STAT              0x01FE
 #define REG_CP_CSQ_IB2_STAT              0x01FF
 #define REG_CP_CSQ_RB_STAT               0x01FD
-
 #define REG_CP_DEBUG                     0x01FC
-/*
- * CP DEBUG settings for a3xx and a2xx cores:
- * DYNAMIC_CLK_DISABLE [27] - turn off the dynamic clock control
- * MIU_128BIT_WRITE_ENABLE [25] - Allow 128 bit writes to the VBIF
- */
-#define A2XX_CP_DEBUG_DEFAULT ((1 << 27) | (1 << 25))
-
 #define REG_CP_IB1_BASE                  0x0458
 #define REG_CP_IB1_BUFSZ                 0x0459
 #define REG_CP_IB2_BASE                  0x045A
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a3xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a3xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a3xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a3xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -487,11 +487,6 @@
 #define A3XX_VBIF_PERF_PWR_CNT2_LO 0x307b
 #define A3XX_VBIF_PERF_PWR_CNT2_HI 0x307c
 
-#define A3XX_VBIF_XIN_HALT_CTRL0 0x3080
-#define A3XX_VBIF_XIN_HALT_CTRL0_MASK 0x3F
-#define A3XX_VBIF_XIN_HALT_CTRL1 0x3081
-
-
 /* Bit flags for RBBM_CTL */
 #define RBBM_RBBM_CTL_RESET_PWR_CTR0  BIT(0)
 #define RBBM_RBBM_CTL_RESET_PWR_CTR1  BIT(1)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a4xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a4xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a4xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a4xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -24,201 +24,17 @@
 #define A4XX_RBBM_AHB_CTL1		0x24
 #define A4XX_RBBM_WAIT_IDLE_CLOCKS_CTL	0x2b
 #define A4XX_RBBM_INTERFACE_HANG_INT_CTL	0x2f
+#define A4XX_RBBM_AHB_ERROR_STATUS	0x18f
+#define A4XX_RBBM_STATUS		0x191
 #define A4XX_RBBM_INT_CLEAR_CMD		0x36
 #define A4XX_RBBM_INT_0_MASK		0x37
-
-#define A4XX_RBBM_PERFCTR_CP_0_LO		0x9c
-#define A4XX_RBBM_PERFCTR_CP_0_HI		0x9d
-#define A4XX_RBBM_PERFCTR_CP_1_LO		0x9e
-#define A4XX_RBBM_PERFCTR_CP_1_HI		0x9f
-#define A4XX_RBBM_PERFCTR_RBBM_0_LO		0xac
-#define A4XX_RBBM_PERFCTR_RBBM_0_HI		0xad
-#define A4XX_RBBM_PERFCTR_RBBM_1_LO		0xae
-#define A4XX_RBBM_PERFCTR_RBBM_1_HI		0xaf
-#define A4XX_RBBM_PERFCTR_RBBM_2_LO		0xb0
-#define A4XX_RBBM_PERFCTR_RBBM_2_HI		0xb1
-#define A4XX_RBBM_PERFCTR_RBBM_3_LO		0xb2
-#define A4XX_RBBM_PERFCTR_RBBM_3_HI		0xb3
-#define A4XX_RBBM_PERFCTR_PC_0_LO		0xb4
-#define A4XX_RBBM_PERFCTR_PC_0_HI		0xb5
-#define A4XX_RBBM_PERFCTR_PC_1_LO		0xb6
-#define A4XX_RBBM_PERFCTR_PC_1_HI		0xb7
-#define A4XX_RBBM_PERFCTR_PC_2_LO		0xb8
-#define A4XX_RBBM_PERFCTR_PC_2_HI		0xb9
-#define A4XX_RBBM_PERFCTR_PC_3_LO		0xba
-#define A4XX_RBBM_PERFCTR_PC_3_HI		0xbb
-#define A4XX_RBBM_PERFCTR_PC_4_LO		0xbc
-#define A4XX_RBBM_PERFCTR_PC_4_HI		0xbd
-#define A4XX_RBBM_PERFCTR_PC_5_LO		0xbe
-#define A4XX_RBBM_PERFCTR_PC_5_HI		0xbf
-#define A4XX_RBBM_PERFCTR_PC_6_LO		0xc0
-#define A4XX_RBBM_PERFCTR_PC_6_HI		0xc1
-#define A4XX_RBBM_PERFCTR_PC_7_LO		0xc2
-#define A4XX_RBBM_PERFCTR_PC_7_HI		0xc3
-#define A4XX_RBBM_PERFCTR_VFD_0_LO		0xc4
-#define A4XX_RBBM_PERFCTR_VFD_0_HI		0xc5
-#define A4XX_RBBM_PERFCTR_VFD_1_LO		0xc6
-#define A4XX_RBBM_PERFCTR_VFD_1_HI		0xc7
-#define A4XX_RBBM_PERFCTR_VFD_2_LO		0xc8
-#define A4XX_RBBM_PERFCTR_VFD_2_HI		0xc9
-#define A4XX_RBBM_PERFCTR_VFD_3_LO		0xca
-#define A4XX_RBBM_PERFCTR_VFD_3_HI		0xcb
-#define A4XX_RBBM_PERFCTR_VFD_4_LO		0xcc
-#define A4XX_RBBM_PERFCTR_VFD_4_HI		0xcd
-#define A4XX_RBBM_PERFCTR_VFD_5_LO		0xce
-#define A4XX_RBBM_PERFCTR_VFD_5_HI		0xcf
-#define A4XX_RBBM_PERFCTR_VFD_6_LO		0xd0
-#define A4XX_RBBM_PERFCTR_VFD_6_HI		0xd1
-#define A4XX_RBBM_PERFCTR_VFD_7_LO		0xd2
-#define A4XX_RBBM_PERFCTR_VFD_7_HI		0xd3
-#define A4XX_RBBM_PERFCTR_HLSQ_0_LO		0xd4
-#define A4XX_RBBM_PERFCTR_HLSQ_0_HI		0xd5
-#define A4XX_RBBM_PERFCTR_HLSQ_1_LO		0xd6
-#define A4XX_RBBM_PERFCTR_HLSQ_1_HI		0xd7
-#define A4XX_RBBM_PERFCTR_HLSQ_2_LO		0xd8
-#define A4XX_RBBM_PERFCTR_HLSQ_2_HI		0xd9
-#define A4XX_RBBM_PERFCTR_HLSQ_3_LO		0xda
-#define A4XX_RBBM_PERFCTR_HLSQ_3_HI		0xdb
-#define A4XX_RBBM_PERFCTR_HLSQ_4_LO		0xdc
-#define A4XX_RBBM_PERFCTR_HLSQ_4_HI		0xdd
-#define A4XX_RBBM_PERFCTR_HLSQ_5_LO		0xde
-#define A4XX_RBBM_PERFCTR_HLSQ_5_HI		0xdf
-#define A4XX_RBBM_PERFCTR_HLSQ_6_LO		0xe0
-#define A4XX_RBBM_PERFCTR_HLSQ_6_HI		0xe1
-#define A4XX_RBBM_PERFCTR_HLSQ_7_LO		0xe2
-#define A4XX_RBBM_PERFCTR_HLSQ_7_HI		0xe3
-#define A4XX_RBBM_PERFCTR_VPC_0_LO		0xe4
-#define A4XX_RBBM_PERFCTR_VPC_0_HI		0xe5
-#define A4XX_RBBM_PERFCTR_VPC_1_LO		0xe6
-#define A4XX_RBBM_PERFCTR_VPC_1_HI		0xe7
-#define A4XX_RBBM_PERFCTR_VPC_2_LO		0xe8
-#define A4XX_RBBM_PERFCTR_VPC_2_HI		0xe9
-#define A4XX_RBBM_PERFCTR_VPC_3_LO		0xea
-#define A4XX_RBBM_PERFCTR_VPC_3_HI		0xeb
-#define A4XX_RBBM_PERFCTR_CCU_0_LO		0xec
-#define A4XX_RBBM_PERFCTR_CCU_0_HI		0xed
-#define A4XX_RBBM_PERFCTR_CCU_1_LO		0xee
-#define A4XX_RBBM_PERFCTR_CCU_1_HI		0xef
-#define A4XX_RBBM_PERFCTR_CCU_2_LO		0xf0
-#define A4XX_RBBM_PERFCTR_CCU_2_HI		0xf1
-#define A4XX_RBBM_PERFCTR_CCU_3_LO		0xf2
-#define A4XX_RBBM_PERFCTR_CCU_3_HI		0xf3
-#define A4XX_RBBM_PERFCTR_TSE_0_LO		0xf4
-#define A4XX_RBBM_PERFCTR_TSE_0_HI		0xf5
-#define A4XX_RBBM_PERFCTR_TSE_1_LO		0xf6
-#define A4XX_RBBM_PERFCTR_TSE_1_HI		0xf7
-#define A4XX_RBBM_PERFCTR_TSE_2_LO		0xf8
-#define A4XX_RBBM_PERFCTR_TSE_2_HI		0xf9
-#define A4XX_RBBM_PERFCTR_TSE_3_LO		0xfa
-#define A4XX_RBBM_PERFCTR_TSE_3_HI		0xfb
-#define A4XX_RBBM_PERFCTR_RAS_0_LO		0xfc
-#define A4XX_RBBM_PERFCTR_RAS_0_HI		0xfd
-#define A4XX_RBBM_PERFCTR_RAS_1_LO		0xfe
-#define A4XX_RBBM_PERFCTR_RAS_1_HI		0xff
-#define A4XX_RBBM_PERFCTR_RAS_2_LO		0x100
-#define A4XX_RBBM_PERFCTR_RAS_2_HI		0x101
-#define A4XX_RBBM_PERFCTR_RAS_3_LO		0x102
-#define A4XX_RBBM_PERFCTR_RAS_3_HI		0x103
-#define A4XX_RBBM_PERFCTR_UCHE_0_LO		0x104
-#define A4XX_RBBM_PERFCTR_UCHE_0_HI		0x105
-#define A4XX_RBBM_PERFCTR_UCHE_1_LO		0x106
-#define A4XX_RBBM_PERFCTR_UCHE_1_HI		0x107
-#define A4XX_RBBM_PERFCTR_UCHE_2_LO		0x108
-#define A4XX_RBBM_PERFCTR_UCHE_2_HI		0x109
-#define A4XX_RBBM_PERFCTR_UCHE_3_LO		0x10a
-#define A4XX_RBBM_PERFCTR_UCHE_3_HI		0x10b
-#define A4XX_RBBM_PERFCTR_UCHE_4_LO		0x10c
-#define A4XX_RBBM_PERFCTR_UCHE_4_HI		0x10d
-#define A4XX_RBBM_PERFCTR_UCHE_5_LO		0x10e
-#define A4XX_RBBM_PERFCTR_UCHE_5_HI		0x10f
-#define A4XX_RBBM_PERFCTR_UCHE_6_LO		0x110
-#define A4XX_RBBM_PERFCTR_UCHE_6_HI		0x111
-#define A4XX_RBBM_PERFCTR_UCHE_7_LO		0x112
-#define A4XX_RBBM_PERFCTR_UCHE_7_HI		0x113
-#define A4XX_RBBM_PERFCTR_TP_0_LO		0x114
-#define A4XX_RBBM_PERFCTR_TP_0_HI		0x115
-#define A4XX_RBBM_PERFCTR_TP_1_LO		0x116
-#define A4XX_RBBM_PERFCTR_TP_1_HI		0x117
-#define A4XX_RBBM_PERFCTR_TP_2_LO		0x118
-#define A4XX_RBBM_PERFCTR_TP_2_HI		0x119
-#define A4XX_RBBM_PERFCTR_TP_3_LO		0x11a
-#define A4XX_RBBM_PERFCTR_TP_3_HI		0x11b
-#define A4XX_RBBM_PERFCTR_TP_4_LO		0x11c
-#define A4XX_RBBM_PERFCTR_TP_4_HI		0x11d
-#define A4XX_RBBM_PERFCTR_TP_5_LO		0x11e
-#define A4XX_RBBM_PERFCTR_TP_5_HI		0x11f
-#define A4XX_RBBM_PERFCTR_TP_6_LO		0x120
-#define A4XX_RBBM_PERFCTR_TP_6_HI		0x121
-#define A4XX_RBBM_PERFCTR_TP_7_LO		0x122
-#define A4XX_RBBM_PERFCTR_TP_7_HI		0x123
-#define A4XX_RBBM_PERFCTR_SP_0_LO		0x124
-#define A4XX_RBBM_PERFCTR_SP_0_HI		0x125
-#define A4XX_RBBM_PERFCTR_SP_1_LO		0x126
-#define A4XX_RBBM_PERFCTR_SP_1_HI		0x127
-#define A4XX_RBBM_PERFCTR_SP_2_LO		0x128
-#define A4XX_RBBM_PERFCTR_SP_2_HI		0x129
-#define A4XX_RBBM_PERFCTR_SP_3_LO		0x12a
-#define A4XX_RBBM_PERFCTR_SP_3_HI		0x12b
-#define A4XX_RBBM_PERFCTR_SP_4_LO		0x12c
-#define A4XX_RBBM_PERFCTR_SP_4_HI		0x12d
-#define A4XX_RBBM_PERFCTR_SP_5_LO		0x12e
-#define A4XX_RBBM_PERFCTR_SP_5_HI		0x12f
-#define A4XX_RBBM_PERFCTR_SP_6_LO		0x130
-#define A4XX_RBBM_PERFCTR_SP_6_HI		0x131
-#define A4XX_RBBM_PERFCTR_SP_7_LO		0x132
-#define A4XX_RBBM_PERFCTR_SP_7_HI		0x133
-#define A4XX_RBBM_PERFCTR_SP_8_LO		0x134
-#define A4XX_RBBM_PERFCTR_SP_8_HI		0x135
-#define A4XX_RBBM_PERFCTR_SP_9_LO		0x136
-#define A4XX_RBBM_PERFCTR_SP_9_HI		0x137
-#define A4XX_RBBM_PERFCTR_SP_10_LO		0x138
-#define A4XX_RBBM_PERFCTR_SP_10_HI		0x139
-#define A4XX_RBBM_PERFCTR_SP_11_LO		0x13a
-#define A4XX_RBBM_PERFCTR_SP_11_HI		0x13b
-#define A4XX_RBBM_PERFCTR_RB_0_LO		0x13c
-#define A4XX_RBBM_PERFCTR_RB_0_HI		0x13d
-#define A4XX_RBBM_PERFCTR_RB_1_LO		0x13e
-#define A4XX_RBBM_PERFCTR_RB_1_HI		0x13f
-#define A4XX_RBBM_PERFCTR_RB_2_LO		0x140
-#define A4XX_RBBM_PERFCTR_RB_2_HI		0x141
-#define A4XX_RBBM_PERFCTR_RB_3_LO		0x142
-#define A4XX_RBBM_PERFCTR_RB_3_HI		0x143
-#define A4XX_RBBM_PERFCTR_RB_4_LO		0x144
-#define A4XX_RBBM_PERFCTR_RB_4_HI		0x145
-#define A4XX_RBBM_PERFCTR_RB_5_LO		0x146
-#define A4XX_RBBM_PERFCTR_RB_5_HI		0x147
-#define A4XX_RBBM_PERFCTR_RB_6_LO		0x148
-#define A4XX_RBBM_PERFCTR_RB_6_HI		0x149
-#define A4XX_RBBM_PERFCTR_RB_7_LO		0x14a
-#define A4XX_RBBM_PERFCTR_RB_7_HI		0x14b
-#define A4XX_RBBM_PERFCTR_VSC_0_LO		0x14c
-#define A4XX_RBBM_PERFCTR_VSC_0_HI		0x14d
-#define A4XX_RBBM_PERFCTR_VSC_1_LO		0x14e
-#define A4XX_RBBM_PERFCTR_VSC_1_HI		0x14f
-#define A4XX_RBBM_PERFCTR_PWR_0_LO		0x166
-#define A4XX_RBBM_PERFCTR_PWR_0_HI		0x167
-#define A4XX_RBBM_PERFCTR_PWR_1_LO		0x168
-#define A4XX_RBBM_PERFCTR_PWR_1_HI		0x169
-#define A4XX_RBBM_PERFCTR_CTL			0x170
-#define A4XX_RBBM_PERFCTR_LOAD_CMD0		0x171
-#define A4XX_RBBM_PERFCTR_LOAD_CMD1		0x172
-#define A4XX_RBBM_PERFCTR_LOAD_CMD2		0x173
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_0		0x176
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_1		0x177
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_2		0x178
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_3		0x179
-#define A4XX_RBBM_GPU_BUSY_MASKED		0x17a
-#define A4XX_RBBM_INT_0_STATUS			0x17d
-#define A4XX_RBBM_AHB_ERROR_STATUS		0x18f
-#define A4XX_RBBM_STATUS			0x191
-#define A4XX_RBBM_CFG_COUNTER0			0x1a2
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF0		0x1a9
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF1		0x1aa
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF2		0x1ab
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF3		0x1ac
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF4		0x1ad
-#define A4XX_RBBM_CFG_DEBBUS_MISR0		0x1ae
-#define A4XX_RBBM_CFG_DEBBUS_MISR1		0x1af
+#define A4XX_RBBM_INT_0_STATUS		0x17d
+#define A4XX_RBBM_PERFCTR_CTL		0x170
+#define A4XX_RBBM_PERFCTR_LOAD_CMD0	0x171
+#define A4XX_RBBM_PERFCTR_LOAD_CMD1	0x172
+#define A4XX_RBBM_PERFCTR_LOAD_CMD2	0x173
+#define A4XX_RBBM_GPU_BUSY_MASKED	0x17a
+#define A4XX_RBBM_PERFCTR_PWR_1_LO	0x168
 
 /* CP registers */
 #define A4XX_CP_SCRATCH_REG0		0x578
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.c	2014-09-21 01:02:11.000000000 +0000
@@ -17,6 +17,7 @@
 #include <linux/sched.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/msm_kgsl.h>
 #include <linux/delay.h>
 #include <linux/of_coresight.h>
 
@@ -161,12 +162,6 @@
 	unsigned int pfp_jt_idx;
 	/* PFP jump table load addr */
 	unsigned int pfp_jt_addr;
-	/* PM4 bootstrap loader size */
-	unsigned int pm4_bstrp_size;
-	/* PFP bootstrap loader size */
-	unsigned int pfp_bstrp_size;
-	/* PFP bootstrap loader supported version */
-	unsigned int pfp_bstrp_ver;
 
 } adreno_gpulist[] = {
 	{ ADRENO_REV_A200, 0, 2, ANY_ID, ANY_ID,
@@ -204,8 +199,7 @@
 		512, 0, 2, SZ_512K, 0x3FF037, 0x3FF016 },
 	{ ADRENO_REV_A330, 3, 3, 0, ANY_ID,
 		"a330_pm4.fw", "a330_pfp.fw", &adreno_a3xx_gpudev,
-		512, 0, 2, SZ_1M, NO_VER, NO_VER, 0x8AD, 0x2E4, 0x201, 0x200,
-		0x6, 0x20, 0x330020 },
+		512, 0, 2, SZ_1M, NO_VER, NO_VER, 0x8AD, 0x2E4, 0x201, 0x200 },
 	{ ADRENO_REV_A305B, 3, 0, 5, 0x10,
 		"a330_pm4.fw", "a330_pfp.fw", &adreno_a3xx_gpudev,
 		512, 0, 2, SZ_128K, NO_VER, NO_VER, 0x8AD, 0x2E4,
@@ -425,29 +419,12 @@
 	return 0;
 }
 
-static inline void refcount_group(struct adreno_perfcount_group *group,
-	unsigned int reg, unsigned int flags,
-	unsigned int *lo, unsigned int *hi)
-{
-	if (flags & PERFCOUNTER_FLAG_KERNEL)
-		group->regs[reg].kernelcount++;
-	else
-		group->regs[reg].usercount++;
-
-	if (lo)
-		*lo = group->regs[reg].offset;
-
-	if (hi)
-		*hi = group->regs[reg].offset_hi;
-}
-
 /**
  * adreno_perfcounter_get: Try to put a countable in an available counter
  * @adreno_dev: Adreno device to configure
  * @groupid: Desired performance counter group
  * @countable: Countable desired to be in a counter
- * @offset: Return offset of the LO counter assigned
- * @offset_hi: Return offset of the HI counter assigned
+ * @offset: Return offset of the countable
  * @flags: Used to setup kernel perf counters
  *
  * Try to place a countable in an available counter.  If the countable is
@@ -457,7 +434,7 @@
 
 int adreno_perfcounter_get(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int *offset,
-	unsigned int *offset_hi, unsigned int flags)
+	unsigned int flags)
 {
 	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
 	struct adreno_perfcount_group *group;
@@ -467,8 +444,6 @@
 	/* always clear return variables */
 	if (offset)
 		*offset = 0;
-	if (offset_hi)
-		*offset_hi = 0;
 
 	if (NULL == counters)
 		return -EINVAL;
@@ -480,16 +455,22 @@
 
 	/*
 	 * Check if the countable is already associated with a counter.
-	 * Refcount and return the offset, otherwise, try and find an
-	 * empty counter and assign the countable to it.
+	 * Refcount and return the offset, otherwise, try and find an empty
+	 * counter and assign the countable to it.
 	 */
-
 	for (i = 0; i < group->reg_count; i++) {
 		if (group->regs[i].countable == countable) {
-			refcount_group(group, i, flags, offset, offset_hi);
+			/* Countable already associated with counter */
+			if (flags & PERFCOUNTER_FLAG_KERNEL)
+				group->regs[i].kernelcount++;
+			else
+				group->regs[i].usercount++;
+
+			if (offset)
+				*offset = group->regs[i].offset;
 			return 0;
 		} else if (group->regs[i].countable ==
-					KGSL_PERFCOUNTER_NOT_USED) {
+			KGSL_PERFCOUNTER_NOT_USED) {
 			/* keep track of unused counter */
 			empty = i;
 		}
@@ -518,8 +499,6 @@
 
 	if (offset)
 		*offset = group->regs[empty].offset;
-	if (offset_hi)
-		*offset_hi = group->regs[empty].offset_hi;
 
 	return ret;
 }
@@ -595,6 +574,8 @@
 
 	kgsl_mmu_unmap(pagetable, &rb->buffer_desc);
 
+	kgsl_mmu_unmap(pagetable, &rb->memptrs_desc);
+
 	kgsl_mmu_unmap(pagetable, &device->memstore);
 
 	kgsl_mmu_unmap(pagetable, &adreno_dev->pwron_fixup);
@@ -611,11 +592,8 @@
 
 	result = kgsl_mmu_map_global(pagetable, &rb->buffer_desc);
 
-	/*
-	 * ALERT: Order of these mapping is important to
-	 * Keep the most used entries like memstore
-	 * and mmu setstate memory by TLB prefetcher.
-	 */
+	if (!result)
+		result = kgsl_mmu_map_global(pagetable, &rb->memptrs_desc);
 
 	if (!result)
 		result = kgsl_mmu_map_global(pagetable, &device->memstore);
@@ -884,7 +862,9 @@
 					uint32_t flags)
 {
 	phys_addr_t pt_val;
-	unsigned int *link, *cmds;
+	unsigned int link[230];
+	unsigned int *cmds = &link[0];
+	int sizedwords = 0;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int num_iommu_units;
 	struct kgsl_context *context;
@@ -899,18 +879,17 @@
 	num_iommu_units = kgsl_mmu_get_num_iommu_units(&device->mmu);
 
 	context = kgsl_context_get(device, context_id);
-	if (context)
-		adreno_ctx = ADRENO_CONTEXT(context);
-
-	link = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (link == NULL) {
-		result = -ENOMEM;
-		goto done;
+	if (context == NULL) {
+		kgsl_mmu_device_setstate(&device->mmu, KGSL_CONTEXT_INVALID);
+		return -EINVAL;
 	}
 
-	cmds = link;
+	adreno_ctx = ADRENO_CONTEXT(context);
 
-	kgsl_mmu_enable_clk(&device->mmu, KGSL_IOMMU_MAX_UNITS);
+	result = kgsl_mmu_enable_clk(&device->mmu,
+				KGSL_IOMMU_CONTEXT_USER);
+	if (result)
+		goto done;
 
 	pt_val = kgsl_mmu_get_pt_base_addr(&device->mmu,
 				device->mmu.hwpagetable);
@@ -927,11 +906,17 @@
 		cmds += _adreno_iommu_setstate_v1(device, cmds, pt_val,
 						num_iommu_units, flags);
 
+	sizedwords += (cmds - &link[0]);
+	if (sizedwords == 0) {
+		KGSL_DRV_ERR(device, "no commands generated\n");
+		BUG();
+	}
 	/* invalidate all base pointers */
 	*cmds++ = cp_type3_packet(CP_INVALIDATE_STATE, 1);
 	*cmds++ = 0x7fff;
+	sizedwords += 2;
 
-	if ((unsigned int) (cmds - link) > (PAGE_SIZE / sizeof(unsigned int))) {
+	if (sizedwords > (sizeof(link)/sizeof(unsigned int))) {
 		KGSL_DRV_ERR(device, "Temp command buffer overflow\n");
 		BUG();
 	}
@@ -939,22 +924,13 @@
 	 * This returns the per context timestamp but we need to
 	 * use the global timestamp for iommu clock disablement
 	 */
-	result = adreno_ringbuffer_issuecmds(device, adreno_ctx,
-			KGSL_CMD_FLAGS_PMODE, link,
-			(unsigned int)(cmds - link));
+	adreno_ringbuffer_issuecmds(device, adreno_ctx, KGSL_CMD_FLAGS_PMODE,
+			&link[0], sizedwords);
 
-	/*
-	 * On error disable the IOMMU clock right away otherwise turn it off
-	 * after the command has been retired
-	 */
-	if (result)
-		kgsl_mmu_disable_clk(&device->mmu, KGSL_IOMMU_MAX_UNITS);
-	else
-		kgsl_mmu_disable_clk_on_ts(&device->mmu, rb->global_ts,
-						KGSL_IOMMU_MAX_UNITS);
+	kgsl_mmu_disable_clk_on_ts(&device->mmu,
+		rb->global_ts, true);
 
 done:
-	kfree(link);
 	kgsl_context_put(context);
 	return result;
 }
@@ -988,7 +964,6 @@
 		context = kgsl_context_get(device, context_id);
 		if (context == NULL)
 			return -EINVAL;
-
 		adreno_ctx = ADRENO_CONTEXT(context);
 
 		if (flags & KGSL_MMUFLAGS_PTUPDATE) {
@@ -1204,11 +1179,8 @@
 	adreno_dev->gmem_size = adreno_gpulist[i].gmem_size;
 	adreno_dev->pm4_jt_idx = adreno_gpulist[i].pm4_jt_idx;
 	adreno_dev->pm4_jt_addr = adreno_gpulist[i].pm4_jt_addr;
-	adreno_dev->pm4_bstrp_size = adreno_gpulist[i].pm4_bstrp_size;
 	adreno_dev->pfp_jt_idx = adreno_gpulist[i].pfp_jt_idx;
 	adreno_dev->pfp_jt_addr = adreno_gpulist[i].pfp_jt_addr;
-	adreno_dev->pfp_bstrp_size = adreno_gpulist[i].pfp_bstrp_size;
-	adreno_dev->pfp_bstrp_ver = adreno_gpulist[i].pfp_bstrp_ver;
 	adreno_dev->gpulist_index = i;
 	/*
 	 * Initialize uninitialzed gpu registers, only needs to be done once
@@ -1617,6 +1589,7 @@
 static int adreno_init(struct kgsl_device *device)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 	int i;
 	int ret;
 
@@ -1664,6 +1637,8 @@
 		adreno_gpulist[adreno_dev->gpulist_index].sync_lock_pfp_ver))
 		device->mmu.flags |= KGSL_MMU_FLAGS_IOMMU_SYNC;
 
+	rb->global_ts = 0;
+
 	/* Initialize ft detection register offsets */
 	ft_detect_regs[0] = adreno_getreg(adreno_dev,
 						ADRENO_REG_RBBM_STATUS);
@@ -1692,6 +1667,7 @@
 	if (adreno_is_a330v2(adreno_dev))
 		adreno_a3xx_pwron_fixup_init(adreno_dev);
 
+	set_bit(ADRENO_DEVICE_INITIALIZED, &adreno_dev->priv);
 done:
 	return ret;
 }
@@ -1703,9 +1679,6 @@
 	unsigned int state = device->state;
 	unsigned int regulator_left_on = 0;
 
-	if (test_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv))
-		return 0;
-
 	kgsl_cffdump_open(device);
 
 	kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
@@ -1715,7 +1688,7 @@
 				regulator_is_enabled(device->pwrctrl.gpu_cx)));
 
 	/* Clear any GPU faults that might have been left over */
-	adreno_clear_gpu_fault(adreno_dev);
+	adreno_set_gpu_fault(adreno_dev, 0);
 
 	/* Power up the device */
 	kgsl_pwrctrl_enable(device);
@@ -1761,21 +1734,23 @@
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
 
-	adreno_perfcounter_start(adreno_dev);
-
-	status = adreno_ringbuffer_cold_start(&adreno_dev->ringbuffer);
+	status = adreno_ringbuffer_start(&adreno_dev->ringbuffer);
 	if (status)
 		goto error_irq_off;
 
+	status = adreno_perfcounter_start(adreno_dev);
+	if (status)
+		goto error_rb_stop;
+
 	/* Start the dispatcher */
 	adreno_dispatcher_start(device);
 
 	device->reset_counter++;
 
-	set_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
 	return 0;
 
+error_rb_stop:
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
 error_irq_off:
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
 
@@ -1790,44 +1765,19 @@
 	return status;
 }
 
-/**
- * adreno_vbif_clear_pending_transactions() - Clear transactions in VBIF pipe
- * @device: Pointer to the device whose VBIF pipe is to be cleared
- */
-static void adreno_vbif_clear_pending_transactions(struct kgsl_device *device)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int mask = A3XX_VBIF_XIN_HALT_CTRL0_MASK;
-	unsigned int val;
-	unsigned long wait_for_vbif;
-
-	adreno_writereg(adreno_dev, ADRENO_REG_VBIF_XIN_HALT_CTRL0, mask);
-	/* wait for the transactions to clear */
-	wait_for_vbif = jiffies + msecs_to_jiffies(100);
-	while (1) {
-		adreno_readreg(adreno_dev,
-			ADRENO_REG_VBIF_XIN_HALT_CTRL1, &val);
-		if ((val & mask) == mask)
-			break;
-		if (time_after(jiffies, wait_for_vbif))
-			break;
-	}
-	adreno_writereg(adreno_dev, ADRENO_REG_VBIF_XIN_HALT_CTRL0, 0);
-}
-
-
 static int adreno_stop(struct kgsl_device *device)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	if (!test_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv))
-		return 0;
-
-	kgsl_pwrctrl_enable(device);
+	if (adreno_dev->drawctxt_active)
+		kgsl_context_put(&adreno_dev->drawctxt_active->base);
 
 	adreno_dev->drawctxt_active = NULL;
 
 	adreno_dispatcher_stop(adreno_dev);
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
+
+	kgsl_mmu_stop(&device->mmu);
 
 	device->ftbl->irqctrl(device, 0);
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
@@ -1835,15 +1785,11 @@
 
 	adreno_ocmem_gmem_free(adreno_dev);
 
-	kgsl_mmu_stop(&device->mmu);
-
 	/* Power down the device */
 	kgsl_pwrctrl_disable(device);
 
 	kgsl_cffdump_close(device);
 
-	clear_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
 	return 0;
 }
 
@@ -1851,20 +1797,20 @@
  * adreno_reset() - Helper function to reset the GPU
  * @device: Pointer to the KGSL device structure for the GPU
  *
- * Try to reset the GPU to recover from a fault.  First, try to do a low latency
- * soft reset.  If the soft reset fails for some reason, then bring out the big
- * guns and toggle the footswitch.
+ * Helper function to reset the GPU hardware by toggling the footswitch
  */
 int adreno_reset(struct kgsl_device *device)
 {
 	int ret = -EINVAL;
+	struct kgsl_mmu *mmu = &device->mmu;
 	int i = 0;
 
-	/* clear pending vbif transactions before reset */
-	adreno_vbif_clear_pending_transactions(device);
-
-	/* Try soft reset first */
-	ret = adreno_soft_reset(device);
+	/* Try soft reset first, for non mmu fault case only */
+	if (!atomic_read(&mmu->fault)) {
+		ret = adreno_soft_reset(device);
+		if (ret)
+			KGSL_DEV_ERR_ONCE(device, "Device soft reset failed\n");
+	}
 	if (ret) {
 		/* If soft reset failed/skipped, then pull the power */
 		adreno_stop(device);
@@ -2255,70 +2201,12 @@
 	return status;
 }
 
-static int adreno_set_constraint(struct kgsl_device *device,
-				struct kgsl_context *context,
-				struct kgsl_device_constraint *constraint)
-{
-	int status = 0;
-
-	switch (constraint->type) {
-	case KGSL_CONSTRAINT_PWRLEVEL: {
-		struct kgsl_device_constraint_pwrlevel pwr;
-
-		if (constraint->size != sizeof(pwr)) {
-			status = -EINVAL;
-			break;
-		}
-
-		if (copy_from_user(&pwr,
-				(void __user *)constraint->data,
-				sizeof(pwr))) {
-			status = -EFAULT;
-			break;
-		}
-		if (pwr.level >= KGSL_CONSTRAINT_PWR_MAXLEVELS) {
-			status = -EINVAL;
-			break;
-		}
-
-		context->pwr_constraint.type =
-				KGSL_CONSTRAINT_PWRLEVEL;
-		context->pwr_constraint.sub_type = pwr.level;
-		trace_kgsl_user_pwrlevel_constraint(device,
-			context->id,
-			context->pwr_constraint.type,
-			context->pwr_constraint.sub_type);
-		}
-		break;
-	case KGSL_CONSTRAINT_NONE:
-		if (context->pwr_constraint.type == KGSL_CONSTRAINT_PWRLEVEL)
-			trace_kgsl_user_pwrlevel_constraint(device,
-				context->id,
-				KGSL_CONSTRAINT_NONE,
-				context->pwr_constraint.sub_type);
-		context->pwr_constraint.type = KGSL_CONSTRAINT_NONE;
-		break;
-
-	default:
-		status = -EINVAL;
-		break;
-	}
-
-	/* If a new constraint has been set for a context, cancel the old one */
-	if ((status == 0) &&
-		(context->id == device->pwrctrl.constraint.owner_id))
-		device->pwrctrl.constraint.type = KGSL_CONSTRAINT_NONE;
-
-	return status;
-}
-
-static int adreno_setproperty(struct kgsl_device_private *dev_priv,
+static int adreno_setproperty(struct kgsl_device *device,
 				enum kgsl_property_type type,
 				void *value,
 				unsigned int sizebytes)
 {
 	int status = -EINVAL;
-	struct kgsl_device *device = dev_priv->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	switch (type) {
@@ -2335,7 +2223,6 @@
 			}
 
 			if (enable) {
-				device->pwrctrl.ctrl_flags = 0;
 				adreno_dev->fast_hang_detect = 1;
 				kgsl_pwrscale_enable(device);
 			} else {
@@ -2348,28 +2235,6 @@
 			status = 0;
 		}
 		break;
-	case KGSL_PROP_PWR_CONSTRAINT: {
-			struct kgsl_device_constraint constraint;
-			struct kgsl_context *context;
-
-			if (sizebytes != sizeof(constraint))
-				break;
-
-			if (copy_from_user(&constraint, value,
-				sizeof(constraint))) {
-				status = -EFAULT;
-				break;
-			}
-
-			context = kgsl_context_get_owner(dev_priv,
-							constraint.context_id);
-			if (context == NULL)
-				break;
-			status = adreno_set_constraint(device, context,
-								&constraint);
-			kgsl_context_put(context);
-		}
-		break;
 	default:
 		break;
 	}
@@ -2393,6 +2258,7 @@
 	if (adreno_dev->gpudev->irq_pending(adreno_dev))
 		return false;
 
+	/* Read the correct RBBM status for the GPU type */
 	adreno_readreg(adreno_dev, ADRENO_REG_RBBM_STATUS,
 		&reg_rbbm_status);
 
@@ -2425,19 +2291,17 @@
 		return -EINVAL;
 	}
 
-	clear_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
-	if (adreno_dev->drawctxt_active)
-		kgsl_context_put(&adreno_dev->drawctxt_active->base);
-
 	adreno_dev->drawctxt_active = NULL;
 
+	/* Stop the ringbuffer */
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
+
 	if (kgsl_pwrctrl_isenabled(device))
 		device->ftbl->irqctrl(device, 0);
 
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
 
-	adreno_clear_gpu_fault(adreno_dev);
+	adreno_set_gpu_fault(adreno_dev, 0);
 
 	/* Delete the idle timer */
 	del_timer_sync(&device->idle_timer);
@@ -2463,20 +2327,17 @@
 	if (adreno_dev->pm4_jt_idx)
 		ret = adreno_ringbuffer_warm_start(&adreno_dev->ringbuffer);
 	else
-		ret = adreno_ringbuffer_cold_start(&adreno_dev->ringbuffer);
+		ret = adreno_ringbuffer_start(&adreno_dev->ringbuffer);
 
 	if (ret)
 		return ret;
-	else {
-		device->reset_counter++;
-		set_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-	}
 
+	device->reset_counter++;
 
 	return 0;
 }
 
-/*
+/**
  * adreno_isidle() - return true if the GPU hardware is idle
  * @device: Pointer to the KGSL device structure for the GPU
  *
@@ -2488,7 +2349,8 @@
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	unsigned int rptr;
 
-	if (!kgsl_pwrctrl_isenabled(device))
+	/* If the device isn't active, don't force it on. */
+	if (device->state != KGSL_STATE_ACTIVE)
 		return true;
 
 	rptr = adreno_get_rptr(&adreno_dev->ringbuffer);
@@ -2521,7 +2383,7 @@
 	if (adreno_is_a3xx(adreno_dev) || adreno_is_a4xx(adreno_dev))
 		kgsl_cffdump_regpoll(device,
 			adreno_getreg(adreno_dev, ADRENO_REG_RBBM_STATUS) << 2,
-			0x00000000, 0x80000000);
+		        0x00000000, 0x80000000);
 	else
 		kgsl_cffdump_regpoll(device,
 			adreno_getreg(adreno_dev, ADRENO_REG_RBBM_STATUS) << 2,
@@ -2637,6 +2499,9 @@
 	if (kgsl_gpuaddr_in_memdesc(&ringbuffer->buffer_desc, gpuaddr, size))
 		return &ringbuffer->buffer_desc;
 
+	if (kgsl_gpuaddr_in_memdesc(&ringbuffer->memptrs_desc, gpuaddr, size))
+		return &ringbuffer->memptrs_desc;
+
 	if (kgsl_gpuaddr_in_memdesc(&device->memstore, gpuaddr, size))
 		return &device->memstore;
 
@@ -2753,6 +2618,143 @@
 	__raw_writel(value, reg);
 }
 
+
+static unsigned int _get_context_id(struct kgsl_context *k_ctxt)
+{
+	unsigned int context_id = KGSL_MEMSTORE_GLOBAL;
+
+	if (k_ctxt != NULL) {
+		struct adreno_context *a_ctxt = ADRENO_CONTEXT(k_ctxt);
+		if (kgsl_context_detached(k_ctxt))
+			context_id = KGSL_CONTEXT_INVALID;
+		else if (a_ctxt->flags & CTXT_FLAGS_PER_CONTEXT_TS)
+			context_id = k_ctxt->id;
+	}
+
+	return context_id;
+}
+static unsigned int adreno_check_hw_ts(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	int status = 0;
+	unsigned int ref_ts, enableflag;
+	unsigned int context_id = _get_context_id(context);
+
+	/*
+	 * If the context ID is invalid, we are in a race with
+	 * the context being destroyed by userspace so bail.
+	 */
+	if (context_id == KGSL_CONTEXT_INVALID) {
+		KGSL_DRV_WARN(device, "context was detached");
+		return -EINVAL;
+	}
+
+	status = kgsl_check_timestamp(device, context, timestamp);
+	if (status)
+		return status;
+
+	kgsl_sharedmem_readl(&device->memstore, &enableflag,
+			KGSL_MEMSTORE_OFFSET(context_id, ts_cmp_enable));
+	/*
+	 * Barrier is needed here to make sure the read from memstore
+	 * has posted
+	 */
+
+	mb();
+
+	if (enableflag) {
+		kgsl_sharedmem_readl(&device->memstore, &ref_ts,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ref_wait_ts));
+
+		/* Make sure the memstore read has posted */
+		mb();
+		if (timestamp_cmp(ref_ts, timestamp) >= 0) {
+			kgsl_sharedmem_writel(device, &device->memstore,
+					KGSL_MEMSTORE_OFFSET(context_id,
+						ref_wait_ts), timestamp);
+			/* Make sure the memstore write is posted */
+			wmb();
+		}
+	} else {
+		kgsl_sharedmem_writel(device, &device->memstore,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ref_wait_ts), timestamp);
+		enableflag = 1;
+		kgsl_sharedmem_writel(device, &device->memstore,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ts_cmp_enable), enableflag);
+
+		/* Make sure the memstore write gets posted */
+		wmb();
+
+		/*
+		 * submit a dummy packet so that even if all
+		 * commands upto timestamp get executed we will still
+		 * get an interrupt
+		 */
+
+		if (context && device->state != KGSL_STATE_SLUMBER) {
+			adreno_ringbuffer_issuecmds(device,
+					ADRENO_CONTEXT(context),
+					KGSL_CMD_FLAGS_GET_INT, NULL, 0);
+		}
+	}
+
+	return 0;
+}
+static int _check_pending_timestamp(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	unsigned int context_id = _get_context_id(context);
+	unsigned int ts_issued;
+
+	if (context_id == KGSL_CONTEXT_INVALID)
+		return -EINVAL;
+
+	ts_issued = adreno_dev->ringbuffer.timestamp[context_id];
+
+	if (timestamp_cmp(timestamp, ts_issued) <= 0)
+		return 0;
+
+	if (context && !context->wait_on_invalid_ts) {
+		KGSL_DRV_ERR(device, "Cannot wait for invalid ts <%d:0x%x>, last issued ts <%d:0x%x>\n",
+			context_id, timestamp, context_id, ts_issued);
+
+			/* Only print this message once */
+			context->wait_on_invalid_ts = true;
+	}
+
+	return -EINVAL;
+}
+
+/*
+ wait_event_interruptible_timeout checks for the exit condition before
+ placing a process in wait q. For conditional interrupts we expect the
+ process to already be in its wait q when its exit condition checking
+ function is called.
+*/
+#define kgsl_wait_event_interruptible_timeout(wq, condition, timeout, io)\
+({									\
+	long __ret = timeout;						\
+	if (io)						\
+		__wait_io_event_interruptible_timeout(wq, condition, __ret);\
+	else						\
+		__wait_event_interruptible_timeout(wq, condition, __ret);\
+	__ret;								\
+})
+static int adreno_check_interrupt_timestamp(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	int status;
+
+	mutex_lock(&device->mutex);
+	status = adreno_check_hw_ts(device, context, timestamp);
+	mutex_unlock(&device->mutex);
+
+	return status;
+}
 /**
  * adreno_waittimestamp - sleep while waiting for the specified timestamp
  * @device - pointer to a KGSL device structure
@@ -2767,37 +2769,137 @@
 		unsigned int timestamp,
 		unsigned int msecs)
 {
-	int ret;
-	struct adreno_context *drawctxt;
+    
+	static unsigned int io_cnt;
+	struct adreno_context *adreno_ctx = context ? ADRENO_CONTEXT(context) :
+		NULL;
+	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
+	unsigned int context_id = _get_context_id(context);
+	unsigned int time_elapsed = 0;
+	unsigned int wait;
+	int ts_compare = 1;
+	int io, ret = -ETIMEDOUT;
 
-	if (context == NULL) {
-		/* If they are doing then complain once */
-		dev_WARN_ONCE(device->dev, 1,
-			"IOCTL_KGSL_DEVICE_WAITTIMESTAMP is deprecated\n");
-		return -ENOTTY;
-	}
+	/* Get out early if the context has already been destroyed */
 
-	/* Return -EINVAL if the context has been detached */
-	if (kgsl_context_detached(context))
+	if (context_id == KGSL_CONTEXT_INVALID) {
+		KGSL_DRV_WARN(device, "context was detached");
 		return -EINVAL;
+	}
 
-	ret = adreno_drawctxt_wait(ADRENO_DEVICE(device), context,
-		timestamp, msecs);
+	/*
+	 * Check to see if the requested timestamp is "newer" then the last
+	 * timestamp issued. If it is complain once and return error.  Only
+	 * print the message once per context so that badly behaving
+	 * applications don't spam the logs
+	 */
 
-	/* If the context got invalidated then return a specific error */
-	drawctxt = ADRENO_CONTEXT(context);
+	/* this is sort of crack.. it would be racy to check the ts and the
+	 * wait on it, and this check is pointless.. so just get rid of it:
+	if (adreno_ctx && !(adreno_ctx->flags & CTXT_FLAGS_USER_GENERATED_TS)) {
+		if (_check_pending_timestamp(device, context, timestamp))
+			return -EINVAL;
 
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID)
-		ret = -EDEADLK;
+		context->wait_on_invalid_ts = false;
+	}
+	 */
 
 	/*
-	 * Return -EPROTO if the device has faulted since the last time we
-	 * checked.  Userspace uses this as a marker for performing post
-	 * fault activities
+	 * On the first time through the loop only wait 100ms.
+	 * this gives enough time for the engine to start moving and oddly
+	 * provides better hang detection results than just going the full
+	 * KGSL_TIMEOUT_PART right off the bat. The exception to this rule
+	 * is if msecs happens to be < 100ms then just use the full timeout
 	 */
 
-	if (!ret && test_and_clear_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv))
-		ret = -EPROTO;
+	wait = 100;
+
+	do {
+		long status;
+
+		/*
+		 * if the timestamp happens while we're not
+		 * waiting, there's a chance that an interrupt
+		 * will not be generated and thus the timestamp
+		 * work needs to be queued.
+		 */
+
+		if (kgsl_check_timestamp(device, context, timestamp)) {
+			queue_work(device->work_queue, &device->ts_expired_ws);
+			ret = 0;
+			break;
+		}
+
+		/*
+		 * For proper power accounting sometimes we need to call
+		 * io_wait_interruptible_timeout and sometimes we need to call
+		 * plain old wait_interruptible_timeout. We call the regular
+		 * timeout N times out of 100, where N is a number specified by
+		 * the current power level
+		 */
+
+		io_cnt = (io_cnt + 1) % 100;
+		io = (io_cnt < pwr->pwrlevels[pwr->active_pwrlevel].io_fraction)
+			? 0 : 1;
+
+		mutex_unlock(&device->mutex);
+
+		/* Wait for a timestamp event */
+		status = kgsl_wait_event_interruptible_timeout(
+			device->wait_queue,
+			adreno_check_interrupt_timestamp(device, context,
+				timestamp), msecs_to_jiffies(wait), io);
+
+		mutex_lock(&device->mutex);
+
+		/*
+		 * If status is non zero then either the condition was satisfied
+		 * or there was an error.  In either event, this is the end of
+		 * the line for us
+		 */
+
+		if (status != 0) {
+			ret = (status > 0) ? 0 : (int) status;
+			break;
+		}
+		time_elapsed += wait;
+
+		/* If user specified timestamps are being used, wait at least
+		 * KGSL_SYNCOBJ_SERVER_TIMEOUT msecs for the user driver to
+		 * issue a IB for a timestamp before checking to see if the
+		 * current timestamp we are waiting for is valid or not
+		 */
+
+		if (ts_compare && (adreno_ctx &&
+			(adreno_ctx->flags & CTXT_FLAGS_USER_GENERATED_TS))) {
+			if (time_elapsed > KGSL_SYNCOBJ_SERVER_TIMEOUT) {
+				ret = _check_pending_timestamp(device, context,
+					timestamp);
+				if (ret)
+					break;
+
+				/* Don't do this check again */
+				ts_compare = 0;
+
+				/*
+				 * Reset the invalid timestamp flag on a valid
+				 * wait
+				 */
+				context->wait_on_invalid_ts = false;
+			}
+		}
+
+		/*
+		 * We want to wait the floor of KGSL_TIMEOUT_PART
+		 * and (msecs - time_elapsed).
+		 */
+
+		if (KGSL_TIMEOUT_PART < (msecs - time_elapsed))
+			wait = KGSL_TIMEOUT_PART;
+		else
+			wait = (msecs - time_elapsed);
+
+	} while (!msecs || time_elapsed < msecs);
 
 	return ret;
 }
@@ -2872,8 +2974,7 @@
 		if (result)
 			break;
 		result = adreno_perfcounter_get(adreno_dev, get->groupid,
-			get->countable, &get->offset, &get->offset_hi,
-			PERFCOUNTER_FLAG_NONE);
+			get->countable, &get->offset, PERFCOUNTER_FLAG_NONE);
 		kgsl_active_count_put(device);
 		break;
 	}
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,8 +19,6 @@
 #include "kgsl_iommu.h"
 #include <mach/ocmem.h>
 
-#include "a3xx_reg.h"
-
 #define DEVICE_3D_NAME "kgsl-3d"
 #define DEVICE_3D0_NAME "kgsl-3d0"
 
@@ -41,6 +39,7 @@
 #define KGSL_CMD_FLAGS_INTERNAL_ISSUE   BIT(1)
 #define KGSL_CMD_FLAGS_WFI              BIT(2)
 #define KGSL_CMD_FLAGS_PWRON_FIXUP      BIT(3)
+#define KGSL_CMD_FLAGS_GET_INT          BIT(4)
 
 /* Command identifiers */
 #define KGSL_CONTEXT_TO_MEM_IDENTIFIER	0x2EADBEEF
@@ -60,6 +59,7 @@
 #define ADRENO_DEFAULT_PWRSCALE_POLICY  NULL
 #endif
 
+void adreno_debugfs_init(struct kgsl_device *device);
 
 #define ADRENO_ISTORE_START 0x5000 /* Istore offset */
 
@@ -169,11 +169,8 @@
 	unsigned int wait_timeout;
 	unsigned int pm4_jt_idx;
 	unsigned int pm4_jt_addr;
-	unsigned int pm4_bstrp_size;
 	unsigned int pfp_jt_idx;
 	unsigned int pfp_jt_addr;
-	unsigned int pfp_bstrp_size;
-	unsigned int pfp_bstrp_ver;
 	unsigned int istore_size;
 	unsigned int pix_shader_start;
 	unsigned int instruction_size;
@@ -203,7 +200,6 @@
 	ADRENO_DEVICE_PWRON = 0,
 	ADRENO_DEVICE_PWRON_FIXUP = 1,
 	ADRENO_DEVICE_INITIALIZED = 2,
-	ADRENO_DEVICE_STARTED = 3,
 };
 
 #define PERFCOUNTER_FLAG_NONE 0x0
@@ -225,7 +221,6 @@
 	unsigned int kernelcount;
 	unsigned int usercount;
 	unsigned int offset;
-	unsigned int offset_hi;
 	int load_bit;
 	unsigned int select;
 };
@@ -313,9 +308,6 @@
 	ADRENO_REG_TC_CNTL_STATUS,
 	ADRENO_REG_TP0_CHICKEN,
 	ADRENO_REG_RBBM_RBBM_CTL,
-	ADRENO_REG_UCHE_INVALIDATE0,
-	ADRENO_REG_VBIF_XIN_HALT_CTRL0,
-	ADRENO_REG_VBIF_XIN_HALT_CTRL1,
 	ADRENO_REG_REGISTER_MAX,
 };
 
@@ -385,8 +377,8 @@
 	void (*coresight_disable) (struct kgsl_device *device);
 	void (*coresight_config_debug_reg) (struct kgsl_device *device,
 			int debug_reg, unsigned int val);
-	void (*soft_reset)(struct adreno_device *device);
 	void (*postmortem_dump)(struct adreno_device *adreno_dev);
+	void (*soft_reset)(struct adreno_device *device);
 };
 
 #define FT_DETECT_REGS_COUNT 12
@@ -403,9 +395,7 @@
 #define  KGSL_FT_SKIPFRAME                3
 #define  KGSL_FT_DISABLE                  4
 #define  KGSL_FT_TEMP_DISABLE             5
-#define  KGSL_FT_THROTTLE                 6
-#define  KGSL_FT_DEFAULT_POLICY (BIT(KGSL_FT_REPLAY) + BIT(KGSL_FT_SKIPIB) \
-				+ BIT(KGSL_FT_THROTTLE))
+#define  KGSL_FT_DEFAULT_POLICY (BIT(KGSL_FT_REPLAY) + BIT(KGSL_FT_SKIPIB))
 
 /* This internal bit is used to skip the PM dump on replayed command batches */
 #define  KGSL_FT_SKIP_PMDUMP              31
@@ -423,8 +413,15 @@
 	{ BIT(KGSL_FT_SKIPIB), "skipib" }, \
 	{ BIT(KGSL_FT_SKIPFRAME), "skipframe" }, \
 	{ BIT(KGSL_FT_DISABLE), "disable" }, \
-	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }, \
-	{ BIT(KGSL_FT_THROTTLE), "throttle"}
+	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }
+
+#define ADRENO_FT_TYPES \
+	{ BIT(KGSL_FT_OFF), "off" }, \
+	{ BIT(KGSL_FT_REPLAY), "replay" }, \
+	{ BIT(KGSL_FT_SKIPIB), "skipib" }, \
+	{ BIT(KGSL_FT_SKIPFRAME), "skipframe" }, \
+	{ BIT(KGSL_FT_DISABLE), "disable" }, \
+	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }
 
 extern struct adreno_gpudev adreno_a2xx_gpudev;
 extern struct adreno_gpudev adreno_a3xx_gpudev;
@@ -512,7 +509,7 @@
 
 int adreno_perfcounter_get(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int *offset,
-	unsigned int *offset_hi, unsigned int flags);
+	unsigned int flags);
 
 int adreno_perfcounter_put(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int flags);
@@ -717,11 +714,6 @@
 	*cmds++ = val;
 	*cmds++ = 0xFFFFFFFF;
 	*cmds++ = 0xFFFFFFFF;
-
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += __adreno_add_idle_indirect_cmds(cmds, nop_gpuaddr);
 	return cmds - start;
 }
@@ -737,13 +729,13 @@
 	unsigned int *start = cmds;
 
 	*cmds++ = cp_type3_packet(CP_WAIT_FOR_IDLE, 1);
-	*cmds++ = 0;
+	*cmds++ = 0x00000000;
 
 	if ((adreno_dev->gpurev == ADRENO_REV_A305) ||
 		(adreno_dev->gpurev == ADRENO_REV_A305C) ||
 		(adreno_dev->gpurev == ADRENO_REV_A320)) {
 		*cmds++ = cp_type3_packet(CP_WAIT_FOR_ME, 1);
-		*cmds++ = 0;
+		*cmds++ = 0x00000000;
 	}
 
 	return cmds - start;
@@ -860,19 +852,6 @@
 	smp_wmb();
 }
 
-/**
- * adreno_clear_gpu_fault() - Clear the GPU fault register
- * @adreno_dev: A pointer to an adreno_device structure
- *
- * Clear the GPU fault status for the adreno device
- */
-
-static inline void adreno_clear_gpu_fault(struct adreno_device *adreno_dev)
-{
-	atomic_set(&adreno_dev->dispatcher.fault, 0);
-	smp_wmb();
-}
-
 /*
  * adreno_vbif_start() - Program VBIF registers, called in device start
  * @device: Pointer to device whose vbif data is to be programmed
@@ -901,75 +880,4 @@
 	}
 }
 
-#ifdef CONFIG_DEBUG_FS
-void adreno_debugfs_init(struct kgsl_device *device);
-#else
-static inline void adreno_debugfs_init(struct kgsl_device *device) { }
-#endif
-
-/*
- * adreno_bootstrap_ucode() - Checks if Ucode bootstrapping is supported
- * @adreno_dev:		Pointer to the the adreno device
- */
-static inline int adreno_bootstrap_ucode(struct adreno_device *adreno_dev)
-{
-	if ((adreno_dev->pfp_bstrp_size) && (adreno_dev->pm4_bstrp_size)
-		&& (adreno_dev->pfp_fw_version >= adreno_dev->pfp_bstrp_ver))
-		return 1;
-	else
-		return 0;
-}
-
-/**
- * adreno_get_rptr() - Get the current ringbuffer read pointer
- * @rb: Pointer the ringbuffer to query
- *
- * Get the current read pointer from the GPU register.
- */
-static inline unsigned int
-adreno_get_rptr(struct adreno_ringbuffer *rb)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
-	unsigned int result;
-	adreno_readreg(adreno_dev, ADRENO_REG_CP_RB_RPTR, &result);
-	return result;
-}
-/**
- * adreno_set_protected_registers() - Protect the specified range of registers
- * from being accessed by the GPU
- * @device: pointer to the KGSL device
- * @index: Pointer to the index of the protect mode register to write to
- * @reg: Starting dword register to write
- * @mask_len: Size of the mask to protect (# of registers = 2 ** mask_len)
- *
- * Add the range of registers to the list of protected mode registers that will
- * cause an exception if the GPU accesses them.  There are 16 available
- * protected mode registers.  Index is used to specify which register to write
- * to - the intent is to call this function multiple times with the same index
- * pointer for each range and the registers will be magically programmed in
- * incremental fashion
- */
-static inline void adreno_set_protected_registers(struct kgsl_device *device,
-	unsigned int *index, unsigned int reg, int mask_len)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int val;
-
-	/* This function is only for adreno A3XX and beyond */
-	BUG_ON(adreno_is_a2xx(adreno_dev));
-
-	/* There are only 16 registers available */
-	BUG_ON(*index >= 16);
-
-	val = 0x60000000 | ((mask_len & 0x1F) << 24) | ((reg << 2) & 0x1FFFF);
-
-	/*
-	 * Write the protection range to the next available protection
-	 * register
-	 */
-
-	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_0 + *index, val);
-	*index = *index + 1;
-}
-
 #endif /*__ADRENO_H */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a2xx.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a2xx.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a2xx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a2xx.c	2014-09-21 01:02:11.000000000 +0000
@@ -655,7 +655,7 @@
 	unsigned int addr = shadow->gmemshadow.gpuaddr;
 	unsigned int offset = (addr - (addr & 0xfffff000)) / bytesperpixel;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Store TP0_CHICKEN register */
 		*cmds++ = cp_type3_packet(CP_REG_TO_MEM, 2);
 		*cmds++ = REG_TP0_CHICKEN;
@@ -864,7 +864,7 @@
 	unsigned int *cmds = shadow->gmem_restore_commands;
 	unsigned int *start = cmds;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Store TP0_CHICKEN register */
 		*cmds++ = cp_type3_packet(CP_REG_TO_MEM, 2);
 		*cmds++ = REG_TP0_CHICKEN;
@@ -1334,6 +1334,8 @@
 static int a2xx_create_gpustate_shadow(struct adreno_device *adreno_dev,
 			struct adreno_context *drawctxt)
 {
+	drawctxt->flags |= CTXT_FLAGS_STATE_SHADOW;
+
 	/* build indirect command buffers to save & restore regs/constants */
 	build_regrestore_cmds(adreno_dev, drawctxt);
 	build_regsave_cmds(adreno_dev, drawctxt);
@@ -1352,14 +1354,16 @@
 	calc_gmemsize(&drawctxt->context_gmem_shadow, adreno_dev->gmem_size);
 	tmp_ctx.gmem_base = adreno_dev->gmem_base;
 
-	result = kgsl_allocate(&(adreno_dev->dev),
-		&drawctxt->context_gmem_shadow.gmemshadow,
+	result = kgsl_allocate(&drawctxt->context_gmem_shadow.gmemshadow,
 		drawctxt->base.proc_priv->pagetable,
 		drawctxt->context_gmem_shadow.size);
 
 	if (result)
 		return result;
 
+	/* set the gmem shadow flag for the context */
+	drawctxt->flags |= CTXT_FLAGS_GMEM_SHADOW;
+
 	/* blank out gmem shadow. */
 	kgsl_sharedmem_set(drawctxt->base.device,
 			&drawctxt->context_gmem_shadow.gmemshadow, 0, 0,
@@ -1370,7 +1374,7 @@
 		&tmp_ctx.cmd);
 
 	/* build TP0_CHICKEN register restore command buffer */
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE))
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE))
 		tmp_ctx.cmd = build_chicken_restore_cmds(drawctxt);
 
 	/* build indirect command buffers to save & restore gmem */
@@ -1433,8 +1437,8 @@
 {
 	int ret;
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE
-	   && drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC) {
+	if (drawctxt->flags & CTXT_FLAGS_PREAMBLE
+	   && drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC) {
 		drawctxt->ops = (adreno_is_a225(adreno_dev))
 			?  &a225_preamble_ctx_ops : &adreno_preamble_ctx_ops;
 
@@ -1451,7 +1455,7 @@
 	 * and texture and vertex buffer storage too
 	 */
 
-	ret = kgsl_allocate(&(adreno_dev->dev), &drawctxt->gpustate,
+	ret = kgsl_allocate(&drawctxt->gpustate,
 		drawctxt->base.proc_priv->pagetable, _context_size(adreno_dev));
 
 	if (ret)
@@ -1463,14 +1467,15 @@
 	tmp_ctx.cmd = tmp_ctx.start
 	    = (unsigned int *)((char *)drawctxt->gpustate.hostptr + CMD_OFFSET);
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = a2xx_create_gpustate_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
 
+		drawctxt->flags |= CTXT_FLAGS_SHADER_SAVE;
 	}
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC)) {
 		ret = a2xx_create_gmem_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
@@ -1550,7 +1555,7 @@
 	struct kgsl_device *device = &adreno_dev->dev;
 	int ret;
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->reg_save[1],
 			context->reg_save[2] << 2, true);
@@ -1562,7 +1567,7 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_SAVE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_SAVE) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_save[1],
@@ -1572,8 +1577,6 @@
 				KGSL_CMD_FLAGS_PMODE,
 				context->shader_save, 3);
 
-			if (ret)
-				return ret;
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_fixup[1],
@@ -1589,11 +1592,12 @@
 			if (ret)
 				return ret;
 
-			set_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv);
+			context->flags |= CTXT_FLAGS_SHADER_RESTORE;
 		}
 	}
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_SAVE, &context->priv)) {
+	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
+	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->context_gmem_shadow.gmem_save[1],
 			context->context_gmem_shadow.gmem_save[2] << 2, true);
@@ -1606,13 +1610,12 @@
 
 		if (ret)
 			return ret;
-
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->chicken_restore[1],
 			context->chicken_restore[2] << 2, true);
 
 		/* Restore TP0_CHICKEN */
-		if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->chicken_restore, 3);
@@ -1622,7 +1625,7 @@
 		}
 		adreno_dev->gpudev->ctx_switches_since_last_draw = 0;
 
-		set_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags |= CTXT_FLAGS_GMEM_RESTORE;
 	} else if (adreno_is_a2xx(adreno_dev))
 		return a2xx_drawctxt_draw_workaround(adreno_dev, context);
 
@@ -1643,7 +1646,7 @@
 	 *  restore gmem.
 	 *  (note: changes shader. shader must not already be restored.)
 	 */
-	if (test_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv)) {
+	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->context_gmem_shadow.gmem_restore[1],
 			context->context_gmem_shadow.gmem_restore[2] << 2,
@@ -1655,7 +1658,7 @@
 		if (ret)
 			return ret;
 
-		if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->chicken_restore[1],
@@ -1668,10 +1671,11 @@
 			if (ret)
 				return ret;
 		}
-		clear_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+
+		context->flags &= ~CTXT_FLAGS_GMEM_RESTORE;
 	}
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->reg_restore[1],
 			context->reg_restore[2] << 2, true);
@@ -1683,7 +1687,7 @@
 			return ret;
 
 		/* restore shader instructions & partitioning. */
-		if (test_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_RESTORE) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_restore[1],
@@ -2089,8 +2093,6 @@
 	kgsl_regwrite(device, REG_SQ_INT_CNTL, 0);
 
 	a2xx_gmeminit(adreno_dev);
-
-	kgsl_regwrite(device, REG_CP_DEBUG, A2XX_CP_DEBUG_DEFAULT);
 }
 
 static void a2xx_postmortem_dump(struct adreno_device *adreno_dev)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx.c	2014-09-21 01:02:11.000000000 +0000
@@ -2297,6 +2297,8 @@
 static int a3xx_create_gpustate_shadow(struct adreno_device *adreno_dev,
 				     struct adreno_context *drawctxt)
 {
+	drawctxt->flags |= CTXT_FLAGS_STATE_SHADOW;
+
 	build_regrestore_cmds(adreno_dev, drawctxt);
 	build_constantrestore_cmds(adreno_dev, drawctxt);
 	build_hlsqcontrol_restore_cmds(adreno_dev, drawctxt);
@@ -2318,8 +2320,7 @@
 	calc_gmemsize(&drawctxt->context_gmem_shadow, adreno_dev->gmem_size);
 	tmp_ctx.gmem_base = adreno_dev->gmem_base;
 
-	result = kgsl_allocate(&(adreno_dev->dev),
-		&drawctxt->context_gmem_shadow.gmemshadow,
+	result = kgsl_allocate(&drawctxt->context_gmem_shadow.gmemshadow,
 		drawctxt->base.proc_priv->pagetable,
 		drawctxt->context_gmem_shadow.size);
 
@@ -2337,6 +2338,8 @@
 	kgsl_cache_range_op(&drawctxt->context_gmem_shadow.gmemshadow,
 		KGSL_CACHE_OP_FLUSH);
 
+	drawctxt->flags |= CTXT_FLAGS_GMEM_SHADOW;
+
 	return 0;
 }
 
@@ -2368,14 +2371,14 @@
 	 * Nothing to do here if the context is using preambles and doesn't need
 	 * GMEM save/restore
 	 */
-	if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) &&
-		(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC)) {
+	if ((drawctxt->flags & CTXT_FLAGS_PREAMBLE) &&
+		(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC)) {
 		drawctxt->ops = &adreno_preamble_ctx_ops;
 		return 0;
 	}
 	drawctxt->ops = &a3xx_legacy_ctx_ops;
 
-	ret = kgsl_allocate(&(adreno_dev->dev), &drawctxt->gpustate,
+	ret = kgsl_allocate(&drawctxt->gpustate,
 		drawctxt->base.proc_priv->pagetable, CONTEXT_SIZE);
 
 	if (ret)
@@ -2385,15 +2388,15 @@
 			CONTEXT_SIZE);
 	tmp_ctx.cmd = drawctxt->gpustate.hostptr + CMD_OFFSET;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = a3xx_create_gpustate_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
 
-		set_bit(ADRENO_CONTEXT_SHADER_SAVE, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_SHADER_SAVE;
 	}
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC))
+	if (!(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC))
 		ret = a3xx_create_gmem_shadow(adreno_dev, drawctxt);
 
 done:
@@ -2412,7 +2415,7 @@
 	if (context->state == ADRENO_CONTEXT_STATE_INVALID)
 		return 0;
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Fixup self modifying IBs for save operations */
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE, context->save_fixup, 3);
@@ -2426,17 +2429,19 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_SAVE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_SAVE) {
 			/* Save shader instructions */
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_PMODE, context->shader_save, 3);
 			if (ret)
 				return ret;
-			set_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv);
+
+			context->flags |= CTXT_FLAGS_SHADER_RESTORE;
 		}
 	}
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_SAVE, &context->priv)) {
+	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
+	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
 		/*
 		 * Save GMEM (note: changes shader. shader must
 		 * already be saved.)
@@ -2454,7 +2459,7 @@
 		if (ret)
 			return ret;
 
-		set_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags |= CTXT_FLAGS_GMEM_RESTORE;
 	}
 
 	return 0;
@@ -2476,7 +2481,7 @@
 	 * Shader must not already be restored.)
 	 */
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv)) {
+	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
 		kgsl_cffdump_syncmem(context->base.device,
 			&context->gpustate,
 			context->context_gmem_shadow.gmem_restore[1],
@@ -2489,10 +2494,10 @@
 					    gmem_restore, 3);
 		if (ret)
 			return ret;
-		clear_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags &= ~CTXT_FLAGS_GMEM_RESTORE;
 	}
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE, context->reg_restore, 3);
 		if (ret)
@@ -2511,13 +2516,12 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_RESTORE)
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->shader_restore, 3);
 			if (ret)
 				return ret;
-		}
 		/* Restore HLSQ_CONTROL_0 register */
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE,
@@ -3033,10 +3037,8 @@
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000001);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
-
-	/* Enable protected mode registers for A3XX */
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x20000000);
-
+	/* Protected mode control - turned off for A3XX/A4XX */
+	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 
@@ -3098,16 +3100,9 @@
 	case A3XX_INT_CP_HW_FAULT:
 		err = "ringbuffer hardware fault";
 		break;
-	case A3XX_INT_CP_REG_PROTECT_FAULT: {
-		unsigned int reg;
-		kgsl_regread(device, A3XX_CP_PROTECT_STATUS, &reg);
-
-		KGSL_DRV_CRIT(device,
-			"CP | Protected mode error| %s | addr=%x\n",
-			reg & (1 << 24) ? "WRITE" : "READ",
-			(reg & 0x1FFFF) >> 2);
-		goto done;
-	}
+	case A3XX_INT_CP_REG_PROTECT_FAULT:
+		err = "ringbuffer protected mode error interrupt";
+		break;
 	case A3XX_INT_CP_AHB_ERROR_HALT:
 		err = "ringbuffer AHB error interrupt";
 		break;
@@ -3142,6 +3137,7 @@
 
 	device->pwrctrl.irq_last = 1;
 	queue_work(device->work_queue, &device->ts_expired_ws);
+
 	adreno_dispatcher_schedule(device);
 }
 
@@ -3431,7 +3427,7 @@
 static struct {
 	void (*func)(struct adreno_device *, int);
 } a3xx_irq_funcs[] = {
-	A3XX_IRQ_CALLBACK(NULL), /* 0 - RBBM_GPU_IDLE */
+	A3XX_IRQ_CALLBACK(NULL),               /* 0 - RBBM_GPU_IDLE */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 1 - RBBM_AHB_ERROR */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 2 - RBBM_REG_TIMEOUT */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 3 - RBBM_ME_MS_TIMEOUT */
@@ -3683,158 +3679,141 @@
 
 static struct adreno_perfcount_register a3xx_perfcounters_cp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_CP_0_LO,
-		A3XX_RBBM_PERFCTR_CP_0_HI, 0, A3XX_CP_PERFCOUNTER_SELECT },
+		0, A3XX_CP_PERFCOUNTER_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_rbbm[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RBBM_0_LO,
-		A3XX_RBBM_PERFCTR_RBBM_0_HI, 1, A3XX_RBBM_PERFCOUNTER0_SELECT },
+		1, A3XX_RBBM_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RBBM_1_LO,
-		A3XX_RBBM_PERFCTR_RBBM_1_HI, 2, A3XX_RBBM_PERFCOUNTER1_SELECT },
+		2, A3XX_RBBM_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_pc[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_0_LO,
-		A3XX_RBBM_PERFCTR_PC_0_HI, 3, A3XX_PC_PERFCOUNTER0_SELECT },
+		3, A3XX_PC_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_1_LO,
-		A3XX_RBBM_PERFCTR_PC_1_HI, 4, A3XX_PC_PERFCOUNTER1_SELECT },
+		4, A3XX_PC_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_2_LO,
-		A3XX_RBBM_PERFCTR_PC_2_HI, 5, A3XX_PC_PERFCOUNTER2_SELECT },
+		5, A3XX_PC_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_3_LO,
-		A3XX_RBBM_PERFCTR_PC_3_HI, 6, A3XX_PC_PERFCOUNTER3_SELECT },
+		6, A3XX_PC_PERFCOUNTER3_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vfd[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VFD_0_LO,
-		A3XX_RBBM_PERFCTR_VFD_0_HI, 7, A3XX_VFD_PERFCOUNTER0_SELECT },
+		7, A3XX_VFD_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VFD_1_LO,
-		A3XX_RBBM_PERFCTR_VFD_1_HI, 8, A3XX_VFD_PERFCOUNTER1_SELECT },
+		8, A3XX_VFD_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_hlsq[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_0_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_0_HI, 9,
-		A3XX_HLSQ_PERFCOUNTER0_SELECT },
+		9, A3XX_HLSQ_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_1_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_1_HI, 10,
-		A3XX_HLSQ_PERFCOUNTER1_SELECT },
+		10, A3XX_HLSQ_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_2_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_2_HI, 11,
-		A3XX_HLSQ_PERFCOUNTER2_SELECT },
+		11, A3XX_HLSQ_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_3_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_3_HI, 12,
-		A3XX_HLSQ_PERFCOUNTER3_SELECT },
+		12, A3XX_HLSQ_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_4_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_4_HI, 13,
-		A3XX_HLSQ_PERFCOUNTER4_SELECT },
+		13, A3XX_HLSQ_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_5_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_5_HI, 14,
-		A3XX_HLSQ_PERFCOUNTER5_SELECT },
+		14, A3XX_HLSQ_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vpc[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VPC_0_LO,
-		A3XX_RBBM_PERFCTR_VPC_0_HI, 15, A3XX_VPC_PERFCOUNTER0_SELECT },
+		15, A3XX_VPC_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VPC_1_LO,
-		A3XX_RBBM_PERFCTR_VPC_1_HI, 16, A3XX_VPC_PERFCOUNTER1_SELECT },
+		16, A3XX_VPC_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_tse[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TSE_0_LO,
-		A3XX_RBBM_PERFCTR_TSE_0_HI, 17, A3XX_GRAS_PERFCOUNTER0_SELECT },
+		17, A3XX_GRAS_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TSE_1_LO,
-		A3XX_RBBM_PERFCTR_TSE_1_HI, 18, A3XX_GRAS_PERFCOUNTER1_SELECT },
+		18, A3XX_GRAS_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_ras[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RAS_0_LO,
-		A3XX_RBBM_PERFCTR_RAS_0_HI, 19, A3XX_GRAS_PERFCOUNTER2_SELECT },
+		19, A3XX_GRAS_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RAS_1_LO,
-		A3XX_RBBM_PERFCTR_RAS_1_HI, 20, A3XX_GRAS_PERFCOUNTER3_SELECT },
+		20, A3XX_GRAS_PERFCOUNTER3_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_uche[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_0_LO,
-		A3XX_RBBM_PERFCTR_UCHE_0_HI, 21,
-		A3XX_UCHE_PERFCOUNTER0_SELECT },
+		21, A3XX_UCHE_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_1_LO,
-		A3XX_RBBM_PERFCTR_UCHE_1_HI, 22,
-		A3XX_UCHE_PERFCOUNTER1_SELECT },
+		22, A3XX_UCHE_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_2_LO,
-		A3XX_RBBM_PERFCTR_UCHE_2_HI, 23,
-		A3XX_UCHE_PERFCOUNTER2_SELECT },
+		23, A3XX_UCHE_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_3_LO,
-		A3XX_RBBM_PERFCTR_UCHE_3_HI, 24,
-		A3XX_UCHE_PERFCOUNTER3_SELECT },
+		24, A3XX_UCHE_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_4_LO,
-		A3XX_RBBM_PERFCTR_UCHE_4_HI, 25,
-		A3XX_UCHE_PERFCOUNTER4_SELECT },
+		25, A3XX_UCHE_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_5_LO,
-		A3XX_RBBM_PERFCTR_UCHE_5_HI, 26,
-		A3XX_UCHE_PERFCOUNTER5_SELECT },
+		26, A3XX_UCHE_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_tp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_0_LO,
-		A3XX_RBBM_PERFCTR_TP_0_HI, 27, A3XX_TP_PERFCOUNTER0_SELECT },
+		27, A3XX_TP_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_1_LO,
-		A3XX_RBBM_PERFCTR_TP_1_HI, 28, A3XX_TP_PERFCOUNTER1_SELECT },
+		28, A3XX_TP_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_2_LO,
-		A3XX_RBBM_PERFCTR_TP_2_HI, 29, A3XX_TP_PERFCOUNTER2_SELECT },
+		29, A3XX_TP_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_3_LO,
-		A3XX_RBBM_PERFCTR_TP_3_HI, 30, A3XX_TP_PERFCOUNTER3_SELECT },
+		30, A3XX_TP_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_4_LO,
-		A3XX_RBBM_PERFCTR_TP_4_HI, 31, A3XX_TP_PERFCOUNTER4_SELECT },
+		31, A3XX_TP_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_5_LO,
-		A3XX_RBBM_PERFCTR_TP_5_HI, 32, A3XX_TP_PERFCOUNTER5_SELECT },
+		32, A3XX_TP_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_sp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_0_LO,
-		A3XX_RBBM_PERFCTR_SP_0_HI, 33, A3XX_SP_PERFCOUNTER0_SELECT },
+		33, A3XX_SP_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_1_LO,
-		A3XX_RBBM_PERFCTR_SP_1_HI, 34, A3XX_SP_PERFCOUNTER1_SELECT },
+		34, A3XX_SP_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_2_LO,
-		A3XX_RBBM_PERFCTR_SP_2_HI, 35, A3XX_SP_PERFCOUNTER2_SELECT },
+		35, A3XX_SP_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_3_LO,
-		A3XX_RBBM_PERFCTR_SP_3_HI, 36, A3XX_SP_PERFCOUNTER3_SELECT },
+		36, A3XX_SP_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_4_LO,
-		A3XX_RBBM_PERFCTR_SP_4_HI, 37, A3XX_SP_PERFCOUNTER4_SELECT },
+		37, A3XX_SP_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_5_LO,
-		A3XX_RBBM_PERFCTR_SP_5_HI, 38, A3XX_SP_PERFCOUNTER5_SELECT },
+		38, A3XX_SP_PERFCOUNTER5_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_6_LO,
-		A3XX_RBBM_PERFCTR_SP_6_HI, 39, A3XX_SP_PERFCOUNTER6_SELECT },
+		39, A3XX_SP_PERFCOUNTER6_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_7_LO,
-		A3XX_RBBM_PERFCTR_SP_7_HI, 40, A3XX_SP_PERFCOUNTER7_SELECT },
+		40, A3XX_SP_PERFCOUNTER7_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_rb[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RB_0_LO,
-		A3XX_RBBM_PERFCTR_RB_0_HI, 41, A3XX_RB_PERFCOUNTER0_SELECT },
+		41, A3XX_RB_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RB_1_LO,
-		A3XX_RBBM_PERFCTR_RB_1_HI, 42, A3XX_RB_PERFCOUNTER1_SELECT },
+		42, A3XX_RB_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_pwr[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PWR_0_LO,
-		A3XX_RBBM_PERFCTR_PWR_0_HI, -1, 0 },
+		-1, 0 },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PWR_1_LO,
-		A3XX_RBBM_PERFCTR_PWR_1_HI, -1, 0 },
+		-1, 0 },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vbif[] = {
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT0_LO,
-		A3XX_VBIF_PERF_CNT0_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT1_LO,
-		A3XX_VBIF_PERF_CNT1_HI, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT0_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT1_LO, -1, 0 },
 };
 static struct adreno_perfcount_register a3xx_perfcounters_vbif_pwr[] = {
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT0_LO,
-		A3XX_VBIF_PERF_PWR_CNT0_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT1_LO,
-		A3XX_VBIF_PERF_PWR_CNT1_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT2_LO,
-		A3XX_VBIF_PERF_PWR_CNT2_HI, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT0_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT1_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT2_LO, -1, 0 },
 };
 
 static struct adreno_perfcount_group a3xx_perfcounter_groups[] = {
@@ -3900,43 +3879,35 @@
 	if (adreno_dev->fast_hang_detect) {
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP_ALU_ACTIVE_CYCLES,
-			&ft_detect_regs[6], &ft_detect_regs[7],
+			SP_ALU_ACTIVE_CYCLES, &ft_detect_regs[6],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[7] = ft_detect_regs[6] + 1;
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP0_ICL1_MISSES,
-			&ft_detect_regs[8], &ft_detect_regs[9],
+			SP0_ICL1_MISSES, &ft_detect_regs[8],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[9] = ft_detect_regs[8] + 1;
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP_FS_CFLOW_INSTRUCTIONS,
-			&ft_detect_regs[10], &ft_detect_regs[11],
+			SP_FS_CFLOW_INSTRUCTIONS, &ft_detect_regs[10],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[11] = ft_detect_regs[10] + 1;
 	}
 
 	ret = adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
-		SP_FS_FULL_ALU_INSTRUCTIONS, NULL, NULL,
-		PERFCOUNTER_FLAG_KERNEL);
+		SP_FS_FULL_ALU_INSTRUCTIONS, NULL, PERFCOUNTER_FLAG_KERNEL);
 	if (ret)
 		goto err;
 
 	/* Reserve and start countable 1 in the PWR perfcounter group */
 	ret = adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_PWR, 1,
-			NULL, NULL, PERFCOUNTER_FLAG_KERNEL);
-	if (ret)
-		goto err;
-
-	/* VBIF waiting for RAM */
-	ret = adreno_perfcounter_get(adreno_dev,
-				KGSL_PERFCOUNTER_GROUP_VBIF_PWR, 0,
-				NULL, NULL, PERFCOUNTER_FLAG_KERNEL);
+			NULL, PERFCOUNTER_FLAG_KERNEL);
 	if (ret)
 		goto err;
 
@@ -3955,36 +3926,29 @@
  */
 static void a3xx_protect_init(struct kgsl_device *device)
 {
-	int index = 0;
-
 	/* enable access protection to privileged registers */
 	kgsl_regwrite(device, A3XX_CP_PROTECT_CTRL, 0x00000007);
 
 	/* RBBM registers */
-	adreno_set_protected_registers(device, &index, 0x18, 0);
-	adreno_set_protected_registers(device, &index, 0x20, 2);
-	adreno_set_protected_registers(device, &index, 0x33, 0);
-	adreno_set_protected_registers(device, &index, 0x42, 0);
-	adreno_set_protected_registers(device, &index, 0x50, 4);
-	adreno_set_protected_registers(device, &index, 0x63, 0);
-	adreno_set_protected_registers(device, &index, 0x100, 4);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_0, 0x63000040);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_1, 0x62000080);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_2, 0x600000CC);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_3, 0x60000108);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_4, 0x64000140);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_5, 0x66000400);
 
 	/* CP registers */
-	adreno_set_protected_registers(device, &index, 0x1C0, 5);
-	adreno_set_protected_registers(device, &index, 0x1EC, 1);
-	adreno_set_protected_registers(device, &index, 0x1F6, 1);
-	adreno_set_protected_registers(device, &index, 0x1F8, 2);
-	adreno_set_protected_registers(device, &index, 0x45E, 2);
-	adreno_set_protected_registers(device, &index, 0x460, 4);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_6, 0x65000700);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_7, 0x610007D8);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_8, 0x620007E0);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_9, 0x61001178);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_A, 0x64001180);
 
 	/* RB registers */
-	adreno_set_protected_registers(device, &index, 0xCC0, 0);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_B, 0x60003300);
 
 	/* VBIF registers */
-	adreno_set_protected_registers(device, &index, 0x3000, 6);
-
-	/* SMMU registers */
-	adreno_set_protected_registers(device, &index, 0x4000, 14);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_C, 0x6B00C000);
 }
 
 static void a3xx_start(struct adreno_device *adreno_dev)
@@ -4047,9 +4011,6 @@
 	/* Turn on the GPU busy counter and let it run free */
 
 	adreno_dev->gpu_cycles = 0;
-
-	/* the CP_DEBUG register offset and value are same as A2XX */
-	kgsl_regwrite(device, REG_CP_DEBUG, A2XX_CP_DEBUG_DEFAULT);
 }
 
 /**
@@ -4405,12 +4366,6 @@
 	ADRENO_REG_DEFINE(ADRENO_REG_TC_CNTL_STATUS, REG_TC_CNTL_STATUS),
 	ADRENO_REG_DEFINE(ADRENO_REG_TP0_CHICKEN, REG_TP0_CHICKEN),
 	ADRENO_REG_DEFINE(ADRENO_REG_RBBM_RBBM_CTL, A3XX_RBBM_RBBM_CTL),
-	ADRENO_REG_DEFINE(ADRENO_REG_UCHE_INVALIDATE0,
-			A3XX_UCHE_CACHE_INVALIDATE0_REG),
-	ADRENO_REG_DEFINE(ADRENO_REG_VBIF_XIN_HALT_CTRL0,
-				A3XX_VBIF_XIN_HALT_CTRL0),
-	ADRENO_REG_DEFINE(ADRENO_REG_VBIF_XIN_HALT_CTRL1,
-				A3XX_VBIF_XIN_HALT_CTRL1),
 };
 
 const struct adreno_reg_offsets a3xx_reg_offsets = {
@@ -4437,6 +4392,6 @@
 	.coresight_enable = a3xx_coresight_enable,
 	.coresight_disable = a3xx_coresight_disable,
 	.coresight_config_debug_reg = a3xx_coresight_config_debug_reg,
-	.soft_reset = a3xx_soft_reset,
 	.postmortem_dump = a3xx_postmortem_dump,
+	.soft_reset = a3xx_soft_reset,
 };
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_snapshot.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_snapshot.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_snapshot.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_snapshot.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -277,6 +277,7 @@
 
 	struct kgsl_snapshot_debugbus *header = snapshot;
 	struct debugbus_block *block = priv;
+	unsigned int val;
 	int i;
 	unsigned int *data = snapshot + sizeof(*header);
 	unsigned int dwords;
@@ -299,6 +300,8 @@
 		return 0;
 	}
 
+	val = (block->block_id << 8) | (1 << 16);
+
 	header->id = block->block_id;
 	header->count = dwords;
 
@@ -492,22 +495,6 @@
 	/* Reading these will hang the GPU if it isn't already hung */
 
 	if (hang) {
-		unsigned int reg;
-
-		/*
-		 * Reading the microcode while the CP will is running will
-		 * basically basically move the CP instruction pointer to
-		 * whatever address we read. Big badaboom ensues. Stop the CP
-		 * (if it isn't already stopped) to ensure that we are safe.
-		 * We do this here and not earlier to avoid corrupting the RBBM
-		 * status and CP registers - by the time we get here we don't
-		 * care about the contents of the CP anymore.
-		 */
-
-		adreno_readreg(adreno_dev, ADRENO_REG_CP_ME_CNTL, &reg);
-		reg |= (1 << 27) | (1 << 28);
-		adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, reg);
-
 		snapshot = kgsl_snapshot_add_section(device,
 			KGSL_SNAPSHOT_SECTION_DEBUG, snapshot, remain,
 			a3xx_snapshot_cp_pfp_ram, NULL);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -48,7 +48,7 @@
 		"d_name=%s status=%s",
 		__get_str(device_name),
 		__entry->status ? __print_flags(__entry->status, "|",
-			{ 1 << A3XX_INT_RBBM_GPU_IDLE, "RBBM_GPU_IDLE" },
+			{ 1 << A3XX_INT_RBBM_AHB_ERROR, "RBBM_GPU_IDLE" },
 			{ 1 << A3XX_INT_RBBM_AHB_ERROR, "RBBM_AHB_ERR" },
 			{ 1 << A3XX_INT_RBBM_REG_TIMEOUT, "RBBM_REG_TIMEOUT" },
 			{ 1 << A3XX_INT_RBBM_ME_MS_TIMEOUT,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_debugfs.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_debugfs.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_debugfs.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,6 +23,8 @@
 
 #include "a2xx_reg.h"
 
+unsigned int kgsl_cff_dump_enable;
+
 DEFINE_SIMPLE_ATTRIBUTE(kgsl_cff_dump_enable_fops, kgsl_cff_dump_enable_get,
 			kgsl_cff_dump_enable_set, "%llu\n");
 
@@ -54,6 +56,41 @@
 		&adreno_dev->wait_timeout);
 	debugfs_create_u32("ib_check", 0644, device->d_debugfs,
 			   &adreno_dev->ib_check_level);
+	/* By Default enable fast hang detection */
+	adreno_dev->fast_hang_detect = 1;
+	debugfs_create_u32("fast_hang_detect", 0644, device->d_debugfs,
+			   &adreno_dev->fast_hang_detect);
+	/*
+	 * FT policy can be set to any of the options below.
+	 * KGSL_FT_OFF -> BIT(0) Set to turn off FT
+	 * KGSL_FT_REPLAY  -> BIT(1) Set to enable replay
+	 * KGSL_FT_SKIPIB  -> BIT(2) Set to skip IB
+	 * KGSL_FT_SKIPFRAME -> BIT(3) Set to skip frame
+	 * KGSL_FT_DISABLE -> BIT(4) Set to disable FT for faulting context
+	 * by default set FT policy to KGSL_FT_DEFAULT_POLICY
+	 */
+	adreno_dev->ft_policy = KGSL_FT_DEFAULT_POLICY;
+	debugfs_create_u32("ft_policy", 0644, device->d_debugfs,
+			   &adreno_dev->ft_policy);
+	/* By default enable long IB detection */
+	adreno_dev->long_ib_detect = 1;
+	debugfs_create_u32("long_ib_detect", 0644, device->d_debugfs,
+			   &adreno_dev->long_ib_detect);
+
+	/*
+	 * FT pagefault policy can be set to any of the options below.
+	 * KGSL_FT_PAGEFAULT_INT_ENABLE -> BIT(0) set to enable pagefault INT
+	 * KGSL_FT_PAGEFAULT_GPUHALT_ENABLE  -> BIT(1) Set to enable GPU HALT on
+	 * pagefaults. This stalls the GPU on a pagefault on IOMMU v1 HW.
+	 * KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE  -> BIT(2) Set to log only one
+	 * pagefault per page.
+	 * KGSL_FT_PAGEFAULT_LOG_ONE_PER_INT -> BIT(3) Set to log only one
+	 * pagefault per INT.
+	 */
+	 adreno_dev->ft_pf_policy = KGSL_FT_PAGEFAULT_DEFAULT_POLICY;
+	 debugfs_create_u32("ft_pagefault_policy", 0644, device->d_debugfs,
+			&adreno_dev->ft_pf_policy);
+
 	debugfs_create_file("active_cnt", 0444, device->d_debugfs, device,
 			    &_active_count_fops);
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_dispatch.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_dispatch.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_dispatch.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_dispatch.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -33,15 +33,6 @@
 /* Number of command batches sent at a time from a single context */
 static unsigned int _context_cmdbatch_burst = 5;
 
-/*
- * GFT throttle parameters. If GFT recovered more than
- * X times in Y ms invalidate the context and do not attempt recovery.
- * X -> _fault_throttle_burst
- * Y -> _fault_throttle_time
- */
-static unsigned int _fault_throttle_time = 3000;
-static unsigned int _fault_throttle_burst = 3;
-
 /* Number of command batches inflight in the ringbuffer at any time */
 static unsigned int _dispatcher_inflight = 15;
 
@@ -195,9 +186,10 @@
 		return -EINVAL;
 	}
 
-	prev = drawctxt->cmdqueue_head == 0 ?
-		(ADRENO_CONTEXT_CMDQUEUE_SIZE - 1) :
-		(drawctxt->cmdqueue_head - 1);
+	prev = drawctxt->cmdqueue_head - 1;
+
+	if (prev < 0)
+		prev = ADRENO_CONTEXT_CMDQUEUE_SIZE - 1;
 
 	/*
 	 * The maximum queue size always needs to be one less then the size of
@@ -233,6 +225,7 @@
 
 	spin_lock(&dispatcher->plist_lock);
 
+
 	if (plist_node_empty(&drawctxt->pending)) {
 		/* Get a reference to the context while it sits on the list */
 		if (_kgsl_context_get(&drawctxt->base)) {
@@ -357,6 +350,9 @@
 
 		cmdbatch = adreno_dispatcher_get_cmdbatch(drawctxt);
 
+		if (cmdbatch == NULL)
+			break;
+
 		/*
 		 * adreno_context_get_cmdbatch returns -EAGAIN if the current
 		 * cmdbatch has pending sync points so no more to do here.
@@ -364,9 +360,8 @@
 		 * reqeueued
 		 */
 
-		if (IS_ERR_OR_NULL(cmdbatch)) {
-			if (IS_ERR(cmdbatch) && PTR_ERR(cmdbatch) == -EAGAIN)
-				requeued = 1;
+		if (IS_ERR(cmdbatch) && PTR_ERR(cmdbatch) == -EAGAIN) {
+			requeued = 1;
 			break;
 		}
 
@@ -407,7 +402,7 @@
 	 */
 
 	if (count)
-		wake_up_all(&drawctxt->wq);
+		wake_up_interruptible_all(&drawctxt->wq);
 
 	/*
 	 * Return positive if the context submitted commands or if we figured
@@ -568,7 +563,7 @@
 		return 0;
 	}
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_USER_GENERATED_TS) {
+	if (drawctxt->flags & CTXT_FLAGS_USER_GENERATED_TS) {
 		/*
 		 * User specified timestamps need to be greater than the last
 		 * issued timestamp in the context
@@ -585,7 +580,7 @@
 }
 
 /**
- * adreno_dispactcher_queue_cmd() - Queue a new command in the context
+ * adreno_dispatcher_queue_cmd() - Queue a new command in the context
  * @adreno_dev: Pointer to the adreno device struct
  * @drawctxt: Pointer to the adreno draw context
  * @cmdbatch: Pointer to the command batch being submitted
@@ -612,8 +607,10 @@
 	 * to run (if it exists) regardless of the context state.
 	 */
 
-	if (test_and_clear_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv))
+	if (drawctxt->flags & CTXT_FLAGS_FORCE_PREAMBLE) {
 		set_bit(CMDBATCH_FLAG_FORCE_PREAMBLE, &cmdbatch->priv);
+		drawctxt->flags &= ~CTXT_FLAGS_FORCE_PREAMBLE;
+	}
 
 	/*
 	 * If we are waiting for the end of frame and it hasn't appeared yet,
@@ -621,7 +618,7 @@
 	 * through the pipeline but it won't actually send any commands
 	 */
 
-	if (test_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv)) {
+	if (drawctxt->flags & CTXT_FLAGS_SKIP_EOF) {
 		set_bit(CMDBATCH_FLAG_SKIP, &cmdbatch->priv);
 
 		/*
@@ -630,13 +627,14 @@
 		 */
 
 		if (cmdbatch->flags & KGSL_CONTEXT_END_OF_FRAME) {
-			clear_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv);
+			drawctxt->flags &= ~CTXT_FLAGS_SKIP_EOF;
 
 			/*
 			 * Force the preamble on the next command to ensure that
 			 * the state is correct
 			 */
-			set_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv);
+
+			drawctxt->flags |= CTXT_FLAGS_FORCE_PREAMBLE;
 		}
 	}
 
@@ -682,10 +680,10 @@
 
 	/*
 	 * Set the fault tolerance policy for the command batch - assuming the
-	 * context hasn't disabled FT use the current device policy
+	 * context hsn't disabled FT use the current device policy
 	 */
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+	if (drawctxt->flags & CTXT_FLAGS_NO_FAULT_TOLERANCE)
 		set_bit(KGSL_FT_DISABLE, &cmdbatch->fault_policy);
 	else
 		cmdbatch->fault_policy = adreno_dev->ft_policy;
@@ -719,44 +717,6 @@
 	return 0;
 }
 
-static int _mark_context(int id, void *ptr, void *data)
-{
-	unsigned int guilty = *((unsigned int *) data);
-	struct kgsl_context *context = ptr;
-
-	/*
-	 * If the context is guilty mark it as such.  Otherwise mark it as
-	 * innocent if it had not already been marked as guilty.  If id is
-	 * passed as 0 then mark EVERYBODY guilty (recovery failed)
-	 */
-
-	if (guilty == 0 || guilty == context->id)
-		context->reset_status =
-			KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT;
-	else if (context->reset_status !=
-		KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT)
-		context->reset_status =
-			KGSL_CTX_STAT_INNOCENT_CONTEXT_RESET_EXT;
-
-	return 0;
-}
-
-/**
- * mark_guilty_context() - Mark the given context as guilty (failed recovery)
- * @device: Pointer to a KGSL device structure
- * @id: Context ID of the guilty context (or 0 to mark all as guilty)
- *
- * Mark the given (or all) context(s) as guilty (failed recovery)
- */
-static void mark_guilty_context(struct kgsl_device *device, unsigned int id)
-{
-	/* Mark the status for all the contexts in the device */
-
-	read_lock(&device->context_lock);
-	idr_for_each(&device->context_idr, _mark_context, &id);
-	read_unlock(&device->context_lock);
-}
-
 /*
  * If an IB inside of the command batch has a gpuaddr that matches the base
  * passed in then zero the size which effectively skips it when it is submitted
@@ -815,7 +775,7 @@
 	 */
 
 	if (skip && drawctxt)
-		set_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_SKIP_EOF;
 
 	/*
 	 * If we did see the EOF flag then force the preamble on for the
@@ -823,7 +783,7 @@
 	 */
 
 	if (!skip && drawctxt)
-		set_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_FORCE_PREAMBLE;
 }
 
 static void remove_invalidated_cmdbatches(struct kgsl_device *device,
@@ -965,8 +925,6 @@
 		/* Skip the PM dump for a timeout because it confuses people */
 		set_bit(KGSL_FT_SKIP_PMDUMP, &cmdbatch->fault_policy);
 	}
-	/* Set pagefault if it occurred */
-	kgsl_mmu_set_pagefault(&device->mmu);
 
 	adreno_readreg(adreno_dev, ADRENO_REG_CP_IB1_BASE, &base);
 
@@ -992,9 +950,6 @@
 	if (replay == NULL) {
 		unsigned int ptr = dispatcher->head;
 
-		/* Recovery failed - mark everybody guilty */
-		mark_guilty_context(device, 0);
-
 		while (ptr != dispatcher->tail) {
 			struct kgsl_context *context =
 				dispatcher->cmdqueue[ptr]->context;
@@ -1030,35 +985,6 @@
 	cmdbatch = replay[0];
 
 	/*
-	 * If GFT recovered more than X times in Y ms invalidate the context
-	 * and do not attempt recovery.
-	 * Example: X==3 and Y==3000 ms, GPU hung at 500ms, 1700ms, 25000ms and
-	 * 3000ms for the same context, we will not try FT and invalidate the
-	 * context @3000ms because context triggered GFT more than 3 times in
-	 * last 3 seconds. If a context caused recoverable GPU hangs
-	 * where 1st and 4th gpu hang are more than 3 seconds apart we
-	 * won't disable GFT and invalidate the context.
-	 */
-	if (test_bit(KGSL_FT_THROTTLE, &cmdbatch->fault_policy)) {
-		if (time_after(jiffies, (cmdbatch->context->fault_time
-				+ msecs_to_jiffies(_fault_throttle_time)))) {
-			cmdbatch->context->fault_time = jiffies;
-			cmdbatch->context->fault_count = 1;
-		} else {
-			cmdbatch->context->fault_count++;
-			if (cmdbatch->context->fault_count >
-					_fault_throttle_burst) {
-				set_bit(KGSL_FT_DISABLE,
-						&cmdbatch->fault_policy);
-				pr_fault(device, cmdbatch,
-					 "gpu fault threshold exceeded %d faults in %d msecs\n",
-					 _fault_throttle_burst,
-					 _fault_throttle_time);
-			}
-		}
-	}
-
-	/*
 	 * If FT is disabled for this cmdbatch invalidate immediately
 	 */
 
@@ -1067,7 +993,6 @@
 		pr_fault(device, cmdbatch, "gpu skipped ctx %d ts %d\n",
 			cmdbatch->context->id, cmdbatch->timestamp);
 
-		mark_guilty_context(device, cmdbatch->context->id);
 		adreno_drawctxt_invalidate(device, cmdbatch->context);
 	}
 
@@ -1163,9 +1088,6 @@
 	pr_fault(device, cmdbatch, "gpu failed ctx %d ts %d\n",
 		cmdbatch->context->id, cmdbatch->timestamp);
 
-	/* Mark the context as failed */
-	mark_guilty_context(device, cmdbatch->context->id);
-
 	/* Invalidate the context */
 	adreno_drawctxt_invalidate(device, cmdbatch->context);
 
@@ -1226,9 +1148,6 @@
 				"gpu reset failed ctx %d ts %d\n",
 				replay[i]->context->id, replay[i]->timestamp);
 
-			/* Mark this context as guilty (failed recovery) */
-			mark_guilty_context(device, replay[i]->context->id);
-
 			adreno_drawctxt_invalidate(device, replay[i]->context);
 			remove_invalidated_cmdbatches(device, &replay[i],
 				count - i);
@@ -1285,7 +1204,6 @@
 		container_of(dispatcher, struct adreno_device, dispatcher);
 	struct kgsl_device *device = &adreno_dev->dev;
 	int count = 0;
-	int last_context = KGSL_CONTEXT_INVALID;
 	int fault_handled = 0;
 
 	mutex_lock(&dispatcher->mutex);
@@ -1317,22 +1235,12 @@
 			 * successful completion to the world
 			 */
 
-			if (cmdbatch->fault_recovery != 0) {
-				struct adreno_context *drawctxt =
-					ADRENO_CONTEXT(cmdbatch->context);
-
-				/* Mark the context as faulted and recovered */
-				set_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv);
-
+			if (cmdbatch->fault_recovery != 0)
 				_print_recovery(device, cmdbatch);
-			}
 
 			trace_adreno_cmdbatch_retired(cmdbatch,
 				dispatcher->inflight - 1);
 
-			/* Remember the last context that got retired */
-			last_context = cmdbatch->context->id;
-
 			/* Reduce the number of inflight command batches */
 			dispatcher->inflight--;
 
@@ -1381,7 +1289,7 @@
 		 */
 
 		if (!adreno_dev->long_ib_detect ||
-			drawctxt->base.flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+			drawctxt->flags & CTXT_FLAGS_NO_FAULT_TOLERANCE)
 			break;
 
 		/*
@@ -1437,18 +1345,6 @@
 		/* Update the timeout timer for the next command batch */
 		mod_timer(&dispatcher->timer, cmdbatch->expires);
 
-		/*
-		 * if the context for the next pending cmdbatch is different
-		 * than the last one we retired, then trace it as a GPU switch
-		 */
-
-		if (cmdbatch->context->id != last_context) {
-			u64 now = ktime_to_ns(ktime_get());
-			kgsl_trace_gpu_sched_switch(device->name, now,
-				cmdbatch->context->id, cmdbatch->priority,
-				cmdbatch->timestamp);
-		}
-
 		/* There are still things in flight - update the idle counts */
 		mutex_lock(&device->mutex);
 		kgsl_pwrscale_idle(device);
@@ -1567,6 +1463,7 @@
  * adreno_dispatcher_start() - activate the dispatcher
  * @adreno_dev: pointer to the adreno device structure
  *
+ * Set the disaptcher active and start the loop once to get things going
  */
 void adreno_dispatcher_start(struct kgsl_device *device)
 {
@@ -1680,10 +1577,6 @@
 static DISPATCHER_UINT_ATTR(context_queue_wait, 0644, 0, _context_queue_wait);
 static DISPATCHER_UINT_ATTR(fault_detect_interval, 0644, 0,
 	_fault_timer_interval);
-static DISPATCHER_UINT_ATTR(fault_throttle_time, 0644, 0,
-	_fault_throttle_time);
-static DISPATCHER_UINT_ATTR(fault_throttle_burst, 0644, 0,
-	_fault_throttle_burst);
 
 static struct attribute *dispatcher_attrs[] = {
 	&dispatcher_attr_inflight.attr,
@@ -1692,8 +1585,6 @@
 	&dispatcher_attr_cmdbatch_timeout.attr,
 	&dispatcher_attr_context_queue_wait.attr,
 	&dispatcher_attr_fault_detect_interval.attr,
-	&dispatcher_attr_fault_throttle_time.attr,
-	&dispatcher_attr_fault_throttle_burst.attr,
 	NULL,
 };
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -138,7 +138,7 @@
 		u32 timestamp, u32 type)
 {
 	struct adreno_context *drawctxt = priv;
-	wake_up_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->waiting);
 }
 
 #define adreno_wait_event_interruptible_timeout(wq, condition, timeout, io)   \
@@ -266,18 +266,20 @@
 {
 	struct adreno_context *drawctxt = priv;
 
-	wake_up_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->waiting);
 	kgsl_context_put(&drawctxt->base);
 }
 
 static int _check_global_timestamp(struct kgsl_device *device,
-		struct adreno_context *drawctxt, unsigned int timestamp)
+		unsigned int timestamp)
 {
-	/* Stop waiting if the context is invalidated */
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID)
-		return 1;
+	int ret;
 
-	return kgsl_check_timestamp(device, NULL, timestamp);
+	mutex_lock(&device->mutex);
+	ret = kgsl_check_timestamp(device, NULL, timestamp);
+	mutex_unlock(&device->mutex);
+
+	return ret;
 }
 
 int adreno_drawctxt_wait_global(struct adreno_device *adreno_dev,
@@ -286,7 +288,7 @@
 {
 	struct kgsl_device *device = &adreno_dev->dev;
 	struct adreno_context *drawctxt = ADRENO_CONTEXT(context);
-	int ret = 0;
+	int ret;
 
 	/* Needs to hold the device mutex */
 	BUG_ON(!mutex_is_locked(&device->mutex));
@@ -296,15 +298,6 @@
 		goto done;
 	}
 
-	/*
-	 * If the context is invalid then return immediately - we may end up
-	 * waiting for a timestamp that will never come
-	 */
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID) {
-		kgsl_context_put(context);
-		goto done;
-	}
-
 	trace_adreno_drawctxt_wait_start(KGSL_MEMSTORE_GLOBAL, timestamp);
 
 	ret = kgsl_add_event(device, KGSL_MEMSTORE_GLOBAL, timestamp,
@@ -318,7 +311,7 @@
 
 	if (timeout) {
 		ret = (int) wait_event_timeout(drawctxt->waiting,
-			_check_global_timestamp(device, drawctxt, timestamp),
+			_check_global_timestamp(device, timestamp),
 			msecs_to_jiffies(timeout));
 
 		if (ret == 0)
@@ -327,7 +320,7 @@
 			ret = 0;
 	} else {
 		wait_event(drawctxt->waiting,
-			_check_global_timestamp(device, drawctxt, timestamp));
+			_check_global_timestamp(device, timestamp));
 	}
 
 	mutex_lock(&device->mutex);
@@ -391,8 +384,8 @@
 	mutex_unlock(&drawctxt->mutex);
 
 	/* Give the bad news to everybody waiting around */
-	wake_up_all(&drawctxt->waiting);
-	wake_up_all(&drawctxt->wq);
+	wake_up_interruptible_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->wq);
 }
 
 /**
@@ -412,7 +405,6 @@
 	int ret;
 
 	drawctxt = kzalloc(sizeof(struct adreno_context), GFP_KERNEL);
-
 	if (drawctxt == NULL)
 		return ERR_PTR(-ENOMEM);
 
@@ -425,16 +417,25 @@
 	drawctxt->bin_base_offset = 0;
 	drawctxt->timestamp = 0;
 
-	drawctxt->base.flags = *flags & (KGSL_CONTEXT_PREAMBLE |
+	*flags &= (KGSL_CONTEXT_PREAMBLE |
 		KGSL_CONTEXT_NO_GMEM_ALLOC |
 		KGSL_CONTEXT_PER_CONTEXT_TS |
 		KGSL_CONTEXT_USER_GENERATED_TS |
 		KGSL_CONTEXT_NO_FAULT_TOLERANCE |
-		KGSL_CONTEXT_TYPE_MASK |
-		KGSL_CONTEXT_PWR_CONSTRAINT);
+		KGSL_CONTEXT_TYPE_MASK);
 
 	/* Always enable per-context timestamps */
-	drawctxt->base.flags |= KGSL_CONTEXT_PER_CONTEXT_TS;
+	*flags |= KGSL_CONTEXT_PER_CONTEXT_TS;
+	drawctxt->flags |= CTXT_FLAGS_PER_CONTEXT_TS;
+
+	if (*flags & KGSL_CONTEXT_PREAMBLE)
+		drawctxt->flags |= CTXT_FLAGS_PREAMBLE;
+
+	if (*flags & KGSL_CONTEXT_NO_GMEM_ALLOC)
+		drawctxt->flags |= CTXT_FLAGS_NOGMEMALLOC;
+
+	if (*flags & KGSL_CONTEXT_USER_GENERATED_TS)
+		drawctxt->flags |= CTXT_FLAGS_USER_GENERATED_TS;
 
 	mutex_init(&drawctxt->mutex);
 	init_waitqueue_head(&drawctxt->wq);
@@ -448,12 +449,18 @@
 
 	plist_node_init(&drawctxt->pending, ADRENO_CONTEXT_DEFAULT_PRIORITY);
 
+	if (*flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+		drawctxt->flags |= CTXT_FLAGS_NO_FAULT_TOLERANCE;
+
+	drawctxt->type =
+		(*flags & KGSL_CONTEXT_TYPE_MASK) >> KGSL_CONTEXT_TYPE_SHIFT;
+
 	if (adreno_dev->gpudev->ctxt_create) {
 		ret = adreno_dev->gpudev->ctxt_create(adreno_dev, drawctxt);
 		if (ret)
 			goto err;
-	} else if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) == 0 ||
-		  (drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC) == 0) {
+	} else if ((*flags & KGSL_CONTEXT_PREAMBLE) == 0 ||
+		  (*flags & KGSL_CONTEXT_NO_GMEM_ALLOC) == 0) {
 		KGSL_DEV_ERR_ONCE(device,
 				"legacy context switch not supported\n");
 		ret = -EINVAL;
@@ -469,8 +476,7 @@
 	kgsl_sharedmem_writel(device, &device->memstore,
 			KGSL_MEMSTORE_OFFSET(drawctxt->base.id, eoptimestamp),
 			0);
-	/* copy back whatever flags we dediced were valid */
-	*flags = drawctxt->base.flags;
+
 	return &drawctxt->base;
 err:
 	kgsl_context_detach(&drawctxt->base);
@@ -545,22 +551,9 @@
 	 */
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
-	/* Wait for the last global timestamp to pass before continuing.
-	 * The maxumum wait time is 30s, some large IB's can take longer
-	 * than 10s and if hang happens then the time for the context's
-	 * commands to retire will be greater than 10s. 30s should be sufficient
-	 * time to wait for the commands even if a hang happens.
-	 */
+	/* Wait for the last global timestamp to pass before continuing */
 	ret = adreno_drawctxt_wait_global(adreno_dev, context,
-		drawctxt->internal_timestamp, 30 * 1000);
-
-	/*
-	 * If the wait for global fails then nothing after this point is likely
-	 * to work very well - BUG_ON() so we can take advantage of the debug
-	 * tools to figure out what the h - e - double hockey sticks happened
-	 */
-
-	BUG_ON(ret);
+		drawctxt->internal_timestamp, 10 * 1000);
 
 	kgsl_sharedmem_writel(device, &device->memstore,
 			KGSL_MEMSTORE_OFFSET(context->id, soptimestamp),
@@ -577,8 +570,8 @@
 		drawctxt->ops->detach(drawctxt);
 
 	/* wake threads waiting to submit commands from this context */
-	wake_up_all(&drawctxt->waiting);
-	wake_up_all(&drawctxt->wq);
+	wake_up_interruptible_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->wq);
 
 	return ret;
 }
@@ -609,14 +602,14 @@
 int adreno_context_restore(struct adreno_device *adreno_dev,
 				  struct adreno_context *context)
 {
+	int ret;
 	struct kgsl_device *device;
-	unsigned int cmds[8];
+	unsigned int cmds[5];
 
 	if (adreno_dev == NULL || context == NULL)
 		return -EINVAL;
 
 	device = &adreno_dev->dev;
-
 	/* write the context identifier to the ringbuffer */
 	cmds[0] = cp_nop_packet(1);
 	cmds[1] = KGSL_CONTEXT_TO_MEM_IDENTIFIER;
@@ -624,13 +617,14 @@
 	cmds[3] = device->memstore.gpuaddr +
 		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL, current_context);
 	cmds[4] = context->base.id;
-	/* Flush the UCHE for new context */
-	cmds[5] = cp_type0_packet(
-		adreno_getreg(adreno_dev, ADRENO_REG_UCHE_INVALIDATE0), 2);
-	cmds[6] = 0;
-	cmds[7] = 0x90000000;
-	return adreno_ringbuffer_issuecmds(device, context,
-				KGSL_CMD_FLAGS_NONE, cmds, 8);
+	ret = adreno_ringbuffer_issuecmds(device, context, KGSL_CMD_FLAGS_NONE,
+					cmds, 5);
+	if (ret)
+		return ret;
+
+	return kgsl_mmu_setstate(&device->mmu,
+			context->base.proc_priv->pagetable,
+			context->base.id);
 }
 
 
@@ -703,10 +697,10 @@
 		if (flags & KGSL_CONTEXT_SAVE_GMEM)
 			/* Set the flag in context so that the save is done
 			* when this context is switched out. */
-			set_bit(ADRENO_CONTEXT_GMEM_SAVE, &drawctxt->priv);
+			drawctxt->flags |= CTXT_FLAGS_GMEM_SAVE;
 		else
 			/* Remove GMEM saving flag from the context */
-			clear_bit(ADRENO_CONTEXT_GMEM_SAVE, &drawctxt->priv);
+			drawctxt->flags &= ~CTXT_FLAGS_GMEM_SAVE;
 	}
 
 	/* already current? */
@@ -720,16 +714,25 @@
 	trace_adreno_drawctxt_switch(adreno_dev->drawctxt_active,
 		drawctxt, flags);
 
+	if (adreno_dev->drawctxt_active) {
+		ret = context_save(adreno_dev, adreno_dev->drawctxt_active);
+		if (ret) {
+			KGSL_DRV_ERR(device,
+				"Error in GPU context %d save: %d\n",
+				adreno_dev->drawctxt_active->base.id, ret);
+			return ret;
+		}
+
+		/* Put the old instance of the active drawctxt */
+		kgsl_context_put(&adreno_dev->drawctxt_active->base);
+		adreno_dev->drawctxt_active = NULL;
+	}
+
 	/* Get a refcount to the new instance */
 	if (drawctxt) {
 		if (!_kgsl_context_get(&drawctxt->base))
 			return -EINVAL;
 
-		ret = kgsl_mmu_setstate(&device->mmu,
-			drawctxt->base.proc_priv->pagetable,
-			adreno_dev->drawctxt_active ?
-			adreno_dev->drawctxt_active->base.id :
-			KGSL_CONTEXT_INVALID);
 		/* Set the new context */
 		ret = drawctxt->ops->restore(adreno_dev, drawctxt);
 		if (ret) {
@@ -747,11 +750,9 @@
 		 */
 		ret = kgsl_mmu_setstate(&device->mmu,
 					 device->mmu.defaultpagetable,
-					adreno_dev->drawctxt_active->base.id);
+					 KGSL_CONTEXT_INVALID);
 	}
-	/* Put the old instance of the active drawctxt */
-	if (adreno_dev->drawctxt_active)
-		kgsl_context_put(&adreno_dev->drawctxt_active->base);
+
 	adreno_dev->drawctxt_active = drawctxt;
 	return 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.h	2014-09-21 01:02:11.000000000 +0000
@@ -16,6 +16,44 @@
 #include "adreno_pm4types.h"
 #include "a2xx_reg.h"
 
+/* Flags */
+
+#define CTXT_FLAGS_NOT_IN_USE		0x00000000
+#define CTXT_FLAGS_IN_USE		BIT(0)
+
+/* state shadow memory allocated */
+#define CTXT_FLAGS_STATE_SHADOW		BIT(1)
+
+/* gmem shadow memory allocated */
+#define CTXT_FLAGS_GMEM_SHADOW		BIT(2)
+/* gmem must be copied to shadow */
+#define CTXT_FLAGS_GMEM_SAVE		BIT(3)
+/* gmem can be restored from shadow */
+#define CTXT_FLAGS_GMEM_RESTORE		BIT(4)
+/* preamble packed in cmdbuffer for context switching */
+#define CTXT_FLAGS_PREAMBLE		BIT(5)
+/* shader must be copied to shadow */
+#define CTXT_FLAGS_SHADER_SAVE		BIT(6)
+/* shader can be restored from shadow */
+#define CTXT_FLAGS_SHADER_RESTORE	BIT(7)
+/* Context has caused a GPU hang */
+#define CTXT_FLAGS_GPU_HANG		BIT(8)
+/* Specifies there is no need to save GMEM */
+#define CTXT_FLAGS_NOGMEMALLOC          BIT(9)
+/* Trash state for context */
+#define CTXT_FLAGS_TRASHSTATE		BIT(10)
+/* per context timestamps enabled */
+#define CTXT_FLAGS_PER_CONTEXT_TS	BIT(11)
+/* Context has caused a GPU hang and fault tolerance successful */
+#define CTXT_FLAGS_GPU_HANG_FT	BIT(12)
+/* User mode generated timestamps enabled */
+#define CTXT_FLAGS_USER_GENERATED_TS    BIT(14)
+/* Context skip till EOF */
+#define CTXT_FLAGS_SKIP_EOF             BIT(15)
+/* Context no fault tolerance */
+#define CTXT_FLAGS_NO_FAULT_TOLERANCE  BIT(16)
+/* Force the preamble for the next submission */
+#define CTXT_FLAGS_FORCE_PREAMBLE      BIT(17)
 
 /* Symbolic table for the adreno draw context type */
 #define ADRENO_DRAWCTXT_TYPES \
@@ -92,7 +130,7 @@
  * @internal_timestamp: Global timestamp of the last issued command
  *			NOTE: guarded by device->mutex, not drawctxt->mutex!
  * @state: Current state of the context
- * @priv: Internal flags
+ * @flags: Bitfield controlling behavior of the context
  * @type: Context type (GL, CL, RS)
  * @mutex: Mutex to protect the cmdqueue
  * @pagetable: Pointer to the GPU pagetable for the context
@@ -131,7 +169,7 @@
 	unsigned int timestamp;
 	unsigned int internal_timestamp;
 	int state;
-	unsigned long priv;
+	uint32_t flags;
 	unsigned int type;
 	struct mutex mutex;
 	struct kgsl_memdesc gpustate;
@@ -162,8 +200,8 @@
 
 	/* Dispatcher */
 	struct kgsl_cmdbatch *cmdqueue[ADRENO_CONTEXT_CMDQUEUE_SIZE];
-	unsigned int cmdqueue_head;
-	unsigned int cmdqueue_tail;
+	int cmdqueue_head;
+	int cmdqueue_tail;
 
 	struct plist_node pending;
 	wait_queue_head_t wq;
@@ -174,31 +212,6 @@
 	const struct adreno_context_ops *ops;
 };
 
-/**
- * enum adreno_context_priv - Private flags for an adreno draw context
- * @ADRENO_CONTEXT_FAULT - set if the context has faulted (and recovered)
- * @ADRENO_CONTEXT_GMEM_SAVE - gmem must be copied to shadow
- * @ADRENO_CONTEXT_GMEM_RESTORE - gmem can be restored from shadow
- * @ADRENO_CONTEXT_SHADER_SAVE - shader must be copied to shadow
- * @ADRENO_CONTEXT_SHADER_RESTORE - shader can be restored from shadow
- * @ADRENO_CONTEXT_GPU_HANG - Context has caused a GPU hang
- * @ADRENO_CONTEXT_GPU_HANG_FT - Context has caused a GPU hang
- *      and fault tolerance was successful
- * @ADRENO_CONTEXT_SKIP_EOF - Context skip IBs until the next end of frame
- *      marker.
- * @ADRENO_CONTEXT_FORCE_PREAMBLE - Force the preamble for the next submission.
- */
-enum adreno_context_priv {
-	ADRENO_CONTEXT_FAULT = 0,
-	ADRENO_CONTEXT_GMEM_SAVE,
-	ADRENO_CONTEXT_GMEM_RESTORE,
-	ADRENO_CONTEXT_SHADER_SAVE,
-	ADRENO_CONTEXT_SHADER_RESTORE,
-	ADRENO_CONTEXT_GPU_HANG,
-	ADRENO_CONTEXT_GPU_HANG_FT,
-	ADRENO_CONTEXT_SKIP_EOF,
-	ADRENO_CONTEXT_FORCE_PREAMBLE,
-};
 
 struct kgsl_context *adreno_drawctxt_create(struct kgsl_device_private *,
 			uint32_t *flags);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_pm4types.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_pm4types.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_pm4types.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_pm4types.h	2014-09-21 01:02:11.000000000 +0000
@@ -143,10 +143,10 @@
 #define CP_IM_STORE            0x2c
 
 /* test 2 memory locations to dword values specified */
-#define CP_TEST_TWO_MEMS	0x71
+#define CP_TEST_TWO_MEMS    0x71
 
 /* PFP waits until the FIFO between the PFP and the ME is empty */
-#define CP_WAIT_FOR_ME		0x13
+#define CP_WAIT_FOR_ME      0x13
 
 /*
  * for a20x
@@ -164,8 +164,6 @@
 
 #define CP_SET_PROTECTED_MODE  0x5f /* sets the register protection mode */
 
-#define CP_BOOTSTRAP_UCODE  0x6f /* bootstraps microcode */
-
 /*
  * for a3xx
  */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_postmortem.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_postmortem.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_postmortem.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_postmortem.c	2014-09-21 01:02:11.000000000 +0000
@@ -12,7 +12,6 @@
  */
 
 #include <linux/vmalloc.h>
-#include <mach/board.h>
 
 #include "kgsl.h"
 #include "kgsl_sharedmem.h"
@@ -52,7 +51,6 @@
 	{CP_DRAW_INDX,			"DRW_NDX_"},
 	{CP_DRAW_INDX_BIN,		"DRW_NDXB"},
 	{CP_EVENT_WRITE,		"EVENT_WT"},
-	{CP_MEM_WRITE,			"MEM_WRIT"},
 	{CP_IM_LOAD,			"IN__LOAD"},
 	{CP_IM_LOAD_IMMEDIATE,		"IM_LOADI"},
 	{CP_IM_STORE,			"IM_STORE"},
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,7 +20,6 @@
 #include "kgsl.h"
 #include "kgsl_sharedmem.h"
 #include "kgsl_cffdump.h"
-#include "kgsl_trace.h"
 
 #include "adreno.h"
 #include "adreno_pm4types.h"
@@ -31,6 +30,14 @@
 
 #define GSL_RB_NOP_SIZEDWORDS				2
 
+/*
+ * CP DEBUG settings for all cores:
+ * DYNAMIC_CLK_DISABLE [27] - turn off the dynamic clock control
+ * PROG_END_PTR_ENABLE [25] - Allow 128 bit writes to the VBIF
+ */
+
+#define CP_DEBUG_DEFAULT ((1 << 27) | (1 << 25))
+
 void adreno_ringbuffer_submit(struct adreno_ringbuffer *rb)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
@@ -208,19 +215,28 @@
  * adreno_ringbuffer_load_pm4_ucode() - Load pm4 ucode
  * @device: Pointer to a KGSL device
  * @start: Starting index in pm4 ucode to load
- * @end: Ending index of pm4 ucode to load
  * @addr: Address to load the pm4 ucode
  *
  * Load the pm4 ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
-			unsigned int start, unsigned int end, unsigned int addr)
+int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
+					unsigned int start, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int i;
 
+	if (adreno_dev->pm4_fw == NULL) {
+		int ret = adreno_ringbuffer_read_pm4_ucode(device);
+		if (ret)
+			return ret;
+	}
+
+	KGSL_DRV_INFO(device, "loading pm4 ucode version: %d\n",
+		adreno_dev->pm4_fw_version);
+
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_DEBUG, CP_DEBUG_DEFAULT);
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_RAM_WADDR, addr);
-	for (i = start; i < end; i++)
+	for (i = 1; i < adreno_dev->pm4_fw_size; i++)
 		adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_RAM_DATA,
 					adreno_dev->pm4_fw[i]);
 
@@ -262,19 +278,27 @@
  * adreno_ringbuffer_load_pfp_ucode() - Load pfp ucode
  * @device: Pointer to a KGSL device
  * @start: Starting index in pfp ucode to load
- * @end: Ending index of pfp ucode to load
  * @addr: Address to load the pfp ucode
  *
  * Load the pfp ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
-			unsigned int start, unsigned int end, unsigned int addr)
+int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
+					unsigned int start, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int i;
 
+	if (adreno_dev->pfp_fw == NULL) {
+		int ret = adreno_ringbuffer_read_pfp_ucode(device);
+		if (ret)
+			return ret;
+	}
+
+	KGSL_DRV_INFO(device, "loading pfp ucode version: %d\n",
+			adreno_dev->pfp_fw_version);
+
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_ADDR, addr);
-	for (i = start; i < end; i++)
+	for (i = 1; i < adreno_dev->pfp_fw_size; i++)
 		adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_DATA,
 						adreno_dev->pfp_fw[i]);
 
@@ -282,113 +306,72 @@
 }
 
 /**
- * _ringbuffer_bootstrap_ucode() - Bootstrap GPU Ucode
+ * _ringbuffer_start_common() - Ringbuffer start
  * @rb: Pointer to adreno ringbuffer
- * @load_jt: If non zero only load Jump tables
- *
- * Bootstrap ucode for GPU
- * load_jt == 0, bootstrap full microcode
- * load_jt == 1, bootstrap jump tables of microcode
  *
- * For example a bootstrap packet would like below
- * Setup a type3 bootstrap packet
- * PFP size to bootstrap
- * PFP addr to write the PFP data
- * PM4 size to bootstrap
- * PM4 addr to write the PM4 data
- * PFP dwords from microcode to bootstrap
- * PM4 size dwords from microcode to bootstrap
+ * Setup ringbuffer for GPU.
  */
-static int _ringbuffer_bootstrap_ucode(struct adreno_ringbuffer *rb,
-					unsigned int load_jt)
+int _ringbuffer_start_common(struct adreno_ringbuffer *rb)
 {
-	unsigned int *cmds, cmds_gpu, bootstrap_size;
-	int i = 0;
+	int status;
+	union reg_cp_rb_cntl cp_rb_cntl;
+	unsigned int rb_cntl;
 	struct kgsl_device *device = rb->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int pm4_size, pm4_idx, pm4_addr, pfp_size, pfp_idx, pfp_addr;
 
-	/* Only bootstrap jump tables of ucode */
-	if (load_jt) {
-		pm4_idx = adreno_dev->pm4_jt_idx;
-		pm4_addr = adreno_dev->pm4_jt_addr;
-		pfp_idx = adreno_dev->pfp_jt_idx;
-		pfp_addr = adreno_dev->pfp_jt_addr;
-	} else {
-		/* Bootstrap full ucode */
-		pm4_idx = 1;
-		pm4_addr = 0;
-		pfp_idx = 1;
-		pfp_addr = 0;
-	}
+	if (rb->flags & KGSL_FLAGS_STARTED)
+		return 0;
 
-	pm4_size = (adreno_dev->pm4_fw_size - pm4_idx);
-	pfp_size = (adreno_dev->pfp_fw_size - pfp_idx);
-
-	/*
-	 * Below set of commands register with PFP that 6f is the
-	 * opcode for bootstrapping
-	 */
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_ADDR, 0x200);
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_DATA, 0x6f0005);
-
-	/* clear ME_HALT to start micro engine */
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, 0);
-
-	bootstrap_size = (pm4_size + pfp_size + 5);
-
-	cmds = adreno_ringbuffer_allocspace(rb, NULL, bootstrap_size);
-	if (cmds == NULL)
-			return -ENOMEM;
-
-	cmds_gpu = rb->buffer_desc.gpuaddr +
-			sizeof(uint) * (rb->wptr - bootstrap_size);
-	/* Construct the packet that bootsraps the ucode */
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu,
-			cp_type3_packet(CP_BOOTSTRAP_UCODE,
-			(bootstrap_size - 1)));
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pfp_size);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pfp_addr);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pm4_size);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pm4_addr);
-	for (i = pfp_idx; i < adreno_dev->pfp_fw_size; i++)
-		GSL_RB_WRITE(rb->device, cmds, cmds_gpu, adreno_dev->pfp_fw[i]);
-	for (i = pm4_idx; i < adreno_dev->pm4_fw_size; i++)
-		GSL_RB_WRITE(rb->device, cmds, cmds_gpu, adreno_dev->pm4_fw[i]);
-
-	adreno_ringbuffer_submit(rb);
-	/* idle device to validate bootstrap */
-	return adreno_idle(device);
-}
-
-/**
- * _ringbuffer_setup_common() - Ringbuffer start
- * @rb: Pointer to adreno ringbuffer
- *
- * Setup ringbuffer for GPU.
- */
-void _ringbuffer_setup_common(struct adreno_ringbuffer *rb)
-{
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	kgsl_sharedmem_set(rb->device, &rb->memptrs_desc, 0, 0,
+			   sizeof(struct kgsl_rbmemptrs));
 
 	kgsl_sharedmem_set(rb->device, &rb->buffer_desc, 0, 0xAA,
 			   (rb->sizedwords << 2));
 
+	if (adreno_is_a2xx(adreno_dev)) {
+		kgsl_regwrite(device, REG_CP_RB_WPTR_BASE,
+			(rb->memptrs_desc.gpuaddr
+			+ GSL_RB_MEMPTRS_WPTRPOLL_OFFSET));
+
+		/* setup WPTR delay */
+		kgsl_regwrite(device, REG_CP_RB_WPTR_DELAY,
+			0 /*0x70000010 */);
+	}
+
+	/*setup REG_CP_RB_CNTL */
+	adreno_readreg(adreno_dev, ADRENO_REG_CP_RB_CNTL, &rb_cntl);
+	cp_rb_cntl.val = rb_cntl;
+
 	/*
 	 * The size of the ringbuffer in the hardware is the log2
-	 * representation of the size in quadwords (sizedwords / 2).
-	 * Also disable the host RPTR shadow register as it might be unreliable
-	 * in certain circumstances.
+	 * representation of the size in quadwords (sizedwords / 2)
 	 */
+	cp_rb_cntl.f.rb_bufsz = ilog2(rb->sizedwords >> 1);
 
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_CNTL,
-		(ilog2(rb->sizedwords >> 1) & 0x3F) |
-		(1 << 27));
+	/*
+	 * Specify the quadwords to read before updating mem RPTR.
+	 * Like above, pass the log2 representation of the blocksize
+	 * in quadwords.
+	*/
+	cp_rb_cntl.f.rb_blksz = ilog2(KGSL_RB_BLKSIZE >> 3);
+
+	if (adreno_is_a2xx(adreno_dev)) {
+		/* WPTR polling */
+		cp_rb_cntl.f.rb_poll_en = GSL_RB_CNTL_POLL_EN;
+	}
+
+	/* mem RPTR writebacks */
+	cp_rb_cntl.f.rb_no_update =  GSL_RB_CNTL_NO_UPDATE;
+
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_CNTL, cp_rb_cntl.val);
 
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_BASE,
 					rb->buffer_desc.gpuaddr);
 
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_RPTR_ADDR,
+				rb->memptrs_desc.gpuaddr +
+				GSL_RB_MEMPTRS_RPTR_OFFSET);
+
 	if (adreno_is_a2xx(adreno_dev)) {
 		/* explicitly clear all cp interrupts */
 		kgsl_regwrite(device, REG_CP_INT_ACK, 0xFFFFFFFF);
@@ -411,19 +394,6 @@
 		kgsl_regwrite(device, REG_CP_QUEUE_THRESHOLDS, 0x003E2008);
 
 	rb->wptr = 0;
-}
-
-/**
- * _ringbuffer_start_common() - Ringbuffer start
- * @rb: Pointer to adreno ringbuffer
- *
- * Start ringbuffer for GPU.
- */
-int _ringbuffer_start_common(struct adreno_ringbuffer *rb)
-{
-	int status;
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	/* clear ME_HALT to start micro engine */
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, 0);
@@ -436,6 +406,9 @@
 	/* idle device to validate ME INIT */
 	status = adreno_idle(device);
 
+	if (status == 0)
+		rb->flags |= KGSL_FLAGS_STARTED;
+
 	return status;
 }
 
@@ -452,94 +425,52 @@
 	struct kgsl_device *device = rb->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	_ringbuffer_setup_common(rb);
-
-	/* If bootstrapping if supported to load jump tables */
-	if (adreno_bootstrap_ucode(adreno_dev)) {
-		status = _ringbuffer_bootstrap_ucode(rb, 1);
-		if (status != 0)
-			return status;
-
-	} else {
-		/* load the CP jump tables using AHB writes */
-		status = adreno_ringbuffer_load_pm4_ucode(device,
-			adreno_dev->pm4_jt_idx, adreno_dev->pm4_fw_size,
-			adreno_dev->pm4_jt_addr);
-		if (status != 0)
-			return status;
-
-		/* load the prefetch parser jump tables using AHB writes */
-		status = adreno_ringbuffer_load_pfp_ucode(device,
-			adreno_dev->pfp_jt_idx, adreno_dev->pfp_fw_size,
-			adreno_dev->pfp_jt_addr);
-		if (status != 0)
-			return status;
-	}
+	/* load the CP ucode */
+	status = adreno_ringbuffer_load_pm4_ucode(device,
+			adreno_dev->pm4_jt_idx, adreno_dev->pm4_jt_addr);
+	if (status != 0)
+		return status;
 
-	status = _ringbuffer_start_common(rb);
+	/* load the prefetch parser ucode */
+	status = adreno_ringbuffer_load_pfp_ucode(device,
+			adreno_dev->pfp_jt_idx, adreno_dev->pfp_jt_addr);
+	if (status != 0)
+		return status;
 
-	return status;
+	return _ringbuffer_start_common(rb);
 }
 
-/**
- * adreno_ringbuffer_cold_start() - Ringbuffer cold start
- * @rb: Pointer to adreno ringbuffer
- *
- * Start the ringbuffer from power collapse.
- */
-int adreno_ringbuffer_cold_start(struct adreno_ringbuffer *rb)
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb)
 {
 	int status;
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
+	if (rb->flags & KGSL_FLAGS_STARTED)
+		return 0;
 
-	_ringbuffer_setup_common(rb);
-
-	/* If bootstrapping if supported to load ucode */
-	if (adreno_bootstrap_ucode(adreno_dev)) {
+	/* load the CP ucode */
+	status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1, 0);
+	if (status != 0)
+		return status;
 
-		/*
-		 * load first adreno_dev->pm4_bstrp_size +
-		 * adreno_dev->pfp_bstrp_size microcode dwords using AHB write,
-		 * this small microcode has dispatcher + booter, this initial
-		 * microcode enables CP to understand CP_BOOTSTRAP_UCODE packet
-		 * in function _ringbuffer_bootstrap_ucode. CP_BOOTSTRAP_UCODE
-		 * packet loads rest of the microcode.
-		 */
+	/* load the prefetch parser ucode */
+	status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1, 0);
+	if (status != 0)
+		return status;
 
-		status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1,
-					adreno_dev->pm4_bstrp_size+1, 0);
-		if (status != 0)
-			return status;
-
-		status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1,
-					adreno_dev->pfp_bstrp_size+1, 0);
-		if (status != 0)
-			return status;
-
-		/* Bootstrap rest of the ucode here */
-		status = _ringbuffer_bootstrap_ucode(rb, 0);
-		if (status != 0)
-			return status;
+	return _ringbuffer_start_common(rb);
+}
 
-	} else {
-		/* load the CP ucode using AHB writes */
-		status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1,
-					adreno_dev->pm4_fw_size, 0);
-		if (status != 0)
-			return status;
-
-		/* load the prefetch parser ucode using AHB writes */
-		status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1,
-					adreno_dev->pfp_fw_size, 0);
-		if (status != 0)
-			return status;
-	}
+void adreno_ringbuffer_stop(struct adreno_ringbuffer *rb)
+{
+	struct kgsl_device *device = rb->device;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	status = _ringbuffer_start_common(rb);
+	if (rb->flags & KGSL_FLAGS_STARTED) {
+		if (adreno_is_a200(adreno_dev))
+			kgsl_regwrite(rb->device, REG_CP_ME_CNTL, 0x10000000);
 
-	return status;
+		rb->flags &= ~KGSL_FLAGS_STARTED;
+	}
 }
 
 int adreno_ringbuffer_init(struct kgsl_device *device)
@@ -566,6 +497,20 @@
 		return status;
 	}
 
+	/* allocate memory for polling and timestamps */
+	/* This really can be at 4 byte alignment boundry but for using MMU
+	 * we need to make it at page boundary */
+	status = kgsl_allocate_contiguous(&rb->memptrs_desc,
+		sizeof(struct kgsl_rbmemptrs));
+
+	if (status != 0) {
+		adreno_ringbuffer_close(rb);
+		return status;
+	}
+
+	/* overlay structure on memptrs memory */
+	rb->memptrs = (struct kgsl_rbmemptrs *) rb->memptrs_desc.hostptr;
+
 	rb->global_ts = 0;
 
 	return 0;
@@ -576,6 +521,7 @@
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
 
 	kgsl_sharedmem_free(&rb->buffer_desc);
+	kgsl_sharedmem_free(&rb->memptrs_desc);
 
 	kfree(adreno_dev->pfp_fw);
 	kfree(adreno_dev->pm4_fw);
@@ -632,8 +578,7 @@
 	total_sizedwords += (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE) ? 2 : 0;
 
 	/* Add two dwords for the CP_INTERRUPT */
-	total_sizedwords +=
-		(drawctxt || (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE)) ?  2 : 0;
+	total_sizedwords += drawctxt ? 2 : 0;
 
 	/* context rollover */
 	if (adreno_is_a3xx(adreno_dev))
@@ -649,9 +594,6 @@
 	total_sizedwords += 3; /* sop timestamp */
 	total_sizedwords += 4; /* eop timestamp */
 
-	if (adreno_is_a20x(adreno_dev))
-		total_sizedwords += 2; /* CACHE_FLUSH */
-
 	if (drawctxt) {
 		total_sizedwords += 3; /* global timestamp without cache
 					* flush for non-zero context */
@@ -665,7 +607,7 @@
 
 	/* Add space for the power on shader fixup if we need it */
 	if (flags & KGSL_CMD_FLAGS_PWRON_FIXUP)
-		total_sizedwords += 9;
+		total_sizedwords += 5;
 
 	ringcmds = adreno_ringbuffer_allocspace(rb, drawctxt, total_sizedwords);
 
@@ -687,11 +629,6 @@
 	}
 
 	if (flags & KGSL_CMD_FLAGS_PWRON_FIXUP) {
-		/* Disable protected mode for the fixup */
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_SET_PROTECTED_MODE, 1));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, 0);
-
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, cp_nop_packet(1));
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
 				KGSL_PWRON_FIXUP_IDENTIFIER);
@@ -701,11 +638,6 @@
 			adreno_dev->pwron_fixup.gpuaddr);
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
 			adreno_dev->pwron_fixup_dwords);
-
-		/* Re-enable protected mode */
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_SET_PROTECTED_MODE, 1));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, 1);
 	}
 
 	/* start-of-pipeline timestamp */
@@ -777,8 +709,7 @@
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, (gpuaddr +
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 				eoptimestamp)));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			rb->global_ts);
+		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, rb->global_ts);
 	}
 
 	if (adreno_is_a20x(adreno_dev)) {
@@ -1083,7 +1014,7 @@
 		timestamp);
 
 	if (ret)
-		KGSL_DRV_ERR(device, "adreno_context_queue_cmd returned %d\n",
+		KGSL_DRV_ERR(device, "adreno_dispatcher_queue_cmd returned %d\n",
 				ret);
 	else {
 		/*
@@ -1102,89 +1033,9 @@
 		}
 	}
 
-	/*
-	 * Return -EPROTO if the device has faulted since the last time we
-	 * checked - userspace uses this to perform post-fault activities
-	 */
-	if (!ret && test_and_clear_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv))
-		ret = -EPROTO;
-
 	return ret;
 }
 
-unsigned int adreno_ringbuffer_get_constraint(struct kgsl_device *device,
-				struct kgsl_context *context)
-{
-	unsigned int pwrlevel = device->pwrctrl.active_pwrlevel;
-
-	switch (context->pwr_constraint.type) {
-	case KGSL_CONSTRAINT_PWRLEVEL: {
-		switch (context->pwr_constraint.sub_type) {
-		case KGSL_CONSTRAINT_PWR_MAX:
-			pwrlevel = device->pwrctrl.max_pwrlevel;
-			break;
-		case KGSL_CONSTRAINT_PWR_MIN:
-			pwrlevel = device->pwrctrl.min_pwrlevel;
-			break;
-		default:
-			break;
-		}
-	}
-	break;
-
-	}
-
-	return pwrlevel;
-}
-
-void adreno_ringbuffer_set_constraint(struct kgsl_device *device,
-			struct kgsl_cmdbatch *cmdbatch)
-{
-	unsigned int constraint;
-	struct kgsl_context *context = cmdbatch->context;
-	/*
-	 * Check if the context has a constraint and constraint flags are
-	 * set.
-	 */
-	if (context->pwr_constraint.type &&
-		((context->flags & KGSL_CONTEXT_PWR_CONSTRAINT) ||
-			(cmdbatch->flags & KGSL_CONTEXT_PWR_CONSTRAINT))) {
-
-		constraint = adreno_ringbuffer_get_constraint(device, context);
-
-		/*
-		 * If a constraint is already set, set a new constraint only
-		 * if it is faster.  If the requested constraint is the same
-		 * as the current one, update ownership and timestamp.
-		 */
-		if ((device->pwrctrl.constraint.type ==
-			KGSL_CONSTRAINT_NONE) || (constraint <
-			device->pwrctrl.constraint.hint.pwrlevel.level)) {
-
-			kgsl_pwrctrl_pwrlevel_change(device, constraint);
-			device->pwrctrl.constraint.type =
-					context->pwr_constraint.type;
-			device->pwrctrl.constraint.hint.
-					pwrlevel.level = constraint;
-			device->pwrctrl.constraint.owner_id = context->id;
-			device->pwrctrl.constraint.expires = jiffies +
-					device->pwrctrl.interval_timeout;
-			/* Trace the constraint being set by the driver */
-			trace_kgsl_constraint(device,
-					device->pwrctrl.constraint.type,
-					constraint, 1);
-		} else if ((device->pwrctrl.constraint.type ==
-				context->pwr_constraint.type) &&
-			(device->pwrctrl.constraint.hint.pwrlevel.level ==
-				constraint)) {
-			device->pwrctrl.constraint.owner_id = context->id;
-			device->pwrctrl.constraint.expires = jiffies +
-					device->pwrctrl.interval_timeout;
-		}
-	}
-
-}
-
 /* adreno_rindbuffer_submitcmd - submit userspace IBs to the GPU */
 int adreno_ringbuffer_submitcmd(struct adreno_device *adreno_dev,
 		struct kgsl_cmdbatch *cmdbatch)
@@ -1211,7 +1062,7 @@
 	commands are stored in the first node of the IB chain. We can skip that
 	if a context switch hasn't occured */
 
-	if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) &&
+	if ((drawctxt->flags & CTXT_FLAGS_PREAMBLE) &&
 		!test_bit(CMDBATCH_FLAG_FORCE_PREAMBLE, &cmdbatch->priv) &&
 		(adreno_dev->drawctxt_active == drawctxt))
 		start_index = 1;
@@ -1292,9 +1143,6 @@
 		test_bit(ADRENO_DEVICE_PWRON_FIXUP, &adreno_dev->priv))
 		flags |= KGSL_CMD_FLAGS_PWRON_FIXUP;
 
-	/* Set the constraints before adding to ringbuffer */
-	adreno_ringbuffer_set_constraint(device, cmdbatch);
-
 	ret = adreno_ringbuffer_addcmds(&adreno_dev->ringbuffer,
 					drawctxt,
 					flags,
@@ -1316,7 +1164,7 @@
 	device->pwrctrl.irq_last = 0;
 	kgsl_trace_issueibcmds(device, context->id, cmdbatch,
 		cmdbatch->timestamp, cmdbatch->flags, ret,
-		drawctxt->type);
+		drawctxt ? drawctxt->type : 0);
 
 	kfree(link);
 	return ret;
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,6 +19,7 @@
  */
 
 #define KGSL_RB_SIZE (32 * 1024)
+#define KGSL_RB_BLKSIZE 16
 
 /* CP timestamp register */
 #define	REG_CP_TIMESTAMP		 REG_SCRATCH_REG0
@@ -27,18 +28,35 @@
 struct kgsl_device;
 struct kgsl_device_private;
 
+#define GSL_RB_MEMPTRS_SCRATCH_COUNT	 8
+struct kgsl_rbmemptrs {
+	int  rptr;
+	int  wptr_poll;
+};
+
+#define GSL_RB_MEMPTRS_RPTR_OFFSET \
+	(offsetof(struct kgsl_rbmemptrs, rptr))
+
+#define GSL_RB_MEMPTRS_WPTRPOLL_OFFSET \
+	(offsetof(struct kgsl_rbmemptrs, wptr_poll))
+
 struct adreno_ringbuffer {
 	struct kgsl_device *device;
 	uint32_t flags;
 
 	struct kgsl_memdesc buffer_desc;
 
+	struct kgsl_memdesc memptrs_desc;
+	struct kgsl_rbmemptrs *memptrs;
+
 	/*ringbuffer size */
 	unsigned int sizedwords;
 
 	unsigned int wptr; /* write pointer offset in dwords from baseaddr */
 
 	unsigned int global_ts;
+
+    unsigned int timestamp[KGSL_MEMSTORE_MAX];
 };
 
 
@@ -54,6 +72,25 @@
 /* enable timestamp (...scratch0) memory shadowing */
 #define GSL_RB_MEMPTRS_SCRATCH_MASK 0x1
 
+/* mem rptr */
+#define GSL_RB_CNTL_NO_UPDATE 0x0 /* enable */
+
+/**
+ * adreno_get_rptr - Get the current ringbuffer read pointer
+ * @rb -  the ringbuffer
+ *
+ * Get the current read pointer, which is written by the GPU.
+ */
+static inline unsigned int
+adreno_get_rptr(struct adreno_ringbuffer *rb)
+{
+	unsigned int result = rb->memptrs->rptr;
+	rmb();
+	return result;
+}
+
+#define GSL_RB_CNTL_POLL_EN 0x0 /* disable */
+
 /*
  * protected mode error checking below register address 0x800
  * note: if CP_INTERRUPT packet is used then checking needs
@@ -73,7 +110,9 @@
 
 int adreno_ringbuffer_warm_start(struct adreno_ringbuffer *rb);
 
-int adreno_ringbuffer_cold_start(struct adreno_ringbuffer *rb);
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb);
+
+void adreno_ringbuffer_stop(struct adreno_ringbuffer *rb);
 
 void adreno_ringbuffer_close(struct adreno_ringbuffer *rb);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -21,7 +21,6 @@
 #define TRACE_INCLUDE_FILE adreno_trace
 
 #include <linux/tracepoint.h>
-#include "kgsl_device.h"
 
 TRACE_EVENT(adreno_cmdbatch_queued,
 	TP_PROTO(struct kgsl_cmdbatch *cmdbatch, unsigned int queued),
@@ -265,36 +264,6 @@
 		__entry->ib2base, __entry->ib2size)
 );
 
-TRACE_EVENT(kgsl_user_pwrlevel_constraint,
-
-	TP_PROTO(struct kgsl_device *device, unsigned int id, unsigned int type,
-		unsigned int sub_type),
-
-	TP_ARGS(device, id, type, sub_type),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(unsigned int, id)
-		__field(unsigned int, type)
-		__field(unsigned int, sub_type)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->id = id;
-		__entry->type = type;
-		__entry->sub_type = sub_type;
-	),
-
-	TP_printk(
-		"d_name=%s ctx=%u constraint_type=%s constraint_subtype=%s",
-		__get_str(device_name), __entry->id,
-		__print_symbolic(__entry->type, KGSL_CONSTRAINT_TYPES),
-		__print_symbolic(__entry->sub_type,
-		KGSL_CONSTRAINT_PWRLEVEL_SUBTYPES)
-	)
-);
-
 #endif /* _ADRENO_TRACE_H */
 
 /* This part must be outside protection */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.c	2014-09-21 01:02:11.000000000 +0000
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/workqueue.h>
 #include <linux/dma-buf.h>
+
 #include <linux/vmalloc.h>
 #include <linux/pm_runtime.h>
 #include <linux/genlock.h>
@@ -40,7 +41,6 @@
 #include "kgsl_device.h"
 #include "kgsl_trace.h"
 #include "kgsl_sync.h"
-#include "adreno.h"
 
 #undef MODULE_PARAM_PREFIX
 #define MODULE_PARAM_PREFIX "kgsl."
@@ -62,6 +62,9 @@
 
 static void kgsl_mem_entry_detach_process(struct kgsl_mem_entry *entry);
 
+static void
+kgsl_put_process_private(struct kgsl_device *device,
+			 struct kgsl_process_private *private);
 /**
  * kgsl_trace_issueibcmds() - Call trace_issueibcmds by proxy
  * device: KGSL device
@@ -341,33 +344,27 @@
  */
 static int
 kgsl_mem_entry_attach_process(struct kgsl_mem_entry *entry,
-				   struct kgsl_device_private *dev_priv)
+				   struct kgsl_process_private *process)
 {
 	int ret;
-	struct kgsl_process_private *process = dev_priv->process_priv;
-
-	ret = kgsl_process_private_get(process);
-	if (!ret)
-		return -EBADF;
 
 	while (1) {
 		if (idr_pre_get(&process->mem_idr, GFP_KERNEL) == 0) {
 			ret = -ENOMEM;
-			goto err_put_proc_priv;
+			goto err;
 		}
 
 		spin_lock(&process->mem_lock);
 		ret = idr_get_new_above(&process->mem_idr, entry, 1,
 					&entry->id);
 		spin_unlock(&process->mem_lock);
+
 		if (ret == 0)
 			break;
 		else if (ret != -EAGAIN)
-			goto err_put_proc_priv;
+			goto err;
 	}
-
 	entry->priv = process;
-	entry->dev_priv = dev_priv;
 
 	spin_lock(&process->mem_lock);
 	ret = kgsl_mem_entry_track_gpuaddr(process, entry);
@@ -375,17 +372,14 @@
 		idr_remove(&process->mem_idr, entry->id);
 	spin_unlock(&process->mem_lock);
 	if (ret)
-		goto err_put_proc_priv;
+		goto err;
 	/* map the memory after unlocking if gpuaddr has been assigned */
 	if (entry->memdesc.gpuaddr) {
 		ret = kgsl_mmu_map(process->pagetable, &entry->memdesc);
 		if (ret)
 			kgsl_mem_entry_detach_process(entry);
 	}
-	return ret;
-
-err_put_proc_priv:
-	kgsl_process_private_put(process);
+err:
 	return ret;
 }
 
@@ -408,7 +402,6 @@
 
 	entry->priv->stats[entry->memtype].cur -= entry->memdesc.size;
 	spin_unlock(&entry->priv->mem_lock);
-	kgsl_process_private_put(entry->priv);
 
 	entry->priv = NULL;
 }
@@ -466,7 +459,7 @@
 	 * the context is destroyed. This will also prevent the pagetable
 	 * from being destroyed
 	 */
-	if (!kgsl_process_private_get(dev_priv->process_priv))
+	if (!kref_get_unless_zero(&dev_priv->process_priv->refcount))
 		goto fail_free_id;
 	context->device = dev_priv->device;
 	context->dev_priv = dev_priv;
@@ -513,29 +506,31 @@
  */
 int kgsl_context_detach(struct kgsl_context *context)
 {
+	struct kgsl_device *device;
 	int ret;
 
-	if (context == NULL)
+	if (context == NULL || kgsl_context_detached(context))
 		return -EINVAL;
 
+	device = context->device;
+
+	trace_kgsl_context_detach(device, context);
+
 	/*
 	 * Mark the context as detached to keep others from using
-	 * the context before it gets fully removed, and to make sure
-	 * we don't try to detach twice.
+	 * the context before it gets fully removed
 	 */
-	if (test_and_set_bit(KGSL_CONTEXT_DETACHED, &context->priv))
-		return -EINVAL;
-
-	trace_kgsl_context_detach(context->device, context);
+	set_bit(KGSL_CONTEXT_DETACHED, &context->priv);
 
-	ret = context->device->ftbl->drawctxt_detach(context);
+	ret = device->ftbl->drawctxt_detach(context);
 
 	/*
 	 * Cancel events after the device-specific context is
 	 * detached, to avoid possibly freeing memory while
 	 * it is still in use by the GPU.
 	 */
-	kgsl_context_cancel_events(context->device, context);
+
+	kgsl_context_cancel_events(device, context);
 
 	kgsl_context_put(context);
 
@@ -555,28 +550,13 @@
 
 	write_lock(&device->context_lock);
 	if (context->id != KGSL_CONTEXT_INVALID) {
-
-		/* Clear the timestamps in the memstore during destroy */
-		kgsl_sharedmem_writel(device, &device->memstore,
-			KGSL_MEMSTORE_OFFSET(context->id, soptimestamp), 0);
-		kgsl_sharedmem_writel(device, &device->memstore,
-			KGSL_MEMSTORE_OFFSET(context->id, eoptimestamp), 0);
-
-		/* clear device power constraint */
-		if (context->id == device->pwrctrl.constraint.owner_id) {
-			trace_kgsl_constraint(device,
-				device->pwrctrl.constraint.type,
-				device->pwrctrl.active_pwrlevel,
-				0);
-			device->pwrctrl.constraint.type = KGSL_CONSTRAINT_NONE;
-		}
-
 		idr_remove(&device->context_idr, context->id);
 		context->id = KGSL_CONTEXT_INVALID;
 	}
 	write_unlock(&device->context_lock);
 	kgsl_sync_timeline_destroy(context);
-	kgsl_process_private_put(context->proc_priv);
+	kgsl_put_process_private(device,
+				context->proc_priv);
 
 	device->ftbl->drawctxt_destroy(context);
 }
@@ -841,8 +821,9 @@
 	return;
 }
 
-void
-kgsl_process_private_put(struct kgsl_process_private *private)
+static void
+kgsl_put_process_private(struct kgsl_device *device,
+			 struct kgsl_process_private *private)
 {
 	mutex_lock(&kgsl_driver.process_mutex);
 
@@ -856,7 +837,7 @@
 	return;
 }
 
-/**
+/*
  * find_process_private() - Helper function to search for process private
  * @cur_dev_priv: Pointer to device private structure which contains pointers
  * to device and process_private structs.
@@ -871,8 +852,7 @@
 	mutex_lock(&kgsl_driver.process_mutex);
 	list_for_each_entry(private, &kgsl_driver.process_list, list) {
 		if (private->pid == task_tgid_nr(current)) {
-			if (!kgsl_process_private_get(private))
-				private = NULL;
+			kref_get(&private->refcount);
 			goto done;
 		}
 	}
@@ -897,7 +877,7 @@
 	return private;
 }
 
-/**
+/*
  * kgsl_get_process_private() - Used to find the process private structure
  * @cur_dev_priv: Current device pointer
  * Finds or creates a new porcess private structire and initializes its members
@@ -911,12 +891,13 @@
 
 	private = kgsl_find_process_private(cur_dev_priv);
 
-	if (!private)
-		return NULL;
-
 	mutex_lock(&private->process_private_mutex);
 
-	if (test_bit(KGSL_PROCESS_INIT, &private->priv))
+	/*
+	 * If debug root initialized then it means the rest of the fields
+	 * are also initialized
+	 */
+	if (private->debug_root)
 		goto done;
 
 	private->mem_rb = RB_ROOT;
@@ -937,15 +918,13 @@
 	if (kgsl_process_init_debugfs(private))
 		goto error;
 
-	set_bit(KGSL_PROCESS_INIT, &private->priv);
-
 done:
 	mutex_unlock(&private->process_private_mutex);
 	return private;
 
 error:
 	mutex_unlock(&private->process_private_mutex);
-	kgsl_process_private_put(private);
+	kgsl_put_process_private(cur_dev_priv->device, private);
 	return NULL;
 }
 
@@ -961,6 +940,8 @@
 		/* Fail if the wait times out */
 		BUG_ON(atomic_read(&device->active_cnt) > 0);
 
+		/* Force power on to do the stop */
+		kgsl_pwrctrl_enable(device);
 		result = device->ftbl->stop(device);
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
 	}
@@ -976,7 +957,6 @@
 	struct kgsl_process_private *private = dev_priv->process_priv;
 	struct kgsl_device *device = dev_priv->device;
 	struct kgsl_context *context;
-	struct kgsl_mem_entry *entry;
 	int next = 0;
 
 	filep->private_data = NULL;
@@ -1005,31 +985,6 @@
 
 		next = next + 1;
 	}
-
-	next = 0;
-	while (1) {
-		spin_lock(&private->mem_lock);
-		entry = idr_get_next(&private->mem_idr, &next);
-		if (entry == NULL) {
-			spin_unlock(&private->mem_lock);
-			break;
-		}
-		/*
-		 * If the free pending flag is not set it means that user space
-		 * did not free it's reference to this entry, in that case
-		 * free a reference to this entry, other references are from
-		 * within kgsl so they will be freed eventually by kgsl
-		 */
-		if (entry->dev_priv == dev_priv && !entry->pending_free) {
-			entry->pending_free = 1;
-			spin_unlock(&private->mem_lock);
-			trace_kgsl_mem_free(entry);
-			kgsl_mem_entry_put(entry);
-		} else {
-			spin_unlock(&private->mem_lock);
-		}
-		next = next + 1;
-	}
 	/*
 	 * Clean up any to-be-freed entries that belong to this
 	 * process and this device. This is done after the context
@@ -1040,10 +995,9 @@
 
 	result = kgsl_close_device(device);
 	mutex_unlock(&device->mutex);
-
 	kfree(dev_priv);
 
-	kgsl_process_private_put(private);
+	kgsl_put_process_private(device, private);
 
 	pm_runtime_put(device->parentdev);
 	return result;
@@ -1151,7 +1105,7 @@
 	if (device->open_count == 0) {
 		/* make sure power is on to stop the device */
 		kgsl_pwrctrl_enable(device);
-		device->ftbl->stop(device);
+		result = device->ftbl->stop(device);
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
 		atomic_dec(&device->active_cnt);
 	}
@@ -1319,12 +1273,10 @@
 static inline bool kgsl_mem_entry_set_pend(struct kgsl_mem_entry *entry)
 {
 	bool ret = false;
-
-	if (entry == NULL)
-		return false;
-
 	spin_lock(&entry->priv->mem_lock);
-	if (!entry->pending_free) {
+	if (entry && entry->pending_free) {
+		ret = false;
+	} else if (entry) {
 		entry->pending_free = 1;
 		ret = true;
 	}
@@ -1379,7 +1331,6 @@
 			result = -EINVAL;
 			break;
 		}
-
 		/*
 		 * Copy the reset status to value which also serves as
 		 * the out parameter
@@ -1414,8 +1365,8 @@
 
 	if (dev_priv->device->ftbl->setproperty)
 		result = dev_priv->device->ftbl->setproperty(
-			dev_priv, param->type, param->value,
-			param->sizebytes);
+			dev_priv->device, param->type,
+			param->value, param->sizebytes);
 
 	return result;
 }
@@ -1948,8 +1899,7 @@
 
 /**
  * _kgsl_cmdbatch_verify() - Perform a quick sanity check on a command batch
- * @device: Pointer to a KGSL instance that owns the command batch
- * @pagetable: Pointer to the pagetable for the current process
+ * @device: Pointer to a KGSL device that owns the command batch
  * @cmdbatch: Number of indirect buffers to make room for in the cmdbatch
  *
  * Do a quick sanity test on the list of indirect buffers in a command batch
@@ -1959,6 +1909,7 @@
 	struct kgsl_cmdbatch *cmdbatch)
 {
 	int i;
+
 	struct kgsl_process_private *private = dev_priv->process_priv;
 
 	for (i = 0; i < cmdbatch->ibcount; i++) {
@@ -2123,11 +2074,7 @@
 		cmdbatch, &param->timestamp);
 
 free_cmdbatch:
-	/*
-	 * -EPROTO is a "success" error - it just tells the user that the
-	 * context had previously faulted
-	 */
-	if (result && result != -EPROTO)
+	if (result)
 		kgsl_cmdbatch_destroy(cmdbatch);
 
 done:
@@ -2175,11 +2122,7 @@
 		cmdbatch, &param->timestamp);
 
 free_cmdbatch:
-	/*
-	 * -EPROTO is a "success" error - it just tells the user that the
-	 * context had previously faulted
-	 */
-	if (result && result != -EPROTO)
+	if (result)
 		kgsl_cmdbatch_destroy(cmdbatch);
 
 done:
@@ -2388,11 +2331,6 @@
 
 	trace_kgsl_mem_free(entry);
 
-	kgsl_memfree_hist_set_event(entry->priv->pid,
-				    entry->memdesc.gpuaddr,
-				    entry->memdesc.size,
-				    entry->memdesc.flags);
-
 	/*
 	 * First kgsl_mem_entry_put is for the reference that we took in
 	 * this function when calling kgsl_sharedmem_find_id, second one is
@@ -2475,8 +2413,10 @@
 
 	ret = -ERANGE;
 
-	if (phys == 0)
+	if (phys == 0) {
+		KGSL_CORE_ERR("kgsl_get_phys_file returned phys=0\n");
 		goto err;
+	}
 
 	/* Make sure the length of the region, the offset and the desired
 	 * size are all page aligned or bail
@@ -2484,13 +2424,19 @@
 	if ((len & ~PAGE_MASK) ||
 		(offset & ~PAGE_MASK) ||
 		(size & ~PAGE_MASK)) {
-		KGSL_CORE_ERR("length offset or size is not page aligned\n");
+		KGSL_CORE_ERR("length %lu, offset %u or size %u "
+				"is not page aligned\n",
+				len, offset, size);
 		goto err;
 	}
 
 	/* The size or offset can never be greater than the PMEM length */
-	if (offset >= len || size > len)
+	if (offset >= len || size > len) {
+		KGSL_CORE_ERR("offset %u or size %u "
+				"exceeds pmem length %lu\n",
+				offset, size, len);
 		goto err;
+	}
 
 	/* If size is 0, then adjust it to default to the size of the region
 	 * minus the offset.  If size isn't zero, then make sure that it will
@@ -2807,7 +2753,7 @@
 			| KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	entry->memdesc.flags = param->flags;
-	if (!kgsl_mmu_use_cpu_map(&dev_priv->device->mmu))
+	if (!kgsl_mmu_use_cpu_map(private->pagetable->mmu))
 		entry->memdesc.flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
@@ -2880,7 +2826,7 @@
 	/* echo back flags */
 	param->flags = entry->memdesc.flags;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result)
 		goto error_attach;
 
@@ -2910,9 +2856,6 @@
 		break;
 	}
 error:
-	/* Clear gpuaddr here so userspace doesn't get any wrong ideas */
-	param->gpuaddr = 0;
-
 	kfree(entry);
 	return result;
 }
@@ -3007,7 +2950,7 @@
 	bool full_flush = false;
 
 	if (param->id_list == NULL || param->count == 0
-			|| param->count > (PAGE_SIZE / sizeof(unsigned int)))
+			|| param->count > (UINT_MAX/sizeof(unsigned int)))
 		return -EINVAL;
 
 	id_list = kzalloc(param->count * sizeof(unsigned int), GFP_KERNEL);
@@ -3129,8 +3072,7 @@
 
 	align = (flags & KGSL_MEMALIGN_MASK) >> KGSL_MEMALIGN_SHIFT;
 	if (align >= 32) {
-		KGSL_CORE_ERR("Alignment too big, restricting to 2^31\n");
-
+		KGSL_CORE_ERR("Alignment too big, restricting to 2^32\n");
 		flags &= ~KGSL_MEMALIGN_MASK;
 		flags |= (31 << KGSL_MEMALIGN_SHIFT) & KGSL_MEMALIGN_MASK;
 	}
@@ -3142,8 +3084,8 @@
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
 		entry->memdesc.priv |= KGSL_MEMDESC_GUARD_PAGE;
 
-	result = kgsl_allocate_user(dev_priv->device, &entry->memdesc,
-				private->pagetable, size, flags);
+	result = kgsl_allocate_user(&entry->memdesc, private->pagetable, size,
+				    flags);
 	if (result != 0)
 		goto err;
 
@@ -3171,7 +3113,7 @@
 	if (result)
 		return result;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result != 0)
 		goto err;
 
@@ -3193,19 +3135,18 @@
 			unsigned int cmd, void *data)
 {
 	struct kgsl_process_private *private = dev_priv->process_priv;
-	struct kgsl_device *device = dev_priv->device;
 	struct kgsl_gpumem_alloc_id *param = data;
 	struct kgsl_mem_entry *entry = NULL;
 	int result;
 
-	if (!kgsl_mmu_use_cpu_map(&device->mmu))
+	if (!kgsl_mmu_use_cpu_map(private->pagetable->mmu))
 		param->flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	result = _gpumem_alloc(dev_priv, &entry, param->size, param->flags);
 	if (result != 0)
 		goto err;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result != 0)
 		goto err;
 
@@ -3302,12 +3243,11 @@
 };
 
 /**
- * kgsl_genlock_event_cb() - Event callback for a genlock timestamp event
- * @device: The KGSL device that expired the timestamp
- * @priv: private data for the event
- * @context_id: the context id that goes with the timestamp
- * @timestamp: the timestamp that triggered the event
- * @type: Type of event that signaled the callback
+ * kgsl_genlock_event_cb - Event callback for a genlock timestamp event
+ * @device - The KGSL device that expired the timestamp
+ * @priv - private data for the event
+ * @context_id - the context id that goes with the timestamp
+ * @timestamp - the timestamp that triggered the event
  *
  * Release a genlock lock following the expiration of a timestamp
  */
@@ -3428,7 +3368,7 @@
 static const struct {
 	unsigned int cmd;
 	kgsl_ioctl_func_t func;
-	unsigned int flags;
+	int flags;
 } kgsl_ioctl_funcs[] = {
 	KGSL_IOCTL_FUNC(IOCTL_KGSL_DEVICE_GETPROPERTY,
 			kgsl_ioctl_device_getproperty,
@@ -3707,7 +3647,7 @@
 static inline bool
 mmap_range_valid(unsigned long addr, unsigned long len)
 {
-	return ((ULONG_MAX - addr) > len) && ((addr + len) < TASK_SIZE);
+	return (addr + len) > addr && (addr + len) < TASK_SIZE;
 }
 
 static unsigned long
@@ -3864,7 +3804,7 @@
 	if (ret)
 		return ret;
 
-	vma->vm_flags |= entry->memdesc.ops->vmflags;
+	vma->vm_flags |= entry->memdesc.ops->vmflags(&entry->memdesc);
 
 	vma->vm_private_data = entry;
 
@@ -4191,7 +4131,7 @@
 			pwr->power_flags, pwr->active_pwrlevel);
 
 		KGSL_LOG_DUMP(device, "POWER: INTERVAL TIMEOUT = %08X ",
-				pwr->interval_timeout);
+				  pwr->interval_timeout);
 
 	}
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.h	2014-09-21 01:02:11.000000000 +0000
@@ -146,7 +146,7 @@
 struct kgsl_cmdbatch;
 
 struct kgsl_memdesc_ops {
-	unsigned int vmflags;
+	int (*vmflags)(struct kgsl_memdesc *);
 	int (*vmfault)(struct kgsl_memdesc *, struct vm_area_struct *,
 		       struct vm_fault *);
 	void (*free)(struct kgsl_memdesc *memdesc);
@@ -178,7 +178,6 @@
 	unsigned int sglen_alloc;  /* Allocated entries in the sglist */
 	struct kgsl_memdesc_ops *ops;
 	unsigned int flags; /* Flags set from userspace */
-	struct device *dev;
 };
 
 /* List of different memory entry types */
@@ -203,7 +202,6 @@
 	struct kgsl_process_private *priv;
 	/* Initialized to 0, set to 1 when entry is marked for freeing */
 	int pending_free;
-	struct kgsl_device_private *dev_priv;
 };
 
 #ifdef CONFIG_MSM_KGSL_MMU_PAGE_FAULT
@@ -273,7 +271,7 @@
 		size = 1;
 
 	/* don't overflow */
-	if (size > UINT_MAX - gpuaddr)
+	if ((gpuaddr + size) < gpuaddr)
 		return 0;
 
 	if (gpuaddr >= memdesc->gpuaddr &&
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.c	2014-09-21 01:02:11.000000000 +0000
@@ -247,7 +247,7 @@
 
 static void print_mem_entry(struct seq_file *s, struct kgsl_mem_entry *entry)
 {
-	char flags[7];
+	char flags[6];
 	char usage[16];
 	struct kgsl_memdesc *m = &entry->memdesc;
 
@@ -256,16 +256,13 @@
 	flags[2] = get_alignflag(m);
 	flags[3] = get_cacheflag(m);
 	flags[4] = kgsl_memdesc_use_cpu_map(m) ? 'p' : '-';
-	flags[5] = (m->useraddr) ? 'Y' : 'N';
-	flags[6] = '\0';
+	flags[5] = '\0';
 
 	kgsl_get_memory_usage(usage, sizeof(usage), m->flags);
 
-	seq_printf(s, "%pK %pK %8zd %5d %6s %10s %16s %5d\n",
-			   (unsigned long *)(uintptr_t) m->gpuaddr,
-			   (unsigned long *) m->useraddr,
-				m->size, entry->id, flags,
-				memtype_str(entry->memtype), usage, m->sglen);
+	seq_printf(s, "%08x %08lx %8d %5d %5s %10s %16s %5d\n",
+			m->gpuaddr, m->useraddr, m->size, entry->id, flags,
+			memtype_str(entry->memtype), usage, m->sglen);
 }
 
 static int process_mem_print(struct seq_file *s, void *unused)
@@ -275,7 +272,7 @@
 	struct kgsl_process_private *private = s->private;
 	int next = 0;
 
-	seq_printf(s, "%8s %8s %8s %5s %6s %10s %16s %5s\n",
+	seq_printf(s, "%8s %8s %8s %5s %5s %10s %16s %5s\n",
 		   "gpuaddr", "useraddr", "size", "id", "flags", "type",
 		   "usage", "sglen");
 
@@ -304,36 +301,14 @@
 
 static int process_mem_open(struct inode *inode, struct file *file)
 {
-	struct kgsl_process_private *private = inode->i_private;
-
-	/*
-	 * Hold a reference count on the process while open
-	 * in case the process tries to die in the meantime.
-	 * If the process is already dying we cannot get a
-	 * refcount, print nothing.
-	 */
-
-	if (!private || !kgsl_process_private_get(private))
-		return -ENODEV;
-
-	return single_open(file, process_mem_print, private);
-}
-
-static int process_mem_release(struct inode *inode, struct file *file)
-{
-	struct kgsl_process_private *private = inode->i_private;
-
-	if (private)
-		kgsl_process_private_put(private);
-
-	return single_release(inode, file);
+	return single_open(file, process_mem_print, inode->i_private);
 }
 
 static const struct file_operations process_mem_fops = {
 	.open = process_mem_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = process_mem_release,
+	.release = single_release,
 };
 
 
@@ -375,7 +350,7 @@
 	 * So if debugfs is disabled in kernel, return as
 	 * success.
 	 */
-	dentry = debugfs_create_file("mem", 0444, private->debug_root, private,
+	dentry = debugfs_create_file("mem", 0400, private->debug_root, private,
 			    &process_mem_fops);
 
 	if (IS_ERR(dentry)) {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2011,2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,7 +35,7 @@
 static inline void kgsl_device_debugfs_init(struct kgsl_device *device) { }
 static inline void kgsl_core_debugfs_close(void) { }
 static inline struct dentry *kgsl_get_debugfs_dir(void) { return NULL; }
-static inline int kgsl_process_init_debugfs(struct kgsl_process_private *priv)
+static inline int kgsl_process_init_debugfs(struct kgsl_process_private *)
 {
 	return 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_device.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_device.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_device.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_device.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -127,8 +127,8 @@
 	void (*drawctxt_destroy) (struct kgsl_context *context);
 	long (*ioctl) (struct kgsl_device_private *dev_priv,
 		unsigned int cmd, void *data);
-	int (*setproperty) (struct kgsl_device_private *dev_priv,
-		enum kgsl_property_type type, void __user *value,
+	int (*setproperty) (struct kgsl_device *device,
+		enum kgsl_property_type type, void *value,
 		unsigned int sizebytes);
 	int (*postmortem_dump) (struct kgsl_device *device, int manual);
 	void (*drawctxt_sched)(struct kgsl_device *device,
@@ -311,6 +311,7 @@
 };
 
 void kgsl_process_events(struct work_struct *work);
+void kgsl_check_fences(struct work_struct *work);
 
 #define KGSL_DEVICE_COMMON_INIT(_dev) \
 	.hwaccess_gate = COMPLETION_INITIALIZER((_dev).hwaccess_gate),\
@@ -358,10 +359,6 @@
  * @pagefault: flag set if this context caused a pagefault.
  * @pagefault_ts: global timestamp of the pagefault, if KGSL_CONTEXT_PAGEFAULT
  * is set.
- * @flags: flags from userspace controlling the behavior of this context
- * @fault_count: number of times gpu hanged in last _context_throttle_time ms
- * @fault_time: time of the first gpu hang in last _context_throttle_time ms
- * @pwr_constraint: power constraint from userspace for this context
  */
 struct kgsl_context {
 	struct kref refcount;
@@ -377,29 +374,10 @@
 	struct list_head events;
 	struct list_head events_list;
 	unsigned int pagefault_ts;
-	unsigned int flags;
-	unsigned int fault_count;
-	unsigned long fault_time;
-	struct kgsl_pwr_constraint pwr_constraint;
 };
 
-/**
- * struct kgsl_process_private -  Private structure for a KGSL process (across
- * all devices)
- * @priv: Internal flags, use KGSL_PROCESS_* values
- * @pid: ID for the task owner of the process
- * @mem_lock: Spinlock to protect the process memory lists
- * @refcount: kref object for reference counting the process
- * @process_private_mutex: Mutex to synchronize access to the process struct
- * @mem_rb: RB tree node for the memory owned by this process
- * @idr: Iterator for assigning IDs to memory allocations
- * @pagetable: Pointer to the pagetable owned by this process
- * @kobj: Pointer to a kobj for the sysfs directory for this process
- * @debug_root: Pointer to the debugfs root for this process
- * @stats: Memory allocation statistics for this process
- */
 struct kgsl_process_private {
-	unsigned long priv;
+	unsigned int refcnt;
 	pid_t pid;
 	spinlock_t mem_lock;
 
@@ -421,14 +399,6 @@
 	} stats[KGSL_MEM_ENTRY_MAX];
 };
 
-/**
- * enum kgsl_process_priv_flags - Private flags for kgsl_process_private
- * @KGSL_PROCESS_INIT: Set if the process structure has been set up
- */
-enum kgsl_process_priv_flags {
-	KGSL_PROCESS_INIT = 0,
-};
-
 struct kgsl_device_private {
 	struct kgsl_device *device;
 	struct kgsl_process_private *process_priv;
@@ -661,7 +631,7 @@
  * Find the context associated with the given ID number, increase the reference
  * count on it and return it.  The caller must make sure that this call is
  * paired with a kgsl_context_put. This function validates that the context id
- * given is owned by the dev_priv instancet that is passed in.  See
+ * given is owned by the dev_priv instancet that is passed in.  see
  * kgsl_context_get for the internal version that doesn't do the check
  */
 static inline struct kgsl_context *kgsl_context_get_owner(
@@ -712,24 +682,6 @@
 void kgsl_cmdbatch_destroy_object(struct kref *kref);
 
 /**
-* kgsl_process_private_get() - increment the refcount on a kgsl_process_private
-*   struct
-* @process: Pointer to the KGSL process_private
-*
-* Returns 0 if the structure is invalid and a reference count could not be
-* obtained, nonzero otherwise.
-*/
-static inline int kgsl_process_private_get(struct kgsl_process_private *process)
-{
-	int ret = 0;
-	if (process != NULL)
-		ret = kref_get_unless_zero(&process->refcount);
-	return ret;
-}
-
-void kgsl_process_private_put(struct kgsl_process_private *private);
-
-/**
  * kgsl_cmdbatch_put() - Decrement the refcount for a command batch object
  * @cmdbatch: Pointer to the command batch object
  */
@@ -748,16 +700,7 @@
  */
 static inline int kgsl_cmdbatch_sync_pending(struct kgsl_cmdbatch *cmdbatch)
 {
-	int ret;
-
-	if (cmdbatch == NULL)
-		return 0;
-
-	spin_lock(&cmdbatch->lock);
-	ret = list_empty(&cmdbatch->synclist) ? 0 : 1;
-	spin_unlock(&cmdbatch->lock);
-
-	return ret;
+	return list_empty(&cmdbatch->synclist) ? 0 : 1;
 }
 
 #if defined(CONFIG_GPU_TRACEPOINTS)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_drm.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_drm.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_drm.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_drm.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -16,9 +16,7 @@
  */
 #include "drmP.h"
 #include "drm.h"
-
-#include <linux/msm_ion.h>
-#include <linux/genlock.h>
+#include <linux/android_pmem.h>
 
 #include "kgsl.h"
 #include "kgsl_device.h"
@@ -29,7 +27,7 @@
 #define DRIVER_AUTHOR           "Qualcomm"
 #define DRIVER_NAME             "kgsl"
 #define DRIVER_DESC             "KGSL DRM"
-#define DRIVER_DATE             "20121107"
+#define DRIVER_DATE             "20100127"
 
 #define DRIVER_MAJOR            2
 #define DRIVER_MINOR            1
@@ -108,7 +106,6 @@
 	uint32_t type;
 	struct kgsl_memdesc memdesc;
 	struct kgsl_pagetable *pagetable;
-	struct ion_handle *ion_handle;
 	uint64_t mmap_offset;
 	int bufcount;
 	int flags;
@@ -120,8 +117,6 @@
 		uint32_t gpuaddr;
 	} bufs[DRM_KGSL_GEM_MAX_BUFFERS];
 
-	struct genlock_handle *glock_handle[DRM_KGSL_GEM_MAX_BUFFERS];
-
 	int bound;
 	int lockpid;
 	/* Put these here to avoid allocing all the time */
@@ -134,18 +129,86 @@
 	struct list_head wait_list;
 };
 
-static struct ion_client *kgsl_drm_ion_client;
-
 static int kgsl_drm_inited = DRM_KGSL_NOT_INITED;
 
 /* This is a global list of all the memory currently mapped in the MMU */
 static struct list_head kgsl_mem_list;
 
+static void kgsl_gem_mem_flush(struct kgsl_memdesc *memdesc, int type, int op)
+{
+	int cacheop = 0;
+
+	switch (op) {
+	case DRM_KGSL_GEM_CACHE_OP_TO_DEV:
+		if (type & (DRM_KGSL_GEM_CACHE_WBACK |
+			    DRM_KGSL_GEM_CACHE_WBACKWA))
+			cacheop = KGSL_CACHE_OP_CLEAN;
+
+		break;
+
+	case DRM_KGSL_GEM_CACHE_OP_FROM_DEV:
+		if (type & (DRM_KGSL_GEM_CACHE_WBACK |
+			    DRM_KGSL_GEM_CACHE_WBACKWA |
+			    DRM_KGSL_GEM_CACHE_WTHROUGH))
+			cacheop = KGSL_CACHE_OP_INV;
+	}
+
+	kgsl_cache_range_op(memdesc, cacheop);
+}
+
+/* TODO:
+ * Add vsync wait */
+
+static int kgsl_drm_load(struct drm_device *dev, unsigned long flags)
+{
+	return 0;
+}
+
+static int kgsl_drm_unload(struct drm_device *dev)
+{
+	return 0;
+}
+
 struct kgsl_drm_device_priv {
 	struct kgsl_device *device[KGSL_DEVICE_MAX];
 	struct kgsl_device_private *devpriv[KGSL_DEVICE_MAX];
 };
 
+void kgsl_drm_preclose(struct drm_device *dev, struct drm_file *file_priv)
+{
+}
+
+static int kgsl_drm_suspend(struct drm_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int kgsl_drm_resume(struct drm_device *dev)
+{
+	return 0;
+}
+
+static void
+kgsl_gem_free_mmap_offset(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_kgsl_gem_object *priv = obj->driver_private;
+	struct drm_map_list *list;
+
+	list = &obj->map_list;
+	drm_ht_remove_item(&mm->offset_hash, &list->hash);
+	if (list->file_offset_node) {
+		drm_mm_put_block(list->file_offset_node);
+		list->file_offset_node = NULL;
+	}
+
+	kfree(list->map);
+	list->map = NULL;
+
+	priv->mmap_offset = 0;
+}
+
 static int
 kgsl_gem_memory_allocated(struct drm_gem_object *obj)
 {
@@ -156,10 +219,8 @@
 static int
 kgsl_gem_alloc_memory(struct drm_gem_object *obj)
 {
+    struct kgsl_mmu *mmu;
 	struct drm_kgsl_gem_object *priv = obj->driver_private;
-	struct kgsl_mmu *mmu;
-	struct sg_table *sg_table;
-	struct scatterlist *s;
 	int index;
 	int result = 0;
 
@@ -167,19 +228,11 @@
 
 	if (kgsl_gem_memory_allocated(obj) || TYPE_IS_FD(priv->type))
 		return 0;
-
-	if (priv->pagetable == NULL) {
-		/* Hard coded to use A2X device for MSM7X27 and MSM8625
-		 * Others to use A3X device
-		 */
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM8625)
-		mmu = &kgsl_get_device(KGSL_DEVICE_2D0)->mmu;
-#else
-		mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
-#endif
-
-		priv->pagetable = kgsl_mmu_getpagetable(mmu,
-					KGSL_MMU_GLOBAL_PT);
+    
+    mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
+	
+    if (priv->pagetable == NULL) {
+		priv->pagetable = kgsl_mmu_getpagetable(mmu, KGSL_MMU_GLOBAL_PT);
 
 		if (priv->pagetable == NULL) {
 			DRM_ERROR("Unable to get the GPU MMU pagetable\n");
@@ -190,62 +243,15 @@
 	if (TYPE_IS_PMEM(priv->type)) {
 		if (priv->type == DRM_KGSL_GEM_TYPE_EBI ||
 		    priv->type & DRM_KGSL_GEM_PMEM_EBI) {
-			priv->ion_handle = ion_alloc(kgsl_drm_ion_client,
-				obj->size * priv->bufcount, PAGE_SIZE,
-				ION_HEAP(ION_SF_HEAP_ID), 0);
-			if (IS_ERR_OR_NULL(priv->ion_handle)) {
-				DRM_ERROR(
-				"Unable to allocate ION Phys memory handle\n");
-				return -ENOMEM;
-			}
-
-			priv->memdesc.pagetable = priv->pagetable;
-
-			result = ion_phys(kgsl_drm_ion_client,
-				priv->ion_handle, (ion_phys_addr_t *)
-				&priv->memdesc.physaddr, &priv->memdesc.size);
-			if (result) {
-				DRM_ERROR(
-				"Unable to get ION Physical memory address\n");
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-
-			result = memdesc_sg_phys(&priv->memdesc,
-				priv->memdesc.physaddr, priv->memdesc.size);
-			if (result) {
-				DRM_ERROR(
-				"Unable to get sg list\n");
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-
-			result = kgsl_mmu_get_gpuaddr(priv->pagetable,
-							&priv->memdesc);
-			if (result) {
-				DRM_ERROR(
-				"kgsl_mmu_get_gpuaddr failed. result = %d\n",
-				result);
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-			result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-			if (result) {
-				DRM_ERROR(
-				"kgsl_mmu_map failed.  result = %d\n", result);
-				kgsl_mmu_put_gpuaddr(priv->pagetable,
-							&priv->memdesc);
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
+				result = kgsl_sharedmem_ebimem_user(
+						&priv->memdesc,
+						priv->pagetable,
+						obj->size * priv->bufcount);
+				if (result) {
+					DRM_ERROR(
+					"Unable to allocate PMEM memory\n");
+					return result;
+				}
 		}
 		else
 			return -EINVAL;
@@ -256,53 +262,33 @@
 			priv->type & DRM_KGSL_GEM_CACHE_MASK)
 				list_add(&priv->list, &kgsl_mem_list);
 
-		priv->memdesc.pagetable = priv->pagetable;
-
-		priv->ion_handle = ion_alloc(kgsl_drm_ion_client,
-				obj->size * priv->bufcount, PAGE_SIZE,
-				ION_HEAP(ION_IOMMU_HEAP_ID), 0);
-		if (IS_ERR_OR_NULL(priv->ion_handle)) {
-			DRM_ERROR(
-				"Unable to allocate ION IOMMU memory handle\n");
-				return -ENOMEM;
-		}
-
-		sg_table = ion_sg_table(kgsl_drm_ion_client,
-				priv->ion_handle);
-		if (IS_ERR_OR_NULL(priv->ion_handle)) {
-			DRM_ERROR(
-			"Unable to get ION sg table\n");
-			goto memerr;
-		}
-
-		priv->memdesc.sg = sg_table->sgl;
-
-		/* Calculate the size of the memdesc from the sglist */
-
-		priv->memdesc.sglen = 0;
-
-		for (s = priv->memdesc.sg; s != NULL; s = sg_next(s)) {
-			priv->memdesc.size += s->length;
-			priv->memdesc.sglen++;
-		}
+		result = kgsl_sharedmem_page_alloc_user(&priv->memdesc,
+					priv->pagetable,
+					obj->size * priv->bufcount);
 
-		result = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
-		if (result) {
-			DRM_ERROR(
-			"kgsl_mmu_get_gpuaddr failed.  result = %d\n", result);
-			goto memerr;
-		}
-		result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-		if (result) {
-			DRM_ERROR(
-			"kgsl_mmu_map failed.  result = %d\n", result);
-			kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
-			goto memerr;
+		if (result != 0) {
+				DRM_ERROR(
+				"Unable to allocate Vmalloc user memory\n");
+				return result;
 		}
-
 	} else
 		return -EINVAL;
 
+	/* TODO would be good to cleanup in the error paths, but right now I
+	 * just need it to work enough to run some simple tests..
+	 */
+	result = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
+	if (result) {
+		DRM_ERROR("kgsl_mmu_get_gpuaddr failed.  result = %d\n", result);
+		return result;
+	}
+	result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
+	if (result) {
+		DRM_ERROR("kgsl_mmu_map failed.  result = %d\n", result);
+		kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
+		return result;
+	}
+
 	for (index = 0; index < priv->bufcount; index++) {
 		priv->bufs[index].offset = index * obj->size;
 		priv->bufs[index].gpuaddr =
@@ -311,46 +297,21 @@
 	}
 	priv->flags |= DRM_KGSL_GEM_FLAG_MAPPED;
 
-
 	return 0;
-
-memerr:
-	ion_free(kgsl_drm_ion_client,
-		priv->ion_handle);
-	priv->ion_handle = NULL;
-	return -ENOMEM;
-
 }
 
 static void
 kgsl_gem_free_memory(struct drm_gem_object *obj)
 {
 	struct drm_kgsl_gem_object *priv = obj->driver_private;
-	int index;
 
 	if (!kgsl_gem_memory_allocated(obj) || TYPE_IS_FD(priv->type))
 		return;
 
-	if (priv->memdesc.gpuaddr) {
-		kgsl_mmu_unmap(priv->memdesc.pagetable, &priv->memdesc);
-		kgsl_mmu_put_gpuaddr(priv->memdesc.pagetable, &priv->memdesc);
-	}
-
-	/* ION will take care of freeing the sg table. */
-	priv->memdesc.sg = NULL;
-	priv->memdesc.sglen = 0;
-
-	if (priv->ion_handle)
-		ion_free(kgsl_drm_ion_client, priv->ion_handle);
-
-	priv->ion_handle = NULL;
-
-	memset(&priv->memdesc, 0, sizeof(priv->memdesc));
+	kgsl_gem_mem_flush(&priv->memdesc,  priv->type,
+			   DRM_KGSL_GEM_CACHE_OP_FROM_DEV);
 
-	for (index = 0; index < priv->bufcount; index++) {
-		if (priv->glock_handle[index])
-			genlock_put_handle(priv->glock_handle[index]);
-	}
+	kgsl_sharedmem_free(&priv->memdesc);
 
 	kgsl_mmu_putpagetable(priv->pagetable);
 	priv->pagetable = NULL;
@@ -383,10 +344,66 @@
 kgsl_gem_free_object(struct drm_gem_object *obj)
 {
 	kgsl_gem_free_memory(obj);
+	kgsl_gem_free_mmap_offset(obj);
 	drm_gem_object_release(obj);
 	kfree(obj->driver_private);
 }
 
+static int
+kgsl_gem_create_mmap_offset(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_kgsl_gem_object *priv = obj->driver_private;
+	struct drm_map_list *list;
+	int msize;
+
+	list = &obj->map_list;
+	list->map = kzalloc(sizeof(struct drm_map_list), GFP_KERNEL);
+	if (list->map == NULL) {
+		DRM_ERROR("Unable to allocate drm_map_list\n");
+		return -ENOMEM;
+	}
+
+	msize = obj->size * priv->bufcount;
+
+	list->map->type = _DRM_GEM;
+	list->map->size = msize;
+	list->map->handle = obj;
+
+	/* Allocate a mmap offset */
+	list->file_offset_node = drm_mm_search_free(&mm->offset_manager,
+						    msize / PAGE_SIZE,
+						    0, 0);
+
+	if (!list->file_offset_node) {
+		DRM_ERROR("Failed to allocate offset for %d\n", obj->name);
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	list->file_offset_node = drm_mm_get_block(list->file_offset_node,
+						  msize / PAGE_SIZE, 0);
+
+	if (!list->file_offset_node) {
+		DRM_ERROR("Unable to create the file_offset_node\n");
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	list->hash.key = list->file_offset_node->start;
+	if (drm_ht_insert_item(&mm->offset_hash, &list->hash)) {
+		DRM_ERROR("Failed to add to map hash\n");
+		drm_mm_put_block(list->file_offset_node);
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	priv->mmap_offset = ((uint64_t) list->hash.key) << PAGE_SHIFT;
+
+	return 0;
+}
+
 int
 kgsl_gem_obj_addr(int drm_fd, int handle, unsigned long *start,
 			unsigned long *len)
@@ -433,6 +450,9 @@
 			priv->bufs[priv->active].offset;
 
 		*len = priv->memdesc.size;
+
+		kgsl_gem_mem_flush(&priv->memdesc,
+				   priv->type, DRM_KGSL_GEM_CACHE_OP_TO_DEV);
 	} else {
 		*start = 0;
 		*len = 0;
@@ -463,7 +483,10 @@
 	priv->active = 0;
 	priv->bound = 0;
 
-	priv->type = DRM_KGSL_GEM_TYPE_KMEM;
+	/* To preserve backwards compatability, the default memory source
+	   is EBI */
+
+	priv->type = DRM_KGSL_GEM_TYPE_PMEM | DRM_KGSL_GEM_PMEM_EBI;
 
 	ret = drm_gem_handle_create(file_priv, obj, handle);
 
@@ -505,11 +528,8 @@
 	}
 
 	ret = kgsl_gem_init_obj(dev, file_priv, obj, &handle);
-	if (ret) {
-		drm_gem_object_release(obj);
-		DRM_ERROR("Unable to initialize GEM object ret = %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	create->handle = handle;
 	return 0;
@@ -582,167 +602,6 @@
 }
 
 int
-kgsl_gem_create_from_ion_ioctl(struct drm_device *dev, void *data,
-		      struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_create_from_ion *args = data;
-	struct drm_gem_object *obj;
-	struct ion_handle *ion_handle;
-	struct drm_kgsl_gem_object *priv;
-	struct sg_table *sg_table;
-	struct scatterlist *s;
-	int ret, handle;
-	unsigned long size;
-	struct kgsl_mmu *mmu;
-
-	ion_handle = ion_import_dma_buf(kgsl_drm_ion_client, args->ion_fd);
-	if (IS_ERR_OR_NULL(ion_handle)) {
-		DRM_ERROR("Unable to import dmabuf.  Error number = %d\n",
-			(int)PTR_ERR(ion_handle));
-		return -EINVAL;
-	}
-
-	ion_handle_get_size(kgsl_drm_ion_client, ion_handle, &size);
-
-	if (size == 0) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		DRM_ERROR(
-		"cannot create GEM object from zero size ION buffer\n");
-		return -EINVAL;
-	}
-
-	obj = drm_gem_object_alloc(dev, size);
-
-	if (obj == NULL) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		DRM_ERROR("Unable to allocate the GEM object\n");
-		return -ENOMEM;
-	}
-
-	ret = kgsl_gem_init_obj(dev, file_priv, obj, &handle);
-	if (ret) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		drm_gem_object_release(obj);
-		DRM_ERROR("Unable to initialize GEM object ret = %d\n", ret);
-		return ret;
-	}
-
-	priv = obj->driver_private;
-	priv->ion_handle = ion_handle;
-
-	priv->type = DRM_KGSL_GEM_TYPE_KMEM;
-	list_add(&priv->list, &kgsl_mem_list);
-
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM8625)
-	mmu = &kgsl_get_device(KGSL_DEVICE_2D0)->mmu;
-#else
-	mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
-#endif
-
-	priv->pagetable = kgsl_mmu_getpagetable(mmu, KGSL_MMU_GLOBAL_PT);
-
-	priv->memdesc.pagetable = priv->pagetable;
-
-	sg_table = ion_sg_table(kgsl_drm_ion_client,
-		priv->ion_handle);
-	if (IS_ERR_OR_NULL(priv->ion_handle)) {
-		DRM_ERROR("Unable to get ION sg table\n");
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-
-	priv->memdesc.sg = sg_table->sgl;
-
-	/* Calculate the size of the memdesc from the sglist */
-
-	priv->memdesc.sglen = 0;
-
-	for (s = priv->memdesc.sg; s != NULL; s = sg_next(s)) {
-		priv->memdesc.size += s->length;
-		priv->memdesc.sglen++;
-	}
-
-	ret = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
-	if (ret) {
-		DRM_ERROR("kgsl_mmu_get_gpuaddr failed.  ret = %d\n", ret);
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-	ret = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-	if (ret) {
-		DRM_ERROR("kgsl_mmu_map failed.  ret = %d\n", ret);
-		kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-
-	priv->bufs[0].offset = 0;
-	priv->bufs[0].gpuaddr = priv->memdesc.gpuaddr;
-	priv->flags |= DRM_KGSL_GEM_FLAG_MAPPED;
-
-	args->handle = handle;
-	return 0;
-}
-
-int
-kgsl_gem_get_ion_fd_ioctl(struct drm_device *dev, void *data,
-			struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_get_ion_fd *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int ret = 0;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	if (TYPE_IS_FD(priv->type))
-		ret = -EINVAL;
-	else if (TYPE_IS_PMEM(priv->type) || TYPE_IS_MEM(priv->type)) {
-		if (priv->ion_handle) {
-			args->ion_fd = ion_share_dma_buf_fd(
-				kgsl_drm_ion_client, priv->ion_handle);
-			if (args->ion_fd < 0) {
-				DRM_ERROR(
-				"Could not share ion buffer. Error = %d\n",
-					args->ion_fd);
-				ret = -EINVAL;
-			}
-		} else {
-			DRM_ERROR("GEM object has no ion memory allocated.\n");
-			ret = -EINVAL;
-		}
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return ret;
-}
-
-int
 kgsl_gem_setmemtype_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv)
 {
@@ -841,9 +700,13 @@
 
 	if (ret) {
 		DRM_ERROR("Unable to allocate object memory\n");
+	} else if (!priv->mmap_offset) {
+		ret = kgsl_gem_create_mmap_offset(obj);
+		if (ret)
+			DRM_ERROR("Unable to create a mmap offset\n");
 	}
 
-	args->offset = 0;
+	args->offset = priv->mmap_offset;
 
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
@@ -855,7 +718,33 @@
 kgsl_gem_mmap_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv)
 {
-	/* Ion is used for mmap at this time */
+	struct drm_kgsl_gem_mmap *args = data;
+	struct drm_gem_object *obj;
+	unsigned long addr;
+
+	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
+
+	if (obj == NULL) {
+		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
+		return -EBADF;
+	}
+
+	down_write(&current->mm->mmap_sem);
+
+	addr = do_mmap(obj->filp, 0, args->size,
+		       PROT_READ | PROT_WRITE, MAP_SHARED,
+		       args->offset);
+
+	up_write(&current->mm->mmap_sem);
+
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+
+	if (IS_ERR((void *) addr))
+		return addr;
+
+	args->hostptr = (uint32_t) addr;
 	return 0;
 }
 
@@ -888,6 +777,18 @@
 		return ret;
 	}
 
+	if (priv->mmap_offset == 0) {
+		ret = kgsl_gem_create_mmap_offset(obj);
+		if (ret) {
+			drm_gem_object_unreference(obj);
+			mutex_unlock(&dev->struct_mutex);
+			return ret;
+		}
+	}
+
+	args->offset = priv->mmap_offset;
+	args->phys = priv->memdesc.physaddr;
+
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
@@ -914,11 +815,6 @@
 	mutex_lock(&dev->struct_mutex);
 	priv = obj->driver_private;
 
-	if (!kgsl_gem_memory_allocated(obj)) {
-		DRM_ERROR("Memory not allocated for this object\n");
-		goto out;
-	}
-
 	for (index = 0; index < priv->bufcount; index++) {
 		args->offset[index] = priv->bufs[index].offset;
 		args->gpuaddr[index] = priv->bufs[index].gpuaddr;
@@ -929,75 +825,12 @@
 
 	ret = 0;
 
-out:
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
 	return ret;
 }
 
-/* Get the genlock handles base off the GEM handle
- */
-
-int
-kgsl_gem_get_glock_handles_ioctl(struct drm_device *dev, void *data,
-					struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_glockinfo *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int index;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	for (index = 0; index < priv->bufcount; index++) {
-		args->glockhandle[index] = genlock_get_fd_handle(
-						priv->glock_handle[index]);
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-	return 0;
-}
-
-int
-kgsl_gem_set_glock_handles_ioctl(struct drm_device *dev, void *data,
-					struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_glockinfo *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int index;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	for (index = 0; index < priv->bufcount; index++) {
-		priv->glock_handle[index] = genlock_get_handle_fd(
-						args->glockhandle[index]);
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return 0;
-}
-
 int
 kgsl_gem_set_bufcount_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
@@ -1040,32 +873,6 @@
 }
 
 int
-kgsl_gem_get_bufcount_ioctl(struct drm_device *dev, void *data,
-			  struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_bufcount *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	args->bufcount =  priv->bufcount;
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return 0;
-}
-
-int
 kgsl_gem_set_active_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
@@ -1084,15 +891,9 @@
 	mutex_lock(&dev->struct_mutex);
 	priv = obj->driver_private;
 
-	if (args->active < 0 || args->active >= priv->bufcount) {
-		DRM_ERROR("Invalid active buffer %d\n", args->active);
-		goto out;
-	}
-
 	priv->active = args->active;
 	ret = 0;
 
-out:
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
@@ -1159,6 +960,122 @@
 	}
 }
 
+static struct vm_operations_struct kgsl_gem_kmem_vm_ops = {
+	.fault = kgsl_gem_kmem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static struct vm_operations_struct kgsl_gem_phys_vm_ops = {
+	.fault = kgsl_gem_phys_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+/* This is a clone of the standard drm_gem_mmap function modified to allow
+   us to properly map KMEM regions as well as the PMEM regions */
+
+int msm_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->minor->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_local_map *map = NULL;
+	struct drm_gem_object *obj;
+	struct drm_hash_item *hash;
+	struct drm_kgsl_gem_object *gpriv;
+	int ret = 0;
+
+	mutex_lock(&dev->struct_mutex);
+
+	if (drm_ht_find_item(&mm->offset_hash, vma->vm_pgoff, &hash)) {
+		mutex_unlock(&dev->struct_mutex);
+		return drm_mmap(filp, vma);
+	}
+
+	map = drm_hash_entry(hash, struct drm_map_list, hash)->map;
+	if (!map ||
+	    ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN))) {
+		ret =  -EPERM;
+		goto out_unlock;
+	}
+
+	/* Check for valid size. */
+	if (map->size < vma->vm_end - vma->vm_start) {
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	obj = map->handle;
+
+	gpriv = obj->driver_private;
+
+	/* VM_PFNMAP is only for memory that doesn't use struct page
+	 * in other words, not "normal" memory.  If you try to use it
+	 * with "normal" memory then the mappings don't get flushed. */
+
+	if (TYPE_IS_MEM(gpriv->type)) {
+		vma->vm_flags |= VM_RESERVED | VM_DONTEXPAND;
+		vma->vm_ops = &kgsl_gem_kmem_vm_ops;
+	} else {
+		vma->vm_flags |= VM_RESERVED | VM_IO | VM_PFNMAP |
+			VM_DONTEXPAND;
+		vma->vm_ops = &kgsl_gem_phys_vm_ops;
+	}
+
+	vma->vm_private_data = map->handle;
+
+
+	/* Take care of requested caching policy */
+	if (gpriv->type == DRM_KGSL_GEM_TYPE_KMEM ||
+	    gpriv->type & DRM_KGSL_GEM_CACHE_MASK) {
+		if (gpriv->type & DRM_KGSL_GEM_CACHE_WBACKWA)
+			vma->vm_page_prot =
+			pgprot_writebackwacache(vma->vm_page_prot);
+		else if (gpriv->type & DRM_KGSL_GEM_CACHE_WBACK)
+				vma->vm_page_prot =
+				pgprot_writebackcache(vma->vm_page_prot);
+		else if (gpriv->type & DRM_KGSL_GEM_CACHE_WTHROUGH)
+				vma->vm_page_prot =
+				pgprot_writethroughcache(vma->vm_page_prot);
+		else
+			vma->vm_page_prot =
+			pgprot_writecombine(vma->vm_page_prot);
+	} else {
+		if (gpriv->type == DRM_KGSL_GEM_TYPE_KMEM_NOCACHE)
+			vma->vm_page_prot =
+			pgprot_noncached(vma->vm_page_prot);
+		else
+			/* default pmem is WC */
+			vma->vm_page_prot =
+			pgprot_writecombine(vma->vm_page_prot);
+	}
+
+	/* flush out existing KMEM cached mappings if new ones are
+	 * of uncached type */
+	if (IS_MEM_UNCACHED(gpriv->type))
+		kgsl_cache_range_op(&gpriv->memdesc,
+				    KGSL_CACHE_OP_FLUSH);
+
+	/* Add the other memory types here */
+
+	/* Take a ref for this mapping of the object, so that the fault
+	 * handler can dereference the mmap offset's pointer to the object.
+	 * This reference is cleaned up by the corresponding vm_close
+	 * (which should happen whether the vma was created by this call, or
+	 * by a vm_open due to mremap or partial unmap or whatever).
+	 */
+	drm_gem_object_reference(obj);
+
+	vma->vm_file = filp;	/* Needed for drm_vm_open() */
+	drm_vm_open_locked(vma);
+
+out_unlock:
+	mutex_unlock(&dev->struct_mutex);
+
+	return ret;
+}
+
 void
 cleanup_fence(struct drm_kgsl_gem_object_fence *fence, int check_waiting)
 {
@@ -1520,17 +1437,8 @@
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_ALLOC, kgsl_gem_alloc_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_MMAP, kgsl_gem_mmap_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_BUFINFO, kgsl_gem_get_bufinfo_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_ION_FD, kgsl_gem_get_ion_fd_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_CREATE_FROM_ION,
-				kgsl_gem_create_from_ion_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_BUFCOUNT,
-				kgsl_gem_set_bufcount_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_BUFCOUNT,
-				kgsl_gem_get_bufcount_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_GLOCK_HANDLES_INFO,
-				kgsl_gem_set_glock_handles_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_GLOCK_HANDLES_INFO,
-				kgsl_gem_get_glock_handles_ioctl, 0),
+		      kgsl_gem_set_bufcount_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_ACTIVE, kgsl_gem_set_active_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_LOCK_HANDLE,
 				  kgsl_gem_lock_handle_ioctl, 0),
@@ -1542,22 +1450,30 @@
 		      DRM_MASTER),
 };
 
-static const struct file_operations kgsl_drm_driver_fops = {
-	.owner = THIS_MODULE,
-	.open = drm_open,
-	.release = drm_release,
-	.unlocked_ioctl = drm_ioctl,
-	.mmap = drm_gem_mmap,
-	.poll = drm_poll,
-	.fasync = drm_fasync,
+static const const struct file_operations fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.unlocked_ioctl = drm_ioctl,
+		.mmap = msm_drm_gem_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
 };
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_GEM,
+	.load = kgsl_drm_load,
+	.unload = kgsl_drm_unload,
+	.preclose = kgsl_drm_preclose,
+	.suspend = kgsl_drm_suspend,
+	.resume = kgsl_drm_resume,
+	.reclaim_buffers = drm_core_reclaim_buffers,
 	.gem_init_object = kgsl_gem_init_object,
 	.gem_free_object = kgsl_gem_free_object,
 	.ioctls = kgsl_drm_ioctls,
-	.fops = &kgsl_drm_driver_fops,
+
+	.fops = &fops,
+
 	.name = DRIVER_NAME,
 	.desc = DRIVER_DESC,
 	.date = DRIVER_DATE,
@@ -1586,24 +1502,11 @@
 		gem_buf_fence[i].fence_id = ENTRY_EMPTY;
 	}
 
-	/* Create ION Client */
-	kgsl_drm_ion_client = msm_ion_client_create(
-			0xffffffff, "kgsl_drm");
-	if (!kgsl_drm_ion_client) {
-		DRM_ERROR("Unable to create ION client\n");
-		return -ENOMEM;
-	}
-
 	return drm_platform_init(&driver, dev);
 }
 
 void kgsl_drm_exit(void)
 {
 	kgsl_drm_inited = DRM_KGSL_NOT_INITED;
-
-	if (kgsl_drm_ion_client)
-		ion_client_destroy(kgsl_drm_ion_client);
-	kgsl_drm_ion_client = NULL;
-
 	drm_platform_exit(&driver, driver.kdriver.platform_device);
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_events.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_events.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_events.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_events.c	2014-09-21 01:02:11.000000000 +0000
@@ -211,8 +211,10 @@
 	kgsl_event_func func, void *priv, void *owner)
 {
 	struct kgsl_event *event;
-	unsigned int queued = 0, cur_ts;
+	unsigned int cur_ts;
 	struct kgsl_context *context = NULL;
+	struct adreno_context *drawctxt;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
@@ -223,23 +225,16 @@
 		context = kgsl_context_get(device, id);
 		if (context == NULL)
 			return -EINVAL;
-	}
-	/*
-	 * If the caller is creating their own timestamps, let them schedule
-	 * events in the future. Otherwise only allow timestamps that have been
-	 * queued.
-	 */
-	if (context == NULL ||
-		((context->flags & KGSL_CONTEXT_USER_GENERATED_TS) == 0)) {
-		queued = kgsl_readtimestamp(device, context,
-			KGSL_TIMESTAMP_QUEUED);
-
-		if (timestamp_cmp(ts, queued) > 0) {
+		/* Do not allow registering of event with invalid timestamp */
+		drawctxt = ADRENO_CONTEXT(context);
+		if (timestamp_cmp(ts, drawctxt->timestamp) > 0) {
 			kgsl_context_put(context);
 			return -EINVAL;
 		}
+	} else {
+		if (timestamp_cmp(ts, adreno_dev->ringbuffer.global_ts) > 0)
+			return -EINVAL;
 	}
-
 	cur_ts = kgsl_readtimestamp(device, context, KGSL_TIMESTAMP_RETIRED);
 
 	/*
@@ -338,11 +333,7 @@
 		void *priv)
 {
 	struct kgsl_event *event;
-	struct list_head *head;
-
-	BUG_ON(!mutex_is_locked(&device->mutex));
-
-	head = _get_list_head(device, context);
+	struct list_head *head = _get_list_head(device, context);
 
 	event = _find_event(device, head, timestamp, func, priv);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_gpummu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_gpummu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_gpummu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_gpummu.c	2014-09-21 01:02:11.000000000 +0000
@@ -23,7 +23,6 @@
 #include "kgsl_device.h"
 #include "kgsl_sharedmem.h"
 #include "kgsl_trace.h"
-#include "adreno.h"
 
 #define KGSL_PAGETABLE_SIZE \
 	ALIGN(KGSL_PAGETABLE_ENTRIES(CONFIG_MSM_KGSL_PAGE_TABLE_SIZE) * \
@@ -404,22 +403,11 @@
 {
 	unsigned int reg;
 	unsigned int ptbase;
-	struct kgsl_device *device;
-	struct adreno_device *adreno_dev;
-	unsigned int no_page_fault_log = 0;
 
-	device = mmu->device;
-	adreno_dev = ADRENO_DEVICE(device);
+	kgsl_regread(mmu->device, MH_MMU_PAGE_FAULT, &reg);
+	kgsl_regread(mmu->device, MH_MMU_PT_BASE, &ptbase);
 
-	kgsl_regread(device, MH_MMU_PAGE_FAULT, &reg);
-	kgsl_regread(device, MH_MMU_PT_BASE, &ptbase);
-
-
-	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE)
-		no_page_fault_log = kgsl_mmu_log_fault_addr(mmu, ptbase, reg);
-
-	if (!no_page_fault_log)
-		KGSL_MEM_CRIT(mmu->device,
+	KGSL_MEM_CRIT(mmu->device,
 			"mmu page fault: page=0x%lx pt=%d op=%s axi=%d\n",
 			reg & ~(PAGE_SIZE - 1),
 			kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase),
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.c	2014-09-21 01:02:11.000000000 +0000
@@ -42,13 +42,12 @@
 	{ 0x10, 1 },			/* TTBR0 */
 	{ 0x14, 1 },			/* TTBR1 */
 	{ 0x20, 1 },			/* FSR */
-	{ 0x28, 1 },			/* FAR */
 	{ 0x800, 1 },			/* TLBIALL */
 	{ 0x820, 1 },			/* RESUME */
 	{ 0x03C, 1 },			/* TLBLKCR */
 	{ 0x818, 1 },			/* V2PUR */
 	{ 0x2C, 1 },			/* FSYNR0 */
-	{ 0x30, 1 },			/* FSYNR1 */
+	{ 0x30, 1 },			/* FSYNR0 */
 	{ 0, 0 },			/* TLBSYNC, not in v0 */
 	{ 0, 0 },			/* TLBSTATUS, not in v0 */
 	{ 0, 0 }			/* IMPLDEF_MICRO_MMU_CRTL, not in v0 */
@@ -60,7 +59,6 @@
 	{ 0x20, 1 },			/* TTBR0 */
 	{ 0x28, 1 },			/* TTBR1 */
 	{ 0x58, 1 },			/* FSR */
-	{ 0x60, 1 },			/* FAR_0 */
 	{ 0x618, 1 },			/* TLBIALL */
 	{ 0x008, 1 },			/* RESUME */
 	{ 0, 0 },			/* TLBLKCR not in V1 */
@@ -73,21 +71,14 @@
 };
 
 /* naming mismatch with iommu things */
-static int kgsl_iommu_default_setstate(struct kgsl_mmu *mmu,
-		uint32_t flags);
-static phys_addr_t
-kgsl_iommu_get_current_ptbase(struct kgsl_mmu *mmu);
-
 static void _iommu_lock(void)
 {
-	msm_iommu_lock();
 	return;
 }
 
 /* naming mismatch with iommu things */
 static void _iommu_unlock(void)
 {
-	msm_iommu_unlock();
 	return;
 }
 
@@ -326,13 +317,13 @@
 	struct kgsl_iommu_unit *iommu_unit;
 	struct kgsl_iommu_device *iommu_dev;
 	unsigned int ptbase, fsr;
-	unsigned int pid;
-	struct _mem_entry prev, next;
-	unsigned int fsynr0, fsynr1;
-	int write;
 	struct kgsl_device *device;
 	struct adreno_device *adreno_dev;
 	unsigned int no_page_fault_log = 0;
+	unsigned int pid;
+	unsigned int fsynr0, fsynr1;
+	int write;
+	struct _mem_entry prev, next;
 	unsigned int curr_context_id = 0;
 	unsigned int curr_global_ts = 0;
 	struct kgsl_context *context;
@@ -343,13 +334,11 @@
 
 	device = mmu->device;
 	adreno_dev = ADRENO_DEVICE(device);
-	/*
-	 * If mmu fault not set then set it and continue else
-	 * exit this function since another thread has already set
-	 * it and will execute rest of this function for the fault.
-	 */
-	if (1 == atomic_cmpxchg(&mmu->fault, 0, 1))
+	if (atomic_read(&mmu->fault)) {
+		if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
+			ret = -EBUSY;
 		goto done;
+	}
 
 	iommu_dev = get_iommu_device(iommu_unit, dev);
 	if (!iommu_dev) {
@@ -359,16 +348,6 @@
 	}
 	iommu = mmu->priv;
 
-	fsr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
-		iommu_dev->ctx_id, FSR);
-	/*
-	 * If fsr is not set then it means that we cleared the fault while the
-	 * bottom half called from IOMMU driver is running
-	 */
-	if (!fsr) {
-		atomic_set(&mmu->fault, 0);
-		goto done;
-	}
 	/*
 	 * set the fault bits and stuff before any printks so that if fault
 	 * handler runs then it will know it's dealing with a pagefault
@@ -391,6 +370,7 @@
 		context = NULL;
 	}
 
+	atomic_set(&mmu->fault, 1);
 	iommu_dev->fault = 1;
 
 	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE) {
@@ -400,15 +380,17 @@
 		adreno_dispatcher_schedule(device);
 	}
 
-	ptbase = KGSL_IOMMU_GET_CTX_REG_LL(iommu, iommu_unit,
+	ptbase = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 					iommu_dev->ctx_id, TTBR0);
 
+	fsr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
+		iommu_dev->ctx_id, FSR);
 	fsynr0 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 		iommu_dev->ctx_id, FSYNR0);
 	fsynr1 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 		iommu_dev->ctx_id, FSYNR1);
 
-	if (msm_soc_version_supports_iommu_v1())
+	if (!msm_soc_version_supports_iommu_v1())
 		write = ((fsynr1 & (KGSL_IOMMU_FSYNR1_AWRITE_MASK <<
 			KGSL_IOMMU_FSYNR1_AWRITE_SHIFT)) ? 1 : 0);
 	else
@@ -445,7 +427,6 @@
 			_print_entry(iommu_dev->kgsldev, &next);
 		else
 			KGSL_LOG_DUMP(iommu_dev->kgsldev, "*EMPTY*\n");
-
 	}
 
 	trace_kgsl_mmu_pagefault(iommu_dev->kgsldev, addr,
@@ -467,29 +448,30 @@
 /*
  * kgsl_iommu_disable_clk - Disable iommu clocks
  * @mmu - Pointer to mmu structure
- * @unit - Iommu unit
  *
- * Disables iommu clocks for an iommu unit
+ * Disables iommu clocks
  * Return - void
  */
-static void kgsl_iommu_disable_clk(struct kgsl_mmu *mmu, int unit)
+static void kgsl_iommu_disable_clk(struct kgsl_mmu *mmu)
 {
 	struct kgsl_iommu *iommu = mmu->priv;
+	struct msm_iommu_drvdata *iommu_drvdata;
 	int i, j;
 
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-
-		/* Turn off the clks for IOMMU unit requested */
-		if ((unit != i) && (unit != KGSL_IOMMU_MAX_UNITS))
-			continue;
-
-		atomic_dec(&iommu_unit->clk_enable_count);
-		BUG_ON(atomic_read(&iommu_unit->clk_enable_count) < 0);
-
-		for (j = (KGSL_IOMMU_MAX_CLKS - 1); j >= 0; j--)
-			if (iommu_unit->clks[j])
-				clk_disable_unprepare(iommu_unit->clks[j]);
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			if (!iommu_unit->dev[j].clk_enabled)
+				continue;
+			iommu_drvdata = dev_get_drvdata(
+					iommu_unit->dev[j].dev->parent);
+			if (iommu_drvdata->aclk)
+				clk_disable_unprepare(iommu_drvdata->aclk);
+			if (iommu_drvdata->clk)
+				clk_disable_unprepare(iommu_drvdata->clk);
+			clk_disable_unprepare(iommu_drvdata->pclk);
+			iommu_unit->dev[j].clk_enabled = false;
+		}
 	}
 }
 
@@ -509,12 +491,32 @@
 					unsigned int id, unsigned int ts,
 					u32 type)
 {
-	struct kgsl_iommu_disable_clk_param *param = data;
+	struct kgsl_mmu *mmu = data;
+	struct kgsl_iommu *iommu = mmu->priv;
 
-	kgsl_iommu_disable_clk(param->mmu, param->unit);
+	if (!iommu->clk_event_queued) {
+		if (0 > timestamp_cmp(ts, iommu->iommu_last_cmd_ts))
+			KGSL_DRV_ERR(device,
+			"IOMMU disable clock event being cancelled, "
+			"iommu_last_cmd_ts: %x, retired ts: %x\n",
+			iommu->iommu_last_cmd_ts, ts);
+		return;
+	}
 
-	/* Free param we are done using it */
-	kfree(param);
+	if (0 <= timestamp_cmp(ts, iommu->iommu_last_cmd_ts)) {
+		kgsl_iommu_disable_clk(mmu);
+		iommu->clk_event_queued = false;
+	} else {
+		/* add new event to fire when ts is reached, this can happen
+		 * if we queued an event and someone requested the clocks to
+		 * be disbaled on a later timestamp */
+		if (kgsl_add_event(device, id, iommu->iommu_last_cmd_ts,
+			kgsl_iommu_clk_disable_event, mmu, mmu)) {
+				KGSL_DRV_ERR(device,
+				"Failed to add IOMMU disable clk event\n");
+				iommu->clk_event_queued = false;
+		}
+	}
 }
 
 /*
@@ -524,7 +526,6 @@
  * @ts_valid - Indicates whether ts parameter is valid, if this parameter
  * is false then it means that the calling function wants to disable the
  * IOMMU clocks immediately without waiting for any timestamp
- * @unit: IOMMU unit for which clocks are to be turned off
  *
  * Creates an event to disable the IOMMU clocks on timestamp and if event
  * already exists then updates the timestamp of disabling the IOMMU clocks
@@ -533,88 +534,84 @@
  * Return - void
  */
 static void
-kgsl_iommu_disable_clk_on_ts(struct kgsl_mmu *mmu,
-				unsigned int ts, int unit)
-{
-	struct kgsl_iommu_disable_clk_param *param;
-
-	param = kzalloc(sizeof(*param), GFP_KERNEL);
-	if (!param) {
-		KGSL_CORE_ERR("kzalloc(%d) failed\n", sizeof(*param));
-		return;
-	}
-	param->mmu = mmu;
-	param->unit = unit;
-	param->ts = ts;
-
-	if (kgsl_add_event(mmu->device, KGSL_MEMSTORE_GLOBAL,
-			ts, kgsl_iommu_clk_disable_event, param, mmu)) {
-		KGSL_DRV_ERR(mmu->device,
-			"Failed to add IOMMU disable clk event\n");
-		kfree(param);
-	}
-}
-
-/*
- * kgsl_iommu_enable_clk_prepare_enable - Enable iommu clock
- * @clk - clock to enable
- *
- * Prepare enables clock. Retries 3 times on enable failure, on 4th failure
- * returns an error.
- * Return: 0 on success else 1 on error
- */
-
-static int kgsl_iommu_clk_prepare_enable(struct clk *clk)
+kgsl_iommu_disable_clk_on_ts(struct kgsl_mmu *mmu, unsigned int ts,
+				bool ts_valid)
 {
-	int num_retries = 4;
+	struct kgsl_iommu *iommu = mmu->priv;
 
-	while (num_retries--) {
-		if (!clk_prepare_enable(clk))
-			return 0;
+	if (iommu->clk_event_queued) {
+		if (ts_valid && (0 <
+			timestamp_cmp(ts, iommu->iommu_last_cmd_ts)))
+			iommu->iommu_last_cmd_ts = ts;
+	} else {
+		if (ts_valid) {
+			iommu->iommu_last_cmd_ts = ts;
+			iommu->clk_event_queued = true;
+			if (kgsl_add_event(mmu->device, KGSL_MEMSTORE_GLOBAL,
+				ts, kgsl_iommu_clk_disable_event, mmu, mmu)) {
+				KGSL_DRV_ERR(mmu->device,
+				"Failed to add IOMMU disable clk event\n");
+				iommu->clk_event_queued = false;
+			}
+		} else {
+			kgsl_iommu_disable_clk(mmu);
+		}
 	}
-
-	return 1;
 }
 
 /*
  * kgsl_iommu_enable_clk - Enable iommu clocks
  * @mmu - Pointer to mmu structure
- * @unit - The iommu unit whose clocks are to be turned on
+ * @ctx_id - The context bank whose clocks are to be turned on
  *
- * Enables iommu clocks of a given iommu unit
+ * Enables iommu clocks of a given context
  * Return: 0 on success else error code
  */
-static void kgsl_iommu_enable_clk(struct kgsl_mmu *mmu,
-				int unit)
+static int kgsl_iommu_enable_clk(struct kgsl_mmu *mmu,
+				int ctx_id)
 {
+	int ret = 0;
 	int i, j;
 	struct kgsl_iommu *iommu = mmu->priv;
+	struct msm_iommu_drvdata *iommu_drvdata;
 
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-
-		/* Turn on the clks for IOMMU unit requested */
-		if ((unit != i) && (unit != KGSL_IOMMU_MAX_UNITS))
-			continue;
-
-		for (j = 0; j < KGSL_IOMMU_MAX_CLKS; j++) {
-			if (iommu_unit->clks[j])
-				if (kgsl_iommu_clk_prepare_enable(
-						iommu_unit->clks[j]))
-						goto done;
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			if (iommu_unit->dev[j].clk_enabled ||
+				ctx_id != iommu_unit->dev[j].ctx_id)
+				continue;
+			iommu_drvdata =
+			dev_get_drvdata(iommu_unit->dev[j].dev->parent);
+			ret = clk_prepare_enable(iommu_drvdata->pclk);
+			if (ret)
+				goto done;
+			if (iommu_drvdata->clk) {
+				ret = clk_prepare_enable(iommu_drvdata->clk);
+				if (ret) {
+					clk_disable_unprepare(
+						iommu_drvdata->pclk);
+					goto done;
+				}
+			}
+			if (iommu_drvdata->aclk) {
+				ret = clk_prepare_enable(iommu_drvdata->aclk);
+				if (ret) {
+					if (iommu_drvdata->clk)
+						clk_disable_unprepare(
+							iommu_drvdata->clk);
+					clk_disable_unprepare(
+							iommu_drvdata->pclk);
+					goto done;
+				}
+			}
+			iommu_unit->dev[j].clk_enabled = true;
 		}
-		atomic_inc(&iommu_unit->clk_enable_count);
 	}
-	return;
 done:
-	/*
-	 * Any Clock enable failure should be fatal,
-	 * System usually crashes when enabling clock fails
-	 * BUG_ON here to catch the system in bad state for
-	 * further debug
-	 */
-	KGSL_CORE_ERR("IOMMU clk enable failed\n");
-	BUG();
+	if (ret)
+		kgsl_iommu_disable_clk(mmu);
+	return ret;
 }
 
 /*
@@ -769,7 +766,6 @@
 {
 	struct kgsl_iommu_pt *iommu_pt;
 	struct kgsl_iommu *iommu = mmu->priv;
-	struct msm_iommu_drvdata *drvdata = 0;
 	int i, j, ret = 0;
 
 	/*
@@ -784,12 +780,9 @@
 			 * If there is a 2nd default pagetable then priv domain
 			 * is attached to this pagetable
 			 */
-			if (KGSL_IOMMU_CONTEXT_PRIV == j) {
-				if (mmu->priv_bank_table)
-					iommu_pt = mmu->priv_bank_table->priv;
-				else
-					continue;
-			}
+			if (mmu->priv_bank_table &&
+				(KGSL_IOMMU_CONTEXT_PRIV == j))
+				iommu_pt = mmu->priv_bank_table->priv;
 			if (!iommu_unit->dev[j].attached) {
 				ret = iommu_attach_device(iommu_pt->domain,
 							iommu_unit->dev[j].dev);
@@ -804,14 +797,6 @@
 				"iommu pt %p attached to dev %p, ctx_id %d\n",
 				iommu_pt->domain, iommu_unit->dev[j].dev,
 				iommu_unit->dev[j].ctx_id);
-				/* Init IOMMU unit clks here */
-				if (!drvdata) {
-					drvdata = dev_get_drvdata(
-					iommu_unit->dev[j].dev->parent);
-					iommu_unit->clks[0] = drvdata->pclk;
-					iommu_unit->clks[1] = drvdata->clk;
-					iommu_unit->clks[2] = drvdata->aclk;
-				}
 			}
 		}
 	}
@@ -837,7 +822,6 @@
 	struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[unit_id];
 	int i, j;
 	int found_ctx;
-	int ret = 0;
 
 	for (j = 0; j < KGSL_IOMMU_MAX_DEVS_PER_UNIT; j++) {
 		found_ctx = 0;
@@ -851,22 +835,16 @@
 			break;
 		if (!data->iommu_ctxs[i].iommu_ctx_name) {
 			KGSL_CORE_ERR("Context name invalid\n");
-			ret = -EINVAL;
-			goto done;
+			return -EINVAL;
 		}
-		atomic_set(&(iommu_unit->clk_enable_count), 0);
 
 		iommu_unit->dev[iommu_unit->dev_count].dev =
 			msm_iommu_get_ctx(data->iommu_ctxs[i].iommu_ctx_name);
-		if (NULL == iommu_unit->dev[iommu_unit->dev_count].dev)
-			ret = -EINVAL;
-		if (IS_ERR(iommu_unit->dev[iommu_unit->dev_count].dev)) {
-			ret = PTR_ERR(
-				iommu_unit->dev[iommu_unit->dev_count].dev);
-			iommu_unit->dev[iommu_unit->dev_count].dev = NULL;
+		if (iommu_unit->dev[iommu_unit->dev_count].dev == NULL) {
+			KGSL_CORE_ERR("Failed to get iommu dev handle for "
+			"device %s\n", data->iommu_ctxs[i].iommu_ctx_name);
+			return -EINVAL;
 		}
-		if (ret)
-			goto done;
 		iommu_unit->dev[iommu_unit->dev_count].ctx_id =
 						data->iommu_ctxs[i].ctx_id;
 		iommu_unit->dev[iommu_unit->dev_count].kgsldev = mmu->device;
@@ -878,23 +856,12 @@
 
 		iommu_unit->dev_count++;
 	}
-done:
-	if (!iommu_unit->dev_count && !ret)
-		ret = -EINVAL;
-	if (ret) {
-		/*
-		 * If at least the first context is initialized on v1
-		 * then we can continue
-		 */
-		if (!msm_soc_version_supports_iommu_v1() &&
-			iommu_unit->dev_count)
-			ret = 0;
-		else
-			KGSL_CORE_ERR(
-			"Failed to initialize iommu contexts, err: %d\n", ret);
+	if (!j) {
+		KGSL_CORE_ERR("No ctxts initialized, user ctxt absent\n ");
+		return -EINVAL;
 	}
 
-	return ret;
+	return 0;
 }
 
 /*
@@ -957,17 +924,6 @@
 		!kgsl_mmu_is_perprocess(mmu))
 		return status;
 
-	/*
-	 * For 2D devices cpu side sync lock is required. For 3D device,
-	 * since we only have a single 3D core and we always ensure that
-	 * 3D core is idle while writing to IOMMU register using CPU this
-	 * lock is not required
-	 */
-	if (KGSL_DEVICE_2D0 == mmu->device->id ||
-		KGSL_DEVICE_2D1 == mmu->device->id) {
-		return status;
-	}
-
 	/* Return if already initialized */
 	if (iommu->sync_lock_initialized)
 		return status;
@@ -1037,10 +993,6 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	*cmds++ = cp_type3_packet(CP_MEM_WRITE, 2);
 	*cmds++ = lock_vars->turn;
 	*cmds++ = 0;
@@ -1055,19 +1007,11 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	*cmds++ = cp_type3_packet(CP_TEST_TWO_MEMS, 3);
 	*cmds++ = lock_vars->flag[PROC_APPS];
 	*cmds++ = lock_vars->turn;
 	*cmds++ = 0;
 
-	/* TEST_TWO_MEMS turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += adreno_add_idle_cmds(adreno_dev, cmds);
 
 	return cmds - start;
@@ -1105,10 +1049,6 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += adreno_add_idle_cmds(adreno_dev, cmds);
 
 	return cmds - start;
@@ -1256,17 +1196,19 @@
 {
 	int ret = 0;
 
-	/* page table not current, then setup mmu to use new
-	 *  specified page table
-	 */
-	if (mmu->hwpagetable != pagetable) {
-		unsigned int flags = 0;
-		mmu->hwpagetable = pagetable;
-		flags |= kgsl_mmu_pt_get_flags(mmu->hwpagetable,
-						mmu->device->id) |
-						KGSL_MMUFLAGS_TLBFLUSH;
-		ret = kgsl_setstate(mmu, context_id,
-			KGSL_MMUFLAGS_PTUPDATE | flags);
+	if (mmu->flags & KGSL_FLAGS_STARTED) {
+		/* page table not current, then setup mmu to use new
+		 *  specified page table
+		 */
+		if (mmu->hwpagetable != pagetable) {
+			unsigned int flags = 0;
+			mmu->hwpagetable = pagetable;
+			flags |= kgsl_mmu_pt_get_flags(mmu->hwpagetable,
+							mmu->device->id) |
+							KGSL_MMUFLAGS_TLBFLUSH;
+			ret = kgsl_setstate(mmu, context_id,
+				KGSL_MMUFLAGS_PTUPDATE | flags);
+		}
 	}
 
 	return ret;
@@ -1567,8 +1509,6 @@
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			tlblkcr = 0;
 			if (cpu_is_msm8960())
 				tlblkcr |= ((num_tlb_entries &
@@ -1594,8 +1534,6 @@
 					TLBLKCR, tlblkcr);
 		}
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			/* skip locking entries for private bank on 8960 */
 			if (cpu_is_msm8960() &&  KGSL_IOMMU_CONTEXT_PRIV == j)
 				continue;
@@ -1635,8 +1573,6 @@
 			}
 		}
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			tlblkcr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 						iommu_unit->dev[j].ctx_id,
 						TLBLKCR);
@@ -1652,16 +1588,25 @@
 
 static int kgsl_iommu_start(struct kgsl_mmu *mmu)
 {
+	struct kgsl_device *device = mmu->device;
 	int status;
 	struct kgsl_iommu *iommu = mmu->priv;
 	int i, j;
 	int sctlr_val = 0;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(mmu->device);
 
+	if (mmu->flags & KGSL_FLAGS_STARTED)
+		return 0;
+
 	if (mmu->defaultpagetable == NULL) {
 		status = kgsl_iommu_setup_defaultpagetable(mmu);
 		if (status)
 			return -ENOMEM;
+
+		/* Initialize the sync lock between GPU and CPU */
+		if (msm_soc_version_supports_iommu_v1() &&
+			(device->id == KGSL_DEVICE_3D0))
+				kgsl_iommu_init_sync_lock(mmu);
 	}
 	status = kgsl_iommu_start_sync_lock(mmu);
 	if (status)
@@ -1686,20 +1631,26 @@
 		mmu->hwpagetable = NULL;
 		goto done;
 	}
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
+	status = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+	if (status) {
+		KGSL_CORE_ERR("clk enable failed\n");
+		goto done;
+	}
+	status = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_PRIV);
+	if (status) {
+		KGSL_CORE_ERR("clk enable failed\n");
+		goto done;
+	}
 	/* Get the lsb value of pagetables set in the IOMMU ttbr0 register as
 	 * that value should not change when we change pagetables, so while
 	 * changing pagetables we can use this lsb value of the pagetable w/o
 	 * having to read it again
 	 */
-	_iommu_lock();
+	msm_iommu_lock();
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
+
 			/*
 			 * For IOMMU V1 do not halt IOMMU on pagefault if
 			 * FT pagefault policy is set accordingly
@@ -1718,25 +1669,37 @@
 						iommu_unit->dev[j].ctx_id,
 						SCTLR, sctlr_val);
 			}
-
-			iommu_unit->dev[j].default_ttbr0 =
-				KGSL_IOMMU_GET_CTX_REG_LL(iommu,
+			if (sizeof(phys_addr_t) > sizeof(unsigned long)) {
+				iommu_unit->dev[j].default_ttbr0 =
+						KGSL_IOMMU_GET_CTX_REG_LL(iommu,
 						iommu_unit,
 						iommu_unit->dev[j].ctx_id,
 						TTBR0);
+			} else {
+				iommu_unit->dev[j].default_ttbr0 =
+						KGSL_IOMMU_GET_CTX_REG(iommu,
+						iommu_unit,
+						iommu_unit->dev[j].ctx_id,
+						TTBR0);
+			}
 		}
 	}
 	kgsl_iommu_lock_rb_in_tlb(mmu);
-	_iommu_unlock();
+	msm_iommu_unlock();
 
 	/* For complete CFF */
 	kgsl_cffdump_setmem(mmu->device, mmu->setstate_memory.gpuaddr +
 				KGSL_IOMMU_SETSTATE_NOP_OFFSET,
 				cp_nop_packet(1), sizeof(unsigned int));
 
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
+	mmu->flags |= KGSL_FLAGS_STARTED;
 
 done:
+	if (status) {
+		kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
+		kgsl_detach_pagetable_iommu_domain(mmu);
+	}
 	return status;
 }
 
@@ -1745,11 +1708,9 @@
 		struct kgsl_memdesc *memdesc,
 		unsigned int *tlb_flags)
 {
-	int ret = 0, lock_taken = 0;
+	int ret;
 	unsigned int range = memdesc->size;
 	struct kgsl_iommu_pt *iommu_pt = pt->priv;
-	struct kgsl_device *device = pt->mmu->device;
-	struct kgsl_iommu *iommu = pt->mmu->priv;
 
 	/* All GPU addresses as assigned are page aligned, but some
 	   functions purturb the gpuaddr with an offset, so apply the
@@ -1764,38 +1725,18 @@
 		range += PAGE_SIZE;
 
 	ret = iommu_unmap_range(iommu_pt->domain, gpuaddr, range);
-	if (ret) {
+	if (ret)
 		KGSL_CORE_ERR("iommu_unmap_range(%p, %x, %d) failed "
 			"with err: %d\n", iommu_pt->domain, gpuaddr,
 			range, ret);
-		return ret;
-	}
-
-	/*
-	 * Check to see if the current thread already holds the device mutex.
-	 * If it does not, then take the device mutex which is required for
-	 * flushing the tlb
-	 */
-	if (!mutex_is_locked(&device->mutex) ||
-		device->mutex.owner != current) {
-		mutex_lock(&device->mutex);
-		lock_taken = 1;
-	}
 
 	/*
-	 * Flush the tlb only if the iommu device is attached and the pagetable
-	 * hasn't been switched yet
+	 * Flushing only required if per process pagetables are used. With
+	 * global case, flushing will happen inside iommu_map function
 	 */
-	if (kgsl_mmu_is_perprocess(pt->mmu) &&
-		iommu->iommu_units[0].dev[KGSL_IOMMU_CONTEXT_USER].attached &&
-		kgsl_iommu_pt_equal(pt->mmu, pt,
-		kgsl_iommu_get_current_ptbase(pt->mmu)))
-		kgsl_iommu_default_setstate(pt->mmu, KGSL_MMUFLAGS_TLBFLUSH);
-
-	if (lock_taken)
-		mutex_unlock(&device->mutex);
-
-	return ret;
+	if (!ret && kgsl_mmu_is_perprocess(pt->mmu))
+		*tlb_flags = UINT_MAX;
+	return 0;
 }
 
 static int
@@ -1845,14 +1786,12 @@
 	int i, j;
 
 	if (atomic_read(&mmu->fault)) {
-		kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
 		for (i = 0; i < iommu->unit_count; i++) {
 			struct kgsl_iommu_unit *iommu_unit =
 						&iommu->iommu_units[i];
 			for (j = 0; j < iommu_unit->dev_count; j++) {
-				if (!iommu_unit->dev[j].attached)
-					continue;
 				if (iommu_unit->dev[j].fault) {
+					kgsl_iommu_enable_clk(mmu, j);
 					_iommu_lock();
 					KGSL_IOMMU_SET_CTX_REG(iommu,
 						iommu_unit,
@@ -1867,25 +1806,32 @@
 				}
 			}
 		}
-		kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
 		atomic_set(&mmu->fault, 0);
 	}
 }
 
+
 static void kgsl_iommu_stop(struct kgsl_mmu *mmu)
 {
+	struct kgsl_iommu *iommu = mmu->priv;
 	/*
 	 *  stop device mmu
 	 *
 	 *  call this with the global lock held
-	 *  detach iommu attachment
 	 */
-	kgsl_detach_pagetable_iommu_domain(mmu);
-	mmu->hwpagetable = NULL;
+	if (mmu->flags & KGSL_FLAGS_STARTED) {
+		/* detach iommu attachment */
+		kgsl_detach_pagetable_iommu_domain(mmu);
+		mmu->hwpagetable = NULL;
 
-	kgsl_iommu_pagefault_resume(mmu);
+		mmu->flags &= ~KGSL_FLAGS_STARTED;
+
+		kgsl_iommu_pagefault_resume(mmu);
+	}
 	/* switch off MMU clocks and cancel any events it has queued */
+	iommu->clk_event_queued = false;
 	kgsl_cancel_events(mmu->device, mmu);
+	kgsl_iommu_disable_clk(mmu);
 }
 
 static int kgsl_iommu_close(struct kgsl_mmu *mmu)
@@ -1934,11 +1880,11 @@
 	if (in_interrupt())
 		return 0;
 	/* Return the current pt base by reading IOMMU pt_base register */
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	pt_base = KGSL_IOMMU_GET_CTX_REG_LL(iommu, (&iommu->iommu_units[0]),
+	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+	pt_base = KGSL_IOMMU_GET_CTX_REG(iommu, (&iommu->iommu_units[0]),
 					KGSL_IOMMU_CONTEXT_USER,
 					TTBR0);
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
 	return pt_base & KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 }
 
@@ -1961,11 +1907,16 @@
 	int temp;
 	int i;
 	int ret = 0;
-	phys_addr_t pt_base = kgsl_iommu_get_pt_base_addr(mmu,
+	unsigned int pt_base = kgsl_iommu_get_pt_base_addr(mmu,
 						mmu->hwpagetable);
 	phys_addr_t pt_val;
 
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	ret = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+
+	if (ret) {
+		KGSL_DRV_ERR(mmu->device, "Failed to enable iommu clocks\n");
+		return ret;
+	}
 
 	/* For v0 SMMU GPU needs to be idle for tlb invalidate as well */
 	/* naming mismatch for iommu */
@@ -1976,7 +1927,7 @@
 	}
 
 	/* Acquire GPU-CPU sync Lock here */
-	_iommu_lock();
+	msm_iommu_lock();
 
 	if (flags & KGSL_MMUFLAGS_PTUPDATE) {
 	/* naming mismatch for iommu */
@@ -1994,12 +1945,18 @@
 			pt_base &= KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 			pt_val &= ~KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 			pt_val |= pt_base;
-			KGSL_IOMMU_SET_CTX_REG_LL(iommu,
+			if (sizeof(phys_addr_t) > sizeof(unsigned long)) {
+				KGSL_IOMMU_SET_CTX_REG_LL(iommu,
+					(&iommu->iommu_units[i]),
+					KGSL_IOMMU_CONTEXT_USER, TTBR0, pt_val);
+			} else {
+				KGSL_IOMMU_SET_CTX_REG(iommu,
 					(&iommu->iommu_units[i]),
 					KGSL_IOMMU_CONTEXT_USER, TTBR0, pt_val);
+			}
 
 			mb();
-			temp = KGSL_IOMMU_GET_CTX_REG_LL(iommu,
+			temp = KGSL_IOMMU_GET_CTX_REG(iommu,
 				(&iommu->iommu_units[i]),
 				KGSL_IOMMU_CONTEXT_USER, TTBR0);
 		}
@@ -2043,11 +2000,10 @@
 unlock:
 
 	/* Release GPU-CPU sync Lock here */
-	_iommu_unlock();
+	msm_iommu_unlock();
 
 	/* Disable smmu clock */
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
 	return ret;
 }
 
@@ -2094,103 +2050,6 @@
 	return iommu->unit_count;
 }
 
-/*
- * kgsl_iommu_set_pf_policy() - Set the pagefault policy for IOMMU
- * @mmu: Pointer to mmu structure
- * @pf_policy: The pagefault polict to set
- *
- * Check if the new policy indicated by pf_policy is same as current
- * policy, if same then return else set the policy
- */
-static int kgsl_iommu_set_pf_policy(struct kgsl_mmu *mmu,
-				unsigned int pf_policy)
-{
-	int i, j;
-	struct kgsl_iommu *iommu = mmu->priv;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(mmu->device);
-	int ret = 0;
-	unsigned int sctlr_val;
-
-	if ((adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE) ==
-		(pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE))
-		return ret;
-	if (!msm_soc_version_supports_iommu_v1())
-		return ret;
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
-	/* Need to idle device before changing options */
-	ret = mmu->device->ftbl->idle(mmu->device);
-	if (ret) {
-		kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-		return ret;
-	}
-
-	for (i = 0; i < iommu->unit_count; i++) {
-		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-		for (j = 0; j < iommu_unit->dev_count; j++) {
-			sctlr_val = KGSL_IOMMU_GET_CTX_REG(iommu,
-					iommu_unit,
-					iommu_unit->dev[j].ctx_id,
-					SCTLR);
-			if (pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
-				sctlr_val &= ~(0x1 <<
-					KGSL_IOMMU_SCTLR_HUPCF_SHIFT);
-			else
-				sctlr_val |= (0x1 <<
-					KGSL_IOMMU_SCTLR_HUPCF_SHIFT);
-			KGSL_IOMMU_SET_CTX_REG(iommu,
-					iommu_unit,
-					iommu_unit->dev[j].ctx_id,
-					SCTLR, sctlr_val);
-		}
-	}
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	return ret;
-}
-
-/**
- * kgsl_iommu_set_pagefault() - Checks if a IOMMU device has faulted
- * @mmu: MMU pointer of the device
- *
- * This function is called to set the pagefault bits for the device so
- * that recovery can run with pagefault in consideration
- */
-static void kgsl_iommu_set_pagefault(struct kgsl_mmu *mmu)
-{
-	int i, j;
-	struct kgsl_iommu *iommu = mmu->priv;
-	unsigned int fsr;
-
-	/* fault already detected then return early */
-	if (atomic_read(&mmu->fault))
-		return;
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	/* Loop through all IOMMU devices to check for fault */
-	for (i = 0; i < iommu->unit_count; i++) {
-		for (j = 0; j < iommu->iommu_units[i].dev_count; j++) {
-			if (!iommu->iommu_units[i].dev[j].attached)
-				continue;
-			fsr = KGSL_IOMMU_GET_CTX_REG(iommu,
-				(&(iommu->iommu_units[i])),
-				iommu->iommu_units[i].dev[j].ctx_id, FSR);
-			if (fsr) {
-				uint64_t far =
-					KGSL_IOMMU_GET_CTX_REG_LL(iommu,
-					(&(iommu->iommu_units[i])),
-					iommu->iommu_units[i].dev[j].ctx_id,
-					FAR);
-				kgsl_iommu_fault_handler(NULL,
-				iommu->iommu_units[i].dev[j].dev, far, 0, NULL);
-				break;
-			}
-		}
-	}
-
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-}
-
 struct kgsl_mmu_ops iommu_ops = {
 	.mmu_init = kgsl_iommu_init,
 	.mmu_close = kgsl_iommu_close,
@@ -2216,8 +2075,6 @@
 	.mmu_cleanup_pt = NULL,
 	.mmu_sync_lock = kgsl_iommu_sync_lock,
 	.mmu_sync_unlock = kgsl_iommu_sync_unlock,
-	.mmu_set_pf_policy = kgsl_iommu_set_pf_policy,
-	.mmu_set_pagefault = kgsl_iommu_set_pagefault
 };
 
 struct kgsl_mmu_pt_ops iommu_pt_ops = {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -70,7 +70,6 @@
 	KGSL_IOMMU_CTX_TTBR0,
 	KGSL_IOMMU_CTX_TTBR1,
 	KGSL_IOMMU_CTX_FSR,
-	KGSL_IOMMU_CTX_FAR,
 	KGSL_IOMMU_CTX_TLBIALL,
 	KGSL_IOMMU_CTX_RESUME,
 	KGSL_IOMMU_CTX_TLBLKCR,
@@ -92,16 +91,10 @@
  * Max number of iommu units that the gpu core can have
  * On APQ8064, KGSL can control a maximum of 2 IOMMU units.
  */
-enum kgsl_iommu_units {
-	KGSL_IOMMU_UNIT_0 = 0,
-	KGSL_IOMMU_UNIT_1 = 1,
-	KGSL_IOMMU_MAX_UNITS = 2,
-};
+#define KGSL_IOMMU_MAX_UNITS 2
 
 /* Max number of iommu contexts per IOMMU unit */
 #define KGSL_IOMMU_MAX_DEVS_PER_UNIT 2
-/* Max number of iommu clks per IOMMU unit */
-#define KGSL_IOMMU_MAX_CLKS 3
 
 /* Macros to read/write IOMMU registers */
 #define KGSL_IOMMU_SET_CTX_REG_LL(iommu, iommu_unit, ctx, REG, val)	\
@@ -112,7 +105,7 @@
 		iommu->ctx_offset)
 
 #define KGSL_IOMMU_GET_CTX_REG_LL(iommu, iommu_unit, ctx, REG)		\
-		readll_relaxed(						\
+		readl_relaxed(						\
 		iommu_unit->reg_map.hostptr +				\
 		iommu->iommu_reg_list[KGSL_IOMMU_CTX_##REG].reg_offset +\
 		(ctx << KGSL_IOMMU_CTX_SHIFT) +				\
@@ -174,8 +167,6 @@
  * @iommu_halt_enable: Valid only on IOMMU-v1, when set indicates that the iommu
  * unit supports halting of the IOMMU, which can be enabled while programming
  * the IOMMU registers for synchronization
- * @clk_enable_count: The ref count of clock enable calls
- * @clks: iommu unit clks
  */
 struct kgsl_iommu_unit {
 	struct kgsl_iommu_device dev[KGSL_IOMMU_MAX_DEVS_PER_UNIT];
@@ -183,8 +174,6 @@
 	struct kgsl_memdesc reg_map;
 	unsigned int ahb_base;
 	int iommu_halt_enable;
-	atomic_t clk_enable_count;
-	struct clk *clks[KGSL_IOMMU_MAX_CLKS];
 };
 
 /*
@@ -193,6 +182,10 @@
  * iommu contexts owned by graphics cores
  * @unit_count: Number of IOMMU units that are available for this
  * instance of the IOMMU driver
+ * @iommu_last_cmd_ts: The timestamp of last command submitted that
+ * aceeses iommu registers
+ * @clk_event_queued: Indicates whether an event to disable clocks
+ * is already queued or not
  * @device: Pointer to kgsl device
  * @ctx_offset: The context offset to be added to base address when
  * accessing IOMMU registers
@@ -208,6 +201,8 @@
 struct kgsl_iommu {
 	struct kgsl_iommu_unit iommu_units[KGSL_IOMMU_MAX_UNITS];
 	unsigned int unit_count;
+	unsigned int iommu_last_cmd_ts;
+	bool clk_event_queued;
 	struct kgsl_device *device;
 	unsigned int ctx_offset;
 	struct kgsl_iommu_register_list *iommu_reg_list;
@@ -227,18 +222,4 @@
 	struct kgsl_iommu *iommu;
 };
 
-/*
- * struct kgsl_iommu_disable_clk_param - Parameter struct for disble clk event
- * @mmu: The mmu pointer
- * @rb_level: the rb level in which the timestamp of the event belongs to
- * @unit: The IOMMU unit whose clock is to be turned off
- * @ts: Timestamp on which clock is to be disabled
- */
-struct kgsl_iommu_disable_clk_param {
-	struct kgsl_mmu *mmu;
-	int rb_level;
-	int unit;
-	unsigned int ts;
-};
-
 #endif
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_log.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_log.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_log.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_log.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2011,2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,6 +13,8 @@
 #ifndef __KGSL_LOG_H
 #define __KGSL_LOG_H
 
+extern unsigned int kgsl_cff_dump_enable;
+
 #define KGSL_LOG_INFO(dev, lvl, fmt, args...) \
 	do { \
 		if ((lvl) >= 6)  \
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.c	2014-09-21 01:02:11.000000000 +0000
@@ -20,7 +20,6 @@
 #include <linux/iommu.h>
 #include <mach/iommu.h>
 #include <mach/socinfo.h>
-#include <linux/types.h>
 
 #include "kgsl.h"
 #include "kgsl_mmu.h"
@@ -349,7 +348,7 @@
 	unsigned int ret = 0;
 
 	if (!mmu->mmu_ops || !mmu->mmu_ops->mmu_pt_equal)
-		return 0;
+		return KGSL_MMU_GLOBAL_PT;
 	spin_lock(&kgsl_driver.ptlock);
 	list_for_each_entry(pt, &kgsl_driver.pagetable_list, list) {
 		if (kref_get_unless_zero(&pt->refcount)) {
@@ -386,18 +385,12 @@
 	status = kgsl_allocate_contiguous(&mmu->setstate_memory, PAGE_SIZE);
 	if (status)
 		return status;
-
-	/* Mark the setstate memory as read only */
-	mmu->setstate_memory.flags |= KGSL_MEMFLAGS_GPUREADONLY;
-
 	kgsl_sharedmem_set(device, &mmu->setstate_memory, 0, 0,
 				mmu->setstate_memory.size);
 
 	if (KGSL_MMU_TYPE_NONE == kgsl_mmu_type) {
 		dev_info(device->dev, "|%s| MMU type set for device is "
 				"NOMMU\n", __func__);
-		status = dma_set_coherent_mask(device->dev->parent,
-					DMA_BIT_MASK(sizeof(dma_addr_t)*8));
 		goto done;
 	} else if (KGSL_MMU_TYPE_GPU == kgsl_mmu_type)
 		mmu->mmu_ops = &gpummu_ops;
@@ -737,10 +730,6 @@
 	if (!kgsl_memdesc_is_global(memdesc) &&
 		(KGSL_MEMDESC_MAPPED & memdesc->priv))
 		return -EINVAL;
-
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
-		return 0;
-
 	/* Add space for the guard page when allocating the mmu VA. */
 	size = memdesc->size;
 	if (kgsl_memdesc_has_guard_page(memdesc))
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -148,12 +148,11 @@
 	void (*mmu_pagefault_resume)
 			(struct kgsl_mmu *mmu);
 	void (*mmu_disable_clk_on_ts)
-		(struct kgsl_mmu *mmu,
-		uint32_t ts, int unit);
-	void (*mmu_enable_clk)
-		(struct kgsl_mmu *mmu, int unit);
+		(struct kgsl_mmu *mmu, uint32_t ts, bool ts_valid);
+	int (*mmu_enable_clk)
+		(struct kgsl_mmu *mmu, int ctx_id);
 	void (*mmu_disable_clk)
-		(struct kgsl_mmu *mmu, int unit);
+		(struct kgsl_mmu *mmu);
 	phys_addr_t (*mmu_get_default_ttbr0)(struct kgsl_mmu *mmu,
 				unsigned int unit_id,
 				enum kgsl_iommu_context_id ctx_id);
@@ -178,8 +177,6 @@
 	unsigned int (*mmu_sync_unlock)
 			(struct kgsl_mmu *mmu, unsigned int *cmds);
 	int (*mmu_hw_halt_supported)(struct kgsl_mmu *mmu, int iommu_unit_num);
-	int (*mmu_set_pf_policy)(struct kgsl_mmu *mmu, unsigned int pf_policy);
-	void (*mmu_set_pagefault)(struct kgsl_mmu *mmu);
 };
 
 struct kgsl_mmu_pt_ops {
@@ -324,25 +321,26 @@
 		return 0;
 }
 
-static inline void kgsl_mmu_enable_clk(struct kgsl_mmu *mmu, int unit)
+static inline int kgsl_mmu_enable_clk(struct kgsl_mmu *mmu,
+					int ctx_id)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_enable_clk)
-		mmu->mmu_ops->mmu_enable_clk(mmu, unit);
+		return mmu->mmu_ops->mmu_enable_clk(mmu, ctx_id);
 	else
-		return;
+		return 0;
 }
 
-static inline void kgsl_mmu_disable_clk(struct kgsl_mmu *mmu, int unit)
+static inline void kgsl_mmu_disable_clk(struct kgsl_mmu *mmu)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_disable_clk)
-		mmu->mmu_ops->mmu_disable_clk(mmu, unit);
+		mmu->mmu_ops->mmu_disable_clk(mmu);
 }
 
 static inline void kgsl_mmu_disable_clk_on_ts(struct kgsl_mmu *mmu,
-						unsigned int ts, int unit)
+						unsigned int ts, bool ts_valid)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_disable_clk_on_ts)
-		mmu->mmu_ops->mmu_disable_clk_on_ts(mmu, ts, unit);
+		mmu->mmu_ops->mmu_disable_clk_on_ts(mmu, ts, ts_valid);
 }
 
 static inline unsigned int kgsl_mmu_get_int_mask(void)
@@ -483,19 +481,4 @@
 		return 0;
 }
 
-static inline int kgsl_mmu_set_pagefault_policy(struct kgsl_mmu *mmu,
-						unsigned int pf_policy)
-{
-	if (mmu->mmu_ops && mmu->mmu_ops->mmu_set_pf_policy)
-		return mmu->mmu_ops->mmu_set_pf_policy(mmu, pf_policy);
-	else
-		return 0;
-}
-
-static inline void kgsl_mmu_set_pagefault(struct kgsl_mmu *mmu)
-{
-	if (mmu->mmu_ops && mmu->mmu_ops->mmu_set_pagefault)
-		return mmu->mmu_ops->mmu_set_pagefault(mmu);
-}
-
 #endif /* __KGSL_MMU_H */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.c	2014-09-21 01:02:11.000000000 +0000
@@ -26,8 +26,6 @@
 #include "kgsl_trace.h"
 #include "kgsl_sharedmem.h"
 
-#include <mach/kgsl.h>
-
 #define KGSL_PWRFLAGS_POWER_ON 0
 #define KGSL_PWRFLAGS_CLK_ON   1
 #define KGSL_PWRFLAGS_AXI_ON   2
@@ -46,12 +44,6 @@
 #define INIT_UDELAY		200
 #define MAX_UDELAY		2000
 
-unsigned long internal_max = 450000000;
-
-#ifdef CONFIG_CPU_FREQ_GOV_ELEMENTALX
-int graphics_boost = 2;
-#endif
-
 struct clk_pair {
 	const char *name;
 	uint map;
@@ -196,10 +188,6 @@
 
 
 	trace_kgsl_pwrlevel(device, pwr->active_pwrlevel, pwrlevel->gpu_freq);
-
-#ifdef CONFIG_CPU_FREQ_GOV_ELEMENTALX
-        graphics_boost = pwr->active_pwrlevel;
-#endif
 }
 
 EXPORT_SYMBOL(kgsl_pwrctrl_pwrlevel_change);
@@ -403,8 +391,6 @@
 	return -ERANGE;
 }
 
-extern void SetGPUpll_config(u32 loc, unsigned long freq);
-
 static int kgsl_pwrctrl_max_gpuclk_store(struct device *dev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
@@ -423,34 +409,6 @@
 	if (ret != 1)
 		return count;
 
-	if (max_gpu) {
-
-		if (val == 450000000) {
-			SetGPUpll_config(0x21, val);
-		}
-		else if (val == 477000000) {
-			SetGPUpll_config(0x23, val);
-		}
-		else if (val == 490500000) {
-			SetGPUpll_config(0x24, val);
-		}
-		else if (val == 504000000) {
-			SetGPUpll_config(0x25, val);
-		}
-		else if (val == 531000000) {
-			SetGPUpll_config(0x27, val);
-		}
-		else if (val == 558000000) {
-			SetGPUpll_config(0x29, val);
-		}
-		else if (val == 585000000) {
-			SetGPUpll_config(0x2B, val);
-		}
-	
-		internal_max = val;
-
-	}
-	
 	mutex_lock(&device->mutex);
 	level = _get_nearest_pwrlevel(pwr, val);
 	if (level < 0)
@@ -481,13 +439,8 @@
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-
-	if (max_gpu)
-		return snprintf(buf, PAGE_SIZE, "%ld\n",
-				internal_max);
-	else
-		return snprintf(buf, PAGE_SIZE, "%d\n",
-				pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
 }
 
 static int kgsl_pwrctrl_gpuclk_store(struct device *dev,
@@ -526,12 +479,8 @@
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-	if (pwr->active_pwrlevel != 0 || !max_gpu)
-		return snprintf(buf, PAGE_SIZE, "%d\n",
+	return snprintf(buf, PAGE_SIZE, "%d\n",
 			pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq);
-	else
-		return snprintf(buf, PAGE_SIZE, "%ld\n",
-			internal_max);
 }
 
 static int kgsl_pwrctrl_idle_timer_store(struct device *dev,
@@ -677,19 +626,8 @@
 		return 0;
 	pwr = &device->pwrctrl;
 	for (index = 0; index < pwr->num_pwrlevels - 1; index++)
-
-		if (index == 0 && max_gpu)
-		{
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",585000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",558000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",531000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",504000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",490500000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",477000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",450000000);
-		}
-		else
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",pwr->pwrlevels[index].gpu_freq);
+		num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",
+		pwr->pwrlevels[index].gpu_freq);
 	buf[num_chars++] = '\n';
 	return num_chars;
 }
@@ -828,12 +766,12 @@
 DEVICE_ATTR(num_pwrlevels, 0444,
 	kgsl_pwrctrl_num_pwrlevels_show,
 	NULL);
-DEVICE_ATTR(pmqos_latency, 0644,
-	kgsl_pwrctrl_pmqos_latency_show,
-	kgsl_pwrctrl_pmqos_latency_store);
 DEVICE_ATTR(reset_count, 0444,
 	kgsl_pwrctrl_reset_count_show,
 	NULL);
+DEVICE_ATTR(pmqos_latency, 0644,
+	kgsl_pwrctrl_pmqos_latency_show,
+	kgsl_pwrctrl_pmqos_latency_store);
 DEVICE_ATTR(force_clk_on, 0644,
 	kgsl_pwrctrl_force_clk_on_show,
 	kgsl_pwrctrl_force_clk_on_store);
@@ -855,8 +793,8 @@
 	&dev_attr_min_pwrlevel,
 	&dev_attr_thermal_pwrlevel,
 	&dev_attr_num_pwrlevels,
-	&dev_attr_pmqos_latency,
 	&dev_attr_reset_count,
+	&dev_attr_pmqos_latency,
 	&dev_attr_force_clk_on,
 	&dev_attr_force_bus_on,
 	&dev_attr_force_rail_on,
@@ -1394,6 +1332,8 @@
 		break;
 	}
 
+	kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
+
 	return 0;
 }
 
@@ -1443,6 +1383,7 @@
 		break;
 	case KGSL_STATE_SLEEP:
 		status = _sleep(device);
+		kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
 		break;
 	case KGSL_STATE_SLUMBER:
 		status = _slumber(device);
@@ -1493,7 +1434,6 @@
 			kgsl_pwrstate_to_str(state),
 			context ? context->id : -1, ts_processed);
 		kgsl_context_put(context);
-
 		/* fall through */
 	case KGSL_STATE_NAP:
 		/* Turn on the core clocks */
@@ -1524,10 +1464,7 @@
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
 	/* Order pwrrail/clk sequence based upon platform */
 	kgsl_pwrctrl_pwrrail(device, KGSL_PWRFLAGS_ON);
-
-	if (pwr->constraint.type == KGSL_CONSTRAINT_NONE)
-		kgsl_pwrctrl_pwrlevel_change(device, pwr->default_pwrlevel);
-
+	kgsl_pwrctrl_pwrlevel_change(device, pwr->default_pwrlevel);
 	kgsl_pwrctrl_clk(device, KGSL_PWRFLAGS_ON, KGSL_STATE_ACTIVE);
 	kgsl_pwrctrl_axi(device, KGSL_PWRFLAGS_ON);
 }
@@ -1600,11 +1537,13 @@
 	int ret = 0;
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
-	if ((atomic_read(&device->active_cnt) == 0) &&
-		(device->state != KGSL_STATE_ACTIVE)) {
-		mutex_unlock(&device->mutex);
-		wait_for_completion(&device->hwaccess_gate);
-		mutex_lock(&device->mutex);
+	if (atomic_read(&device->active_cnt) == 0) {
+		if (device->requested_state == KGSL_STATE_SUSPEND ||
+				device->state == KGSL_STATE_SUSPEND) {
+			mutex_unlock(&device->mutex);
+			wait_for_completion(&device->hwaccess_gate);
+			mutex_lock(&device->mutex);
+		}
 
 		ret = kgsl_pwrctrl_wake(device);
 	}
@@ -1657,9 +1596,12 @@
 
 	if (atomic_dec_and_test(&device->active_cnt)) {
 		if (device->state == KGSL_STATE_ACTIVE &&
-			device->requested_state == KGSL_STATE_NONE) {
+				 device->requested_state == KGSL_STATE_NONE) {
 			kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
-			queue_work(device->work_queue, &device->idle_check_ws);
+			if (kgsl_pwrctrl_sleep(device)) {
+				kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
+				queue_work(device->work_queue, &device->idle_check_ws);
+			}
 		}
 
 		mod_timer(&device->idle_timer,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -27,18 +27,6 @@
 
 #define KGSL_MAX_CLKS 6
 
-/* Only two supported levels, min & max */
-#define KGSL_CONSTRAINT_PWR_MAXLEVELS 2
-
-/* Symbolic table for the constraint type */
-#define KGSL_CONSTRAINT_TYPES \
-	{ KGSL_CONSTRAINT_NONE, "None" }, \
-	{ KGSL_CONSTRAINT_PWRLEVEL, "Pwrlevel" }
-/* Symbolic table for the constraint sub type */
-#define KGSL_CONSTRAINT_PWRLEVEL_SUBTYPES \
-	{ KGSL_CONSTRAINT_PWR_MIN, "Min" }, \
-	{ KGSL_CONSTRAINT_PWR_MAX, "Max" }
-
 struct platform_device;
 
 struct kgsl_clk_stats {
@@ -52,18 +40,6 @@
 	unsigned int elapsed_old;
 };
 
-struct kgsl_pwr_constraint {
-	unsigned int type;
-	unsigned int sub_type;
-	union {
-		struct {
-			unsigned int level;
-		} pwrlevel;
-	} hint;
-	unsigned long expires;
-	uint32_t owner_id;
-};
-
 /**
  * struct kgsl_pwrctrl - Power control settings for a KGSL device
  * @interrupt_num - The interrupt number for the device
@@ -89,7 +65,6 @@
  * @pm_qos_req_dma - the power management quality of service structure
  * @pm_qos_latency - allowed CPU latency in microseconds
  * @step_mul - multiplier for moving between power levels
- * @constraint - currently active power constraint
  */
 
 struct kgsl_pwrctrl {
@@ -119,7 +94,6 @@
 	unsigned int pm_qos_latency;
 	unsigned int step_mul;
 	unsigned int irq_last;
-	struct kgsl_pwr_constraint constraint;
 };
 
 void kgsl_pwrctrl_irq(struct kgsl_device *device, int state);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrscale_trustzone.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2014-09-21 01:02:11.000000000 +0000
@@ -22,17 +22,9 @@
 #include "kgsl.h"
 #include "kgsl_pwrscale.h"
 #include "kgsl_device.h"
-#include "kgsl_trace.h"
-
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-#include <linux/module.h>
-#endif
 
 #define TZ_GOVERNOR_PERFORMANCE 0
 #define TZ_GOVERNOR_ONDEMAND    1
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-#define TZ_GOVERNOR_SIMPLE	2
-#endif
 
 struct tz_priv {
 	int governor;
@@ -87,10 +79,6 @@
 
 	if (priv->governor == TZ_GOVERNOR_ONDEMAND)
 		ret = snprintf(buf, 10, "ondemand\n");
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-	else if (priv->governor == TZ_GOVERNOR_SIMPLE)
-		ret = snprintf(buf, 8, "simple\n");
-#endif
 	else
 		ret = snprintf(buf, 13, "performance\n");
 
@@ -114,10 +102,6 @@
 
 	if (!strncmp(str, "ondemand", 8))
 		priv->governor = TZ_GOVERNOR_ONDEMAND;
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-	else if (!strncmp(str, "simple", 6))
-		priv->governor = TZ_GOVERNOR_SIMPLE;
-#endif
 	else if (!strncmp(str, "performance", 11))
 		priv->governor = TZ_GOVERNOR_PERFORMANCE;
 
@@ -147,60 +131,11 @@
 {
 	struct tz_priv *priv = pwrscale->priv;
 	if (device->state != KGSL_STATE_NAP &&
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-		(priv->governor == TZ_GOVERNOR_ONDEMAND ||
-		 priv->governor == TZ_GOVERNOR_SIMPLE))
-#else
 		priv->governor == TZ_GOVERNOR_ONDEMAND)
-#endif
-		if (device->pwrctrl.constraint.type == KGSL_CONSTRAINT_NONE)
-			kgsl_pwrctrl_pwrlevel_change(device,
+		kgsl_pwrctrl_pwrlevel_change(device,
 					device->pwrctrl.default_pwrlevel);
 }
 
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-/* KGSL Simple GPU Governor */
-/* Copyright (c) 2011-2013, Paul Reioux (Faux123). All rights reserved. */
-static int default_laziness = 5;
-module_param_named(simple_laziness, default_laziness, int, 0664);
-
-static int ramp_up_threshold = 6000;
-module_param_named(simple_ramp_threshold, ramp_up_threshold, int, 0664);
-
-static int laziness;
-
-static int simple_governor(struct kgsl_device *device, int idle_stat)
-{
-	int val = 0;
-	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-
-	/* it's currently busy */
-	if (idle_stat < ramp_up_threshold) {
-		if (pwr->active_pwrlevel == 0)
-			val = 0; /* already maxed, so do nothing */
-		else if ((pwr->active_pwrlevel > 0) &&
-			(pwr->active_pwrlevel <= (pwr->num_pwrlevels - 1)))
-			val = -1; /* bump up to next pwrlevel */
-	/* idle case */
-	} else {
-		if ((pwr->active_pwrlevel >= 0) &&
-			(pwr->active_pwrlevel < (pwr->num_pwrlevels - 1)))
-			if (laziness > 0) {
-				/* hold off for a while */
-				laziness--;
-				val = 0; /* don't change anything yet */
-			} else {
-				val = 1; /* above min, lower it */
-				/* reset laziness count */
-				laziness = default_laziness;
-			}
-		else if (pwr->active_pwrlevel == (pwr->num_pwrlevels - 1))
-			val = 0; /* already @ min, so do nothing */
-	}
-	return val;
-}
-#endif
-
 static void tz_idle(struct kgsl_device *device, struct kgsl_pwrscale *pwrscale)
 {
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
@@ -224,13 +159,11 @@
 		(priv->bin.total_time < FLOOR))
 		return;
 
-	/* If there is an extended block of busy processing, set
-	 * frequency to turbo.  Otherwise run the normal algorithm.
+	/* If there is an extended block of busy processing,
+	 * increase frequency.  Otherwise run the normal algorithm.
 	 */
 	if (priv->bin.busy_time > CEILING) {
-		val = 0;
-		kgsl_pwrctrl_pwrlevel_change(device,
-				KGSL_PWRLEVEL_TURBO);
+		val = -1;
 	} else if (priv->idle_dcvs) {
 		idle = priv->bin.total_time - priv->bin.busy_time;
 		idle = (idle > 0) ? idle : 0;
@@ -241,22 +174,9 @@
 				(pwr->active_pwrlevel + 1)/2,
 				priv->bin.total_time, priv->bin.busy_time);
 		else
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-			{
-			idle = priv->bin.total_time - priv->bin.busy_time;
-			idle = (idle > 0) ? idle : 0;
-			if (priv->governor == TZ_GOVERNOR_SIMPLE)
-				val = simple_governor(device, idle);
-			else
-				val = __secure_tz_entry3(TZ_UPDATE_ID,
-				pwr->active_pwrlevel,
-				priv->bin.total_time, priv->bin.busy_time);
-			}
-#else
 			val = __secure_tz_entry3(TZ_UPDATE_ID,
 				pwr->active_pwrlevel,
 				priv->bin.total_time, priv->bin.busy_time);
-#endif
 	}
 
 	priv->bin.total_time = 0;
@@ -267,21 +187,9 @@
 	 */
 	if (val > 0)
 		val *= pwr->step_mul;
-
-	if ((pwr->constraint.type == KGSL_CONSTRAINT_NONE) ||
-			(time_after(jiffies, pwr->constraint.expires))) {
-
+	if (val)
 		kgsl_pwrctrl_pwrlevel_change(device,
 					     pwr->active_pwrlevel + val);
-		if (pwr->constraint.type != KGSL_CONSTRAINT_NONE) {
-			/* Trace the constraint being un-set by the driver */
-			trace_kgsl_constraint(device,
-				pwr->constraint.type,
-				pwr->active_pwrlevel, 0);
-			/*Invalidate the constraint set */
-			pwr->constraint.type = KGSL_CONSTRAINT_NONE;
-		}
-	}
 }
 
 static void tz_busy(struct kgsl_device *device,
@@ -295,7 +203,7 @@
 {
 	struct tz_priv *priv = pwrscale->priv;
 
-	kgsl_pwrctrl_pwrlevel_change(device, 3);
+	__secure_tz_entry2(TZ_RESET_ID, 0, 0);
 	priv->bin.total_time = 0;
 	priv->bin.busy_time = 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.c	2014-09-21 01:02:11.000000000 +0000
@@ -390,6 +390,16 @@
 	return VM_FAULT_SIGBUS;
 }
 
+static int kgsl_page_alloc_vmflags(struct kgsl_memdesc *memdesc)
+{
+	return VM_RESERVED | VM_DONTEXPAND;
+}
+
+static int kgsl_contiguous_vmflags(struct kgsl_memdesc *memdesc)
+{
+	return VM_RESERVED | VM_IO | VM_PFNMAP | VM_DONTEXPAND;
+}
+
 /*
  * kgsl_page_alloc_unmap_kernel() - Unmap the memory in memdesc
  *
@@ -508,37 +518,76 @@
 	return VM_FAULT_NOPAGE;
 }
 
-static void kgsl_coherent_free(struct kgsl_memdesc *memdesc)
+static void kgsl_ebimem_unmap_kernel(struct kgsl_memdesc *memdesc)
+{
+	mutex_lock(&kernel_map_global_lock);
+	if (!memdesc->hostptr) {
+		BUG_ON(memdesc->hostptr_count);
+		goto done;
+	}
+	memdesc->hostptr_count--;
+	if (memdesc->hostptr_count)
+		goto done;
+
+	iounmap(memdesc->hostptr);
+	memdesc->hostptr = NULL;
+done:
+	mutex_unlock(&kernel_map_global_lock);
+}
+
+static void kgsl_ebimem_free(struct kgsl_memdesc *memdesc)
+
 {
 	kgsl_driver.stats.coherent -= memdesc->size;
-	dma_free_coherent(NULL, memdesc->size,
-			  memdesc->hostptr, memdesc->physaddr);
+	kgsl_ebimem_unmap_kernel(memdesc);
+	/* we certainly do not expect the hostptr to still be mapped */
+	BUG_ON(memdesc->hostptr);
+
+	free_contiguous_memory_by_paddr(memdesc->physaddr);
 }
 
-static void kgsl_cma_coherent_free(struct kgsl_memdesc *memdesc)
+static int kgsl_ebimem_map_kernel(struct kgsl_memdesc *memdesc)
 {
-	if (memdesc->hostptr) {
-		kgsl_driver.stats.coherent -= memdesc->size;
-		dma_free_coherent(memdesc->dev, memdesc->size,
-				memdesc->hostptr, memdesc->physaddr);
+	int ret = 0;
+	mutex_lock(&kernel_map_global_lock);
+	if (!memdesc->hostptr) {
+		memdesc->hostptr = ioremap(memdesc->physaddr, memdesc->size);
+		if (!memdesc->hostptr) {
+			KGSL_CORE_ERR("ioremap failed, addr:0x%p, size:0x%x\n",
+				memdesc->hostptr, memdesc->size);
+			ret = -ENOMEM;
+			goto done;
+		}
 	}
+	memdesc->hostptr_count++;
+done:
+	mutex_unlock(&kernel_map_global_lock);
+	return ret;
+}
+
+static void kgsl_coherent_free(struct kgsl_memdesc *memdesc)
+{
+	kgsl_driver.stats.coherent -= memdesc->size;
+	dma_free_coherent(NULL, memdesc->size,
+			  memdesc->hostptr, memdesc->physaddr);
 }
 
 /* Global - also used by kgsl_drm.c */
 struct kgsl_memdesc_ops kgsl_page_alloc_ops = {
 	.free = kgsl_page_alloc_free,
-	.vmflags = VM_NODUMP | VM_DONTEXPAND | VM_DONTCOPY,
+	.vmflags = kgsl_page_alloc_vmflags,
 	.vmfault = kgsl_page_alloc_vmfault,
 	.map_kernel = kgsl_page_alloc_map_kernel,
 	.unmap_kernel = kgsl_page_alloc_unmap_kernel,
 };
 EXPORT_SYMBOL(kgsl_page_alloc_ops);
 
-/* CMA ops - used during NOMMU mode */
-static struct kgsl_memdesc_ops kgsl_cma_ops = {
-	.free = kgsl_cma_coherent_free,
-	.vmflags = VM_NODUMP | VM_PFNMAP | VM_DONTEXPAND | VM_DONTCOPY,
+static struct kgsl_memdesc_ops kgsl_ebimem_ops = {
+	.free = kgsl_ebimem_free,
+	.vmflags = kgsl_contiguous_vmflags,
 	.vmfault = kgsl_contiguous_vmfault,
+	.map_kernel = kgsl_ebimem_map_kernel,
+	.unmap_kernel = kgsl_ebimem_unmap_kernel,
 };
 
 static struct kgsl_memdesc_ops kgsl_coherent_ops = {
@@ -579,15 +628,13 @@
 			struct kgsl_pagetable *pagetable,
 			size_t size)
 {
-	int order, ret = 0;
-	int page_size, sglen_alloc, sglen = 0;
+	int pcount = 0, order, ret = 0;
+	int j, len, page_size, sglen_alloc, sglen = 0;
+	struct page **pages = NULL;
+	pgprot_t page_prot = pgprot_writecombine(PAGE_KERNEL);
 	void *ptr;
-	size_t len;
 	unsigned int align;
-
-	size = PAGE_ALIGN(size);
-	if (size == 0 || size > UINT_MAX)
-		return -EINVAL;
+	int step = ((VMALLOC_END - VMALLOC_START)/8) >> PAGE_SHIFT;
 
 	align = (memdesc->flags & KGSL_MEMALIGN_MASK) >> KGSL_MEMALIGN_SHIFT;
 
@@ -604,6 +651,7 @@
 
 	sglen_alloc = PAGE_ALIGN(size) >> PAGE_SHIFT;
 
+	memdesc->size = size;
 	memdesc->pagetable = pagetable;
 	memdesc->ops = &kgsl_page_alloc_ops;
 
@@ -615,6 +663,24 @@
 		goto done;
 	}
 
+	/*
+	 * Allocate space to store the list of pages to send to vmap.
+	 * This is an array of pointers so we can t rack 1024 pages per page
+	 * of allocation.  Since allocations can be as large as the user dares,
+	 * we have to use the kmalloc/vmalloc trick here to make sure we can
+	 * get the memory we need.
+	 */
+
+	if ((memdesc->sglen_alloc * sizeof(struct page *)) > PAGE_SIZE)
+		pages = vmalloc(memdesc->sglen_alloc * sizeof(struct page *));
+	else
+		pages = kmalloc(PAGE_SIZE, GFP_KERNEL);
+
+	if (pages == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
 	kmemleak_not_leak(memdesc->sg);
 
 	sg_init_table(memdesc->sg, memdesc->sglen_alloc);
@@ -640,8 +706,6 @@
 		else
 			gfp_mask |= GFP_KERNEL;
 
-		gfp_mask |= __GFP_ZERO;
-
 		page = alloc_pages(gfp_mask, get_order(page_size));
 
 		if (page == NULL) {
@@ -650,14 +714,6 @@
 				continue;
 			}
 
-			/*
-			 * Update sglen and memdesc size,as requested allocation
-			 * not served fully. So that they can be correctly freed
-			 * in kgsl_sharedmem_free().
-			 */
-			memdesc->sglen = sglen;
-			memdesc->size = (size - len);
-
 			KGSL_CORE_ERR(
 				"Out of memory: only allocated %dKB of %dKB requested\n",
 				(size - len) >> 10, size >> 10);
@@ -666,31 +722,73 @@
 			goto done;
 		}
 
-		for (j = 0; j < page_size >> PAGE_SHIFT; j++) {
-			struct page *p = nth_page(page, j);
-			ptr = kmap_atomic(p);
-			dmac_flush_range(ptr, ptr + PAGE_SIZE);
-			kunmap_atomic(ptr);
-		}
+		for (j = 0; j < page_size >> PAGE_SHIFT; j++)
+			pages[pcount++] = nth_page(page, j);
 
 		sg_set_page(&memdesc->sg[sglen++], page, page_size, 0);
 		len -= page_size;
 	}
 
 	memdesc->sglen = sglen;
-	memdesc->size = size;
+
+	/*
+	 * All memory that goes to the user has to be zeroed out before it gets
+	 * exposed to userspace. This means that the memory has to be mapped in
+	 * the kernel, zeroed (memset) and then unmapped.  This also means that
+	 * the dcache has to be flushed to ensure coherency between the kernel
+	 * and user pages. We used to pass __GFP_ZERO to alloc_page which mapped
+	 * zeroed and unmaped each individual page, and then we had to turn
+	 * around and call flush_dcache_page() on that page to clear the caches.
+	 * This was killing us for performance. Instead, we found it is much
+	 * faster to allocate the pages without GFP_ZERO, map a chunk of the
+	 * range ('step' pages), memset it, flush it and then unmap
+	 * - this results in a factor of 4 improvement for speed for large
+	 * buffers. There is a small decrease in speed for small buffers,
+	 * but only on the order of a few microseconds at best. The 'step'
+	 * size is based on a guess at the amount of free vmalloc space, but
+	 * will scale down if there's not enough free space.
+	 */
+	for (j = 0; j < pcount; j += step) {
+		step = min(step, pcount - j);
+
+		ptr = vmap(&pages[j], step, VM_IOREMAP, page_prot);
+
+		if (ptr != NULL) {
+			memset(ptr, 0, step * PAGE_SIZE);
+			dmac_flush_range(ptr, ptr + step * PAGE_SIZE);
+			vunmap(ptr);
+		} else {
+			int k;
+			/* Very, very, very slow path */
+
+			for (k = j; k < j + step; k++) {
+				ptr = kmap_atomic(pages[k]);
+				memset(ptr, 0, PAGE_SIZE);
+				dmac_flush_range(ptr, ptr + PAGE_SIZE);
+				kunmap_atomic(ptr);
+			}
+			/* scale down the step size to avoid this path */
+			if (step > 1)
+				step >>= 1;
+		}
+	}
 
 	outer_cache_range_op_sg(memdesc->sg, memdesc->sglen,
 				KGSL_CACHE_OP_FLUSH);
 
+	KGSL_STATS_ADD(size, kgsl_driver.stats.page_alloc,
+		kgsl_driver.stats.page_alloc_max);
+
 	order = get_order(size);
 
 	if (order < 16)
 		kgsl_driver.stats.histogram[order]++;
 
 done:
-	KGSL_STATS_ADD(memdesc->size, kgsl_driver.stats.page_alloc,
-		kgsl_driver.stats.page_alloc_max);
+	if ((memdesc->sglen_alloc * sizeof(struct page *)) > PAGE_SIZE)
+		vfree(pages);
+	else
+		kfree(pages);
 
 	if (ret)
 		kgsl_sharedmem_free(memdesc);
@@ -787,6 +885,77 @@
 }
 EXPORT_SYMBOL(kgsl_sharedmem_free);
 
+static int
+_kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable, size_t size)
+{
+	int result = 0;
+
+	memdesc->size = size;
+	memdesc->pagetable = pagetable;
+	memdesc->ops = &kgsl_ebimem_ops;
+	memdesc->physaddr = allocate_contiguous_ebi_nomap(size, SZ_8K);
+
+	if (memdesc->physaddr == 0) {
+		KGSL_CORE_ERR("allocate_contiguous_ebi_nomap(%d) failed\n",
+			size);
+		return -ENOMEM;
+	}
+
+	result = memdesc_sg_phys(memdesc, memdesc->physaddr, size);
+
+	if (result)
+		goto err;
+
+	KGSL_STATS_ADD(size, kgsl_driver.stats.coherent,
+		kgsl_driver.stats.coherent_max);
+
+err:
+	if (result)
+		kgsl_sharedmem_free(memdesc);
+
+	return result;
+}
+
+int
+kgsl_sharedmem_ebimem_user(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable,
+			size_t size)
+{
+	size = ALIGN(size, PAGE_SIZE);
+	if (size == 0)
+		return -EINVAL;
+
+	return _kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+}
+EXPORT_SYMBOL(kgsl_sharedmem_ebimem_user);
+
+int
+kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+		struct kgsl_pagetable *pagetable, size_t size)
+{
+	int result;
+	size = ALIGN(size, 8192);
+	if (size == 0)
+		return -EINVAL;
+
+	result = _kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+
+	if (result)
+		return result;
+
+	result = kgsl_ebimem_map_kernel(memdesc);
+
+	if (result) {
+		KGSL_CORE_ERR("hostptr mapping failed\n");
+		kgsl_sharedmem_free(memdesc);
+		return result;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(kgsl_sharedmem_ebimem);
+
 int
 kgsl_sharedmem_readl(const struct kgsl_memdesc *memdesc,
 			uint32_t *dst,
@@ -915,42 +1084,3 @@
 		snprintf(name, name_size, "unknown(%3d)", type);
 }
 EXPORT_SYMBOL(kgsl_get_memory_usage);
-
-int kgsl_cma_alloc_coherent(struct kgsl_device *device,
-			struct kgsl_memdesc *memdesc,
-			struct kgsl_pagetable *pagetable, size_t size)
-{
-	int result = 0;
-
-	if (size == 0)
-		return -EINVAL;
-
-	memdesc->size = size;
-	memdesc->pagetable = pagetable;
-	memdesc->ops = &kgsl_cma_ops;
-	memdesc->dev = device->dev->parent;
-
-	memdesc->hostptr = dma_alloc_coherent(memdesc->dev, size,
-					&memdesc->physaddr, GFP_KERNEL);
-
-	if (memdesc->hostptr == NULL) {
-		result = -ENOMEM;
-		goto err;
-	}
-
-	result = memdesc_sg_phys(memdesc, memdesc->physaddr, size);
-	if (result)
-		goto err;
-
-	/* Record statistics */
-
-	KGSL_STATS_ADD(size, kgsl_driver.stats.coherent,
-		       kgsl_driver.stats.coherent_max);
-
-err:
-	if (result)
-		kgsl_sharedmem_free(memdesc);
-
-	return result;
-}
-EXPORT_SYMBOL(kgsl_cma_alloc_coherent);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.h	2014-09-21 01:02:11.000000000 +0000
@@ -41,9 +41,13 @@
 
 int kgsl_sharedmem_alloc_coherent(struct kgsl_memdesc *memdesc, size_t size);
 
-int kgsl_cma_alloc_coherent(struct kgsl_device *device,
-			struct kgsl_memdesc *memdesc,
-			struct kgsl_pagetable *pagetable, size_t size);
+int kgsl_sharedmem_ebimem_user(struct kgsl_memdesc *memdesc,
+			     struct kgsl_pagetable *pagetable,
+			     size_t size);
+
+int kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable,
+			size_t size);
 
 void kgsl_sharedmem_free(struct kgsl_memdesc *memdesc);
 
@@ -137,13 +141,15 @@
 
 static inline void *kgsl_sg_alloc(unsigned int sglen)
 {
-	if ((sglen == 0) || (sglen >= ULONG_MAX / sizeof(struct scatterlist)))
-		return NULL;
-
 	if ((sglen * sizeof(struct scatterlist)) <  PAGE_SIZE)
 		return kzalloc(sglen * sizeof(struct scatterlist), GFP_KERNEL);
-	else
-		return vmalloc(sglen * sizeof(struct scatterlist));
+	else {
+		void *ptr = vmalloc(sglen * sizeof(struct scatterlist));
+		if (ptr)
+			memset(ptr, 0, sglen * sizeof(struct scatterlist));
+
+		return ptr;
+	}
 }
 
 static inline void kgsl_sg_free(void *ptr, unsigned int sglen)
@@ -159,7 +165,7 @@
 		phys_addr_t physaddr, unsigned int size)
 {
 	memdesc->sg = kgsl_sg_alloc(1);
-	if (memdesc->sg == NULL)
+	if (!memdesc->sg)
 		return -ENOMEM;
 
 	kmemleak_not_leak(memdesc->sg);
@@ -249,16 +255,14 @@
 }
 
 static inline int
-kgsl_allocate(struct kgsl_device *device, struct kgsl_memdesc *memdesc,
+kgsl_allocate(struct kgsl_memdesc *memdesc,
 		struct kgsl_pagetable *pagetable, size_t size)
 {
 	int ret;
 	memdesc->priv |= (KGSL_MEMTYPE_KERNEL << KGSL_MEMTYPE_SHIFT);
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE) {
-		size = ALIGN(size, PAGE_SIZE * 2);
-		return kgsl_cma_alloc_coherent(device, memdesc, pagetable,
-						size);
-	}
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
+		return kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+
 	ret = kgsl_sharedmem_page_alloc(memdesc, pagetable, size);
 	if (ret)
 		return ret;
@@ -274,8 +278,7 @@
 }
 
 static inline int
-kgsl_allocate_user(struct kgsl_device *device,
-		struct kgsl_memdesc *memdesc,
+kgsl_allocate_user(struct kgsl_memdesc *memdesc,
 		struct kgsl_pagetable *pagetable,
 		size_t size, unsigned int flags)
 {
@@ -286,10 +289,8 @@
 
 	memdesc->flags = flags;
 
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE) {
-		size = ALIGN(size, PAGE_SIZE);
-		ret = kgsl_cma_alloc_coherent(device, memdesc, pagetable, size);
-	}
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
+		ret = kgsl_sharedmem_ebimem_user(memdesc, pagetable, size);
 	else
 		ret = kgsl_sharedmem_page_alloc_user(memdesc, pagetable, size);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_snapshot.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_snapshot.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_snapshot.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_snapshot.c	2014-09-21 01:02:11.000000000 +0000
@@ -210,8 +210,10 @@
 	header->ctxtcount = ctxtcount;
 
 	_ctxtptr = snapshot + sizeof(*header);
+
 	/* append information for the global context */
 	snapshot_context_info(KGSL_MEMSTORE_GLOBAL, NULL, device);
+
 	/* append information for each context */
 
 	read_lock(&device->context_lock);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.c	2014-09-21 01:02:11.000000000 +0000
@@ -13,9 +13,12 @@
 
 #include <linux/err.h>
 #include <linux/file.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
+#include <asm/current.h>
+
 #include "kgsl_sync.h"
 
 struct sync_pt *kgsl_sync_pt_create(struct sync_timeline *timeline,
@@ -87,7 +90,9 @@
 	void *priv, u32 context_id, u32 timestamp, u32 type)
 {
 	struct kgsl_fence_event_priv *ev = priv;
-	kgsl_sync_timeline_signal(ev->context->timeline, ev->timestamp);
+
+	/* Signal time timeline for every event type */
+	kgsl_sync_timeline_signal(ev->context->timeline, timestamp);
 	kgsl_context_put(ev->context);
 	kfree(ev);
 }
@@ -125,8 +130,10 @@
 
 	context = kgsl_context_get_owner(owner, context_id);
 
-	if (context == NULL)
-		goto fail_pt;
+	if (context == NULL) {
+		kfree(event);
+		return -EINVAL;
+	}
 
 	event->context = context;
 	event->timestamp = timestamp;
@@ -185,6 +192,35 @@
 	return ret;
 }
 
+static unsigned int kgsl_sync_get_timestamp(
+	struct kgsl_sync_timeline *ktimeline, enum kgsl_timestamp_type type)
+{
+	struct kgsl_context *context = idr_find(&ktimeline->device->context_idr,
+						ktimeline->context_id);
+	if (context == NULL)
+		return 0;
+
+	return kgsl_readtimestamp(ktimeline->device, context, type);
+}
+
+static void kgsl_sync_timeline_value_str(struct sync_timeline *sync_timeline,
+					 char *str, int size)
+{
+	struct kgsl_sync_timeline *ktimeline =
+		(struct kgsl_sync_timeline *) sync_timeline;
+	unsigned int timestamp_retired = kgsl_sync_get_timestamp(ktimeline,
+		KGSL_TIMESTAMP_RETIRED);
+	snprintf(str, size, "%u retired:%u", ktimeline->last_timestamp,
+		timestamp_retired);
+}
+
+static void kgsl_sync_pt_value_str(struct sync_pt *sync_pt,
+				   char *str, int size)
+{
+	struct kgsl_sync_pt *kpt = (struct kgsl_sync_pt *) sync_pt;
+	snprintf(str, size, "%u", kpt->timestamp);
+}
+
 static void kgsl_sync_timeline_release_obj(struct sync_timeline *sync_timeline)
 {
 	/*
@@ -199,6 +235,8 @@
 	.dup = kgsl_sync_pt_dup,
 	.has_signaled = kgsl_sync_pt_has_signaled,
 	.compare = kgsl_sync_pt_compare,
+	.timeline_value_str = kgsl_sync_timeline_value_str,
+	.pt_value_str = kgsl_sync_pt_value_str,
 	.release_obj = kgsl_sync_timeline_release_obj,
 };
 
@@ -206,13 +244,25 @@
 {
 	struct kgsl_sync_timeline *ktimeline;
 
+	/* Generate a name which includes the thread name, thread id, process
+	 * name, process id, and context id. This makes it possible to
+	 * identify the context of a timeline in the sync dump. */
+	char ktimeline_name[sizeof(context->timeline->name)] = {};
+	snprintf(ktimeline_name, sizeof(ktimeline_name),
+		"%s_%.15s(%d)-%.15s(%d)-%d",
+		context->device->name,
+		current->group_leader->comm, current->group_leader->pid,
+		current->comm, current->pid, context->id);
+
 	context->timeline = sync_timeline_create(&kgsl_sync_timeline_ops,
-		(int) sizeof(struct kgsl_sync_timeline), "kgsl-timeline");
+		(int) sizeof(struct kgsl_sync_timeline), ktimeline_name);
 	if (context->timeline == NULL)
 		return -EINVAL;
 
 	ktimeline = (struct kgsl_sync_timeline *) context->timeline;
 	ktimeline->last_timestamp = 0;
+	ktimeline->device = context->dev_priv->device;
+	ktimeline->context_id = context->id;
 
 	return 0;
 }
@@ -255,7 +305,7 @@
 		return ERR_PTR(-EINVAL);
 
 	/* create the waiter */
-	kwaiter = kzalloc(sizeof(*kwaiter), GFP_ATOMIC);
+	kwaiter = kzalloc(sizeof(*kwaiter), GFP_KERNEL);
 	if (kwaiter == NULL) {
 		sync_fence_put(fence);
 		return ERR_PTR(-ENOMEM);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,6 +19,8 @@
 struct kgsl_sync_timeline {
 	struct sync_timeline timeline;
 	unsigned int last_timestamp;
+	struct kgsl_device *device;
+	u32 context_id;
 };
 
 struct kgsl_sync_pt {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -676,36 +676,6 @@
 	)
 );
 
-TRACE_EVENT(kgsl_constraint,
-
-	TP_PROTO(struct kgsl_device *device, unsigned int type,
-		unsigned int value, unsigned int on),
-
-	TP_ARGS(device, type, value, on),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(unsigned int, type)
-		__field(unsigned int, value)
-		__field(unsigned int, on)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->type = type;
-		__entry->value = value;
-		__entry->on = on;
-	),
-
-	TP_printk(
-		"d_name=%s constraint_type=%s constraint_value=%u status=%s",
-		__get_str(device_name),
-		__print_symbolic(__entry->type, KGSL_CONSTRAINT_TYPES),
-		__entry->value,
-		__entry->on ? "ON" : "OFF"
-	)
-);
-
 TRACE_EVENT(kgsl_mmu_pagefault,
 
 	TP_PROTO(struct kgsl_device *device, unsigned int page,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/z180.c flo-ElementalX-5.00-patched/drivers/gpu/msm/z180.c
--- flo-ElementalX-5.00/drivers/gpu/msm/z180.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/z180.c	2014-09-21 01:02:11.000000000 +0000
@@ -514,7 +514,7 @@
 	z180_cmdwindow_write(device, ADDR_VGV3_CONTROL, 0);
 error:
 	kgsl_trace_issueibcmds(device, context->id, cmdbatch,
-		*timestamp, cmdbatch ? cmdbatch->flags : 0, result, 0);
+		*timestamp, cmdbatch->flags, result, 0);
 
 	kgsl_active_count_put(device);
 error_active_count:
@@ -614,6 +614,7 @@
 
 	z180_cmdstream_start(device);
 
+	mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
 
diff -urN flo-ElementalX-5.00/drivers/hid/hid-multitouch.c flo-ElementalX-5.00-patched/drivers/hid/hid-multitouch.c
--- flo-ElementalX-5.00/drivers/hid/hid-multitouch.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/hid/hid-multitouch.c	2016-06-01 16:27:31.000000000 +0000
@@ -278,9 +278,8 @@
 static void set_last_slot_field(struct hid_usage *usage, struct mt_device *td,
 		struct hid_input *hi)
 {
-	if ((BIT_WORD(usage->hid)) < (sizeof(hi->input->absbit) / sizeof(int)))
-		if (!test_bit(usage->hid, hi->input->absbit))
-			td->last_slot_field = usage->hid;
+	if (!test_bit(usage->hid, hi->input->absbit))
+		td->last_slot_field = usage->hid;
 }
 
 static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
diff -urN flo-ElementalX-5.00/drivers/i2c/busses/i2c-mv64xxx.c flo-ElementalX-5.00-patched/drivers/i2c/busses/i2c-mv64xxx.c
--- flo-ElementalX-5.00/drivers/i2c/busses/i2c-mv64xxx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/i2c/busses/i2c-mv64xxx.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,618 +0,0 @@
-/*
- * Driver for the i2c controller on the Marvell line of host bridges
- * (e.g, gt642[46]0, mv643[46]0, mv644[46]0, and Orion SoC family).
- *
- * Author: Mark A. Greer <mgreer@mvista.com>
- *
- * 2005 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/i2c.h>
-#include <linux/interrupt.h>
-#include <linux/mv643xx_i2c.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-
-/* Register defines */
-#define	MV64XXX_I2C_REG_SLAVE_ADDR			0x00
-#define	MV64XXX_I2C_REG_DATA				0x04
-#define	MV64XXX_I2C_REG_CONTROL				0x08
-#define	MV64XXX_I2C_REG_STATUS				0x0c
-#define	MV64XXX_I2C_REG_BAUD				0x0c
-#define	MV64XXX_I2C_REG_EXT_SLAVE_ADDR			0x10
-#define	MV64XXX_I2C_REG_SOFT_RESET			0x1c
-
-#define	MV64XXX_I2C_REG_CONTROL_ACK			0x00000004
-#define	MV64XXX_I2C_REG_CONTROL_IFLG			0x00000008
-#define	MV64XXX_I2C_REG_CONTROL_STOP			0x00000010
-#define	MV64XXX_I2C_REG_CONTROL_START			0x00000020
-#define	MV64XXX_I2C_REG_CONTROL_TWSIEN			0x00000040
-#define	MV64XXX_I2C_REG_CONTROL_INTEN			0x00000080
-
-/* Ctlr status values */
-#define	MV64XXX_I2C_STATUS_BUS_ERR			0x00
-#define	MV64XXX_I2C_STATUS_MAST_START			0x08
-#define	MV64XXX_I2C_STATUS_MAST_REPEAT_START		0x10
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK		0x18
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK		0x20
-#define	MV64XXX_I2C_STATUS_MAST_WR_ACK			0x28
-#define	MV64XXX_I2C_STATUS_MAST_WR_NO_ACK		0x30
-#define	MV64XXX_I2C_STATUS_MAST_LOST_ARB		0x38
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK		0x40
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK		0x48
-#define	MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK		0x50
-#define	MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK		0x58
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK		0xd0
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_NO_ACK	0xd8
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK		0xe0
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_NO_ACK	0xe8
-#define	MV64XXX_I2C_STATUS_NO_STATUS			0xf8
-
-/* Driver states */
-enum {
-	MV64XXX_I2C_STATE_INVALID,
-	MV64XXX_I2C_STATE_IDLE,
-	MV64XXX_I2C_STATE_WAITING_FOR_START_COND,
-	MV64XXX_I2C_STATE_WAITING_FOR_RESTART,
-	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA,
-};
-
-/* Driver actions */
-enum {
-	MV64XXX_I2C_ACTION_INVALID,
-	MV64XXX_I2C_ACTION_CONTINUE,
-	MV64XXX_I2C_ACTION_SEND_START,
-	MV64XXX_I2C_ACTION_SEND_RESTART,
-	MV64XXX_I2C_ACTION_SEND_ADDR_1,
-	MV64XXX_I2C_ACTION_SEND_ADDR_2,
-	MV64XXX_I2C_ACTION_SEND_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA_STOP,
-	MV64XXX_I2C_ACTION_SEND_STOP,
-};
-
-struct mv64xxx_i2c_data {
-	int			irq;
-	u32			state;
-	u32			action;
-	u32			aborting;
-	u32			cntl_bits;
-	void __iomem		*reg_base;
-	u32			reg_base_p;
-	u32			reg_size;
-	u32			addr1;
-	u32			addr2;
-	u32			bytes_left;
-	u32			byte_posn;
-	u32			send_stop;
-	u32			block;
-	int			rc;
-	u32			freq_m;
-	u32			freq_n;
-	wait_queue_head_t	waitq;
-	spinlock_t		lock;
-	struct i2c_msg		*msg;
-	struct i2c_adapter	adapter;
-};
-
-/*
- *****************************************************************************
- *
- *	Finite State Machine & Interrupt Routines
- *
- *****************************************************************************
- */
-
-/* Reset hardware and initialize FSM */
-static void
-mv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)
-{
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SOFT_RESET);
-	writel((((drv_data->freq_m & 0xf) << 3) | (drv_data->freq_n & 0x7)),
-		drv_data->reg_base + MV64XXX_I2C_REG_BAUD);
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SLAVE_ADDR);
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_EXT_SLAVE_ADDR);
-	writel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,
-		drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-	drv_data->state = MV64XXX_I2C_STATE_IDLE;
-}
-
-static void
-mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
-{
-	/*
-	 * If state is idle, then this is likely the remnants of an old
-	 * operation that driver has given up on or the user has killed.
-	 * If so, issue the stop condition and go to idle.
-	 */
-	if (drv_data->state == MV64XXX_I2C_STATE_IDLE) {
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		return;
-	}
-
-	/* The status from the ctlr [mostly] tells us what to do next */
-	switch (status) {
-	/* Start condition interrupt */
-	case MV64XXX_I2C_STATUS_MAST_START: /* 0x08 */
-	case MV64XXX_I2C_STATUS_MAST_REPEAT_START: /* 0x10 */
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;
-		drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;
-		break;
-
-	/* Performing a write */
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK: /* 0x18 */
-		if (drv_data->msg->flags & I2C_M_TEN) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK: /* 0xd0 */
-	case MV64XXX_I2C_STATUS_MAST_WR_ACK: /* 0x28 */
-		if ((drv_data->bytes_left == 0)
-				|| (drv_data->aborting
-					&& (drv_data->byte_posn != 0))) {
-			if (drv_data->send_stop) {
-				drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-				drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			} else {
-				drv_data->action =
-					MV64XXX_I2C_ACTION_SEND_RESTART;
-				drv_data->state =
-					MV64XXX_I2C_STATE_WAITING_FOR_RESTART;
-			}
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;
-			drv_data->bytes_left--;
-		}
-		break;
-
-	/* Performing a read */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK: /* 40 */
-		if (drv_data->msg->flags & I2C_M_TEN) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK: /* 0xe0 */
-		if (drv_data->bytes_left == 0) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-			drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK: /* 0x50 */
-		if (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)
-			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
-		else {
-			drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;
-			drv_data->bytes_left--;
-		}
-		drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;
-
-		if ((drv_data->bytes_left == 1) || drv_data->aborting)
-			drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;
-		break;
-
-	case MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK: /* 0x58 */
-		drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;
-		drv_data->state = MV64XXX_I2C_STATE_IDLE;
-		break;
-
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK: /* 0x20 */
-	case MV64XXX_I2C_STATUS_MAST_WR_NO_ACK: /* 30 */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK: /* 48 */
-		/* Doesn't seem to be a device at other end */
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		drv_data->state = MV64XXX_I2C_STATE_IDLE;
-		drv_data->rc = -ENODEV;
-		break;
-
-	default:
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, "
-			"status: 0x%x, addr: 0x%x, flags: 0x%x\n",
-			 drv_data->state, status, drv_data->msg->addr,
-			 drv_data->msg->flags);
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		mv64xxx_i2c_hw_init(drv_data);
-		drv_data->rc = -EIO;
-	}
-}
-
-static void
-mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
-{
-	switch(drv_data->action) {
-	case MV64XXX_I2C_ACTION_SEND_RESTART:
-		drv_data->cntl_bits |= MV64XXX_I2C_REG_CONTROL_START;
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-
-	case MV64XXX_I2C_ACTION_CONTINUE:
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_START:
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_ADDR_1:
-		writel(drv_data->addr1,
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_ADDR_2:
-		writel(drv_data->addr2,
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_DATA:
-		writel(drv_data->msg->buf[drv_data->byte_posn++],
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_RCV_DATA:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_RCV_DATA_STOP:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-
-	case MV64XXX_I2C_ACTION_INVALID:
-	default:
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx_i2c_do_action: Invalid action: %d\n",
-			drv_data->action);
-		drv_data->rc = -EIO;
-		/* FALLTHRU */
-	case MV64XXX_I2C_ACTION_SEND_STOP:
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-	}
-}
-
-static irqreturn_t
-mv64xxx_i2c_intr(int irq, void *dev_id)
-{
-	struct mv64xxx_i2c_data	*drv_data = dev_id;
-	unsigned long	flags;
-	u32		status;
-	irqreturn_t	rc = IRQ_NONE;
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
-						MV64XXX_I2C_REG_CONTROL_IFLG) {
-		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
-		mv64xxx_i2c_fsm(drv_data, status);
-		mv64xxx_i2c_do_action(drv_data);
-		rc = IRQ_HANDLED;
-	}
-	spin_unlock_irqrestore(&drv_data->lock, flags);
-
-	return rc;
-}
-
-/*
- *****************************************************************************
- *
- *	I2C Msg Execution Routines
- *
- *****************************************************************************
- */
-static void
-mv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,
-	struct i2c_msg *msg)
-{
-	u32	dir = 0;
-
-	drv_data->msg = msg;
-	drv_data->byte_posn = 0;
-	drv_data->bytes_left = msg->len;
-	drv_data->aborting = 0;
-	drv_data->rc = 0;
-	drv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |
-		MV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;
-
-	if (msg->flags & I2C_M_RD)
-		dir = 1;
-
-	if (msg->flags & I2C_M_TEN) {
-		drv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;
-		drv_data->addr2 = (u32)msg->addr & 0xff;
-	} else {
-		drv_data->addr1 = ((u32)msg->addr & 0x7f) << 1 | dir;
-		drv_data->addr2 = 0;
-	}
-}
-
-static void
-mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
-{
-	long		time_left;
-	unsigned long	flags;
-	char		abort = 0;
-
-	time_left = wait_event_interruptible_timeout(drv_data->waitq,
-		!drv_data->block, drv_data->adapter.timeout);
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	if (!time_left) { /* Timed out */
-		drv_data->rc = -ETIMEDOUT;
-		abort = 1;
-	} else if (time_left < 0) { /* Interrupted/Error */
-		drv_data->rc = time_left; /* errno value */
-		abort = 1;
-	}
-
-	if (abort && drv_data->block) {
-		drv_data->aborting = 1;
-		spin_unlock_irqrestore(&drv_data->lock, flags);
-
-		time_left = wait_event_timeout(drv_data->waitq,
-			!drv_data->block, drv_data->adapter.timeout);
-
-		if ((time_left <= 0) && drv_data->block) {
-			drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			dev_err(&drv_data->adapter.dev,
-				"mv64xxx: I2C bus locked, block: %d, "
-				"time_left: %d\n", drv_data->block,
-				(int)time_left);
-			mv64xxx_i2c_hw_init(drv_data);
-		}
-	} else
-		spin_unlock_irqrestore(&drv_data->lock, flags);
-}
-
-static int
-mv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,
-				int is_first, int is_last)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	mv64xxx_i2c_prepare_for_io(drv_data, msg);
-
-	if (unlikely(msg->flags & I2C_M_NOSTART)) { /* Skip start/addr phases */
-		if (drv_data->msg->flags & I2C_M_RD) {
-			/* No action to do, wait for slave to send a byte */
-			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;
-			drv_data->bytes_left--;
-		}
-	} else {
-		if (is_first) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_START;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_START_COND;
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;
-		}
-	}
-
-	drv_data->send_stop = is_last;
-	drv_data->block = 1;
-	mv64xxx_i2c_do_action(drv_data);
-	spin_unlock_irqrestore(&drv_data->lock, flags);
-
-	mv64xxx_i2c_wait_for_completion(drv_data);
-	return drv_data->rc;
-}
-
-/*
- *****************************************************************************
- *
- *	I2C Core Support Routines (Interface to higher level I2C code)
- *
- *****************************************************************************
- */
-static u32
-mv64xxx_i2c_functionality(struct i2c_adapter *adap)
-{
-	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
-}
-
-static int
-mv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-	int	i, rc;
-
-	for (i = 0; i < num; i++) {
-		rc = mv64xxx_i2c_execute_msg(drv_data, &msgs[i],
-						i == 0, i + 1 == num);
-		if (rc < 0)
-			return rc;
-	}
-
-	return num;
-}
-
-static const struct i2c_algorithm mv64xxx_i2c_algo = {
-	.master_xfer = mv64xxx_i2c_xfer,
-	.functionality = mv64xxx_i2c_functionality,
-};
-
-/*
- *****************************************************************************
- *
- *	Driver Interface & Early Init Routines
- *
- *****************************************************************************
- */
-static int __devinit
-mv64xxx_i2c_map_regs(struct platform_device *pd,
-	struct mv64xxx_i2c_data *drv_data)
-{
-	int size;
-	struct resource	*r = platform_get_resource(pd, IORESOURCE_MEM, 0);
-
-	if (!r)
-		return -ENODEV;
-
-	size = resource_size(r);
-
-	if (!request_mem_region(r->start, size, drv_data->adapter.name))
-		return -EBUSY;
-
-	drv_data->reg_base = ioremap(r->start, size);
-	drv_data->reg_base_p = r->start;
-	drv_data->reg_size = size;
-
-	return 0;
-}
-
-static void
-mv64xxx_i2c_unmap_regs(struct mv64xxx_i2c_data *drv_data)
-{
-	if (drv_data->reg_base) {
-		iounmap(drv_data->reg_base);
-		release_mem_region(drv_data->reg_base_p, drv_data->reg_size);
-	}
-
-	drv_data->reg_base = NULL;
-	drv_data->reg_base_p = 0;
-}
-
-static int __devinit
-mv64xxx_i2c_probe(struct platform_device *pd)
-{
-	struct mv64xxx_i2c_data		*drv_data;
-	struct mv64xxx_i2c_pdata	*pdata = pd->dev.platform_data;
-	int	rc;
-
-	if ((pd->id != 0) || !pdata)
-		return -ENODEV;
-
-	drv_data = kzalloc(sizeof(struct mv64xxx_i2c_data), GFP_KERNEL);
-	if (!drv_data)
-		return -ENOMEM;
-
-	if (mv64xxx_i2c_map_regs(pd, drv_data)) {
-		rc = -ENODEV;
-		goto exit_kfree;
-	}
-
-	strlcpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME " adapter",
-		sizeof(drv_data->adapter.name));
-
-	init_waitqueue_head(&drv_data->waitq);
-	spin_lock_init(&drv_data->lock);
-
-	drv_data->freq_m = pdata->freq_m;
-	drv_data->freq_n = pdata->freq_n;
-	drv_data->irq = platform_get_irq(pd, 0);
-	if (drv_data->irq < 0) {
-		rc = -ENXIO;
-		goto exit_unmap_regs;
-	}
-	drv_data->adapter.dev.parent = &pd->dev;
-	drv_data->adapter.algo = &mv64xxx_i2c_algo;
-	drv_data->adapter.owner = THIS_MODULE;
-	drv_data->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
-	drv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);
-	drv_data->adapter.nr = pd->id;
-	platform_set_drvdata(pd, drv_data);
-	i2c_set_adapdata(&drv_data->adapter, drv_data);
-
-	mv64xxx_i2c_hw_init(drv_data);
-
-	if (request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,
-			MV64XXX_I2C_CTLR_NAME, drv_data)) {
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx: Can't register intr handler irq: %d\n",
-			drv_data->irq);
-		rc = -EINVAL;
-		goto exit_unmap_regs;
-	} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);
-		goto exit_free_irq;
-	}
-
-	return 0;
-
-	exit_free_irq:
-		free_irq(drv_data->irq, drv_data);
-	exit_unmap_regs:
-		mv64xxx_i2c_unmap_regs(drv_data);
-	exit_kfree:
-		kfree(drv_data);
-	return rc;
-}
-
-static int __devexit
-mv64xxx_i2c_remove(struct platform_device *dev)
-{
-	struct mv64xxx_i2c_data		*drv_data = platform_get_drvdata(dev);
-	int	rc;
-
-	rc = i2c_del_adapter(&drv_data->adapter);
-	free_irq(drv_data->irq, drv_data);
-	mv64xxx_i2c_unmap_regs(drv_data);
-	kfree(drv_data);
-
-	return rc;
-}
-
-static struct platform_driver mv64xxx_i2c_driver = {
-	.probe	= mv64xxx_i2c_probe,
-	.remove	= __devexit_p(mv64xxx_i2c_remove),
-	.driver	= {
-		.owner	= THIS_MODULE,
-		.name	= MV64XXX_I2C_CTLR_NAME,
-	},
-};
-
-module_platform_driver(mv64xxx_i2c_driver);
-
-MODULE_AUTHOR("Mark A. Greer <mgreer@mvista.com>");
-MODULE_DESCRIPTION("Marvell mv64xxx host bridge i2c ctlr driver");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/drivers/input/touchscreen/ektf3k.c flo-ElementalX-5.00-patched/drivers/input/touchscreen/ektf3k.c
--- flo-ElementalX-5.00/drivers/input/touchscreen/ektf3k.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/input/touchscreen/ektf3k.c	2016-06-01 15:49:14.000000000 +0000
@@ -1658,7 +1658,7 @@
               fbits = fbits >> 1;
               idx += 3;
 	    }
-
+	  input_mt_report_pointer_emulation(ts->input_dev, true);
           input_sync(idev);
 	} // checksum
 	else {
@@ -1718,6 +1718,7 @@
 			fbits = fbits >> 1;
 			idx += 3;
 		}
+		input_mt_report_pointer_emulation(ts->input_dev, true);
 		input_sync(idev);
 	} // checksum
 
@@ -2254,10 +2255,15 @@
 	ts->input_dev->name = "elan-touchscreen";  
 
 	//set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
 	ts->abs_x_max =  pdata->abs_x_max;
 	ts->abs_y_max = pdata->abs_y_max;
 	touch_debug(DEBUG_INFO, "[Elan] Max X=%d, Max Y=%d\n", ts->abs_x_max, ts->abs_y_max);
 
+	input_set_abs_params(ts->input_dev, ABS_X, pdata->abs_y_min, pdata->abs_y_max, 0, 0); // for 800 * 1280 
+	input_set_abs_params(ts->input_dev, ABS_Y, pdata->abs_x_min, pdata->abs_x_max, 0, 0); // for 800 * 1280 
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, MAX_FINGER_PRESSURE, 0, 0);
+
 	input_mt_init_slots(ts->input_dev, FINGER_NUM);
 	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, pdata->abs_y_min,  pdata->abs_y_max, 0, 0); // for 800 * 1280 
 	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, pdata->abs_x_min,  pdata->abs_x_max, 0, 0);// for 800 * 1280 
diff -urN flo-ElementalX-5.00/drivers/media/common/saa7146_video.c flo-ElementalX-5.00-patched/drivers/media/common/saa7146_video.c
--- flo-ElementalX-5.00/drivers/media/common/saa7146_video.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/media/common/saa7146_video.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,1435 +0,0 @@
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <media/saa7146_vv.h>
-#include <media/v4l2-chip-ident.h>
-#include <linux/module.h>
-
-static int max_memory = 32;
-
-module_param(max_memory, int, 0644);
-MODULE_PARM_DESC(max_memory, "maximum memory usage for capture buffers (default: 32Mb)");
-
-#define IS_CAPTURE_ACTIVE(fh) \
-	(((vv->video_status & STATUS_CAPTURE) != 0) && (vv->video_fh == fh))
-
-#define IS_OVERLAY_ACTIVE(fh) \
-	(((vv->video_status & STATUS_OVERLAY) != 0) && (vv->video_fh == fh))
-
-/* format descriptions for capture and preview */
-static struct saa7146_format formats[] = {
-	{
-		.name		= "RGB-8 (3-3-2)",
-		.pixelformat	= V4L2_PIX_FMT_RGB332,
-		.trans		= RGB08_COMPOSED,
-		.depth		= 8,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-16 (5/B-6/G-5/R)",
-		.pixelformat	= V4L2_PIX_FMT_RGB565,
-		.trans		= RGB16_COMPOSED,
-		.depth		= 16,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-24 (B-G-R)",
-		.pixelformat	= V4L2_PIX_FMT_BGR24,
-		.trans		= RGB24_COMPOSED,
-		.depth		= 24,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-32 (B-G-R)",
-		.pixelformat	= V4L2_PIX_FMT_BGR32,
-		.trans		= RGB32_COMPOSED,
-		.depth		= 32,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-32 (R-G-B)",
-		.pixelformat	= V4L2_PIX_FMT_RGB32,
-		.trans		= RGB32_COMPOSED,
-		.depth		= 32,
-		.flags		= 0,
-		.swap		= 0x2,
-	}, {
-		.name		= "Greyscale-8",
-		.pixelformat	= V4L2_PIX_FMT_GREY,
-		.trans		= Y8,
-		.depth		= 8,
-		.flags		= 0,
-	}, {
-		.name		= "YUV 4:2:2 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YUV422P,
-		.trans		= YUV422_DECOMPOSED,
-		.depth		= 16,
-		.flags		= FORMAT_BYTE_SWAP|FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YVU 4:2:0 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YVU420,
-		.trans		= YUV420_DECOMPOSED,
-		.depth		= 12,
-		.flags		= FORMAT_BYTE_SWAP|FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YUV 4:2:0 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YUV420,
-		.trans		= YUV420_DECOMPOSED,
-		.depth		= 12,
-		.flags		= FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YUV 4:2:2 (U-Y-V-Y)",
-		.pixelformat	= V4L2_PIX_FMT_UYVY,
-		.trans		= YUV422_COMPOSED,
-		.depth		= 16,
-		.flags		= 0,
-	}
-};
-
-/* unfortunately, the saa7146 contains a bug which prevents it from doing on-the-fly byte swaps.
-   due to this, it's impossible to provide additional *packed* formats, which are simply byte swapped
-   (like V4L2_PIX_FMT_YUYV) ... 8-( */
-
-static int NUM_FORMATS = sizeof(formats)/sizeof(struct saa7146_format);
-
-struct saa7146_format* saa7146_format_by_fourcc(struct saa7146_dev *dev, int fourcc)
-{
-	int i, j = NUM_FORMATS;
-
-	for (i = 0; i < j; i++) {
-		if (formats[i].pixelformat == fourcc) {
-			return formats+i;
-		}
-	}
-
-	DEB_D("unknown pixelformat:'%4.4s'\n", (char *)&fourcc);
-	return NULL;
-}
-
-static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f);
-
-int saa7146_start_preview(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct v4l2_format fmt;
-	int ret = 0, err = 0;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	/* check if we have overlay informations */
-	if( NULL == fh->ov.fh ) {
-		DEB_D("no overlay data available. try S_FMT first.\n");
-		return -EAGAIN;
-	}
-
-	/* check if streaming capture is running */
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_D("streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	/* check if overlay is running */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		if (vv->video_fh == fh) {
-			DEB_D("overlay is already active\n");
-			return 0;
-		}
-		DEB_D("overlay is already active in another open\n");
-		return -EBUSY;
-	}
-
-	if (0 == saa7146_res_get(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP)) {
-		DEB_D("cannot get necessary overlay resources\n");
-		return -EBUSY;
-	}
-
-	fmt.fmt.win = fh->ov.win;
-	err = vidioc_try_fmt_vid_overlay(NULL, fh, &fmt);
-	if (0 != err) {
-		saa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-		return -EBUSY;
-	}
-	fh->ov.win = fmt.fmt.win;
-	vv->ov_data = &fh->ov;
-
-	DEB_D("%dx%d+%d+%d %s field=%s\n",
-	      fh->ov.win.w.width, fh->ov.win.w.height,
-	      fh->ov.win.w.left, fh->ov.win.w.top,
-	      vv->ov_fmt->name, v4l2_field_names[fh->ov.win.field]);
-
-	if (0 != (ret = saa7146_enable_overlay(fh))) {
-		DEB_D("enabling overlay failed: %d\n", ret);
-		saa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-		return ret;
-	}
-
-	vv->video_status = STATUS_OVERLAY;
-	vv->video_fh = fh;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(saa7146_start_preview);
-
-int saa7146_stop_preview(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	/* check if streaming capture is running */
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_D("streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	/* check if overlay is running at all */
-	if ((vv->video_status & STATUS_OVERLAY) == 0) {
-		DEB_D("no active overlay\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_D("overlay is active, but in another open\n");
-		return -EBUSY;
-	}
-
-	vv->video_status = 0;
-	vv->video_fh = NULL;
-
-	saa7146_disable_overlay(fh);
-
-	saa7146_res_free(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(saa7146_stop_preview);
-
-/********************************************************************************/
-/* device controls */
-
-static struct v4l2_queryctrl controls[] = {
-	{
-		.id		= V4L2_CID_BRIGHTNESS,
-		.name		= "Brightness",
-		.minimum	= 0,
-		.maximum	= 255,
-		.step		= 1,
-		.default_value	= 128,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_CONTRAST,
-		.name		= "Contrast",
-		.minimum	= 0,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 64,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_SATURATION,
-		.name		= "Saturation",
-		.minimum	= 0,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 64,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_VFLIP,
-		.name		= "Vertical Flip",
-		.minimum	= 0,
-		.maximum	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	},{
-		.id		= V4L2_CID_HFLIP,
-		.name		= "Horizontal Flip",
-		.minimum	= 0,
-		.maximum	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	},
-};
-static int NUM_CONTROLS = sizeof(controls)/sizeof(struct v4l2_queryctrl);
-
-#define V4L2_CID_PRIVATE_LASTP1      (V4L2_CID_PRIVATE_BASE + 0)
-
-static struct v4l2_queryctrl* ctrl_by_id(int id)
-{
-	int i;
-
-	for (i = 0; i < NUM_CONTROLS; i++)
-		if (controls[i].id == id)
-			return controls+i;
-	return NULL;
-}
-
-/********************************************************************************/
-/* common pagetable functions */
-
-static int saa7146_pgtable_build(struct saa7146_dev *dev, struct saa7146_buf *buf)
-{
-	struct pci_dev *pci = dev->pci;
-	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);
-	struct scatterlist *list = dma->sglist;
-	int length = dma->sglen;
-	struct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);
-
-	DEB_EE("dev:%p, buf:%p, sg_len:%d\n", dev, buf, length);
-
-	if( 0 != IS_PLANAR(sfmt->trans)) {
-		struct saa7146_pgtable *pt1 = &buf->pt[0];
-		struct saa7146_pgtable *pt2 = &buf->pt[1];
-		struct saa7146_pgtable *pt3 = &buf->pt[2];
-		__le32  *ptr1, *ptr2, *ptr3;
-		__le32 fill;
-
-		int size = buf->fmt->width*buf->fmt->height;
-		int i,p,m1,m2,m3,o1,o2;
-
-		switch( sfmt->depth ) {
-			case 12: {
-				/* create some offsets inside the page table */
-				m1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;
-				m2 = ((size+(size/4)+PAGE_SIZE)/PAGE_SIZE)-1;
-				m3 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;
-				o1 = size%PAGE_SIZE;
-				o2 = (size+(size/4))%PAGE_SIZE;
-				DEB_CAP("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",
-					size, m1, m2, m3, o1, o2);
-				break;
-			}
-			case 16: {
-				/* create some offsets inside the page table */
-				m1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;
-				m2 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;
-				m3 = ((2*size+PAGE_SIZE)/PAGE_SIZE)-1;
-				o1 = size%PAGE_SIZE;
-				o2 = (size+(size/2))%PAGE_SIZE;
-				DEB_CAP("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",
-					size, m1, m2, m3, o1, o2);
-				break;
-			}
-			default: {
-				return -1;
-			}
-		}
-
-		ptr1 = pt1->cpu;
-		ptr2 = pt2->cpu;
-		ptr3 = pt3->cpu;
-
-		/* walk all pages, copy all page addresses to ptr1 */
-		for (i = 0; i < length; i++, list++) {
-			for (p = 0; p * 4096 < list->length; p++, ptr1++) {
-				*ptr1 = cpu_to_le32(sg_dma_address(list) - list->offset);
-			}
-		}
-/*
-		ptr1 = pt1->cpu;
-		for(j=0;j<40;j++) {
-			printk("ptr1 %d: 0x%08x\n",j,ptr1[j]);
-		}
-*/
-
-		/* if we have a user buffer, the first page may not be
-		   aligned to a page boundary. */
-		pt1->offset = dma->sglist->offset;
-		pt2->offset = pt1->offset+o1;
-		pt3->offset = pt1->offset+o2;
-
-		/* create video-dma2 page table */
-		ptr1 = pt1->cpu;
-		for(i = m1; i <= m2 ; i++, ptr2++) {
-			*ptr2 = ptr1[i];
-		}
-		fill = *(ptr2-1);
-		for(;i<1024;i++,ptr2++) {
-			*ptr2 = fill;
-		}
-		/* create video-dma3 page table */
-		ptr1 = pt1->cpu;
-		for(i = m2; i <= m3; i++,ptr3++) {
-			*ptr3 = ptr1[i];
-		}
-		fill = *(ptr3-1);
-		for(;i<1024;i++,ptr3++) {
-			*ptr3 = fill;
-		}
-		/* finally: finish up video-dma1 page table */
-		ptr1 = pt1->cpu+m1;
-		fill = pt1->cpu[m1];
-		for(i=m1;i<1024;i++,ptr1++) {
-			*ptr1 = fill;
-		}
-/*
-		ptr1 = pt1->cpu;
-		ptr2 = pt2->cpu;
-		ptr3 = pt3->cpu;
-		for(j=0;j<40;j++) {
-			printk("ptr1 %d: 0x%08x\n",j,ptr1[j]);
-		}
-		for(j=0;j<40;j++) {
-			printk("ptr2 %d: 0x%08x\n",j,ptr2[j]);
-		}
-		for(j=0;j<40;j++) {
-			printk("ptr3 %d: 0x%08x\n",j,ptr3[j]);
-		}
-*/
-	} else {
-		struct saa7146_pgtable *pt = &buf->pt[0];
-		return saa7146_pgtable_build_single(pci, pt, list, length);
-	}
-
-	return 0;
-}
-
-
-/********************************************************************************/
-/* file operations */
-
-static int video_begin(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt = NULL;
-	unsigned int resource;
-	int ret = 0, err = 0;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	if ((vv->video_status & STATUS_CAPTURE) != 0) {
-		if (vv->video_fh == fh) {
-			DEB_S("already capturing\n");
-			return 0;
-		}
-		DEB_S("already capturing in another open\n");
-		return -EBUSY;
-	}
-
-	if ((vv->video_status & STATUS_OVERLAY) != 0) {
-		DEB_S("warning: suspending overlay video for streaming capture\n");
-		vv->ov_suspend = vv->video_fh;
-		err = saa7146_stop_preview(vv->video_fh); /* side effect: video_status is now 0, video_fh is NULL */
-		if (0 != err) {
-			DEB_D("suspending video failed. aborting\n");
-			return err;
-		}
-	}
-
-	fmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	/* we need to have a valid format set here */
-	BUG_ON(NULL == fmt);
-
-	if (0 != (fmt->flags & FORMAT_IS_PLANAR)) {
-		resource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;
-	} else {
-		resource = RESOURCE_DMA1_HPS;
-	}
-
-	ret = saa7146_res_get(fh, resource);
-	if (0 == ret) {
-		DEB_S("cannot get capture resource %d\n", resource);
-		if (vv->ov_suspend != NULL) {
-			saa7146_start_preview(vv->ov_suspend);
-			vv->ov_suspend = NULL;
-		}
-		return -EBUSY;
-	}
-
-	/* clear out beginning of streaming bit (rps register 0)*/
-	saa7146_write(dev, MC2, MASK_27 );
-
-	/* enable rps0 irqs */
-	SAA7146_IER_ENABLE(dev, MASK_27);
-
-	vv->video_fh = fh;
-	vv->video_status = STATUS_CAPTURE;
-
-	return 0;
-}
-
-static int video_end(struct saa7146_fh *fh, struct file *file)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt = NULL;
-	unsigned long flags;
-	unsigned int resource;
-	u32 dmas = 0;
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	if ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {
-		DEB_S("not capturing\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_S("capturing, but in another open\n");
-		return -EBUSY;
-	}
-
-	fmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	/* we need to have a valid format set here */
-	BUG_ON(NULL == fmt);
-
-	if (0 != (fmt->flags & FORMAT_IS_PLANAR)) {
-		resource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;
-		dmas = MASK_22 | MASK_21 | MASK_20;
-	} else {
-		resource = RESOURCE_DMA1_HPS;
-		dmas = MASK_22;
-	}
-	spin_lock_irqsave(&dev->slock,flags);
-
-	/* disable rps0  */
-	saa7146_write(dev, MC1, MASK_28);
-
-	/* disable rps0 irqs */
-	SAA7146_IER_DISABLE(dev, MASK_27);
-
-	/* shut down all used video dma transfers */
-	saa7146_write(dev, MC1, dmas);
-
-	spin_unlock_irqrestore(&dev->slock, flags);
-
-	vv->video_fh = NULL;
-	vv->video_status = 0;
-
-	saa7146_res_free(fh, resource);
-
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	return 0;
-}
-
-static int vidioc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-
-	strcpy((char *)cap->driver, "saa7146 v4l2");
-	strlcpy((char *)cap->card, dev->ext->name, sizeof(cap->card));
-	sprintf((char *)cap->bus_info, "PCI:%s", pci_name(dev->pci));
-	cap->version = SAA7146_VERSION_CODE;
-	cap->capabilities =
-		V4L2_CAP_VIDEO_CAPTURE |
-		V4L2_CAP_VIDEO_OVERLAY |
-		V4L2_CAP_READWRITE |
-		V4L2_CAP_STREAMING;
-	cap->capabilities |= dev->ext_vv_data->capabilities;
-	return 0;
-}
-
-static int vidioc_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	*fb = vv->ov_fb;
-	fb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;
-	return 0;
-}
-
-static int vidioc_s_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt;
-
-	DEB_EE("VIDIOC_S_FBUF\n");
-
-	if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))
-		return -EPERM;
-
-	/* check args */
-	fmt = saa7146_format_by_fourcc(dev, fb->fmt.pixelformat);
-	if (NULL == fmt)
-		return -EINVAL;
-
-	/* planar formats are not allowed for overlay video, clipping and video dma would clash */
-	if (fmt->flags & FORMAT_IS_PLANAR)
-		DEB_S("planar pixelformat '%4.4s' not allowed for overlay\n",
-		      (char *)&fmt->pixelformat);
-
-	/* check if overlay is running */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		if (vv->video_fh != fh) {
-			DEB_D("refusing to change framebuffer informations while overlay is active in another open\n");
-			return -EBUSY;
-		}
-	}
-
-	/* ok, accept it */
-	vv->ov_fb = *fb;
-	vv->ov_fmt = fmt;
-
-	if (vv->ov_fb.fmt.bytesperline < vv->ov_fb.fmt.width) {
-		vv->ov_fb.fmt.bytesperline = vv->ov_fb.fmt.width * fmt->depth / 8;
-		DEB_D("setting bytesperline to %d\n", vv->ov_fb.fmt.bytesperline);
-	}
-	return 0;
-}
-
-static int vidioc_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)
-{
-	if (f->index >= NUM_FORMATS)
-		return -EINVAL;
-	strlcpy((char *)f->description, formats[f->index].name,
-			sizeof(f->description));
-	f->pixelformat = formats[f->index].pixelformat;
-	return 0;
-}
-
-static int vidioc_queryctrl(struct file *file, void *fh, struct v4l2_queryctrl *c)
-{
-	const struct v4l2_queryctrl *ctrl;
-
-	if ((c->id <  V4L2_CID_BASE ||
-	     c->id >= V4L2_CID_LASTP1) &&
-	    (c->id <  V4L2_CID_PRIVATE_BASE ||
-	     c->id >= V4L2_CID_PRIVATE_LASTP1))
-		return -EINVAL;
-
-	ctrl = ctrl_by_id(c->id);
-	if (ctrl == NULL)
-		return -EINVAL;
-
-	DEB_EE("VIDIOC_QUERYCTRL: id:%d\n", c->id);
-	*c = *ctrl;
-	return 0;
-}
-
-static int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	const struct v4l2_queryctrl *ctrl;
-	u32 value = 0;
-
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl)
-		return -EINVAL;
-	switch (c->id) {
-	case V4L2_CID_BRIGHTNESS:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0xff & (value >> 24);
-		DEB_D("V4L2_CID_BRIGHTNESS: %d\n", c->value);
-		break;
-	case V4L2_CID_CONTRAST:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0x7f & (value >> 16);
-		DEB_D("V4L2_CID_CONTRAST: %d\n", c->value);
-		break;
-	case V4L2_CID_SATURATION:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0x7f & (value >> 0);
-		DEB_D("V4L2_CID_SATURATION: %d\n", c->value);
-		break;
-	case V4L2_CID_VFLIP:
-		c->value = vv->vflip;
-		DEB_D("V4L2_CID_VFLIP: %d\n", c->value);
-		break;
-	case V4L2_CID_HFLIP:
-		c->value = vv->hflip;
-		DEB_D("V4L2_CID_HFLIP: %d\n", c->value);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	const struct v4l2_queryctrl *ctrl;
-
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl) {
-		DEB_D("unknown control %d\n", c->id);
-		return -EINVAL;
-	}
-
-	switch (ctrl->type) {
-	case V4L2_CTRL_TYPE_BOOLEAN:
-	case V4L2_CTRL_TYPE_MENU:
-	case V4L2_CTRL_TYPE_INTEGER:
-		if (c->value < ctrl->minimum)
-			c->value = ctrl->minimum;
-		if (c->value > ctrl->maximum)
-			c->value = ctrl->maximum;
-		break;
-	default:
-		/* nothing */;
-	}
-
-	switch (c->id) {
-	case V4L2_CID_BRIGHTNESS: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0x00ffffff;
-		value |= (c->value << 24);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_CONTRAST: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0xff00ffff;
-		value |= (c->value << 16);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_SATURATION: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0xffffff00;
-		value |= (c->value << 0);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_HFLIP:
-		/* fixme: we can support changing VFLIP and HFLIP here... */
-		if (IS_CAPTURE_ACTIVE(fh) != 0) {
-			DEB_D("V4L2_CID_HFLIP while active capture\n");
-			return -EBUSY;
-		}
-		vv->hflip = c->value;
-		break;
-	case V4L2_CID_VFLIP:
-		if (IS_CAPTURE_ACTIVE(fh) != 0) {
-			DEB_D("V4L2_CID_VFLIP while active capture\n");
-			return -EBUSY;
-		}
-		vv->vflip = c->value;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		saa7146_stop_preview(fh);
-		saa7146_start_preview(fh);
-	}
-	return 0;
-}
-
-static int vidioc_g_parm(struct file *file, void *fh,
-		struct v4l2_streamparm *parm)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	parm->parm.capture.readbuffers = 1;
-	v4l2_video_std_frame_period(vv->standard->id,
-				    &parm->parm.capture.timeperframe);
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.pix = ((struct saa7146_fh *)fh)->video_fmt;
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.win = ((struct saa7146_fh *)fh)->ov.win;
-	return 0;
-}
-
-static int vidioc_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.vbi = ((struct saa7146_fh *)fh)->vbi_fmt;
-	return 0;
-}
-
-static int vidioc_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt;
-	enum v4l2_field field;
-	int maxw, maxh;
-	int calc_bpl;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh);
-
-	fmt = saa7146_format_by_fourcc(dev, f->fmt.pix.pixelformat);
-	if (NULL == fmt)
-		return -EINVAL;
-
-	field = f->fmt.pix.field;
-	maxw  = vv->standard->h_max_out;
-	maxh  = vv->standard->v_max_out;
-
-	if (V4L2_FIELD_ANY == field) {
-		field = (f->fmt.pix.height > maxh / 2)
-			? V4L2_FIELD_INTERLACED
-			: V4L2_FIELD_BOTTOM;
-	}
-	switch (field) {
-	case V4L2_FIELD_ALTERNATE:
-		vv->last_field = V4L2_FIELD_TOP;
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_TOP:
-	case V4L2_FIELD_BOTTOM:
-		vv->last_field = V4L2_FIELD_INTERLACED;
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_INTERLACED:
-		vv->last_field = V4L2_FIELD_INTERLACED;
-		break;
-	default:
-		DEB_D("no known field mode '%d'\n", field);
-		return -EINVAL;
-	}
-
-	f->fmt.pix.field = field;
-	if (f->fmt.pix.width > maxw)
-		f->fmt.pix.width = maxw;
-	if (f->fmt.pix.height > maxh)
-		f->fmt.pix.height = maxh;
-
-	calc_bpl = (f->fmt.pix.width * fmt->depth) / 8;
-
-	if (f->fmt.pix.bytesperline < calc_bpl)
-		f->fmt.pix.bytesperline = calc_bpl;
-
-	if (f->fmt.pix.bytesperline > (2 * PAGE_SIZE * fmt->depth) / 8) /* arbitrary constraint */
-		f->fmt.pix.bytesperline = calc_bpl;
-
-	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;
-	DEB_D("w:%d, h:%d, bytesperline:%d, sizeimage:%d\n",
-	      f->fmt.pix.width, f->fmt.pix.height,
-	      f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);
-
-	return 0;
-}
-
-
-static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct v4l2_window *win = &f->fmt.win;
-	enum v4l2_field field;
-	int maxw, maxh;
-
-	DEB_EE("dev:%p\n", dev);
-
-	if (NULL == vv->ov_fb.base) {
-		DEB_D("no fb base set\n");
-		return -EINVAL;
-	}
-	if (NULL == vv->ov_fmt) {
-		DEB_D("no fb fmt set\n");
-		return -EINVAL;
-	}
-	if (win->w.width < 48 || win->w.height < 32) {
-		DEB_D("min width/height. (%d,%d)\n",
-		      win->w.width, win->w.height);
-		return -EINVAL;
-	}
-	if (win->clipcount > 16) {
-		DEB_D("clipcount too big\n");
-		return -EINVAL;
-	}
-
-	field = win->field;
-	maxw  = vv->standard->h_max_out;
-	maxh  = vv->standard->v_max_out;
-
-	if (V4L2_FIELD_ANY == field) {
-		field = (win->w.height > maxh / 2)
-			? V4L2_FIELD_INTERLACED
-			: V4L2_FIELD_TOP;
-		}
-	switch (field) {
-	case V4L2_FIELD_TOP:
-	case V4L2_FIELD_BOTTOM:
-	case V4L2_FIELD_ALTERNATE:
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_INTERLACED:
-		break;
-	default:
-		DEB_D("no known field mode '%d'\n", field);
-		return -EINVAL;
-	}
-
-	win->field = field;
-	if (win->w.width > maxw)
-		win->w.width = maxw;
-	if (win->w.height > maxh)
-		win->w.height = maxh;
-
-	return 0;
-}
-
-static int vidioc_s_fmt_vid_cap(struct file *file, void *__fh, struct v4l2_format *f)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh);
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_EE("streaming capture is active\n");
-		return -EBUSY;
-	}
-	err = vidioc_try_fmt_vid_cap(file, fh, f);
-	if (0 != err)
-		return err;
-	fh->video_fmt = f->fmt.pix;
-	DEB_EE("set to pixelformat '%4.4s'\n",
-	       (char *)&fh->video_fmt.pixelformat);
-	return 0;
-}
-
-static int vidioc_s_fmt_vid_overlay(struct file *file, void *__fh, struct v4l2_format *f)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_OVERLAY: dev:%p, fh:%p\n", dev, fh);
-	err = vidioc_try_fmt_vid_overlay(file, fh, f);
-	if (0 != err)
-		return err;
-	fh->ov.win    = f->fmt.win;
-	fh->ov.nclips = f->fmt.win.clipcount;
-	if (fh->ov.nclips > 16)
-		fh->ov.nclips = 16;
-	if (copy_from_user(fh->ov.clips, f->fmt.win.clips,
-				sizeof(struct v4l2_clip) * fh->ov.nclips)) {
-		return -EFAULT;
-	}
-
-	/* fh->ov.fh is used to indicate that we have valid overlay informations, too */
-	fh->ov.fh = fh;
-
-	/* check if our current overlay is active */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		saa7146_stop_preview(fh);
-		saa7146_start_preview(fh);
-	}
-	return 0;
-}
-
-static int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	*norm = vv->standard->id;
-	return 0;
-}
-
-	/* the saa7146 supfhrts (used in conjunction with the saa7111a for example)
-	   PAL / NTSC / SECAM. if your hardware does not (or does more)
-	   -- override this function in your extension */
-/*
-	case VIDIOC_ENUMSTD:
-	{
-		struct v4l2_standard *e = arg;
-		if (e->index < 0 )
-			return -EINVAL;
-		if( e->index < dev->ext_vv_data->num_stds ) {
-			DEB_EE("VIDIOC_ENUMSTD: index:%d\n", e->index);
-			v4l2_video_std_construct(e, dev->ext_vv_data->stds[e->index].id, dev->ext_vv_data->stds[e->index].name);
-			return 0;
-		}
-		return -EINVAL;
-	}
-	*/
-
-static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *id)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int found = 0;
-	int err, i;
-
-	DEB_EE("VIDIOC_S_STD\n");
-
-	if ((vv->video_status & STATUS_CAPTURE) == STATUS_CAPTURE) {
-		DEB_D("cannot change video standard while streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	if ((vv->video_status & STATUS_OVERLAY) != 0) {
-		vv->ov_suspend = vv->video_fh;
-		err = saa7146_stop_preview(vv->video_fh); /* side effect: video_status is now 0, video_fh is NULL */
-		if (0 != err) {
-			DEB_D("suspending video failed. aborting\n");
-			return err;
-		}
-	}
-
-	for (i = 0; i < dev->ext_vv_data->num_stds; i++)
-		if (*id & dev->ext_vv_data->stds[i].id)
-			break;
-	if (i != dev->ext_vv_data->num_stds) {
-		vv->standard = &dev->ext_vv_data->stds[i];
-		if (NULL != dev->ext_vv_data->std_callback)
-			dev->ext_vv_data->std_callback(dev, vv->standard);
-		found = 1;
-	}
-
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	if (!found) {
-		DEB_EE("VIDIOC_S_STD: standard not found\n");
-		return -EINVAL;
-	}
-
-	DEB_EE("VIDIOC_S_STD: set to standard to '%s'\n", vv->standard->name);
-	return 0;
-}
-
-static int vidioc_overlay(struct file *file, void *fh, unsigned int on)
-{
-	int err;
-
-	DEB_D("VIDIOC_OVERLAY on:%d\n", on);
-	if (on)
-		err = saa7146_start_preview(fh);
-	else
-		err = saa7146_stop_preview(fh);
-	return err;
-}
-
-static int vidioc_reqbufs(struct file *file, void *__fh, struct v4l2_requestbuffers *b)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_reqbufs(&fh->video_q, b);
-	if (b->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_reqbufs(&fh->vbi_q, b);
-	return -EINVAL;
-}
-
-static int vidioc_querybuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_querybuf(&fh->video_q, buf);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_querybuf(&fh->vbi_q, buf);
-	return -EINVAL;
-}
-
-static int vidioc_qbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_qbuf(&fh->video_q, buf);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_qbuf(&fh->vbi_q, buf);
-	return -EINVAL;
-}
-
-static int vidioc_dqbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_dqbuf(&fh->video_q, buf, file->f_flags & O_NONBLOCK);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_dqbuf(&fh->vbi_q, buf, file->f_flags & O_NONBLOCK);
-	return -EINVAL;
-}
-
-static int vidioc_streamon(struct file *file, void *__fh, enum v4l2_buf_type type)
-{
-	struct saa7146_fh *fh = __fh;
-	int err;
-
-	DEB_D("VIDIOC_STREAMON, type:%d\n", type);
-
-	err = video_begin(fh);
-	if (err)
-		return err;
-	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_streamon(&fh->video_q);
-	if (type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_streamon(&fh->vbi_q);
-	return -EINVAL;
-}
-
-static int vidioc_streamoff(struct file *file, void *__fh, enum v4l2_buf_type type)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_D("VIDIOC_STREAMOFF, type:%d\n", type);
-
-	/* ugly: we need to copy some checks from video_end(),
-	   because videobuf_streamoff() relies on the capture running.
-	   check and fix this */
-	if ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {
-		DEB_S("not capturing\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_S("capturing, but in another open\n");
-		return -EBUSY;
-	}
-
-	err = -EINVAL;
-	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		err = videobuf_streamoff(&fh->video_q);
-	else if (type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		err = videobuf_streamoff(&fh->vbi_q);
-	if (0 != err) {
-		DEB_D("warning: videobuf_streamoff() failed\n");
-		video_end(fh, file);
-	} else {
-		err = video_end(fh, file);
-	}
-	return err;
-}
-
-static int vidioc_g_chip_ident(struct file *file, void *__fh,
-		struct v4l2_dbg_chip_ident *chip)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-
-	chip->ident = V4L2_IDENT_NONE;
-	chip->revision = 0;
-	if (chip->match.type == V4L2_CHIP_MATCH_HOST && !chip->match.addr) {
-		chip->ident = V4L2_IDENT_SAA7146;
-		return 0;
-	}
-	return v4l2_device_call_until_err(&dev->v4l2_dev, 0,
-			core, g_chip_ident, chip);
-}
-
-const struct v4l2_ioctl_ops saa7146_video_ioctl_ops = {
-	.vidioc_querycap             = vidioc_querycap,
-	.vidioc_enum_fmt_vid_cap     = vidioc_enum_fmt_vid_cap,
-	.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_cap,
-	.vidioc_g_fmt_vid_cap        = vidioc_g_fmt_vid_cap,
-	.vidioc_try_fmt_vid_cap      = vidioc_try_fmt_vid_cap,
-	.vidioc_s_fmt_vid_cap        = vidioc_s_fmt_vid_cap,
-	.vidioc_g_fmt_vid_overlay    = vidioc_g_fmt_vid_overlay,
-	.vidioc_try_fmt_vid_overlay  = vidioc_try_fmt_vid_overlay,
-	.vidioc_s_fmt_vid_overlay    = vidioc_s_fmt_vid_overlay,
-	.vidioc_g_fmt_vbi_cap        = vidioc_g_fmt_vbi_cap,
-	.vidioc_g_chip_ident         = vidioc_g_chip_ident,
-
-	.vidioc_overlay 	     = vidioc_overlay,
-	.vidioc_g_fbuf  	     = vidioc_g_fbuf,
-	.vidioc_s_fbuf  	     = vidioc_s_fbuf,
-	.vidioc_reqbufs              = vidioc_reqbufs,
-	.vidioc_querybuf             = vidioc_querybuf,
-	.vidioc_qbuf                 = vidioc_qbuf,
-	.vidioc_dqbuf                = vidioc_dqbuf,
-	.vidioc_g_std                = vidioc_g_std,
-	.vidioc_s_std                = vidioc_s_std,
-	.vidioc_queryctrl            = vidioc_queryctrl,
-	.vidioc_g_ctrl               = vidioc_g_ctrl,
-	.vidioc_s_ctrl               = vidioc_s_ctrl,
-	.vidioc_streamon             = vidioc_streamon,
-	.vidioc_streamoff            = vidioc_streamoff,
-	.vidioc_g_parm 		     = vidioc_g_parm,
-};
-
-/*********************************************************************************/
-/* buffer handling functions                                                  */
-
-static int buffer_activate (struct saa7146_dev *dev,
-		     struct saa7146_buf *buf,
-		     struct saa7146_buf *next)
-{
-	struct saa7146_vv *vv = dev->vv_data;
-
-	buf->vb.state = VIDEOBUF_ACTIVE;
-	saa7146_set_capture(dev,buf,next);
-
-	mod_timer(&vv->video_q.timeout, jiffies+BUFFER_TIMEOUT);
-	return 0;
-}
-
-static void release_all_pagetables(struct saa7146_dev *dev, struct saa7146_buf *buf)
-{
-	saa7146_pgtable_free(dev->pci, &buf->pt[0]);
-	saa7146_pgtable_free(dev->pci, &buf->pt[1]);
-	saa7146_pgtable_free(dev->pci, &buf->pt[2]);
-}
-
-static int buffer_prepare(struct videobuf_queue *q,
-			  struct videobuf_buffer *vb, enum v4l2_field field)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-	int size,err = 0;
-
-	DEB_CAP("vbuf:%p\n", vb);
-
-	/* sanity checks */
-	if (fh->video_fmt.width  < 48 ||
-	    fh->video_fmt.height < 32 ||
-	    fh->video_fmt.width  > vv->standard->h_max_out ||
-	    fh->video_fmt.height > vv->standard->v_max_out) {
-		DEB_D("w (%d) / h (%d) out of bounds\n",
-		      fh->video_fmt.width, fh->video_fmt.height);
-		return -EINVAL;
-	}
-
-	size = fh->video_fmt.sizeimage;
-	if (0 != buf->vb.baddr && buf->vb.bsize < size) {
-		DEB_D("size mismatch\n");
-		return -EINVAL;
-	}
-
-	DEB_CAP("buffer_prepare [size=%dx%d,bytes=%d,fields=%s]\n",
-		fh->video_fmt.width, fh->video_fmt.height,
-		size, v4l2_field_names[fh->video_fmt.field]);
-	if (buf->vb.width  != fh->video_fmt.width  ||
-	    buf->vb.bytesperline != fh->video_fmt.bytesperline ||
-	    buf->vb.height != fh->video_fmt.height ||
-	    buf->vb.size   != size ||
-	    buf->vb.field  != field      ||
-	    buf->vb.field  != fh->video_fmt.field  ||
-	    buf->fmt       != &fh->video_fmt) {
-		saa7146_dma_free(dev,q,buf);
-	}
-
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		struct saa7146_format *sfmt;
-
-		buf->vb.bytesperline  = fh->video_fmt.bytesperline;
-		buf->vb.width  = fh->video_fmt.width;
-		buf->vb.height = fh->video_fmt.height;
-		buf->vb.size   = size;
-		buf->vb.field  = field;
-		buf->fmt       = &fh->video_fmt;
-		buf->vb.field  = fh->video_fmt.field;
-
-		sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);
-
-		release_all_pagetables(dev, buf);
-		if( 0 != IS_PLANAR(sfmt->trans)) {
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[0]);
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[1]);
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[2]);
-		} else {
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[0]);
-		}
-
-		err = videobuf_iolock(q,&buf->vb, &vv->ov_fb);
-		if (err)
-			goto oops;
-		err = saa7146_pgtable_build(dev,buf);
-		if (err)
-			goto oops;
-	}
-	buf->vb.state = VIDEOBUF_PREPARED;
-	buf->activate = buffer_activate;
-
-	return 0;
-
- oops:
-	DEB_D("error out\n");
-	saa7146_dma_free(dev,q,buf);
-
-	return err;
-}
-
-static int buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-
-	if (0 == *count || *count > MAX_SAA7146_CAPTURE_BUFFERS)
-		*count = MAX_SAA7146_CAPTURE_BUFFERS;
-
-	*size = fh->video_fmt.sizeimage;
-
-	/* check if we exceed the "max_memory" parameter */
-	if( (*count * *size) > (max_memory*1048576) ) {
-		*count = (max_memory*1048576) / *size;
-	}
-
-	DEB_CAP("%d buffers, %d bytes each\n", *count, *size);
-
-	return 0;
-}
-
-static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-
-	DEB_CAP("vbuf:%p\n", vb);
-	saa7146_buffer_queue(fh->dev,&vv->video_q,buf);
-}
-
-static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-
-	DEB_CAP("vbuf:%p\n", vb);
-
-	saa7146_dma_free(dev,q,buf);
-
-	release_all_pagetables(dev, buf);
-}
-
-static struct videobuf_queue_ops video_qops = {
-	.buf_setup    = buffer_setup,
-	.buf_prepare  = buffer_prepare,
-	.buf_queue    = buffer_queue,
-	.buf_release  = buffer_release,
-};
-
-/********************************************************************************/
-/* file operations */
-
-static void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)
-{
-	INIT_LIST_HEAD(&vv->video_q.queue);
-
-	init_timer(&vv->video_q.timeout);
-	vv->video_q.timeout.function = saa7146_buffer_timeout;
-	vv->video_q.timeout.data     = (unsigned long)(&vv->video_q);
-	vv->video_q.dev              = dev;
-
-	/* set some default values */
-	vv->standard = &dev->ext_vv_data->stds[0];
-
-	/* FIXME: what's this? */
-	vv->current_hps_source = SAA7146_HPS_SOURCE_PORT_A;
-	vv->current_hps_sync = SAA7146_HPS_SYNC_PORT_A;
-}
-
-
-static int video_open(struct saa7146_dev *dev, struct file *file)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_format *sfmt;
-
-	fh->video_fmt.width = 384;
-	fh->video_fmt.height = 288;
-	fh->video_fmt.pixelformat = V4L2_PIX_FMT_BGR24;
-	fh->video_fmt.bytesperline = 0;
-	fh->video_fmt.field = V4L2_FIELD_ANY;
-	sfmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	fh->video_fmt.sizeimage = (fh->video_fmt.width * fh->video_fmt.height * sfmt->depth)/8;
-
-	videobuf_queue_sg_init(&fh->video_q, &video_qops,
-			    &dev->pci->dev, &dev->slock,
-			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-			    V4L2_FIELD_INTERLACED,
-			    sizeof(struct saa7146_buf),
-			    file, &dev->v4l2_lock);
-
-	return 0;
-}
-
-
-static void video_close(struct saa7146_dev *dev, struct file *file)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct videobuf_queue *q = &fh->video_q;
-
-	if (IS_CAPTURE_ACTIVE(fh) != 0)
-		video_end(fh, file);
-	else if (IS_OVERLAY_ACTIVE(fh) != 0)
-		saa7146_stop_preview(fh);
-
-	videobuf_stop(q);
-	/* hmm, why is this function declared void? */
-}
-
-
-static void video_irq_done(struct saa7146_dev *dev, unsigned long st)
-{
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_dmaqueue *q = &vv->video_q;
-
-	spin_lock(&dev->slock);
-	DEB_CAP("called\n");
-
-	/* only finish the buffer if we have one... */
-	if( NULL != q->curr ) {
-		saa7146_buffer_finish(dev,q,VIDEOBUF_DONE);
-	}
-	saa7146_buffer_next(dev,q,0);
-
-	spin_unlock(&dev->slock);
-}
-
-static ssize_t video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	ssize_t ret = 0;
-
-	DEB_EE("called\n");
-
-	if ((vv->video_status & STATUS_CAPTURE) != 0) {
-		/* fixme: should we allow read() captures while streaming capture? */
-		if (vv->video_fh == fh) {
-			DEB_S("already capturing\n");
-			return -EBUSY;
-		}
-		DEB_S("already capturing in another open\n");
-		return -EBUSY;
-	}
-
-	ret = video_begin(fh);
-	if( 0 != ret) {
-		goto out;
-	}
-
-	ret = videobuf_read_one(&fh->video_q , data, count, ppos,
-				file->f_flags & O_NONBLOCK);
-	if (ret != 0) {
-		video_end(fh, file);
-	} else {
-		ret = video_end(fh, file);
-	}
-out:
-	/* restart overlay if it was active before */
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	return ret;
-}
-
-struct saa7146_use_ops saa7146_video_uops = {
-	.init = video_init,
-	.open = video_open,
-	.release = video_close,
-	.irq_done = video_irq_done,
-	.read = video_read,
-};
diff -urN flo-ElementalX-5.00/drivers/media/dvb/dvb-usb/umt-010.c flo-ElementalX-5.00-patched/drivers/media/dvb/dvb-usb/umt-010.c
--- flo-ElementalX-5.00/drivers/media/dvb/dvb-usb/umt-010.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/media/dvb/dvb-usb/umt-010.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,151 +0,0 @@
-/* DVB USB framework compliant Linux driver for the HanfTek UMT-010 USB2.0
- * DVB-T receiver.
- *
- * Copyright (C) 2004-5 Patrick Boettcher (patrick.boettcher@desy.de)
- *
- *	This program is free software; you can redistribute it and/or modify it
- *	under the terms of the GNU General Public License as published by the Free
- *	Software Foundation, version 2.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#include "dibusb.h"
-
-#include "mt352.h"
-
-DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
-
-static int umt_mt352_demod_init(struct dvb_frontend *fe)
-{
-	static u8 mt352_clock_config[] = { 0x89, 0xb8, 0x2d };
-	static u8 mt352_reset[] = { 0x50, 0x80 };
-	static u8 mt352_mclk_ratio[] = { 0x8b, 0x00 };
-	static u8 mt352_adc_ctl_1_cfg[] = { 0x8E, 0x40 };
-	static u8 mt352_agc_cfg[] = { 0x67, 0x10, 0xa0 };
-
-	static u8 mt352_sec_agc_cfg1[] = { 0x6a, 0xff };
-	static u8 mt352_sec_agc_cfg2[] = { 0x6d, 0xff };
-	static u8 mt352_sec_agc_cfg3[] = { 0x70, 0x40 };
-	static u8 mt352_sec_agc_cfg4[] = { 0x7b, 0x03 };
-	static u8 mt352_sec_agc_cfg5[] = { 0x7d, 0x0f };
-
-	static u8 mt352_acq_ctl[] = { 0x53, 0x50 };
-	static u8 mt352_input_freq_1[] = { 0x56, 0x31, 0x06 };
-
-	mt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));
-	udelay(2000);
-	mt352_write(fe, mt352_reset, sizeof(mt352_reset));
-	mt352_write(fe, mt352_mclk_ratio, sizeof(mt352_mclk_ratio));
-
-	mt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));
-	mt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));
-
-	mt352_write(fe, mt352_sec_agc_cfg1, sizeof(mt352_sec_agc_cfg1));
-	mt352_write(fe, mt352_sec_agc_cfg2, sizeof(mt352_sec_agc_cfg2));
-	mt352_write(fe, mt352_sec_agc_cfg3, sizeof(mt352_sec_agc_cfg3));
-	mt352_write(fe, mt352_sec_agc_cfg4, sizeof(mt352_sec_agc_cfg4));
-	mt352_write(fe, mt352_sec_agc_cfg5, sizeof(mt352_sec_agc_cfg5));
-
-	mt352_write(fe, mt352_acq_ctl, sizeof(mt352_acq_ctl));
-	mt352_write(fe, mt352_input_freq_1, sizeof(mt352_input_freq_1));
-
-	return 0;
-}
-
-static int umt_mt352_frontend_attach(struct dvb_usb_adapter *adap)
-{
-	struct mt352_config umt_config;
-
-	memset(&umt_config,0,sizeof(struct mt352_config));
-	umt_config.demod_init = umt_mt352_demod_init;
-	umt_config.demod_address = 0xf;
-
-	adap->fe_adap[0].fe = dvb_attach(mt352_attach, &umt_config, &adap->dev->i2c_adap);
-
-	return 0;
-}
-
-static int umt_tuner_attach (struct dvb_usb_adapter *adap)
-{
-	dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61, NULL, DVB_PLL_TUA6034);
-	return 0;
-}
-
-/* USB Driver stuff */
-static struct dvb_usb_device_properties umt_properties;
-
-static int umt_probe(struct usb_interface *intf,
-		const struct usb_device_id *id)
-{
-	if (0 == dvb_usb_device_init(intf, &umt_properties,
-				     THIS_MODULE, NULL, adapter_nr))
-		return 0;
-	return -EINVAL;
-}
-
-/* do not change the order of the ID table */
-static struct usb_device_id umt_table [] = {
-/* 00 */	{ USB_DEVICE(USB_VID_HANFTEK, USB_PID_HANFTEK_UMT_010_COLD) },
-/* 01 */	{ USB_DEVICE(USB_VID_HANFTEK, USB_PID_HANFTEK_UMT_010_WARM) },
-			{ }		/* Terminating entry */
-};
-MODULE_DEVICE_TABLE (usb, umt_table);
-
-static struct dvb_usb_device_properties umt_properties = {
-	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
-
-	.usb_ctrl = CYPRESS_FX2,
-	.firmware = "dvb-usb-umt-010-02.fw",
-
-	.num_adapters = 1,
-	.adapter = {
-		{
-		.num_frontends = 1,
-		.fe = {{
-			.streaming_ctrl   = dibusb2_0_streaming_ctrl,
-			.frontend_attach  = umt_mt352_frontend_attach,
-			.tuner_attach     = umt_tuner_attach,
-
-			/* parameter for the MPEG2-data transfer */
-			.stream = {
-				.type = USB_BULK,
-				.count = MAX_NO_URBS_FOR_DATA_STREAM,
-				.endpoint = 0x06,
-				.u = {
-					.bulk = {
-						.buffersize = 512,
-					}
-				}
-			},
-		}},
-			.size_of_priv     = sizeof(struct dibusb_state),
-		}
-	},
-	.power_ctrl       = dibusb_power_ctrl,
-
-	.i2c_algo         = &dibusb_i2c_algo,
-
-	.generic_bulk_ctrl_endpoint = 0x01,
-
-	.num_device_descs = 1,
-	.devices = {
-		{	"Hanftek UMT-010 DVB-T USB2.0",
-			{ &umt_table[0], NULL },
-			{ &umt_table[1], NULL },
-		},
-	}
-};
-
-static struct usb_driver umt_driver = {
-	.name		= "dvb_usb_umt_010",
-	.probe		= umt_probe,
-	.disconnect = dvb_usb_device_exit,
-	.id_table	= umt_table,
-};
-
-module_usb_driver(umt_driver);
-
-MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
-MODULE_DESCRIPTION("Driver for HanfTek UMT 010 USB2.0 DVB-T device");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/drivers/media/dvb/dvb-usb/usb-urb.c flo-ElementalX-5.00-patched/drivers/media/dvb/dvb-usb/usb-urb.c
--- flo-ElementalX-5.00/drivers/media/dvb/dvb-usb/usb-urb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/media/dvb/dvb-usb/usb-urb.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,254 +0,0 @@
-/* usb-urb.c is part of the DVB USB library.
- *
- * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@desy.de)
- * see dvb-usb-init.c for copyright information.
- *
- * This file keeps functions for initializing and handling the
- * BULK and ISOC USB data transfers in a generic way.
- * Can be used for DVB-only and also, that's the plan, for
- * Hybrid USB devices (analog and DVB).
- */
-#include "dvb-usb-common.h"
-
-/* URB stuff for streaming */
-static void usb_urb_complete(struct urb *urb)
-{
-	struct usb_data_stream *stream = urb->context;
-	int ptype = usb_pipetype(urb->pipe);
-	int i;
-	u8 *b;
-
-	deb_uxfer("'%s' urb completed. status: %d, length: %d/%d, pack_num: %d, errors: %d\n",
-		ptype == PIPE_ISOCHRONOUS ? "isoc" : "bulk",
-		urb->status,urb->actual_length,urb->transfer_buffer_length,
-		urb->number_of_packets,urb->error_count);
-
-	switch (urb->status) {
-		case 0:         /* success */
-		case -ETIMEDOUT:    /* NAK */
-			break;
-		case -ECONNRESET:   /* kill */
-		case -ENOENT:
-		case -ESHUTDOWN:
-			return;
-		default:        /* error */
-			deb_ts("urb completition error %d.\n", urb->status);
-			break;
-	}
-
-	b = (u8 *) urb->transfer_buffer;
-	switch (ptype) {
-		case PIPE_ISOCHRONOUS:
-			for (i = 0; i < urb->number_of_packets; i++) {
-
-				if (urb->iso_frame_desc[i].status != 0)
-					deb_ts("iso frame descriptor has an error: %d\n",urb->iso_frame_desc[i].status);
-				else if (urb->iso_frame_desc[i].actual_length > 0)
-					stream->complete(stream, b + urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].actual_length);
-
-				urb->iso_frame_desc[i].status = 0;
-				urb->iso_frame_desc[i].actual_length = 0;
-			}
-			debug_dump(b,20,deb_uxfer);
-			break;
-		case PIPE_BULK:
-			if (urb->actual_length > 0)
-				stream->complete(stream, b, urb->actual_length);
-			break;
-		default:
-			err("unknown endpoint type in completition handler.");
-			return;
-	}
-	usb_submit_urb(urb,GFP_ATOMIC);
-}
-
-int usb_urb_kill(struct usb_data_stream *stream)
-{
-	int i;
-	for (i = 0; i < stream->urbs_submitted; i++) {
-		deb_ts("killing URB no. %d.\n",i);
-
-		/* stop the URB */
-		usb_kill_urb(stream->urb_list[i]);
-	}
-	stream->urbs_submitted = 0;
-	return 0;
-}
-
-int usb_urb_submit(struct usb_data_stream *stream)
-{
-	int i,ret;
-	for (i = 0; i < stream->urbs_initialized; i++) {
-		deb_ts("submitting URB no. %d\n",i);
-		if ((ret = usb_submit_urb(stream->urb_list[i],GFP_ATOMIC))) {
-			err("could not submit URB no. %d - get them all back",i);
-			usb_urb_kill(stream);
-			return ret;
-		}
-		stream->urbs_submitted++;
-	}
-	return 0;
-}
-
-static int usb_free_stream_buffers(struct usb_data_stream *stream)
-{
-	if (stream->state & USB_STATE_URB_BUF) {
-		while (stream->buf_num) {
-			stream->buf_num--;
-			deb_mem("freeing buffer %d\n",stream->buf_num);
-			usb_free_coherent(stream->udev, stream->buf_size,
-					  stream->buf_list[stream->buf_num],
-					  stream->dma_addr[stream->buf_num]);
-		}
-	}
-
-	stream->state &= ~USB_STATE_URB_BUF;
-
-	return 0;
-}
-
-static int usb_allocate_stream_buffers(struct usb_data_stream *stream, int num, unsigned long size)
-{
-	stream->buf_num = 0;
-	stream->buf_size = size;
-
-	deb_mem("all in all I will use %lu bytes for streaming\n",num*size);
-
-	for (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {
-		deb_mem("allocating buffer %d\n",stream->buf_num);
-		if (( stream->buf_list[stream->buf_num] =
-					usb_alloc_coherent(stream->udev, size, GFP_ATOMIC,
-					&stream->dma_addr[stream->buf_num]) ) == NULL) {
-			deb_mem("not enough memory for urb-buffer allocation.\n");
-			usb_free_stream_buffers(stream);
-			return -ENOMEM;
-		}
-		deb_mem("buffer %d: %p (dma: %Lu)\n",
-			stream->buf_num,
-stream->buf_list[stream->buf_num], (long long)stream->dma_addr[stream->buf_num]);
-		memset(stream->buf_list[stream->buf_num],0,size);
-		stream->state |= USB_STATE_URB_BUF;
-	}
-	deb_mem("allocation successful\n");
-
-	return 0;
-}
-
-static int usb_bulk_urb_init(struct usb_data_stream *stream)
-{
-	int i, j;
-
-	if ((i = usb_allocate_stream_buffers(stream,stream->props.count,
-					stream->props.u.bulk.buffersize)) < 0)
-		return i;
-
-	/* allocate the URBs */
-	for (i = 0; i < stream->props.count; i++) {
-		stream->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);
-		if (!stream->urb_list[i]) {
-			deb_mem("not enough memory for urb_alloc_urb!.\n");
-			for (j = 0; j < i; j++)
-				usb_free_urb(stream->urb_list[j]);
-			return -ENOMEM;
-		}
-		usb_fill_bulk_urb( stream->urb_list[i], stream->udev,
-				usb_rcvbulkpipe(stream->udev,stream->props.endpoint),
-				stream->buf_list[i],
-				stream->props.u.bulk.buffersize,
-				usb_urb_complete, stream);
-
-		stream->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
-		stream->urb_list[i]->transfer_dma = stream->dma_addr[i];
-		stream->urbs_initialized++;
-	}
-	return 0;
-}
-
-static int usb_isoc_urb_init(struct usb_data_stream *stream)
-{
-	int i,j;
-
-	if ((i = usb_allocate_stream_buffers(stream,stream->props.count,
-					stream->props.u.isoc.framesize*stream->props.u.isoc.framesperurb)) < 0)
-		return i;
-
-	/* allocate the URBs */
-	for (i = 0; i < stream->props.count; i++) {
-		struct urb *urb;
-		int frame_offset = 0;
-
-		stream->urb_list[i] = usb_alloc_urb(stream->props.u.isoc.framesperurb, GFP_ATOMIC);
-		if (!stream->urb_list[i]) {
-			deb_mem("not enough memory for urb_alloc_urb!\n");
-			for (j = 0; j < i; j++)
-				usb_free_urb(stream->urb_list[j]);
-			return -ENOMEM;
-		}
-
-		urb = stream->urb_list[i];
-
-		urb->dev = stream->udev;
-		urb->context = stream;
-		urb->complete = usb_urb_complete;
-		urb->pipe = usb_rcvisocpipe(stream->udev,stream->props.endpoint);
-		urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
-		urb->interval = stream->props.u.isoc.interval;
-		urb->number_of_packets = stream->props.u.isoc.framesperurb;
-		urb->transfer_buffer_length = stream->buf_size;
-		urb->transfer_buffer = stream->buf_list[i];
-		urb->transfer_dma = stream->dma_addr[i];
-
-		for (j = 0; j < stream->props.u.isoc.framesperurb; j++) {
-			urb->iso_frame_desc[j].offset = frame_offset;
-			urb->iso_frame_desc[j].length = stream->props.u.isoc.framesize;
-			frame_offset += stream->props.u.isoc.framesize;
-		}
-
-		stream->urbs_initialized++;
-	}
-	return 0;
-}
-
-int usb_urb_init(struct usb_data_stream *stream, struct usb_data_stream_properties *props)
-{
-	if (stream == NULL || props == NULL)
-		return -EINVAL;
-
-	memcpy(&stream->props, props, sizeof(*props));
-
-	usb_clear_halt(stream->udev,usb_rcvbulkpipe(stream->udev,stream->props.endpoint));
-
-	if (stream->complete == NULL) {
-		err("there is no data callback - this doesn't make sense.");
-		return -EINVAL;
-	}
-
-	switch (stream->props.type) {
-		case USB_BULK:
-			return usb_bulk_urb_init(stream);
-		case USB_ISOC:
-			return usb_isoc_urb_init(stream);
-		default:
-			err("unknown URB-type for data transfer.");
-			return -EINVAL;
-	}
-}
-
-int usb_urb_exit(struct usb_data_stream *stream)
-{
-	int i;
-
-	usb_urb_kill(stream);
-
-	for (i = 0; i < stream->urbs_initialized; i++) {
-		if (stream->urb_list[i] != NULL) {
-			deb_mem("freeing URB no. %d.\n",i);
-			/* free the URBs */
-			usb_free_urb(stream->urb_list[i]);
-		}
-	}
-	stream->urbs_initialized = 0;
-
-	usb_free_stream_buffers(stream);
-	return 0;
-}
diff -urN flo-ElementalX-5.00/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c flo-ElementalX-5.00-patched/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
--- flo-ElementalX-5.00/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c	2016-05-10 02:52:00.000000000 +0000
@@ -920,13 +920,6 @@
 static int msm_ispif_set_vfe_info(struct ispif_device *ispif,
 	struct msm_ispif_vfe_info *vfe_info)
 {
-        if (!vfe_info || (vfe_info->num_vfe <= 0) ||
-	    ((uint32_t)(vfe_info->num_vfe) > VFE_MAX)) {
-		pr_err("Invalid VFE info: %p %d\n", vfe_info,
-			   (vfe_info ? vfe_info->num_vfe:0));
- 		return -EINVAL;
-	}
-
 	memcpy(&ispif->vfe_info, vfe_info, sizeof(struct msm_ispif_vfe_info));
 
 	return 0;
diff -urN flo-ElementalX-5.00/drivers/media/video/sn9c102/sn9c102_ov7660.c flo-ElementalX-5.00-patched/drivers/media/video/sn9c102/sn9c102_ov7660.c
--- flo-ElementalX-5.00/drivers/media/video/sn9c102/sn9c102_ov7660.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/media/video/sn9c102/sn9c102_ov7660.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,538 +0,0 @@
-/***************************************************************************
- * Plug-in for OV7660 image sensor connected to the SN9C1xx PC Camera      *
- * Controllers                                                             *
- *                                                                         *
- * Copyright (C) 2007 by Luca Risolia <luca.risolia@studio.unibo.it>       *
- *                                                                         *
- * This program is free software; you can redistribute it and/or modify    *
- * it under the terms of the GNU General Public License as published by    *
- * the Free Software Foundation; either version 2 of the License, or       *
- * (at your option) any later version.                                     *
- *                                                                         *
- * This program is distributed in the hope that it will be useful,         *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
- * GNU General Public License for more details.                            *
- *                                                                         *
- * You should have received a copy of the GNU General Public License       *
- * along with this program; if not, write to the Free Software             *
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.               *
- ***************************************************************************/
-
-#include "sn9c102_sensor.h"
-#include "sn9c102_devtable.h"
-
-
-static int ov7660_init(struct sn9c102_device* cam)
-{
-	int err = 0;
-
-	err = sn9c102_write_const_regs(cam, {0x40, 0x02}, {0x00, 0x03},
-				       {0x1a, 0x04}, {0x03, 0x10},
-				       {0x08, 0x14}, {0x20, 0x17},
-				       {0x8b, 0x18}, {0x00, 0x19},
-				       {0x1d, 0x1a}, {0x10, 0x1b},
-				       {0x02, 0x1c}, {0x03, 0x1d},
-				       {0x0f, 0x1e}, {0x0c, 0x1f},
-				       {0x00, 0x20}, {0x29, 0x21},
-				       {0x40, 0x22}, {0x54, 0x23},
-				       {0x66, 0x24}, {0x76, 0x25},
-				       {0x85, 0x26}, {0x94, 0x27},
-				       {0xa1, 0x28}, {0xae, 0x29},
-				       {0xbb, 0x2a}, {0xc7, 0x2b},
-				       {0xd3, 0x2c}, {0xde, 0x2d},
-				       {0xea, 0x2e}, {0xf4, 0x2f},
-				       {0xff, 0x30}, {0x00, 0x3f},
-				       {0xc7, 0x40}, {0x01, 0x41},
-				       {0x44, 0x42}, {0x00, 0x43},
-				       {0x44, 0x44}, {0x00, 0x45},
-				       {0x44, 0x46}, {0x00, 0x47},
-				       {0xc7, 0x48}, {0x01, 0x49},
-				       {0xc7, 0x4a}, {0x01, 0x4b},
-				       {0xc7, 0x4c}, {0x01, 0x4d},
-				       {0x44, 0x4e}, {0x00, 0x4f},
-				       {0x44, 0x50}, {0x00, 0x51},
-				       {0x44, 0x52}, {0x00, 0x53},
-				       {0xc7, 0x54}, {0x01, 0x55},
-				       {0xc7, 0x56}, {0x01, 0x57},
-				       {0xc7, 0x58}, {0x01, 0x59},
-				       {0x44, 0x5a}, {0x00, 0x5b},
-				       {0x44, 0x5c}, {0x00, 0x5d},
-				       {0x44, 0x5e}, {0x00, 0x5f},
-				       {0xc7, 0x60}, {0x01, 0x61},
-				       {0xc7, 0x62}, {0x01, 0x63},
-				       {0xc7, 0x64}, {0x01, 0x65},
-				       {0x44, 0x66}, {0x00, 0x67},
-				       {0x44, 0x68}, {0x00, 0x69},
-				       {0x44, 0x6a}, {0x00, 0x6b},
-				       {0xc7, 0x6c}, {0x01, 0x6d},
-				       {0xc7, 0x6e}, {0x01, 0x6f},
-				       {0xc7, 0x70}, {0x01, 0x71},
-				       {0x44, 0x72}, {0x00, 0x73},
-				       {0x44, 0x74}, {0x00, 0x75},
-				       {0x44, 0x76}, {0x00, 0x77},
-				       {0xc7, 0x78}, {0x01, 0x79},
-				       {0xc7, 0x7a}, {0x01, 0x7b},
-				       {0xc7, 0x7c}, {0x01, 0x7d},
-				       {0x44, 0x7e}, {0x00, 0x7f},
-				       {0x14, 0x84}, {0x00, 0x85},
-				       {0x27, 0x86}, {0x00, 0x87},
-				       {0x07, 0x88}, {0x00, 0x89},
-				       {0xec, 0x8a}, {0x0f, 0x8b},
-				       {0xd8, 0x8c}, {0x0f, 0x8d},
-				       {0x3d, 0x8e}, {0x00, 0x8f},
-				       {0x3d, 0x90}, {0x00, 0x91},
-				       {0xcd, 0x92}, {0x0f, 0x93},
-				       {0xf7, 0x94}, {0x0f, 0x95},
-				       {0x0c, 0x96}, {0x00, 0x97},
-				       {0x00, 0x98}, {0x66, 0x99},
-				       {0x05, 0x9a}, {0x00, 0x9b},
-				       {0x04, 0x9c}, {0x00, 0x9d},
-				       {0x08, 0x9e}, {0x00, 0x9f},
-				       {0x2d, 0xc0}, {0x2d, 0xc1},
-				       {0x3a, 0xc2}, {0x05, 0xc3},
-				       {0x04, 0xc4}, {0x3f, 0xc5},
-				       {0x00, 0xc6}, {0x00, 0xc7},
-				       {0x50, 0xc8}, {0x3C, 0xc9},
-				       {0x28, 0xca}, {0xd8, 0xcb},
-				       {0x14, 0xcc}, {0xec, 0xcd},
-				       {0x32, 0xce}, {0xdd, 0xcf},
-				       {0x32, 0xd0}, {0xdd, 0xd1},
-				       {0x6a, 0xd2}, {0x50, 0xd3},
-				       {0x00, 0xd4}, {0x00, 0xd5},
-				       {0x00, 0xd6});
-
-	err += sn9c102_i2c_write(cam, 0x12, 0x80);
-	err += sn9c102_i2c_write(cam, 0x11, 0x09);
-	err += sn9c102_i2c_write(cam, 0x00, 0x0A);
-	err += sn9c102_i2c_write(cam, 0x01, 0x80);
-	err += sn9c102_i2c_write(cam, 0x02, 0x80);
-	err += sn9c102_i2c_write(cam, 0x03, 0x00);
-	err += sn9c102_i2c_write(cam, 0x04, 0x00);
-	err += sn9c102_i2c_write(cam, 0x05, 0x08);
-	err += sn9c102_i2c_write(cam, 0x06, 0x0B);
-	err += sn9c102_i2c_write(cam, 0x07, 0x00);
-	err += sn9c102_i2c_write(cam, 0x08, 0x1C);
-	err += sn9c102_i2c_write(cam, 0x09, 0x01);
-	err += sn9c102_i2c_write(cam, 0x0A, 0x76);
-	err += sn9c102_i2c_write(cam, 0x0B, 0x60);
-	err += sn9c102_i2c_write(cam, 0x0C, 0x00);
-	err += sn9c102_i2c_write(cam, 0x0D, 0x08);
-	err += sn9c102_i2c_write(cam, 0x0E, 0x04);
-	err += sn9c102_i2c_write(cam, 0x0F, 0x6F);
-	err += sn9c102_i2c_write(cam, 0x10, 0x20);
-	err += sn9c102_i2c_write(cam, 0x11, 0x03);
-	err += sn9c102_i2c_write(cam, 0x12, 0x05);
-	err += sn9c102_i2c_write(cam, 0x13, 0xC7);
-	err += sn9c102_i2c_write(cam, 0x14, 0x2C);
-	err += sn9c102_i2c_write(cam, 0x15, 0x00);
-	err += sn9c102_i2c_write(cam, 0x16, 0x02);
-	err += sn9c102_i2c_write(cam, 0x17, 0x10);
-	err += sn9c102_i2c_write(cam, 0x18, 0x60);
-	err += sn9c102_i2c_write(cam, 0x19, 0x02);
-	err += sn9c102_i2c_write(cam, 0x1A, 0x7B);
-	err += sn9c102_i2c_write(cam, 0x1B, 0x02);
-	err += sn9c102_i2c_write(cam, 0x1C, 0x7F);
-	err += sn9c102_i2c_write(cam, 0x1D, 0xA2);
-	err += sn9c102_i2c_write(cam, 0x1E, 0x01);
-	err += sn9c102_i2c_write(cam, 0x1F, 0x0E);
-	err += sn9c102_i2c_write(cam, 0x20, 0x05);
-	err += sn9c102_i2c_write(cam, 0x21, 0x05);
-	err += sn9c102_i2c_write(cam, 0x22, 0x05);
-	err += sn9c102_i2c_write(cam, 0x23, 0x05);
-	err += sn9c102_i2c_write(cam, 0x24, 0x68);
-	err += sn9c102_i2c_write(cam, 0x25, 0x58);
-	err += sn9c102_i2c_write(cam, 0x26, 0xD4);
-	err += sn9c102_i2c_write(cam, 0x27, 0x80);
-	err += sn9c102_i2c_write(cam, 0x28, 0x80);
-	err += sn9c102_i2c_write(cam, 0x29, 0x30);
-	err += sn9c102_i2c_write(cam, 0x2A, 0x00);
-	err += sn9c102_i2c_write(cam, 0x2B, 0x00);
-	err += sn9c102_i2c_write(cam, 0x2C, 0x80);
-	err += sn9c102_i2c_write(cam, 0x2D, 0x00);
-	err += sn9c102_i2c_write(cam, 0x2E, 0x00);
-	err += sn9c102_i2c_write(cam, 0x2F, 0x0E);
-	err += sn9c102_i2c_write(cam, 0x30, 0x08);
-	err += sn9c102_i2c_write(cam, 0x31, 0x30);
-	err += sn9c102_i2c_write(cam, 0x32, 0xB4);
-	err += sn9c102_i2c_write(cam, 0x33, 0x00);
-	err += sn9c102_i2c_write(cam, 0x34, 0x07);
-	err += sn9c102_i2c_write(cam, 0x35, 0x84);
-	err += sn9c102_i2c_write(cam, 0x36, 0x00);
-	err += sn9c102_i2c_write(cam, 0x37, 0x0C);
-	err += sn9c102_i2c_write(cam, 0x38, 0x02);
-	err += sn9c102_i2c_write(cam, 0x39, 0x43);
-	err += sn9c102_i2c_write(cam, 0x3A, 0x00);
-	err += sn9c102_i2c_write(cam, 0x3B, 0x0A);
-	err += sn9c102_i2c_write(cam, 0x3C, 0x6C);
-	err += sn9c102_i2c_write(cam, 0x3D, 0x99);
-	err += sn9c102_i2c_write(cam, 0x3E, 0x0E);
-	err += sn9c102_i2c_write(cam, 0x3F, 0x41);
-	err += sn9c102_i2c_write(cam, 0x40, 0xC1);
-	err += sn9c102_i2c_write(cam, 0x41, 0x22);
-	err += sn9c102_i2c_write(cam, 0x42, 0x08);
-	err += sn9c102_i2c_write(cam, 0x43, 0xF0);
-	err += sn9c102_i2c_write(cam, 0x44, 0x10);
-	err += sn9c102_i2c_write(cam, 0x45, 0x78);
-	err += sn9c102_i2c_write(cam, 0x46, 0xA8);
-	err += sn9c102_i2c_write(cam, 0x47, 0x60);
-	err += sn9c102_i2c_write(cam, 0x48, 0x80);
-	err += sn9c102_i2c_write(cam, 0x49, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4A, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4B, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4C, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4D, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4E, 0x00);
-	err += sn9c102_i2c_write(cam, 0x4F, 0x46);
-	err += sn9c102_i2c_write(cam, 0x50, 0x36);
-	err += sn9c102_i2c_write(cam, 0x51, 0x0F);
-	err += sn9c102_i2c_write(cam, 0x52, 0x17);
-	err += sn9c102_i2c_write(cam, 0x53, 0x7F);
-	err += sn9c102_i2c_write(cam, 0x54, 0x96);
-	err += sn9c102_i2c_write(cam, 0x55, 0x40);
-	err += sn9c102_i2c_write(cam, 0x56, 0x40);
-	err += sn9c102_i2c_write(cam, 0x57, 0x40);
-	err += sn9c102_i2c_write(cam, 0x58, 0x0F);
-	err += sn9c102_i2c_write(cam, 0x59, 0xBA);
-	err += sn9c102_i2c_write(cam, 0x5A, 0x9A);
-	err += sn9c102_i2c_write(cam, 0x5B, 0x22);
-	err += sn9c102_i2c_write(cam, 0x5C, 0xB9);
-	err += sn9c102_i2c_write(cam, 0x5D, 0x9B);
-	err += sn9c102_i2c_write(cam, 0x5E, 0x10);
-	err += sn9c102_i2c_write(cam, 0x5F, 0xF0);
-	err += sn9c102_i2c_write(cam, 0x60, 0x05);
-	err += sn9c102_i2c_write(cam, 0x61, 0x60);
-	err += sn9c102_i2c_write(cam, 0x62, 0x00);
-	err += sn9c102_i2c_write(cam, 0x63, 0x00);
-	err += sn9c102_i2c_write(cam, 0x64, 0x50);
-	err += sn9c102_i2c_write(cam, 0x65, 0x30);
-	err += sn9c102_i2c_write(cam, 0x66, 0x00);
-	err += sn9c102_i2c_write(cam, 0x67, 0x80);
-	err += sn9c102_i2c_write(cam, 0x68, 0x7A);
-	err += sn9c102_i2c_write(cam, 0x69, 0x90);
-	err += sn9c102_i2c_write(cam, 0x6A, 0x80);
-	err += sn9c102_i2c_write(cam, 0x6B, 0x0A);
-	err += sn9c102_i2c_write(cam, 0x6C, 0x30);
-	err += sn9c102_i2c_write(cam, 0x6D, 0x48);
-	err += sn9c102_i2c_write(cam, 0x6E, 0x80);
-	err += sn9c102_i2c_write(cam, 0x6F, 0x74);
-	err += sn9c102_i2c_write(cam, 0x70, 0x64);
-	err += sn9c102_i2c_write(cam, 0x71, 0x60);
-	err += sn9c102_i2c_write(cam, 0x72, 0x5C);
-	err += sn9c102_i2c_write(cam, 0x73, 0x58);
-	err += sn9c102_i2c_write(cam, 0x74, 0x54);
-	err += sn9c102_i2c_write(cam, 0x75, 0x4C);
-	err += sn9c102_i2c_write(cam, 0x76, 0x40);
-	err += sn9c102_i2c_write(cam, 0x77, 0x38);
-	err += sn9c102_i2c_write(cam, 0x78, 0x34);
-	err += sn9c102_i2c_write(cam, 0x79, 0x30);
-	err += sn9c102_i2c_write(cam, 0x7A, 0x2F);
-	err += sn9c102_i2c_write(cam, 0x7B, 0x2B);
-	err += sn9c102_i2c_write(cam, 0x7C, 0x03);
-	err += sn9c102_i2c_write(cam, 0x7D, 0x07);
-	err += sn9c102_i2c_write(cam, 0x7E, 0x17);
-	err += sn9c102_i2c_write(cam, 0x7F, 0x34);
-	err += sn9c102_i2c_write(cam, 0x80, 0x41);
-	err += sn9c102_i2c_write(cam, 0x81, 0x4D);
-	err += sn9c102_i2c_write(cam, 0x82, 0x58);
-	err += sn9c102_i2c_write(cam, 0x83, 0x63);
-	err += sn9c102_i2c_write(cam, 0x84, 0x6E);
-	err += sn9c102_i2c_write(cam, 0x85, 0x77);
-	err += sn9c102_i2c_write(cam, 0x86, 0x87);
-	err += sn9c102_i2c_write(cam, 0x87, 0x95);
-	err += sn9c102_i2c_write(cam, 0x88, 0xAF);
-	err += sn9c102_i2c_write(cam, 0x89, 0xC7);
-	err += sn9c102_i2c_write(cam, 0x8A, 0xDF);
-	err += sn9c102_i2c_write(cam, 0x8B, 0x99);
-	err += sn9c102_i2c_write(cam, 0x8C, 0x99);
-	err += sn9c102_i2c_write(cam, 0x8D, 0xCF);
-	err += sn9c102_i2c_write(cam, 0x8E, 0x20);
-	err += sn9c102_i2c_write(cam, 0x8F, 0x26);
-	err += sn9c102_i2c_write(cam, 0x90, 0x10);
-	err += sn9c102_i2c_write(cam, 0x91, 0x0C);
-	err += sn9c102_i2c_write(cam, 0x92, 0x25);
-	err += sn9c102_i2c_write(cam, 0x93, 0x00);
-	err += sn9c102_i2c_write(cam, 0x94, 0x50);
-	err += sn9c102_i2c_write(cam, 0x95, 0x50);
-	err += sn9c102_i2c_write(cam, 0x96, 0x00);
-	err += sn9c102_i2c_write(cam, 0x97, 0x01);
-	err += sn9c102_i2c_write(cam, 0x98, 0x10);
-	err += sn9c102_i2c_write(cam, 0x99, 0x40);
-	err += sn9c102_i2c_write(cam, 0x9A, 0x40);
-	err += sn9c102_i2c_write(cam, 0x9B, 0x20);
-	err += sn9c102_i2c_write(cam, 0x9C, 0x00);
-	err += sn9c102_i2c_write(cam, 0x9D, 0x99);
-	err += sn9c102_i2c_write(cam, 0x9E, 0x7F);
-	err += sn9c102_i2c_write(cam, 0x9F, 0x00);
-	err += sn9c102_i2c_write(cam, 0xA0, 0x00);
-	err += sn9c102_i2c_write(cam, 0xA1, 0x00);
-
-	return err;
-}
-
-
-static int ov7660_get_ctrl(struct sn9c102_device* cam,
-			   struct v4l2_control* ctrl)
-{
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_EXPOSURE:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x10)) < 0)
-			return -EIO;
-		break;
-	case V4L2_CID_DO_WHITE_BALANCE:
-		if ((ctrl->value = sn9c102_read_reg(cam, 0x02)) < 0)
-			return -EIO;
-		ctrl->value = (ctrl->value & 0x04) ? 1 : 0;
-		break;
-	case V4L2_CID_RED_BALANCE:
-		if ((ctrl->value = sn9c102_read_reg(cam, 0x05)) < 0)
-			return -EIO;
-		ctrl->value &= 0x7f;
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		if ((ctrl->value = sn9c102_read_reg(cam, 0x06)) < 0)
-			return -EIO;
-		ctrl->value &= 0x7f;
-		break;
-	case SN9C102_V4L2_CID_GREEN_BALANCE:
-		if ((ctrl->value = sn9c102_read_reg(cam, 0x07)) < 0)
-			return -EIO;
-		ctrl->value &= 0x7f;
-		break;
-	case SN9C102_V4L2_CID_BAND_FILTER:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x3b)) < 0)
-			return -EIO;
-		ctrl->value &= 0x08;
-		break;
-	case V4L2_CID_GAIN:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x00)) < 0)
-			return -EIO;
-		ctrl->value &= 0x1f;
-		break;
-	case V4L2_CID_AUTOGAIN:
-		if ((ctrl->value = sn9c102_i2c_read(cam, 0x13)) < 0)
-			return -EIO;
-		ctrl->value &= 0x01;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return err ? -EIO : 0;
-}
-
-
-static int ov7660_set_ctrl(struct sn9c102_device* cam,
-			   const struct v4l2_control* ctrl)
-{
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_EXPOSURE:
-		err += sn9c102_i2c_write(cam, 0x10, ctrl->value);
-		break;
-	case V4L2_CID_DO_WHITE_BALANCE:
-		err += sn9c102_write_reg(cam, 0x43 | (ctrl->value << 2), 0x02);
-		break;
-	case V4L2_CID_RED_BALANCE:
-		err += sn9c102_write_reg(cam, ctrl->value, 0x05);
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		err += sn9c102_write_reg(cam, ctrl->value, 0x06);
-		break;
-	case SN9C102_V4L2_CID_GREEN_BALANCE:
-		err += sn9c102_write_reg(cam, ctrl->value, 0x07);
-		break;
-	case SN9C102_V4L2_CID_BAND_FILTER:
-		err += sn9c102_i2c_write(cam, ctrl->value << 3, 0x3b);
-		break;
-	case V4L2_CID_GAIN:
-		err += sn9c102_i2c_write(cam, 0x00, 0x60 + ctrl->value);
-		break;
-	case V4L2_CID_AUTOGAIN:
-		err += sn9c102_i2c_write(cam, 0x13, 0xc0 |
-						    (ctrl->value * 0x07));
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return err ? -EIO : 0;
-}
-
-
-static int ov7660_set_crop(struct sn9c102_device* cam,
-			   const struct v4l2_rect* rect)
-{
-	struct sn9c102_sensor* s = sn9c102_get_sensor(cam);
-	int err = 0;
-	u8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 1,
-	   v_start = (u8)(rect->top - s->cropcap.bounds.top) + 1;
-
-	err += sn9c102_write_reg(cam, h_start, 0x12);
-	err += sn9c102_write_reg(cam, v_start, 0x13);
-
-	return err;
-}
-
-
-static int ov7660_set_pix_format(struct sn9c102_device* cam,
-				 const struct v4l2_pix_format* pix)
-{
-	int r0, err = 0;
-
-	r0 = sn9c102_pread_reg(cam, 0x01);
-
-	if (pix->pixelformat == V4L2_PIX_FMT_JPEG) {
-		err += sn9c102_write_reg(cam, r0 | 0x40, 0x01);
-		err += sn9c102_write_reg(cam, 0xa2, 0x17);
-		err += sn9c102_i2c_write(cam, 0x11, 0x00);
-	} else {
-		err += sn9c102_write_reg(cam, r0 | 0x40, 0x01);
-		err += sn9c102_write_reg(cam, 0xa2, 0x17);
-		err += sn9c102_i2c_write(cam, 0x11, 0x0d);
-	}
-
-	return err;
-}
-
-
-static const struct sn9c102_sensor ov7660 = {
-	.name = "OV7660",
-	.maintainer = "Luca Risolia <luca.risolia@studio.unibo.it>",
-	.supported_bridge = BRIDGE_SN9C105 | BRIDGE_SN9C120,
-	.sysfs_ops = SN9C102_I2C_READ | SN9C102_I2C_WRITE,
-	.frequency = SN9C102_I2C_100KHZ,
-	.interface = SN9C102_I2C_2WIRES,
-	.i2c_slave_id = 0x21,
-	.init = &ov7660_init,
-	.qctrl = {
-		{
-			.id = V4L2_CID_GAIN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "global gain",
-			.minimum = 0x00,
-			.maximum = 0x1f,
-			.step = 0x01,
-			.default_value = 0x09,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_EXPOSURE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "exposure",
-			.minimum = 0x00,
-			.maximum = 0xff,
-			.step = 0x01,
-			.default_value = 0x27,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_DO_WHITE_BALANCE,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "night mode",
-			.minimum = 0x00,
-			.maximum = 0x01,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_RED_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "red balance",
-			.minimum = 0x00,
-			.maximum = 0x7f,
-			.step = 0x01,
-			.default_value = 0x14,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_BLUE_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "blue balance",
-			.minimum = 0x00,
-			.maximum = 0x7f,
-			.step = 0x01,
-			.default_value = 0x14,
-			.flags = 0,
-		},
-		{
-			.id = V4L2_CID_AUTOGAIN,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "auto adjust",
-			.minimum = 0x00,
-			.maximum = 0x01,
-			.step = 0x01,
-			.default_value = 0x01,
-			.flags = 0,
-		},
-		{
-			.id = SN9C102_V4L2_CID_GREEN_BALANCE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "green balance",
-			.minimum = 0x00,
-			.maximum = 0x7f,
-			.step = 0x01,
-			.default_value = 0x14,
-			.flags = 0,
-		},
-		{
-			.id = SN9C102_V4L2_CID_BAND_FILTER,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "band filter",
-			.minimum = 0x00,
-			.maximum = 0x01,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-	},
-	.get_ctrl = &ov7660_get_ctrl,
-	.set_ctrl = &ov7660_set_ctrl,
-	.cropcap = {
-		.bounds = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-		.defrect = {
-			.left = 0,
-			.top = 0,
-			.width = 640,
-			.height = 480,
-		},
-	},
-	.set_crop = &ov7660_set_crop,
-	.pix_format = {
-		.width = 640,
-		.height = 480,
-		.pixelformat = V4L2_PIX_FMT_JPEG,
-		.priv = 8,
-	},
-	.set_pix_format = &ov7660_set_pix_format
-};
-
-
-int sn9c102_probe_ov7660(struct sn9c102_device* cam)
-{
-	int pid, ver, err;
-
-	err = sn9c102_write_const_regs(cam, {0x01, 0xf1}, {0x00, 0xf1},
-				       {0x01, 0x01}, {0x00, 0x01},
-				       {0x28, 0x17});
-
-	pid = sn9c102_i2c_try_read(cam, &ov7660, 0x0a);
-	ver = sn9c102_i2c_try_read(cam, &ov7660, 0x0b);
-	if (err || pid < 0 || ver < 0)
-		return -EIO;
-	if (pid != 0x76 || ver != 0x60)
-		return -ENODEV;
-
-	sn9c102_attach_sensor(cam, &ov7660);
-
-	return 0;
-}
diff -urN flo-ElementalX-5.00/drivers/net/ethernet/smsc/smsc9420.c flo-ElementalX-5.00-patched/drivers/net/ethernet/smsc/smsc9420.c
--- flo-ElementalX-5.00/drivers/net/ethernet/smsc/smsc9420.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/net/ethernet/smsc/smsc9420.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,1760 +0,0 @@
- /***************************************************************************
- *
- * Copyright (C) 2007,2008  SMSC
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- ***************************************************************************
- */
-
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/netdevice.h>
-#include <linux/phy.h>
-#include <linux/pci.h>
-#include <linux/if_vlan.h>
-#include <linux/dma-mapping.h>
-#include <linux/crc32.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <asm/unaligned.h>
-#include "smsc9420.h"
-
-#define DRV_NAME		"smsc9420"
-#define PFX			DRV_NAME ": "
-#define DRV_MDIONAME		"smsc9420-mdio"
-#define DRV_DESCRIPTION		"SMSC LAN9420 driver"
-#define DRV_VERSION		"1.01"
-
-MODULE_LICENSE("GPL");
-MODULE_VERSION(DRV_VERSION);
-
-struct smsc9420_dma_desc {
-	u32 status;
-	u32 length;
-	u32 buffer1;
-	u32 buffer2;
-};
-
-struct smsc9420_ring_info {
-	struct sk_buff *skb;
-	dma_addr_t mapping;
-};
-
-struct smsc9420_pdata {
-	void __iomem *base_addr;
-	struct pci_dev *pdev;
-	struct net_device *dev;
-
-	struct smsc9420_dma_desc *rx_ring;
-	struct smsc9420_dma_desc *tx_ring;
-	struct smsc9420_ring_info *tx_buffers;
-	struct smsc9420_ring_info *rx_buffers;
-	dma_addr_t rx_dma_addr;
-	dma_addr_t tx_dma_addr;
-	int tx_ring_head, tx_ring_tail;
-	int rx_ring_head, rx_ring_tail;
-
-	spinlock_t int_lock;
-	spinlock_t phy_lock;
-
-	struct napi_struct napi;
-
-	bool software_irq_signal;
-	bool rx_csum;
-	u32 msg_enable;
-
-	struct phy_device *phy_dev;
-	struct mii_bus *mii_bus;
-	int phy_irq[PHY_MAX_ADDR];
-	int last_duplex;
-	int last_carrier;
-};
-
-static DEFINE_PCI_DEVICE_TABLE(smsc9420_id_table) = {
-	{ PCI_VENDOR_ID_9420, PCI_DEVICE_ID_9420, PCI_ANY_ID, PCI_ANY_ID, },
-	{ 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, smsc9420_id_table);
-
-#define SMSC_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
-
-static uint smsc_debug;
-static uint debug = -1;
-module_param(debug, uint, 0);
-MODULE_PARM_DESC(debug, "debug level");
-
-#define smsc_dbg(TYPE, f, a...) \
-do {	if ((pd)->msg_enable & NETIF_MSG_##TYPE) \
-		printk(KERN_DEBUG PFX f "\n", ## a); \
-} while (0)
-
-#define smsc_info(TYPE, f, a...) \
-do {	if ((pd)->msg_enable & NETIF_MSG_##TYPE) \
-		printk(KERN_INFO PFX f "\n", ## a); \
-} while (0)
-
-#define smsc_warn(TYPE, f, a...) \
-do {	if ((pd)->msg_enable & NETIF_MSG_##TYPE) \
-		printk(KERN_WARNING PFX f "\n", ## a); \
-} while (0)
-
-static inline u32 smsc9420_reg_read(struct smsc9420_pdata *pd, u32 offset)
-{
-	return ioread32(pd->base_addr + offset);
-}
-
-static inline void
-smsc9420_reg_write(struct smsc9420_pdata *pd, u32 offset, u32 value)
-{
-	iowrite32(value, pd->base_addr + offset);
-}
-
-static inline void smsc9420_pci_flush_write(struct smsc9420_pdata *pd)
-{
-	/* to ensure PCI write completion, we must perform a PCI read */
-	smsc9420_reg_read(pd, ID_REV);
-}
-
-static int smsc9420_mii_read(struct mii_bus *bus, int phyaddr, int regidx)
-{
-	struct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;
-	unsigned long flags;
-	u32 addr;
-	int i, reg = -EIO;
-
-	spin_lock_irqsave(&pd->phy_lock, flags);
-
-	/*  confirm MII not busy */
-	if ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {
-		smsc_warn(DRV, "MII is busy???");
-		goto out;
-	}
-
-	/* set the address, index & direction (read from PHY) */
-	addr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |
-		MII_ACCESS_MII_READ_;
-	smsc9420_reg_write(pd, MII_ACCESS, addr);
-
-	/* wait for read to complete with 50us timeout */
-	for (i = 0; i < 5; i++) {
-		if (!(smsc9420_reg_read(pd, MII_ACCESS) &
-			MII_ACCESS_MII_BUSY_)) {
-			reg = (u16)smsc9420_reg_read(pd, MII_DATA);
-			goto out;
-		}
-		udelay(10);
-	}
-
-	smsc_warn(DRV, "MII busy timeout!");
-
-out:
-	spin_unlock_irqrestore(&pd->phy_lock, flags);
-	return reg;
-}
-
-static int smsc9420_mii_write(struct mii_bus *bus, int phyaddr, int regidx,
-			   u16 val)
-{
-	struct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;
-	unsigned long flags;
-	u32 addr;
-	int i, reg = -EIO;
-
-	spin_lock_irqsave(&pd->phy_lock, flags);
-
-	/* confirm MII not busy */
-	if ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {
-		smsc_warn(DRV, "MII is busy???");
-		goto out;
-	}
-
-	/* put the data to write in the MAC */
-	smsc9420_reg_write(pd, MII_DATA, (u32)val);
-
-	/* set the address, index & direction (write to PHY) */
-	addr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |
-		MII_ACCESS_MII_WRITE_;
-	smsc9420_reg_write(pd, MII_ACCESS, addr);
-
-	/* wait for write to complete with 50us timeout */
-	for (i = 0; i < 5; i++) {
-		if (!(smsc9420_reg_read(pd, MII_ACCESS) &
-			MII_ACCESS_MII_BUSY_)) {
-			reg = 0;
-			goto out;
-		}
-		udelay(10);
-	}
-
-	smsc_warn(DRV, "MII busy timeout!");
-
-out:
-	spin_unlock_irqrestore(&pd->phy_lock, flags);
-	return reg;
-}
-
-/* Returns hash bit number for given MAC address
- * Example:
- * 01 00 5E 00 00 01 -> returns bit number 31 */
-static u32 smsc9420_hash(u8 addr[ETH_ALEN])
-{
-	return (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;
-}
-
-static int smsc9420_eeprom_reload(struct smsc9420_pdata *pd)
-{
-	int timeout = 100000;
-
-	BUG_ON(!pd);
-
-	if (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {
-		smsc_dbg(DRV, "smsc9420_eeprom_reload: Eeprom busy");
-		return -EIO;
-	}
-
-	smsc9420_reg_write(pd, E2P_CMD,
-		(E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_RELOAD_));
-
-	do {
-		udelay(10);
-		if (!(smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_))
-			return 0;
-	} while (timeout--);
-
-	smsc_warn(DRV, "smsc9420_eeprom_reload: Eeprom timed out");
-	return -EIO;
-}
-
-/* Standard ioctls for mii-tool */
-static int smsc9420_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-
-	if (!netif_running(dev) || !pd->phy_dev)
-		return -EINVAL;
-
-	return phy_mii_ioctl(pd->phy_dev, ifr, cmd);
-}
-
-static int smsc9420_ethtool_get_settings(struct net_device *dev,
-					 struct ethtool_cmd *cmd)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-
-	if (!pd->phy_dev)
-		return -ENODEV;
-
-	cmd->maxtxpkt = 1;
-	cmd->maxrxpkt = 1;
-	return phy_ethtool_gset(pd->phy_dev, cmd);
-}
-
-static int smsc9420_ethtool_set_settings(struct net_device *dev,
-					 struct ethtool_cmd *cmd)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-
-	if (!pd->phy_dev)
-		return -ENODEV;
-
-	return phy_ethtool_sset(pd->phy_dev, cmd);
-}
-
-static void smsc9420_ethtool_get_drvinfo(struct net_device *netdev,
-					 struct ethtool_drvinfo *drvinfo)
-{
-	struct smsc9420_pdata *pd = netdev_priv(netdev);
-
-	strlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));
-	strlcpy(drvinfo->bus_info, pci_name(pd->pdev),
-		sizeof(drvinfo->bus_info));
-	strlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));
-}
-
-static u32 smsc9420_ethtool_get_msglevel(struct net_device *netdev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(netdev);
-	return pd->msg_enable;
-}
-
-static void smsc9420_ethtool_set_msglevel(struct net_device *netdev, u32 data)
-{
-	struct smsc9420_pdata *pd = netdev_priv(netdev);
-	pd->msg_enable = data;
-}
-
-static int smsc9420_ethtool_nway_reset(struct net_device *netdev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(netdev);
-
-	if (!pd->phy_dev)
-		return -ENODEV;
-
-	return phy_start_aneg(pd->phy_dev);
-}
-
-static int smsc9420_ethtool_getregslen(struct net_device *dev)
-{
-	/* all smsc9420 registers plus all phy registers */
-	return 0x100 + (32 * sizeof(u32));
-}
-
-static void
-smsc9420_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,
-			 void *buf)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	struct phy_device *phy_dev = pd->phy_dev;
-	unsigned int i, j = 0;
-	u32 *data = buf;
-
-	regs->version = smsc9420_reg_read(pd, ID_REV);
-	for (i = 0; i < 0x100; i += (sizeof(u32)))
-		data[j++] = smsc9420_reg_read(pd, i);
-
-	// cannot read phy registers if the net device is down
-	if (!phy_dev)
-		return;
-
-	for (i = 0; i <= 31; i++)
-		data[j++] = smsc9420_mii_read(phy_dev->bus, phy_dev->addr, i);
-}
-
-static void smsc9420_eeprom_enable_access(struct smsc9420_pdata *pd)
-{
-	unsigned int temp = smsc9420_reg_read(pd, GPIO_CFG);
-	temp &= ~GPIO_CFG_EEPR_EN_;
-	smsc9420_reg_write(pd, GPIO_CFG, temp);
-	msleep(1);
-}
-
-static int smsc9420_eeprom_send_cmd(struct smsc9420_pdata *pd, u32 op)
-{
-	int timeout = 100;
-	u32 e2cmd;
-
-	smsc_dbg(HW, "op 0x%08x", op);
-	if (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {
-		smsc_warn(HW, "Busy at start");
-		return -EBUSY;
-	}
-
-	e2cmd = op | E2P_CMD_EPC_BUSY_;
-	smsc9420_reg_write(pd, E2P_CMD, e2cmd);
-
-	do {
-		msleep(1);
-		e2cmd = smsc9420_reg_read(pd, E2P_CMD);
-	} while ((e2cmd & E2P_CMD_EPC_BUSY_) && (--timeout));
-
-	if (!timeout) {
-		smsc_info(HW, "TIMED OUT");
-		return -EAGAIN;
-	}
-
-	if (e2cmd & E2P_CMD_EPC_TIMEOUT_) {
-		smsc_info(HW, "Error occurred during eeprom operation");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int smsc9420_eeprom_read_location(struct smsc9420_pdata *pd,
-					 u8 address, u8 *data)
-{
-	u32 op = E2P_CMD_EPC_CMD_READ_ | address;
-	int ret;
-
-	smsc_dbg(HW, "address 0x%x", address);
-	ret = smsc9420_eeprom_send_cmd(pd, op);
-
-	if (!ret)
-		data[address] = smsc9420_reg_read(pd, E2P_DATA);
-
-	return ret;
-}
-
-static int smsc9420_eeprom_write_location(struct smsc9420_pdata *pd,
-					  u8 address, u8 data)
-{
-	u32 op = E2P_CMD_EPC_CMD_ERASE_ | address;
-	int ret;
-
-	smsc_dbg(HW, "address 0x%x, data 0x%x", address, data);
-	ret = smsc9420_eeprom_send_cmd(pd, op);
-
-	if (!ret) {
-		op = E2P_CMD_EPC_CMD_WRITE_ | address;
-		smsc9420_reg_write(pd, E2P_DATA, (u32)data);
-		ret = smsc9420_eeprom_send_cmd(pd, op);
-	}
-
-	return ret;
-}
-
-static int smsc9420_ethtool_get_eeprom_len(struct net_device *dev)
-{
-	return SMSC9420_EEPROM_SIZE;
-}
-
-static int smsc9420_ethtool_get_eeprom(struct net_device *dev,
-				       struct ethtool_eeprom *eeprom, u8 *data)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u8 eeprom_data[SMSC9420_EEPROM_SIZE];
-	int len, i;
-
-	smsc9420_eeprom_enable_access(pd);
-
-	len = min(eeprom->len, SMSC9420_EEPROM_SIZE);
-	for (i = 0; i < len; i++) {
-		int ret = smsc9420_eeprom_read_location(pd, i, eeprom_data);
-		if (ret < 0) {
-			eeprom->len = 0;
-			return ret;
-		}
-	}
-
-	memcpy(data, &eeprom_data[eeprom->offset], len);
-	eeprom->magic = SMSC9420_EEPROM_MAGIC;
-	eeprom->len = len;
-	return 0;
-}
-
-static int smsc9420_ethtool_set_eeprom(struct net_device *dev,
-				       struct ethtool_eeprom *eeprom, u8 *data)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	int ret;
-
-	if (eeprom->magic != SMSC9420_EEPROM_MAGIC)
-		return -EINVAL;
-
-	smsc9420_eeprom_enable_access(pd);
-	smsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWEN_);
-	ret = smsc9420_eeprom_write_location(pd, eeprom->offset, *data);
-	smsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWDS_);
-
-	/* Single byte write, according to man page */
-	eeprom->len = 1;
-
-	return ret;
-}
-
-static const struct ethtool_ops smsc9420_ethtool_ops = {
-	.get_settings = smsc9420_ethtool_get_settings,
-	.set_settings = smsc9420_ethtool_set_settings,
-	.get_drvinfo = smsc9420_ethtool_get_drvinfo,
-	.get_msglevel = smsc9420_ethtool_get_msglevel,
-	.set_msglevel = smsc9420_ethtool_set_msglevel,
-	.nway_reset = smsc9420_ethtool_nway_reset,
-	.get_link = ethtool_op_get_link,
-	.get_eeprom_len = smsc9420_ethtool_get_eeprom_len,
-	.get_eeprom = smsc9420_ethtool_get_eeprom,
-	.set_eeprom = smsc9420_ethtool_set_eeprom,
-	.get_regs_len = smsc9420_ethtool_getregslen,
-	.get_regs = smsc9420_ethtool_getregs,
-};
-
-/* Sets the device MAC address to dev_addr */
-static void smsc9420_set_mac_address(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u8 *dev_addr = dev->dev_addr;
-	u32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];
-	u32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
-	    (dev_addr[1] << 8) | dev_addr[0];
-
-	smsc9420_reg_write(pd, ADDRH, mac_high16);
-	smsc9420_reg_write(pd, ADDRL, mac_low32);
-}
-
-static void smsc9420_check_mac_address(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-
-	/* Check if mac address has been specified when bringing interface up */
-	if (is_valid_ether_addr(dev->dev_addr)) {
-		smsc9420_set_mac_address(dev);
-		smsc_dbg(PROBE, "MAC Address is specified by configuration");
-	} else {
-		/* Try reading mac address from device. if EEPROM is present
-		 * it will already have been set */
-		u32 mac_high16 = smsc9420_reg_read(pd, ADDRH);
-		u32 mac_low32 = smsc9420_reg_read(pd, ADDRL);
-		dev->dev_addr[0] = (u8)(mac_low32);
-		dev->dev_addr[1] = (u8)(mac_low32 >> 8);
-		dev->dev_addr[2] = (u8)(mac_low32 >> 16);
-		dev->dev_addr[3] = (u8)(mac_low32 >> 24);
-		dev->dev_addr[4] = (u8)(mac_high16);
-		dev->dev_addr[5] = (u8)(mac_high16 >> 8);
-
-		if (is_valid_ether_addr(dev->dev_addr)) {
-			/* eeprom values are valid  so use them */
-			smsc_dbg(PROBE, "Mac Address is read from EEPROM");
-		} else {
-			/* eeprom values are invalid, generate random MAC */
-			eth_hw_addr_random(dev);
-			smsc9420_set_mac_address(dev);
-			smsc_dbg(PROBE, "MAC Address is set to random");
-		}
-	}
-}
-
-static void smsc9420_stop_tx(struct smsc9420_pdata *pd)
-{
-	u32 dmac_control, mac_cr, dma_intr_ena;
-	int timeout = 1000;
-
-	/* disable TX DMAC */
-	dmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);
-	dmac_control &= (~DMAC_CONTROL_ST_);
-	smsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);
-
-	/* Wait max 10ms for transmit process to stop */
-	while (--timeout) {
-		if (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_TS_)
-			break;
-		udelay(10);
-	}
-
-	if (!timeout)
-		smsc_warn(IFDOWN, "TX DMAC failed to stop");
-
-	/* ACK Tx DMAC stop bit */
-	smsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_TXPS_);
-
-	/* mask TX DMAC interrupts */
-	dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
-	dma_intr_ena &= ~(DMAC_INTR_ENA_TX_);
-	smsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);
-	smsc9420_pci_flush_write(pd);
-
-	/* stop MAC TX */
-	mac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_TXEN_);
-	smsc9420_reg_write(pd, MAC_CR, mac_cr);
-	smsc9420_pci_flush_write(pd);
-}
-
-static void smsc9420_free_tx_ring(struct smsc9420_pdata *pd)
-{
-	int i;
-
-	BUG_ON(!pd->tx_ring);
-
-	if (!pd->tx_buffers)
-		return;
-
-	for (i = 0; i < TX_RING_SIZE; i++) {
-		struct sk_buff *skb = pd->tx_buffers[i].skb;
-
-		if (skb) {
-			BUG_ON(!pd->tx_buffers[i].mapping);
-			pci_unmap_single(pd->pdev, pd->tx_buffers[i].mapping,
-					 skb->len, PCI_DMA_TODEVICE);
-			dev_kfree_skb_any(skb);
-		}
-
-		pd->tx_ring[i].status = 0;
-		pd->tx_ring[i].length = 0;
-		pd->tx_ring[i].buffer1 = 0;
-		pd->tx_ring[i].buffer2 = 0;
-	}
-	wmb();
-
-	kfree(pd->tx_buffers);
-	pd->tx_buffers = NULL;
-
-	pd->tx_ring_head = 0;
-	pd->tx_ring_tail = 0;
-}
-
-static void smsc9420_free_rx_ring(struct smsc9420_pdata *pd)
-{
-	int i;
-
-	BUG_ON(!pd->rx_ring);
-
-	if (!pd->rx_buffers)
-		return;
-
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		if (pd->rx_buffers[i].skb)
-			dev_kfree_skb_any(pd->rx_buffers[i].skb);
-
-		if (pd->rx_buffers[i].mapping)
-			pci_unmap_single(pd->pdev, pd->rx_buffers[i].mapping,
-				PKT_BUF_SZ, PCI_DMA_FROMDEVICE);
-
-		pd->rx_ring[i].status = 0;
-		pd->rx_ring[i].length = 0;
-		pd->rx_ring[i].buffer1 = 0;
-		pd->rx_ring[i].buffer2 = 0;
-	}
-	wmb();
-
-	kfree(pd->rx_buffers);
-	pd->rx_buffers = NULL;
-
-	pd->rx_ring_head = 0;
-	pd->rx_ring_tail = 0;
-}
-
-static void smsc9420_stop_rx(struct smsc9420_pdata *pd)
-{
-	int timeout = 1000;
-	u32 mac_cr, dmac_control, dma_intr_ena;
-
-	/* mask RX DMAC interrupts */
-	dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
-	dma_intr_ena &= (~DMAC_INTR_ENA_RX_);
-	smsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);
-	smsc9420_pci_flush_write(pd);
-
-	/* stop RX MAC prior to stoping DMA */
-	mac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_RXEN_);
-	smsc9420_reg_write(pd, MAC_CR, mac_cr);
-	smsc9420_pci_flush_write(pd);
-
-	/* stop RX DMAC */
-	dmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);
-	dmac_control &= (~DMAC_CONTROL_SR_);
-	smsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);
-	smsc9420_pci_flush_write(pd);
-
-	/* wait up to 10ms for receive to stop */
-	while (--timeout) {
-		if (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_RS_)
-			break;
-		udelay(10);
-	}
-
-	if (!timeout)
-		smsc_warn(IFDOWN, "RX DMAC did not stop! timeout.");
-
-	/* ACK the Rx DMAC stop bit */
-	smsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_RXPS_);
-}
-
-static irqreturn_t smsc9420_isr(int irq, void *dev_id)
-{
-	struct smsc9420_pdata *pd = dev_id;
-	u32 int_cfg, int_sts, int_ctl;
-	irqreturn_t ret = IRQ_NONE;
-	ulong flags;
-
-	BUG_ON(!pd);
-	BUG_ON(!pd->base_addr);
-
-	int_cfg = smsc9420_reg_read(pd, INT_CFG);
-
-	/* check if it's our interrupt */
-	if ((int_cfg & (INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_)) !=
-	    (INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_))
-		return IRQ_NONE;
-
-	int_sts = smsc9420_reg_read(pd, INT_STAT);
-
-	if (likely(INT_STAT_DMAC_INT_ & int_sts)) {
-		u32 status = smsc9420_reg_read(pd, DMAC_STATUS);
-		u32 ints_to_clear = 0;
-
-		if (status & DMAC_STS_TX_) {
-			ints_to_clear |= (DMAC_STS_TX_ | DMAC_STS_NIS_);
-			netif_wake_queue(pd->dev);
-		}
-
-		if (status & DMAC_STS_RX_) {
-			/* mask RX DMAC interrupts */
-			u32 dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
-			dma_intr_ena &= (~DMAC_INTR_ENA_RX_);
-			smsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);
-			smsc9420_pci_flush_write(pd);
-
-			ints_to_clear |= (DMAC_STS_RX_ | DMAC_STS_NIS_);
-			napi_schedule(&pd->napi);
-		}
-
-		if (ints_to_clear)
-			smsc9420_reg_write(pd, DMAC_STATUS, ints_to_clear);
-
-		ret = IRQ_HANDLED;
-	}
-
-	if (unlikely(INT_STAT_SW_INT_ & int_sts)) {
-		/* mask software interrupt */
-		spin_lock_irqsave(&pd->int_lock, flags);
-		int_ctl = smsc9420_reg_read(pd, INT_CTL);
-		int_ctl &= (~INT_CTL_SW_INT_EN_);
-		smsc9420_reg_write(pd, INT_CTL, int_ctl);
-		spin_unlock_irqrestore(&pd->int_lock, flags);
-
-		smsc9420_reg_write(pd, INT_STAT, INT_STAT_SW_INT_);
-		pd->software_irq_signal = true;
-		smp_wmb();
-
-		ret = IRQ_HANDLED;
-	}
-
-	/* to ensure PCI write completion, we must perform a PCI read */
-	smsc9420_pci_flush_write(pd);
-
-	return ret;
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void smsc9420_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-	smsc9420_isr(0, dev);
-	enable_irq(dev->irq);
-}
-#endif /* CONFIG_NET_POLL_CONTROLLER */
-
-static void smsc9420_dmac_soft_reset(struct smsc9420_pdata *pd)
-{
-	smsc9420_reg_write(pd, BUS_MODE, BUS_MODE_SWR_);
-	smsc9420_reg_read(pd, BUS_MODE);
-	udelay(2);
-	if (smsc9420_reg_read(pd, BUS_MODE) & BUS_MODE_SWR_)
-		smsc_warn(DRV, "Software reset not cleared");
-}
-
-static int smsc9420_stop(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u32 int_cfg;
-	ulong flags;
-
-	BUG_ON(!pd);
-	BUG_ON(!pd->phy_dev);
-
-	/* disable master interrupt */
-	spin_lock_irqsave(&pd->int_lock, flags);
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-
-	netif_tx_disable(dev);
-	napi_disable(&pd->napi);
-
-	smsc9420_stop_tx(pd);
-	smsc9420_free_tx_ring(pd);
-
-	smsc9420_stop_rx(pd);
-	smsc9420_free_rx_ring(pd);
-
-	free_irq(dev->irq, pd);
-
-	smsc9420_dmac_soft_reset(pd);
-
-	phy_stop(pd->phy_dev);
-
-	phy_disconnect(pd->phy_dev);
-	pd->phy_dev = NULL;
-	mdiobus_unregister(pd->mii_bus);
-	mdiobus_free(pd->mii_bus);
-
-	return 0;
-}
-
-static void smsc9420_rx_count_stats(struct net_device *dev, u32 desc_status)
-{
-	if (unlikely(desc_status & RDES0_ERROR_SUMMARY_)) {
-		dev->stats.rx_errors++;
-		if (desc_status & RDES0_DESCRIPTOR_ERROR_)
-			dev->stats.rx_over_errors++;
-		else if (desc_status & (RDES0_FRAME_TOO_LONG_ |
-			RDES0_RUNT_FRAME_ | RDES0_COLLISION_SEEN_))
-			dev->stats.rx_frame_errors++;
-		else if (desc_status & RDES0_CRC_ERROR_)
-			dev->stats.rx_crc_errors++;
-	}
-
-	if (unlikely(desc_status & RDES0_LENGTH_ERROR_))
-		dev->stats.rx_length_errors++;
-
-	if (unlikely(!((desc_status & RDES0_LAST_DESCRIPTOR_) &&
-		(desc_status & RDES0_FIRST_DESCRIPTOR_))))
-		dev->stats.rx_length_errors++;
-
-	if (desc_status & RDES0_MULTICAST_FRAME_)
-		dev->stats.multicast++;
-}
-
-static void smsc9420_rx_handoff(struct smsc9420_pdata *pd, const int index,
-				const u32 status)
-{
-	struct net_device *dev = pd->dev;
-	struct sk_buff *skb;
-	u16 packet_length = (status & RDES0_FRAME_LENGTH_MASK_)
-		>> RDES0_FRAME_LENGTH_SHFT_;
-
-	/* remove crc from packet lendth */
-	packet_length -= 4;
-
-	if (pd->rx_csum)
-		packet_length -= 2;
-
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += packet_length;
-
-	pci_unmap_single(pd->pdev, pd->rx_buffers[index].mapping,
-		PKT_BUF_SZ, PCI_DMA_FROMDEVICE);
-	pd->rx_buffers[index].mapping = 0;
-
-	skb = pd->rx_buffers[index].skb;
-	pd->rx_buffers[index].skb = NULL;
-
-	if (pd->rx_csum) {
-		u16 hw_csum = get_unaligned_le16(skb_tail_pointer(skb) +
-			NET_IP_ALIGN + packet_length + 4);
-		put_unaligned_le16(hw_csum, &skb->csum);
-		skb->ip_summed = CHECKSUM_COMPLETE;
-	}
-
-	skb_reserve(skb, NET_IP_ALIGN);
-	skb_put(skb, packet_length);
-
-	skb->protocol = eth_type_trans(skb, dev);
-
-	netif_receive_skb(skb);
-}
-
-static int smsc9420_alloc_rx_buffer(struct smsc9420_pdata *pd, int index)
-{
-	struct sk_buff *skb = netdev_alloc_skb(pd->dev, PKT_BUF_SZ);
-	dma_addr_t mapping;
-
-	BUG_ON(pd->rx_buffers[index].skb);
-	BUG_ON(pd->rx_buffers[index].mapping);
-
-	if (unlikely(!skb)) {
-		smsc_warn(RX_ERR, "Failed to allocate new skb!");
-		return -ENOMEM;
-	}
-
-	mapping = pci_map_single(pd->pdev, skb_tail_pointer(skb),
-				 PKT_BUF_SZ, PCI_DMA_FROMDEVICE);
-	if (pci_dma_mapping_error(pd->pdev, mapping)) {
-		dev_kfree_skb_any(skb);
-		smsc_warn(RX_ERR, "pci_map_single failed!");
-		return -ENOMEM;
-	}
-
-	pd->rx_buffers[index].skb = skb;
-	pd->rx_buffers[index].mapping = mapping;
-	pd->rx_ring[index].buffer1 = mapping + NET_IP_ALIGN;
-	pd->rx_ring[index].status = RDES0_OWN_;
-	wmb();
-
-	return 0;
-}
-
-static void smsc9420_alloc_new_rx_buffers(struct smsc9420_pdata *pd)
-{
-	while (pd->rx_ring_tail != pd->rx_ring_head) {
-		if (smsc9420_alloc_rx_buffer(pd, pd->rx_ring_tail))
-			break;
-
-		pd->rx_ring_tail = (pd->rx_ring_tail + 1) % RX_RING_SIZE;
-	}
-}
-
-static int smsc9420_rx_poll(struct napi_struct *napi, int budget)
-{
-	struct smsc9420_pdata *pd =
-		container_of(napi, struct smsc9420_pdata, napi);
-	struct net_device *dev = pd->dev;
-	u32 drop_frame_cnt, dma_intr_ena, status;
-	int work_done;
-
-	for (work_done = 0; work_done < budget; work_done++) {
-		rmb();
-		status = pd->rx_ring[pd->rx_ring_head].status;
-
-		/* stop if DMAC owns this dma descriptor */
-		if (status & RDES0_OWN_)
-			break;
-
-		smsc9420_rx_count_stats(dev, status);
-		smsc9420_rx_handoff(pd, pd->rx_ring_head, status);
-		pd->rx_ring_head = (pd->rx_ring_head + 1) % RX_RING_SIZE;
-		smsc9420_alloc_new_rx_buffers(pd);
-	}
-
-	drop_frame_cnt = smsc9420_reg_read(pd, MISS_FRAME_CNTR);
-	dev->stats.rx_dropped +=
-	    (drop_frame_cnt & 0xFFFF) + ((drop_frame_cnt >> 17) & 0x3FF);
-
-	/* Kick RXDMA */
-	smsc9420_reg_write(pd, RX_POLL_DEMAND, 1);
-	smsc9420_pci_flush_write(pd);
-
-	if (work_done < budget) {
-		napi_complete(&pd->napi);
-
-		/* re-enable RX DMA interrupts */
-		dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
-		dma_intr_ena |= (DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);
-		smsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);
-		smsc9420_pci_flush_write(pd);
-	}
-	return work_done;
-}
-
-static void
-smsc9420_tx_update_stats(struct net_device *dev, u32 status, u32 length)
-{
-	if (unlikely(status & TDES0_ERROR_SUMMARY_)) {
-		dev->stats.tx_errors++;
-		if (status & (TDES0_EXCESSIVE_DEFERRAL_ |
-			TDES0_EXCESSIVE_COLLISIONS_))
-			dev->stats.tx_aborted_errors++;
-
-		if (status & (TDES0_LOSS_OF_CARRIER_ | TDES0_NO_CARRIER_))
-			dev->stats.tx_carrier_errors++;
-	} else {
-		dev->stats.tx_packets++;
-		dev->stats.tx_bytes += (length & 0x7FF);
-	}
-
-	if (unlikely(status & TDES0_EXCESSIVE_COLLISIONS_)) {
-		dev->stats.collisions += 16;
-	} else {
-		dev->stats.collisions +=
-			(status & TDES0_COLLISION_COUNT_MASK_) >>
-			TDES0_COLLISION_COUNT_SHFT_;
-	}
-
-	if (unlikely(status & TDES0_HEARTBEAT_FAIL_))
-		dev->stats.tx_heartbeat_errors++;
-}
-
-/* Check for completed dma transfers, update stats and free skbs */
-static void smsc9420_complete_tx(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-
-	while (pd->tx_ring_tail != pd->tx_ring_head) {
-		int index = pd->tx_ring_tail;
-		u32 status, length;
-
-		rmb();
-		status = pd->tx_ring[index].status;
-		length = pd->tx_ring[index].length;
-
-		/* Check if DMA still owns this descriptor */
-		if (unlikely(TDES0_OWN_ & status))
-			break;
-
-		smsc9420_tx_update_stats(dev, status, length);
-
-		BUG_ON(!pd->tx_buffers[index].skb);
-		BUG_ON(!pd->tx_buffers[index].mapping);
-
-		pci_unmap_single(pd->pdev, pd->tx_buffers[index].mapping,
-			pd->tx_buffers[index].skb->len, PCI_DMA_TODEVICE);
-		pd->tx_buffers[index].mapping = 0;
-
-		dev_kfree_skb_any(pd->tx_buffers[index].skb);
-		pd->tx_buffers[index].skb = NULL;
-
-		pd->tx_ring[index].buffer1 = 0;
-		wmb();
-
-		pd->tx_ring_tail = (pd->tx_ring_tail + 1) % TX_RING_SIZE;
-	}
-}
-
-static netdev_tx_t smsc9420_hard_start_xmit(struct sk_buff *skb,
-					    struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	dma_addr_t mapping;
-	int index = pd->tx_ring_head;
-	u32 tmp_desc1;
-	bool about_to_take_last_desc =
-		(((pd->tx_ring_head + 2) % TX_RING_SIZE) == pd->tx_ring_tail);
-
-	smsc9420_complete_tx(dev);
-
-	rmb();
-	BUG_ON(pd->tx_ring[index].status & TDES0_OWN_);
-	BUG_ON(pd->tx_buffers[index].skb);
-	BUG_ON(pd->tx_buffers[index].mapping);
-
-	mapping = pci_map_single(pd->pdev, skb->data,
-				 skb->len, PCI_DMA_TODEVICE);
-	if (pci_dma_mapping_error(pd->pdev, mapping)) {
-		smsc_warn(TX_ERR, "pci_map_single failed, dropping packet");
-		return NETDEV_TX_BUSY;
-	}
-
-	pd->tx_buffers[index].skb = skb;
-	pd->tx_buffers[index].mapping = mapping;
-
-	tmp_desc1 = (TDES1_LS_ | ((u32)skb->len & 0x7FF));
-	if (unlikely(about_to_take_last_desc)) {
-		tmp_desc1 |= TDES1_IC_;
-		netif_stop_queue(pd->dev);
-	}
-
-	/* check if we are at the last descriptor and need to set EOR */
-	if (unlikely(index == (TX_RING_SIZE - 1)))
-		tmp_desc1 |= TDES1_TER_;
-
-	pd->tx_ring[index].buffer1 = mapping;
-	pd->tx_ring[index].length = tmp_desc1;
-	wmb();
-
-	/* increment head */
-	pd->tx_ring_head = (pd->tx_ring_head + 1) % TX_RING_SIZE;
-
-	/* assign ownership to DMAC */
-	pd->tx_ring[index].status = TDES0_OWN_;
-	wmb();
-
-	skb_tx_timestamp(skb);
-
-	/* kick the DMA */
-	smsc9420_reg_write(pd, TX_POLL_DEMAND, 1);
-	smsc9420_pci_flush_write(pd);
-
-	return NETDEV_TX_OK;
-}
-
-static struct net_device_stats *smsc9420_get_stats(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u32 counter = smsc9420_reg_read(pd, MISS_FRAME_CNTR);
-	dev->stats.rx_dropped +=
-	    (counter & 0x0000FFFF) + ((counter >> 17) & 0x000003FF);
-	return &dev->stats;
-}
-
-static void smsc9420_set_multicast_list(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u32 mac_cr = smsc9420_reg_read(pd, MAC_CR);
-
-	if (dev->flags & IFF_PROMISC) {
-		smsc_dbg(HW, "Promiscuous Mode Enabled");
-		mac_cr |= MAC_CR_PRMS_;
-		mac_cr &= (~MAC_CR_MCPAS_);
-		mac_cr &= (~MAC_CR_HPFILT_);
-	} else if (dev->flags & IFF_ALLMULTI) {
-		smsc_dbg(HW, "Receive all Multicast Enabled");
-		mac_cr &= (~MAC_CR_PRMS_);
-		mac_cr |= MAC_CR_MCPAS_;
-		mac_cr &= (~MAC_CR_HPFILT_);
-	} else if (!netdev_mc_empty(dev)) {
-		struct netdev_hw_addr *ha;
-		u32 hash_lo = 0, hash_hi = 0;
-
-		smsc_dbg(HW, "Multicast filter enabled");
-		netdev_for_each_mc_addr(ha, dev) {
-			u32 bit_num = smsc9420_hash(ha->addr);
-			u32 mask = 1 << (bit_num & 0x1F);
-
-			if (bit_num & 0x20)
-				hash_hi |= mask;
-			else
-				hash_lo |= mask;
-
-		}
-		smsc9420_reg_write(pd, HASHH, hash_hi);
-		smsc9420_reg_write(pd, HASHL, hash_lo);
-
-		mac_cr &= (~MAC_CR_PRMS_);
-		mac_cr &= (~MAC_CR_MCPAS_);
-		mac_cr |= MAC_CR_HPFILT_;
-	} else {
-		smsc_dbg(HW, "Receive own packets only.");
-		smsc9420_reg_write(pd, HASHH, 0);
-		smsc9420_reg_write(pd, HASHL, 0);
-
-		mac_cr &= (~MAC_CR_PRMS_);
-		mac_cr &= (~MAC_CR_MCPAS_);
-		mac_cr &= (~MAC_CR_HPFILT_);
-	}
-
-	smsc9420_reg_write(pd, MAC_CR, mac_cr);
-	smsc9420_pci_flush_write(pd);
-}
-
-static void smsc9420_phy_update_flowcontrol(struct smsc9420_pdata *pd)
-{
-	struct phy_device *phy_dev = pd->phy_dev;
-	u32 flow;
-
-	if (phy_dev->duplex == DUPLEX_FULL) {
-		u16 lcladv = phy_read(phy_dev, MII_ADVERTISE);
-		u16 rmtadv = phy_read(phy_dev, MII_LPA);
-		u8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
-
-		if (cap & FLOW_CTRL_RX)
-			flow = 0xFFFF0002;
-		else
-			flow = 0;
-
-		smsc_info(LINK, "rx pause %s, tx pause %s",
-			(cap & FLOW_CTRL_RX ? "enabled" : "disabled"),
-			(cap & FLOW_CTRL_TX ? "enabled" : "disabled"));
-	} else {
-		smsc_info(LINK, "half duplex");
-		flow = 0;
-	}
-
-	smsc9420_reg_write(pd, FLOW, flow);
-}
-
-/* Update link mode if anything has changed.  Called periodically when the
- * PHY is in polling mode, even if nothing has changed. */
-static void smsc9420_phy_adjust_link(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	struct phy_device *phy_dev = pd->phy_dev;
-	int carrier;
-
-	if (phy_dev->duplex != pd->last_duplex) {
-		u32 mac_cr = smsc9420_reg_read(pd, MAC_CR);
-		if (phy_dev->duplex) {
-			smsc_dbg(LINK, "full duplex mode");
-			mac_cr |= MAC_CR_FDPX_;
-		} else {
-			smsc_dbg(LINK, "half duplex mode");
-			mac_cr &= ~MAC_CR_FDPX_;
-		}
-		smsc9420_reg_write(pd, MAC_CR, mac_cr);
-
-		smsc9420_phy_update_flowcontrol(pd);
-		pd->last_duplex = phy_dev->duplex;
-	}
-
-	carrier = netif_carrier_ok(dev);
-	if (carrier != pd->last_carrier) {
-		if (carrier)
-			smsc_dbg(LINK, "carrier OK");
-		else
-			smsc_dbg(LINK, "no carrier");
-		pd->last_carrier = carrier;
-	}
-}
-
-static int smsc9420_mii_probe(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	struct phy_device *phydev = NULL;
-
-	BUG_ON(pd->phy_dev);
-
-	/* Device only supports internal PHY at address 1 */
-	if (!pd->mii_bus->phy_map[1]) {
-		pr_err("%s: no PHY found at address 1\n", dev->name);
-		return -ENODEV;
-	}
-
-	phydev = pd->mii_bus->phy_map[1];
-	smsc_info(PROBE, "PHY addr %d, phy_id 0x%08X", phydev->addr,
-		phydev->phy_id);
-
-	phydev = phy_connect(dev, dev_name(&phydev->dev),
-		smsc9420_phy_adjust_link, 0, PHY_INTERFACE_MODE_MII);
-
-	if (IS_ERR(phydev)) {
-		pr_err("%s: Could not attach to PHY\n", dev->name);
-		return PTR_ERR(phydev);
-	}
-
-	pr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
-		dev->name, phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
-
-	/* mask with MAC supported features */
-	phydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
-			      SUPPORTED_Asym_Pause);
-	phydev->advertising = phydev->supported;
-
-	pd->phy_dev = phydev;
-	pd->last_duplex = -1;
-	pd->last_carrier = -1;
-
-	return 0;
-}
-
-static int smsc9420_mii_init(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	int err = -ENXIO, i;
-
-	pd->mii_bus = mdiobus_alloc();
-	if (!pd->mii_bus) {
-		err = -ENOMEM;
-		goto err_out_1;
-	}
-	pd->mii_bus->name = DRV_MDIONAME;
-	snprintf(pd->mii_bus->id, MII_BUS_ID_SIZE, "%x",
-		(pd->pdev->bus->number << 8) | pd->pdev->devfn);
-	pd->mii_bus->priv = pd;
-	pd->mii_bus->read = smsc9420_mii_read;
-	pd->mii_bus->write = smsc9420_mii_write;
-	pd->mii_bus->irq = pd->phy_irq;
-	for (i = 0; i < PHY_MAX_ADDR; ++i)
-		pd->mii_bus->irq[i] = PHY_POLL;
-
-	/* Mask all PHYs except ID 1 (internal) */
-	pd->mii_bus->phy_mask = ~(1 << 1);
-
-	if (mdiobus_register(pd->mii_bus)) {
-		smsc_warn(PROBE, "Error registering mii bus");
-		goto err_out_free_bus_2;
-	}
-
-	if (smsc9420_mii_probe(dev) < 0) {
-		smsc_warn(PROBE, "Error probing mii bus");
-		goto err_out_unregister_bus_3;
-	}
-
-	return 0;
-
-err_out_unregister_bus_3:
-	mdiobus_unregister(pd->mii_bus);
-err_out_free_bus_2:
-	mdiobus_free(pd->mii_bus);
-err_out_1:
-	return err;
-}
-
-static int smsc9420_alloc_tx_ring(struct smsc9420_pdata *pd)
-{
-	int i;
-
-	BUG_ON(!pd->tx_ring);
-
-	pd->tx_buffers = kmalloc((sizeof(struct smsc9420_ring_info) *
-		TX_RING_SIZE), GFP_KERNEL);
-	if (!pd->tx_buffers) {
-		smsc_warn(IFUP, "Failed to allocated tx_buffers");
-		return -ENOMEM;
-	}
-
-	/* Initialize the TX Ring */
-	for (i = 0; i < TX_RING_SIZE; i++) {
-		pd->tx_buffers[i].skb = NULL;
-		pd->tx_buffers[i].mapping = 0;
-		pd->tx_ring[i].status = 0;
-		pd->tx_ring[i].length = 0;
-		pd->tx_ring[i].buffer1 = 0;
-		pd->tx_ring[i].buffer2 = 0;
-	}
-	pd->tx_ring[TX_RING_SIZE - 1].length = TDES1_TER_;
-	wmb();
-
-	pd->tx_ring_head = 0;
-	pd->tx_ring_tail = 0;
-
-	smsc9420_reg_write(pd, TX_BASE_ADDR, pd->tx_dma_addr);
-	smsc9420_pci_flush_write(pd);
-
-	return 0;
-}
-
-static int smsc9420_alloc_rx_ring(struct smsc9420_pdata *pd)
-{
-	int i;
-
-	BUG_ON(!pd->rx_ring);
-
-	pd->rx_buffers = kmalloc((sizeof(struct smsc9420_ring_info) *
-		RX_RING_SIZE), GFP_KERNEL);
-	if (pd->rx_buffers == NULL) {
-		smsc_warn(IFUP, "Failed to allocated rx_buffers");
-		goto out;
-	}
-
-	/* initialize the rx ring */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		pd->rx_ring[i].status = 0;
-		pd->rx_ring[i].length = PKT_BUF_SZ;
-		pd->rx_ring[i].buffer2 = 0;
-		pd->rx_buffers[i].skb = NULL;
-		pd->rx_buffers[i].mapping = 0;
-	}
-	pd->rx_ring[RX_RING_SIZE - 1].length = (PKT_BUF_SZ | RDES1_RER_);
-
-	/* now allocate the entire ring of skbs */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		if (smsc9420_alloc_rx_buffer(pd, i)) {
-			smsc_warn(IFUP, "failed to allocate rx skb %d", i);
-			goto out_free_rx_skbs;
-		}
-	}
-
-	pd->rx_ring_head = 0;
-	pd->rx_ring_tail = 0;
-
-	smsc9420_reg_write(pd, VLAN1, ETH_P_8021Q);
-	smsc_dbg(IFUP, "VLAN1 = 0x%08x", smsc9420_reg_read(pd, VLAN1));
-
-	if (pd->rx_csum) {
-		/* Enable RX COE */
-		u32 coe = smsc9420_reg_read(pd, COE_CR) | RX_COE_EN;
-		smsc9420_reg_write(pd, COE_CR, coe);
-		smsc_dbg(IFUP, "COE_CR = 0x%08x", coe);
-	}
-
-	smsc9420_reg_write(pd, RX_BASE_ADDR, pd->rx_dma_addr);
-	smsc9420_pci_flush_write(pd);
-
-	return 0;
-
-out_free_rx_skbs:
-	smsc9420_free_rx_ring(pd);
-out:
-	return -ENOMEM;
-}
-
-static int smsc9420_open(struct net_device *dev)
-{
-	struct smsc9420_pdata *pd;
-	u32 bus_mode, mac_cr, dmac_control, int_cfg, dma_intr_ena, int_ctl;
-	unsigned long flags;
-	int result = 0, timeout;
-
-	BUG_ON(!dev);
-	pd = netdev_priv(dev);
-	BUG_ON(!pd);
-
-	if (!is_valid_ether_addr(dev->dev_addr)) {
-		smsc_warn(IFUP, "dev_addr is not a valid MAC address");
-		result = -EADDRNOTAVAIL;
-		goto out_0;
-	}
-
-	netif_carrier_off(dev);
-
-	/* disable, mask and acknowledge all interrupts */
-	spin_lock_irqsave(&pd->int_lock, flags);
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-	smsc9420_reg_write(pd, INT_CTL, 0);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-	smsc9420_reg_write(pd, DMAC_INTR_ENA, 0);
-	smsc9420_reg_write(pd, INT_STAT, 0xFFFFFFFF);
-	smsc9420_pci_flush_write(pd);
-
-	if (request_irq(dev->irq, smsc9420_isr, IRQF_SHARED | IRQF_DISABLED,
-			DRV_NAME, pd)) {
-		smsc_warn(IFUP, "Unable to use IRQ = %d", dev->irq);
-		result = -ENODEV;
-		goto out_0;
-	}
-
-	smsc9420_dmac_soft_reset(pd);
-
-	/* make sure MAC_CR is sane */
-	smsc9420_reg_write(pd, MAC_CR, 0);
-
-	smsc9420_set_mac_address(dev);
-
-	/* Configure GPIO pins to drive LEDs */
-	smsc9420_reg_write(pd, GPIO_CFG,
-		(GPIO_CFG_LED_3_ | GPIO_CFG_LED_2_ | GPIO_CFG_LED_1_));
-
-	bus_mode = BUS_MODE_DMA_BURST_LENGTH_16;
-
-#ifdef __BIG_ENDIAN
-	bus_mode |= BUS_MODE_DBO_;
-#endif
-
-	smsc9420_reg_write(pd, BUS_MODE, bus_mode);
-
-	smsc9420_pci_flush_write(pd);
-
-	/* set bus master bridge arbitration priority for Rx and TX DMA */
-	smsc9420_reg_write(pd, BUS_CFG, BUS_CFG_RXTXWEIGHT_4_1);
-
-	smsc9420_reg_write(pd, DMAC_CONTROL,
-		(DMAC_CONTROL_SF_ | DMAC_CONTROL_OSF_));
-
-	smsc9420_pci_flush_write(pd);
-
-	/* test the IRQ connection to the ISR */
-	smsc_dbg(IFUP, "Testing ISR using IRQ %d", dev->irq);
-	pd->software_irq_signal = false;
-
-	spin_lock_irqsave(&pd->int_lock, flags);
-	/* configure interrupt deassertion timer and enable interrupts */
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;
-	int_cfg &= ~(INT_CFG_INT_DEAS_MASK);
-	int_cfg |= (INT_DEAS_TIME & INT_CFG_INT_DEAS_MASK);
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-
-	/* unmask software interrupt */
-	int_ctl = smsc9420_reg_read(pd, INT_CTL) | INT_CTL_SW_INT_EN_;
-	smsc9420_reg_write(pd, INT_CTL, int_ctl);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-	smsc9420_pci_flush_write(pd);
-
-	timeout = 1000;
-	while (timeout--) {
-		if (pd->software_irq_signal)
-			break;
-		msleep(1);
-	}
-
-	/* disable interrupts */
-	spin_lock_irqsave(&pd->int_lock, flags);
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-
-	if (!pd->software_irq_signal) {
-		smsc_warn(IFUP, "ISR failed signaling test");
-		result = -ENODEV;
-		goto out_free_irq_1;
-	}
-
-	smsc_dbg(IFUP, "ISR passed test using IRQ %d", dev->irq);
-
-	result = smsc9420_alloc_tx_ring(pd);
-	if (result) {
-		smsc_warn(IFUP, "Failed to Initialize tx dma ring");
-		result = -ENOMEM;
-		goto out_free_irq_1;
-	}
-
-	result = smsc9420_alloc_rx_ring(pd);
-	if (result) {
-		smsc_warn(IFUP, "Failed to Initialize rx dma ring");
-		result = -ENOMEM;
-		goto out_free_tx_ring_2;
-	}
-
-	result = smsc9420_mii_init(dev);
-	if (result) {
-		smsc_warn(IFUP, "Failed to initialize Phy");
-		result = -ENODEV;
-		goto out_free_rx_ring_3;
-	}
-
-	/* Bring the PHY up */
-	phy_start(pd->phy_dev);
-
-	napi_enable(&pd->napi);
-
-	/* start tx and rx */
-	mac_cr = smsc9420_reg_read(pd, MAC_CR) | MAC_CR_TXEN_ | MAC_CR_RXEN_;
-	smsc9420_reg_write(pd, MAC_CR, mac_cr);
-
-	dmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);
-	dmac_control |= DMAC_CONTROL_ST_ | DMAC_CONTROL_SR_;
-	smsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);
-	smsc9420_pci_flush_write(pd);
-
-	dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);
-	dma_intr_ena |=
-		(DMAC_INTR_ENA_TX_ | DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);
-	smsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);
-	smsc9420_pci_flush_write(pd);
-
-	netif_wake_queue(dev);
-
-	smsc9420_reg_write(pd, RX_POLL_DEMAND, 1);
-
-	/* enable interrupts */
-	spin_lock_irqsave(&pd->int_lock, flags);
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-
-	return 0;
-
-out_free_rx_ring_3:
-	smsc9420_free_rx_ring(pd);
-out_free_tx_ring_2:
-	smsc9420_free_tx_ring(pd);
-out_free_irq_1:
-	free_irq(dev->irq, pd);
-out_0:
-	return result;
-}
-
-#ifdef CONFIG_PM
-
-static int smsc9420_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u32 int_cfg;
-	ulong flags;
-
-	/* disable interrupts */
-	spin_lock_irqsave(&pd->int_lock, flags);
-	int_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);
-	smsc9420_reg_write(pd, INT_CFG, int_cfg);
-	spin_unlock_irqrestore(&pd->int_lock, flags);
-
-	if (netif_running(dev)) {
-		netif_tx_disable(dev);
-		smsc9420_stop_tx(pd);
-		smsc9420_free_tx_ring(pd);
-
-		napi_disable(&pd->napi);
-		smsc9420_stop_rx(pd);
-		smsc9420_free_rx_ring(pd);
-
-		free_irq(dev->irq, pd);
-
-		netif_device_detach(dev);
-	}
-
-	pci_save_state(pdev);
-	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
-	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-
-	return 0;
-}
-
-static int smsc9420_resume(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct smsc9420_pdata *pd = netdev_priv(dev);
-	int err;
-
-	pci_set_power_state(pdev, PCI_D0);
-	pci_restore_state(pdev);
-
-	err = pci_enable_device(pdev);
-	if (err)
-		return err;
-
-	pci_set_master(pdev);
-
-	err = pci_enable_wake(pdev, 0, 0);
-	if (err)
-		smsc_warn(IFUP, "pci_enable_wake failed: %d", err);
-
-	if (netif_running(dev)) {
-		err = smsc9420_open(dev);
-		netif_device_attach(dev);
-	}
-	return err;
-}
-
-#endif /* CONFIG_PM */
-
-static const struct net_device_ops smsc9420_netdev_ops = {
-	.ndo_open		= smsc9420_open,
-	.ndo_stop		= smsc9420_stop,
-	.ndo_start_xmit		= smsc9420_hard_start_xmit,
-	.ndo_get_stats		= smsc9420_get_stats,
-	.ndo_set_rx_mode	= smsc9420_set_multicast_list,
-	.ndo_do_ioctl		= smsc9420_do_ioctl,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_set_mac_address 	= eth_mac_addr,
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller	= smsc9420_poll_controller,
-#endif /* CONFIG_NET_POLL_CONTROLLER */
-};
-
-static int __devinit
-smsc9420_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	struct net_device *dev;
-	struct smsc9420_pdata *pd;
-	void __iomem *virt_addr;
-	int result = 0;
-	u32 id_rev;
-
-	printk(KERN_INFO DRV_DESCRIPTION " version " DRV_VERSION "\n");
-
-	/* First do the PCI initialisation */
-	result = pci_enable_device(pdev);
-	if (unlikely(result)) {
-		printk(KERN_ERR "Cannot enable smsc9420\n");
-		goto out_0;
-	}
-
-	pci_set_master(pdev);
-
-	dev = alloc_etherdev(sizeof(*pd));
-	if (!dev)
-		goto out_disable_pci_device_1;
-
-	SET_NETDEV_DEV(dev, &pdev->dev);
-
-	if (!(pci_resource_flags(pdev, SMSC_BAR) & IORESOURCE_MEM)) {
-		printk(KERN_ERR "Cannot find PCI device base address\n");
-		goto out_free_netdev_2;
-	}
-
-	if ((pci_request_regions(pdev, DRV_NAME))) {
-		printk(KERN_ERR "Cannot obtain PCI resources, aborting.\n");
-		goto out_free_netdev_2;
-	}
-
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
-		printk(KERN_ERR "No usable DMA configuration, aborting.\n");
-		goto out_free_regions_3;
-	}
-
-	virt_addr = ioremap(pci_resource_start(pdev, SMSC_BAR),
-		pci_resource_len(pdev, SMSC_BAR));
-	if (!virt_addr) {
-		printk(KERN_ERR "Cannot map device registers, aborting.\n");
-		goto out_free_regions_3;
-	}
-
-	/* registers are double mapped with 0 offset for LE and 0x200 for BE */
-	virt_addr += LAN9420_CPSR_ENDIAN_OFFSET;
-
-	dev->base_addr = (ulong)virt_addr;
-
-	pd = netdev_priv(dev);
-
-	/* pci descriptors are created in the PCI consistent area */
-	pd->rx_ring = pci_alloc_consistent(pdev,
-		sizeof(struct smsc9420_dma_desc) * RX_RING_SIZE +
-		sizeof(struct smsc9420_dma_desc) * TX_RING_SIZE,
-		&pd->rx_dma_addr);
-
-	if (!pd->rx_ring)
-		goto out_free_io_4;
-
-	/* descriptors are aligned due to the nature of pci_alloc_consistent */
-	pd->tx_ring = (struct smsc9420_dma_desc *)
-	    (pd->rx_ring + RX_RING_SIZE);
-	pd->tx_dma_addr = pd->rx_dma_addr +
-	    sizeof(struct smsc9420_dma_desc) * RX_RING_SIZE;
-
-	pd->pdev = pdev;
-	pd->dev = dev;
-	pd->base_addr = virt_addr;
-	pd->msg_enable = smsc_debug;
-	pd->rx_csum = true;
-
-	smsc_dbg(PROBE, "lan_base=0x%08lx", (ulong)virt_addr);
-
-	id_rev = smsc9420_reg_read(pd, ID_REV);
-	switch (id_rev & 0xFFFF0000) {
-	case 0x94200000:
-		smsc_info(PROBE, "LAN9420 identified, ID_REV=0x%08X", id_rev);
-		break;
-	default:
-		smsc_warn(PROBE, "LAN9420 NOT identified");
-		smsc_warn(PROBE, "ID_REV=0x%08X", id_rev);
-		goto out_free_dmadesc_5;
-	}
-
-	smsc9420_dmac_soft_reset(pd);
-	smsc9420_eeprom_reload(pd);
-	smsc9420_check_mac_address(dev);
-
-	dev->netdev_ops = &smsc9420_netdev_ops;
-	dev->ethtool_ops = &smsc9420_ethtool_ops;
-	dev->irq = pdev->irq;
-
-	netif_napi_add(dev, &pd->napi, smsc9420_rx_poll, NAPI_WEIGHT);
-
-	result = register_netdev(dev);
-	if (result) {
-		smsc_warn(PROBE, "error %i registering device", result);
-		goto out_free_dmadesc_5;
-	}
-
-	pci_set_drvdata(pdev, dev);
-
-	spin_lock_init(&pd->int_lock);
-	spin_lock_init(&pd->phy_lock);
-
-	dev_info(&dev->dev, "MAC Address: %pM\n", dev->dev_addr);
-
-	return 0;
-
-out_free_dmadesc_5:
-	pci_free_consistent(pdev, sizeof(struct smsc9420_dma_desc) *
-		(RX_RING_SIZE + TX_RING_SIZE), pd->rx_ring, pd->rx_dma_addr);
-out_free_io_4:
-	iounmap(virt_addr - LAN9420_CPSR_ENDIAN_OFFSET);
-out_free_regions_3:
-	pci_release_regions(pdev);
-out_free_netdev_2:
-	free_netdev(dev);
-out_disable_pci_device_1:
-	pci_disable_device(pdev);
-out_0:
-	return -ENODEV;
-}
-
-static void __devexit smsc9420_remove(struct pci_dev *pdev)
-{
-	struct net_device *dev;
-	struct smsc9420_pdata *pd;
-
-	dev = pci_get_drvdata(pdev);
-	if (!dev)
-		return;
-
-	pci_set_drvdata(pdev, NULL);
-
-	pd = netdev_priv(dev);
-	unregister_netdev(dev);
-
-	/* tx_buffers and rx_buffers are freed in stop */
-	BUG_ON(pd->tx_buffers);
-	BUG_ON(pd->rx_buffers);
-
-	BUG_ON(!pd->tx_ring);
-	BUG_ON(!pd->rx_ring);
-
-	pci_free_consistent(pdev, sizeof(struct smsc9420_dma_desc) *
-		(RX_RING_SIZE + TX_RING_SIZE), pd->rx_ring, pd->rx_dma_addr);
-
-	iounmap(pd->base_addr - LAN9420_CPSR_ENDIAN_OFFSET);
-	pci_release_regions(pdev);
-	free_netdev(dev);
-	pci_disable_device(pdev);
-}
-
-static struct pci_driver smsc9420_driver = {
-	.name = DRV_NAME,
-	.id_table = smsc9420_id_table,
-	.probe = smsc9420_probe,
-	.remove = __devexit_p(smsc9420_remove),
-#ifdef CONFIG_PM
-	.suspend = smsc9420_suspend,
-	.resume = smsc9420_resume,
-#endif /* CONFIG_PM */
-};
-
-static int __init smsc9420_init_module(void)
-{
-	smsc_debug = netif_msg_init(debug, SMSC_MSG_DEFAULT);
-
-	return pci_register_driver(&smsc9420_driver);
-}
-
-static void __exit smsc9420_exit_module(void)
-{
-	pci_unregister_driver(&smsc9420_driver);
-}
-
-module_init(smsc9420_init_module);
-module_exit(smsc9420_exit_module);
diff -urN flo-ElementalX-5.00/drivers/net/fddi/skfp/pmf.c flo-ElementalX-5.00-patched/drivers/net/fddi/skfp/pmf.c
--- flo-ElementalX-5.00/drivers/net/fddi/skfp/pmf.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/net/fddi/skfp/pmf.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,1663 +0,0 @@
-/******************************************************************************
- *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *
- *	See the file "skfddi.c" for further information.
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	The information in this file is provided "AS IS" without warranty.
- *
- ******************************************************************************/
-
-/*
-	Parameter Management Frame processing for SMT 7.2
-*/
-
-#include "h/types.h"
-#include "h/fddi.h"
-#include "h/smc.h"
-#include "h/smt_p.h"
-
-#define KERNEL
-#include "h/smtstate.h"
-
-#ifndef	SLIM_SMT
-
-#ifndef	lint
-static const char ID_sccs[] = "@(#)pmf.c	1.37 97/08/04 (C) SK " ;
-#endif
-
-static int smt_authorize(struct s_smc *smc, struct smt_header *sm);
-static int smt_check_set_count(struct s_smc *smc, struct smt_header *sm);
-static const struct s_p_tab* smt_get_ptab(u_short para);
-static int smt_mib_phys(struct s_smc *smc);
-static int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index,
-			int local, int set);
-void smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,
-		  int index, int local);
-static SMbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req,
-				     int set, int local);
-static int port_to_mib(struct s_smc *smc, int p);
-
-#define MOFFSS(e)	offsetof(struct fddi_mib, e)
-#define MOFFMS(e)	offsetof(struct fddi_mib_m, e)
-#define MOFFAS(e)	offsetof(struct fddi_mib_a, e)
-#define MOFFPS(e)	offsetof(struct fddi_mib_p, e)
-
-
-#define AC_G	0x01		/* Get */
-#define AC_GR	0x02		/* Get/Set */
-#define AC_S	0x04		/* Set */
-#define AC_NA	0x08
-#define AC_GROUP	0x10		/* Group */
-#define MS2BCLK(x)	((x)*12500L)
-/*
-	F	LFag (byte)
-	B	byte
-	S	u_short	16 bit
-	C	Counter 32 bit
-	L	Long 32 bit
-	T	Timer_2	32 bit
-	P	TimeStamp ;
-	A	LongAddress (6 byte)
-	E	Enum 16 bit
-	R	ResId 16 Bit
-*/
-static const struct s_p_tab {
-	u_short	p_num ;		/* parameter code */
-	u_char	p_access ;	/* access rights */
-	u_short	p_offset ;	/* offset in mib */
-	char	p_swap[3] ;	/* format string */
-} p_tab[] = {
-	/* StationIdGrp */
-	{ SMT_P100A,AC_GROUP	} ,
-	{ SMT_P100B,AC_G,	MOFFSS(fddiSMTStationId),	"8"	} ,
-	{ SMT_P100D,AC_G,	MOFFSS(fddiSMTOpVersionId),	"S"	} ,
-	{ SMT_P100E,AC_G,	MOFFSS(fddiSMTHiVersionId),	"S"	} ,
-	{ SMT_P100F,AC_G,	MOFFSS(fddiSMTLoVersionId),	"S"	} ,
-	{ SMT_P1010,AC_G,	MOFFSS(fddiSMTManufacturerData), "D" } ,
-	{ SMT_P1011,AC_GR,	MOFFSS(fddiSMTUserData),	"D"	} ,
-	{ SMT_P1012,AC_G,	MOFFSS(fddiSMTMIBVersionId),	"S"	} ,
-
-	/* StationConfigGrp */
-	{ SMT_P1014,AC_GROUP	} ,
-	{ SMT_P1015,AC_G,	MOFFSS(fddiSMTMac_Ct),		"B"	} ,
-	{ SMT_P1016,AC_G,	MOFFSS(fddiSMTNonMaster_Ct),	"B"	} ,
-	{ SMT_P1017,AC_G,	MOFFSS(fddiSMTMaster_Ct),	"B"	} ,
-	{ SMT_P1018,AC_G,	MOFFSS(fddiSMTAvailablePaths),	"B"	} ,
-	{ SMT_P1019,AC_G,	MOFFSS(fddiSMTConfigCapabilities),"S"	} ,
-	{ SMT_P101A,AC_GR,	MOFFSS(fddiSMTConfigPolicy),	"wS"	} ,
-	{ SMT_P101B,AC_GR,	MOFFSS(fddiSMTConnectionPolicy),"wS"	} ,
-	{ SMT_P101D,AC_GR,	MOFFSS(fddiSMTTT_Notify),	"wS"	} ,
-	{ SMT_P101E,AC_GR,	MOFFSS(fddiSMTStatRptPolicy),	"bB"	} ,
-	{ SMT_P101F,AC_GR,	MOFFSS(fddiSMTTrace_MaxExpiration),"lL"	} ,
-	{ SMT_P1020,AC_G,	MOFFSS(fddiSMTPORTIndexes),	"II"	} ,
-	{ SMT_P1021,AC_G,	MOFFSS(fddiSMTMACIndexes),	"I"	} ,
-	{ SMT_P1022,AC_G,	MOFFSS(fddiSMTBypassPresent),	"F"	} ,
-
-	/* StatusGrp */
-	{ SMT_P1028,AC_GROUP	} ,
-	{ SMT_P1029,AC_G,	MOFFSS(fddiSMTECMState),	"E"	} ,
-	{ SMT_P102A,AC_G,	MOFFSS(fddiSMTCF_State),	"E"	} ,
-	{ SMT_P102C,AC_G,	MOFFSS(fddiSMTRemoteDisconnectFlag),"F"	} ,
-	{ SMT_P102D,AC_G,	MOFFSS(fddiSMTStationStatus),	"E"	} ,
-	{ SMT_P102E,AC_G,	MOFFSS(fddiSMTPeerWrapFlag),	"F"	} ,
-
-	/* MIBOperationGrp */
-	{ SMT_P1032,AC_GROUP	} ,
-	{ SMT_P1033,AC_G,	MOFFSS(fddiSMTTimeStamp),"P"		} ,
-	{ SMT_P1034,AC_G,	MOFFSS(fddiSMTTransitionTimeStamp),"P"	} ,
-	/* NOTE : SMT_P1035 is already swapped ! SMT_P_SETCOUNT */
-	{ SMT_P1035,AC_G,	MOFFSS(fddiSMTSetCount),"4P"		} ,
-	{ SMT_P1036,AC_G,	MOFFSS(fddiSMTLastSetStationId),"8"	} ,
-
-	{ SMT_P103C,AC_S,	0,				"wS"	} ,
-
-	/*
-	 * PRIVATE EXTENSIONS
-	 * only accessible locally to get/set passwd
-	 */
-	{ SMT_P10F0,AC_GR,	MOFFSS(fddiPRPMFPasswd),	"8"	} ,
-	{ SMT_P10F1,AC_GR,	MOFFSS(fddiPRPMFStation),	"8"	} ,
-#ifdef	ESS
-	{ SMT_P10F2,AC_GR,	MOFFSS(fddiESSPayload),		"lL"	} ,
-	{ SMT_P10F3,AC_GR,	MOFFSS(fddiESSOverhead),	"lL"	} ,
-	{ SMT_P10F4,AC_GR,	MOFFSS(fddiESSMaxTNeg),		"lL"	} ,
-	{ SMT_P10F5,AC_GR,	MOFFSS(fddiESSMinSegmentSize),	"lL"	} ,
-	{ SMT_P10F6,AC_GR,	MOFFSS(fddiESSCategory),	"lL"	} ,
-	{ SMT_P10F7,AC_GR,	MOFFSS(fddiESSSynchTxMode),	"wS"	} ,
-#endif
-#ifdef	SBA
-	{ SMT_P10F8,AC_GR,	MOFFSS(fddiSBACommand),		"bF"	} ,
-	{ SMT_P10F9,AC_GR,	MOFFSS(fddiSBAAvailable),	"bF"	} ,
-#endif
-	/* MAC Attributes */
-	{ SMT_P200A,AC_GROUP	} ,
-	{ SMT_P200B,AC_G,	MOFFMS(fddiMACFrameStatusFunctions),"S"	} ,
-	{ SMT_P200D,AC_G,	MOFFMS(fddiMACT_MaxCapabilitiy),"T"	} ,
-	{ SMT_P200E,AC_G,	MOFFMS(fddiMACTVXCapabilitiy),"T"	} ,
-
-	/* ConfigGrp */
-	{ SMT_P2014,AC_GROUP	} ,
-	{ SMT_P2016,AC_G,	MOFFMS(fddiMACAvailablePaths),	"B"	} ,
-	{ SMT_P2017,AC_G,	MOFFMS(fddiMACCurrentPath),	"S"	} ,
-	{ SMT_P2018,AC_G,	MOFFMS(fddiMACUpstreamNbr),	"A"	} ,
-	{ SMT_P2019,AC_G,	MOFFMS(fddiMACDownstreamNbr),	"A"	} ,
-	{ SMT_P201A,AC_G,	MOFFMS(fddiMACOldUpstreamNbr),	"A"	} ,
-	{ SMT_P201B,AC_G,	MOFFMS(fddiMACOldDownstreamNbr),"A"	} ,
-	{ SMT_P201D,AC_G,	MOFFMS(fddiMACDupAddressTest),	"E"	} ,
-	{ SMT_P2020,AC_GR,	MOFFMS(fddiMACRequestedPaths),	"wS"	} ,
-	{ SMT_P2021,AC_G,	MOFFMS(fddiMACDownstreamPORTType),"E"	} ,
-	{ SMT_P2022,AC_G,	MOFFMS(fddiMACIndex),		"S"	} ,
-
-	/* AddressGrp */
-	{ SMT_P2028,AC_GROUP	} ,
-	{ SMT_P2029,AC_G,	MOFFMS(fddiMACSMTAddress),	"A"	} ,
-
-	/* OperationGrp */
-	{ SMT_P2032,AC_GROUP	} ,
-	{ SMT_P2033,AC_G,	MOFFMS(fddiMACT_Req),		"T"	} ,
-	{ SMT_P2034,AC_G,	MOFFMS(fddiMACT_Neg),		"T"	} ,
-	{ SMT_P2035,AC_G,	MOFFMS(fddiMACT_Max),		"T"	} ,
-	{ SMT_P2036,AC_G,	MOFFMS(fddiMACTvxValue),	"T"	} ,
-	{ SMT_P2038,AC_G,	MOFFMS(fddiMACT_Pri0),		"T"	} ,
-	{ SMT_P2039,AC_G,	MOFFMS(fddiMACT_Pri1),		"T"	} ,
-	{ SMT_P203A,AC_G,	MOFFMS(fddiMACT_Pri2),		"T"	} ,
-	{ SMT_P203B,AC_G,	MOFFMS(fddiMACT_Pri3),		"T"	} ,
-	{ SMT_P203C,AC_G,	MOFFMS(fddiMACT_Pri4),		"T"	} ,
-	{ SMT_P203D,AC_G,	MOFFMS(fddiMACT_Pri5),		"T"	} ,
-	{ SMT_P203E,AC_G,	MOFFMS(fddiMACT_Pri6),		"T"	} ,
-
-
-	/* CountersGrp */
-	{ SMT_P2046,AC_GROUP	} ,
-	{ SMT_P2047,AC_G,	MOFFMS(fddiMACFrame_Ct),	"C"	} ,
-	{ SMT_P2048,AC_G,	MOFFMS(fddiMACCopied_Ct),	"C"	} ,
-	{ SMT_P2049,AC_G,	MOFFMS(fddiMACTransmit_Ct),	"C"	} ,
-	{ SMT_P204A,AC_G,	MOFFMS(fddiMACToken_Ct),	"C"	} ,
-	{ SMT_P2051,AC_G,	MOFFMS(fddiMACError_Ct),	"C"	} ,
-	{ SMT_P2052,AC_G,	MOFFMS(fddiMACLost_Ct),		"C"	} ,
-	{ SMT_P2053,AC_G,	MOFFMS(fddiMACTvxExpired_Ct),	"C"	} ,
-	{ SMT_P2054,AC_G,	MOFFMS(fddiMACNotCopied_Ct),	"C"	} ,
-	{ SMT_P2056,AC_G,	MOFFMS(fddiMACRingOp_Ct),	"C"	} ,
-
-	/* FrameErrorConditionGrp */
-	{ SMT_P205A,AC_GROUP	} ,
-	{ SMT_P205F,AC_GR,	MOFFMS(fddiMACFrameErrorThreshold),"wS"	} ,
-	{ SMT_P2060,AC_G,	MOFFMS(fddiMACFrameErrorRatio),	"S"	} ,
-
-	/* NotCopiedConditionGrp */
-	{ SMT_P2064,AC_GROUP	} ,
-	{ SMT_P2067,AC_GR,	MOFFMS(fddiMACNotCopiedThreshold),"wS"	} ,
-	{ SMT_P2069,AC_G,	MOFFMS(fddiMACNotCopiedRatio),	"S"	} ,
-
-	/* StatusGrp */
-	{ SMT_P206E,AC_GROUP	} ,
-	{ SMT_P206F,AC_G,	MOFFMS(fddiMACRMTState),	"S"	} ,
-	{ SMT_P2070,AC_G,	MOFFMS(fddiMACDA_Flag),	"F"	} ,
-	{ SMT_P2071,AC_G,	MOFFMS(fddiMACUNDA_Flag),	"F"	} ,
-	{ SMT_P2072,AC_G,	MOFFMS(fddiMACFrameErrorFlag),	"F"	} ,
-	{ SMT_P2073,AC_G,	MOFFMS(fddiMACNotCopiedFlag),	"F"	} ,
-	{ SMT_P2074,AC_G,	MOFFMS(fddiMACMA_UnitdataAvailable),"F"	} ,
-	{ SMT_P2075,AC_G,	MOFFMS(fddiMACHardwarePresent),	"F"	} ,
-	{ SMT_P2076,AC_GR,	MOFFMS(fddiMACMA_UnitdataEnable),"bF"	} ,
-
-	/*
-	 * PRIVATE EXTENSIONS
-	 * only accessible locally to get/set TMIN
-	 */
-	{ SMT_P20F0,AC_NA						} ,
-	{ SMT_P20F1,AC_GR,	MOFFMS(fddiMACT_Min),		"lT"	} ,
-
-	/* Path Attributes */
-	/*
-	 * DON't swap 320B,320F,3210: they are already swapped in swap_para()
-	 */
-	{ SMT_P320A,AC_GROUP	} ,
-	{ SMT_P320B,AC_G,	MOFFAS(fddiPATHIndex),		"r"	} ,
-	{ SMT_P320F,AC_GR,	MOFFAS(fddiPATHSbaPayload),	"l4"	} ,
-	{ SMT_P3210,AC_GR,	MOFFAS(fddiPATHSbaOverhead),	"l4"	} ,
-	/* fddiPATHConfiguration */
-	{ SMT_P3212,AC_G,	0,				""	} ,
-	{ SMT_P3213,AC_GR,	MOFFAS(fddiPATHT_Rmode),	"lT"	} ,
-	{ SMT_P3214,AC_GR,	MOFFAS(fddiPATHSbaAvailable),	"lL"	} ,
-	{ SMT_P3215,AC_GR,	MOFFAS(fddiPATHTVXLowerBound),	"lT"	} ,
-	{ SMT_P3216,AC_GR,	MOFFAS(fddiPATHT_MaxLowerBound),"lT"	} ,
-	{ SMT_P3217,AC_GR,	MOFFAS(fddiPATHMaxT_Req),	"lT"	} ,
-
-	/* Port Attributes */
-	/* ConfigGrp */
-	{ SMT_P400A,AC_GROUP	} ,
-	{ SMT_P400C,AC_G,	MOFFPS(fddiPORTMy_Type),	"E"	} ,
-	{ SMT_P400D,AC_G,	MOFFPS(fddiPORTNeighborType),	"E"	} ,
-	{ SMT_P400E,AC_GR,	MOFFPS(fddiPORTConnectionPolicies),"bB"	} ,
-	{ SMT_P400F,AC_G,	MOFFPS(fddiPORTMacIndicated),	"2"	} ,
-	{ SMT_P4010,AC_G,	MOFFPS(fddiPORTCurrentPath),	"E"	} ,
-	{ SMT_P4011,AC_GR,	MOFFPS(fddiPORTRequestedPaths),	"l4"	} ,
-	{ SMT_P4012,AC_G,	MOFFPS(fddiPORTMACPlacement),	"S"	} ,
-	{ SMT_P4013,AC_G,	MOFFPS(fddiPORTAvailablePaths),	"B"	} ,
-	{ SMT_P4016,AC_G,	MOFFPS(fddiPORTPMDClass),	"E"	} ,
-	{ SMT_P4017,AC_G,	MOFFPS(fddiPORTConnectionCapabilities),	"B"} ,
-	{ SMT_P401D,AC_G,	MOFFPS(fddiPORTIndex),		"R"	} ,
-
-	/* OperationGrp */
-	{ SMT_P401E,AC_GROUP	} ,
-	{ SMT_P401F,AC_GR,	MOFFPS(fddiPORTMaint_LS),	"wE"	} ,
-	{ SMT_P4021,AC_G,	MOFFPS(fddiPORTBS_Flag),	"F"	} ,
-	{ SMT_P4022,AC_G,	MOFFPS(fddiPORTPC_LS),		"E"	} ,
-
-	/* ErrorCtrsGrp */
-	{ SMT_P4028,AC_GROUP	} ,
-	{ SMT_P4029,AC_G,	MOFFPS(fddiPORTEBError_Ct),	"C"	} ,
-	{ SMT_P402A,AC_G,	MOFFPS(fddiPORTLCTFail_Ct),	"C"	} ,
-
-	/* LerGrp */
-	{ SMT_P4032,AC_GROUP	} ,
-	{ SMT_P4033,AC_G,	MOFFPS(fddiPORTLer_Estimate),	"F"	} ,
-	{ SMT_P4034,AC_G,	MOFFPS(fddiPORTLem_Reject_Ct),	"C"	} ,
-	{ SMT_P4035,AC_G,	MOFFPS(fddiPORTLem_Ct),		"C"	} ,
-	{ SMT_P403A,AC_GR,	MOFFPS(fddiPORTLer_Cutoff),	"bB"	} ,
-	{ SMT_P403B,AC_GR,	MOFFPS(fddiPORTLer_Alarm),	"bB"	} ,
-
-	/* StatusGrp */
-	{ SMT_P403C,AC_GROUP	} ,
-	{ SMT_P403D,AC_G,	MOFFPS(fddiPORTConnectState),	"E"	} ,
-	{ SMT_P403E,AC_G,	MOFFPS(fddiPORTPCMStateX),	"E"	} ,
-	{ SMT_P403F,AC_G,	MOFFPS(fddiPORTPC_Withhold),	"E"	} ,
-	{ SMT_P4040,AC_G,	MOFFPS(fddiPORTLerFlag),	"F"	} ,
-	{ SMT_P4041,AC_G,	MOFFPS(fddiPORTHardwarePresent),"F"	} ,
-
-	{ SMT_P4046,AC_S,	0,				"wS"	} ,
-
-	{ 0,	AC_GROUP	} ,
-	{ 0 }
-} ;
-
-void smt_pmf_received_pack(struct s_smc *smc, SMbuf *mb, int local)
-{
-	struct smt_header	*sm ;
-	SMbuf		*reply ;
-
-	sm = smtod(mb,struct smt_header *) ;
-	DB_SMT("SMT: processing PMF frame at %x len %d\n",sm,mb->sm_len) ;
-#ifdef	DEBUG
-	dump_smt(smc,sm,"PMF Received") ;
-#endif
-	/*
-	 * Start the watchdog: It may be a long, long packet and
-	 * maybe the watchdog occurs ...
-	 */
-	smt_start_watchdog(smc) ;
-
-	if (sm->smt_class == SMT_PMF_GET ||
-	    sm->smt_class == SMT_PMF_SET) {
-		reply = smt_build_pmf_response(smc,sm,
-			sm->smt_class == SMT_PMF_SET,local) ;
-		if (reply) {
-			sm = smtod(reply,struct smt_header *) ;
-#ifdef	DEBUG
-			dump_smt(smc,sm,"PMF Reply") ;
-#endif
-			smt_send_frame(smc,reply,FC_SMT_INFO,local) ;
-		}
-	}
-}
-
-static SMbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req,
-				     int set, int local)
-{
-	SMbuf			*mb ;
-	struct smt_header	*smt ;
-	struct smt_para		*pa ;
-	struct smt_p_reason	*res ;
-	const struct s_p_tab	*pt ;
-	int			len ;
-	int			index ;
-	int			idx_end ;
-	int			error ;
-	int			range ;
-	SK_LOC_DECL(struct s_pcon,pcon) ;
-	SK_LOC_DECL(struct s_pcon,set_pcon) ;
-
-	/*
-	 * build SMT header
-	 */
-	if (!(mb = smt_get_mbuf(smc)))
-		return mb;
-
-	smt = smtod(mb, struct smt_header *) ;
-	smt->smt_dest = req->smt_source ;	/* DA == source of request */
-	smt->smt_class = req->smt_class ;	/* same class (GET/SET) */
-	smt->smt_type = SMT_REPLY ;
-	smt->smt_version = SMT_VID_2 ;
-	smt->smt_tid = req->smt_tid ;		/* same TID */
-	smt->smt_pad = 0 ;
-	smt->smt_len = 0 ;
-
-	/*
-	 * setup parameter status
-	 */
-	pcon.pc_len = SMT_MAX_INFO_LEN ;	/* max para length */
-	pcon.pc_err = 0 ;			/* no error */
-	pcon.pc_badset = 0 ;			/* no bad set count */
-	pcon.pc_p = (void *) (smt + 1) ;	/* paras start here */
-
-	/*
-	 * check authoriziation and set count
-	 */
-	error = 0 ;
-	if (set) {
-		if (!local && smt_authorize(smc,req))
-			error = SMT_RDF_AUTHOR ;
-		else if (smt_check_set_count(smc,req))
-			pcon.pc_badset = SMT_RDF_BADSET ;
-	}
-	/*
-	 * add reason code and all mandatory parameters
-	 */
-	res = (struct smt_p_reason *) pcon.pc_p ;
-	smt_add_para(smc,&pcon,(u_short) SMT_P_REASON,0,0) ;
-	smt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;
-	/* update 1035 and 1036 later if set */
-	set_pcon = pcon ;
-	smt_add_para(smc,&pcon,(u_short) SMT_P1035,0,0) ;
-	smt_add_para(smc,&pcon,(u_short) SMT_P1036,0,0) ;
-
-	pcon.pc_err = error ;
-	len = req->smt_len ;
-	pa = (struct smt_para *) (req + 1) ;
-	/*
-	 * process list of paras
-	 */
-	while (!pcon.pc_err && len > 0 ) {
-		if (((u_short)len < pa->p_len + PARA_LEN) || (pa->p_len & 3)) {
-			pcon.pc_err = SMT_RDF_LENGTH ;
-			break ;
-		}
-
-		if (((range = (pa->p_type & 0xf000)) == 0x2000) ||
-			range == 0x3000 || range == 0x4000) {
-			/*
-			 * get index for PART,MAC ad PATH group
-			 */
-			index = *((u_char *)pa + PARA_LEN + 3) ;/* index */
-			idx_end = index ;
-			if (!set && (pa->p_len != 4)) {
-				pcon.pc_err = SMT_RDF_LENGTH ;
-				break ;
-			}
-			if (!index && !set) {
-				switch (range) {
-				case 0x2000 :
-					index = INDEX_MAC ;
-					idx_end = index - 1 + NUMMACS ;
-					break ;
-				case 0x3000 :
-					index = INDEX_PATH ;
-					idx_end = index - 1 + NUMPATHS ;
-					break ;
-				case 0x4000 :
-					index = INDEX_PORT ;
-					idx_end = index - 1 + NUMPHYS ;
-#ifndef	CONCENTRATOR
-					if (smc->s.sas == SMT_SAS)
-						idx_end = INDEX_PORT ;
-#endif
-					break ;
-				}
-			}
-		}
-		else {
-			/*
-			 * smt group has no index
-			 */
-			if (!set && (pa->p_len != 0)) {
-				pcon.pc_err = SMT_RDF_LENGTH ;
-				break ;
-			}
-			index = 0 ;
-			idx_end = 0 ;
-		}
-		while (index <= idx_end) {
-			/*
-			 * if group
-			 *	add all paras of group
-			 */
-			pt = smt_get_ptab(pa->p_type) ;
-			if (pt && pt->p_access == AC_GROUP && !set) {
-				pt++ ;
-				while (pt->p_access == AC_G ||
-					pt->p_access == AC_GR) {
-					smt_add_para(smc,&pcon,pt->p_num,
-						index,local);
-					pt++ ;
-				}
-			}
-			/*
-			 * ignore
-			 *	AUTHORIZATION in get/set
-			 *	SET COUNT in set
-			 */
-			else if (pa->p_type != SMT_P_AUTHOR &&
-				 (!set || (pa->p_type != SMT_P1035))) {
-				int	st ;
-				if (pcon.pc_badset) {
-					smt_add_para(smc,&pcon,pa->p_type,
-						index,local) ;
-				}
-				else if (set) {
-					st = smt_set_para(smc,pa,index,local,1);
-					/*
-					 * return para even if error
-					 */
-					smt_add_para(smc,&pcon,pa->p_type,
-						index,local) ;
-					pcon.pc_err = st ;
-				}
-				else {
-					if (pt && pt->p_access == AC_S) {
-						pcon.pc_err =
-							SMT_RDF_ILLEGAL ;
-					}
-					smt_add_para(smc,&pcon,pa->p_type,
-						index,local) ;
-				}
-			}
-			if (pcon.pc_err)
-				break ;
-			index++ ;
-		}
-		len -= pa->p_len + PARA_LEN ;
-		pa = (struct smt_para *) ((char *)pa + pa->p_len + PARA_LEN) ;
-	}
-	smt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;
-	mb->sm_len = smt->smt_len + sizeof(struct smt_header) ;
-
-	/* update reason code */
-	res->rdf_reason = pcon.pc_badset ? pcon.pc_badset :
-			pcon.pc_err ? pcon.pc_err : SMT_RDF_SUCCESS ;
-	if (set && (res->rdf_reason == SMT_RDF_SUCCESS)) {
-		/*
-		 * increment set count
-		 * set time stamp
-		 * store station id of last set
-		 */
-		smc->mib.fddiSMTSetCount.count++ ;
-		smt_set_timestamp(smc,smc->mib.fddiSMTSetCount.timestamp) ;
-		smc->mib.fddiSMTLastSetStationId = req->smt_sid ;
-		smt_add_para(smc,&set_pcon,(u_short) SMT_P1035,0,0) ;
-		smt_add_para(smc,&set_pcon,(u_short) SMT_P1036,0,0) ;
-	}
-	return mb;
-}
-
-static int smt_authorize(struct s_smc *smc, struct smt_header *sm)
-{
-	struct smt_para	*pa ;
-	int		i ;
-	char		*p ;
-
-	/*
-	 * check source station id if not zero
-	 */
-	p = (char *) &smc->mib.fddiPRPMFStation ;
-	for (i = 0 ; i < 8 && !p[i] ; i++)
-		;
-	if (i != 8) {
-		if (memcmp((char *) &sm->smt_sid,
-			(char *) &smc->mib.fddiPRPMFStation,8))
-			return 1;
-	}
-	/*
-	 * check authoriziation parameter if passwd not zero
-	 */
-	p = (char *) smc->mib.fddiPRPMFPasswd ;
-	for (i = 0 ; i < 8 && !p[i] ; i++)
-		;
-	if (i != 8) {
-		pa = (struct smt_para *) sm_to_para(smc,sm,SMT_P_AUTHOR) ;
-		if (!pa)
-			return 1;
-		if (pa->p_len != 8)
-			return 1;
-		if (memcmp((char *)(pa+1),(char *)smc->mib.fddiPRPMFPasswd,8))
-			return 1;
-	}
-	return 0;
-}
-
-static int smt_check_set_count(struct s_smc *smc, struct smt_header *sm)
-{
-	struct smt_para	*pa ;
-	struct smt_p_setcount	*sc ;
-
-	pa = (struct smt_para *) sm_to_para(smc,sm,SMT_P1035) ;
-	if (pa) {
-		sc = (struct smt_p_setcount *) pa ;
-		if ((smc->mib.fddiSMTSetCount.count != sc->count) ||
-			memcmp((char *) smc->mib.fddiSMTSetCount.timestamp,
-			(char *)sc->timestamp,8))
-			return 1;
-	}
-	return 0;
-}
-
-void smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,
-		  int index, int local)
-{
-	struct smt_para	*pa ;
-	const struct s_p_tab	*pt ;
-	struct fddi_mib_m *mib_m = NULL;
-	struct fddi_mib_p *mib_p = NULL;
-	int		len ;
-	int		plen ;
-	char		*from ;
-	char		*to ;
-	const char	*swap ;
-	char		c ;
-	int		range ;
-	char		*mib_addr ;
-	int		mac ;
-	int		path ;
-	int		port ;
-	int		sp_len ;
-
-	/*
-	 * skip if error
-	 */
-	if (pcon->pc_err)
-		return ;
-
-	/*
-	 * actions don't have a value
-	 */
-	pt = smt_get_ptab(para) ;
-	if (pt && pt->p_access == AC_S)
-		return ;
-
-	to = (char *) (pcon->pc_p) ;	/* destination pointer */
-	len = pcon->pc_len ;		/* free space */
-	plen = len ;			/* remember start length */
-	pa = (struct smt_para *) to ;	/* type/length pointer */
-	to += PARA_LEN ;		/* skip smt_para */
-	len -= PARA_LEN ;
-	/*
-	 * set index if required
-	 */
-	if (((range = (para & 0xf000)) == 0x2000) ||
-		range == 0x3000 || range == 0x4000) {
-		if (len < 4)
-			goto wrong_error ;
-		to[0] = 0 ;
-		to[1] = 0 ;
-		to[2] = 0 ;
-		to[3] = index ;
-		len -= 4 ;
-		to += 4 ;
-	}
-	mac = index - INDEX_MAC ;
-	path = index - INDEX_PATH ;
-	port = index - INDEX_PORT ;
-	/*
-	 * get pointer to mib
-	 */
-	switch (range) {
-	case 0x1000 :
-	default :
-		mib_addr = (char *) (&smc->mib) ;
-		break ;
-	case 0x2000 :
-		if (mac < 0 || mac >= NUMMACS) {
-			pcon->pc_err = SMT_RDF_NOPARAM ;
-			return ;
-		}
-		mib_addr = (char *) (&smc->mib.m[mac]) ;
-		mib_m = (struct fddi_mib_m *) mib_addr ;
-		break ;
-	case 0x3000 :
-		if (path < 0 || path >= NUMPATHS) {
-			pcon->pc_err = SMT_RDF_NOPARAM ;
-			return ;
-		}
-		mib_addr = (char *) (&smc->mib.a[path]) ;
-		break ;
-	case 0x4000 :
-		if (port < 0 || port >= smt_mib_phys(smc)) {
-			pcon->pc_err = SMT_RDF_NOPARAM ;
-			return ;
-		}
-		mib_addr = (char *) (&smc->mib.p[port_to_mib(smc,port)]) ;
-		mib_p = (struct fddi_mib_p *) mib_addr ;
-		break ;
-	}
-	/*
-	 * check special paras
-	 */
-	swap = NULL;
-	switch (para) {
-	case SMT_P10F0 :
-	case SMT_P10F1 :
-#ifdef	ESS
-	case SMT_P10F2 :
-	case SMT_P10F3 :
-	case SMT_P10F4 :
-	case SMT_P10F5 :
-	case SMT_P10F6 :
-	case SMT_P10F7 :
-#endif
-#ifdef	SBA
-	case SMT_P10F8 :
-	case SMT_P10F9 :
-#endif
-	case SMT_P20F1 :
-		if (!local) {
-			pcon->pc_err = SMT_RDF_NOPARAM ;
-			return ;
-		}
-		break ;
-	case SMT_P2034 :
-	case SMT_P2046 :
-	case SMT_P2047 :
-	case SMT_P204A :
-	case SMT_P2051 :
-	case SMT_P2052 :
-		mac_update_counter(smc) ;
-		break ;
-	case SMT_P4022:
-		mib_p->fddiPORTPC_LS = LS2MIB(
-			sm_pm_get_ls(smc,port_to_mib(smc,port))) ;
-		break ;
-	case SMT_P_REASON :
-		* (u_long *) to = 0 ;
-		sp_len = 4 ;
-		goto sp_done ;
-	case SMT_P1033 :			/* time stamp */
-		smt_set_timestamp(smc,smc->mib.fddiSMTTimeStamp) ;
-		break ;
-
-	case SMT_P1020:				/* port indexes */
-#if	NUMPHYS == 12
-		swap = "IIIIIIIIIIII" ;
-#else
-#if	NUMPHYS == 2
-		if (smc->s.sas == SMT_SAS)
-			swap = "I" ;
-		else
-			swap = "II" ;
-#else
-#if	NUMPHYS == 24
-		swap = "IIIIIIIIIIIIIIIIIIIIIIII" ;
-#else
-	????
-#endif
-#endif
-#endif
-		break ;
-	case SMT_P3212 :
-		{
-			sp_len = cem_build_path(smc,to,path) ;
-			goto sp_done ;
-		}
-	case SMT_P1048 :		/* peer wrap condition */
-		{
-			struct smt_p_1048	*sp ;
-			sp = (struct smt_p_1048 *) to ;
-			sp->p1048_flag = smc->mib.fddiSMTPeerWrapFlag ;
-			sp->p1048_cf_state = smc->mib.fddiSMTCF_State ;
-			sp_len = sizeof(struct smt_p_1048) ;
-			goto sp_done ;
-		}
-	case SMT_P208C :
-		{
-			struct smt_p_208c	*sp ;
-			sp = (struct smt_p_208c *) to ;
-			sp->p208c_flag =
-				smc->mib.m[MAC0].fddiMACDuplicateAddressCond ;
-			sp->p208c_dupcondition =
-				(mib_m->fddiMACDA_Flag ? SMT_ST_MY_DUPA : 0) |
-				(mib_m->fddiMACUNDA_Flag ? SMT_ST_UNA_DUPA : 0);
-			sp->p208c_fddilong =
-				mib_m->fddiMACSMTAddress ;
-			sp->p208c_fddiunalong =
-				mib_m->fddiMACUpstreamNbr ;
-			sp->p208c_pad = 0 ;
-			sp_len = sizeof(struct smt_p_208c) ;
-			goto sp_done ;
-		}
-	case SMT_P208D :		/* frame error condition */
-		{
-			struct smt_p_208d	*sp ;
-			sp = (struct smt_p_208d *) to ;
-			sp->p208d_flag =
-				mib_m->fddiMACFrameErrorFlag ;
-			sp->p208d_frame_ct =
-				mib_m->fddiMACFrame_Ct ;
-			sp->p208d_error_ct =
-				mib_m->fddiMACError_Ct ;
-			sp->p208d_lost_ct =
-				mib_m->fddiMACLost_Ct ;
-			sp->p208d_ratio =
-				mib_m->fddiMACFrameErrorRatio ;
-			sp_len = sizeof(struct smt_p_208d) ;
-			goto sp_done ;
-		}
-	case SMT_P208E :		/* not copied condition */
-		{
-			struct smt_p_208e	*sp ;
-			sp = (struct smt_p_208e *) to ;
-			sp->p208e_flag =
-				mib_m->fddiMACNotCopiedFlag ;
-			sp->p208e_not_copied =
-				mib_m->fddiMACNotCopied_Ct ;
-			sp->p208e_copied =
-				mib_m->fddiMACCopied_Ct ;
-			sp->p208e_not_copied_ratio =
-				mib_m->fddiMACNotCopiedRatio ;
-			sp_len = sizeof(struct smt_p_208e) ;
-			goto sp_done ;
-		}
-	case SMT_P208F :	/* neighbor change event */
-		{
-			struct smt_p_208f	*sp ;
-			sp = (struct smt_p_208f *) to ;
-			sp->p208f_multiple =
-				mib_m->fddiMACMultiple_N ;
-			sp->p208f_nacondition =
-				mib_m->fddiMACDuplicateAddressCond ;
-			sp->p208f_old_una =
-				mib_m->fddiMACOldUpstreamNbr ;
-			sp->p208f_new_una =
-				mib_m->fddiMACUpstreamNbr ;
-			sp->p208f_old_dna =
-				mib_m->fddiMACOldDownstreamNbr ;
-			sp->p208f_new_dna =
-				mib_m->fddiMACDownstreamNbr ;
-			sp->p208f_curren_path =
-				mib_m->fddiMACCurrentPath ;
-			sp->p208f_smt_address =
-				mib_m->fddiMACSMTAddress ;
-			sp_len = sizeof(struct smt_p_208f) ;
-			goto sp_done ;
-		}
-	case SMT_P2090 :
-		{
-			struct smt_p_2090	*sp ;
-			sp = (struct smt_p_2090 *) to ;
-			sp->p2090_multiple =
-				mib_m->fddiMACMultiple_P ;
-			sp->p2090_availablepaths =
-				mib_m->fddiMACAvailablePaths ;
-			sp->p2090_currentpath =
-				mib_m->fddiMACCurrentPath ;
-			sp->p2090_requestedpaths =
-				mib_m->fddiMACRequestedPaths ;
-			sp_len = sizeof(struct smt_p_2090) ;
-			goto sp_done ;
-		}
-	case SMT_P4050 :
-		{
-			struct smt_p_4050	*sp ;
-			sp = (struct smt_p_4050 *) to ;
-			sp->p4050_flag =
-				mib_p->fddiPORTLerFlag ;
-			sp->p4050_pad = 0 ;
-			sp->p4050_cutoff =
-				mib_p->fddiPORTLer_Cutoff ;
-			sp->p4050_alarm =
-				mib_p->fddiPORTLer_Alarm ;
-			sp->p4050_estimate =
-				mib_p->fddiPORTLer_Estimate ;
-			sp->p4050_reject_ct =
-				mib_p->fddiPORTLem_Reject_Ct ;
-			sp->p4050_ct =
-				mib_p->fddiPORTLem_Ct ;
-			sp_len = sizeof(struct smt_p_4050) ;
-			goto sp_done ;
-		}
-
-	case SMT_P4051 :
-		{
-			struct smt_p_4051	*sp ;
-			sp = (struct smt_p_4051 *) to ;
-			sp->p4051_multiple =
-				mib_p->fddiPORTMultiple_U ;
-			sp->p4051_porttype =
-				mib_p->fddiPORTMy_Type ;
-			sp->p4051_connectstate =
-				mib_p->fddiPORTConnectState ;
-			sp->p4051_pc_neighbor =
-				mib_p->fddiPORTNeighborType ;
-			sp->p4051_pc_withhold =
-				mib_p->fddiPORTPC_Withhold ;
-			sp_len = sizeof(struct smt_p_4051) ;
-			goto sp_done ;
-		}
-	case SMT_P4052 :
-		{
-			struct smt_p_4052	*sp ;
-			sp = (struct smt_p_4052 *) to ;
-			sp->p4052_flag =
-				mib_p->fddiPORTEB_Condition ;
-			sp->p4052_eberrorcount =
-				mib_p->fddiPORTEBError_Ct ;
-			sp_len = sizeof(struct smt_p_4052) ;
-			goto sp_done ;
-		}
-	case SMT_P4053 :
-		{
-			struct smt_p_4053	*sp ;
-			sp = (struct smt_p_4053 *) to ;
-			sp->p4053_multiple =
-				mib_p->fddiPORTMultiple_P ;
-			sp->p4053_availablepaths =
-				mib_p->fddiPORTAvailablePaths ;
-			sp->p4053_currentpath =
-				mib_p->fddiPORTCurrentPath ;
-			memcpy(	(char *) &sp->p4053_requestedpaths,
-				(char *) mib_p->fddiPORTRequestedPaths,4) ;
-			sp->p4053_mytype =
-				mib_p->fddiPORTMy_Type ;
-			sp->p4053_neighbortype =
-				mib_p->fddiPORTNeighborType ;
-			sp_len = sizeof(struct smt_p_4053) ;
-			goto sp_done ;
-		}
-	default :
-		break ;
-	}
-	/*
-	 * in table ?
-	 */
-	if (!pt) {
-		pcon->pc_err = (para & 0xff00) ? SMT_RDF_NOPARAM :
-						SMT_RDF_ILLEGAL ;
-		return ;
-	}
-	/*
-	 * check access rights
-	 */
-	switch (pt->p_access) {
-	case AC_G :
-	case AC_GR :
-		break ;
-	default :
-		pcon->pc_err = SMT_RDF_ILLEGAL ;
-		return ;
-	}
-	from = mib_addr + pt->p_offset ;
-	if (!swap)
-		swap = pt->p_swap ;		/* pointer to swap string */
-
-	/*
-	 * copy values
-	 */
-	while ((c = *swap++)) {
-		switch(c) {
-		case 'b' :
-		case 'w' :
-		case 'l' :
-			break ;
-		case 'S' :
-		case 'E' :
-		case 'R' :
-		case 'r' :
-			if (len < 4)
-				goto len_error ;
-			to[0] = 0 ;
-			to[1] = 0 ;
-#ifdef	LITTLE_ENDIAN
-			if (c == 'r') {
-				to[2] = *from++ ;
-				to[3] = *from++ ;
-			}
-			else {
-				to[3] = *from++ ;
-				to[2] = *from++ ;
-			}
-#else
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-#endif
-			to += 4 ;
-			len -= 4 ;
-			break ;
-		case 'I' :		/* for SET of port indexes */
-			if (len < 2)
-				goto len_error ;
-#ifdef	LITTLE_ENDIAN
-			to[1] = *from++ ;
-			to[0] = *from++ ;
-#else
-			to[0] = *from++ ;
-			to[1] = *from++ ;
-#endif
-			to += 2 ;
-			len -= 2 ;
-			break ;
-		case 'F' :
-		case 'B' :
-			if (len < 4)
-				goto len_error ;
-			len -= 4 ;
-			to[0] = 0 ;
-			to[1] = 0 ;
-			to[2] = 0 ;
-			to[3] = *from++ ;
-			to += 4 ;
-			break ;
-		case 'C' :
-		case 'T' :
-		case 'L' :
-			if (len < 4)
-				goto len_error ;
-#ifdef	LITTLE_ENDIAN
-			to[3] = *from++ ;
-			to[2] = *from++ ;
-			to[1] = *from++ ;
-			to[0] = *from++ ;
-#else
-			to[0] = *from++ ;
-			to[1] = *from++ ;
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-#endif
-			len -= 4 ;
-			to += 4 ;
-			break ;
-		case '2' :		/* PortMacIndicated */
-			if (len < 4)
-				goto len_error ;
-			to[0] = 0 ;
-			to[1] = 0 ;
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-			len -= 4 ;
-			to += 4 ;
-			break ;
-		case '4' :
-			if (len < 4)
-				goto len_error ;
-			to[0] = *from++ ;
-			to[1] = *from++ ;
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-			len -= 4 ;
-			to += 4 ;
-			break ;
-		case 'A' :
-			if (len < 8)
-				goto len_error ;
-			to[0] = 0 ;
-			to[1] = 0 ;
-			memcpy((char *) to+2,(char *) from,6) ;
-			to += 8 ;
-			from += 8 ;
-			len -= 8 ;
-			break ;
-		case '8' :
-			if (len < 8)
-				goto len_error ;
-			memcpy((char *) to,(char *) from,8) ;
-			to += 8 ;
-			from += 8 ;
-			len -= 8 ;
-			break ;
-		case 'D' :
-			if (len < 32)
-				goto len_error ;
-			memcpy((char *) to,(char *) from,32) ;
-			to += 32 ;
-			from += 32 ;
-			len -= 32 ;
-			break ;
-		case 'P' :		/* timestamp is NOT swapped */
-			if (len < 8)
-				goto len_error ;
-			to[0] = *from++ ;
-			to[1] = *from++ ;
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-			to[4] = *from++ ;
-			to[5] = *from++ ;
-			to[6] = *from++ ;
-			to[7] = *from++ ;
-			to += 8 ;
-			len -= 8 ;
-			break ;
-		default :
-			SMT_PANIC(smc,SMT_E0119, SMT_E0119_MSG) ;
-			break ;
-		}
-	}
-
-done:
-	/*
-	 * make it even (in case of 'I' encoding)
-	 * note: len is DECREMENTED
-	 */
-	if (len & 3) {
-		to[0] = 0 ;
-		to[1] = 0 ;
-		to += 4 - (len & 3 ) ;
-		len = len & ~ 3 ;
-	}
-
-	/* set type and length */
-	pa->p_type = para ;
-	pa->p_len = plen - len - PARA_LEN ;
-	/* return values */
-	pcon->pc_p = (void *) to ;
-	pcon->pc_len = len ;
-	return ;
-
-sp_done:
-	len -= sp_len ;
-	to += sp_len ;
-	goto done ;
-
-len_error:
-	/* parameter does not fit in frame */
-	pcon->pc_err = SMT_RDF_TOOLONG ;
-	return ;
-
-wrong_error:
-	pcon->pc_err = SMT_RDF_LENGTH ;
-}
-
-/*
- * set parameter
- */
-static int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index,
-			int local, int set)
-{
-#define IFSET(x)	if (set) (x)
-
-	const struct s_p_tab	*pt ;
-	int		len ;
-	char		*from ;
-	char		*to ;
-	const char	*swap ;
-	char		c ;
-	char		*mib_addr ;
-	struct fddi_mib	*mib ;
-	struct fddi_mib_m	*mib_m = NULL;
-	struct fddi_mib_a	*mib_a = NULL;
-	struct fddi_mib_p	*mib_p = NULL;
-	int		mac ;
-	int		path ;
-	int		port ;
-	SK_LOC_DECL(u_char,byte_val) ;
-	SK_LOC_DECL(u_short,word_val) ;
-	SK_LOC_DECL(u_long,long_val) ;
-
-	mac = index - INDEX_MAC ;
-	path = index - INDEX_PATH ;
-	port = index - INDEX_PORT ;
-	len = pa->p_len ;
-	from = (char *) (pa + 1 ) ;
-
-	mib = &smc->mib ;
-	switch (pa->p_type & 0xf000) {
-	case 0x1000 :
-	default :
-		mib_addr = (char *) mib ;
-		break ;
-	case 0x2000 :
-		if (mac < 0 || mac >= NUMMACS) {
-			return SMT_RDF_NOPARAM;
-		}
-		mib_m = &smc->mib.m[mac] ;
-		mib_addr = (char *) mib_m ;
-		from += 4 ;		/* skip index */
-		len -= 4 ;
-		break ;
-	case 0x3000 :
-		if (path < 0 || path >= NUMPATHS) {
-			return SMT_RDF_NOPARAM;
-		}
-		mib_a = &smc->mib.a[path] ;
-		mib_addr = (char *) mib_a ;
-		from += 4 ;		/* skip index */
-		len -= 4 ;
-		break ;
-	case 0x4000 :
-		if (port < 0 || port >= smt_mib_phys(smc)) {
-			return SMT_RDF_NOPARAM;
-		}
-		mib_p = &smc->mib.p[port_to_mib(smc,port)] ;
-		mib_addr = (char *) mib_p ;
-		from += 4 ;		/* skip index */
-		len -= 4 ;
-		break ;
-	}
-	switch (pa->p_type) {
-	case SMT_P10F0 :
-	case SMT_P10F1 :
-#ifdef	ESS
-	case SMT_P10F2 :
-	case SMT_P10F3 :
-	case SMT_P10F4 :
-	case SMT_P10F5 :
-	case SMT_P10F6 :
-	case SMT_P10F7 :
-#endif
-#ifdef	SBA
-	case SMT_P10F8 :
-	case SMT_P10F9 :
-#endif
-	case SMT_P20F1 :
-		if (!local)
-			return SMT_RDF_NOPARAM;
-		break ;
-	}
-	pt = smt_get_ptab(pa->p_type) ;
-	if (!pt)
-		return (pa->p_type & 0xff00) ? SMT_RDF_NOPARAM :
-					       SMT_RDF_ILLEGAL;
-	switch (pt->p_access) {
-	case AC_GR :
-	case AC_S :
-		break ;
-	default :
-		return SMT_RDF_ILLEGAL;
-	}
-	to = mib_addr + pt->p_offset ;
-	swap = pt->p_swap ;		/* pointer to swap string */
-
-	while (swap && (c = *swap++)) {
-		switch(c) {
-		case 'b' :
-			to = (char *) &byte_val ;
-			break ;
-		case 'w' :
-			to = (char *) &word_val ;
-			break ;
-		case 'l' :
-			to = (char *) &long_val ;
-			break ;
-		case 'S' :
-		case 'E' :
-		case 'R' :
-		case 'r' :
-			if (len < 4) {
-				goto len_error ;
-			}
-			if (from[0] | from[1])
-				goto val_error ;
-#ifdef	LITTLE_ENDIAN
-			if (c == 'r') {
-				to[0] = from[2] ;
-				to[1] = from[3] ;
-			}
-			else {
-				to[1] = from[2] ;
-				to[0] = from[3] ;
-			}
-#else
-			to[0] = from[2] ;
-			to[1] = from[3] ;
-#endif
-			from += 4 ;
-			to += 2 ;
-			len -= 4 ;
-			break ;
-		case 'F' :
-		case 'B' :
-			if (len < 4) {
-				goto len_error ;
-			}
-			if (from[0] | from[1] | from[2])
-				goto val_error ;
-			to[0] = from[3] ;
-			len -= 4 ;
-			from += 4 ;
-			to += 4 ;
-			break ;
-		case 'C' :
-		case 'T' :
-		case 'L' :
-			if (len < 4) {
-				goto len_error ;
-			}
-#ifdef	LITTLE_ENDIAN
-			to[3] = *from++ ;
-			to[2] = *from++ ;
-			to[1] = *from++ ;
-			to[0] = *from++ ;
-#else
-			to[0] = *from++ ;
-			to[1] = *from++ ;
-			to[2] = *from++ ;
-			to[3] = *from++ ;
-#endif
-			len -= 4 ;
-			to += 4 ;
-			break ;
-		case 'A' :
-			if (len < 8)
-				goto len_error ;
-			if (set)
-				memcpy((char *) to,(char *) from+2,6) ;
-			to += 8 ;
-			from += 8 ;
-			len -= 8 ;
-			break ;
-		case '4' :
-			if (len < 4)
-				goto len_error ;
-			if (set)
-				memcpy((char *) to,(char *) from,4) ;
-			to += 4 ;
-			from += 4 ;
-			len -= 4 ;
-			break ;
-		case '8' :
-			if (len < 8)
-				goto len_error ;
-			if (set)
-				memcpy((char *) to,(char *) from,8) ;
-			to += 8 ;
-			from += 8 ;
-			len -= 8 ;
-			break ;
-		case 'D' :
-			if (len < 32)
-				goto len_error ;
-			if (set)
-				memcpy((char *) to,(char *) from,32) ;
-			to += 32 ;
-			from += 32 ;
-			len -= 32 ;
-			break ;
-		case 'P' :		/* timestamp is NOT swapped */
-			if (set) {
-				to[0] = *from++ ;
-				to[1] = *from++ ;
-				to[2] = *from++ ;
-				to[3] = *from++ ;
-				to[4] = *from++ ;
-				to[5] = *from++ ;
-				to[6] = *from++ ;
-				to[7] = *from++ ;
-			}
-			to += 8 ;
-			len -= 8 ;
-			break ;
-		default :
-			SMT_PANIC(smc,SMT_E0120, SMT_E0120_MSG) ;
-			return SMT_RDF_ILLEGAL;
-		}
-	}
-	/*
-	 * actions and internal updates
-	 */
-	switch (pa->p_type) {
-	case SMT_P101A:			/* fddiSMTConfigPolicy */
-		if (word_val & ~1)
-			goto val_error ;
-		IFSET(mib->fddiSMTConfigPolicy = word_val) ;
-		break ;
-	case SMT_P101B :		/* fddiSMTConnectionPolicy */
-		if (!(word_val & POLICY_MM))
-			goto val_error ;
-		IFSET(mib->fddiSMTConnectionPolicy = word_val) ;
-		break ;
-	case SMT_P101D : 		/* fddiSMTTT_Notify */
-		if (word_val < 2 || word_val > 30)
-			goto val_error ;
-		IFSET(mib->fddiSMTTT_Notify = word_val) ;
-		break ;
-	case SMT_P101E :		/* fddiSMTStatRptPolicy */
-		if (byte_val & ~1)
-			goto val_error ;
-		IFSET(mib->fddiSMTStatRptPolicy = byte_val) ;
-		break ;
-	case SMT_P101F :		/* fddiSMTTrace_MaxExpiration */
-		/*
-		 * note: lower limit trace_max = 6.001773... s
-		 * NO upper limit
-		 */
-		if (long_val < (long)0x478bf51L)
-			goto val_error ;
-		IFSET(mib->fddiSMTTrace_MaxExpiration = long_val) ;
-		break ;
-#ifdef	ESS
-	case SMT_P10F2 :		/* fddiESSPayload */
-		if (long_val > 1562)
-			goto val_error ;
-		if (set && smc->mib.fddiESSPayload != long_val) {
-			smc->ess.raf_act_timer_poll = TRUE ;
-			smc->mib.fddiESSPayload = long_val ;
-		}
-		break ;
-	case SMT_P10F3 :		/* fddiESSOverhead */
-		if (long_val < 50 || long_val > 5000)
-			goto val_error ;
-		if (set && smc->mib.fddiESSPayload &&
-			smc->mib.fddiESSOverhead != long_val) {
-			smc->ess.raf_act_timer_poll = TRUE ;
-			smc->mib.fddiESSOverhead = long_val ;
-		}
-		break ;
-	case SMT_P10F4 :		/* fddiESSMaxTNeg */
-		if (long_val > -MS2BCLK(5) || long_val < -MS2BCLK(165))
-			goto val_error ;
-		IFSET(mib->fddiESSMaxTNeg = long_val) ;
-		break ;
-	case SMT_P10F5 :		/* fddiESSMinSegmentSize */
-		if (long_val < 1 || long_val > 4478)
-			goto val_error ;
-		IFSET(mib->fddiESSMinSegmentSize = long_val) ;
-		break ;
-	case SMT_P10F6 :		/* fddiESSCategory */
-		if ((long_val & 0xffff) != 1)
-			goto val_error ;
-		IFSET(mib->fddiESSCategory = long_val) ;
-		break ;
-	case SMT_P10F7 :		/* fddiESSSyncTxMode */
-		if (word_val > 1)
-			goto val_error ;
-		IFSET(mib->fddiESSSynchTxMode = word_val) ;
-		break ;
-#endif
-#ifdef	SBA
-	case SMT_P10F8 :		/* fddiSBACommand */
-		if (byte_val != SB_STOP && byte_val != SB_START)
-			goto val_error ;
-		IFSET(mib->fddiSBACommand = byte_val) ;
-		break ;
-	case SMT_P10F9 :		/* fddiSBAAvailable */
-		if (byte_val > 100)
-			goto val_error ;
-		IFSET(mib->fddiSBAAvailable = byte_val) ;
-		break ;
-#endif
-	case SMT_P2020 :		/* fddiMACRequestedPaths */
-		if ((word_val & (MIB_P_PATH_PRIM_PREFER |
-			MIB_P_PATH_PRIM_ALTER)) == 0 )
-			goto val_error ;
-		IFSET(mib_m->fddiMACRequestedPaths = word_val) ;
-		break ;
-	case SMT_P205F :		/* fddiMACFrameErrorThreshold */
-		/* 0 .. ffff acceptable */
-		IFSET(mib_m->fddiMACFrameErrorThreshold = word_val) ;
-		break ;
-	case SMT_P2067 :		/* fddiMACNotCopiedThreshold */
-		/* 0 .. ffff acceptable */
-		IFSET(mib_m->fddiMACNotCopiedThreshold = word_val) ;
-		break ;
-	case SMT_P2076:			/* fddiMACMA_UnitdataEnable */
-		if (byte_val & ~1)
-			goto val_error ;
-		if (set) {
-			mib_m->fddiMACMA_UnitdataEnable = byte_val ;
-			queue_event(smc,EVENT_RMT,RM_ENABLE_FLAG) ;
-		}
-		break ;
-	case SMT_P20F1 :		/* fddiMACT_Min */
-		IFSET(mib_m->fddiMACT_Min = long_val) ;
-		break ;
-	case SMT_P320F :
-		if (long_val > 1562)
-			goto val_error ;
-		IFSET(mib_a->fddiPATHSbaPayload = long_val) ;
-#ifdef	ESS
-		if (set)
-			ess_para_change(smc) ;
-#endif
-		break ;
-	case SMT_P3210 :
-		if (long_val > 5000)
-			goto val_error ;
-		
-		if (long_val != 0 && mib_a->fddiPATHSbaPayload == 0)
-			goto val_error ;
-
-		IFSET(mib_a->fddiPATHSbaOverhead = long_val) ;
-#ifdef	ESS
-		if (set)
-			ess_para_change(smc) ;
-#endif
-		break ;
-	case SMT_P3213:			/* fddiPATHT_Rmode */
-		/* no limit :
-		 * 0 .. 343.597 => 0 .. 2e32 * 80nS
-		 */
-		if (set) {
-			mib_a->fddiPATHT_Rmode = long_val ;
-			rtm_set_timer(smc) ;
-		}
-		break ;
-	case SMT_P3214 :		/* fddiPATHSbaAvailable */
-		if (long_val > 0x00BEBC20L)
-			goto val_error ;
-#ifdef SBA 
-		if (set && mib->fddiSBACommand == SB_STOP)
-			goto val_error ;
-#endif
-		IFSET(mib_a->fddiPATHSbaAvailable = long_val) ;
-		break ;
-	case SMT_P3215 :		/* fddiPATHTVXLowerBound */
-		IFSET(mib_a->fddiPATHTVXLowerBound = long_val) ;
-		goto change_mac_para ;
-	case SMT_P3216 :		/* fddiPATHT_MaxLowerBound */
-		IFSET(mib_a->fddiPATHT_MaxLowerBound = long_val) ;
-		goto change_mac_para ;
-	case SMT_P3217 :		/* fddiPATHMaxT_Req */
-		IFSET(mib_a->fddiPATHMaxT_Req = long_val) ;
-
-change_mac_para:
-		if (set && smt_set_mac_opvalues(smc)) {
-			RS_SET(smc,RS_EVENT) ;
-			smc->sm.please_reconnect = 1 ;
-			queue_event(smc,EVENT_ECM,EC_DISCONNECT) ;
-		}
-		break ;
-	case SMT_P400E :		/* fddiPORTConnectionPolicies */
-		if (byte_val > 1)
-			goto val_error ;
-		IFSET(mib_p->fddiPORTConnectionPolicies = byte_val) ;
-		break ;
-	case SMT_P4011 :		/* fddiPORTRequestedPaths */
-		/* all 3*8 bits allowed */
-		IFSET(memcpy((char *)mib_p->fddiPORTRequestedPaths,
-			(char *)&long_val,4)) ;
-		break ;
-	case SMT_P401F:			/* fddiPORTMaint_LS */
-		if (word_val > 4)
-			goto val_error ;
-		IFSET(mib_p->fddiPORTMaint_LS = word_val) ;
-		break ;
-	case SMT_P403A :		/* fddiPORTLer_Cutoff */
-		if (byte_val < 4 || byte_val > 15)
-			goto val_error ;
-		IFSET(mib_p->fddiPORTLer_Cutoff = byte_val) ;
-		break ;
-	case SMT_P403B :		/* fddiPORTLer_Alarm */
-		if (byte_val < 4 || byte_val > 15)
-			goto val_error ;
-		IFSET(mib_p->fddiPORTLer_Alarm = byte_val) ;
-		break ;
-
-	/*
-	 * Actions
-	 */
-	case SMT_P103C :		/* fddiSMTStationAction */
-		if (smt_action(smc,SMT_STATION_ACTION, (int) word_val, 0))
-			goto val_error ;
-		break ;
-	case SMT_P4046:			/* fddiPORTAction */
-		if (smt_action(smc,SMT_PORT_ACTION, (int) word_val,
-			port_to_mib(smc,port)))
-			goto val_error ;
-		break ;
-	default :
-		break ;
-	}
-	return 0;
-
-val_error:
-	/* parameter value in frame is out of range */
-	return SMT_RDF_RANGE;
-
-len_error:
-	/* parameter value in frame is too short */
-	return SMT_RDF_LENGTH;
-
-#if	0
-no_author_error:
-	/* parameter not setable, because the SBA is not active
-	 * Please note: we give the return code 'not authorizeed
-	 *  because SBA denied is not a valid return code in the
-	 * PMF protocol.
-	 */
-	return SMT_RDF_AUTHOR;
-#endif
-}
-
-static const struct s_p_tab *smt_get_ptab(u_short para)
-{
-	const struct s_p_tab	*pt ;
-	for (pt = p_tab ; pt->p_num && pt->p_num != para ; pt++)
-		;
-	return pt->p_num ? pt : NULL;
-}
-
-static int smt_mib_phys(struct s_smc *smc)
-{
-#ifdef	CONCENTRATOR
-	SK_UNUSED(smc) ;
-
-	return NUMPHYS;
-#else
-	if (smc->s.sas == SMT_SAS)
-		return 1;
-	return NUMPHYS;
-#endif
-}
-
-static int port_to_mib(struct s_smc *smc, int p)
-{
-#ifdef	CONCENTRATOR
-	SK_UNUSED(smc) ;
-
-	return p;
-#else
-	if (smc->s.sas == SMT_SAS)
-		return PS;
-	return p;
-#endif
-}
-
-
-#ifdef	DEBUG
-#ifndef	BOOT
-void dump_smt(struct s_smc *smc, struct smt_header *sm, char *text)
-{
-	int	len ;
-	struct smt_para	*pa ;
-	char	*c ;
-	int	n ;
-	int	nn ;
-#ifdef	LITTLE_ENDIAN
-	int	smtlen ;
-#endif
-
-	SK_UNUSED(smc) ;
-
-#ifdef	DEBUG_BRD
-	if (smc->debug.d_smtf < 2)
-#else
-	if (debug.d_smtf < 2)
-#endif
-		return ;
-#ifdef	LITTLE_ENDIAN
-	smtlen = sm->smt_len + sizeof(struct smt_header) ;
-#endif
-	printf("SMT Frame [%s]:\nDA  ",text) ;
-	dump_hex((char *) &sm->smt_dest,6) ;
-	printf("\tSA ") ;
-	dump_hex((char *) &sm->smt_source,6) ;
-	printf(" Class %x Type %x Version %x\n",
-		sm->smt_class,sm->smt_type,sm->smt_version)  ;
-	printf("TID %lx\t\tSID ",sm->smt_tid) ;
-	dump_hex((char *) &sm->smt_sid,8) ;
-	printf(" LEN %x\n",sm->smt_len) ;
-
-	len = sm->smt_len ;
-	pa = (struct smt_para *) (sm + 1) ;
-	while (len > 0 ) {
-		int	plen ;
-#ifdef UNIX
-		printf("TYPE %x LEN %x VALUE\t",pa->p_type,pa->p_len) ;
-#else
-		printf("TYPE %04x LEN %2x VALUE\t",pa->p_type,pa->p_len) ;
-#endif
-		n = pa->p_len ;
-		if ( (n < 0 ) || (n > (int)(len - PARA_LEN))) {
-			n = len - PARA_LEN ;
-			printf(" BAD LENGTH\n") ;
-			break ;
-		}
-#ifdef	LITTLE_ENDIAN
-		smt_swap_para(sm,smtlen,0) ;
-#endif
-		if (n < 24) {
-			dump_hex((char *)(pa+1),(int) n) ;
-			printf("\n") ;
-		}
-		else {
-			int	first = 0 ;
-			c = (char *)(pa+1) ;
-			dump_hex(c,16) ;
-			printf("\n") ;
-			n -= 16 ;
-			c += 16 ;
-			while (n > 0) {
-				nn = (n > 16) ? 16 : n ;
-				if (n > 64) {
-					if (first == 0)
-						printf("\t\t\t...\n") ;
-					first = 1 ;
-				}
-				else {
-					printf("\t\t\t") ;
-					dump_hex(c,nn) ;
-					printf("\n") ;
-				}
-				n -= nn ;
-				c += 16 ;
-			}
-		}
-#ifdef	LITTLE_ENDIAN
-		smt_swap_para(sm,smtlen,1) ;
-#endif
-		plen = (pa->p_len + PARA_LEN + 3) & ~3 ;
-		len -= plen ;
-		pa = (struct smt_para *)((char *)pa + plen) ;
-	}
-	printf("-------------------------------------------------\n\n") ;
-}
-
-void dump_hex(char *p, int len)
-{
-	int	n = 0 ;
-	while (len--) {
-		n++ ;
-#ifdef UNIX
-		printf("%x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
-#else
-		printf("%02x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
-#endif
-	}
-}
-#endif	/* no BOOT */
-#endif	/* DEBUG */
-
-
-#endif	/* no SLIM_SMT */
diff -urN flo-ElementalX-5.00/drivers/net/fddi/skfp/skfddi.c flo-ElementalX-5.00-patched/drivers/net/fddi/skfp/skfddi.c
--- flo-ElementalX-5.00/drivers/net/fddi/skfp/skfddi.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/net/fddi/skfp/skfddi.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,2260 +0,0 @@
-/*
- * File Name:
- *   skfddi.c
- *
- * Copyright Information:
- *   Copyright SysKonnect 1998,1999.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * The information in this file is provided "AS IS" without warranty.
- *
- * Abstract:
- *   A Linux device driver supporting the SysKonnect FDDI PCI controller
- *   familie.
- *
- * Maintainers:
- *   CG    Christoph Goos (cgoos@syskonnect.de)
- *
- * Contributors:
- *   DM    David S. Miller
- *
- * Address all question to:
- *   linux@syskonnect.de
- *
- * The technical manual for the adapters is available from SysKonnect's
- * web pages: www.syskonnect.com
- * Goto "Support" and search Knowledge Base for "manual".
- *
- * Driver Architecture:
- *   The driver architecture is based on the DEC FDDI driver by
- *   Lawrence V. Stefani and several ethernet drivers.
- *   I also used an existing Windows NT miniport driver.
- *   All hardware dependent functions are handled by the SysKonnect
- *   Hardware Module.
- *   The only headerfiles that are directly related to this source
- *   are skfddi.c, h/types.h, h/osdef1st.h, h/targetos.h.
- *   The others belong to the SysKonnect FDDI Hardware Module and
- *   should better not be changed.
- *
- * Modification History:
- *              Date            Name    Description
- *              02-Mar-98       CG	Created.
- *
- *		10-Mar-99	CG	Support for 2.2.x added.
- *		25-Mar-99	CG	Corrected IRQ routing for SMP (APIC)
- *		26-Oct-99	CG	Fixed compilation error on 2.2.13
- *		12-Nov-99	CG	Source code release
- *		22-Nov-99	CG	Included in kernel source.
- *		07-May-00	DM	64 bit fixes, new dma interface
- *		31-Jul-03	DB	Audit copy_*_user in skfp_ioctl
- *					  Daniele Bellucci <bellucda@tiscali.it>
- *		03-Dec-03	SH	Convert to PCI device model
- *
- * Compilation options (-Dxxx):
- *              DRIVERDEBUG     print lots of messages to log file
- *              DUMPPACKETS     print received/transmitted packets to logfile
- * 
- * Tested cpu architectures:
- *	- i386
- *	- sparc64
- */
-
-/* Version information string - should be updated prior to */
-/* each new release!!! */
-#define VERSION		"2.07"
-
-static const char * const boot_msg = 
-	"SysKonnect FDDI PCI Adapter driver v" VERSION " for\n"
-	"  SK-55xx/SK-58xx adapters (SK-NET FDDI-FP/UP/LP)";
-
-/* Include files */
-
-#include <linux/capability.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/fddidevice.h>
-#include <linux/skbuff.h>
-#include <linux/bitops.h>
-#include <linux/gfp.h>
-
-#include <asm/byteorder.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-
-#include	"h/types.h"
-#undef ADDR			// undo Linux definition
-#include	"h/skfbi.h"
-#include	"h/fddi.h"
-#include	"h/smc.h"
-#include	"h/smtstate.h"
-
-
-// Define module-wide (static) routines
-static int skfp_driver_init(struct net_device *dev);
-static int skfp_open(struct net_device *dev);
-static int skfp_close(struct net_device *dev);
-static irqreturn_t skfp_interrupt(int irq, void *dev_id);
-static struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev);
-static void skfp_ctl_set_multicast_list(struct net_device *dev);
-static void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev);
-static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr);
-static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-static netdev_tx_t skfp_send_pkt(struct sk_buff *skb,
-				       struct net_device *dev);
-static void send_queued_packets(struct s_smc *smc);
-static void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr);
-static void ResetAdapter(struct s_smc *smc);
-
-
-// Functions needed by the hardware module
-void *mac_drv_get_space(struct s_smc *smc, u_int size);
-void *mac_drv_get_desc_mem(struct s_smc *smc, u_int size);
-unsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt);
-unsigned long dma_master(struct s_smc *smc, void *virt, int len, int flag);
-void dma_complete(struct s_smc *smc, volatile union s_fp_descr *descr,
-		  int flag);
-void mac_drv_tx_complete(struct s_smc *smc, volatile struct s_smt_fp_txd *txd);
-void llc_restart_tx(struct s_smc *smc);
-void mac_drv_rx_complete(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-			 int frag_count, int len);
-void mac_drv_requeue_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-			 int frag_count);
-void mac_drv_fill_rxd(struct s_smc *smc);
-void mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-		       int frag_count);
-int mac_drv_rx_init(struct s_smc *smc, int len, int fc, char *look_ahead,
-		    int la_len);
-void dump_data(unsigned char *Data, int length);
-
-// External functions from the hardware module
-extern u_int mac_drv_check_space(void);
-extern int mac_drv_init(struct s_smc *smc);
-extern void hwm_tx_frag(struct s_smc *smc, char far * virt, u_long phys,
-			int len, int frame_status);
-extern int hwm_tx_init(struct s_smc *smc, u_char fc, int frag_count,
-		       int frame_len, int frame_status);
-extern void fddi_isr(struct s_smc *smc);
-extern void hwm_rx_frag(struct s_smc *smc, char far * virt, u_long phys,
-			int len, int frame_status);
-extern void mac_drv_rx_mode(struct s_smc *smc, int mode);
-extern void mac_drv_clear_rx_queue(struct s_smc *smc);
-extern void enable_tx_irq(struct s_smc *smc, u_short queue);
-
-static DEFINE_PCI_DEVICE_TABLE(skfddi_pci_tbl) = {
-	{ PCI_VENDOR_ID_SK, PCI_DEVICE_ID_SK_FP, PCI_ANY_ID, PCI_ANY_ID, },
-	{ }			/* Terminating entry */
-};
-MODULE_DEVICE_TABLE(pci, skfddi_pci_tbl);
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mirko Lindner <mlindner@syskonnect.de>");
-
-// Define module-wide (static) variables
-
-static int num_boards;	/* total number of adapters configured */
-
-static const struct net_device_ops skfp_netdev_ops = {
-	.ndo_open		= skfp_open,
-	.ndo_stop		= skfp_close,
-	.ndo_start_xmit		= skfp_send_pkt,
-	.ndo_get_stats		= skfp_ctl_get_stats,
-	.ndo_change_mtu		= fddi_change_mtu,
-	.ndo_set_rx_mode	= skfp_ctl_set_multicast_list,
-	.ndo_set_mac_address	= skfp_ctl_set_mac_address,
-	.ndo_do_ioctl		= skfp_ioctl,
-};
-
-/*
- * =================
- * = skfp_init_one =
- * =================
- *   
- * Overview:
- *   Probes for supported FDDI PCI controllers
- *  
- * Returns:
- *   Condition code
- *       
- * Arguments:
- *   pdev - pointer to PCI device information
- *
- * Functional Description:
- *   This is now called by PCI driver registration process
- *   for each board found.
- *   
- * Return Codes:
- *   0           - This device (fddi0, fddi1, etc) configured successfully
- *   -ENODEV - No devices present, or no SysKonnect FDDI PCI device
- *                         present for this device name
- *
- *
- * Side Effects:
- *   Device structures for FDDI adapters (fddi0, fddi1, etc) are
- *   initialized and the board resources are read and stored in
- *   the device structure.
- */
-static int skfp_init_one(struct pci_dev *pdev,
-				const struct pci_device_id *ent)
-{
-	struct net_device *dev;
-	struct s_smc *smc;	/* board pointer */
-	void __iomem *mem;
-	int err;
-
-	pr_debug("entering skfp_init_one\n");
-
-	if (num_boards == 0) 
-		printk("%s\n", boot_msg);
-
-	err = pci_enable_device(pdev);
-	if (err)
-		return err;
-
-	err = pci_request_regions(pdev, "skfddi");
-	if (err)
-		goto err_out1;
-
-	pci_set_master(pdev);
-
-#ifdef MEM_MAPPED_IO
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
-		printk(KERN_ERR "skfp: region is not an MMIO resource\n");
-		err = -EIO;
-		goto err_out2;
-	}
-
-	mem = ioremap(pci_resource_start(pdev, 0), 0x4000);
-#else
-	if (!(pci_resource_flags(pdev, 1) & IO_RESOURCE_IO)) {
-		printk(KERN_ERR "skfp: region is not PIO resource\n");
-		err = -EIO;
-		goto err_out2;
-	}
-
-	mem = ioport_map(pci_resource_start(pdev, 1), FP_IO_LEN);
-#endif
-	if (!mem) {
-		printk(KERN_ERR "skfp:  Unable to map register, "
-				"FDDI adapter will be disabled.\n");
-		err = -EIO;
-		goto err_out2;
-	}
-
-	dev = alloc_fddidev(sizeof(struct s_smc));
-	if (!dev) {
-		printk(KERN_ERR "skfp: Unable to allocate fddi device, "
-				"FDDI adapter will be disabled.\n");
-		err = -ENOMEM;
-		goto err_out3;
-	}
-
-	dev->irq = pdev->irq;
-	dev->netdev_ops = &skfp_netdev_ops;
-
-	SET_NETDEV_DEV(dev, &pdev->dev);
-
-	/* Initialize board structure with bus-specific info */
-	smc = netdev_priv(dev);
-	smc->os.dev = dev;
-	smc->os.bus_type = SK_BUS_TYPE_PCI;
-	smc->os.pdev = *pdev;
-	smc->os.QueueSkb = MAX_TX_QUEUE_LEN;
-	smc->os.MaxFrameSize = MAX_FRAME_SIZE;
-	smc->os.dev = dev;
-	smc->hw.slot = -1;
-	smc->hw.iop = mem;
-	smc->os.ResetRequested = FALSE;
-	skb_queue_head_init(&smc->os.SendSkbQueue);
-
-	dev->base_addr = (unsigned long)mem;
-
-	err = skfp_driver_init(dev);
-	if (err)
-		goto err_out4;
-
-	err = register_netdev(dev);
-	if (err)
-		goto err_out5;
-
-	++num_boards;
-	pci_set_drvdata(pdev, dev);
-
-	if ((pdev->subsystem_device & 0xff00) == 0x5500 ||
-	    (pdev->subsystem_device & 0xff00) == 0x5800) 
-		printk("%s: SysKonnect FDDI PCI adapter"
-		       " found (SK-%04X)\n", dev->name,	
-		       pdev->subsystem_device);
-	else
-		printk("%s: FDDI PCI adapter found\n", dev->name);
-
-	return 0;
-err_out5:
-	if (smc->os.SharedMemAddr) 
-		pci_free_consistent(pdev, smc->os.SharedMemSize,
-				    smc->os.SharedMemAddr, 
-				    smc->os.SharedMemDMA);
-	pci_free_consistent(pdev, MAX_FRAME_SIZE,
-			    smc->os.LocalRxBuffer, smc->os.LocalRxBufferDMA);
-err_out4:
-	free_netdev(dev);
-err_out3:
-#ifdef MEM_MAPPED_IO
-	iounmap(mem);
-#else
-	ioport_unmap(mem);
-#endif
-err_out2:
-	pci_release_regions(pdev);
-err_out1:
-	pci_disable_device(pdev);
-	return err;
-}
-
-/*
- * Called for each adapter board from pci_unregister_driver
- */
-static void __devexit skfp_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *p = pci_get_drvdata(pdev);
-	struct s_smc *lp = netdev_priv(p);
-
-	unregister_netdev(p);
-
-	if (lp->os.SharedMemAddr) {
-		pci_free_consistent(&lp->os.pdev,
-				    lp->os.SharedMemSize,
-				    lp->os.SharedMemAddr,
-				    lp->os.SharedMemDMA);
-		lp->os.SharedMemAddr = NULL;
-	}
-	if (lp->os.LocalRxBuffer) {
-		pci_free_consistent(&lp->os.pdev,
-				    MAX_FRAME_SIZE,
-				    lp->os.LocalRxBuffer,
-				    lp->os.LocalRxBufferDMA);
-		lp->os.LocalRxBuffer = NULL;
-	}
-#ifdef MEM_MAPPED_IO
-	iounmap(lp->hw.iop);
-#else
-	ioport_unmap(lp->hw.iop);
-#endif
-	pci_release_regions(pdev);
-	free_netdev(p);
-
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-}
-
-/*
- * ====================
- * = skfp_driver_init =
- * ====================
- *   
- * Overview:
- *   Initializes remaining adapter board structure information
- *   and makes sure adapter is in a safe state prior to skfp_open().
- *  
- * Returns:
- *   Condition code
- *       
- * Arguments:
- *   dev - pointer to device information
- *
- * Functional Description:
- *   This function allocates additional resources such as the host memory
- *   blocks needed by the adapter.
- *   The adapter is also reset. The OS must call skfp_open() to open 
- *   the adapter and bring it on-line.
- *
- * Return Codes:
- *    0 - initialization succeeded
- *   -1 - initialization failed
- */
-static  int skfp_driver_init(struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	skfddi_priv *bp = &smc->os;
-	int err = -EIO;
-
-	pr_debug("entering skfp_driver_init\n");
-
-	// set the io address in private structures
-	bp->base_addr = dev->base_addr;
-
-	// Get the interrupt level from the PCI Configuration Table
-	smc->hw.irq = dev->irq;
-
-	spin_lock_init(&bp->DriverLock);
-	
-	// Allocate invalid frame
-	bp->LocalRxBuffer = pci_alloc_consistent(&bp->pdev, MAX_FRAME_SIZE, &bp->LocalRxBufferDMA);
-	if (!bp->LocalRxBuffer) {
-		printk("could not allocate mem for ");
-		printk("LocalRxBuffer: %d byte\n", MAX_FRAME_SIZE);
-		goto fail;
-	}
-
-	// Determine the required size of the 'shared' memory area.
-	bp->SharedMemSize = mac_drv_check_space();
-	pr_debug("Memory for HWM: %ld\n", bp->SharedMemSize);
-	if (bp->SharedMemSize > 0) {
-		bp->SharedMemSize += 16;	// for descriptor alignment
-
-		bp->SharedMemAddr = pci_alloc_consistent(&bp->pdev,
-							 bp->SharedMemSize,
-							 &bp->SharedMemDMA);
-		if (!bp->SharedMemAddr) {
-			printk("could not allocate mem for ");
-			printk("hardware module: %ld byte\n",
-			       bp->SharedMemSize);
-			goto fail;
-		}
-		bp->SharedMemHeap = 0;	// Nothing used yet.
-
-	} else {
-		bp->SharedMemAddr = NULL;
-		bp->SharedMemHeap = 0;
-	}			// SharedMemSize > 0
-
-	memset(bp->SharedMemAddr, 0, bp->SharedMemSize);
-
-	card_stop(smc);		// Reset adapter.
-
-	pr_debug("mac_drv_init()..\n");
-	if (mac_drv_init(smc) != 0) {
-		pr_debug("mac_drv_init() failed\n");
-		goto fail;
-	}
-	read_address(smc, NULL);
-	pr_debug("HW-Addr: %pMF\n", smc->hw.fddi_canon_addr.a);
-	memcpy(dev->dev_addr, smc->hw.fddi_canon_addr.a, 6);
-
-	smt_reset_defaults(smc, 0);
-
-	return 0;
-
-fail:
-	if (bp->SharedMemAddr) {
-		pci_free_consistent(&bp->pdev,
-				    bp->SharedMemSize,
-				    bp->SharedMemAddr,
-				    bp->SharedMemDMA);
-		bp->SharedMemAddr = NULL;
-	}
-	if (bp->LocalRxBuffer) {
-		pci_free_consistent(&bp->pdev, MAX_FRAME_SIZE,
-				    bp->LocalRxBuffer, bp->LocalRxBufferDMA);
-		bp->LocalRxBuffer = NULL;
-	}
-	return err;
-}				// skfp_driver_init
-
-
-/*
- * =============
- * = skfp_open =
- * =============
- *   
- * Overview:
- *   Opens the adapter
- *  
- * Returns:
- *   Condition code
- *       
- * Arguments:
- *   dev - pointer to device information
- *
- * Functional Description:
- *   This function brings the adapter to an operational state.
- *
- * Return Codes:
- *   0           - Adapter was successfully opened
- *   -EAGAIN - Could not register IRQ
- */
-static int skfp_open(struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	int err;
-
-	pr_debug("entering skfp_open\n");
-	/* Register IRQ - support shared interrupts by passing device ptr */
-	err = request_irq(dev->irq, skfp_interrupt, IRQF_SHARED,
-			  dev->name, dev);
-	if (err)
-		return err;
-
-	/*
-	 * Set current address to factory MAC address
-	 *
-	 * Note: We've already done this step in skfp_driver_init.
-	 *       However, it's possible that a user has set a node
-	 *               address override, then closed and reopened the
-	 *               adapter.  Unless we reset the device address field
-	 *               now, we'll continue to use the existing modified
-	 *               address.
-	 */
-	read_address(smc, NULL);
-	memcpy(dev->dev_addr, smc->hw.fddi_canon_addr.a, 6);
-
-	init_smt(smc, NULL);
-	smt_online(smc, 1);
-	STI_FBI();
-
-	/* Clear local multicast address tables */
-	mac_clear_multicast(smc);
-
-	/* Disable promiscuous filter settings */
-	mac_drv_rx_mode(smc, RX_DISABLE_PROMISC);
-
-	netif_start_queue(dev);
-	return 0;
-}				// skfp_open
-
-
-/*
- * ==============
- * = skfp_close =
- * ==============
- *   
- * Overview:
- *   Closes the device/module.
- *  
- * Returns:
- *   Condition code
- *       
- * Arguments:
- *   dev - pointer to device information
- *
- * Functional Description:
- *   This routine closes the adapter and brings it to a safe state.
- *   The interrupt service routine is deregistered with the OS.
- *   The adapter can be opened again with another call to skfp_open().
- *
- * Return Codes:
- *   Always return 0.
- *
- * Assumptions:
- *   No further requests for this adapter are made after this routine is
- *   called.  skfp_open() can be called to reset and reinitialize the
- *   adapter.
- */
-static int skfp_close(struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	skfddi_priv *bp = &smc->os;
-
-	CLI_FBI();
-	smt_reset_defaults(smc, 1);
-	card_stop(smc);
-	mac_drv_clear_tx_queue(smc);
-	mac_drv_clear_rx_queue(smc);
-
-	netif_stop_queue(dev);
-	/* Deregister (free) IRQ */
-	free_irq(dev->irq, dev);
-
-	skb_queue_purge(&bp->SendSkbQueue);
-	bp->QueueSkb = MAX_TX_QUEUE_LEN;
-
-	return 0;
-}				// skfp_close
-
-
-/*
- * ==================
- * = skfp_interrupt =
- * ==================
- *   
- * Overview:
- *   Interrupt processing routine
- *  
- * Returns:
- *   None
- *       
- * Arguments:
- *   irq        - interrupt vector
- *   dev_id     - pointer to device information
- *
- * Functional Description:
- *   This routine calls the interrupt processing routine for this adapter.  It
- *   disables and reenables adapter interrupts, as appropriate.  We can support
- *   shared interrupts since the incoming dev_id pointer provides our device
- *   structure context. All the real work is done in the hardware module.
- *
- * Return Codes:
- *   None
- *
- * Assumptions:
- *   The interrupt acknowledgement at the hardware level (eg. ACKing the PIC
- *   on Intel-based systems) is done by the operating system outside this
- *   routine.
- *
- *       System interrupts are enabled through this call.
- *
- * Side Effects:
- *   Interrupts are disabled, then reenabled at the adapter.
- */
-
-static irqreturn_t skfp_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	struct s_smc *smc;	/* private board structure pointer */
-	skfddi_priv *bp;
-
-	smc = netdev_priv(dev);
-	bp = &smc->os;
-
-	// IRQs enabled or disabled ?
-	if (inpd(ADDR(B0_IMSK)) == 0) {
-		// IRQs are disabled: must be shared interrupt
-		return IRQ_NONE;
-	}
-	// Note: At this point, IRQs are enabled.
-	if ((inpd(ISR_A) & smc->hw.is_imask) == 0) {	// IRQ?
-		// Adapter did not issue an IRQ: must be shared interrupt
-		return IRQ_NONE;
-	}
-	CLI_FBI();		// Disable IRQs from our adapter.
-	spin_lock(&bp->DriverLock);
-
-	// Call interrupt handler in hardware module (HWM).
-	fddi_isr(smc);
-
-	if (smc->os.ResetRequested) {
-		ResetAdapter(smc);
-		smc->os.ResetRequested = FALSE;
-	}
-	spin_unlock(&bp->DriverLock);
-	STI_FBI();		// Enable IRQs from our adapter.
-
-	return IRQ_HANDLED;
-}				// skfp_interrupt
-
-
-/*
- * ======================
- * = skfp_ctl_get_stats =
- * ======================
- *   
- * Overview:
- *   Get statistics for FDDI adapter
- *  
- * Returns:
- *   Pointer to FDDI statistics structure
- *       
- * Arguments:
- *   dev - pointer to device information
- *
- * Functional Description:
- *   Gets current MIB objects from adapter, then
- *   returns FDDI statistics structure as defined
- *   in if_fddi.h.
- *
- *   Note: Since the FDDI statistics structure is
- *   still new and the device structure doesn't
- *   have an FDDI-specific get statistics handler,
- *   we'll return the FDDI statistics structure as
- *   a pointer to an Ethernet statistics structure.
- *   That way, at least the first part of the statistics
- *   structure can be decoded properly.
- *   We'll have to pay attention to this routine as the
- *   device structure becomes more mature and LAN media
- *   independent.
- *
- */
-static struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev)
-{
-	struct s_smc *bp = netdev_priv(dev);
-
-	/* Fill the bp->stats structure with driver-maintained counters */
-
-	bp->os.MacStat.port_bs_flag[0] = 0x1234;
-	bp->os.MacStat.port_bs_flag[1] = 0x5678;
-// goos: need to fill out fddi statistic
-#if 0
-	/* Get FDDI SMT MIB objects */
-
-/* Fill the bp->stats structure with the SMT MIB object values */
-
-	memcpy(bp->stats.smt_station_id, &bp->cmd_rsp_virt->smt_mib_get.smt_station_id, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_station_id));
-	bp->stats.smt_op_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_op_version_id;
-	bp->stats.smt_hi_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_hi_version_id;
-	bp->stats.smt_lo_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_lo_version_id;
-	memcpy(bp->stats.smt_user_data, &bp->cmd_rsp_virt->smt_mib_get.smt_user_data, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_user_data));
-	bp->stats.smt_mib_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_mib_version_id;
-	bp->stats.smt_mac_cts = bp->cmd_rsp_virt->smt_mib_get.smt_mac_ct;
-	bp->stats.smt_non_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_non_master_ct;
-	bp->stats.smt_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_master_ct;
-	bp->stats.smt_available_paths = bp->cmd_rsp_virt->smt_mib_get.smt_available_paths;
-	bp->stats.smt_config_capabilities = bp->cmd_rsp_virt->smt_mib_get.smt_config_capabilities;
-	bp->stats.smt_config_policy = bp->cmd_rsp_virt->smt_mib_get.smt_config_policy;
-	bp->stats.smt_connection_policy = bp->cmd_rsp_virt->smt_mib_get.smt_connection_policy;
-	bp->stats.smt_t_notify = bp->cmd_rsp_virt->smt_mib_get.smt_t_notify;
-	bp->stats.smt_stat_rpt_policy = bp->cmd_rsp_virt->smt_mib_get.smt_stat_rpt_policy;
-	bp->stats.smt_trace_max_expiration = bp->cmd_rsp_virt->smt_mib_get.smt_trace_max_expiration;
-	bp->stats.smt_bypass_present = bp->cmd_rsp_virt->smt_mib_get.smt_bypass_present;
-	bp->stats.smt_ecm_state = bp->cmd_rsp_virt->smt_mib_get.smt_ecm_state;
-	bp->stats.smt_cf_state = bp->cmd_rsp_virt->smt_mib_get.smt_cf_state;
-	bp->stats.smt_remote_disconnect_flag = bp->cmd_rsp_virt->smt_mib_get.smt_remote_disconnect_flag;
-	bp->stats.smt_station_status = bp->cmd_rsp_virt->smt_mib_get.smt_station_status;
-	bp->stats.smt_peer_wrap_flag = bp->cmd_rsp_virt->smt_mib_get.smt_peer_wrap_flag;
-	bp->stats.smt_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_msg_time_stamp.ls;
-	bp->stats.smt_transition_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_transition_time_stamp.ls;
-	bp->stats.mac_frame_status_functions = bp->cmd_rsp_virt->smt_mib_get.mac_frame_status_functions;
-	bp->stats.mac_t_max_capability = bp->cmd_rsp_virt->smt_mib_get.mac_t_max_capability;
-	bp->stats.mac_tvx_capability = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_capability;
-	bp->stats.mac_available_paths = bp->cmd_rsp_virt->smt_mib_get.mac_available_paths;
-	bp->stats.mac_current_path = bp->cmd_rsp_virt->smt_mib_get.mac_current_path;
-	memcpy(bp->stats.mac_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);
-	memcpy(bp->stats.mac_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);
-	memcpy(bp->stats.mac_old_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);
-	memcpy(bp->stats.mac_old_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);
-	bp->stats.mac_dup_address_test = bp->cmd_rsp_virt->smt_mib_get.mac_dup_address_test;
-	bp->stats.mac_requested_paths = bp->cmd_rsp_virt->smt_mib_get.mac_requested_paths;
-	bp->stats.mac_downstream_port_type = bp->cmd_rsp_virt->smt_mib_get.mac_downstream_port_type;
-	memcpy(bp->stats.mac_smt_address, &bp->cmd_rsp_virt->smt_mib_get.mac_smt_address, FDDI_K_ALEN);
-	bp->stats.mac_t_req = bp->cmd_rsp_virt->smt_mib_get.mac_t_req;
-	bp->stats.mac_t_neg = bp->cmd_rsp_virt->smt_mib_get.mac_t_neg;
-	bp->stats.mac_t_max = bp->cmd_rsp_virt->smt_mib_get.mac_t_max;
-	bp->stats.mac_tvx_value = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_value;
-	bp->stats.mac_frame_error_threshold = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_threshold;
-	bp->stats.mac_frame_error_ratio = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_ratio;
-	bp->stats.mac_rmt_state = bp->cmd_rsp_virt->smt_mib_get.mac_rmt_state;
-	bp->stats.mac_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_da_flag;
-	bp->stats.mac_una_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_unda_flag;
-	bp->stats.mac_frame_error_flag = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_flag;
-	bp->stats.mac_ma_unitdata_available = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_available;
-	bp->stats.mac_hardware_present = bp->cmd_rsp_virt->smt_mib_get.mac_hardware_present;
-	bp->stats.mac_ma_unitdata_enable = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_enable;
-	bp->stats.path_tvx_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_tvx_lower_bound;
-	bp->stats.path_t_max_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_t_max_lower_bound;
-	bp->stats.path_max_t_req = bp->cmd_rsp_virt->smt_mib_get.path_max_t_req;
-	memcpy(bp->stats.path_configuration, &bp->cmd_rsp_virt->smt_mib_get.path_configuration, sizeof(bp->cmd_rsp_virt->smt_mib_get.path_configuration));
-	bp->stats.port_my_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[0];
-	bp->stats.port_my_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[1];
-	bp->stats.port_neighbor_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[0];
-	bp->stats.port_neighbor_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[1];
-	bp->stats.port_connection_policies[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[0];
-	bp->stats.port_connection_policies[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[1];
-	bp->stats.port_mac_indicated[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[0];
-	bp->stats.port_mac_indicated[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[1];
-	bp->stats.port_current_path[0] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[0];
-	bp->stats.port_current_path[1] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[1];
-	memcpy(&bp->stats.port_requested_paths[0 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[0], 3);
-	memcpy(&bp->stats.port_requested_paths[1 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[1], 3);
-	bp->stats.port_mac_placement[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[0];
-	bp->stats.port_mac_placement[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[1];
-	bp->stats.port_available_paths[0] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[0];
-	bp->stats.port_available_paths[1] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[1];
-	bp->stats.port_pmd_class[0] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[0];
-	bp->stats.port_pmd_class[1] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[1];
-	bp->stats.port_connection_capabilities[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[0];
-	bp->stats.port_connection_capabilities[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[1];
-	bp->stats.port_bs_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[0];
-	bp->stats.port_bs_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[1];
-	bp->stats.port_ler_estimate[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[0];
-	bp->stats.port_ler_estimate[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[1];
-	bp->stats.port_ler_cutoff[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[0];
-	bp->stats.port_ler_cutoff[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[1];
-	bp->stats.port_ler_alarm[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[0];
-	bp->stats.port_ler_alarm[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[1];
-	bp->stats.port_connect_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[0];
-	bp->stats.port_connect_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[1];
-	bp->stats.port_pcm_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[0];
-	bp->stats.port_pcm_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[1];
-	bp->stats.port_pc_withhold[0] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[0];
-	bp->stats.port_pc_withhold[1] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[1];
-	bp->stats.port_ler_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[0];
-	bp->stats.port_ler_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[1];
-	bp->stats.port_hardware_present[0] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[0];
-	bp->stats.port_hardware_present[1] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[1];
-
-
-	/* Fill the bp->stats structure with the FDDI counter values */
-
-	bp->stats.mac_frame_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.frame_cnt.ls;
-	bp->stats.mac_copied_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.copied_cnt.ls;
-	bp->stats.mac_transmit_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.transmit_cnt.ls;
-	bp->stats.mac_error_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.error_cnt.ls;
-	bp->stats.mac_lost_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.lost_cnt.ls;
-	bp->stats.port_lct_fail_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[0].ls;
-	bp->stats.port_lct_fail_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[1].ls;
-	bp->stats.port_lem_reject_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[0].ls;
-	bp->stats.port_lem_reject_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[1].ls;
-	bp->stats.port_lem_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[0].ls;
-	bp->stats.port_lem_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[1].ls;
-
-#endif
-	return (struct net_device_stats *)&bp->os.MacStat;
-}				// ctl_get_stat
-
-
-/*
- * ==============================
- * = skfp_ctl_set_multicast_list =
- * ==============================
- *   
- * Overview:
- *   Enable/Disable LLC frame promiscuous mode reception
- *   on the adapter and/or update multicast address table.
- *  
- * Returns:
- *   None
- *       
- * Arguments:
- *   dev - pointer to device information
- *
- * Functional Description:
- *   This function acquires the driver lock and only calls
- *   skfp_ctl_set_multicast_list_wo_lock then.
- *   This routine follows a fairly simple algorithm for setting the
- *   adapter filters and CAM:
- *
- *      if IFF_PROMISC flag is set
- *              enable promiscuous mode
- *      else
- *              disable promiscuous mode
- *              if number of multicast addresses <= max. multicast number
- *                      add mc addresses to adapter table
- *              else
- *                      enable promiscuous mode
- *              update adapter filters
- *
- * Assumptions:
- *   Multicast addresses are presented in canonical (LSB) format.
- *
- * Side Effects:
- *   On-board adapter filters are updated.
- */
-static void skfp_ctl_set_multicast_list(struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	skfddi_priv *bp = &smc->os;
-	unsigned long Flags;
-
-	spin_lock_irqsave(&bp->DriverLock, Flags);
-	skfp_ctl_set_multicast_list_wo_lock(dev);
-	spin_unlock_irqrestore(&bp->DriverLock, Flags);
-}				// skfp_ctl_set_multicast_list
-
-
-
-static void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	struct netdev_hw_addr *ha;
-
-	/* Enable promiscuous mode, if necessary */
-	if (dev->flags & IFF_PROMISC) {
-		mac_drv_rx_mode(smc, RX_ENABLE_PROMISC);
-		pr_debug("PROMISCUOUS MODE ENABLED\n");
-	}
-	/* Else, update multicast address table */
-	else {
-		mac_drv_rx_mode(smc, RX_DISABLE_PROMISC);
-		pr_debug("PROMISCUOUS MODE DISABLED\n");
-
-		// Reset all MC addresses
-		mac_clear_multicast(smc);
-		mac_drv_rx_mode(smc, RX_DISABLE_ALLMULTI);
-
-		if (dev->flags & IFF_ALLMULTI) {
-			mac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);
-			pr_debug("ENABLE ALL MC ADDRESSES\n");
-		} else if (!netdev_mc_empty(dev)) {
-			if (netdev_mc_count(dev) <= FPMAX_MULTICAST) {
-				/* use exact filtering */
-
-				// point to first multicast addr
-				netdev_for_each_mc_addr(ha, dev) {
-					mac_add_multicast(smc,
-						(struct fddi_addr *)ha->addr,
-						1);
-
-					pr_debug("ENABLE MC ADDRESS: %pMF\n",
-						 ha->addr);
-				}
-
-			} else {	// more MC addresses than HW supports
-
-				mac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);
-				pr_debug("ENABLE ALL MC ADDRESSES\n");
-			}
-		} else {	// no MC addresses
-
-			pr_debug("DISABLE ALL MC ADDRESSES\n");
-		}
-
-		/* Update adapter filters */
-		mac_update_multicast(smc);
-	}
-}				// skfp_ctl_set_multicast_list_wo_lock
-
-
-/*
- * ===========================
- * = skfp_ctl_set_mac_address =
- * ===========================
- *   
- * Overview:
- *   set new mac address on adapter and update dev_addr field in device table.
- *  
- * Returns:
- *   None
- *       
- * Arguments:
- *   dev  - pointer to device information
- *   addr - pointer to sockaddr structure containing unicast address to set
- *
- * Assumptions:
- *   The address pointed to by addr->sa_data is a valid unicast
- *   address and is presented in canonical (LSB) format.
- */
-static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	struct sockaddr *p_sockaddr = (struct sockaddr *) addr;
-	skfddi_priv *bp = &smc->os;
-	unsigned long Flags;
-
-
-	memcpy(dev->dev_addr, p_sockaddr->sa_data, FDDI_K_ALEN);
-	spin_lock_irqsave(&bp->DriverLock, Flags);
-	ResetAdapter(smc);
-	spin_unlock_irqrestore(&bp->DriverLock, Flags);
-
-	return 0;		/* always return zero */
-}				// skfp_ctl_set_mac_address
-
-
-/*
- * ==============
- * = skfp_ioctl =
- * ==============
- *   
- * Overview:
- *
- * Perform IOCTL call functions here. Some are privileged operations and the
- * effective uid is checked in those cases.
- *  
- * Returns:
- *   status value
- *   0 - success
- *   other - failure
- *       
- * Arguments:
- *   dev  - pointer to device information
- *   rq - pointer to ioctl request structure
- *   cmd - ?
- *
- */
-
-
-static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	skfddi_priv *lp = &smc->os;
-	struct s_skfp_ioctl ioc;
-	int status = 0;
-
-	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
-		return -EFAULT;
-
-	switch (ioc.cmd) {
-	case SKFP_GET_STATS:	/* Get the driver statistics */
-		ioc.len = sizeof(lp->MacStat);
-		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
-				? -EFAULT : 0;
-		break;
-	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
-		if (!capable(CAP_NET_ADMIN)) {
-			status = -EPERM;
-		} else {
-			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
-		}
-		break;
-	default:
-		printk("ioctl for %s: unknown cmd: %04x\n", dev->name, ioc.cmd);
-		status = -EOPNOTSUPP;
-
-	}			// switch
-
-	return status;
-}				// skfp_ioctl
-
-
-/*
- * =====================
- * = skfp_send_pkt     =
- * =====================
- *   
- * Overview:
- *   Queues a packet for transmission and try to transmit it.
- *  
- * Returns:
- *   Condition code
- *       
- * Arguments:
- *   skb - pointer to sk_buff to queue for transmission
- *   dev - pointer to device information
- *
- * Functional Description:
- *   Here we assume that an incoming skb transmit request
- *   is contained in a single physically contiguous buffer
- *   in which the virtual address of the start of packet
- *   (skb->data) can be converted to a physical address
- *   by using pci_map_single().
- *
- *   We have an internal queue for packets we can not send 
- *   immediately. Packets in this queue can be given to the 
- *   adapter if transmit buffers are freed.
- *
- *   We can't free the skb until after it's been DMA'd
- *   out by the adapter, so we'll keep it in the driver and
- *   return it in mac_drv_tx_complete.
- *
- * Return Codes:
- *   0 - driver has queued and/or sent packet
- *       1 - caller should requeue the sk_buff for later transmission
- *
- * Assumptions:
- *   The entire packet is stored in one physically
- *   contiguous buffer which is not cached and whose
- *   32-bit physical address can be determined.
- *
- *   It's vital that this routine is NOT reentered for the
- *   same board and that the OS is not in another section of
- *   code (eg. skfp_interrupt) for the same board on a
- *   different thread.
- *
- * Side Effects:
- *   None
- */
-static netdev_tx_t skfp_send_pkt(struct sk_buff *skb,
-				       struct net_device *dev)
-{
-	struct s_smc *smc = netdev_priv(dev);
-	skfddi_priv *bp = &smc->os;
-
-	pr_debug("skfp_send_pkt\n");
-
-	/*
-	 * Verify that incoming transmit request is OK
-	 *
-	 * Note: The packet size check is consistent with other
-	 *               Linux device drivers, although the correct packet
-	 *               size should be verified before calling the
-	 *               transmit routine.
-	 */
-
-	if (!(skb->len >= FDDI_K_LLC_ZLEN && skb->len <= FDDI_K_LLC_LEN)) {
-		bp->MacStat.gen.tx_errors++;	/* bump error counter */
-		// dequeue packets from xmt queue and send them
-		netif_start_queue(dev);
-		dev_kfree_skb(skb);
-		return NETDEV_TX_OK;	/* return "success" */
-	}
-	if (bp->QueueSkb == 0) {	// return with tbusy set: queue full
-
-		netif_stop_queue(dev);
-		return NETDEV_TX_BUSY;
-	}
-	bp->QueueSkb--;
-	skb_queue_tail(&bp->SendSkbQueue, skb);
-	send_queued_packets(netdev_priv(dev));
-	if (bp->QueueSkb == 0) {
-		netif_stop_queue(dev);
-	}
-	return NETDEV_TX_OK;
-
-}				// skfp_send_pkt
-
-
-/*
- * =======================
- * = send_queued_packets =
- * =======================
- *   
- * Overview:
- *   Send packets from the driver queue as long as there are some and
- *   transmit resources are available.
- *  
- * Returns:
- *   None
- *       
- * Arguments:
- *   smc - pointer to smc (adapter) structure
- *
- * Functional Description:
- *   Take a packet from queue if there is any. If not, then we are done.
- *   Check if there are resources to send the packet. If not, requeue it
- *   and exit. 
- *   Set packet descriptor flags and give packet to adapter.
- *   Check if any send resources can be freed (we do not use the
- *   transmit complete interrupt).
- */
-static void send_queued_packets(struct s_smc *smc)
-{
-	skfddi_priv *bp = &smc->os;
-	struct sk_buff *skb;
-	unsigned char fc;
-	int queue;
-	struct s_smt_fp_txd *txd;	// Current TxD.
-	dma_addr_t dma_address;
-	unsigned long Flags;
-
-	int frame_status;	// HWM tx frame status.
-
-	pr_debug("send queued packets\n");
-	for (;;) {
-		// send first buffer from queue
-		skb = skb_dequeue(&bp->SendSkbQueue);
-
-		if (!skb) {
-			pr_debug("queue empty\n");
-			return;
-		}		// queue empty !
-
-		spin_lock_irqsave(&bp->DriverLock, Flags);
-		fc = skb->data[0];
-		queue = (fc & FC_SYNC_BIT) ? QUEUE_S : QUEUE_A0;
-#ifdef ESS
-		// Check if the frame may/must be sent as a synchronous frame.
-
-		if ((fc & ~(FC_SYNC_BIT | FC_LLC_PRIOR)) == FC_ASYNC_LLC) {
-			// It's an LLC frame.
-			if (!smc->ess.sync_bw_available)
-				fc &= ~FC_SYNC_BIT; // No bandwidth available.
-
-			else {	// Bandwidth is available.
-
-				if (smc->mib.fddiESSSynchTxMode) {
-					// Send as sync. frame.
-					fc |= FC_SYNC_BIT;
-				}
-			}
-		}
-#endif				// ESS
-		frame_status = hwm_tx_init(smc, fc, 1, skb->len, queue);
-
-		if ((frame_status & (LOC_TX | LAN_TX)) == 0) {
-			// Unable to send the frame.
-
-			if ((frame_status & RING_DOWN) != 0) {
-				// Ring is down.
-				pr_debug("Tx attempt while ring down.\n");
-			} else if ((frame_status & OUT_OF_TXD) != 0) {
-				pr_debug("%s: out of TXDs.\n", bp->dev->name);
-			} else {
-				pr_debug("%s: out of transmit resources",
-					bp->dev->name);
-			}
-
-			// Note: We will retry the operation as soon as
-			// transmit resources become available.
-			skb_queue_head(&bp->SendSkbQueue, skb);
-			spin_unlock_irqrestore(&bp->DriverLock, Flags);
-			return;	// Packet has been queued.
-
-		}		// if (unable to send frame)
-
-		bp->QueueSkb++;	// one packet less in local queue
-
-		// source address in packet ?
-		CheckSourceAddress(skb->data, smc->hw.fddi_canon_addr.a);
-
-		txd = (struct s_smt_fp_txd *) HWM_GET_CURR_TXD(smc, queue);
-
-		dma_address = pci_map_single(&bp->pdev, skb->data,
-					     skb->len, PCI_DMA_TODEVICE);
-		if (frame_status & LAN_TX) {
-			txd->txd_os.skb = skb;			// save skb
-			txd->txd_os.dma_addr = dma_address;	// save dma mapping
-		}
-		hwm_tx_frag(smc, skb->data, dma_address, skb->len,
-                      frame_status | FIRST_FRAG | LAST_FRAG | EN_IRQ_EOF);
-
-		if (!(frame_status & LAN_TX)) {		// local only frame
-			pci_unmap_single(&bp->pdev, dma_address,
-					 skb->len, PCI_DMA_TODEVICE);
-			dev_kfree_skb_irq(skb);
-		}
-		spin_unlock_irqrestore(&bp->DriverLock, Flags);
-	}			// for
-
-	return;			// never reached
-
-}				// send_queued_packets
-
-
-/************************
- * 
- * CheckSourceAddress
- *
- * Verify if the source address is set. Insert it if necessary.
- *
- ************************/
-static void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr)
-{
-	unsigned char SRBit;
-
-	if ((((unsigned long) frame[1 + 6]) & ~0x01) != 0) // source routing bit
-
-		return;
-	if ((unsigned short) frame[1 + 10] != 0)
-		return;
-	SRBit = frame[1 + 6] & 0x01;
-	memcpy(&frame[1 + 6], hw_addr, 6);
-	frame[8] |= SRBit;
-}				// CheckSourceAddress
-
-
-/************************
- *
- *	ResetAdapter
- *
- *	Reset the adapter and bring it back to operational mode.
- * Args
- *	smc - A pointer to the SMT context struct.
- * Out
- *	Nothing.
- *
- ************************/
-static void ResetAdapter(struct s_smc *smc)
-{
-
-	pr_debug("[fddi: ResetAdapter]\n");
-
-	// Stop the adapter.
-
-	card_stop(smc);		// Stop all activity.
-
-	// Clear the transmit and receive descriptor queues.
-	mac_drv_clear_tx_queue(smc);
-	mac_drv_clear_rx_queue(smc);
-
-	// Restart the adapter.
-
-	smt_reset_defaults(smc, 1);	// Initialize the SMT module.
-
-	init_smt(smc, (smc->os.dev)->dev_addr);	// Initialize the hardware.
-
-	smt_online(smc, 1);	// Insert into the ring again.
-	STI_FBI();
-
-	// Restore original receive mode (multicasts, promiscuous, etc.).
-	skfp_ctl_set_multicast_list_wo_lock(smc->os.dev);
-}				// ResetAdapter
-
-
-//--------------- functions called by hardware module ----------------
-
-/************************
- *
- *	llc_restart_tx
- *
- *	The hardware driver calls this routine when the transmit complete
- *	interrupt bits (end of frame) for the synchronous or asynchronous
- *	queue is set.
- *
- * NOTE The hardware driver calls this function also if no packets are queued.
- *	The routine must be able to handle this case.
- * Args
- *	smc - A pointer to the SMT context struct.
- * Out
- *	Nothing.
- *
- ************************/
-void llc_restart_tx(struct s_smc *smc)
-{
-	skfddi_priv *bp = &smc->os;
-
-	pr_debug("[llc_restart_tx]\n");
-
-	// Try to send queued packets
-	spin_unlock(&bp->DriverLock);
-	send_queued_packets(smc);
-	spin_lock(&bp->DriverLock);
-	netif_start_queue(bp->dev);// system may send again if it was blocked
-
-}				// llc_restart_tx
-
-
-/************************
- *
- *	mac_drv_get_space
- *
- *	The hardware module calls this function to allocate the memory
- *	for the SMT MBufs if the define MB_OUTSIDE_SMC is specified.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	size - Size of memory in bytes to allocate.
- * Out
- *	!= 0	A pointer to the virtual address of the allocated memory.
- *	== 0	Allocation error.
- *
- ************************/
-void *mac_drv_get_space(struct s_smc *smc, unsigned int size)
-{
-	void *virt;
-
-	pr_debug("mac_drv_get_space (%d bytes), ", size);
-	virt = (void *) (smc->os.SharedMemAddr + smc->os.SharedMemHeap);
-
-	if ((smc->os.SharedMemHeap + size) > smc->os.SharedMemSize) {
-		printk("Unexpected SMT memory size requested: %d\n", size);
-		return NULL;
-	}
-	smc->os.SharedMemHeap += size;	// Move heap pointer.
-
-	pr_debug("mac_drv_get_space end\n");
-	pr_debug("virt addr: %lx\n", (ulong) virt);
-	pr_debug("bus  addr: %lx\n", (ulong)
-	       (smc->os.SharedMemDMA +
-		((char *) virt - (char *)smc->os.SharedMemAddr)));
-	return virt;
-}				// mac_drv_get_space
-
-
-/************************
- *
- *	mac_drv_get_desc_mem
- *
- *	This function is called by the hardware dependent module.
- *	It allocates the memory for the RxD and TxD descriptors.
- *
- *	This memory must be non-cached, non-movable and non-swappable.
- *	This memory should start at a physical page boundary.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	size - Size of memory in bytes to allocate.
- * Out
- *	!= 0	A pointer to the virtual address of the allocated memory.
- *	== 0	Allocation error.
- *
- ************************/
-void *mac_drv_get_desc_mem(struct s_smc *smc, unsigned int size)
-{
-
-	char *virt;
-
-	pr_debug("mac_drv_get_desc_mem\n");
-
-	// Descriptor memory must be aligned on 16-byte boundary.
-
-	virt = mac_drv_get_space(smc, size);
-
-	size = (u_int) (16 - (((unsigned long) virt) & 15UL));
-	size = size % 16;
-
-	pr_debug("Allocate %u bytes alignment gap ", size);
-	pr_debug("for descriptor memory.\n");
-
-	if (!mac_drv_get_space(smc, size)) {
-		printk("fddi: Unable to align descriptor memory.\n");
-		return NULL;
-	}
-	return virt + size;
-}				// mac_drv_get_desc_mem
-
-
-/************************
- *
- *	mac_drv_virt2phys
- *
- *	Get the physical address of a given virtual address.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	virt - A (virtual) pointer into our 'shared' memory area.
- * Out
- *	Physical address of the given virtual address.
- *
- ************************/
-unsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt)
-{
-	return smc->os.SharedMemDMA +
-		((char *) virt - (char *)smc->os.SharedMemAddr);
-}				// mac_drv_virt2phys
-
-
-/************************
- *
- *	dma_master
- *
- *	The HWM calls this function, when the driver leads through a DMA
- *	transfer. If the OS-specific module must prepare the system hardware
- *	for the DMA transfer, it should do it in this function.
- *
- *	The hardware module calls this dma_master if it wants to send an SMT
- *	frame.  This means that the virt address passed in here is part of
- *      the 'shared' memory area.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	virt - The virtual address of the data.
- *
- *	len - The length in bytes of the data.
- *
- *	flag - Indicates the transmit direction and the buffer type:
- *		DMA_RD	(0x01)	system RAM ==> adapter buffer memory
- *		DMA_WR	(0x02)	adapter buffer memory ==> system RAM
- *		SMT_BUF (0x80)	SMT buffer
- *
- *	>> NOTE: SMT_BUF and DMA_RD are always set for PCI. <<
- * Out
- *	Returns the pyhsical address for the DMA transfer.
- *
- ************************/
-u_long dma_master(struct s_smc * smc, void *virt, int len, int flag)
-{
-	return smc->os.SharedMemDMA +
-		((char *) virt - (char *)smc->os.SharedMemAddr);
-}				// dma_master
-
-
-/************************
- *
- *	dma_complete
- *
- *	The hardware module calls this routine when it has completed a DMA
- *	transfer. If the operating system dependent module has set up the DMA
- *	channel via dma_master() (e.g. Windows NT or AIX) it should clean up
- *	the DMA channel.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	descr - A pointer to a TxD or RxD, respectively.
- *
- *	flag - Indicates the DMA transfer direction / SMT buffer:
- *		DMA_RD	(0x01)	system RAM ==> adapter buffer memory
- *		DMA_WR	(0x02)	adapter buffer memory ==> system RAM
- *		SMT_BUF (0x80)	SMT buffer (managed by HWM)
- * Out
- *	Nothing.
- *
- ************************/
-void dma_complete(struct s_smc *smc, volatile union s_fp_descr *descr, int flag)
-{
-	/* For TX buffers, there are two cases.  If it is an SMT transmit
-	 * buffer, there is nothing to do since we use consistent memory
-	 * for the 'shared' memory area.  The other case is for normal
-	 * transmit packets given to us by the networking stack, and in
-	 * that case we cleanup the PCI DMA mapping in mac_drv_tx_complete
-	 * below.
-	 *
-	 * For RX buffers, we have to unmap dynamic PCI DMA mappings here
-	 * because the hardware module is about to potentially look at
-	 * the contents of the buffer.  If we did not call the PCI DMA
-	 * unmap first, the hardware module could read inconsistent data.
-	 */
-	if (flag & DMA_WR) {
-		skfddi_priv *bp = &smc->os;
-		volatile struct s_smt_fp_rxd *r = &descr->r;
-
-		/* If SKB is NULL, we used the local buffer. */
-		if (r->rxd_os.skb && r->rxd_os.dma_addr) {
-			int MaxFrameSize = bp->MaxFrameSize;
-
-			pci_unmap_single(&bp->pdev, r->rxd_os.dma_addr,
-					 MaxFrameSize, PCI_DMA_FROMDEVICE);
-			r->rxd_os.dma_addr = 0;
-		}
-	}
-}				// dma_complete
-
-
-/************************
- *
- *	mac_drv_tx_complete
- *
- *	Transmit of a packet is complete. Release the tx staging buffer.
- *
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	txd - A pointer to the last TxD which is used by the frame.
- * Out
- *	Returns nothing.
- *
- ************************/
-void mac_drv_tx_complete(struct s_smc *smc, volatile struct s_smt_fp_txd *txd)
-{
-	struct sk_buff *skb;
-
-	pr_debug("entering mac_drv_tx_complete\n");
-	// Check if this TxD points to a skb
-
-	if (!(skb = txd->txd_os.skb)) {
-		pr_debug("TXD with no skb assigned.\n");
-		return;
-	}
-	txd->txd_os.skb = NULL;
-
-	// release the DMA mapping
-	pci_unmap_single(&smc->os.pdev, txd->txd_os.dma_addr,
-			 skb->len, PCI_DMA_TODEVICE);
-	txd->txd_os.dma_addr = 0;
-
-	smc->os.MacStat.gen.tx_packets++;	// Count transmitted packets.
-	smc->os.MacStat.gen.tx_bytes+=skb->len;	// Count bytes
-
-	// free the skb
-	dev_kfree_skb_irq(skb);
-
-	pr_debug("leaving mac_drv_tx_complete\n");
-}				// mac_drv_tx_complete
-
-
-/************************
- *
- * dump packets to logfile
- *
- ************************/
-#ifdef DUMPPACKETS
-void dump_data(unsigned char *Data, int length)
-{
-	int i, j;
-	unsigned char s[255], sh[10];
-	if (length > 64) {
-		length = 64;
-	}
-	printk(KERN_INFO "---Packet start---\n");
-	for (i = 0, j = 0; i < length / 8; i++, j += 8)
-		printk(KERN_INFO "%02x %02x %02x %02x %02x %02x %02x %02x\n",
-		       Data[j + 0], Data[j + 1], Data[j + 2], Data[j + 3],
-		       Data[j + 4], Data[j + 5], Data[j + 6], Data[j + 7]);
-	strcpy(s, "");
-	for (i = 0; i < length % 8; i++) {
-		sprintf(sh, "%02x ", Data[j + i]);
-		strcat(s, sh);
-	}
-	printk(KERN_INFO "%s\n", s);
-	printk(KERN_INFO "------------------\n");
-}				// dump_data
-#else
-#define dump_data(data,len)
-#endif				// DUMPPACKETS
-
-/************************
- *
- *	mac_drv_rx_complete
- *
- *	The hardware module calls this function if an LLC frame is received
- *	in a receive buffer. Also the SMT, NSA, and directed beacon frames
- *	from the network will be passed to the LLC layer by this function
- *	if passing is enabled.
- *
- *	mac_drv_rx_complete forwards the frame to the LLC layer if it should
- *	be received. It also fills the RxD ring with new receive buffers if
- *	some can be queued.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	rxd - A pointer to the first RxD which is used by the receive frame.
- *
- *	frag_count - Count of RxDs used by the received frame.
- *
- *	len - Frame length.
- * Out
- *	Nothing.
- *
- ************************/
-void mac_drv_rx_complete(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-			 int frag_count, int len)
-{
-	skfddi_priv *bp = &smc->os;
-	struct sk_buff *skb;
-	unsigned char *virt, *cp;
-	unsigned short ri;
-	u_int RifLength;
-
-	pr_debug("entering mac_drv_rx_complete (len=%d)\n", len);
-	if (frag_count != 1) {	// This is not allowed to happen.
-
-		printk("fddi: Multi-fragment receive!\n");
-		goto RequeueRxd;	// Re-use the given RXD(s).
-
-	}
-	skb = rxd->rxd_os.skb;
-	if (!skb) {
-		pr_debug("No skb in rxd\n");
-		smc->os.MacStat.gen.rx_errors++;
-		goto RequeueRxd;
-	}
-	virt = skb->data;
-
-	// The DMA mapping was released in dma_complete above.
-
-	dump_data(skb->data, len);
-
-	/*
-	 * FDDI Frame format:
-	 * +-------+-------+-------+------------+--------+------------+
-	 * | FC[1] | DA[6] | SA[6] | RIF[0..18] | LLC[3] | Data[0..n] |
-	 * +-------+-------+-------+------------+--------+------------+
-	 *
-	 * FC = Frame Control
-	 * DA = Destination Address
-	 * SA = Source Address
-	 * RIF = Routing Information Field
-	 * LLC = Logical Link Control
-	 */
-
-	// Remove Routing Information Field (RIF), if present.
-
-	if ((virt[1 + 6] & FDDI_RII) == 0)
-		RifLength = 0;
-	else {
-		int n;
-// goos: RIF removal has still to be tested
-		pr_debug("RIF found\n");
-		// Get RIF length from Routing Control (RC) field.
-		cp = virt + FDDI_MAC_HDR_LEN;	// Point behind MAC header.
-
-		ri = ntohs(*((__be16 *) cp));
-		RifLength = ri & FDDI_RCF_LEN_MASK;
-		if (len < (int) (FDDI_MAC_HDR_LEN + RifLength)) {
-			printk("fddi: Invalid RIF.\n");
-			goto RequeueRxd;	// Discard the frame.
-
-		}
-		virt[1 + 6] &= ~FDDI_RII;	// Clear RII bit.
-		// regions overlap
-
-		virt = cp + RifLength;
-		for (n = FDDI_MAC_HDR_LEN; n; n--)
-			*--virt = *--cp;
-		// adjust sbd->data pointer
-		skb_pull(skb, RifLength);
-		len -= RifLength;
-		RifLength = 0;
-	}
-
-	// Count statistics.
-	smc->os.MacStat.gen.rx_packets++;	// Count indicated receive
-						// packets.
-	smc->os.MacStat.gen.rx_bytes+=len;	// Count bytes.
-
-	// virt points to header again
-	if (virt[1] & 0x01) {	// Check group (multicast) bit.
-
-		smc->os.MacStat.gen.multicast++;
-	}
-
-	// deliver frame to system
-	rxd->rxd_os.skb = NULL;
-	skb_trim(skb, len);
-	skb->protocol = fddi_type_trans(skb, bp->dev);
-
-	netif_rx(skb);
-
-	HWM_RX_CHECK(smc, RX_LOW_WATERMARK);
-	return;
-
-      RequeueRxd:
-	pr_debug("Rx: re-queue RXD.\n");
-	mac_drv_requeue_rxd(smc, rxd, frag_count);
-	smc->os.MacStat.gen.rx_errors++;	// Count receive packets
-						// not indicated.
-
-}				// mac_drv_rx_complete
-
-
-/************************
- *
- *	mac_drv_requeue_rxd
- *
- *	The hardware module calls this function to request the OS-specific
- *	module to queue the receive buffer(s) represented by the pointer
- *	to the RxD and the frag_count into the receive queue again. This
- *	buffer was filled with an invalid frame or an SMT frame.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	rxd - A pointer to the first RxD which is used by the receive frame.
- *
- *	frag_count - Count of RxDs used by the received frame.
- * Out
- *	Nothing.
- *
- ************************/
-void mac_drv_requeue_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-			 int frag_count)
-{
-	volatile struct s_smt_fp_rxd *next_rxd;
-	volatile struct s_smt_fp_rxd *src_rxd;
-	struct sk_buff *skb;
-	int MaxFrameSize;
-	unsigned char *v_addr;
-	dma_addr_t b_addr;
-
-	if (frag_count != 1)	// This is not allowed to happen.
-
-		printk("fddi: Multi-fragment requeue!\n");
-
-	MaxFrameSize = smc->os.MaxFrameSize;
-	src_rxd = rxd;
-	for (; frag_count > 0; frag_count--) {
-		next_rxd = src_rxd->rxd_next;
-		rxd = HWM_GET_CURR_RXD(smc);
-
-		skb = src_rxd->rxd_os.skb;
-		if (skb == NULL) {	// this should not happen
-
-			pr_debug("Requeue with no skb in rxd!\n");
-			skb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);
-			if (skb) {
-				// we got a skb
-				rxd->rxd_os.skb = skb;
-				skb_reserve(skb, 3);
-				skb_put(skb, MaxFrameSize);
-				v_addr = skb->data;
-				b_addr = pci_map_single(&smc->os.pdev,
-							v_addr,
-							MaxFrameSize,
-							PCI_DMA_FROMDEVICE);
-				rxd->rxd_os.dma_addr = b_addr;
-			} else {
-				// no skb available, use local buffer
-				pr_debug("Queueing invalid buffer!\n");
-				rxd->rxd_os.skb = NULL;
-				v_addr = smc->os.LocalRxBuffer;
-				b_addr = smc->os.LocalRxBufferDMA;
-			}
-		} else {
-			// we use skb from old rxd
-			rxd->rxd_os.skb = skb;
-			v_addr = skb->data;
-			b_addr = pci_map_single(&smc->os.pdev,
-						v_addr,
-						MaxFrameSize,
-						PCI_DMA_FROMDEVICE);
-			rxd->rxd_os.dma_addr = b_addr;
-		}
-		hwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,
-			    FIRST_FRAG | LAST_FRAG);
-
-		src_rxd = next_rxd;
-	}
-}				// mac_drv_requeue_rxd
-
-
-/************************
- *
- *	mac_drv_fill_rxd
- *
- *	The hardware module calls this function at initialization time
- *	to fill the RxD ring with receive buffers. It is also called by
- *	mac_drv_rx_complete if rx_free is large enough to queue some new
- *	receive buffers into the RxD ring. mac_drv_fill_rxd queues new
- *	receive buffers as long as enough RxDs and receive buffers are
- *	available.
- * Args
- *	smc - A pointer to the SMT context struct.
- * Out
- *	Nothing.
- *
- ************************/
-void mac_drv_fill_rxd(struct s_smc *smc)
-{
-	int MaxFrameSize;
-	unsigned char *v_addr;
-	unsigned long b_addr;
-	struct sk_buff *skb;
-	volatile struct s_smt_fp_rxd *rxd;
-
-	pr_debug("entering mac_drv_fill_rxd\n");
-
-	// Walk through the list of free receive buffers, passing receive
-	// buffers to the HWM as long as RXDs are available.
-
-	MaxFrameSize = smc->os.MaxFrameSize;
-	// Check if there is any RXD left.
-	while (HWM_GET_RX_FREE(smc) > 0) {
-		pr_debug(".\n");
-
-		rxd = HWM_GET_CURR_RXD(smc);
-		skb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);
-		if (skb) {
-			// we got a skb
-			skb_reserve(skb, 3);
-			skb_put(skb, MaxFrameSize);
-			v_addr = skb->data;
-			b_addr = pci_map_single(&smc->os.pdev,
-						v_addr,
-						MaxFrameSize,
-						PCI_DMA_FROMDEVICE);
-			rxd->rxd_os.dma_addr = b_addr;
-		} else {
-			// no skb available, use local buffer
-			// System has run out of buffer memory, but we want to
-			// keep the receiver running in hope of better times.
-			// Multiple descriptors may point to this local buffer,
-			// so data in it must be considered invalid.
-			pr_debug("Queueing invalid buffer!\n");
-			v_addr = smc->os.LocalRxBuffer;
-			b_addr = smc->os.LocalRxBufferDMA;
-		}
-
-		rxd->rxd_os.skb = skb;
-
-		// Pass receive buffer to HWM.
-		hwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,
-			    FIRST_FRAG | LAST_FRAG);
-	}
-	pr_debug("leaving mac_drv_fill_rxd\n");
-}				// mac_drv_fill_rxd
-
-
-/************************
- *
- *	mac_drv_clear_rxd
- *
- *	The hardware module calls this function to release unused
- *	receive buffers.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	rxd - A pointer to the first RxD which is used by the receive buffer.
- *
- *	frag_count - Count of RxDs used by the receive buffer.
- * Out
- *	Nothing.
- *
- ************************/
-void mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
-		       int frag_count)
-{
-
-	struct sk_buff *skb;
-
-	pr_debug("entering mac_drv_clear_rxd\n");
-
-	if (frag_count != 1)	// This is not allowed to happen.
-
-		printk("fddi: Multi-fragment clear!\n");
-
-	for (; frag_count > 0; frag_count--) {
-		skb = rxd->rxd_os.skb;
-		if (skb != NULL) {
-			skfddi_priv *bp = &smc->os;
-			int MaxFrameSize = bp->MaxFrameSize;
-
-			pci_unmap_single(&bp->pdev, rxd->rxd_os.dma_addr,
-					 MaxFrameSize, PCI_DMA_FROMDEVICE);
-
-			dev_kfree_skb(skb);
-			rxd->rxd_os.skb = NULL;
-		}
-		rxd = rxd->rxd_next;	// Next RXD.
-
-	}
-}				// mac_drv_clear_rxd
-
-
-/************************
- *
- *	mac_drv_rx_init
- *
- *	The hardware module calls this routine when an SMT or NSA frame of the
- *	local SMT should be delivered to the LLC layer.
- *
- *	It is necessary to have this function, because there is no other way to
- *	copy the contents of SMT MBufs into receive buffers.
- *
- *	mac_drv_rx_init allocates the required target memory for this frame,
- *	and receives the frame fragment by fragment by calling mac_drv_rx_frag.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	len - The length (in bytes) of the received frame (FC, DA, SA, Data).
- *
- *	fc - The Frame Control field of the received frame.
- *
- *	look_ahead - A pointer to the lookahead data buffer (may be NULL).
- *
- *	la_len - The length of the lookahead data stored in the lookahead
- *	buffer (may be zero).
- * Out
- *	Always returns zero (0).
- *
- ************************/
-int mac_drv_rx_init(struct s_smc *smc, int len, int fc,
-		    char *look_ahead, int la_len)
-{
-	struct sk_buff *skb;
-
-	pr_debug("entering mac_drv_rx_init(len=%d)\n", len);
-
-	// "Received" a SMT or NSA frame of the local SMT.
-
-	if (len != la_len || len < FDDI_MAC_HDR_LEN || !look_ahead) {
-		pr_debug("fddi: Discard invalid local SMT frame\n");
-		pr_debug("  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.\n",
-		       len, la_len, (unsigned long) look_ahead);
-		return 0;
-	}
-	skb = alloc_skb(len + 3, GFP_ATOMIC);
-	if (!skb) {
-		pr_debug("fddi: Local SMT: skb memory exhausted.\n");
-		return 0;
-	}
-	skb_reserve(skb, 3);
-	skb_put(skb, len);
-	skb_copy_to_linear_data(skb, look_ahead, len);
-
-	// deliver frame to system
-	skb->protocol = fddi_type_trans(skb, smc->os.dev);
-	netif_rx(skb);
-
-	return 0;
-}				// mac_drv_rx_init
-
-
-/************************
- *
- *	smt_timer_poll
- *
- *	This routine is called periodically by the SMT module to clean up the
- *	driver.
- *
- *	Return any queued frames back to the upper protocol layers if the ring
- *	is down.
- * Args
- *	smc - A pointer to the SMT context struct.
- * Out
- *	Nothing.
- *
- ************************/
-void smt_timer_poll(struct s_smc *smc)
-{
-}				// smt_timer_poll
-
-
-/************************
- *
- *	ring_status_indication
- *
- *	This function indicates a change of the ring state.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	status - The current ring status.
- * Out
- *	Nothing.
- *
- ************************/
-void ring_status_indication(struct s_smc *smc, u_long status)
-{
-	pr_debug("ring_status_indication( ");
-	if (status & RS_RES15)
-		pr_debug("RS_RES15 ");
-	if (status & RS_HARDERROR)
-		pr_debug("RS_HARDERROR ");
-	if (status & RS_SOFTERROR)
-		pr_debug("RS_SOFTERROR ");
-	if (status & RS_BEACON)
-		pr_debug("RS_BEACON ");
-	if (status & RS_PATHTEST)
-		pr_debug("RS_PATHTEST ");
-	if (status & RS_SELFTEST)
-		pr_debug("RS_SELFTEST ");
-	if (status & RS_RES9)
-		pr_debug("RS_RES9 ");
-	if (status & RS_DISCONNECT)
-		pr_debug("RS_DISCONNECT ");
-	if (status & RS_RES7)
-		pr_debug("RS_RES7 ");
-	if (status & RS_DUPADDR)
-		pr_debug("RS_DUPADDR ");
-	if (status & RS_NORINGOP)
-		pr_debug("RS_NORINGOP ");
-	if (status & RS_VERSION)
-		pr_debug("RS_VERSION ");
-	if (status & RS_STUCKBYPASSS)
-		pr_debug("RS_STUCKBYPASSS ");
-	if (status & RS_EVENT)
-		pr_debug("RS_EVENT ");
-	if (status & RS_RINGOPCHANGE)
-		pr_debug("RS_RINGOPCHANGE ");
-	if (status & RS_RES0)
-		pr_debug("RS_RES0 ");
-	pr_debug("]\n");
-}				// ring_status_indication
-
-
-/************************
- *
- *	smt_get_time
- *
- *	Gets the current time from the system.
- * Args
- *	None.
- * Out
- *	The current time in TICKS_PER_SECOND.
- *
- *	TICKS_PER_SECOND has the unit 'count of timer ticks per second'. It is
- *	defined in "targetos.h". The definition of TICKS_PER_SECOND must comply
- *	to the time returned by smt_get_time().
- *
- ************************/
-unsigned long smt_get_time(void)
-{
-	return jiffies;
-}				// smt_get_time
-
-
-/************************
- *
- *	smt_stat_counter
- *
- *	Status counter update (ring_op, fifo full).
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	stat -	= 0: A ring operational change occurred.
- *		= 1: The FORMAC FIFO buffer is full / FIFO overflow.
- * Out
- *	Nothing.
- *
- ************************/
-void smt_stat_counter(struct s_smc *smc, int stat)
-{
-//      BOOLEAN RingIsUp ;
-
-	pr_debug("smt_stat_counter\n");
-	switch (stat) {
-	case 0:
-		pr_debug("Ring operational change.\n");
-		break;
-	case 1:
-		pr_debug("Receive fifo overflow.\n");
-		smc->os.MacStat.gen.rx_errors++;
-		break;
-	default:
-		pr_debug("Unknown status (%d).\n", stat);
-		break;
-	}
-}				// smt_stat_counter
-
-
-/************************
- *
- *	cfm_state_change
- *
- *	Sets CFM state in custom statistics.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	c_state - Possible values are:
- *
- *		EC0_OUT, EC1_IN, EC2_TRACE, EC3_LEAVE, EC4_PATH_TEST,
- *		EC5_INSERT, EC6_CHECK, EC7_DEINSERT
- * Out
- *	Nothing.
- *
- ************************/
-void cfm_state_change(struct s_smc *smc, int c_state)
-{
-#ifdef DRIVERDEBUG
-	char *s;
-
-	switch (c_state) {
-	case SC0_ISOLATED:
-		s = "SC0_ISOLATED";
-		break;
-	case SC1_WRAP_A:
-		s = "SC1_WRAP_A";
-		break;
-	case SC2_WRAP_B:
-		s = "SC2_WRAP_B";
-		break;
-	case SC4_THRU_A:
-		s = "SC4_THRU_A";
-		break;
-	case SC5_THRU_B:
-		s = "SC5_THRU_B";
-		break;
-	case SC7_WRAP_S:
-		s = "SC7_WRAP_S";
-		break;
-	case SC9_C_WRAP_A:
-		s = "SC9_C_WRAP_A";
-		break;
-	case SC10_C_WRAP_B:
-		s = "SC10_C_WRAP_B";
-		break;
-	case SC11_C_WRAP_S:
-		s = "SC11_C_WRAP_S";
-		break;
-	default:
-		pr_debug("cfm_state_change: unknown %d\n", c_state);
-		return;
-	}
-	pr_debug("cfm_state_change: %s\n", s);
-#endif				// DRIVERDEBUG
-}				// cfm_state_change
-
-
-/************************
- *
- *	ecm_state_change
- *
- *	Sets ECM state in custom statistics.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	e_state - Possible values are:
- *
- *		SC0_ISOLATED, SC1_WRAP_A (5), SC2_WRAP_B (6), SC4_THRU_A (12),
- *		SC5_THRU_B (7), SC7_WRAP_S (8)
- * Out
- *	Nothing.
- *
- ************************/
-void ecm_state_change(struct s_smc *smc, int e_state)
-{
-#ifdef DRIVERDEBUG
-	char *s;
-
-	switch (e_state) {
-	case EC0_OUT:
-		s = "EC0_OUT";
-		break;
-	case EC1_IN:
-		s = "EC1_IN";
-		break;
-	case EC2_TRACE:
-		s = "EC2_TRACE";
-		break;
-	case EC3_LEAVE:
-		s = "EC3_LEAVE";
-		break;
-	case EC4_PATH_TEST:
-		s = "EC4_PATH_TEST";
-		break;
-	case EC5_INSERT:
-		s = "EC5_INSERT";
-		break;
-	case EC6_CHECK:
-		s = "EC6_CHECK";
-		break;
-	case EC7_DEINSERT:
-		s = "EC7_DEINSERT";
-		break;
-	default:
-		s = "unknown";
-		break;
-	}
-	pr_debug("ecm_state_change: %s\n", s);
-#endif				//DRIVERDEBUG
-}				// ecm_state_change
-
-
-/************************
- *
- *	rmt_state_change
- *
- *	Sets RMT state in custom statistics.
- * Args
- *	smc - A pointer to the SMT context struct.
- *
- *	r_state - Possible values are:
- *
- *		RM0_ISOLATED, RM1_NON_OP, RM2_RING_OP, RM3_DETECT,
- *		RM4_NON_OP_DUP, RM5_RING_OP_DUP, RM6_DIRECTED, RM7_TRACE
- * Out
- *	Nothing.
- *
- ************************/
-void rmt_state_change(struct s_smc *smc, int r_state)
-{
-#ifdef DRIVERDEBUG
-	char *s;
-
-	switch (r_state) {
-	case RM0_ISOLATED:
-		s = "RM0_ISOLATED";
-		break;
-	case RM1_NON_OP:
-		s = "RM1_NON_OP - not operational";
-		break;
-	case RM2_RING_OP:
-		s = "RM2_RING_OP - ring operational";
-		break;
-	case RM3_DETECT:
-		s = "RM3_DETECT - detect dupl addresses";
-		break;
-	case RM4_NON_OP_DUP:
-		s = "RM4_NON_OP_DUP - dupl. addr detected";
-		break;
-	case RM5_RING_OP_DUP:
-		s = "RM5_RING_OP_DUP - ring oper. with dupl. addr";
-		break;
-	case RM6_DIRECTED:
-		s = "RM6_DIRECTED - sending directed beacons";
-		break;
-	case RM7_TRACE:
-		s = "RM7_TRACE - trace initiated";
-		break;
-	default:
-		s = "unknown";
-		break;
-	}
-	pr_debug("[rmt_state_change: %s]\n", s);
-#endif				// DRIVERDEBUG
-}				// rmt_state_change
-
-
-/************************
- *
- *	drv_reset_indication
- *
- *	This function is called by the SMT when it has detected a severe
- *	hardware problem. The driver should perform a reset on the adapter
- *	as soon as possible, but not from within this function.
- * Args
- *	smc - A pointer to the SMT context struct.
- * Out
- *	Nothing.
- *
- ************************/
-void drv_reset_indication(struct s_smc *smc)
-{
-	pr_debug("entering drv_reset_indication\n");
-
-	smc->os.ResetRequested = TRUE;	// Set flag.
-
-}				// drv_reset_indication
-
-static struct pci_driver skfddi_pci_driver = {
-	.name		= "skfddi",
-	.id_table	= skfddi_pci_tbl,
-	.probe		= skfp_init_one,
-	.remove		= __devexit_p(skfp_remove_one),
-};
-
-static int __init skfd_init(void)
-{
-	return pci_register_driver(&skfddi_pci_driver);
-}
-
-static void __exit skfd_exit(void)
-{
-	pci_unregister_driver(&skfddi_pci_driver);
-}
-
-module_init(skfd_init);
-module_exit(skfd_exit);
diff -urN flo-ElementalX-5.00/drivers/net/wireless/bcmdhd/wl_android.c flo-ElementalX-5.00-patched/drivers/net/wireless/bcmdhd/wl_android.c
--- flo-ElementalX-5.00/drivers/net/wireless/bcmdhd/wl_android.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/net/wireless/bcmdhd/wl_android.c	2016-05-10 02:52:00.000000000 +0000
@@ -447,10 +447,6 @@
 		ret = -EINVAL;
 		goto exit;
 	}
-	if (!capable(CAP_NET_ADMIN)) {
-		ret = -EPERM;
-		goto exit;
-	}
 	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
 		ret = -EFAULT;
 		goto exit;
diff -urN flo-ElementalX-5.00/drivers/net/wireless/rtlwifi/debug.c flo-ElementalX-5.00-patched/drivers/net/wireless/rtlwifi/debug.c
--- flo-ElementalX-5.00/drivers/net/wireless/rtlwifi/debug.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/net/wireless/rtlwifi/debug.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,50 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2009-2012  Realtek Corporation.
- *
- * Tmis program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * Tmis program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * tmis program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- * Tme full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *****************************************************************************/
-
-#include "wifi.h"
-
-#include <linux/moduleparam.h>
-
-void rtl_dbgp_flag_init(struct ieee80211_hw *hw)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 i;
-
-	rtlpriv->dbg.global_debugcomponents =
-	    COMP_ERR | COMP_FW | COMP_INIT | COMP_RECV | COMP_SEND |
-	    COMP_MLME | COMP_SCAN | COMP_INTR | COMP_LED | COMP_SEC |
-	    COMP_BEACON | COMP_RATE | COMP_RXDESC | COMP_DIG | COMP_TXAGC |
-	    COMP_POWER | COMP_POWER_TRACKING | COMP_BB_POWERSAVING | COMP_SWAS |
-	    COMP_RF | COMP_TURBO | COMP_RATR | COMP_CMD |
-	    COMP_EFUSE | COMP_QOS | COMP_MAC80211 | COMP_REGD | COMP_CHAN;
-
-	for (i = 0; i < DBGP_TYPE_MAX; i++)
-		rtlpriv->dbg.dbgp_type[i] = 0;
-
-	/*Init Debug flag enable condition */
-}
diff -urN flo-ElementalX-5.00/drivers/power/bq27541_battery.c flo-ElementalX-5.00-patched/drivers/power/bq27541_battery.c
--- flo-ElementalX-5.00/drivers/power/bq27541_battery.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/power/bq27541_battery.c	2016-06-01 17:44:25.000000000 +0000
@@ -188,13 +188,9 @@
 	        usb_on = 0;
 	}
 	else if(bq27541_battery_cable_status  == USB_Cable) {
-		if (force_fast_charge == 1) {
-			ac_on = 1;
-			usb_on = 0;
-		} else {
+
 			usb_on = 1;
 			ac_on = 0;
-		}
 	}
 	else {
 		ac_on = 0;
diff -urN flo-ElementalX-5.00/drivers/rtc/rtc-mrst.c flo-ElementalX-5.00-patched/drivers/rtc/rtc-mrst.c
--- flo-ElementalX-5.00/drivers/rtc/rtc-mrst.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/rtc/rtc-mrst.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,544 +0,0 @@
-/*
- * rtc-mrst.c: Driver for Moorestown virtual RTC
- *
- * (C) Copyright 2009 Intel Corporation
- * Author: Jacob Pan (jacob.jun.pan@intel.com)
- *	   Feng Tang (feng.tang@intel.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; version 2
- * of the License.
- *
- * Note:
- * VRTC is emulated by system controller firmware, the real HW
- * RTC is located in the PMIC device. SCU FW shadows PMIC RTC
- * in a memory mapped IO space that is visible to the host IA
- * processor.
- *
- * This driver is based upon drivers/rtc/rtc-cmos.c
- */
-
-/*
- * Note:
- *  * vRTC only supports binary mode and 24H mode
- *  * vRTC only support PIE and AIE, no UIE, and its PIE only happens
- *    at 23:59:59pm everyday, no support for adjustable frequency
- *  * Alarm function is also limited to hr/min/sec.
- */
-
-#include <linux/mod_devicetable.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/sfi.h>
-
-#include <asm-generic/rtc.h>
-#include <asm/intel_scu_ipc.h>
-#include <asm/mrst.h>
-#include <asm/mrst-vrtc.h>
-
-struct mrst_rtc {
-	struct rtc_device	*rtc;
-	struct device		*dev;
-	int			irq;
-	struct resource		*iomem;
-
-	u8			enabled_wake;
-	u8			suspend_ctrl;
-};
-
-static const char driver_name[] = "rtc_mrst";
-
-#define	RTC_IRQMASK	(RTC_PF | RTC_AF)
-
-static inline int is_intr(u8 rtc_intr)
-{
-	if (!(rtc_intr & RTC_IRQF))
-		return 0;
-	return rtc_intr & RTC_IRQMASK;
-}
-
-static inline unsigned char vrtc_is_updating(void)
-{
-	unsigned char uip;
-	unsigned long flags;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-	uip = (vrtc_cmos_read(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-	return uip;
-}
-
-/*
- * rtc_time's year contains the increment over 1900, but vRTC's YEAR
- * register can't be programmed to value larger than 0x64, so vRTC
- * driver chose to use 1972 (1970 is UNIX time start point) as the base,
- * and does the translation at read/write time.
- *
- * Why not just use 1970 as the offset? it's because using 1972 will
- * make it consistent in leap year setting for both vrtc and low-level
- * physical rtc devices. Then why not use 1960 as the offset? If we use
- * 1960, for a device's first use, its YEAR register is 0 and the system
- * year will be parsed as 1960 which is not a valid UNIX time and will
- * cause many applications to fail mysteriously.
- */
-static int mrst_read_time(struct device *dev, struct rtc_time *time)
-{
-	unsigned long flags;
-
-	if (vrtc_is_updating())
-		mdelay(20);
-
-	spin_lock_irqsave(&rtc_lock, flags);
-	time->tm_sec = vrtc_cmos_read(RTC_SECONDS);
-	time->tm_min = vrtc_cmos_read(RTC_MINUTES);
-	time->tm_hour = vrtc_cmos_read(RTC_HOURS);
-	time->tm_mday = vrtc_cmos_read(RTC_DAY_OF_MONTH);
-	time->tm_mon = vrtc_cmos_read(RTC_MONTH);
-	time->tm_year = vrtc_cmos_read(RTC_YEAR);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-
-	/* Adjust for the 1972/1900 */
-	time->tm_year += 72;
-	time->tm_mon--;
-	return rtc_valid_tm(time);
-}
-
-static int mrst_set_time(struct device *dev, struct rtc_time *time)
-{
-	int ret;
-	unsigned long flags;
-	unsigned char mon, day, hrs, min, sec;
-	unsigned int yrs;
-
-	yrs = time->tm_year;
-	mon = time->tm_mon + 1;   /* tm_mon starts at zero */
-	day = time->tm_mday;
-	hrs = time->tm_hour;
-	min = time->tm_min;
-	sec = time->tm_sec;
-
-	if (yrs < 72 || yrs > 138)
-		return -EINVAL;
-	yrs -= 72;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-
-	vrtc_cmos_write(yrs, RTC_YEAR);
-	vrtc_cmos_write(mon, RTC_MONTH);
-	vrtc_cmos_write(day, RTC_DAY_OF_MONTH);
-	vrtc_cmos_write(hrs, RTC_HOURS);
-	vrtc_cmos_write(min, RTC_MINUTES);
-	vrtc_cmos_write(sec, RTC_SECONDS);
-
-	spin_unlock_irqrestore(&rtc_lock, flags);
-
-	ret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETTIME);
-	return ret;
-}
-
-static int mrst_read_alarm(struct device *dev, struct rtc_wkalrm *t)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	unsigned char rtc_control;
-
-	if (mrst->irq <= 0)
-		return -EIO;
-
-	/* Basic alarms only support hour, minute, and seconds fields.
-	 * Some also support day and month, for alarms up to a year in
-	 * the future.
-	 */
-	t->time.tm_mday = -1;
-	t->time.tm_mon = -1;
-	t->time.tm_year = -1;
-
-	/* vRTC only supports binary mode */
-	spin_lock_irq(&rtc_lock);
-	t->time.tm_sec = vrtc_cmos_read(RTC_SECONDS_ALARM);
-	t->time.tm_min = vrtc_cmos_read(RTC_MINUTES_ALARM);
-	t->time.tm_hour = vrtc_cmos_read(RTC_HOURS_ALARM);
-
-	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
-
-	t->enabled = !!(rtc_control & RTC_AIE);
-	t->pending = 0;
-
-	return 0;
-}
-
-static void mrst_checkintr(struct mrst_rtc *mrst, unsigned char rtc_control)
-{
-	unsigned char	rtc_intr;
-
-	/*
-	 * NOTE after changing RTC_xIE bits we always read INTR_FLAGS;
-	 * allegedly some older rtcs need that to handle irqs properly
-	 */
-	rtc_intr = vrtc_cmos_read(RTC_INTR_FLAGS);
-	rtc_intr &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;
-	if (is_intr(rtc_intr))
-		rtc_update_irq(mrst->rtc, 1, rtc_intr);
-}
-
-static void mrst_irq_enable(struct mrst_rtc *mrst, unsigned char mask)
-{
-	unsigned char	rtc_control;
-
-	/*
-	 * Flush any pending IRQ status, notably for update irqs,
-	 * before we enable new IRQs
-	 */
-	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	mrst_checkintr(mrst, rtc_control);
-
-	rtc_control |= mask;
-	vrtc_cmos_write(rtc_control, RTC_CONTROL);
-
-	mrst_checkintr(mrst, rtc_control);
-}
-
-static void mrst_irq_disable(struct mrst_rtc *mrst, unsigned char mask)
-{
-	unsigned char	rtc_control;
-
-	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	rtc_control &= ~mask;
-	vrtc_cmos_write(rtc_control, RTC_CONTROL);
-	mrst_checkintr(mrst, rtc_control);
-}
-
-static int mrst_set_alarm(struct device *dev, struct rtc_wkalrm *t)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	unsigned char hrs, min, sec;
-	int ret = 0;
-
-	if (!mrst->irq)
-		return -EIO;
-
-	hrs = t->time.tm_hour;
-	min = t->time.tm_min;
-	sec = t->time.tm_sec;
-
-	spin_lock_irq(&rtc_lock);
-	/* Next rtc irq must not be from previous alarm setting */
-	mrst_irq_disable(mrst, RTC_AIE);
-
-	/* Update alarm */
-	vrtc_cmos_write(hrs, RTC_HOURS_ALARM);
-	vrtc_cmos_write(min, RTC_MINUTES_ALARM);
-	vrtc_cmos_write(sec, RTC_SECONDS_ALARM);
-
-	spin_unlock_irq(&rtc_lock);
-
-	ret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETALARM);
-	if (ret)
-		return ret;
-
-	spin_lock_irq(&rtc_lock);
-	if (t->enabled)
-		mrst_irq_enable(mrst, RTC_AIE);
-
-	spin_unlock_irq(&rtc_lock);
-
-	return 0;
-}
-
-/* Currently, the vRTC doesn't support UIE ON/OFF */
-static int mrst_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	unsigned long	flags;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-	if (enabled)
-		mrst_irq_enable(mrst, RTC_AIE);
-	else
-		mrst_irq_disable(mrst, RTC_AIE);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-	return 0;
-}
-
-
-#if defined(CONFIG_RTC_INTF_PROC) || defined(CONFIG_RTC_INTF_PROC_MODULE)
-
-static int mrst_procfs(struct device *dev, struct seq_file *seq)
-{
-	unsigned char	rtc_control, valid;
-
-	spin_lock_irq(&rtc_lock);
-	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	valid = vrtc_cmos_read(RTC_VALID);
-	spin_unlock_irq(&rtc_lock);
-
-	return seq_printf(seq,
-			"periodic_IRQ\t: %s\n"
-			"alarm\t\t: %s\n"
-			"BCD\t\t: no\n"
-			"periodic_freq\t: daily (not adjustable)\n",
-			(rtc_control & RTC_PIE) ? "on" : "off",
-			(rtc_control & RTC_AIE) ? "on" : "off");
-}
-
-#else
-#define	mrst_procfs	NULL
-#endif
-
-static const struct rtc_class_ops mrst_rtc_ops = {
-	.read_time	= mrst_read_time,
-	.set_time	= mrst_set_time,
-	.read_alarm	= mrst_read_alarm,
-	.set_alarm	= mrst_set_alarm,
-	.proc		= mrst_procfs,
-	.alarm_irq_enable = mrst_rtc_alarm_irq_enable,
-};
-
-static struct mrst_rtc	mrst_rtc;
-
-/*
- * When vRTC IRQ is captured by SCU FW, FW will clear the AIE bit in
- * Reg B, so no need for this driver to clear it
- */
-static irqreturn_t mrst_rtc_irq(int irq, void *p)
-{
-	u8 irqstat;
-
-	spin_lock(&rtc_lock);
-	/* This read will clear all IRQ flags inside Reg C */
-	irqstat = vrtc_cmos_read(RTC_INTR_FLAGS);
-	spin_unlock(&rtc_lock);
-
-	irqstat &= RTC_IRQMASK | RTC_IRQF;
-	if (is_intr(irqstat)) {
-		rtc_update_irq(p, 1, irqstat);
-		return IRQ_HANDLED;
-	}
-	return IRQ_NONE;
-}
-
-static int __devinit
-vrtc_mrst_do_probe(struct device *dev, struct resource *iomem, int rtc_irq)
-{
-	int retval = 0;
-	unsigned char rtc_control;
-
-	/* There can be only one ... */
-	if (mrst_rtc.dev)
-		return -EBUSY;
-
-	if (!iomem)
-		return -ENODEV;
-
-	iomem = request_mem_region(iomem->start, resource_size(iomem),
-				   driver_name);
-	if (!iomem) {
-		dev_dbg(dev, "i/o mem already in use.\n");
-		return -EBUSY;
-	}
-
-	mrst_rtc.irq = rtc_irq;
-	mrst_rtc.iomem = iomem;
-	mrst_rtc.dev = dev;
-	dev_set_drvdata(dev, &mrst_rtc);
-
-	mrst_rtc.rtc = rtc_device_register(driver_name, dev,
-				&mrst_rtc_ops, THIS_MODULE);
-	if (IS_ERR(mrst_rtc.rtc)) {
-		retval = PTR_ERR(mrst_rtc.rtc);
-		goto cleanup0;
-	}
-
-	rename_region(iomem, dev_name(&mrst_rtc.rtc->dev));
-
-	spin_lock_irq(&rtc_lock);
-	mrst_irq_disable(&mrst_rtc, RTC_PIE | RTC_AIE);
-	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
-
-	if (!(rtc_control & RTC_24H) || (rtc_control & (RTC_DM_BINARY)))
-		dev_dbg(dev, "TODO: support more than 24-hr BCD mode\n");
-
-	if (rtc_irq) {
-		retval = request_irq(rtc_irq, mrst_rtc_irq,
-				0, dev_name(&mrst_rtc.rtc->dev),
-				mrst_rtc.rtc);
-		if (retval < 0) {
-			dev_dbg(dev, "IRQ %d is already in use, err %d\n",
-				rtc_irq, retval);
-			goto cleanup1;
-		}
-	}
-	dev_dbg(dev, "initialised\n");
-	return 0;
-
-cleanup1:
-	rtc_device_unregister(mrst_rtc.rtc);
-cleanup0:
-	dev_set_drvdata(dev, NULL);
-	mrst_rtc.dev = NULL;
-	release_mem_region(iomem->start, resource_size(iomem));
-	dev_err(dev, "rtc-mrst: unable to initialise\n");
-	return retval;
-}
-
-static void rtc_mrst_do_shutdown(void)
-{
-	spin_lock_irq(&rtc_lock);
-	mrst_irq_disable(&mrst_rtc, RTC_IRQMASK);
-	spin_unlock_irq(&rtc_lock);
-}
-
-static void __devexit rtc_mrst_do_remove(struct device *dev)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	struct resource *iomem;
-
-	rtc_mrst_do_shutdown();
-
-	if (mrst->irq)
-		free_irq(mrst->irq, mrst->rtc);
-
-	rtc_device_unregister(mrst->rtc);
-	mrst->rtc = NULL;
-
-	iomem = mrst->iomem;
-	release_mem_region(iomem->start, resource_size(iomem));
-	mrst->iomem = NULL;
-
-	mrst->dev = NULL;
-	dev_set_drvdata(dev, NULL);
-}
-
-#ifdef	CONFIG_PM
-static int mrst_suspend(struct device *dev, pm_message_t mesg)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	unsigned char	tmp;
-
-	/* Only the alarm might be a wakeup event source */
-	spin_lock_irq(&rtc_lock);
-	mrst->suspend_ctrl = tmp = vrtc_cmos_read(RTC_CONTROL);
-	if (tmp & (RTC_PIE | RTC_AIE)) {
-		unsigned char	mask;
-
-		if (device_may_wakeup(dev))
-			mask = RTC_IRQMASK & ~RTC_AIE;
-		else
-			mask = RTC_IRQMASK;
-		tmp &= ~mask;
-		vrtc_cmos_write(tmp, RTC_CONTROL);
-
-		mrst_checkintr(mrst, tmp);
-	}
-	spin_unlock_irq(&rtc_lock);
-
-	if (tmp & RTC_AIE) {
-		mrst->enabled_wake = 1;
-		enable_irq_wake(mrst->irq);
-	}
-
-	dev_dbg(&mrst_rtc.rtc->dev, "suspend%s, ctrl %02x\n",
-			(tmp & RTC_AIE) ? ", alarm may wake" : "",
-			tmp);
-
-	return 0;
-}
-
-/*
- * We want RTC alarms to wake us from the deep power saving state
- */
-static inline int mrst_poweroff(struct device *dev)
-{
-	return mrst_suspend(dev, PMSG_HIBERNATE);
-}
-
-static int mrst_resume(struct device *dev)
-{
-	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
-	unsigned char tmp = mrst->suspend_ctrl;
-
-	/* Re-enable any irqs previously active */
-	if (tmp & RTC_IRQMASK) {
-		unsigned char	mask;
-
-		if (mrst->enabled_wake) {
-			disable_irq_wake(mrst->irq);
-			mrst->enabled_wake = 0;
-		}
-
-		spin_lock_irq(&rtc_lock);
-		do {
-			vrtc_cmos_write(tmp, RTC_CONTROL);
-
-			mask = vrtc_cmos_read(RTC_INTR_FLAGS);
-			mask &= (tmp & RTC_IRQMASK) | RTC_IRQF;
-			if (!is_intr(mask))
-				break;
-
-			rtc_update_irq(mrst->rtc, 1, mask);
-			tmp &= ~RTC_AIE;
-		} while (mask & RTC_AIE);
-		spin_unlock_irq(&rtc_lock);
-	}
-
-	dev_dbg(&mrst_rtc.rtc->dev, "resume, ctrl %02x\n", tmp);
-
-	return 0;
-}
-
-#else
-#define	mrst_suspend	NULL
-#define	mrst_resume	NULL
-
-static inline int mrst_poweroff(struct device *dev)
-{
-	return -ENOSYS;
-}
-
-#endif
-
-static int __devinit vrtc_mrst_platform_probe(struct platform_device *pdev)
-{
-	return vrtc_mrst_do_probe(&pdev->dev,
-			platform_get_resource(pdev, IORESOURCE_MEM, 0),
-			platform_get_irq(pdev, 0));
-}
-
-static int __devexit vrtc_mrst_platform_remove(struct platform_device *pdev)
-{
-	rtc_mrst_do_remove(&pdev->dev);
-	return 0;
-}
-
-static void vrtc_mrst_platform_shutdown(struct platform_device *pdev)
-{
-	if (system_state == SYSTEM_POWER_OFF && !mrst_poweroff(&pdev->dev))
-		return;
-
-	rtc_mrst_do_shutdown();
-}
-
-MODULE_ALIAS("platform:vrtc_mrst");
-
-static struct platform_driver vrtc_mrst_platform_driver = {
-	.probe		= vrtc_mrst_platform_probe,
-	.remove		= __devexit_p(vrtc_mrst_platform_remove),
-	.shutdown	= vrtc_mrst_platform_shutdown,
-	.driver = {
-		.name		= (char *) driver_name,
-		.suspend	= mrst_suspend,
-		.resume		= mrst_resume,
-	}
-};
-
-module_platform_driver(vrtc_mrst_platform_driver);
-
-MODULE_AUTHOR("Jacob Pan; Feng Tang");
-MODULE_DESCRIPTION("Driver for Moorestown virtual RTC");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/drivers/scsi/3w-sas.h flo-ElementalX-5.00-patched/drivers/scsi/3w-sas.h
--- flo-ElementalX-5.00/drivers/scsi/3w-sas.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/scsi/3w-sas.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,396 +0,0 @@
-/*
-   3w-sas.h -- LSI 3ware SAS/SATA-RAID Controller device driver for Linux.
-
-   Written By: Adam Radford <linuxraid@lsi.com>
-
-   Copyright (C) 2009 LSI Corporation.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; version 2 of the License.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   NO WARRANTY
-   THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
-   CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
-   LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
-   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
-   solely responsible for determining the appropriateness of using and
-   distributing the Program and assumes all risks associated with its
-   exercise of rights under this Agreement, including but not limited to
-   the risks and costs of program errors, damage to or loss of data,
-   programs or equipment, and unavailability or interruption of operations.
-
-   DISCLAIMER OF LIABILITY
-   NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
-   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-   DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-   USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
-   HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-   Bugs/Comments/Suggestions should be mailed to:
-   linuxraid@lsi.com
-
-   For more information, goto:
-   http://www.lsi.com
-*/
-
-#ifndef _3W_SAS_H
-#define _3W_SAS_H
-
-/* AEN severity table */
-static char *twl_aen_severity_table[] =
-{
-	"None", "ERROR", "WARNING", "INFO", "DEBUG", NULL
-};
-
-/* Liberator register offsets */
-#define TWL_STATUS                         0x0  /* Status */
-#define TWL_HIBDB                          0x20 /* Inbound doorbell */
-#define TWL_HISTAT                         0x30 /* Host interrupt status */
-#define TWL_HIMASK                         0x34 /* Host interrupt mask */
-#define TWL_HOBDB			   0x9C /* Outbound doorbell */
-#define TWL_HOBDBC                         0xA0 /* Outbound doorbell clear */
-#define TWL_SCRPD3                         0xBC /* Scratchpad */
-#define TWL_HIBQPL                         0xC0 /* Host inbound Q low */
-#define TWL_HIBQPH                         0xC4 /* Host inbound Q high */
-#define TWL_HOBQPL                         0xC8 /* Host outbound Q low */
-#define TWL_HOBQPH                         0xCC /* Host outbound Q high */
-#define TWL_HISTATUS_VALID_INTERRUPT	   0xC
-#define TWL_HISTATUS_ATTENTION_INTERRUPT   0x4
-#define TWL_HISTATUS_RESPONSE_INTERRUPT	   0x8
-#define TWL_STATUS_OVERRUN_SUBMIT	   0x2000
-#define TWL_ISSUE_SOFT_RESET		   0x100
-#define TWL_CONTROLLER_READY		   0x2000
-#define TWL_DOORBELL_CONTROLLER_ERROR	   0x200000
-#define TWL_DOORBELL_ATTENTION_INTERRUPT   0x40000
-#define TWL_PULL_MODE			   0x1
-
-/* Command packet opcodes used by the driver */
-#define TW_OP_INIT_CONNECTION 0x1
-#define TW_OP_GET_PARAM	      0x12
-#define TW_OP_SET_PARAM	      0x13
-#define TW_OP_EXECUTE_SCSI    0x10
-
-/* Asynchronous Event Notification (AEN) codes used by the driver */
-#define TW_AEN_QUEUE_EMPTY       0x0000
-#define TW_AEN_SOFT_RESET        0x0001
-#define TW_AEN_SYNC_TIME_WITH_HOST 0x031
-#define TW_AEN_SEVERITY_ERROR    0x1
-#define TW_AEN_SEVERITY_DEBUG    0x4
-#define TW_AEN_NOT_RETRIEVED 0x1
-
-/* Command state defines */
-#define TW_S_INITIAL   0x1  /* Initial state */
-#define TW_S_STARTED   0x2  /* Id in use */
-#define TW_S_POSTED    0x4  /* Posted to the controller */
-#define TW_S_COMPLETED 0x8  /* Completed by isr */
-#define TW_S_FINISHED  0x10 /* I/O completely done */
-
-/* Compatibility defines */
-#define TW_9750_ARCH_ID 10
-#define TW_CURRENT_DRIVER_SRL 40
-#define TW_CURRENT_DRIVER_BUILD 0
-#define TW_CURRENT_DRIVER_BRANCH 0
-
-/* Phase defines */
-#define TW_PHASE_INITIAL 0
-#define TW_PHASE_SGLIST  2
-
-/* Misc defines */
-#define TW_SECTOR_SIZE                        512
-#define TW_MAX_UNITS			      32
-#define TW_INIT_MESSAGE_CREDITS		      0x100
-#define TW_INIT_COMMAND_PACKET_SIZE	      0x3
-#define TW_INIT_COMMAND_PACKET_SIZE_EXTENDED  0x6
-#define TW_EXTENDED_INIT_CONNECT	      0x2
-#define TW_BASE_FW_SRL			      24
-#define TW_BASE_FW_BRANCH		      0
-#define TW_BASE_FW_BUILD		      1
-#define TW_Q_LENGTH			      256
-#define TW_Q_START			      0
-#define TW_MAX_SLOT			      32
-#define TW_MAX_RESET_TRIES		      2
-#define TW_MAX_CMDS_PER_LUN		      254
-#define TW_MAX_AEN_DRAIN		      255
-#define TW_IN_RESET                           2
-#define TW_USING_MSI			      3
-#define TW_IN_ATTENTION_LOOP		      4
-#define TW_MAX_SECTORS                        256
-#define TW_MAX_CDB_LEN                        16
-#define TW_IOCTL_CHRDEV_TIMEOUT               60 /* 60 seconds */
-#define TW_IOCTL_CHRDEV_FREE                  -1
-#define TW_COMMAND_OFFSET                     128 /* 128 bytes */
-#define TW_VERSION_TABLE                      0x0402
-#define TW_TIMEKEEP_TABLE		      0x040A
-#define TW_INFORMATION_TABLE		      0x0403
-#define TW_PARAM_FWVER			      3
-#define TW_PARAM_FWVER_LENGTH		      16
-#define TW_PARAM_BIOSVER		      4
-#define TW_PARAM_BIOSVER_LENGTH		      16
-#define TW_PARAM_MODEL			      8
-#define TW_PARAM_MODEL_LENGTH		      16
-#define TW_PARAM_PHY_SUMMARY_TABLE	      1
-#define TW_PARAM_PHYCOUNT		      2
-#define TW_PARAM_PHYCOUNT_LENGTH	      1
-#define TW_IOCTL_FIRMWARE_PASS_THROUGH        0x108  // Used by smartmontools
-#define TW_ALLOCATION_LENGTH		      128
-#define TW_SENSE_DATA_LENGTH		      18
-#define TW_ERROR_LOGICAL_UNIT_NOT_SUPPORTED   0x10a
-#define TW_ERROR_INVALID_FIELD_IN_CDB	      0x10d
-#define TW_ERROR_UNIT_OFFLINE                 0x128
-#define TW_MESSAGE_SOURCE_CONTROLLER_ERROR    3
-#define TW_MESSAGE_SOURCE_CONTROLLER_EVENT    4
-#define TW_DRIVER 			      6
-#ifndef PCI_DEVICE_ID_3WARE_9750
-#define PCI_DEVICE_ID_3WARE_9750 0x1010
-#endif
-
-/* Bitmask macros to eliminate bitfields */
-
-/* opcode: 5, reserved: 3 */
-#define TW_OPRES_IN(x,y) ((x << 5) | (y & 0x1f))
-#define TW_OP_OUT(x) (x & 0x1f)
-
-/* opcode: 5, sgloffset: 3 */
-#define TW_OPSGL_IN(x,y) ((x << 5) | (y & 0x1f))
-#define TW_SGL_OUT(x) ((x >> 5) & 0x7)
-
-/* severity: 3, reserved: 5 */
-#define TW_SEV_OUT(x) (x & 0x7)
-
-/* not_mfa: 1, reserved: 7, status: 8, request_id: 16 */
-#define TW_RESID_OUT(x) ((x >> 16) & 0xffff)
-#define TW_NOTMFA_OUT(x) (x & 0x1)
-
-/* request_id: 12, lun: 4 */
-#define TW_REQ_LUN_IN(lun, request_id) (((lun << 12) & 0xf000) | (request_id & 0xfff))
-#define TW_LUN_OUT(lun) ((lun >> 12) & 0xf)
-
-/* Register access macros */
-#define TWL_STATUS_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_STATUS)
-#define TWL_HOBQPL_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HOBQPL)
-#define TWL_HOBQPH_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HOBQPH)
-#define TWL_HOBDB_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HOBDB)
-#define TWL_HOBDBC_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HOBDBC)
-#define TWL_HIMASK_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HIMASK)
-#define TWL_HISTAT_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HISTAT)
-#define TWL_HIBQPH_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HIBQPH)
-#define TWL_HIBQPL_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HIBQPL)
-#define TWL_HIBDB_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_HIBDB)
-#define TWL_SCRPD3_REG_ADDR(x) ((unsigned char __iomem *)x->base_addr + TWL_SCRPD3)
-#define TWL_MASK_INTERRUPTS(x) (writel(~0, TWL_HIMASK_REG_ADDR(tw_dev)))
-#define TWL_UNMASK_INTERRUPTS(x) (writel(~TWL_HISTATUS_VALID_INTERRUPT, TWL_HIMASK_REG_ADDR(tw_dev)))
-#define TWL_CLEAR_DB_INTERRUPT(x) (writel(~0, TWL_HOBDBC_REG_ADDR(tw_dev)))
-#define TWL_SOFT_RESET(x) (writel(TWL_ISSUE_SOFT_RESET, TWL_HIBDB_REG_ADDR(tw_dev)))
-
-/* Macros */
-#define TW_PRINTK(h,a,b,c) { \
-if (h) \
-printk(KERN_WARNING "3w-sas: scsi%d: ERROR: (0x%02X:0x%04X): %s.\n",h->host_no,a,b,c); \
-else \
-printk(KERN_WARNING "3w-sas: ERROR: (0x%02X:0x%04X): %s.\n",a,b,c); \
-}
-#define TW_MAX_LUNS 16
-#define TW_COMMAND_SIZE (sizeof(dma_addr_t) > 4 ? 6 : 4)
-#define TW_LIBERATOR_MAX_SGL_LENGTH (sizeof(dma_addr_t) > 4 ? 46 : 92)
-#define TW_LIBERATOR_MAX_SGL_LENGTH_OLD (sizeof(dma_addr_t) > 4 ? 47 : 94)
-#define TW_PADDING_LENGTH_LIBERATOR 136
-#define TW_PADDING_LENGTH_LIBERATOR_OLD 132
-#define TW_CPU_TO_SGL(x) (sizeof(dma_addr_t) > 4 ? cpu_to_le64(x) : cpu_to_le32(x))
-
-#pragma pack(1)
-
-/* SGL entry */
-typedef struct TAG_TW_SG_Entry_ISO {
-	dma_addr_t address;
-	dma_addr_t length;
-} TW_SG_Entry_ISO;
-
-/* Old Command Packet with ISO SGL */
-typedef struct TW_Command {
-	unsigned char opcode__sgloffset;
-	unsigned char size;
-	unsigned char request_id;
-	unsigned char unit__hostid;
-	/* Second DWORD */
-	unsigned char status;
-	unsigned char flags;
-	union {
-		unsigned short block_count;
-		unsigned short parameter_count;
-	} byte6_offset;
-	union {
-		struct {
-			u32 lba;
-			TW_SG_Entry_ISO sgl[TW_LIBERATOR_MAX_SGL_LENGTH_OLD];
-			unsigned char padding[TW_PADDING_LENGTH_LIBERATOR_OLD];
-		} io;
-		struct {
-			TW_SG_Entry_ISO sgl[TW_LIBERATOR_MAX_SGL_LENGTH_OLD];
-			u32 padding;
-			unsigned char padding2[TW_PADDING_LENGTH_LIBERATOR_OLD];
-		} param;
-	} byte8_offset;
-} TW_Command;
-
-/* New Command Packet with ISO SGL */
-typedef struct TAG_TW_Command_Apache {
-	unsigned char opcode__reserved;
-	unsigned char unit;
-	unsigned short request_id__lunl;
-	unsigned char status;
-	unsigned char sgl_offset;
-	unsigned short sgl_entries__lunh;
-	unsigned char cdb[16];
-	TW_SG_Entry_ISO sg_list[TW_LIBERATOR_MAX_SGL_LENGTH];
-	unsigned char padding[TW_PADDING_LENGTH_LIBERATOR];
-} TW_Command_Apache;
-
-/* New command packet header */
-typedef struct TAG_TW_Command_Apache_Header {
-	unsigned char sense_data[TW_SENSE_DATA_LENGTH];
-	struct {
-		char reserved[4];
-		unsigned short error;
-		unsigned char padding;
-		unsigned char severity__reserved;
-	} status_block;
-	unsigned char err_specific_desc[98];
-	struct {
-		unsigned char size_header;
-		unsigned short request_id;
-		unsigned char size_sense;
-	} header_desc;
-} TW_Command_Apache_Header;
-
-/* This struct is a union of the 2 command packets */
-typedef struct TAG_TW_Command_Full {
-	TW_Command_Apache_Header header;
-	union {
-		TW_Command oldcommand;
-		TW_Command_Apache newcommand;
-	} command;
-} TW_Command_Full;
-
-/* Initconnection structure */
-typedef struct TAG_TW_Initconnect {
-	unsigned char opcode__reserved;
-	unsigned char size;
-	unsigned char request_id;
-	unsigned char res2;
-	unsigned char status;
-	unsigned char flags;
-	unsigned short message_credits;
-	u32 features;
-	unsigned short fw_srl;
-	unsigned short fw_arch_id;
-	unsigned short fw_branch;
-	unsigned short fw_build;
-	u32 result;
-} TW_Initconnect;
-
-/* Event info structure */
-typedef struct TAG_TW_Event
-{
-	unsigned int sequence_id;
-	unsigned int time_stamp_sec;
-	unsigned short aen_code;
-	unsigned char severity;
-	unsigned char retrieved;
-	unsigned char repeat_count;
-	unsigned char parameter_len;
-	unsigned char parameter_data[98];
-} TW_Event;
-
-typedef struct TAG_TW_Ioctl_Driver_Command {
-	unsigned int control_code;
-	unsigned int status;
-	unsigned int unique_id;
-	unsigned int sequence_id;
-	unsigned int os_specific;
-	unsigned int buffer_length;
-} TW_Ioctl_Driver_Command;
-
-typedef struct TAG_TW_Ioctl_Apache {
-	TW_Ioctl_Driver_Command driver_command;
-        char padding[488];
-	TW_Command_Full firmware_command;
-	char data_buffer[1];
-} TW_Ioctl_Buf_Apache;
-
-/* GetParam descriptor */
-typedef struct {
-	unsigned short	table_id;
-	unsigned short	parameter_id;
-	unsigned short	parameter_size_bytes;
-	unsigned short  actual_parameter_size_bytes;
-	unsigned char	data[1];
-} TW_Param_Apache;
-
-/* Compatibility information structure */
-typedef struct TAG_TW_Compatibility_Info
-{
-	char driver_version[32];
-	unsigned short working_srl;
-	unsigned short working_branch;
-	unsigned short working_build;
-	unsigned short driver_srl_high;
-	unsigned short driver_branch_high;
-	unsigned short driver_build_high;
-	unsigned short driver_srl_low;
-	unsigned short driver_branch_low;
-	unsigned short driver_build_low;
-	unsigned short fw_on_ctlr_srl;
-	unsigned short fw_on_ctlr_branch;
-	unsigned short fw_on_ctlr_build;
-} TW_Compatibility_Info;
-
-#pragma pack()
-
-typedef struct TAG_TW_Device_Extension {
-	void                     __iomem *base_addr;
-	unsigned long	       	*generic_buffer_virt[TW_Q_LENGTH];
-	dma_addr_t	       	generic_buffer_phys[TW_Q_LENGTH];
-	TW_Command_Full	       	*command_packet_virt[TW_Q_LENGTH];
-	dma_addr_t		command_packet_phys[TW_Q_LENGTH];
-	TW_Command_Apache_Header *sense_buffer_virt[TW_Q_LENGTH];
-	dma_addr_t		sense_buffer_phys[TW_Q_LENGTH];
-	struct pci_dev		*tw_pci_dev;
-	struct scsi_cmnd	*srb[TW_Q_LENGTH];
-	unsigned char		free_queue[TW_Q_LENGTH];
-	unsigned char		free_head;
-	unsigned char		free_tail;
-	int     		state[TW_Q_LENGTH];
-	unsigned int		posted_request_count;
-	unsigned int		max_posted_request_count;
-	unsigned int		max_sgl_entries;
-	unsigned int		sgl_entries;
-	unsigned int		num_resets;
-	unsigned int		sector_count;
-	unsigned int		max_sector_count;
-	unsigned int		aen_count;
-	struct Scsi_Host	*host;
-	long			flags;
-	TW_Event                *event_queue[TW_Q_LENGTH];
-	unsigned char           error_index;
-	unsigned int            error_sequence_id;
-	int			chrdev_request_id;
-	wait_queue_head_t	ioctl_wqueue;
-	struct mutex		ioctl_lock;
-	TW_Compatibility_Info	tw_compat_info;
-	char			online;
-} TW_Device_Extension;
-
-#endif /* _3W_SAS_H */
-
diff -urN flo-ElementalX-5.00/drivers/staging/ozwpan/ozusbsvc1.c flo-ElementalX-5.00-patched/drivers/staging/ozwpan/ozusbsvc1.c
--- flo-ElementalX-5.00/drivers/staging/ozwpan/ozusbsvc1.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/ozwpan/ozusbsvc1.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,437 +0,0 @@
-/* -----------------------------------------------------------------------------
- * Copyright (c) 2011 Ozmo Inc
- * Released under the GNU General Public License Version 2 (GPLv2).
- *
- * This file implements the protocol specific parts of the USB service for a PD.
- * -----------------------------------------------------------------------------
- */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/sched.h>
-#include <linux/netdevice.h>
-#include <linux/errno.h>
-#include <linux/input.h>
-#include <asm/unaligned.h>
-#include "ozconfig.h"
-#include "ozprotocol.h"
-#include "ozeltbuf.h"
-#include "ozpd.h"
-#include "ozproto.h"
-#include "ozusbif.h"
-#include "ozhcd.h"
-#include "oztrace.h"
-#include "ozusbsvc.h"
-#include "ozevent.h"
-/*------------------------------------------------------------------------------
- */
-#define MAX_ISOC_FIXED_DATA	(253-sizeof(struct oz_isoc_fixed))
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-static int oz_usb_submit_elt(struct oz_elt_buf *eb, struct oz_elt_info *ei,
-	struct oz_usb_ctx *usb_ctx, u8 strid, u8 isoc)
-{
-	int ret;
-	struct oz_elt *elt = (struct oz_elt *)ei->data;
-	struct oz_app_hdr *app_hdr = (struct oz_app_hdr *)(elt+1);
-	elt->type = OZ_ELT_APP_DATA;
-	ei->app_id = OZ_APPID_USB;
-	ei->length = elt->length + sizeof(struct oz_elt);
-	app_hdr->app_id = OZ_APPID_USB;
-	spin_lock_bh(&eb->lock);
-	if (isoc == 0) {
-		app_hdr->elt_seq_num = usb_ctx->tx_seq_num++;
-		if (usb_ctx->tx_seq_num == 0)
-			usb_ctx->tx_seq_num = 1;
-	}
-	ret = oz_queue_elt_info(eb, isoc, strid, ei);
-	if (ret)
-		oz_elt_info_free(eb, ei);
-	spin_unlock_bh(&eb->lock);
-	return ret;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-int oz_usb_get_desc_req(void *hpd, u8 req_id, u8 req_type, u8 desc_type,
-	u8 index, u16 windex, int offset, int len)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_get_desc_req *body;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	oz_trace("    req_type = 0x%x\n", req_type);
-	oz_trace("    desc_type = 0x%x\n", desc_type);
-	oz_trace("    index = 0x%x\n", index);
-	oz_trace("    windex = 0x%x\n", windex);
-	oz_trace("    offset = 0x%x\n", offset);
-	oz_trace("    len = 0x%x\n", len);
-	if (len > 200)
-		len = 200;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_get_desc_req);
-	body = (struct oz_get_desc_req *)(elt+1);
-	body->type = OZ_GET_DESC_REQ;
-	body->req_id = req_id;
-	put_unaligned(cpu_to_le16(offset), &body->offset);
-	put_unaligned(cpu_to_le16(len), &body->size);
-	body->req_type = req_type;
-	body->desc_type = desc_type;
-	body->w_index = windex;
-	body->index = index;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_config_req(void *hpd, u8 req_id, u8 index)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_set_config_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_set_config_req);
-	body = (struct oz_set_config_req *)(elt+1);
-	body->type = OZ_SET_CONFIG_REQ;
-	body->req_id = req_id;
-	body->index = index;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_interface_req(void *hpd, u8 req_id, u8 index, u8 alt)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_set_interface_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_set_interface_req);
-	body = (struct oz_set_interface_req *)(elt+1);
-	body->type = OZ_SET_INTERFACE_REQ;
-	body->req_id = req_id;
-	body->index = index;
-	body->alternative = alt;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_clear_feature_req(void *hpd, u8 req_id, u8 type,
-			u8 recipient, u8 index, __le16 feature)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_feature_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_feature_req);
-	body = (struct oz_feature_req *)(elt+1);
-	body->type = type;
-	body->req_id = req_id;
-	body->recipient = recipient;
-	body->index = index;
-	put_unaligned(feature, &body->feature);
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_vendor_class_req(void *hpd, u8 req_id, u8 req_type,
-	u8 request, __le16 value, __le16 index, u8 *data, int data_len)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_vendor_class_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_vendor_class_req) - 1 + data_len;
-	body = (struct oz_vendor_class_req *)(elt+1);
-	body->type = OZ_VENDOR_CLASS_REQ;
-	body->req_id = req_id;
-	body->req_type = req_type;
-	body->request = request;
-	put_unaligned(value, &body->value);
-	put_unaligned(index, &body->index);
-	if (data_len)
-		memcpy(body->data, data, data_len);
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-int oz_usb_control_req(void *hpd, u8 req_id, struct usb_ctrlrequest *setup,
-			u8 *data, int data_len)
-{
-	unsigned wvalue = le16_to_cpu(setup->wValue);
-	unsigned windex = le16_to_cpu(setup->wIndex);
-	unsigned wlength = le16_to_cpu(setup->wLength);
-	int rc = 0;
-	oz_event_log(OZ_EVT_CTRL_REQ, setup->bRequest, req_id,
-		(void *)(((unsigned long)(setup->wValue))<<16 |
-			((unsigned long)setup->wIndex)),
-		setup->bRequestType);
-	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		switch (setup->bRequest) {
-		case USB_REQ_GET_DESCRIPTOR:
-			rc = oz_usb_get_desc_req(hpd, req_id,
-				setup->bRequestType, (u8)(wvalue>>8),
-				(u8)wvalue, setup->wIndex, 0, wlength);
-			break;
-		case USB_REQ_SET_CONFIGURATION:
-			rc = oz_usb_set_config_req(hpd, req_id, (u8)wvalue);
-			break;
-		case USB_REQ_SET_INTERFACE: {
-				u8 if_num = (u8)windex;
-				u8 alt = (u8)wvalue;
-				rc = oz_usb_set_interface_req(hpd, req_id,
-					if_num, alt);
-			}
-			break;
-		case USB_REQ_SET_FEATURE:
-			rc = oz_usb_set_clear_feature_req(hpd, req_id,
-				OZ_SET_FEATURE_REQ,
-				setup->bRequestType & 0xf, (u8)windex,
-				setup->wValue);
-			break;
-		case USB_REQ_CLEAR_FEATURE:
-			rc = oz_usb_set_clear_feature_req(hpd, req_id,
-				OZ_CLEAR_FEATURE_REQ,
-				setup->bRequestType & 0xf,
-				(u8)windex, setup->wValue);
-			break;
-		}
-	} else {
-		rc = oz_usb_vendor_class_req(hpd, req_id, setup->bRequestType,
-			setup->bRequest, setup->wValue, setup->wIndex,
-			data, data_len);
-	}
-	return rc;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-int oz_usb_send_isoc(void *hpd, u8 ep_num, struct urb *urb)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt_buf *eb;
-	int i;
-	int hdr_size;
-	u8 *data;
-	struct usb_iso_packet_descriptor *desc;
-
-	if (pd->mode & OZ_F_ISOC_NO_ELTS) {
-		for (i = 0; i < urb->number_of_packets; i++) {
-			u8 *data;
-			desc = &urb->iso_frame_desc[i];
-			data = ((u8 *)urb->transfer_buffer)+desc->offset;
-			oz_send_isoc_unit(pd, ep_num, data, desc->length);
-		}
-		return 0;
-	}
-
-	hdr_size = sizeof(struct oz_isoc_fixed) - 1;
-	eb = &pd->elt_buff;
-	i = 0;
-	while (i < urb->number_of_packets) {
-		struct oz_elt_info *ei = oz_elt_info_alloc(eb);
-		struct oz_elt *elt;
-		struct oz_isoc_fixed *body;
-		int unit_count;
-		int unit_size;
-		int rem;
-		if (ei == 0)
-			return -1;
-		rem = MAX_ISOC_FIXED_DATA;
-		elt = (struct oz_elt *)ei->data;
-		body = (struct oz_isoc_fixed *)(elt + 1);
-		body->type = OZ_USB_ENDPOINT_DATA;
-		body->endpoint = ep_num;
-		body->format = OZ_DATA_F_ISOC_FIXED;
-		unit_size = urb->iso_frame_desc[i].length;
-		body->unit_size = (u8)unit_size;
-		data = ((u8 *)(elt+1)) + hdr_size;
-		unit_count = 0;
-		while (i < urb->number_of_packets) {
-			desc = &urb->iso_frame_desc[i];
-			if ((unit_size == desc->length) &&
-				(desc->length <= rem)) {
-				memcpy(data, ((u8 *)urb->transfer_buffer) +
-					desc->offset, unit_size);
-				data += unit_size;
-				rem -= unit_size;
-				unit_count++;
-				desc->status = 0;
-				desc->actual_length = desc->length;
-				i++;
-			} else {
-				break;
-			}
-		}
-		elt->length = hdr_size + MAX_ISOC_FIXED_DATA - rem;
-		/* Store the number of units in body->frame_number for the
-		 * moment. This field will be correctly determined before
-		 * the element is sent. */
-		body->frame_number = (u8)unit_count;
-		oz_usb_submit_elt(eb, ei, usb_ctx, ep_num,
-			pd->mode & OZ_F_ISOC_ANYTIME);
-	}
-	return 0;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq-serialized
- */
-void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
-	struct oz_usb_hdr *usb_hdr, int len)
-{
-	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;
-	switch (data_hdr->format) {
-	case OZ_DATA_F_MULTIPLE_FIXED: {
-			struct oz_multiple_fixed *body =
-				(struct oz_multiple_fixed *)data_hdr;
-			u8 *data = body->data;
-			int n = (len - sizeof(struct oz_multiple_fixed)+1)
-				/ body->unit_size;
-			while (n--) {
-				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
-					data, body->unit_size);
-				data += body->unit_size;
-			}
-		}
-		break;
-	case OZ_DATA_F_ISOC_FIXED: {
-			struct oz_isoc_fixed *body =
-				(struct oz_isoc_fixed *)data_hdr;
-			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
-			int unit_size = body->unit_size;
-			u8 *data = body->data;
-			int count;
-			int i;
-			if (!unit_size)
-				break;
-			count = data_len/unit_size;
-			for (i = 0; i < count; i++) {
-				oz_hcd_data_ind(usb_ctx->hport,
-					body->endpoint, data, unit_size);
-				data += unit_size;
-			}
-		}
-		break;
-	}
-
-}
-/*------------------------------------------------------------------------------
- * This is called when the PD has received a USB element. The type of element
- * is determined and is then passed to an appropriate handler function.
- * Context: softirq-serialized
- */
-void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)
-{
-	struct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);
-	struct oz_usb_ctx *usb_ctx;
-
-	spin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	usb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB-1];
-	if (usb_ctx)
-		oz_usb_get(usb_ctx);
-	spin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	if (usb_ctx == 0)
-		return; /* Context has gone so nothing to do. */
-	if (usb_ctx->stopped)
-		goto done;
-	/* If sequence number is non-zero then check it is not a duplicate.
-	 * Zero sequence numbers are always accepted.
-	 */
-	if (usb_hdr->elt_seq_num != 0) {
-		if (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)
-			/* Reject duplicate element. */
-			goto done;
-	}
-	usb_ctx->rx_seq_num = usb_hdr->elt_seq_num;
-	switch (usb_hdr->type) {
-	case OZ_GET_DESC_RSP: {
-			struct oz_get_desc_rsp *body =
-				(struct oz_get_desc_rsp *)usb_hdr;
-			int data_len = elt->length -
-					sizeof(struct oz_get_desc_rsp) + 1;
-			u16 offs = le16_to_cpu(get_unaligned(&body->offset));
-			u16 total_size =
-				le16_to_cpu(get_unaligned(&body->total_size));
-			oz_trace("USB_REQ_GET_DESCRIPTOR - cnf\n");
-			oz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,
-					body->rcode, body->data,
-					data_len, offs, total_size);
-		}
-		break;
-	case OZ_SET_CONFIG_RSP: {
-			struct oz_set_config_rsp *body =
-				(struct oz_set_config_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport, body->req_id,
-				body->rcode, 0, 0);
-		}
-		break;
-	case OZ_SET_INTERFACE_RSP: {
-			struct oz_set_interface_rsp *body =
-				(struct oz_set_interface_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport,
-				body->req_id, body->rcode, 0, 0);
-		}
-		break;
-	case OZ_VENDOR_CLASS_RSP: {
-			struct oz_vendor_class_rsp *body =
-				(struct oz_vendor_class_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport, body->req_id,
-				body->rcode, body->data, elt->length-
-				sizeof(struct oz_vendor_class_rsp)+1);
-		}
-		break;
-	case OZ_USB_ENDPOINT_DATA:
-		oz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);
-		break;
-	}
-done:
-	oz_usb_put(usb_ctx);
-}
-/*------------------------------------------------------------------------------
- * Context: softirq, process
- */
-void oz_usb_farewell(struct oz_pd *pd, u8 ep_num, u8 *data, u8 len)
-{
-	struct oz_usb_ctx *usb_ctx;
-	spin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	usb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB-1];
-	if (usb_ctx)
-		oz_usb_get(usb_ctx);
-	spin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	if (usb_ctx == 0)
-		return; /* Context has gone so nothing to do. */
-	if (!usb_ctx->stopped) {
-		oz_trace("Farewell indicated ep = 0x%x\n", ep_num);
-		oz_hcd_data_ind(usb_ctx->hport, ep_num, data, len);
-	}
-	oz_usb_put(usb_ctx);
-}
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h	2014-12-03 11:07:31.000000000 +0000
@@ -1342,6 +1342,13 @@
 #define CFG_P2P_DEVICE_ADDRESS_ADMINISTRATED_MAX                 ( 1 )
 #define CFG_P2P_DEVICE_ADDRESS_ADMINISTRATED_DEFAULT             ( 0 )
 
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+#define CFG_MC_ADDR_LIST_FILTER_NAME               "isMcAddrListFilter"
+#define CFG_MC_ADDR_LIST_FILTER_MIN                ( 0 )
+#define CFG_MC_ADDR_LIST_FILTER_MAX                ( 1 )
+#define CFG_MC_ADDR_LIST_FILTER_DEFAULT            ( 0 )
+#endif
+
 #define CFG_ENABLE_SSR                      "gEnableSSR"
 #define CFG_ENABLE_SSR_MIN                  ( 0 )
 #define CFG_ENABLE_SSR_MAX                  ( 1 )
@@ -1776,16 +1783,6 @@
 #define CFG_SPLIT_SCAN_TRAFFIC_MONITOR_TIMER_MAX       ( 10000 )
 #define CFG_SPLIT_SCAN_TRAFFIC_MONITOR_TIMER_DEFAULT   ( 5000 )
 
-#define CFG_RA_FILTER_ENABLE_NAME               "gRAFilterEnable"
-#define CFG_RA_FILTER_ENABLE_DEFAULT            (1)
-#define CFG_RA_FILTER_ENABLE_MIN                (0)
-#define CFG_RA_FILTER_ENABLE_MAX                (1)
-
-#define CFG_RA_RATE_LIMIT_INTERVAL_NAME         "gRARateLimitInterval"
-#define CFG_RA_RATE_LIMIT_INTERVAL_DEFAULT      (60)
-#define CFG_RA_RATE_LIMIT_INTERVAL_MIN          (0)
-#define CFG_RA_RATE_LIMIT_INTERVAL_MAX          (60)
-
 /*--------------------------------------------------------------------------- 
   Type declarations
   -------------------------------------------------------------------------*/ 
@@ -2113,6 +2110,9 @@
    v_U8_t                      allowMCCGODiffBI;
    v_BOOL_t                    isP2pDeviceAddrAdministrated;
    v_U8_t                      thermalMitigationEnable;
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+   v_BOOL_t                    isMcAddrListFilter;
+#endif
 #ifdef WLAN_FEATURE_11AC
    v_U8_t                      vhtChannelWidth;
    v_U8_t                      vhtRxMCS;
@@ -2165,8 +2165,6 @@
    v_U32_t                     cfgMaxMediumTime;
    v_U8_t                      enableTrafficMonitor;
    v_U32_t                     trafficIdleTimeout;
-   v_BOOL_t                    cfgRAFilterEnable;
-   v_U16_t                     cfgRARateLimitInterval;
 } hdd_config_t;
 /*--------------------------------------------------------------------------- 
   Function declarations and documenation
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h	2014-12-03 11:07:31.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -190,8 +190,6 @@
 #define GTK_OFFLOAD_DISABLE 1
 #endif
 
-#define MAX_USER_COMMAND_SIZE 4096
-
 #define HDD_MAC_ADDR_LEN    6
 typedef v_U8_t tWlanHddMacAddr[HDD_MAC_ADDR_LEN];
 
@@ -684,13 +682,6 @@
 
    /** Handle to the network device */
    struct net_device *dev;
-
-#ifdef WLAN_NS_OFFLOAD
-   /** IPv6 notifier callback for handling NS offload on change in IP */
-   struct notifier_block ipv6_notifier;
-   bool ipv6_notifier_registered;
-   struct work_struct  ipv6NotifierWorkQueue;
-#endif
     
    //TODO Move this to sta Ctx
    struct wireless_dev wdev ;
@@ -1109,7 +1100,5 @@
 int wlan_hdd_setIPv6Filter(hdd_context_t *pHddCtx, tANI_U8 filterType, tANI_U8 sessionId);
 #endif
 VOS_STATUS hdd_issta_p2p_clientconnected(hdd_context_t *pHddCtx);
-#ifdef WLAN_NS_OFFLOAD
-void hdd_ipv6_notifier_work_queue(struct work_struct *work);
-#endif
+
 #endif    // end #if !defined( WLAN_HDD_MAIN_H )
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h	2014-12-03 11:07:31.000000000 +0000
@@ -102,6 +102,6 @@
 void hdd_conf_gtk_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable);
 #endif
 #ifdef WLAN_NS_OFFLOAD
-void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, int fenable);
+void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable);
 #endif
 #endif // if !defined __WLAN_QCT_DRIVER_H
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c	2014-12-03 11:07:31.000000000 +0000
@@ -2299,12 +2299,9 @@
                 if (pHddCtx->hdd_mcastbcast_filter_set == TRUE)
                 {
                     hdd_conf_mcastbcast_filter(pHddCtx, FALSE);
-
-                    if (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid) {
-                        pHddCtx->configuredMcastBcastFilter =
-                            pHddCtx->sus_res_mcastbcast_filter;
-                        pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
-                    }
+                    pHddCtx->configuredMcastBcastFilter =
+                        pHddCtx->sus_res_mcastbcast_filter;
+                    pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
 
                     hddLog(VOS_TRACE_LEVEL_INFO,
                            "offload: disassociation happening, restoring configuredMcastBcastFilter");
@@ -2314,12 +2311,19 @@
                            "offload: already called mcastbcast filter");
                     (WLAN_HDD_GET_CTX(pAdapter))->hdd_mcastbcast_filter_set = FALSE;
                 }
-#ifdef WLAN_FEATURE_PACKET_FILTERING
-                /* Call to clear any MC Addr List filter applied after
-                 * successful connection.
-                 */
-                wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+#ifdef WLAN_FEATURE_PACKET_FILTERING    
+                if (pHddCtx->cfg_ini->isMcAddrListFilter)
+                {
+                    /*Multicast addr filtering is enabled*/
+                    if (pAdapter->mc_addr_list.isFilterApplied)
+                    {
+                        /*Filter applied during suspend mode*/
+                        /*Clear it here*/
+                        wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+                    }
+                }
 #endif
+
             }
             break;
         case eCSR_ROAM_IBSS_LEAVE:
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c	2014-12-03 11:07:31.000000000 +0000
@@ -1998,6 +1998,14 @@
               CFG_THERMAL_MIGRATION_ENABLE_DEFAULT,
               CFG_THERMAL_MIGRATION_ENABLE_MIN,
               CFG_THERMAL_MIGRATION_ENABLE_MAX ),
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+ REG_VARIABLE( CFG_MC_ADDR_LIST_FILTER_NAME, WLAN_PARAM_Integer,
+              hdd_config_t, isMcAddrListFilter,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_MC_ADDR_LIST_FILTER_DEFAULT,
+              CFG_MC_ADDR_LIST_FILTER_MIN,
+              CFG_MC_ADDR_LIST_FILTER_MAX ),
+#endif
 
 REG_VARIABLE( CFG_ENABLE_MODULATED_DTIM_NAME, WLAN_PARAM_Integer,
               hdd_config_t, enableModulatedDTIM,
@@ -2290,20 +2298,6 @@
                 CFG_TRAFFIC_IDLE_TIMEOUT_DEFAULT,
                 CFG_TRAFFIC_IDLE_TIMEOUT_MIN,
                 CFG_TRAFFIC_IDLE_TIMEOUT_MAX),
-
-   REG_VARIABLE(CFG_RA_FILTER_ENABLE_NAME, WLAN_PARAM_Integer,
-                hdd_config_t, cfgRAFilterEnable,
-                VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
-                CFG_RA_FILTER_ENABLE_DEFAULT,
-                CFG_RA_FILTER_ENABLE_MIN,
-                CFG_RA_FILTER_ENABLE_MAX ),
-
-   REG_VARIABLE(CFG_RA_RATE_LIMIT_INTERVAL_NAME, WLAN_PARAM_Integer,
-               hdd_config_t, cfgRARateLimitInterval,
-               VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
-               CFG_RA_RATE_LIMIT_INTERVAL_DEFAULT,
-               CFG_RA_RATE_LIMIT_INTERVAL_MIN,
-               CFG_RA_RATE_LIMIT_INTERVAL_MAX ),
 };
 
 /*
@@ -3794,20 +3788,6 @@
       hddLog(LOGE, "Could not pass on WNI_CFG_MAX_MEDIUM_TIME to CCM");
    }
 
-   if (ccmCfgSetInt(pHddCtx->hHal, WNI_CFG_RA_FILTER_ENABLE, pConfig->cfgRAFilterEnable,
-      NULL, eANI_BOOLEAN_FALSE) == eHAL_STATUS_FAILURE)
-   {
-      fStatus = FALSE;
-      hddLog(LOGE, "Could not pass on WNI_CFG_RA_FILTER_ENABLE to CCM");
-   }
-
-   if (ccmCfgSetInt(pHddCtx->hHal, WNI_CFG_RA_RATE_LIMIT_INTERVAL, pConfig->cfgRARateLimitInterval,
-      NULL, eANI_BOOLEAN_FALSE) == eHAL_STATUS_FAILURE)
-   {
-      fStatus = FALSE;
-      hddLog(LOGE, "Could not pass on WNI_CFG_RA_FILTER_ENABLE to CCM");
-   }
-
    return fStatus;
 }
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c	2014-12-03 11:07:31.000000000 +0000
@@ -469,14 +469,6 @@
    DATA_RATE_11AC_MAX_MCS_NA
 } eDataRate11ACMaxMcs;
 
-/* SSID broadcast  type */
-typedef enum eSSIDBcastType
-{
-  eBCAST_UNKNOWN      = 0,
-  eBCAST_NORMAL       = 1,
-  eBCAST_HIDDEN       = 2,
-} tSSIDBcastType;
-
 /* MCS Based VHT rate table */
 static struct index_vht_data_rate_type supported_vht_mcs_rate[] =
 {
@@ -519,8 +511,6 @@
         return NULL;
     }
 
-    wiphy->country_ie_pref = NL80211_COUNTRY_IE_IGNORE_CORE;
-
     return wiphy;
 }
 
@@ -4696,31 +4686,19 @@
         if( request->ie_len )
         {
             /* save this for future association (join requires this) */
-            /*TODO: Array needs to be converted to dynamic allocation,
-             * as multiple ie.s can be sent in cfg80211_scan_request structure
-             * CR 597966
-             */
             memset( &pScanInfo->scanAddIE, 0, sizeof(pScanInfo->scanAddIE) );
             memcpy( pScanInfo->scanAddIE.addIEdata, request->ie, request->ie_len);
             pScanInfo->scanAddIE.length = request->ie_len;
 
-            if ((WLAN_HDD_INFRA_STATION == pAdapter->device_mode) ||
+            if((WLAN_HDD_INFRA_STATION == pAdapter->device_mode) ||
                 (WLAN_HDD_P2P_CLIENT == pAdapter->device_mode) ||
-                (WLAN_HDD_P2P_DEVICE == pAdapter->device_mode))
+                (WLAN_HDD_P2P_DEVICE == pAdapter->device_mode)
+              )
             {
-                if ( request->ie_len <= SIR_MAC_MAX_IE_LENGTH)
-                {
-                    pwextBuf->roamProfile.nAddIEScanLength = request->ie_len;
-                    memcpy( pwextBuf->roamProfile.addIEScan,
-                                     request->ie, request->ie_len);
-                }
-                else
-                {
-                    hddLog(VOS_TRACE_LEVEL_ERROR, "Scan Ie length is invalid:"
-                             "%d", request->ie_len);
-                }
-
+               pwextBuf->roamProfile.pAddIEScan = pScanInfo->scanAddIE.addIEdata;
+               pwextBuf->roamProfile.nAddIEScanLength = pScanInfo->scanAddIE.length;
             }
+
             scanRequest.uIEFieldLen = pScanInfo->scanAddIE.length;
             scanRequest.pIEField = pScanInfo->scanAddIE.addIEdata;
 
@@ -7140,7 +7118,7 @@
     tpSirPNOScanReq pPnoRequest = NULL;
     hdd_context_t *pHddCtx;
     tHalHandle hHal;
-    v_U32_t i, indx, num_ch, j;
+    v_U32_t i, indx, num_ch;
     u8 valid_ch[WNI_CFG_VALID_CHANNEL_LIST_LEN];
     u8 channels_allowed[WNI_CFG_VALID_CHANNEL_LIST_LEN];
     v_U32_t num_channels_allowed = WNI_CFG_VALID_CHANNEL_LIST_LEN;
@@ -7245,7 +7223,7 @@
                request->match_sets[i].ssid.ssid_len);
         pPnoRequest->aNetworks[i].authentication = 0; /*eAUTH_TYPE_ANY*/
         pPnoRequest->aNetworks[i].encryption     = 0; /*eED_ANY*/
-        pPnoRequest->aNetworks[i].bcastNetwType  = eBCAST_NORMAL; /*eBCAST_NORMAL*/
+        pPnoRequest->aNetworks[i].bcastNetwType  = 0; /*eBCAST_UNKNOWN*/
 
         /*Copying list of valid channel into request */
         memcpy(pPnoRequest->aNetworks[i].aChannels, valid_ch, num_ch);
@@ -7254,26 +7232,6 @@
         pPnoRequest->aNetworks[i].rssiThreshold = 0; //Default value
     }
 
-    for (i = 0; i < request->n_ssids; i++)
-    {
-        j = 0;
-        while (j < pPnoRequest->ucNetworksCount)
-        {
-            if ((pPnoRequest->aNetworks[j].ssId.length ==
-                 request->ssids[i].ssid_len) &&
-                 (0 == memcmp(pPnoRequest->aNetworks[j].ssId.ssId,
-                            request->ssids[i].ssid,
-                            pPnoRequest->aNetworks[j].ssId.length)))
-            {
-                pPnoRequest->aNetworks[j].bcastNetwType = eBCAST_HIDDEN;
-                break;
-            }
-            j++;
-        }
-    }
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "Number of hidden networks being Configured = %d",
-              request->n_ssids);
     /* framework provides interval in ms */
     pPnoRequest->scanTimers.ucScanTimersCount = 1;
     pPnoRequest->scanTimers.aTimerValues[0].uTimerValue =
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c	2014-12-03 11:07:31.000000000 +0000
@@ -107,8 +107,6 @@
 #include "wlan_hdd_packet_filtering.h"
 
 #define HDD_SSR_BRING_UP_TIME 180000
-#define NS_DEFAULT_SLOT_INDEX 4
-#define NS_EXTENDED_SLOT_INDEX 18
 
 static eHalStatus g_full_pwr_status;
 static eHalStatus g_standby_status;
@@ -562,157 +560,22 @@
 }
 
 #ifdef WLAN_NS_OFFLOAD
-void hdd_ipv6_notifier_work_queue(struct work_struct *work)
-{
-    hdd_adapter_t* pAdapter =
-             container_of(work, hdd_adapter_t, ipv6NotifierWorkQueue);
-    hdd_context_t *pHddCtx;
-    int status;
-
-    hddLog(LOG1, FL("Reconfiguring NS Offload"));
-    pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
-    status = wlan_hdd_validate_context(pHddCtx);
-    if (0 != status)
-    {
-        hddLog(LOGE, FL("HDD context is invalid"));
-        return;
-    }
-
-    if ((eConnectionState_Associated ==
-                (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState)
-         && (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid))
-    {
-        // This invocation being part of the IPv6 registration callback,
-        // we are passing second parameter as 2 to avoid registration
-        // of IPv6 notifier again.
-        hdd_conf_ns_offload(pAdapter, 2);
-    }
-}
-
-static int wlan_hdd_ipv6_changed(struct notifier_block *nb,
-                                   unsigned long data, void *arg)
-{
-    struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)arg;
-    struct net_device *ndev = ifa->idev->dev;
-    hdd_adapter_t *pAdapter =
-             container_of(nb, struct hdd_adapter_s, ipv6_notifier);
-    hdd_context_t *pHddCtx;
-    int status;
-
-    if (pAdapter && pAdapter->dev == ndev)
-    {
-        pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
-        status = wlan_hdd_validate_context(pHddCtx);
-        if (0 != status)
-        {
-            hddLog(LOGE, FL("HDD context is invalid"));
-            return NOTIFY_DONE;
-        }
-
-        schedule_work(&pAdapter->ipv6NotifierWorkQueue);
-    }
-
-    return NOTIFY_DONE;
-}
-
-/**----------------------------------------------------------------------------
-
-  \brief hdd_conf_ns_offload() - Configure NS offload
-
-  Called during SUSPEND to configure the NS offload (MC BC filter) which
-  reduces power consumption.
-
-  \param  - pAdapter - Adapter context for which NS offload is to be configured
-  \param  - fenable - 0 - disable.
-                      1 - enable. (with IPv6 notifier registration)
-                      2 - enable. (without IPv6 notifier registration)
-
-  \return - void
-
-  ---------------------------------------------------------------------------*/
-void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, int fenable)
+void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable)
 {
     struct inet6_dev *in6_dev;
     struct inet6_ifaddr *ifp;
     struct list_head *p;
+    tANI_U8 selfIPv6Addr[SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA][SIR_MAC_IPV6_ADDR_LEN] = {{0,}};
+    tANI_BOOLEAN selfIPv6AddrValid[SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA] = {0};
     tSirHostOffloadReq offLoadRequest;
-    int slot_index = NS_DEFAULT_SLOT_INDEX;
-    tANI_U8 **selfIPv6Addr;
-    tANI_U8 *selfIPv6AddrValid;
     hdd_context_t *pHddCtx;
-    tHalHandle halHandle;
-    int status;
 
-    int i = 0, slot = 0;
-    int ret = 0;
+    int i =0;
     eHalStatus returnStatus;
 
-    ENTER();
-    hddLog(LOG1, FL(" fenable = %d"), fenable);
-
-    if (NULL == pAdapter)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD adapter is Null"));
-        return;
-    }
-
-    halHandle = WLAN_HDD_GET_HAL_CTX(pAdapter);
     pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
-    status = wlan_hdd_validate_context(pHddCtx);
-
-    if (0 != status)
-    {
-        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                   "%s: HDD context is not valid", __func__);
-        return;
-    }
-
-    if (sme_IsFeatureSupportedByFW(EXTENDED_NSOFFLOAD_SLOT))
-    {
-        slot_index = NS_EXTENDED_SLOT_INDEX;
-    }
-
-    hddLog(VOS_TRACE_LEVEL_INFO, FL("slot_idex = %d"), slot_index);
-
-    selfIPv6AddrValid =
-            (tANI_U8 *)vos_mem_malloc(sizeof(tANI_U8) * slot_index);
-
-    if (NULL == selfIPv6AddrValid)
-    {
-        hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory for"
-                                         " selfIPv6AddrValid"));
-        goto end;
-    }
-
-    memset(selfIPv6AddrValid, 0, slot_index * sizeof(tANI_U8));
-
-    selfIPv6Addr = (tANI_U8 **)vos_mem_malloc(sizeof(tANI_U8 *) * slot_index);
-
-    if (NULL == selfIPv6Addr)
-    {
-        hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory for"
-                                         " selfIPv6Addr"));
-        goto end;
-    }
-
-    memset(selfIPv6Addr, 0, slot_index * sizeof(tANI_U8 *));
-
-    for (slot = 0; slot < slot_index; slot++)
-    {
-        selfIPv6Addr[slot] =
-           (tANI_U8 *)vos_mem_malloc(SIR_MAC_IPV6_ADDR_LEN);
-        if (NULL == selfIPv6Addr[slot])
-        {
-            hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory"
-                                              "for selfIPv6Addr"));
-            goto end;
-        }
-        memset(selfIPv6Addr[slot], 0, SIR_MAC_IPV6_ADDR_LEN);
-    }
-
-    i = 0;
-
+    ENTER();
     if (fenable)
     {
         in6_dev = __in6_dev_get(pAdapter->dev);
@@ -721,47 +584,34 @@
             //read_lock_bh(&in6_dev->lock);
             list_for_each(p, &in6_dev->addr_list)
             {
-                if (i >= slot_index)
-                {
-                    hddLog (VOS_TRACE_LEVEL_ERROR,
-                            FL("IPv6 address list is greater than IPv6"
-                               "address supported by firmware"));
-                    hddLog (VOS_TRACE_LEVEL_ERROR,
-                            FL("FW supported IPv6 address = %d"), slot_index);
-                    break;
-                }
                 ifp = list_entry(p, struct inet6_ifaddr, if_list);
                 switch(ipv6_addr_src_scope(&ifp->addr))
                 {
                     case IPV6_ADDR_SCOPE_LINKLOCAL:
-                        vos_mem_copy(selfIPv6Addr[i], &ifp->addr.s6_addr,
+                        vos_mem_copy(&selfIPv6Addr[0], &ifp->addr.s6_addr,
                                 sizeof(ifp->addr.s6_addr));
-                        selfIPv6AddrValid[i] = SIR_IPV6_ADDR_VALID;
+                        selfIPv6AddrValid[0] = SIR_IPV6_ADDR_VALID;
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                           FL("Found IPV6_ADDR_SCOPE_LINKLOCAL Address : %pI6"),
-                               selfIPv6Addr[i]);
+                               "Found IPV6_ADDR_SCOPE_LINKLOCAL Address : %pI6",
+                               selfIPv6Addr[0]);
                         break;
                     case IPV6_ADDR_SCOPE_GLOBAL:
-                        vos_mem_copy(selfIPv6Addr[i], &ifp->addr.s6_addr,
+                        vos_mem_copy(&selfIPv6Addr[1], &ifp->addr.s6_addr,
                                 sizeof(ifp->addr.s6_addr));
-                        selfIPv6AddrValid[i] = SIR_IPV6_ADDR_VALID;
+                        selfIPv6AddrValid[1] = SIR_IPV6_ADDR_VALID;
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                           FL("Found IPV6_ADDR_SCOPE_GLOBAL Address : %pI6"),
-                               selfIPv6Addr[i]);
+                               "Found IPV6_ADDR_SCOPE_GLOBAL Address : %pI6",
+                               selfIPv6Addr[1]);
                         break;
                     default:
-                        hddLog(VOS_TRACE_LEVEL_ERROR,
-                           FL("The Scope %d is not supported"),
-                               ipv6_addr_src_scope(&ifp->addr));
+                        hddLog(LOGE, "The Scope %d is not supported",
+                                ipv6_addr_src_scope(&ifp->addr));
                 }
-                if (selfIPv6AddrValid[i] == SIR_IPV6_ADDR_VALID)
-                {
-                    i++;
-                }
-            }
 
+            }
+            //read_unlock_bh(&in6_dev->lock);
             vos_mem_zero(&offLoadRequest, sizeof(offLoadRequest));
-            for (i =0; i < slot_index; i++)
+            for (i =0; i<SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA; i++)
             {
                 if (selfIPv6AddrValid[i])
                 {
@@ -779,40 +629,32 @@
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[1] = 0x02;
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[11] = 0x01;
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[12] = 0xFF;
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[13] =
-                                                          selfIPv6Addr[i][13];
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[14] =
-                                                          selfIPv6Addr[i][14];
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[15] =
-                                                          selfIPv6Addr[i][15];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[13] = selfIPv6Addr[i][13];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[14] = selfIPv6Addr[i][14];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[15] = selfIPv6Addr[i][15];
                     offLoadRequest.nsOffloadInfo.slotIdx = i;
 
                     vos_mem_copy(&offLoadRequest.nsOffloadInfo.targetIPv6Addr[0],
-                        selfIPv6Addr[i], sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
+                                &selfIPv6Addr[i][0], sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
                     vos_mem_copy(&offLoadRequest.nsOffloadInfo.selfMacAddr,
                                 &pAdapter->macAddressCurrent.bytes,
                                 sizeof(tANI_U8)*SIR_MAC_ADDR_LEN);
 
-                    offLoadRequest.nsOffloadInfo.targetIPv6AddrValid[0] =
-                                                          SIR_IPV6_ADDR_VALID;
+                    offLoadRequest.nsOffloadInfo.targetIPv6AddrValid[0] = SIR_IPV6_ADDR_VALID;
                     offLoadRequest.offloadType =  SIR_IPV6_NS_OFFLOAD;
                     offLoadRequest.enableOrDisable = SIR_OFFLOAD_ENABLE;
 
                     hddLog (VOS_TRACE_LEVEL_INFO,
-                       FL("configuredMcastBcastFilter: %d"
-                       "NSOffload Slot = %d"),
-                       pHddCtx->configuredMcastBcastFilter, i);
+                    "configuredMcastBcastFilter: %d",pHddCtx->configuredMcastBcastFilter);
 
                     if ((VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid)
                        && ((HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST ==
                           pHddCtx->sus_res_mcastbcast_filter) ||
-                         (HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST_BROADCAST ==
-                          pHddCtx->sus_res_mcastbcast_filter))
-                       && (!pHddCtx->cfg_ini->fEnableMCAddrList))
+                          (HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST_BROADCAST ==
+                          pHddCtx->sus_res_mcastbcast_filter)))
                     {
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                        FL("Set offLoadRequest with"
-                           "SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE"));
+                        "Set offLoadRequest with SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE \n", __func__);
                         offLoadRequest.enableOrDisable =
                          SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE;
                     }
@@ -822,87 +664,45 @@
                                 sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
 
                     hddLog (VOS_TRACE_LEVEL_INFO,
-                    FL("Setting NSOffload with solicitedIp: %pI6,"
-                       "targetIp: %pI6"),
+                    "Setting NSOffload with solicitedIp: %pI6, targetIp: %pI6",
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr,
                     offLoadRequest.nsOffloadInfo.targetIPv6Addr[0]);
 
                     //Configure the Firmware with this
-                    returnStatus = sme_SetHostOffload(halHandle,
+                    returnStatus = sme_SetHostOffload(WLAN_HDD_GET_HAL_CTX(pAdapter),
                                     pAdapter->sessionId, &offLoadRequest);
                     if(eHAL_STATUS_SUCCESS != returnStatus)
                     {
                         hddLog(VOS_TRACE_LEVEL_ERROR,
-                        FL("Failed to enable HostOffload feature with"
-                           " status: %d"), returnStatus);
+                        FL("Failed to enable HostOffload feature with status: %d"),
+                        returnStatus);
                     }
                     vos_mem_zero(&offLoadRequest, sizeof(offLoadRequest));
                 }
             }
-            if (fenable == 1 && !pAdapter->ipv6_notifier_registered)
-            {
-                // Register IPv6 notifier to notify if any change in IP
-                // So that we can reconfigure the offload parameters
-                pAdapter->ipv6_notifier.notifier_call =
-                             wlan_hdd_ipv6_changed;
-                ret = register_inet6addr_notifier(&pAdapter->ipv6_notifier);
-                if (ret)
-                {
-                    hddLog(LOGE, FL("Failed to register IPv6 notifier"));
-                }
-                else
-                {
-                    hddLog(LOG1, FL("Registered IPv6 notifier"));
-                    pAdapter->ipv6_notifier_registered = true;
-                }
-            }
         }
         else
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,
                     FL("IPv6 dev does not exist. Failed to request NSOffload"));
-              goto end;
+            return;
         }
     }
     else
     {
         //Disable NSOffload
-        if (pAdapter->ipv6_notifier_registered)
-        {
-            hddLog(LOG1, FL("Unregistered IPv6 notifier"));
-            unregister_inet6addr_notifier(&pAdapter->ipv6_notifier);
-            pAdapter->ipv6_notifier_registered = false;
-        }
         vos_mem_zero((void *)&offLoadRequest, sizeof(tSirHostOffloadReq));
         offLoadRequest.enableOrDisable = SIR_OFFLOAD_DISABLE;
         offLoadRequest.offloadType =  SIR_IPV6_NS_OFFLOAD;
 
-	for (i = 0; i < slot_index; i++)
-        {
-            hddLog(VOS_TRACE_LEVEL_INFO, FL("Disable Slot= %d"), i);
-            offLoadRequest.nsOffloadInfo.slotIdx = i;
-            if (eHAL_STATUS_SUCCESS !=
+        if (eHAL_STATUS_SUCCESS !=
                  sme_SetHostOffload(WLAN_HDD_GET_HAL_CTX(pAdapter),
                  pAdapter->sessionId, &offLoadRequest))
-            {
-                hddLog(VOS_TRACE_LEVEL_ERROR, FL("Failure to disable"
-                                                 " %d Slot"), i);
-            }
+        {
+            hddLog(VOS_TRACE_LEVEL_ERROR, FL("Failure to disable"
+                             "NSOffload feature"));
         }
     }
-end:
-    while (slot > 0 && selfIPv6Addr[--slot])
-    {
-       vos_mem_free(selfIPv6Addr[slot]);
-    }
-    if (selfIPv6Addr)
-    {
-       vos_mem_free(selfIPv6Addr);
-    }
-    if (selfIPv6AddrValid)
-    {
-       vos_mem_free(selfIPv6AddrValid);
-    }
     return;
 }
 #endif
@@ -1105,11 +905,19 @@
         wlanSuspendParam->configuredMcstBcstFilterSetting = pHddCtx->configuredMcastBcastFilter;
 
 #ifdef WLAN_FEATURE_PACKET_FILTERING
-        /* During suspend, configure MC Addr list filter to the firmware
-         * function takes care of checking necessary conditions before
-         * configuring.
-         */
-        wlan_hdd_set_mc_addr_list(pAdapter, TRUE);
+        if (pHddCtx->cfg_ini->isMcAddrListFilter)
+        {
+           /*Multicast addr list filter is enabled during suspend*/
+           if (((pAdapter->device_mode == WLAN_HDD_INFRA_STATION) ||
+                    (pAdapter->device_mode == WLAN_HDD_P2P_CLIENT))
+                 && pAdapter->mc_addr_list.mc_cnt
+                 && (eConnectionState_Associated ==
+                    (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState))
+           {
+              /*set the filter*/
+              wlan_hdd_set_mc_addr_list(pAdapter, TRUE);
+           }
+        }
 #endif
     }
 
@@ -1153,11 +961,9 @@
 
     pHddCtx->hdd_mcastbcast_filter_set = FALSE;
 
-    if (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid) {
-        pHddCtx->configuredMcastBcastFilter =
-            pHddCtx->sus_res_mcastbcast_filter;
-        pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
-    }
+    pHddCtx->configuredMcastBcastFilter =
+      pHddCtx->sus_res_mcastbcast_filter;
+    pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
 
     hddLog(VOS_TRACE_LEVEL_INFO,
            "offload: in hdd_conf_resume_ind, restoring configuredMcastBcastFilter");
@@ -1166,10 +972,16 @@
 
 
 #ifdef WLAN_FEATURE_PACKET_FILTERING
-    /* Filer was applied during suspend inditication
-     * clear it when we resume.
-     */
-    wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+    if (pHddCtx->cfg_ini->isMcAddrListFilter)
+    {
+       /*Multicast addr filtering is enabled*/
+       if (pAdapter->mc_addr_list.isFilterApplied)
+       {
+          /*Filter applied during suspend mode*/
+          /*Clear it here*/
+          wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+       }
+    }
 #endif
 }
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c	2014-12-03 11:07:31.000000000 +0000
@@ -1338,14 +1338,7 @@
 {
     hdd_adapter_t *pHostapdAdapter = (netdev_priv(dev));
     v_U8_t *peerMacAddr;    
-   
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
+    
     ENTER();
     /* iwpriv tool or framework calls this ioctl with
      * data passed in extra (less than 16 octets);
@@ -2151,17 +2144,9 @@
    u_int8_t *pos;
    tpSap_WPSIE pSap_WPSIe;
    u_int8_t WPSIeType;
-   u_int16_t length;  
-   int ret = 0;
+   u_int16_t length;   
    ENTER();
 
-   if (!capable(CAP_NET_ADMIN))
-   {
-     VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-	       FL("permission check failed"));
-     return -EPERM;
-   }
-
    if(!wrqu->data.length)
       return 0;
 
@@ -2184,8 +2169,8 @@
          case DOT11F_EID_WPA: 
             if (wps_genie[1] < 2 + 4)
             {
-	       ret = -EINVAL;
-	       goto exit;
+               vos_mem_free(pSap_WPSIe); 
+               return -EINVAL;
             }
             else if (memcmp(&wps_genie[2], "\x00\x50\xf2\x04", 4) == 0) 
             {
@@ -2243,11 +2228,6 @@
                       pos += 2; 
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > sizeof(pSap_WPSIe->sapwpsie.sapWPSBeaconIE.UUID_E))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSBeaconIE.UUID_E, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSBeaconIE.FieldPresent |= WPS_BEACON_UUIDE_PRESENT; 
                       pos += length;
@@ -2262,8 +2242,8 @@
                    
                    default:
                       hddLog (LOGW, "UNKNOWN TLV in WPS IE(%x)\n", (*pos<<8 | *(pos+1)));
-		      ret = -EINVAL;
-		      goto exit;
+                      vos_mem_free(pSap_WPSIe);
+                      return -EINVAL; 
                 }
               }  
             }
@@ -2275,8 +2255,8 @@
                  
          default:
             hddLog (LOGE, "%s Set UNKNOWN IE %X",__func__, wps_genie[0]);
-	    ret = -EINVAL;
-	    goto exit;
+            vos_mem_free(pSap_WPSIe);
+            return 0;
       }
     } 
     else if( wps_genie[0] == eQC_WPS_PROBE_RSP_IE)
@@ -2288,8 +2268,8 @@
          case DOT11F_EID_WPA: 
             if (wps_genie[1] < 2 + 4)
             {
-	       ret = -EINVAL;
-	       goto exit;
+               vos_mem_free(pSap_WPSIe); 
+               return -EINVAL;
             }
             else if (memcmp(&wps_genie[2], "\x00\x50\xf2\x04", 4) == 0) 
             {
@@ -2353,11 +2333,6 @@
                       pos += 2; 
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.UUID_E)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.UUID_E, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_UUIDE_PRESENT;
                       pos += length;
@@ -2367,11 +2342,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length >  (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.name)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.num_name = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.name, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MANUFACTURE_PRESENT;
@@ -2382,11 +2352,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MODELNAME_PRESENT;
@@ -2396,11 +2361,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MODELNUMBER_PRESENT;
@@ -2410,11 +2370,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_SERIALNUMBER_PRESENT;
@@ -2425,6 +2380,7 @@
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceCategory = (*pos<<8 | *(pos+1));
                       hddLog(LOG1, "primary dev category: %d\n", pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceCategory);  
                       pos += 2;
+                      
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceOUI, pos, HDD_WPS_DEVICE_OUI_LEN);
                       hddLog(LOG1, "primary dev oui: %02x, %02x, %02x, %02x\n", pos[0], pos[1], pos[2], pos[3]);
                       pos += 4;
@@ -2437,11 +2393,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.text, pos, length);
                       pos += length;
@@ -2473,8 +2424,6 @@
       } // switch
     }
     halStatus = WLANSAP_Set_WpsIe(pVosContext, pSap_WPSIe);
-    if (halStatus != eHAL_STATUS_SUCCESS)
-      ret = -EINVAL;
     pHostapdState = WLAN_HDD_GET_HOSTAP_STATE_PTR(pHostapdAdapter);
     if( pHostapdState->bCommit && WPSIeType == eQC_WPS_PROBE_RSP_IE)
     {
@@ -2483,10 +2432,9 @@
         WLANSAP_Update_WpsIe ( pVosContext );
     }
  
- exit:
     vos_mem_free(pSap_WPSIe);   
     EXIT();
-    return ret;
+    return halStatus;
 }
 
 static int iw_softap_stopbss(struct net_device *dev,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c	2014-12-03 11:07:31.000000000 +0000
@@ -101,8 +101,6 @@
 #include <bapInternal.h>
 #endif // WLAN_BTAMP_FEATURE
 
-#include <linux/inetdevice.h>
-#include <net/addrconf.h>
 #include <linux/wireless.h>
 #include <net/cfg80211.h>
 #include "wlan_hdd_cfg80211.h"
@@ -197,6 +195,7 @@
 #endif
 
 void hdd_wlan_initial_scan(hdd_adapter_t *pAdapter);
+int isWDresetInProgress(void);
 
 extern int hdd_setBand_helper(struct net_device *dev, tANI_U8* ptr);
 #if  defined (WLAN_FEATURE_VOWIFI_11R) || defined (FEATURE_WLAN_CCX) || defined(FEATURE_WLAN_LFR)
@@ -227,6 +226,9 @@
       (strncmp(dev->name, "p2p", 3)))
       return NOTIFY_DONE;
 
+   if (isWDresetInProgress())
+      return NOTIFY_DONE;
+
    if (!dev->ieee80211_ptr)
       return NOTIFY_DONE;
 
@@ -245,9 +247,6 @@
       return NOTIFY_DONE;
    }
 
-   if (pHddCtx->isLogpInProgress)
-      return NOTIFY_DONE;
-
    hddLog(VOS_TRACE_LEVEL_INFO, "%s: %s New Net Device State = %lu",
           __func__, dev->name, state);
 
@@ -3771,11 +3770,6 @@
             hdd_deinit_adapter(pHddCtx, pAdapter);
             goto err_free_netdev;
          }
-
-#ifdef WLAN_NS_OFFLOAD
-         // Workqueue which gets scheduled in IPv6 notification callback.
-         INIT_WORK(&pAdapter->ipv6NotifierWorkQueue, hdd_ipv6_notifier_work_queue);
-#endif
          //Stop the Interface TX queue.
          netif_tx_disable(pAdapter->dev);
          //netif_tx_disable(pWlanDev);
@@ -3869,6 +3863,7 @@
       }
    }
 
+
    if( VOS_STATUS_SUCCESS == status )
    {
       //Add it to the hdd's session list. 
@@ -4065,17 +4060,6 @@
          {
             hdd_abort_mac_scan(pHddCtx);
          }
-#ifdef WLAN_NS_OFFLOAD
-#ifdef WLAN_OPEN_SOURCE
-         cancel_work_sync(&pAdapter->ipv6NotifierWorkQueue);
-#endif
-         if (pAdapter->ipv6_notifier_registered)
-         {
-            hddLog(LOG1, FL("Unregistered IPv6 notifier"));
-            unregister_inet6addr_notifier(&pAdapter->ipv6_notifier);
-            pAdapter->ipv6_notifier_registered = false;
-         }
-#endif
 
          if (test_bit(SME_SESSION_OPENED, &pAdapter->event_flags)) 
          {
@@ -6293,7 +6277,7 @@
    }
    else
    {
-      while(pHddCtx->isLogpInProgress) {
+      while(isWDresetInProgress()) {
          VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
               "%s:SSR in Progress; block rmmod for 1 second!!!", __func__);
          msleep(1000);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c	2014-12-03 11:07:31.000000000 +0000
@@ -203,12 +203,6 @@
     hdd_adapter_t *pAdapter = (netdev_priv(dev));
     hdd_wext_state_t *pwextBuf = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
 
-    if (!capable(CAP_NET_ADMIN)) {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c	2014-12-03 11:07:31.000000000 +0000
@@ -685,8 +685,7 @@
 
       if (wrqu->data.flags & IW_SCAN_THIS_ESSID)  {
 
-          if(scanReq->essid_len &&
-               (scanReq->essid_len <= SIR_MAC_MAX_SSID_LENGTH)) {
+          if(scanReq->essid_len) {
               scanRequest.SSIDs.numOfSSIDs = 1;
               scanRequest.SSIDs.SSIDList =( tCsrSSIDInfo *)vos_mem_malloc(sizeof(tCsrSSIDInfo));
               if(scanRequest.SSIDs.SSIDList) {
@@ -700,10 +699,6 @@
                 VOS_ASSERT(0);
               }
           }
-          else
-          {
-            hddLog(LOGE, FL("Invalid essid length : %d"), scanReq->essid_len);
-          }
       }
 
        /* set min and max channel time */
@@ -745,20 +740,10 @@
        memcpy( pHddCtx->scan_info.scanAddIE.addIEdata, pwextBuf->genIE.addIEdata, 
            pwextBuf->genIE.length );
        pHddCtx->scan_info.scanAddIE.length = pwextBuf->genIE.length;
-      /* Maximum length of each IE is SIR_MAC_MAX_IE_LENGTH */
-       if (SIR_MAC_MAX_IE_LENGTH  >=  pwextBuf->genIE.length)
-       {
-           memcpy( pwextBuf->roamProfile.addIEScan,
-                       pHddCtx->scan_info.scanAddIE.addIEdata,
-                       pHddCtx->scan_info.scanAddIE.length);
-           pwextBuf->roamProfile.nAddIEScanLength =
-                                pHddCtx->scan_info.scanAddIE.length;
-       }
-       else
-       {
-           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                     "Invalid ScanIE, Length is %d", pwextBuf->genIE.length);
-       }
+
+       pwextBuf->roamProfile.pAddIEScan = pHddCtx->scan_info.scanAddIE.addIEdata;
+       pwextBuf->roamProfile.nAddIEScanLength = pHddCtx->scan_info.scanAddIE.length;
+   
        /* clear previous genIE after use it */
        memset( &pwextBuf->genIE, 0, sizeof(pwextBuf->genIE) );
    }
@@ -1136,20 +1121,10 @@
             memcpy( pHddCtx->scan_info.scanAddIE.addIEdata, pwextBuf->genIE.addIEdata, 
                 pwextBuf->genIE.length );
             pHddCtx->scan_info.scanAddIE.length = pwextBuf->genIE.length;
-            if (SIR_MAC_MAX_IE_LENGTH  >=  pwextBuf->genIE.length)
-            {
-                memcpy( pwextBuf->roamProfile.addIEScan,
-                           pHddCtx->scan_info.scanAddIE.addIEdata,
-                           pHddCtx->scan_info.scanAddIE.length);
-                pwextBuf->roamProfile.nAddIEScanLength =
-                                  pHddCtx->scan_info.scanAddIE.length;
-            }
-            else
-            {
-                VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                         "Invalid ScanIE, Length is %d",
-                          pwextBuf->genIE.length);
-            }
+
+            pwextBuf->roamProfile.pAddIEScan = pHddCtx->scan_info.scanAddIE.addIEdata;
+            pwextBuf->roamProfile.nAddIEScanLength = pHddCtx->scan_info.scanAddIE.length;
+
             /* clear previous genIE after use it */
             memset( &pwextBuf->genIE, 0, sizeof(pwextBuf->genIE) );
         }
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c	2014-12-03 11:07:31.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -250,12 +250,17 @@
 #define WLAN_PRIV_DEL_TSPEC (SIOCIWFIRSTPRIV + 11)
 #define WLAN_PRIV_GET_TSPEC (SIOCIWFIRSTPRIV + 13)
 
-/* (SIOCIWFIRSTPRIV + 8)  is currently unused */
-/* (SIOCIWFIRSTPRIV + 16) is currently unused */
-/* (SIOCIWFIRSTPRIV + 10) is currently unused */
-/* (SIOCIWFIRSTPRIV + 12) is currently unused */
-/* (SIOCIWFIRSTPRIV + 14) is currently unused */
-/* (SIOCIWFIRSTPRIV + 15) is currently unused */
+#ifdef FEATURE_WLAN_WAPI
+/* Private ioctls EVEN NO: SET, ODD NO:GET */
+#define WLAN_PRIV_SET_WAPI_MODE         (SIOCIWFIRSTPRIV + 8)
+#define WLAN_PRIV_GET_WAPI_MODE         (SIOCIWFIRSTPRIV + 16)
+#define WLAN_PRIV_SET_WAPI_ASSOC_INFO   (SIOCIWFIRSTPRIV + 10)
+#define WLAN_PRIV_SET_WAPI_KEY          (SIOCIWFIRSTPRIV + 12)
+#define WLAN_PRIV_SET_WAPI_BKID         (SIOCIWFIRSTPRIV + 14)
+#define WLAN_PRIV_GET_WAPI_BKID         (SIOCIWFIRSTPRIV + 15)
+#define WAPI_PSK_AKM_SUITE  0x02721400
+#define WAPI_CERT_AKM_SUITE 0x01721400
+#endif
 
 #ifdef FEATURE_OEM_DATA_SUPPORT
 /* Private ioctls for setting the measurement configuration */
@@ -363,56 +368,6 @@
 
 /**---------------------------------------------------------------------------
 
-  \brief mem_alloc_copy_from_user_helper -
-
-   Helper function to allocate buffer and copy user data.
-
-  \param  - wrqu - Pointer to IOCTL Data.
-            len  - size
-
-  \return - On Success pointer to buffer, On failure NULL
-
-  --------------------------------------------------------------------------*/
-static void *mem_alloc_copy_from_user_helper(const void *wrqu_data, size_t len)
-{
-    u8 *ptr = NULL;
-
-  /* in order to protect the code, an extra byte is post appended to the buffer
-   * and the null termination is added.  However, when allocating (len+1) byte
-   * of memory, we need to make sure that there is no uint overflow when doing
-   * addition. In theory check len < UINT_MAX protects the uint overflow. For
-   * wlan private ioctl, the buffer size is much less than UINT_MAX, as a good
-   * guess, now, it is assumed that the private command buffer size is no
-   * greater than 4K (4096 bytes). So we use 4096 as the upper boundary for now.
-   */
-    if (len > MAX_USER_COMMAND_SIZE)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "Invalid length");
-        return NULL;
-    }
-
-    ptr = kmalloc(len + 1, GFP_KERNEL);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "unable to allocate memory");
-        return NULL;
-    }
-
-    if (copy_from_user(ptr, wrqu_data, len))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: failed to copy data to user buffer", __func__);
-        kfree(ptr);
-        return NULL;
-    }
-    ptr[len] = '\0';
-    return ptr;
-}
-
-/**---------------------------------------------------------------------------
-
   \brief hdd_wlan_get_version() -
 
    This function use to get Wlan Driver, Firmware, & Hardware Version.
@@ -953,8 +908,8 @@
    pWextState->roamProfile.pRSNReqIE = (tANI_U8 *)NULL;
 
    pWextState->roamProfile.bWPSAssociation = VOS_FALSE;
+   pWextState->roamProfile.pAddIEScan = (tANI_U8 *)NULL;
    pWextState->roamProfile.nAddIEScanLength = 0;
-   memset(pWextState->roamProfile.addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH+2);
    pWextState->roamProfile.pAddIEAssoc = (tANI_U8 *)NULL;
    pWextState->roamProfile.nAddIEAssocLength = 0;
 
@@ -1575,37 +1530,24 @@
         union iwreq_data *wrqu,
         char *extra)
 {
-    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+   hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
     hdd_wext_state_t *pWextState = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
-    u_int8_t *genie = NULL;
-    u_int8_t *base_genie = NULL;
+    u_int8_t *genie;
     v_U16_t remLen;
- 
-    ENTER();
-
-    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress) {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, 
-                  "%s:LOGP in Progress. Ignore!!!",__func__);
-        return 0;
-    }
 
-    if (!wrqu->data.length) {
-        hdd_clearRoamProfileIe(pAdapter);
-        EXIT();
-        return 0;
-    }
+   ENTER();
+   if(!wrqu->data.length) {
+      hdd_clearRoamProfileIe(pAdapter);
+      EXIT();
+      return 0;
+   }
 
-    base_genie = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                                 wrqu->data.length);
-    if (NULL == base_genie)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-    
-    genie = base_genie;
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress) {
+      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, "%s:LOGP in Progress. Ignore!!!",__func__);
+      return 0;
+   }
 
+    genie = wrqu->data.pointer;
     remLen = wrqu->data.length;
 
     hddLog(LOG1,"iw_set_genie ioctl IE[0x%X], LEN[%d]\n", genie[0], genie[1]);
@@ -1614,7 +1556,7 @@
     memset( &pWextState->genIE, 0, sizeof(pWextState->genIE) );
 
     while (remLen >= 2)
-    {
+   {
         v_U16_t eLen = 0;
         v_U8_t elementId;
         elementId = *genie++;
@@ -1628,10 +1570,7 @@
          {
             case IE_EID_VENDOR:
                 if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen) /* should have at least OUI */
-		{
-                    kfree(base_genie);
-                    return -EINVAL;
-		}
+                return -EINVAL;
 
                 if (0 == memcmp(&genie[0], "\x00\x50\xf2\x04", 4))
                 {
@@ -1644,8 +1583,7 @@
                        hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
                                                       "Need bigger buffer space\n");
                        VOS_ASSERT(0);
-                       kfree(base_genie);
-		       return -ENOMEM;
+                       return -ENOMEM;
                     }
                     // save to Additional IE ; it should be accumulated to handle WPS IE + other IE
                     memcpy( pWextState->genIE.addIEdata + curGenIELen, genie - 2, eLen + 2);
@@ -1654,14 +1592,6 @@
                 else if (0 == memcmp(&genie[0], "\x00\x50\xf2", 3))
                 {
                     hddLog (VOS_TRACE_LEVEL_INFO, "%s Set WPA IE (len %d)",__func__, eLen + 2);
-                    if ((eLen + 2) > (sizeof(pWextState->WPARSNIE)))
-		      {
-			hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
-			      "Need bigger buffer space");
-			VOS_ASSERT(0);
-                        kfree(base_genie);
-                        return -ENOMEM;
-		      }
                     memset( pWextState->WPARSNIE, 0, MAX_WPA_RSN_IE_LEN );
                     memcpy( pWextState->WPARSNIE, genie - 2, (eLen + 2));
                     pWextState->roamProfile.pWPAReqIE = pWextState->WPARSNIE;
@@ -1678,7 +1608,6 @@
                        hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
                                                       "Need bigger buffer space\n");
                        VOS_ASSERT(0);
-                       kfree(base_genie);
                        return -ENOMEM;
                     }
                     // save to Additional IE ; it should be accumulated to handle WPS IE + other IE
@@ -1688,14 +1617,6 @@
               break;
          case DOT11F_EID_RSN:
                 hddLog (LOG1, "%s Set RSN IE (len %d)",__func__, eLen+2);
-                if ((eLen + 2) > (sizeof(pWextState->WPARSNIE)))
-		  {
-                    hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
-			   "Need bigger buffer space");
-                    VOS_ASSERT(0);
-                    kfree(base_genie);
-                    return -ENOMEM;
-		  }
                 memset( pWextState->WPARSNIE, 0, MAX_WPA_RSN_IE_LEN );
                 memcpy( pWextState->WPARSNIE, genie - 2, (eLen + 2));
                 pWextState->roamProfile.pRSNReqIE = pWextState->WPARSNIE;
@@ -1704,14 +1625,12 @@
 
          default:
                 hddLog (LOGE, "%s Set UNKNOWN IE %X",__func__, elementId);
-		kfree(base_genie);
-                return 0;
-        }
+            return 0;
+    }
         genie += eLen;
         remLen -= eLen;
     }
     EXIT();
-    kfree(base_genie);
     return 0;
 }
 
@@ -1756,16 +1675,9 @@
                                    pAdapter->sessionId,
                                    &length,
                                    genIeBytes);
+    wrqu->data.length = VOS_MIN((u_int16_t) length, DOT11F_IE_RSN_MAX_LEN);
 
-    length = VOS_MIN((u_int16_t) length, DOT11F_IE_RSN_MAX_LEN);
-    if (wrqu->data.length < length)
-    {
-        hddLog(LOG1, "%s: failed to copy data to user buffer", __func__);
-        return -EFAULT;
-    }
-
-    vos_mem_copy(extra, (v_VOID_t*)genIeBytes, wrqu->data.length);
-    wrqu->data.length = length;
+    vos_mem_copy( wrqu->data.pointer, (v_VOID_t*)genIeBytes, wrqu->data.length);
 
     hddLog(LOG1,"%s: RSN IE of %d bytes returned\n", __func__, wrqu->data.length );
 
@@ -2465,7 +2377,7 @@
    }
 
   /* a value is being successfully returned */
-   return rc;
+   return 0;
 }
 
 
@@ -2481,7 +2393,7 @@
                        union iwreq_data *wrqu, char *extra)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-   char *cmd = extra;
+   char *cmd = (char*)wrqu->data.pointer;
    int len = wrqu->data.length;
    v_S7_t s7Rssi = 0;
    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
@@ -2528,7 +2440,7 @@
    }
 
    /* a value is being successfully returned */
-   return rc;
+   return 0;
 }
 
 /*
@@ -2738,23 +2650,13 @@
                        union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    char *cmd = NULL;
+    char *cmd = (char*)wrqu->data.pointer;
     int cmd_len = wrqu->data.length;
     int ret = 0;
-    int rc = 0;
-    VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
-
+    int status = 0;
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
     ENTER();
-    cmd = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == cmd)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
 
     if (ioctl_debug)
     {
@@ -2765,32 +2667,27 @@
            "%s: ***Received %s cmd from Wi-Fi GUI***", __func__, cmd);
 
     if (pHddCtx->isLogpInProgress) {
-        if (ioctl_debug)
-        {
-            pr_info("%s: RESTART in progress\n", __func__);
-        }
+       if (ioctl_debug)
+       {
+          pr_info("%s: RESTART in progress\n", __func__);
+       }
 
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-                  "%s:LOGP in Progress. Ignore!!!",__func__);
-        kfree(cmd);
-        return -EBUSY;
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                 "%s:LOGP in Progress. Ignore!!!",__func__);
+       return status;
     }
 
     if(strncmp(cmd, "CSCAN",5) == 0 )
     {
-        if (eHAL_STATUS_SUCCESS != iw_set_cscan(dev, info, wrqu, cmd)) {
-            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                      "%s: Error in iw_set_scan!", __func__);
-            rc = -EINVAL;
-        }
+       status = iw_set_cscan(dev, info, wrqu, extra);
     }
     else if( strcasecmp(cmd, "start") == 0 ) {
 
         hddLog(VOS_TRACE_LEVEL_INFO_HIGH, "Start command\n");
         /*Exit from Deep sleep or standby if we get the driver START cmd from android GUI*/
+        status = wlan_hdd_exit_lowpower(pHddCtx, pAdapter);
 
-        vos_status = wlan_hdd_exit_lowpower(pHddCtx, pAdapter);
-        if (vos_status == VOS_STATUS_SUCCESS)
+        if(status == VOS_STATUS_SUCCESS)
         {
             union iwreq_data wrqu;
             char buf[10];
@@ -2801,8 +2698,7 @@
         }
         else
         {
-            hddLog(VOS_TRACE_LEVEL_FATAL, "%s: START CMD Status %d", __func__, vos_status);
-            rc = -EIO;
+            hddLog(VOS_TRACE_LEVEL_FATAL, "%s: START CMD Status %d", __func__, status);
         }
         goto done;
     }
@@ -2817,6 +2713,7 @@
         memset(&wrqu, 0, sizeof(wrqu));
         wrqu.data.length = strlcpy(buf, "STOP", sizeof(buf));
         wireless_send_event(pAdapter->dev, IWEVCUSTOM, &wrqu, buf);
+        status = VOS_STATUS_SUCCESS;
         goto done;
     }
     else if (strcasecmp(cmd, "macaddr") == 0)
@@ -2840,18 +2737,17 @@
     }
     else if( strcasecmp(cmd, "linkspeed") == 0 )
     {
-        ret = iw_get_linkspeed(dev, info, wrqu, extra);
+        status = iw_get_linkspeed(dev, info, wrqu, extra);
     }
     else if( strncasecmp(cmd, "COUNTRY", 7) == 0 ) {
         char *country_code;
         long lrc;
-        eHalStatus eHal_status;
 
         country_code =  cmd + 8;
 
         init_completion(&pAdapter->change_country_code);
 
-        eHal_status = sme_ChangeCountryCode(pHddCtx->hHal,
+        status = (int)sme_ChangeCountryCode(pHddCtx->hHal,
                                             (void *)(tSmeChangeCountryCallback)wlan_hdd_change_country_code_callback,
                                             country_code,
                                             pAdapter,
@@ -2864,20 +2760,19 @@
         if (lrc <= 0)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"%s: SME %s while setting country code ",
-                   __func__, "Timed out");
+                 __func__, "Timed out");
         }
 
-        if (eHAL_STATUS_SUCCESS != eHal_status)
+        if( 0 != status )
         {
             VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                       "%s: SME Change Country code fail \n", __func__);
-            kfree(cmd);
-            return -EIO;
+                       "%s: SME Change Country code fail \n",__func__);
+            return VOS_STATUS_E_FAILURE;
         }
     }
     else if( strncasecmp(cmd, "rssi", 4) == 0 )
     {
-        ret = iw_get_rssi(dev, info, wrqu, extra);
+        status = iw_get_rssi(dev, info, wrqu, extra);
     }
     else if( strncasecmp(cmd, "powermode", 9) == 0 ) {
         int mode;
@@ -2948,23 +2843,20 @@
     else if( strncasecmp(cmd, "pno",3) == 0 ) {
 
         hddLog( VOS_TRACE_LEVEL_INFO, "pno\n");
-        vos_status = iw_set_pno(dev, info, wrqu, cmd, 3);
-        kfree(cmd);
-        return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+        status = iw_set_pno(dev, info, wrqu, extra, 3);
+        return status;
     }
     else if( strncasecmp(cmd, "rssifilter",10) == 0 ) {
 
         hddLog( VOS_TRACE_LEVEL_INFO, "rssifilter\n");
-        vos_status = iw_set_rssi_filter(dev, info, wrqu, cmd, 10);
-        kfree(cmd);
-        return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+        status = iw_set_rssi_filter(dev, info, wrqu, extra, 10);
+        return status;
     }
 #endif /*FEATURE_WLAN_SCAN_PNO*/
     else if( strncasecmp(cmd, "powerparams",11) == 0 ) {
       hddLog( VOS_TRACE_LEVEL_INFO, "powerparams\n");
-      vos_status = iw_set_power_params(dev, info, wrqu, cmd, 11);
-      kfree(cmd);
-      return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+      status = iw_set_power_params(dev, info, wrqu, extra, 11);
+      return status;
     }
     else if( 0 == strncasecmp(cmd, "CONFIG-TX-TRACKING", 18) ) {
         tSirTxPerTrackingParam tTxPerTrackingParam;
@@ -2977,8 +2869,7 @@
         if (0 == tTxPerTrackingParam.ucTxPerTrackingPeriod)
         {
             VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Period input is not correct");
-            kfree(cmd);
-            return -EIO;
+            return VOS_STATUS_E_FAILURE;
         }
 
         // use default value 5 is the input is not reasonable. in unit of 10%
@@ -2995,12 +2886,9 @@
             tTxPerTrackingParam.uTxPerTrackingWatermark = TX_PER_TRACKING_DEFAULT_WATERMARK;
         }
 
-        if (eHAL_STATUS_SUCCESS !=
-            sme_SetTxPerTracking(pHddCtx->hHal,
-                                 hdd_tx_per_hit_cb,
-                                 (void*)pAdapter, &tTxPerTrackingParam)) {
-            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Set Tx PER Tracking Failed!");
-            rc = -EIO;
+        status = sme_SetTxPerTracking(pHddCtx->hHal, hdd_tx_per_hit_cb, (void*)pAdapter, &tTxPerTrackingParam);
+        if(status != eHAL_STATUS_SUCCESS){
+           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Set Tx PER Tracking Failed!");
         }
     }
     else {
@@ -3014,27 +2902,16 @@
     if ((ret < 0) || (ret >= cmd_len))
     {
        /* there was an encoding error or overflow */
-       rc = -EINVAL;
-    }
-    else if (ret > 0)
-    {
-        if (copy_to_user(wrqu->data.pointer, cmd, ret))
-        {
-            hddLog(VOS_TRACE_LEVEL_ERROR,
-                   "%s: failed to copy data to user buffer", __func__);
-            kfree(cmd);
-            return -EFAULT;
-        }
-        wrqu->data.length = ret;
+       status = -EIO;
     }
 
     if (ioctl_debug)
     {
        pr_info("%s: rsp [%s] len [%d] status %d\n",
-               __func__, cmd, wrqu->data.length, rc);
+               __func__, cmd, wrqu->data.length, status);
     }
-    kfree(cmd);
-    return rc;
+    return status;
+
 }
 
 static int iw_set_nick(struct net_device *dev,
@@ -3981,19 +3858,14 @@
     VOS_STATUS vstatus;
     int sub_cmd = wrqu->data.flags;
     int ret = 0; /* success */
-    char *pBuffer = NULL;
     hdd_adapter_t *pAdapter = (netdev_priv(dev));
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 #ifdef WLAN_FEATURE_VOWIFI
     hdd_config_t  *pConfig = pHddCtx->cfg_ini;
 #endif /* WLAN_FEATURE_VOWIFI */
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "%s: Received length %d", __func__, wrqu->data.length);
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
@@ -4002,30 +3874,15 @@
         return -EBUSY;
     }
 
-    /* ODD number is used for set, copy data using copy_from_user */
-    pBuffer = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                              wrqu->data.length);
-    if (NULL == pBuffer)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "%s: Received length %d", __func__, wrqu->data.length);
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "%s: Received data %s", __func__, pBuffer);
-
     switch(sub_cmd)
     {
        case WE_WOWL_ADD_PTRN:
           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "ADD_PTRN\n");
-          hdd_add_wowl_ptrn(pAdapter, pBuffer);
+          hdd_add_wowl_ptrn(pAdapter, (char*)wrqu->data.pointer);
           break;
        case WE_WOWL_DEL_PTRN:
           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "DEL_PTRN\n");
-          hdd_del_wowl_ptrn(pAdapter, pBuffer);
+          hdd_del_wowl_ptrn(pAdapter, (char*)wrqu->data.pointer);
           break;
 #if defined WLAN_FEATURE_VOWIFI
        case WE_NEIGHBOR_REPORT_REQUEST:
@@ -4040,7 +3897,7 @@
                 if( !neighborReq.no_ssid )
                 {
                    neighborReq.ssid.length = (wrqu->data.length - 1) > 32 ? 32 : (wrqu->data.length - 1) ;
-                   vos_mem_copy( neighborReq.ssid.ssId, pBuffer, neighborReq.ssid.length );
+                   vos_mem_copy( neighborReq.ssid.ssId, wrqu->data.pointer, neighborReq.ssid.length );
                 }
 
                 callbackInfo.neighborRspCallback = NULL;
@@ -4061,7 +3918,7 @@
           sme_updateP2pIe( WLAN_HDD_GET_HAL_CTX(pAdapter), wrqu->data.pointer, wrqu->data.length );
           break;
        case WE_SET_CONFIG:
-          vstatus = hdd_execute_config_command(pHddCtx, pBuffer);
+          vstatus = hdd_execute_config_command(pHddCtx, wrqu->data.pointer);
           if (VOS_STATUS_SUCCESS != vstatus)
           {
              ret = -EINVAL;
@@ -4074,7 +3931,6 @@
            break;
        }
     }
-    kfree(pBuffer);
     return ret;
 }
 
@@ -4186,13 +4042,6 @@
     int sub_cmd = value[0];
     int ret = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
@@ -4644,6 +4493,7 @@
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
     tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
     int sub_cmd = wrqu->data.flags;
+    int *value = (int*)wrqu->data.pointer;
     int apps_args[MAX_VAR_ARGS] = {0};
     int num_args = wrqu->data.length;
     hdd_station_ctx_t *pStaCtx = NULL ;
@@ -4651,13 +4501,6 @@
     int cmd = 0;
     int staId = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
     hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -4671,14 +4514,7 @@
     {
        num_args = MAX_VAR_ARGS;
     }
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    if (copy_from_user(apps_args, wrqu->data.pointer, (sizeof(int)) * num_args))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: failed to copy data to user buffer", __func__);
-        return -EFAULT;
-    }
+    vos_mem_copy(apps_args, value, (sizeof(int)) * num_args);
 
     if(( sub_cmd == WE_MCC_CONFIG_CREDENTIAL ) ||
         (sub_cmd == WE_MCC_CONFIG_PARAMS ))
@@ -4998,6 +4834,287 @@
    return 0;
 }
 
+
+#ifdef FEATURE_WLAN_WAPI
+static int iw_qcom_set_wapi_mode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    hdd_wext_state_t *pWextState = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
+    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+    tCsrRoamProfile *pRoamProfile = &pWextState->roamProfile;
+
+    WAPI_FUNCTION_MODE *pWapiMode = (WAPI_FUNCTION_MODE *)wrqu->data.pointer;
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_mode called");
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Input Data (wreq) WAPI Mode:%02d", __func__, pWapiMode->wapiMode);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+    if(WZC_ORIGINAL == pWapiMode->wapiMode) {
+        hddLog(LOG1, "%s: WAPI Mode Set to OFF", __func__);
+         /* Set Encryption mode to defualt , this allows next successfull non-WAPI Association */
+        pRoamProfile->EncryptionType.numEntries = 1;
+        pRoamProfile->EncryptionType.encryptionType[0] = eCSR_ENCRYPT_TYPE_NONE;
+        pRoamProfile->mcEncryptionType.numEntries = 1;
+        pRoamProfile->mcEncryptionType.encryptionType[0] = eCSR_ENCRYPT_TYPE_NONE;
+
+        pRoamProfile->AuthType.numEntries = 1;
+        pHddStaCtx->conn_info.authType = eCSR_AUTH_TYPE_OPEN_SYSTEM;
+        pRoamProfile->AuthType.authType[0] = pHddStaCtx->conn_info.authType;
+    }
+    else if(WAPI_EXTENTION == pWapiMode->wapiMode) {
+        hddLog(LOG1, "%s: WAPI Mode Set to ON", __func__);
+    }
+    else
+         return -EINVAL;
+
+    pAdapter->wapi_info.nWapiMode = pWapiMode->wapiMode;
+
+    return 0;
+}
+
+static int iw_qcom_get_wapi_mode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    WAPI_FUNCTION_MODE *pWapiMode = (WAPI_FUNCTION_MODE *)(extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+    hddLog(LOG1, "The function iw_qcom_get_wapi_mode called");
+
+    pWapiMode->wapiMode = pAdapter->wapi_info.nWapiMode;
+    hddLog(LOG1, "%s: GET WAPI Mode Value:%02d", __func__, pWapiMode->wapiMode);
+    printk("\nGET WAPI MODE:%d",pWapiMode->wapiMode);
+    return 0;
+}
+
+static int iw_qcom_set_wapi_assoc_info(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+//    WAPI_AssocInfo *pWapiAssocInfo = (WAPI_AssocInfo *)(wrqu->data.pointer);
+    WAPI_AssocInfo *pWapiAssocInfo = (WAPI_AssocInfo *)(extra);
+    int i = 0, j = 0;
+    hddLog(LOG1, "The function iw_qcom_set_wapi_assoc_info called");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+    VOS_ASSERT(pWapiAssocInfo);
+
+    hddLog(LOG1, "%s: INPUT DATA:\nElement ID:0x%02x Length:0x%02x Version:0x%04x\n",__func__,pWapiAssocInfo->elementID,pWapiAssocInfo->length,pWapiAssocInfo->version);
+    hddLog(LOG1,"%s: akm Suite Cnt:0x%04x",__func__,pWapiAssocInfo->akmSuiteCount);
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"akm suite[%02d]:0x%08lx",i,pWapiAssocInfo->akmSuite[i]);
+
+    hddLog(LOG1,"%s: Unicast Suite Cnt:0x%04x",__func__,pWapiAssocInfo->unicastSuiteCount);
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1, "Unicast suite[%02d]:0x%08lx",i,pWapiAssocInfo->unicastSuite[i]);
+
+    hddLog(LOG1,"%s: Multicast suite:0x%08lx Wapi capa:0x%04x",__func__,pWapiAssocInfo->multicastSuite,pWapiAssocInfo->wapiCability);
+    hddLog(LOG1, "%s: BKID Cnt:0x%04x\n",__func__,pWapiAssocInfo->bkidCount);
+    for(i = 0 ; i < 16 ; i++) {
+        hddLog(LOG1, "BKID List[%02d].bkid:0x",i);
+        for(j = 0 ; j < 16 ; j++)
+            hddLog(LOG1,"%02x",pWapiAssocInfo->bkidList[i].bkid[j]);
+    }
+
+    /* We are not using the entire IE as provided by the supplicant.
+     * This is being calculated by SME. This is the same as in the
+     * case of WPA. Only the auth mode information needs to be
+     * extracted here*/
+    if ( pWapiAssocInfo->akmSuite[0] == WAPI_PSK_AKM_SUITE ) {
+       hddLog(LOG1, "%s: WAPI AUTH MODE SET TO PSK",__func__);
+       pAdapter->wapi_info.wapiAuthMode = WAPI_AUTH_MODE_PSK;
+    }
+
+    if ( pWapiAssocInfo->akmSuite[0] == WAPI_CERT_AKM_SUITE) {
+       hddLog(LOG1, "%s: WAPI AUTH MODE SET TO CERTIFICATE",__func__);
+       pAdapter->wapi_info.wapiAuthMode = WAPI_AUTH_MODE_CERT;
+    }
+    return 0;
+}
+
+static int iw_qcom_set_wapi_key(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+    eHalStatus       halStatus   = eHAL_STATUS_SUCCESS;
+    tANI_U32         roamId      = 0xFF;
+    tANI_U8         *pKeyPtr     = NULL;
+    v_BOOL_t         isConnected = TRUE;
+    tCsrRoamSetKey   setKey;
+    int i = 0;
+    WLAN_WAPI_KEY *pWapiKey = (WLAN_WAPI_KEY *)(extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_key called ");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    hddLog(LOG1,":%s: INPUT DATA:\nKey Type:0x%02x Key Direction:0x%02x KEY ID:0x%02x\n", __func__, pWapiKey->keyType, pWapiKey->keyDirection, pWapiKey->keyId);
+    hddLog(LOG1,"Add Index:0x");
+    for(i =0 ; i < 12 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->addrIndex[i]);
+
+    hddLog(LOG1,"\n%s: WAPI ENCRYPTION KEY LENGTH:0x%04x", __func__,pWapiKey->wpiekLen);
+    hddLog(LOG1, "WAPI ENCRYPTION KEY:0x");
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->wpiek[i]);
+
+    hddLog(LOG1,"\n%s: WAPI INTEGRITY CHECK KEY LENGTH:0x%04x", __func__,pWapiKey->wpickLen);
+    hddLog(LOG1,"WAPI INTEGRITY CHECK KEY:0x");
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->wpick[i]);
+
+    hddLog(LOG1,"\nWAPI PN NUMBER:0x");
+    for(i = 0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->pn[i]);
+
+    // Clear the setkey memory
+    vos_mem_zero(&setKey,sizeof(tCsrRoamSetKey));
+    // Store Key ID
+    setKey.keyId = (unsigned char)( pWapiKey->keyId );
+    // SET WAPI Encryption
+    setKey.encType  = eCSR_ENCRYPT_TYPE_WPI;
+    // Key Directionn both TX and RX
+    setKey.keyDirection = eSIR_TX_RX; // Do WE NEED to update this based on Key Type as GRP/UNICAST??
+    // the PAE role
+    setKey.paeRole = 0 ;
+
+    switch ( pWapiKey->keyType )
+    {
+        case PAIRWISE_KEY:
+        {
+            isConnected = hdd_connIsConnected(pHddStaCtx);
+            vos_mem_copy(setKey.peerMac,&pHddStaCtx->conn_info.bssId,WNI_CFG_BSSID_LEN);
+            break;
+        }
+        case GROUP_KEY:
+        {
+            vos_set_macaddr_broadcast( (v_MACADDR_t *)setKey.peerMac );
+            break;
+        }
+        default:
+        {
+            //Any other option is invalid.
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "[%4d] %s() failed to Set Key. Invalid key type %d", __LINE__,__func__ , -1 );
+
+            hddLog(LOGE," %s: Error WAPI Key Add Type",__func__);
+            halStatus = !eHAL_STATUS_SUCCESS; // NEED TO UPDATE THIS WITH CORRECT VALUE
+            break; // NEED RETURN FROM HERE ????
+        }
+    }
+
+    // Concatenating the Encryption Key (EK) and the MIC key (CK): EK followed by CK
+    setKey.keyLength = (v_U16_t)((pWapiKey->wpiekLen)+(pWapiKey->wpickLen));
+    pKeyPtr = setKey.Key;
+    memcpy( pKeyPtr, pWapiKey->wpiek, pWapiKey->wpiekLen );
+    pKeyPtr += pWapiKey->wpiekLen;
+    memcpy( pKeyPtr, pWapiKey->wpick, pWapiKey->wpickLen );
+
+    // Set the new key with SME.
+    pHddStaCtx->roam_info.roamingState = HDD_ROAM_STATE_SETTING_KEY;
+
+    if ( isConnected ) {
+        halStatus = sme_RoamSetKey( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, &setKey, &roamId );
+        if ( halStatus != eHAL_STATUS_SUCCESS )
+        {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "[%4d] sme_RoamSetKey returned ERROR status= %d", __LINE__, halStatus );
+
+            pHddStaCtx->roam_info.roamingState = HDD_ROAM_STATE_NONE;
+        }
+    }
+#if 0 /// NEED TO CHECK ON THIS
+    else
+    {
+        // Store the keys in the adapter to be moved to the profile & passed to
+        // SME in the ConnectRequest if we are not yet in connected state.
+         memcpy( &pAdapter->setKey[ setKey.keyId ], &setKey, sizeof( setKey ) );
+         pAdapter->fKeySet[ setKey.keyId ] = TRUE;
+
+         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_MED,
+                    "  Saving key [idx= %d] to apply when moving to connected state ",
+                    setKey.keyId );
+
+    }
+#endif
+    return halStatus;
+}
+
+static int iw_qcom_set_wapi_bkid(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+#ifdef WLAN_DEBUG
+    int i = 0;
+    WLAN_BKID_LIST  *pBkid       = ( WLAN_BKID_LIST *) (wrqu->data.pointer);
+#endif
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_bkid called");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    hddLog(LOG1,"%s: INPUT DATA:\n BKID Length:0x%08lx\n", __func__,pBkid->length);
+    hddLog(LOG1,"%s: BKID Cnt:0x%04lx",pBkid->BKIDCount);
+
+    hddLog(LOG1,"BKID KEY LIST[0]:0x");
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+#ifdef WLAN_DEBUG
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pBkid->BKID[0].bkid[i]);
+#endif
+
+    return 0;
+}
+
+static int iw_qcom_get_wapi_bkid(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    /* Yet to implement this function, 19th April 2010 */
+    hddLog(LOG1, "The function iw_qcom_get_wapi_bkid called ");
+
+    return 0;
+}
+#endif /* FEATURE_WLAN_WAPI */
+
 #ifdef WLAN_FEATURE_VOWIFI_11R
 //
 //
@@ -5042,7 +5159,7 @@
 #endif
 
     // Pass the received FT IEs to SME
-    sme_SetFTIEs( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, extra,
+    sme_SetFTIEs( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, wrqu->data.pointer,
         wrqu->data.length);
 
     return 0;
@@ -5054,7 +5171,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpRcvFltMcAddrList pRequest = (tpRcvFltMcAddrList)extra;
+    tpRcvFltMcAddrList pRequest = (tpRcvFltMcAddrList)wrqu->data.pointer;
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
     tpSirWlanSetRxpFilters wlanRxpFilterParam;
     tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
@@ -5168,13 +5285,6 @@
     tpSirWlanSetRxpFilters wlanRxpFilterParam;
     hddLog(VOS_TRACE_LEVEL_INFO_HIGH, "%s: ", __func__);
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
     //Reset the filter to INI value as we have to clear the dynamic filter
     pHddCtx->configuredMcastBcastFilter = pHddCtx->cfg_ini->mcastBcastFilterSetting;
 
@@ -5215,7 +5325,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpHostOffloadRequest pRequest = (tpHostOffloadRequest)extra;
+    tpHostOffloadRequest pRequest = (tpHostOffloadRequest)wrqu->data.pointer;
     tSirHostOffloadReq offloadRequest;
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -5287,7 +5397,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpKeepAliveRequest pRequest = (tpKeepAliveRequest)extra;
+    tpKeepAliveRequest pRequest = (tpKeepAliveRequest)wrqu->data.pointer;
     tSirKeepAliveReq keepaliveRequest;
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -5401,9 +5511,6 @@
 
                 hddLog(VOS_TRACE_LEVEL_INFO, "Data Offset %d Data Len %d\n",
                         pRequest->paramsData[i].dataOffset, pRequest->paramsData[i].dataLength);
-                if ((sizeof(packetFilterSetReq.paramsData[i].compareData)) <
-                           (pRequest->paramsData[i].dataLength))
-                    return -EINVAL;
 
                 memcpy(&packetFilterSetReq.paramsData[i].compareData,
                         pRequest->paramsData[i].compareData, pRequest->paramsData[i].dataLength);
@@ -5636,112 +5743,47 @@
 
 void wlan_hdd_set_mc_addr_list(hdd_adapter_t *pAdapter, v_U8_t set)
 {
+    v_U8_t filterAction;
+    tPacketFilterCfg request;
     v_U8_t i;
-    tpSirRcvFltMcAddrList pMulticastAddrs = NULL;
-    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
-    hdd_context_t* pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
-    if (NULL == hHal)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HAL Handle is NULL"));
-        return;
-    }
-    if (NULL == pHddCtx)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD CTX is NULL"));
-        return;
-    }
+    filterAction = set ? HDD_RCV_FILTER_SET : HDD_RCV_FILTER_CLEAR;
 
-    /* Check if INI is enabled or not, other wise just return
-     */
-    if (pHddCtx->cfg_ini->fEnableMCAddrList)
+    /*set mulitcast addr list*/
+    for (i = 0; i < pAdapter->mc_addr_list.mc_cnt; i++)
     {
-        pMulticastAddrs = vos_mem_malloc(sizeof(tSirRcvFltMcAddrList));
-        if (NULL == pMulticastAddrs)
-        {
-            hddLog(VOS_TRACE_LEVEL_ERROR, FL("Could not allocate Memory"));
-            return;
-        }
-
+        memset(&request, 0, sizeof (tPacketFilterCfg));
+        request.filterAction = filterAction;
+        request.filterId = i; 
         if (set)
         {
-            /* Following pre-conditions should be satisfied before wei
-             * configure the MC address list.
-             */
-            if (((pAdapter->device_mode == WLAN_HDD_INFRA_STATION) ||
-               (pAdapter->device_mode == WLAN_HDD_P2P_CLIENT))
-               && pAdapter->mc_addr_list.mc_cnt
-               && (eConnectionState_Associated ==
-               (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState))
-            {
-                pMulticastAddrs->ulMulticastAddrCnt =
-                                 pAdapter->mc_addr_list.mc_cnt;
-                for (i = 0; i < pAdapter->mc_addr_list.mc_cnt; i++)
-                {
-                    memcpy(&(pMulticastAddrs->multicastAddr[i][0]),
-                            &(pAdapter->mc_addr_list.addr[i][0]),
-                            sizeof(pAdapter->mc_addr_list.addr[i]));
-                    hddLog(VOS_TRACE_LEVEL_INFO,
-                            "%s: %s multicast filter: addr ="
-                            MAC_ADDRESS_STR,
-                            __func__, set ? "setting" : "clearing",
-                            MAC_ADDR_ARRAY(pMulticastAddrs->multicastAddr[i]));
-                }
-                /* Set multicast filter */
-                sme_8023MulticastList(hHal, pAdapter->sessionId,
-                                      pMulticastAddrs);
-            }
-        }
-        else
-        {
-            /* Need to clear only if it was previously configured
-             */
-            if (pAdapter->mc_addr_list.isFilterApplied)
-            {
-                pMulticastAddrs->ulMulticastAddrCnt = 0;
-                sme_8023MulticastList(hHal, pAdapter->sessionId,
-                                      pMulticastAddrs);
-            }
-
+            request.numParams = 1; 
+            request.paramsData[0].protocolLayer = HDD_FILTER_PROTO_TYPE_MAC; 
+            request.paramsData[0].cmpFlag = HDD_FILTER_CMP_TYPE_EQUAL;   
+            request.paramsData[0].dataOffset = WLAN_HDD_80211_FRM_DA_OFFSET;
+            request.paramsData[0].dataLength = ETH_ALEN;
+            memcpy(&(request.paramsData[0].compareData[0]), 
+                    &(pAdapter->mc_addr_list.addr[i][0]), ETH_ALEN);
+            /*set mulitcast filters*/
+            hddLog(VOS_TRACE_LEVEL_INFO, 
+                    "%s: %s multicast filter: addr =" 
+                    MAC_ADDRESS_STR,
+                    __func__, set ? "setting" : "clearing", 
+                    MAC_ADDR_ARRAY(request.paramsData[0].compareData));
         }
-        pAdapter->mc_addr_list.isFilterApplied = set ? TRUE : FALSE;
-    }
-    else
-    {
-        hddLog(VOS_TRACE_LEVEL_INFO,
-                FL("fEnableMCAddrList is not enabled in INI"));
+        wlan_hdd_set_filter(pHddCtx, &request, pAdapter->sessionId);
     }
-    return;
+    pAdapter->mc_addr_list.isFilterApplied = set ? TRUE : FALSE;
 }
 
 static int iw_set_packet_filter_params(struct net_device *dev, struct iw_request_info *info,
         union iwreq_data *wrqu, char *extra)
-{
+{   
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpPacketFilterCfg pRequest = NULL;
-    int ret;
-
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    pRequest = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                               wrqu->data.length);
-    if (NULL == pRequest)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
+    tpPacketFilterCfg pRequest = (tpPacketFilterCfg)wrqu->data.pointer;
 
-    ret = wlan_hdd_set_filter(WLAN_HDD_GET_CTX(pAdapter), pRequest, pAdapter->sessionId);
-    kfree(pRequest);
-
-    return ret;
+    return wlan_hdd_set_filter(WLAN_HDD_GET_CTX(pAdapter), pRequest, pAdapter->sessionId);
 }
 #endif
 static int iw_get_statistics(struct net_device *dev,
@@ -5972,7 +6014,7 @@
   VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
             "PNO data len %d data %s",
             wrqu->data.length,
-            extra);
+            (char *)wrqu->data.pointer);
 
   if (wrqu->data.length <= nOffset )
   {
@@ -6010,7 +6052,7 @@
 
     scan every 5 seconds 2 times, scan every 300 seconds until stopped
   -----------------------------------------------------------------------*/
-  ptr = extra + nOffset;
+  ptr = (char*)(wrqu->data.pointer + nOffset);
 
   sscanf(ptr,"%hhu%n", &(pnoRequest.enable), &nOffset);
 
@@ -6221,7 +6263,7 @@
     v_U8_t rssiThreshold = 0;
     v_U8_t nRead;
 
-    nRead = sscanf(extra + nOffset,"%hhu",
+    nRead = sscanf(wrqu->data.pointer + nOffset,"%hhu",
            &rssiThreshold);
 
     if ( 1 != nRead )
@@ -6382,17 +6424,10 @@
                            union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tANI_U8 *ptr = NULL;
+    tANI_U8 *ptr = (tANI_U8*)wrqu->data.pointer;
     int ret = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s: ", __func__);
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s: ", __func__);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
@@ -6401,56 +6436,23 @@
         return -EBUSY;
     }
 
-    /* ODD number is used for set, copy data using copy_from_user */
-    ptr = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
     if (memcmp(ptr, "SETBAND ", 8) == 0)
     {
         /* Change band request received */
         ret = hdd_setBand_helper(dev, ptr);
-    }
-    kfree(ptr);
+        return ret;
 
-    return ret;
+    }
+    return 0;
 }
 
 static int iw_set_power_params_priv(struct net_device *dev,
                            struct iw_request_info *info,
                            union iwreq_data *wrqu, char *extra)
 {
-    int ret;
-    char *ptr;
-
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "Set power params Private");
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    ptr = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
-    ret = iw_set_power_params(dev, info, wrqu, ptr, 0);
-    kfree(ptr);
-    return ret;
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                "Set power params Private");
+  return iw_set_power_params(dev,info,wrqu,extra,0);
 }
 
 
@@ -6664,6 +6666,14 @@
    [WLAN_PRIV_GET_OEM_DATA_RSP - SIOCIWFIRSTPRIV] = iw_get_oem_data_rsp, //oem data req Specifc
 #endif
 
+#ifdef FEATURE_WLAN_WAPI
+   [WLAN_PRIV_SET_WAPI_MODE             - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_mode,
+   [WLAN_PRIV_GET_WAPI_MODE             - SIOCIWFIRSTPRIV]  = iw_qcom_get_wapi_mode,
+   [WLAN_PRIV_SET_WAPI_ASSOC_INFO       - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_assoc_info,
+   [WLAN_PRIV_SET_WAPI_KEY              - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_key,
+   [WLAN_PRIV_SET_WAPI_BKID             - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_bkid,
+   [WLAN_PRIV_GET_WAPI_BKID             - SIOCIWFIRSTPRIV]  = iw_qcom_get_wapi_bkid,
+#endif /* FEATURE_WLAN_WAPI */
 #ifdef WLAN_FEATURE_VOWIFI_11R
    [WLAN_PRIV_SET_FTIES                 - SIOCIWFIRSTPRIV]   = iw_set_fties,
 #endif
@@ -7012,6 +7022,44 @@
         "get_oem_data_rsp" },
 #endif
 
+#ifdef FEATURE_WLAN_WAPI
+   /* handlers for main ioctl SET_WAPI_MODE */
+    {   WLAN_PRIV_SET_WAPI_MODE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "SET_WAPI_MODE" },
+
+   /* handlers for main ioctl GET_WAPI_MODE */
+    {   WLAN_PRIV_GET_WAPI_MODE,
+        0,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "GET_WAPI_MODE" },
+
+   /* handlers for main ioctl SET_ASSOC_INFO */
+    {   WLAN_PRIV_SET_WAPI_ASSOC_INFO,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 400,
+        0,
+        "SET_WAPI_ASSOC" },
+
+   /* handlers for main ioctl SET_WAPI_KEY */
+    {   WLAN_PRIV_SET_WAPI_KEY,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 71,
+        0,
+        "SET_WAPI_KEY" },
+
+   /* handlers for main ioctl SET_WAPI_BKID */
+    {   WLAN_PRIV_SET_WAPI_BKID,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 24,
+        0,
+        "SET_WAPI_BKID" },
+
+   /* handlers for main ioctl GET_WAPI_BKID */
+    {   WLAN_PRIV_GET_WAPI_BKID,
+        0,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 24,
+        "GET_WAPI_BKID" },
+#endif /* FEATURE_WLAN_WAPI */
+
     /* handlers for main ioctl - host offload */
     {
         WLAN_PRIV_SET_HOST_OFFLOAD,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c	2014-12-03 11:07:31.000000000 +0000
@@ -81,7 +81,6 @@
 #include <linux/semaphore.h>
 #include <wlan_hdd_hostapd.h>
 #include <wlan_hdd_softap_tx_rx.h>
-#include <vos_sched.h>
 
 // change logging behavior based upon debug flag
 #ifdef HDD_WMM_DEBUG
@@ -1814,14 +1813,6 @@
 
    hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);
 
-   if (isWDresetInProgress())
-   {
-       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
-                  FL("called during WDReset"));
-       skb->priority = SME_QOS_WMM_UP_BE;
-       return HDD_LINUX_AC_BE;
-   }
-
    // if we don't want QoS or the AP doesn't support Qos
    // All traffic will get equal opportuniy to transmit data frames.
    if( hdd_wmm_is_active(pAdapter) ) {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h	2014-12-03 11:07:31.000000000 +0000
@@ -60,9 +60,9 @@
 #define QWLAN_VERSION_MINOR            2
 #define QWLAN_VERSION_PATCH            3
 #define QWLAN_VERSION_EXTRA            ""
-#define QWLAN_VERSION_BUILD            23
+#define QWLAN_VERSION_BUILD            13
 
-#define QWLAN_VERSIONSTR              "3.2.3.23"
+#define QWLAN_VERSIONSTR              "3.2.3.13"
 
 #endif /* QWLAN_VERSION_H */
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h	2014-12-03 11:07:31.000000000 +0000
@@ -360,8 +360,6 @@
 #define WNI_CFG_ENABLE_MCC_ADAPTIVE_SCHED    295
 #define WNI_CFG_DISABLE_LDPC_WITH_TXBF_AP    296
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT    297
-#define WNI_CFG_RA_FILTER_ENABLE    298
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL    299
 
 /*
  * String parameter lengths 
@@ -2488,26 +2486,10 @@
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_APMAX    255
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_APDEF    3
 
-#define WNI_CFG_RA_FILTER_ENABLE_STAMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_STAMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_STADEF    1
-
-#define WNI_CFG_RA_FILTER_ENABLE_APMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_APMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_APDEF    1
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STADEF    60
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APDEF    60
-
-#define CFG_PARAM_MAX_NUM         300
-#define CFG_AP_IBUF_MAX_SIZE      239
+#define CFG_PARAM_MAX_NUM         298
+#define CFG_AP_IBUF_MAX_SIZE      237
 #define CFG_AP_SBUF_MAX_SIZE      3422
-#define CFG_STA_IBUF_MAX_SIZE     234
+#define CFG_STA_IBUF_MAX_SIZE     232
 #define CFG_STA_SBUF_MAX_SIZE     3388
 #define CFG_SEM_MAX_NUM           19
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h	2014-12-03 11:07:31.000000000 +0000
@@ -354,8 +354,6 @@
 #define WNI_CFG_ENABLE_MCC_ADAPTIVE_SCHED    295
 #define WNI_CFG_DISABLE_LDPC_WITH_TXBF_AP    296
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT    297
-#define WNI_CFG_RA_FILTER_ENABLE    298
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL    299
 
 /*
  * String parameter lengths 
@@ -1617,16 +1615,8 @@
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_STAMAX    255
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_STADEF    3
 
-#define WNI_CFG_RA_FILTER_ENABLE_STAMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_STAMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_STADEF    1
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STADEF    60
-
-#define CFG_PARAM_MAX_NUM        300
-#define CFG_STA_IBUF_MAX_SIZE    234
+#define CFG_PARAM_MAX_NUM        298
+#define CFG_STA_IBUF_MAX_SIZE    232
 #define CFG_STA_SBUF_MAX_SIZE    3388
 #define CFG_SEM_MAX_NUM          19
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c	2014-12-03 11:07:31.000000000 +0000
@@ -350,8 +350,6 @@
     (unsigned char *)"ENABLE_MCC_ADAPTIVE_SCHED",
     (unsigned char *)"DISABLE_LDPC_WITH_TXBF_AP",
     (unsigned char *)"AP_LINK_MONITOR_TIMEOUT",
-    (unsigned char *)"RA_FILTER_ENABLE",
-    (unsigned char *)"RA_RATE_LIMIT_INTERVAL",
 };
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt	2014-12-03 11:07:31.000000000 +0000
@@ -1,4 +1,4 @@
- *
+/*
  * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
@@ -17,7 +17,7 @@
  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
- *
+ */
 * Copyright (c) 2012, The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
@@ -4498,27 +4498,3 @@
 V    RW    NP
 HAL
 1    255    3
-
-* RA filter enable/disable
-*
-WNI_CFG_RA_FILTER_ENABLE    I    4    7
-V    RW    NP
-HAL
-0    1     1
-V    RW    NP
-HAL
-0    1     1
-*
-*
-
-* RA filter rate interval
-*
-WNI_CFG_RA_RATE_LIMIT_INTERVAL    I    4    7
-V    RW    NP
-HAL
-0    60     60
-V    RW     NP
-HAL
-0    60     60
-*
-*
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/include/sirParams.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/include/sirParams.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/include/sirParams.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/include/sirParams.h	2014-12-03 11:07:31.000000000 +0000
@@ -97,7 +97,6 @@
 #ifdef WLAN_FEATURE_ROAM_SCAN_OFFLOAD
    WLAN_ROAM_SCAN_OFFLOAD = 23,
 #endif
-   EXTENDED_NSOFFLOAD_SLOT = 24,
    //MAX_FEATURE_SUPPORTED = 128
 } placeHolderInCapBitmap;
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c	2014-12-03 11:07:31.000000000 +0000
@@ -157,9 +157,14 @@
         if ((pMac->lim.gLimMlmState  == eLIM_MLM_WT_PROBE_RESP_STATE) ||
             (pMac->lim.gLimMlmState  == eLIM_MLM_PASSIVE_SCAN_STATE))
         {
-            limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo,
-                   ((pMac->lim.gLimHalScanState == eLIM_HAL_SCANNING_STATE) ? eANI_BOOLEAN_TRUE : eANI_BOOLEAN_FALSE),
-                   eANI_BOOLEAN_FALSE);
+            //If we are scanning for P2P, only accept probe rsp
+            if((pMac->lim.gLimHalScanState != eLIM_HAL_SCANNING_STATE) || (NULL == pMac->lim.gpLimMlmScanReq) 
+               || !pMac->lim.gpLimMlmScanReq->p2pSearch )
+            {
+                limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo, 
+                       ((pMac->lim.gLimHalScanState == eLIM_HAL_SCANNING_STATE) ? eANI_BOOLEAN_TRUE : eANI_BOOLEAN_FALSE), 
+                       eANI_BOOLEAN_FALSE);
+            }
         }
         else if (pMac->lim.gLimMlmState == eLIM_MLM_LEARN_STATE)
         {
@@ -276,8 +281,12 @@
         if ( (pMac->lim.gLimMlmState == eLIM_MLM_WT_PROBE_RESP_STATE) ||
              (pMac->lim.gLimMlmState == eLIM_MLM_PASSIVE_SCAN_STATE) )
         {
-            limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo,
-                                         eANI_BOOLEAN_TRUE, eANI_BOOLEAN_FALSE);
+            //If we are scanning for P2P, only accept probe rsp
+            if((pMac->lim.gLimHalScanState != eLIM_HAL_SCANNING_STATE) || (NULL == pMac->lim.gpLimMlmScanReq) 
+               || !pMac->lim.gpLimMlmScanReq->p2pSearch )
+            {
+                limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo, eANI_BOOLEAN_TRUE, eANI_BOOLEAN_FALSE);
+            }
         }
         else if (pMac->lim.gLimMlmState == eLIM_MLM_LEARN_STATE)
         {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c	2014-12-03 11:07:31.000000000 +0000
@@ -139,14 +139,14 @@
  * @return None
  */
 #if defined WLAN_FEATURE_VOWIFI
-eHalStatus
+void
 limCollectBssDescription(tpAniSirGlobal pMac,
                          tSirBssDescription *pBssDescr,
                          tpSirProbeRespBeacon pBPR,
                          tANI_U8  *pRxPacketInfo,
                          tANI_U8  fScanning)
 #else
-eHalStatus
+void
 limCollectBssDescription(tpAniSirGlobal pMac,
                          tSirBssDescription *pBssDescr,
                          tpSirProbeRespBeacon pBPR,
@@ -165,17 +165,6 @@
     rxChannel = WDA_GET_RX_CH(pRxPacketInfo);
     pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);
 
-    /**
-     * Drop all the beacons and probe response without P2P IE during P2P search
-     */
-    if (NULL != pMac->lim.gpLimMlmScanReq && pMac->lim.gpLimMlmScanReq->p2pSearch)
-    {
-        if (NULL == limGetP2pIEPtr(pMac, (pBody + SIR_MAC_B_PR_SSID_OFFSET), ieLen))
-        {
-            limLog( pMac, LOG3, MAC_ADDRESS_STR, MAC_ADDR_ARRAY(pHdr->bssId));
-            return eHAL_STATUS_FAILURE;
-        }
-    }
 
     /**
      * Length of BSS desription is without length of
@@ -294,7 +283,7 @@
         pBssDescr->aniIndicator,
         ieLen );
 
-    return eHAL_STATUS_SUCCESS;
+    return;
 } /*** end limCollectBssDescription() ***/
 
 /**
@@ -508,19 +497,11 @@
 
     // In scan state, store scan result.
 #if defined WLAN_FEATURE_VOWIFI
-    status = limCollectBssDescription(pMac, &pBssDescr->bssDescription,
+    limCollectBssDescription(pMac, &pBssDescr->bssDescription,
                              pBPR, pRxPacketInfo, fScanning);
-    if (eHAL_STATUS_SUCCESS != status)
-    {
-        goto last;
-    }
 #else
-    status = limCollectBssDescription(pMac, &pBssDescr->bssDescription,
+    limCollectBssDescription(pMac, &pBssDescr->bssDescription,
                              pBPR, pRxPacketInfo);
-    if (eHAL_STATUS_SUCCESS != status)
-    {
-        goto last;
-    }
 #endif
     /* Calling dfsChannelList which will convert DFS channel
      * to Active channel for x secs if this channel is DFS channel */
@@ -614,12 +595,10 @@
         }
     }//(eANI_BOOLEAN_TRUE == fScanning)
 
-last:
     if( eHAL_STATUS_SUCCESS != status )
     {
         palFreeMemory( pMac->hHdd, pBssDescr );
     }
-    return;
 } /****** end limCheckAndAddBssDescription() ******/
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h	2014-12-03 11:07:31.000000000 +0000
@@ -76,13 +76,13 @@
 tANI_U32 limDeactivateMinChannelTimerDuringScan(tpAniSirGlobal);
 void    limCheckAndAddBssDescription(tpAniSirGlobal, tpSirProbeRespBeacon, tANI_U8 *, tANI_BOOLEAN, tANI_U8);
 #if defined WLAN_FEATURE_VOWIFI
-eHalStatus    limCollectBssDescription(tpAniSirGlobal,
+void    limCollectBssDescription(tpAniSirGlobal,
                                  tSirBssDescription *,
                                  tpSirProbeRespBeacon,
                                  tANI_U8 *,
                                  tANI_U8);
 #else
-eHalStatus    limCollectBssDescription(tpAniSirGlobal,
+void    limCollectBssDescription(tpAniSirGlobal,
                                  tSirBssDescription *,
                                  tpSirProbeRespBeacon,
                                  tANI_U8 *);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrApi.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrApi.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrApi.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrApi.h	2014-12-03 11:07:31.000000000 +0000
@@ -846,13 +846,8 @@
     tANI_U8 *pWAPIReqIE;   //If not null, it has the IE byte stream for WAPI
 #endif /* FEATURE_WLAN_WAPI */
 
-    //The byte count in the pAddIE for scan (at the time of join)
-    tANI_U32 nAddIEScanLength;
-    /* Additional IE information.
-     * It has the IE byte stream for additional IE,
-     * which can be WSC IE and/or P2P IE
-     */
-    tANI_U8  addIEScan[SIR_MAC_MAX_IE_LENGTH+2];       //Additional IE information.
+    tANI_U32 nAddIEScanLength;   //The byte count in the pAddIE for scan (at the time of join)
+    tANI_U8 *pAddIEScan;       //If not null, it has the IE byte stream for additional IE, which can be WSC IE and/or P2P IE
     tANI_U32 nAddIEAssocLength;   //The byte count in the pAddIE for assoc
     tANI_U8 *pAddIEAssoc;       //If not null, it has the IE byte stream for additional IE, which can be WSC IE and/or P2P IE
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrInternal.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrInternal.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrInternal.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrInternal.h	2014-12-03 11:07:31.000000000 +0000
@@ -883,11 +883,8 @@
     tANI_U32 nWapiRspIeLength;    //the byte count for pWapiRspIE
     tANI_U8 *pWapiRspIE;  //this contain the WAPI IE in beacon/probe rsp
 #endif /* FEATURE_WLAN_WAPI */
-    tANI_U32 nAddIEScanLength;  //length of addIeScan
-    /* This contains the additional IE in (unicast)
-     *  probe request at the time of join
-     */
-    tANI_U8 addIEScan[SIR_MAC_MAX_IE_LENGTH+2];
+    tANI_U32 nAddIEScanLength;  //the byte count of pAddIeScanIE;
+    tANI_U8 *pAddIEScan; //this contains the additional IE in (unicast) probe request at the time of join
     tANI_U32 nAddIEAssocLength;      //the byte count for pAddIeAssocIE
     tANI_U8 *pAddIEAssoc; //this contains the additional IE in (re) assoc request
 
@@ -1112,6 +1109,10 @@
 void csrScanResumeIMPS( tpAniSirGlobal pMac );
 
 eHalStatus csrInitGetChannels(tpAniSirGlobal pMac);
+// Getting the 5GHz Channel list
+eHalStatus csrGet5GChannels(tpAniSirGlobal pMac);
+// Getting the 2.4GHz Channel list
+eHalStatus csrGet24GChannels(tpAniSirGlobal pMac);
 
 eHalStatus csrSetModifyProfileFields(tpAniSirGlobal pMac, tANI_U32 sessionId,
                                      tCsrRoamModifyProfileFields *pModifyProfileFields);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c	2014-12-03 11:07:31.000000000 +0000
@@ -1902,6 +1902,121 @@
     return status;
 }
 
+eHalStatus csrGet5GChannels(tpAniSirGlobal pMac)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    tANI_U8 num20MHzChannelsFound = 0;
+    VOS_STATUS vosStatus;
+    tANI_U8 num40MHzChannelsFound = 0;
+    tANI_U8 Index = 0;
+    tANI_U8 channelList = 0;
+
+    // Updating the defaultpower Table for changed Domain Id
+    vosStatus = vos_nv_getChannelListWithPower( pMac->scan.defaultPowerTable, &num20MHzChannelsFound,
+                                                pMac->scan.defaultPowerTable40MHz, &num40MHzChannelsFound);
+
+    if ( (VOS_STATUS_SUCCESS != vosStatus) || (num20MHzChannelsFound == 0) )
+    {
+        smsLog( pMac, LOGE, FL("failed to get channels"));
+        status = eHAL_STATUS_FAILURE;
+    }
+    else
+    {
+        if ( num20MHzChannelsFound > WNI_CFG_VALID_CHANNEL_LIST_LEN )
+        {
+            num20MHzChannelsFound = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        }
+
+        // Move the only 5GHZ channel list to the global data,
+        // As 2.4GHZ list coming from the AP for the changed domain
+        // structure -- this will be used as the scan list
+        for(channelList = 0; channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN; channelList++)
+        {
+            // If Channel is 5GHz just break the for loop
+            if(!(pMac->scan.base20MHzChannels.channelList[ channelList ] > 0 && pMac->scan.base20MHzChannels.channelList[ channelList ] <= 14))
+                break;
+        }
+        // Update the 5G channels from nv.bin
+        for ( Index = 0; Index < num20MHzChannelsFound; Index++)
+        {
+            if(pMac->scan.defaultPowerTable[Index].chanId >= 36 && pMac->scan.defaultPowerTable[Index].chanId <= 165)
+            {
+                if(channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN)
+                {
+                   pMac->scan.base20MHzChannels.channelList[ channelList ] = pMac->scan.defaultPowerTable[Index].chanId;
+                   channelList++;
+                }
+            }
+        }
+
+        pMac->scan.numChannelsDefault = (num20MHzChannelsFound > channelList) ? num20MHzChannelsFound : channelList;
+        pMac->scan.base20MHzChannels.numChannels = (num20MHzChannelsFound > channelList) ? num20MHzChannelsFound : channelList;
+        // Filling the remaining index as Zero Just for causion
+        for(Index = pMac->scan.base20MHzChannels.numChannels; Index < WNI_CFG_VALID_CHANNEL_LIST_LEN; Index++)
+            pMac->scan.base20MHzChannels.channelList[ Index ] = 0;
+    }
+    return status;
+}
+
+eHalStatus csrGet24GChannels(tpAniSirGlobal pMac)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    tANI_U8 num20MHzChannelsFound = 0;
+    VOS_STATUS vosStatus;
+    tANI_U8 Index = 0;
+    tANI_U8 num40MHzChannelsFound = 0;
+    tANI_U8 channelList5GBackup[WNI_CFG_VALID_CHANNEL_LIST_LEN] = {0}, nuum5GchannelListBackup;
+    tANI_U8 channelList = 0;
+
+    // Read the scan channel list (including the power limit) from EEPROM
+    vosStatus = vos_nv_getChannelListWithPower( pMac->scan.defaultPowerTable, &num20MHzChannelsFound,
+                                                pMac->scan.defaultPowerTable40MHz, &num40MHzChannelsFound);
+
+    if ( (VOS_STATUS_SUCCESS != vosStatus) || (num20MHzChannelsFound == 0) )
+    {
+        smsLog( pMac, LOGE, FL("failed to get channels \n"));
+        status = eHAL_STATUS_FAILURE;
+    }
+    else
+    {
+        if ( num20MHzChannelsFound > WNI_CFG_VALID_CHANNEL_LIST_LEN )
+        {
+            num20MHzChannelsFound = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        }
+
+        // Move the 2.4GHZ channel list only to the global data,
+        // As 5GHz list been provided by AP as part of 11d IE
+        // structure -- this will be used as the scan list
+        for(channelList = 0, nuum5GchannelListBackup = 0; channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN; channelList++)
+        {
+            if(pMac->scan.base20MHzChannels.channelList[ channelList ] >= 36 && pMac->scan.base20MHzChannels.channelList[ channelList ] <= 165)
+            {
+                // First taking the 5GHz channel list backup
+                channelList5GBackup[nuum5GchannelListBackup] = pMac->scan.base20MHzChannels.channelList[ channelList ];
+                nuum5GchannelListBackup++;
+            }
+        }
+        // Updating the 2.4GHz list
+        for ( Index = 0; Index < num20MHzChannelsFound; Index++)
+        {
+            if(pMac->scan.defaultPowerTable[Index].chanId > 0 && pMac->scan.defaultPowerTable[Index].chanId <= 14)
+                pMac->scan.base20MHzChannels.channelList[ Index ] = pMac->scan.defaultPowerTable[Index].chanId;
+        }
+        // Restoring the Backed up 5 GHZ channels
+        for(channelList = 0;channelList < nuum5GchannelListBackup; channelList++ )
+        {
+            if (Index < WNI_CFG_VALID_CHANNEL_LIST_LEN)
+            {
+                pMac->scan.base20MHzChannels.channelList[ Index ] = channelList5GBackup[channelList];
+                Index++;
+            }
+        }
+
+        pMac->scan.numChannelsDefault = (num20MHzChannelsFound > Index) ? num20MHzChannelsFound : Index;
+        pMac->scan.base20MHzChannels.numChannels = (num20MHzChannelsFound > Index) ? num20MHzChannelsFound : Index;
+    }
+    return (status);
+}
 
 eHalStatus csrInitGetChannels(tpAniSirGlobal pMac)
 {
@@ -5630,19 +5745,15 @@
 #endif /* FEATURE_WLAN_WAPI */
         if(pSrcProfile->nAddIEScanLength)
         {
-            memset(pDstProfile->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH);
-            if ( SIR_MAC_MAX_IE_LENGTH >=  pSrcProfile->nAddIEScanLength)
-            {
-                vos_mem_copy(pDstProfile->addIEScan, pSrcProfile->addIEScan,
-                          pSrcProfile->nAddIEScanLength);
-                pDstProfile->nAddIEScanLength = pSrcProfile->nAddIEScanLength;
-            }
-            else
+            status = palAllocateMemory(pMac->hHdd,
+                     (void **)&pDstProfile->pAddIEScan, pSrcProfile->nAddIEScanLength);
+            if(!HAL_STATUS_SUCCESS(status))
             {
-                VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                      FL(" AddIEScanLength is not valid %u"),
-                                  pSrcProfile->nAddIEScanLength);
+                break;
             }
+            pDstProfile->nAddIEScanLength = pSrcProfile->nAddIEScanLength;
+            palCopyMemory(pMac->hHdd, pDstProfile->pAddIEScan, pSrcProfile->pAddIEScan,
+                pSrcProfile->nAddIEScanLength);
         }
         if(pSrcProfile->nAddIEAssocLength)
         {
@@ -6842,17 +6953,7 @@
                 smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
                 return;
             }
-
-            /* While switching between two AP, csr will reissue roam command again
-               to the nextbss if it was interrupted by the dissconnect req for the
-               previous bss.During this csr is incrementing bRefAssocStartCnt twice.
-               so reset the bRefAssocStartCnt.
-            */
-            if(pSession->bRefAssocStartCnt > 0)
-            {
-                pSession->bRefAssocStartCnt--;
-            }
-
+            
             if( pCommand->u.roamCmd.fStopWds )
             {
                 palZeroMemory(pMac->hHdd, &roamInfo, sizeof(tCsrRoamInfo));
@@ -7755,7 +7856,7 @@
             tSirSmeAssocIndToUpperLayerCnf *pUpperLayerAssocCnf;
             tCsrRoamInfo roamInfo;
             tCsrRoamInfo *pRoamInfo = NULL;
-            tANI_U32 sessionId = 0;
+            tANI_U32 sessionId;
             eHalStatus status;
             smsLog( pMac, LOG1, FL("ASSOCIATION confirmation can be given to upper layer "));
             palZeroMemory(pMac->hHdd, &roamInfo, sizeof(tCsrRoamInfo));
@@ -8529,6 +8630,7 @@
     tCsrRoamSession *pSession = NULL;
     tpSirSmeSwitchChannelInd pSwitchChnInd;
     tSmeMaxAssocInd *pSmeMaxAssocInd;
+    tSmeCmd pCommand;
     pSirMsg->messageType = (pSirMsg->messageType);
     pSirMsg->length = (pSirMsg->length);
     pSirMsg->statusCode = (pSirMsg->statusCode);
@@ -8610,105 +8712,77 @@
             }
             break;
         case eWNI_SME_DISASSOC_IND:
+            smsLog( pMac, LOGE, FL("DISASSOCIATION Indication from MAC"));
+            // Check if AP dis-associated us because of MIC failure. If so,
+            // then we need to take action immediately and not wait till the
+            // the WmStatusChange requests is pushed and processed
+            pDisassocInd = (tSirSmeDisassocInd *)pSirMsg;
+            status = csrRoamGetSessionIdFromBSSID( pMac, (tCsrBssid *)pDisassocInd->bssId, &sessionId );
+            if( HAL_STATUS_SUCCESS( status ) )
             {
-                // Check if AP dis-associated us because of MIC failure. If so,
-                // then we need to take action immediately and not wait till the
-                // the WmStatusChange requests is pushed and processed
-                tSmeCmd *pCommand;
-
-                pDisassocInd = (tSirSmeDisassocInd *)pSirMsg;
-                status = csrRoamGetSessionIdFromBSSID( pMac,
-                                   (tCsrBssid *)pDisassocInd->bssId, &sessionId );
-                if( HAL_STATUS_SUCCESS( status ) )
-                {
-                    smsLog( pMac, LOGE, FL("DISASSOCIATION Indication from MAC"
-                                       " for session %d "), sessionId);
-                    smsLog( pMac, LOGE, FL("DISASSOCIATION from peer ="
-                                      MAC_ADDRESS_STR " "
-                                      " reason = %d status = %d "),
-                                     MAC_ADDR_ARRAY(pDisassocInd->peerMacAddr),
-                                     pDisassocInd->reasonCode,
-                                     pDisassocInd->statusCode);
-                    // If we are in neighbor preauth done state then on receiving
-                    // disassoc or deauth we dont roam instead we just disassoc
-                    // from current ap and then go to disconnected state
-                    // This happens for CCX and 11r FT connections ONLY.
+                // If we are in neighbor preauth done state then on receiving
+                // disassoc or deauth we dont roam instead we just disassoc
+                // from current ap and then go to disconnected state 
+                // This happens for CCX and 11r FT connections ONLY.
 #ifdef WLAN_FEATURE_VOWIFI_11R
-                    if (csrRoamIs11rAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIs11rAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
 #ifdef FEATURE_WLAN_CCX
-                    if (csrRoamIsCCXAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIsCCXAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
 #ifdef FEATURE_WLAN_LFR
-                    if (csrRoamIsFastRoamEnabled(pMac, sessionId) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIsFastRoamEnabled(pMac, sessionId) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
-                    pSession = CSR_GET_SESSION( pMac, sessionId );
+                pSession = CSR_GET_SESSION( pMac, sessionId );
 
-                    if (!pSession)
-                    {
-                        smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
-                        return;
-                    }
+                if(!pSession)
+                {
+                    smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
+                    return;
+                }
 
-                    if ( csrIsConnStateInfra( pMac, sessionId ) )
-                    {
-                        pSession->connectState = eCSR_ASSOC_STATE_TYPE_NOT_CONNECTED;
-                    }
+                if ( csrIsConnStateInfra( pMac, sessionId ) )
+                {
+                    pSession->connectState = eCSR_ASSOC_STATE_TYPE_NOT_CONNECTED;
+                }
 #ifndef WLAN_MDM_CODE_REDUCTION_OPT
-                    sme_QosCsrEventInd(pMac, (v_U8_t)sessionId, SME_QOS_CSR_DISCONNECT_IND, NULL);
+                sme_QosCsrEventInd(pMac, (v_U8_t)sessionId, SME_QOS_CSR_DISCONNECT_IND, NULL);
 #endif
-                    csrRoamLinkDown(pMac, sessionId);
-                    csrRoamIssueWmStatusChange( pMac, sessionId, eCsrDisassociated, pSirMsg );
-                    if (CSR_IS_INFRA_AP(&pSession->connectedProfile))
-                    {
+                csrRoamLinkDown(pMac, sessionId);
+                csrRoamIssueWmStatusChange( pMac, sessionId, eCsrDisassociated, pSirMsg );
+                if(CSR_IS_INFRA_AP(&pSession->connectedProfile))
+                {
 
-                        pCommand = csrGetCommandBuffer(pMac);
-                        if (NULL == pCommand)
-                        {
-                            smsLog( pMac, LOGE, FL(" fail to get command buffer") );
-                            status = eHAL_STATUS_RESOURCES;
-                        }
-                        pRoamInfo = &roamInfo;
-                        pRoamInfo->statusCode = pDisassocInd->statusCode;
-                        pRoamInfo->u.pConnectedProfile = &pSession->connectedProfile;
-                        pRoamInfo->staId = (tANI_U8)pDisassocInd->staId;
+                    pRoamInfo = &roamInfo;
 
-                        vos_mem_copy(pRoamInfo->peerMac, pDisassocInd->peerMacAddr,
-                                     sizeof(tSirMacAddr));
-                        vos_mem_copy(&pRoamInfo->bssid, pDisassocInd->bssId,
-                                     sizeof(tCsrBssid));
+                    pRoamInfo->statusCode = pDisassocInd->statusCode; 
+                    pRoamInfo->u.pConnectedProfile = &pSession->connectedProfile;
 
-                        status = csrRoamCallCallback(pMac, sessionId, pRoamInfo, 0,
-                                        eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_DISASSOC_IND);
+                    pRoamInfo->staId = (tANI_U8)pDisassocInd->staId;
 
-                        /*
-                         *  STA/P2P client got  disassociated so remove any pending deauth
-                         *  commands in sme pending list
-                         */
-                        pCommand->command = eSmeCommandRoam;
-                        pCommand->sessionId = (tANI_U8)sessionId;
-                        pCommand->u.roamCmd.roamReason = eCsrForcedDeauthSta;
-                        vos_mem_copy(pCommand->u.roamCmd.peerMac,
-                                     pDisassocInd->peerMacAddr,
-                                     sizeof(tSirMacAddr));
-                        csrRoamRemoveDuplicateCommand(pMac, sessionId, pCommand, eCsrForcedDeauthSta);
-                        csrReleaseCommand( pMac, pCommand );
+                    palCopyMemory(pMac->hHdd, pRoamInfo->peerMac, pDisassocInd->peerMacAddr, sizeof(tSirMacAddr));
+                    palCopyMemory(pMac->hHdd, &pRoamInfo->bssid, pDisassocInd->bssId, sizeof(tCsrBssid));
 
-                    }
-                }
-                else
-                {
-                    smsLog(pMac, LOGE, FL(" Session Id not found for BSSID " MAC_ADDRESS_STR),
-                                            MAC_ADDR_ARRAY(pDisassocInd->bssId));
+                    status = csrRoamCallCallback(pMac, sessionId, pRoamInfo, 0, eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_DISASSOC_IND);
+
+                    /*
+                    *  STA/P2P client got  disassociated so remove any pending deauth 
+                    *  commands in sme pending list
+                    */
+                    pCommand.command = eSmeCommandRoam;
+                    pCommand.sessionId = (tANI_U8)sessionId;
+                    pCommand.u.roamCmd.roamReason = eCsrForcedDeauthSta;
+                    vos_mem_copy(pCommand.u.roamCmd.peerMac, pDisassocInd->peerMacAddr, sizeof(tSirMacAddr));
+                    csrRoamRemoveDuplicateCommand(pMac, sessionId, &pCommand, eCsrForcedDeauthSta);
                 }
             }
             break;
@@ -11930,22 +12004,36 @@
         }
 #endif /* FEATURE_WLAN_CCX */
         // addIEScan
-        if (pProfile->nAddIEScanLength)
+        if(pProfile->nAddIEScanLength && pProfile->pAddIEScan)
         {
             ieLen = pProfile->nAddIEScanLength;
-            memset(pSession->addIEScan, 0 , pSession->nAddIEScanLength);
+            if(ieLen > pSession->nAddIEScanLength)
+            {
+                if(pSession->pAddIEScan && pSession->nAddIEScanLength)
+                {
+                    palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+                }
+                status = palAllocateMemory(pMac->hHdd,
+                                 (void **)&pSession->pAddIEScan, ieLen);
+                if(!HAL_STATUS_SUCCESS(status)) break;
+            }
             pSession->nAddIEScanLength = ieLen;
-            vos_mem_copy(pSession->addIEScan, pProfile->addIEScan, ieLen);
+            palCopyMemory(pMac->hHdd, pSession->pAddIEScan, 
+                                      pProfile->pAddIEScan, ieLen);
             wTmp = pal_cpu_to_be16( ieLen );
             palCopyMemory( pMac->hHdd, pBuf, &wTmp, sizeof(tANI_U16) );
             pBuf += sizeof(tANI_U16);
-            vos_mem_copy(pBuf, pProfile->addIEScan, ieLen);
+            palCopyMemory( pMac->hHdd, pBuf, pProfile->pAddIEScan, ieLen );
             pBuf += ieLen;
         }
         else
         {
-            memset(pSession->addIEScan, 0, pSession->nAddIEScanLength);
             pSession->nAddIEScanLength = 0;
+            if(pSession->pAddIEScan)
+            {
+                palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+                pSession->pAddIEScan = NULL;
+            }
             *pBuf = 0;
             *(pBuf + 1) = 0;
             pBuf += 2;
@@ -13461,9 +13549,10 @@
     }
     pSession->nWapiRspIeLength = 0;
 #endif /* FEATURE_WLAN_WAPI */
-    if (pSession->nAddIEScanLength)
+    if(pSession->pAddIEScan)
     {
-       memset(pSession->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH);
+        palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+        pSession->pAddIEScan = NULL;
     }
     pSession->nAddIEScanLength = 0;
     if(pSession->pAddIEAssoc)
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c	2014-12-03 11:07:31.000000000 +0000
@@ -3664,14 +3664,12 @@
         if ( CSR_IS_CHANNEL_5GHZ( pMac->scan.channelOf11dInfo ) )
         {
             // and the 2.4 band is empty, then populate the 2.4 channel info
-            if ( !csrLLIsListEmpty( &pMac->scan.channelPowerInfoList24, LL_ACCESS_LOCK ) ) break;
             fPopulate5GBand = FALSE;
         }
         else
         {
             // else, we found channel info in the 2.4 GHz band.  If the 5.0 band is empty
             // set the 5.0 band info from the 2.4 country code.
-            if ( !csrLLIsListEmpty( &pMac->scan.channelPowerInfoList5G, LL_ACCESS_LOCK ) ) break;
             fPopulate5GBand = TRUE;
         }
         csrSaveChannelPowerForBand( pMac, fPopulate5GBand );
@@ -3766,6 +3764,7 @@
 tANI_BOOLEAN csrLearnCountryInformation( tpAniSirGlobal pMac, tSirBssDescription *pSirBssDesc,
                                          tDot11fBeaconIEs *pIes, tANI_BOOLEAN fForce)
 {
+    tANI_U8 Num2GChannels, bMaxNumChn;
     eHalStatus status;
     tANI_BOOLEAN fRet = eANI_BOOLEAN_FALSE;
     v_REGDOMAIN_t domainId;
@@ -3885,66 +3884,56 @@
             }
         }
         smsLog(pMac, LOG3, FL("  %d sets each one is %d"), pIesLocal->Country.num_triplets, sizeof(tSirMacChanInfo));
-
-        // set the indicator of the channel where the country IE was found...
-        pMac->scan.channelOf11dInfo = pSirBssDesc->channelId;
-        status = csrGetRegulatoryDomainForCountry(pMac,
-                       pIesLocal->Country.country, &domainId );
-        if ( status != eHAL_STATUS_SUCCESS )
+        // save the channel/power information from the Channel IE.
+        //sizeof(tSirMacChanInfo) has to be 3
+        if (eHAL_STATUS_SUCCESS != csrSaveToChannelPower2G_5G( pMac, pIesLocal->Country.num_triplets * sizeof(tSirMacChanInfo),
+                    (tSirMacChanInfo *)(&pIesLocal->Country.triplets[0]) ))
         {
-            smsLog( pMac, LOGE, FL("  fail to get regId %d"), domainId );
             fRet = eANI_BOOLEAN_FALSE;
             return fRet;
         }
+
+        // set the indicator of the channel where the country IE was found...
+        pMac->scan.channelOf11dInfo = pSirBssDesc->channelId;
+        csrGetRegulatoryDomainForCountry(pMac, pIesLocal->Country.country, &domainId );
         // Checking for Domain Id change
         if ( domainId != pMac->scan.domainIdCurrent )
         {
-            vos_mem_copy(pMac->scan.countryCode11d,
-                                  pIesLocal->Country.country,
-                                  sizeof( pMac->scan.countryCode11d ) );
-            /* Set Current Country code and Current Regulatory domain */
-            status = csrSetRegulatoryDomain(pMac, domainId, NULL);
-            if (eHAL_STATUS_SUCCESS != status)
-            {
-                smsLog(pMac, LOGE, "Set Reg Domain Fail %d", status);
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
-            }
-            //csrSetRegulatoryDomain will fail if the country doesn't fit our domain criteria.
-            vos_mem_copy(pMac->scan.countryCodeCurrent,
-                            pIesLocal->Country.country, WNI_CFG_COUNTRY_CODE_LEN);
-            //Simply set it to cfg.
+            tSirMacChanInfo* pMacChnSet = (tSirMacChanInfo *)(&pIesLocal->Country.triplets[0]);
+            palCopyMemory( pMac->hHdd, pMac->scan.countryCode11d, pIesLocal->Country.country,
+                                        sizeof( pMac->scan.countryCode11d ) );
             csrSetCfgCountryCode(pMac, pIesLocal->Country.country);
-
-            /* overwrite the defualt country code */
-            vos_mem_copy(pMac->scan.countryCodeDefault,
-                                      pMac->scan.countryCodeCurrent,
-                                      WNI_CFG_COUNTRY_CODE_LEN);
-            /* Set Current RegDomain */
-            status = WDA_SetRegDomain(pMac, domainId);
-            if ( status != eHAL_STATUS_SUCCESS )
-            {
-                smsLog( pMac, LOGE, FL("  fail to Set regId %d"), domainId );
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
-            }
-             /* set to default domain ID */
+            WDA_SetRegDomain(pMac, domainId);
             pMac->scan.domainIdCurrent = domainId;
-            /* get the channels based on new cc */
-            status = csrInitGetChannels( pMac );
-
-            if ( status != eHAL_STATUS_SUCCESS )
+            // Check whether AP provided the 2.4GHZ list or 5GHZ list
+            if(CSR_IS_CHANNEL_24GHZ(pMacChnSet[0].firstChanNum))
             {
-                smsLog( pMac, LOGE, FL("  fail to get Channels "));
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
+                // AP Provided the 2.4 Channels, Update the 5GHz channels from nv.bin
+                csrGet5GChannels(pMac );
             }
+            else
+            {
+                // AP Provided the 5G Channels, Update the 2.4GHZ channel list from nv.bin
+                csrGet24GChannels(pMac );
+            }
+        }
+        // Populate both band channel lists based on what we found in the country information...
+        csrSetOppositeBandChannelInfo( pMac );
+        bMaxNumChn = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        // construct 2GHz channel list first
+        csrConstructCurrentValidChannelList( pMac, &pMac->scan.channelPowerInfoList24, pMac->scan.channels11d.channelList, 
+                                                bMaxNumChn, &Num2GChannels );
+        // construct 5GHz channel list now
+        if(bMaxNumChn > Num2GChannels)
+        {
+            csrConstructCurrentValidChannelList( pMac, &pMac->scan.channelPowerInfoList5G, pMac->scan.channels11d.channelList + Num2GChannels,
+                                                 bMaxNumChn - Num2GChannels,
+                                                 &pMac->scan.channels11d.numChannels );
+        }
 
-            /* reset info based on new cc, and we are done */
-            csrResetCountryInformation(pMac, eANI_BOOLEAN_TRUE, eANI_BOOLEAN_TRUE);
-            fRet = eANI_BOOLEAN_TRUE;
+        pMac->scan.channels11d.numChannels += Num2GChannels;
+        fRet = eANI_BOOLEAN_TRUE;
 
-        }
     } while( 0 );
     
     if( !pIes && pIesLocal )
@@ -6785,7 +6774,7 @@
             {
                 pScanCmd->u.scanCmd.u.scanRequest.p2pSearch = 1;
             }
-            if(pProfile->nAddIEScanLength)
+            if(pProfile->pAddIEScan)
             {
                 status = palAllocateMemory(pMac->hHdd,
                                 (void **)&pScanCmd->u.scanCmd.u.scanRequest.pIEField,
@@ -6793,7 +6782,7 @@
                 palZeroMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->nAddIEScanLength);
                 if(HAL_STATUS_SUCCESS(status))
                 {
-                    palCopyMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->addIEScan, pProfile->nAddIEScanLength);
+                    palCopyMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->pAddIEScan, pProfile->nAddIEScanLength);
                     pScanCmd->u.scanCmd.u.scanRequest.uIEFieldLen = pProfile->nAddIEScanLength;
                 }
                 else
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c	2014-12-03 11:07:31.000000000 +0000
@@ -3896,9 +3896,7 @@
     int  init_ft_flag = FALSE;
 #endif
 
-    // if session id invalid then we need return failure
-    if (NULL == pNeighborRoamInfo  || !CSR_IS_SESSION_VALID(pMac, sessionId) ||
-	(NULL == pMac->roam.roamSession[sessionId].pCurRoamProfile))
+    if (NULL == pNeighborRoamInfo)
     {
         return eHAL_STATUS_FAILURE;
     }
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c	2014-12-03 11:07:31.000000000 +0000
@@ -5759,10 +5759,11 @@
             pProfile->pWAPIReqIE = NULL;
         }
 #endif /* FEATURE_WLAN_WAPI */
-        if (pProfile->nAddIEScanLength)
+
+        if(pProfile->pAddIEScan)
         {
-           memset(pProfile->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH+2);
-           pProfile->nAddIEScanLength = 0;
+            palFreeMemory(pMac->hHdd, pProfile->pAddIEScan);
+            pProfile->pAddIEScan = NULL;
         }
 
         if(pProfile->pAddIEAssoc)
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c	2014-12-03 11:07:31.000000000 +0000
@@ -5960,11 +5960,6 @@
          smsLog(pMac, LOG2, "%s:SSID=%s frame length %d",
              __func__, dumpSsId, pPrefNetworkFoundInd->frameLength);
 
-         /* Flush scan results, So as to avoid indication/updation of
-          * stale entries, which may not have aged out during APPS collapse
-          */
-         sme_ScanFlushResult(hHal,0);
-
          //Save the frame to scan result
          if (pPrefNetworkFoundInd->mesgLen > sizeof(tSirPrefNetworkFoundInd))
          {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.c	2014-12-03 11:07:31.000000000 +0000
@@ -626,8 +626,7 @@
       "%s: MC Thread exiting!!!!", __func__);
   complete_and_exit(&pSchedContext->McShutdown, 0);
 } /* VosMCThread() */
-
-v_BOOL_t isWDresetInProgress(void)
+int isWDresetInProgress(void)
 {
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO,
                 "%s: Reset is in Progress...",__func__);
@@ -637,7 +636,7 @@
    }
    else
    {
-      return FALSE;
+      return 0;
    }
 }
 /*---------------------------------------------------------------------------
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.h	2014-12-03 11:07:31.000000000 +0000
@@ -504,6 +504,5 @@
 void vos_timer_module_init( void );
 VOS_STATUS vos_watchdog_wlan_shutdown(void);
 VOS_STATUS vos_watchdog_wlan_re_init(void);
-v_BOOL_t isWDresetInProgress(void);
 
 #endif // #if !defined __VOSS_SCHED_H
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c	2014-12-03 11:07:31.000000000 +0000
@@ -1477,38 +1477,6 @@
    tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
                             + sizeof(tHalCfg) + tlvStruct->length) ;
 
-   /* QWLAN_HAL_CFG_RA_FILTER_ENABLE  */
-   tlvStruct->type = QWLAN_HAL_CFG_RA_FILTER_ENABLE ;
-   tlvStruct->length = sizeof(tANI_U32);
-   configDataValue = (tANI_U32 *)(tlvStruct + 1);
-
-   if (wlan_cfgGetInt(pMac, WNI_CFG_RA_FILTER_ENABLE,
-                                            configDataValue ) != eSIR_SUCCESS)
-   {
-      VOS_TRACE( VOS_MODULE_ID_WDA, VOS_TRACE_LEVEL_ERROR,
-               "Failed to get value for WNI_CFG_RA_FILTER_ENABLE");
-      goto handle_failure;
-   }
-
-   tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
-                           + sizeof(tHalCfg) + tlvStruct->length) ;
-
-   /* QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL  */
-   tlvStruct->type = QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL ;
-   tlvStruct->length = sizeof(tANI_U32);
-   configDataValue = (tANI_U32 *)(tlvStruct + 1);
-
-   if (wlan_cfgGetInt(pMac, WNI_CFG_RA_RATE_LIMIT_INTERVAL,
-                                            configDataValue ) != eSIR_SUCCESS)
-   {
-      VOS_TRACE( VOS_MODULE_ID_WDA, VOS_TRACE_LEVEL_ERROR,
-               "Failed to get value for WNI_CFG_RA_RATE_LIMIT_INTERVAL");
-      goto handle_failure;
-   }
-
-   tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
-                           + sizeof(tHalCfg) + tlvStruct->length) ;
-
    wdiStartParams->usConfigBufferLen = (tANI_U8 *)tlvStruct - tlvStructStart ;
 #ifdef WLAN_DEBUG
    {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/Kbuild flo-ElementalX-5.00-patched/drivers/staging/prima/Kbuild
--- flo-ElementalX-5.00/drivers/staging/prima/Kbuild	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/Kbuild	2014-12-03 11:07:31.000000000 +0000
@@ -628,7 +628,7 @@
 endif
 
 # Fix build for GCC 4.7
-EXTRA_CFLAGS += -Wno-maybe-uninitialized -Wno-unused-function -Wno-array-bounds
+EXTRA_CFLAGS += -Wno-maybe-uninitialized -Wno-unused-function
 
 KBUILD_CPPFLAGS += $(CDEFINES)
 
Binary files flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_cfg.dat and flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_cfg.dat differ
diff -urN flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini
--- flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini	2014-12-03 11:07:31.000000000 +0000
@@ -396,20 +396,6 @@
 gRrmNonOperChanMax=8
 gRrmRandIntvl=100
 
-# TDLS Support
-gEnableTDLSSupport=1
-gEnableTDLSImplicitTrigger=1
-gTDLSExternalControl=1
-gTDLSTxStatsPeriod=500
-gTDLSTxPacketThreshold=10
-gTDLSDiscoveryPeriod=20000
-gTDLSMaxDiscoveryAttempt=5
-gTDLSIdleTimeout=40000
-gTDLSRssiHysteresis=100
-gTDLSRSSITriggerThreshold=-60
-gTDLSIdlePacketThreshold=5
-gTDLSRSSITeardownThreshold=-70
-
 END
 
 # Note: Configuration parser would not read anything past the END marker
diff -urN flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_cfg.h flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_cfg.h
--- flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_cfg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_cfg.h	2014-12-03 11:07:31.000000000 +0000
@@ -155,9 +155,8 @@
 #define QWLAN_HAL_CFG_ENABLE_DETECT_PS_SUPPORT          101
 #define QWLAN_HAL_CFG_AP_LINK_MONITOR_TIMEOUT           102
 #define QWLAN_HAL_CFG_BTC_DWELL_TIME_MULTIPLIER         103
-#define QWLAN_HAL_CFG_RA_FILTER_ENABLE                  104
-#define QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL            105
-#define QWLAN_HAL_CFG_MAX_PARAMS                        106
+#define QWLAN_HAL_CFG_ENABLE_TDLS_OXYGEN_MODE           104
+#define QWLAN_HAL_CFG_MAX_PARAMS                        105
 
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_msg.h flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_msg.h
--- flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_msg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_msg.h	2014-12-03 11:07:31.000000000 +0000
@@ -5666,7 +5666,6 @@
     RATECTRL           = 21,
     WOW                = 22,
     WLAN_ROAM_SCAN_OFFLOAD = 23,
-    EXTENDED_NSOFFLOAD_SLOT = 24,
     //MAX_FEATURE_SUPPORTED = 128
 } placeHolderInCapBitmap;
 
diff -urN flo-ElementalX-5.00/drivers/staging/vt6656/main_usb.c flo-ElementalX-5.00-patched/drivers/staging/vt6656/main_usb.c
--- flo-ElementalX-5.00/drivers/staging/vt6656/main_usb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/vt6656/main_usb.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,2097 +0,0 @@
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * File: main_usb.c
- *
- * Purpose: driver entry for initial, open, close, tx and rx.
- *
- * Author: Lyndon Chen
- *
- * Date: Dec 8, 2005
- *
- * Functions:
- *
- *   vt6656_probe - module initial (insmod) driver entry
- *   device_remove1 - module remove entry
- *   device_open - allocate dma/descripter resource & initial mac/bbp function
- *   device_xmit - asynchrous data tx function
- *   device_set_multi - set mac filter
- *   device_ioctl - ioctl entry
- *   device_close - shutdown mac/bbp & free dma/descripter resource
- *   device_alloc_frag_buf - rx fragement pre-allocated function
- *   device_free_tx_bufs - free tx buffer function
- *   device_dma0_tx_80211- tx 802.11 frame via dma0
- *   device_dma0_xmit- tx PS bufferred frame via dma0
- *   device_init_registers- initial MAC & BBP & RF internal registers.
- *   device_init_rings- initial tx/rx ring buffer
- *   device_init_defrag_cb- initial & allocate de-fragement buffer.
- *   device_tx_srv- tx interrupt service function
- *
- * Revision History:
- */
-#undef __NO_VERSION__
-
-#include "device.h"
-#include "card.h"
-#include "baseband.h"
-#include "mac.h"
-#include "tether.h"
-#include "wmgr.h"
-#include "wctl.h"
-#include "power.h"
-#include "wcmd.h"
-#include "iocmd.h"
-#include "tcrc.h"
-#include "rxtx.h"
-#include "bssdb.h"
-#include "hostap.h"
-#include "wpactl.h"
-#include "ioctl.h"
-#include "iwctl.h"
-#include "dpc.h"
-#include "datarate.h"
-#include "rf.h"
-#include "firmware.h"
-#include "rndis.h"
-#include "control.h"
-#include "channel.h"
-#include "int.h"
-#include "iowpa.h"
-
-/*---------------------  Static Definitions -------------------------*/
-//static int          msglevel                =MSG_LEVEL_DEBUG;
-static int          msglevel                =MSG_LEVEL_INFO;
-
-//
-// Define module options
-//
-
-// Version Information
-#define DRIVER_AUTHOR "VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>"
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION(DEVICE_FULL_DRV_NAM);
-
-#define DEVICE_PARAM(N,D) \
-        static int N[MAX_UINTS]=OPTION_DEFAULT;\
-        module_param_array(N, int, NULL, 0);\
-        MODULE_PARM_DESC(N, D);
-
-#define RX_DESC_MIN0     16
-#define RX_DESC_MAX0     128
-#define RX_DESC_DEF0     64
-DEVICE_PARAM(RxDescriptors0,"Number of receive usb desc buffer");
-
-
-#define TX_DESC_MIN0     16
-#define TX_DESC_MAX0     128
-#define TX_DESC_DEF0     64
-DEVICE_PARAM(TxDescriptors0,"Number of transmit usb desc buffer");
-
-
-#define CHANNEL_MIN     1
-#define CHANNEL_MAX     14
-#define CHANNEL_DEF     6
-
-DEVICE_PARAM(Channel, "Channel number");
-
-
-/* PreambleType[] is the preamble length used for transmit.
-   0: indicate allows long preamble type
-   1: indicate allows short preamble type
-*/
-
-#define PREAMBLE_TYPE_DEF     1
-
-DEVICE_PARAM(PreambleType, "Preamble Type");
-
-
-#define RTS_THRESH_MIN     512
-#define RTS_THRESH_MAX     2347
-#define RTS_THRESH_DEF     2347
-
-DEVICE_PARAM(RTSThreshold, "RTS threshold");
-
-
-#define FRAG_THRESH_MIN     256
-#define FRAG_THRESH_MAX     2346
-#define FRAG_THRESH_DEF     2346
-
-DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
-
-
-#define DATA_RATE_MIN     0
-#define DATA_RATE_MAX     13
-#define DATA_RATE_DEF     13
-/* datarate[] index
-   0: indicate 1 Mbps   0x02
-   1: indicate 2 Mbps   0x04
-   2: indicate 5.5 Mbps 0x0B
-   3: indicate 11 Mbps  0x16
-   4: indicate 6 Mbps   0x0c
-   5: indicate 9 Mbps   0x12
-   6: indicate 12 Mbps  0x18
-   7: indicate 18 Mbps  0x24
-   8: indicate 24 Mbps  0x30
-   9: indicate 36 Mbps  0x48
-  10: indicate 48 Mbps  0x60
-  11: indicate 54 Mbps  0x6c
-  12: indicate 72 Mbps  0x90
-  13: indicate auto rate
-*/
-
-DEVICE_PARAM(ConnectionRate, "Connection data rate");
-
-#define OP_MODE_MAX     2
-#define OP_MODE_DEF     0
-#define OP_MODE_MIN     0
-
-DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
-
-/* OpMode[] is used for transmit.
-   0: indicate infrastruct mode used
-   1: indicate adhoc mode used
-   2: indicate AP mode used
-*/
-
-
-/* PSMode[]
-   0: indicate disable power saving mode
-   1: indicate enable power saving mode
-*/
-
-#define PS_MODE_DEF     0
-
-DEVICE_PARAM(PSMode, "Power saving mode");
-
-
-#define SHORT_RETRY_MIN     0
-#define SHORT_RETRY_MAX     31
-#define SHORT_RETRY_DEF     8
-
-
-DEVICE_PARAM(ShortRetryLimit, "Short frame retry limits");
-
-#define LONG_RETRY_MIN     0
-#define LONG_RETRY_MAX     15
-#define LONG_RETRY_DEF     4
-
-
-DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
-
-
-/* BasebandType[] baseband type selected
-   0: indicate 802.11a type
-   1: indicate 802.11b type
-   2: indicate 802.11g type
-*/
-#define BBP_TYPE_MIN     0
-#define BBP_TYPE_MAX     2
-#define BBP_TYPE_DEF     2
-
-DEVICE_PARAM(BasebandType, "baseband type");
-
-
-
-/* 80211hEnable[]
-   0: indicate disable 802.11h
-   1: indicate enable 802.11h
-*/
-
-#define X80211h_MODE_DEF     0
-
-DEVICE_PARAM(b80211hEnable, "802.11h mode");
-
-
-//
-// Static vars definitions
-//
-
-static struct usb_device_id vt6656_table[] __devinitdata = {
-	{USB_DEVICE(VNT_USB_VENDOR_ID, VNT_USB_PRODUCT_ID)},
-	{}
-};
-
-// Frequency list (map channels to frequencies)
-/*
-static const long frequency_list[] = {
-    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2484,
-    4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,
-    5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210, 5220, 5230, 5240,
-    5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600, 5620, 5640, 5660, 5680,
-    5700, 5745, 5765, 5785, 5805, 5825
-	};
-
-
-#ifndef IW_ENCODE_NOKEY
-#define IW_ENCODE_NOKEY         0x0800
-#define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
-#endif
-
-static const struct iw_handler_def	iwctl_handler_def;
-*/
-
-/*---------------------  Static Functions  --------------------------*/
-
-static int vt6656_probe(struct usb_interface *intf,
-			const struct usb_device_id *id);
-static void vt6656_disconnect(struct usb_interface *intf);
-
-#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
-static int vt6656_suspend(struct usb_interface *intf, pm_message_t message);
-static int vt6656_resume(struct usb_interface *intf);
-#endif /* CONFIG_PM */
-
-static struct net_device_stats *device_get_stats(struct net_device *dev);
-static int  device_open(struct net_device *dev);
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
-static void device_set_multi(struct net_device *dev);
-static int  device_close(struct net_device *dev);
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-
-static BOOL device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
-static BOOL device_init_defrag_cb(PSDevice pDevice);
-static void device_init_diversity_timer(PSDevice pDevice);
-static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
-
-static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
-static void device_free_tx_bufs(PSDevice pDevice);
-static void device_free_rx_bufs(PSDevice pDevice);
-static void device_free_int_bufs(PSDevice pDevice);
-static void device_free_frag_bufs(PSDevice pDevice);
-static BOOL device_alloc_bufs(PSDevice pDevice);
-
-static int Read_config_file(PSDevice pDevice);
-static unsigned char *Config_FileOperation(PSDevice pDevice);
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest,
-				   unsigned char *source);
-
-static BOOL device_release_WPADEV(PSDevice pDevice);
-
-static void usb_device_reset(PSDevice pDevice);
-
-
-
-/*---------------------  Export Variables  --------------------------*/
-
-/*---------------------  Export Functions  --------------------------*/
-
-
-static void
-device_set_options(PSDevice pDevice) {
-
-    BYTE    abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    BYTE    abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    u8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-
-    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
-
-    pDevice->cbTD = TX_DESC_DEF0;
-    pDevice->cbRD = RX_DESC_DEF0;
-    pDevice->uChannel = CHANNEL_DEF;
-    pDevice->wRTSThreshold = RTS_THRESH_DEF;
-    pDevice->wFragmentationThreshold = FRAG_THRESH_DEF;
-    pDevice->byShortRetryLimit = SHORT_RETRY_DEF;
-    pDevice->byLongRetryLimit = LONG_RETRY_DEF;
-    pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
-    pDevice->byShortPreamble = PREAMBLE_TYPE_DEF;
-    pDevice->ePSMode = PS_MODE_DEF;
-    pDevice->b11hEnable = X80211h_MODE_DEF;
-    pDevice->eOPMode = OP_MODE_DEF;
-    pDevice->uConnectionRate = DATA_RATE_DEF;
-    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = TRUE;
-    pDevice->byBBType = BBP_TYPE_DEF;
-    pDevice->byPacketType = pDevice->byBBType;
-    pDevice->byAutoFBCtrl = AUTO_FB_0;
-    pDevice->bUpdateBBVGA = TRUE;
-    pDevice->byFOETuning = 0;
-    pDevice->byAutoPwrTunning = 0;
-    pDevice->wCTSDuration = 0;
-    pDevice->byPreambleType = 0;
-    pDevice->bExistSWNetAddr = FALSE;
-//    pDevice->bDiversityRegCtlON = TRUE;
-    pDevice->bDiversityRegCtlON = FALSE;
-}
-
-
-static void device_init_diversity_timer(PSDevice pDevice)
-{
-    init_timer(&pDevice->TimerSQ3Tmax1);
-    pDevice->TimerSQ3Tmax1.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
-
-    init_timer(&pDevice->TimerSQ3Tmax2);
-    pDevice->TimerSQ3Tmax2.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
-
-    init_timer(&pDevice->TimerSQ3Tmax3);
-    pDevice->TimerSQ3Tmax3.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerSQ3Tmax3CallBack;
-    pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
-
-    return;
-}
-
-
-//
-// Initialiation of MAC & BBP registers
-//
-
-static BOOL device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
-{
-    u8 abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    u8 abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    u8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-    BYTE            byAntenna;
-    unsigned int            ii;
-    CMD_CARD_INIT   sInitCmd;
-    int ntStatus = STATUS_SUCCESS;
-    RSP_CARD_INIT   sInitRsp;
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    BYTE            byTmp;
-    BYTE            byCalibTXIQ = 0;
-    BYTE            byCalibTXDC = 0;
-    BYTE            byCalibRXIQ = 0;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---->INIbInitAdapter. [%d][%d]\n", InitType, pDevice->byPacketType);
-	spin_lock_irq(&pDevice->lock);
-	if (InitType == DEVICE_INIT_COLD) {
-		memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-		memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-		memcpy(pDevice->abySNAP_Bridgetunnel,
-		       abySNAP_Bridgetunnel,
-		       ETH_ALEN);
-
-        if ( !FIRMWAREbCheckVersion(pDevice) ) {
-            if (FIRMWAREbDownload(pDevice) == TRUE) {
-                if (FIRMWAREbBrach2Sram(pDevice) == FALSE) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbBrach2Sram fail \n");
-                  	spin_unlock_irq(&pDevice->lock);
-                    return FALSE;
-                }
-            } else {
-
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbDownload fail \n");
-                spin_unlock_irq(&pDevice->lock);
-                return FALSE;
-            }
-        }
-
-        if ( !BBbVT3184Init(pDevice) ) {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" BBbVT3184Init fail \n");
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-    }
-
-    sInitCmd.byInitClass = (BYTE)InitType;
-    sInitCmd.bExistSWNetAddr = (BYTE) pDevice->bExistSWNetAddr;
-    for (ii = 0; ii < 6; ii++)
-	sInitCmd.bySWNetAddr[ii] = pDevice->abyCurrentNetAddr[ii];
-    sInitCmd.byShortRetryLimit = pDevice->byShortRetryLimit;
-    sInitCmd.byLongRetryLimit = pDevice->byLongRetryLimit;
-
-    //issue Card_init command to device
-    ntStatus = CONTROLnsRequestOut(pDevice,
-                                    MESSAGE_TYPE_CARDINIT,
-                                    0,
-                                    0,
-                                    sizeof(CMD_CARD_INIT),
-                                    (PBYTE) &(sInitCmd));
-
-    if ( ntStatus != STATUS_SUCCESS ) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Issue Card init fail \n");
-        spin_unlock_irq(&pDevice->lock);
-        return FALSE;
-    }
-    if (InitType == DEVICE_INIT_COLD) {
-
-        ntStatus = CONTROLnsRequestIn(pDevice,MESSAGE_TYPE_INIT_RSP,0,0,sizeof(RSP_CARD_INIT), (PBYTE) &(sInitRsp));
-
-        if (ntStatus != STATUS_SUCCESS) {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Cardinit request in status fail!\n");
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-
-        //Local ID for AES functions
-        ntStatus = CONTROLnsRequestIn(pDevice,
-                                    MESSAGE_TYPE_READ,
-                                    MAC_REG_LOCALID,
-                                    MESSAGE_REQUEST_MACREG,
-                                    1,
-                                    &pDevice->byLocalID);
-
-        if ( ntStatus != STATUS_SUCCESS ) {
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-
-        // Do MACbSoftwareReset in MACvInitialize
-        // force CCK
-        pDevice->bCCK = TRUE;
-        pDevice->bProtectMode = FALSE;          //Only used in 11g type, sync with ERP IE
-        pDevice->bNonERPPresent = FALSE;
-        pDevice->bBarkerPreambleMd = FALSE;
-        if ( pDevice->bFixRate ) {
-            pDevice->wCurrentRate = (WORD) pDevice->uConnectionRate;
-        } else {
-            if ( pDevice->byBBType == BB_TYPE_11B )
-                pDevice->wCurrentRate = RATE_11M;
-            else
-                pDevice->wCurrentRate = RATE_54M;
-        }
-
-        CHvInitChannelTable(pDevice);
-
-        pDevice->byTopOFDMBasicRate = RATE_24M;
-        pDevice->byTopCCKBasicRate = RATE_1M;
-        pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
-        pDevice->byCurPwr = 0xFF;
-
-        pDevice->byCCKPwr = pDevice->abyEEPROM[EEP_OFS_PWR_CCK];
-        pDevice->byOFDMPwrG = pDevice->abyEEPROM[EEP_OFS_PWR_OFDMG];
-        // Load power Table
-        for (ii=0;ii<14;ii++) {
-            pDevice->abyCCKPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_CCK_PWR_TBL];
-            if (pDevice->abyCCKPwrTbl[ii] == 0)
-                pDevice->abyCCKPwrTbl[ii] = pDevice->byCCKPwr;
-            pDevice->abyOFDMPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDM_PWR_TBL];
-            if (pDevice->abyOFDMPwrTbl[ii] == 0)
-                pDevice->abyOFDMPwrTbl[ii] = pDevice->byOFDMPwrG;
-        }
-
-	  //original zonetype is USA,but customize zonetype is europe,
-	  // then need recover 12,13 ,14 channel  with 11 channel
-          if(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
-	        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&
-	     (pDevice->byOriginalZonetype == ZoneType_USA)) {
-		for (ii = 11; ii < 14; ii++) {
-			pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-			pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
-		}
-	  }
-
-        //{{ RobertYu: 20041124
-        pDevice->byOFDMPwrA = 0x34; // same as RFbMA2829SelectChannel
-        // Load OFDM A Power Table
-        for (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
-            pDevice->abyOFDMAPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDMA_PWR_TBL];
-            if (pDevice->abyOFDMAPwrTbl[ii] == 0)
-                pDevice->abyOFDMAPwrTbl[ii] = pDevice->byOFDMPwrA;
-        }
-        //}} RobertYu
-
-        byAntenna = pDevice->abyEEPROM[EEP_OFS_ANTENNA];
-        if (byAntenna & EEP_ANTINV)
-            pDevice->bTxRxAntInv = TRUE;
-        else
-            pDevice->bTxRxAntInv = FALSE;
-
-        byAntenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-        if (byAntenna == 0) // if not set default is All
-            byAntenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-        if (byAntenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-            pDevice->byAntennaCount = 2;
-            pDevice->byTxAntennaMode = ANT_B;
-            pDevice->dwTxAntennaSel = 1;
-            pDevice->dwRxAntennaSel = 1;
-            if (pDevice->bTxRxAntInv == TRUE)
-                pDevice->byRxAntennaMode = ANT_A;
-            else
-                pDevice->byRxAntennaMode = ANT_B;
-
-            if (pDevice->bDiversityRegCtlON)
-                pDevice->bDiversityEnable = TRUE;
-            else
-                pDevice->bDiversityEnable = FALSE;
-        } else  {
-            pDevice->bDiversityEnable = FALSE;
-            pDevice->byAntennaCount = 1;
-            pDevice->dwTxAntennaSel = 0;
-            pDevice->dwRxAntennaSel = 0;
-            if (byAntenna & EEP_ANTENNA_AUX) {
-                pDevice->byTxAntennaMode = ANT_A;
-                if (pDevice->bTxRxAntInv == TRUE)
-                    pDevice->byRxAntennaMode = ANT_B;
-                else
-                    pDevice->byRxAntennaMode = ANT_A;
-            } else {
-                pDevice->byTxAntennaMode = ANT_B;
-                if (pDevice->bTxRxAntInv == TRUE)
-                    pDevice->byRxAntennaMode = ANT_A;
-                else
-                    pDevice->byRxAntennaMode = ANT_B;
-            }
-        }
-        pDevice->ulDiversityNValue = 100*255;
-        pDevice->ulDiversityMValue = 100*16;
-        pDevice->byTMax = 1;
-        pDevice->byTMax2 = 4;
-        pDevice->ulSQ3TH = 0;
-        pDevice->byTMax3 = 64;
-        // -----------------------------------------------------------------
-
-        //Get Auto Fall Back Type
-        pDevice->byAutoFBCtrl = AUTO_FB_0;
-
-        // Set SCAN Time
-        pDevice->uScanTime = WLAN_SCAN_MINITIME;
-
-        // default Auto Mode
-        //pDevice->NetworkType = Ndis802_11Automode;
-        pDevice->eConfigPHYMode = PHY_TYPE_AUTO;
-        pDevice->byBBType = BB_TYPE_11G;
-
-        // initialize BBP registers
-        pDevice->ulTxPower = 25;
-
-        // Get Channel range
-        pDevice->byMinChannel = 1;
-        pDevice->byMaxChannel = CB_MAX_CHANNEL;
-
-        // Get RFType
-        pDevice->byRFType = sInitRsp.byRFType;
-
-        if ((pDevice->byRFType & RF_EMU) != 0) {
-            // force change RevID for VT3253 emu
-            pDevice->byRevId = 0x80;
-        }
-
-        // Load EEPROM calibrated vt3266 parameters
-        if (pDevice->byRFType == RF_VT3226D0) {
-            if((pDevice->abyEEPROM[EEP_OFS_MAJOR_VER] == 0x1) &&
-                (pDevice->abyEEPROM[EEP_OFS_MINOR_VER] >= 0x4)) {
-                byCalibTXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_IQ];
-                byCalibTXDC = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_DC];
-                byCalibRXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_RX_IQ];
-                if( (byCalibTXIQ || byCalibTXDC || byCalibRXIQ) ) {
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x03); // CR255, Set BB to support TX/RX IQ and DC compensation Mode
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFB, byCalibTXIQ); // CR251, TX I/Q Imbalance Calibration
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFC, byCalibTXDC); // CR252, TX DC-Offset Calibration
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFD, byCalibRXIQ); // CR253, RX I/Q Imbalance Calibration
-                } else {
-                // turn off BB Calibration compensation
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x0); // CR255
-                }
-            }
-        }
-        pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-        pMgmt->uCurrChannel = pDevice->uChannel;
-        pMgmt->uIBSSChannel = pDevice->uChannel;
-        CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
-
-        // get Permanent network address
-        memcpy(pDevice->abyPermanentNetAddr,&(sInitRsp.byNetAddr[0]),6);
-	memcpy(pDevice->abyCurrentNetAddr,
-	       pDevice->abyPermanentNetAddr,
-	       ETH_ALEN);
-
-        // if exist SW network address, use SW network address.
-
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %pM\n",
-		pDevice->abyCurrentNetAddr);
-    }
-
-    // Set BB and packet type at the same time.
-    // Set Short Slot Time, xIFS, and RSPINF.
-    if (pDevice->byBBType == BB_TYPE_11A) {
-        CARDbAddBasicRate(pDevice, RATE_6M);
-        pDevice->bShortSlotTime = TRUE;
-    } else {
-        CARDbAddBasicRate(pDevice, RATE_1M);
-        pDevice->bShortSlotTime = FALSE;
-    }
-    BBvSetShortSlotTime(pDevice);
-    CARDvSetBSSMode(pDevice);
-
-    if (pDevice->bUpdateBBVGA) {
-        pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
-        pDevice->byBBVGANew = pDevice->byBBVGACurrent;
-        BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-    }
-
-    pDevice->byRadioCtl = pDevice->abyEEPROM[EEP_OFS_RADIOCTL];
-    pDevice->bHWRadioOff = FALSE;
-    if ( (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) != 0 ) {
-        ntStatus = CONTROLnsRequestIn(pDevice,
-                                    MESSAGE_TYPE_READ,
-                                    MAC_REG_GPIOCTL1,
-                                    MESSAGE_REQUEST_MACREG,
-                                    1,
-                                    &byTmp);
-
-        if ( ntStatus != STATUS_SUCCESS ) {
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-        if ( (byTmp & GPIO3_DATA) == 0 ) {
-            pDevice->bHWRadioOff = TRUE;
-            MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-        } else {
-            MACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-            pDevice->bHWRadioOff = FALSE;
-        }
-
-    } //EEP_RADIOCTL_ENABLE
-
-    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_TMLEN,0x38);
-    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
-    MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL0,0x01);
-
-    if ((pDevice->bHWRadioOff == TRUE) || (pDevice->bRadioControlOff == TRUE)) {
-        CARDbRadioPowerOff(pDevice);
-    } else {
-        CARDbRadioPowerOn(pDevice);
-    }
-
-    spin_unlock_irq(&pDevice->lock);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----INIbInitAdapter Exit\n");
-    return TRUE;
-}
-
-static BOOL device_release_WPADEV(PSDevice pDevice)
-{
-  viawget_wpa_header *wpahdr;
-  int ii=0;
- // wait_queue_head_t	Set_wait;
-  //send device close to wpa_supplicnat layer
-    if (pDevice->bWPADEVUp==TRUE) {
-                 wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-                 wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
-                 wpahdr->resp_ie_len = 0;
-                 wpahdr->req_ie_len = 0;
-                 skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-                 pDevice->skb->dev = pDevice->wpadev;
-		 skb_reset_mac_header(pDevice->skb);
-                 pDevice->skb->pkt_type = PACKET_HOST;
-                 pDevice->skb->protocol = htons(ETH_P_802_2);
-                 memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-                 netif_rx(pDevice->skb);
-                 pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
- //wait release WPADEV
-              //    init_waitqueue_head(&Set_wait);
-              //    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
-              while(pDevice->bWPADEVUp==TRUE) {
-	        set_current_state(TASK_UNINTERRUPTIBLE);
-                 schedule_timeout (HZ/20);          //wait 50ms
-                 ii++;
-	        if(ii>20)
-		  break;
-              }
-           }
-    return TRUE;
-}
-
-#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
-
-static int vt6656_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device || !device->dev)
-		return -ENODEV;
-
-	if (device->flags & DEVICE_FLAGS_OPENED)
-		device_close(device->dev);
-
-	usb_put_dev(interface_to_usbdev(intf));
-
-	return 0;
-}
-
-static int vt6656_resume(struct usb_interface *intf)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device || !device->dev)
-		return -ENODEV;
-
-	usb_get_dev(interface_to_usbdev(intf));
-
-	if (!(device->flags & DEVICE_FLAGS_OPENED))
-		device_open(device->dev);
-
-	return 0;
-}
-
-#endif /* CONFIG_PM */
-
-static const struct net_device_ops device_netdev_ops = {
-    .ndo_open               = device_open,
-    .ndo_stop               = device_close,
-    .ndo_do_ioctl           = device_ioctl,
-    .ndo_get_stats          = device_get_stats,
-    .ndo_start_xmit         = device_xmit,
-    .ndo_set_rx_mode	    = device_set_multi,
-};
-
-static int __devinit
-vt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	u8 fake_mac[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
-	struct usb_device *udev = interface_to_usbdev(intf);
-	int rc = 0;
-	struct net_device *netdev = NULL;
-	PSDevice pDevice = NULL;
-
-	printk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-	printk(KERN_NOTICE "Copyright (c) 2004 VIA Networking Technologies, Inc.\n");
-
-	udev = usb_get_dev(udev);
-	netdev = alloc_etherdev(sizeof(DEVICE_INFO));
-	if (!netdev) {
-		printk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");
-		rc = -ENOMEM;
-		goto err_nomem;
-	}
-
-	pDevice = netdev_priv(netdev);
-	memset(pDevice, 0, sizeof(DEVICE_INFO));
-
-	pDevice->dev = netdev;
-	pDevice->usb = udev;
-
-	device_set_options(pDevice);
-	spin_lock_init(&pDevice->lock);
-
-	pDevice->tx_80211 = device_dma0_tx_80211;
-	pDevice->sMgmtObj.pAdapter = (void *) pDevice;
-
-	netdev->netdev_ops = &device_netdev_ops;
-	netdev->wireless_handlers =
-		(struct iw_handler_def *) &iwctl_handler_def;
-
-	usb_set_intfdata(intf, pDevice);
-	SET_NETDEV_DEV(netdev, &intf->dev);
-	memcpy(pDevice->dev->dev_addr, fake_mac, ETH_ALEN);
-	rc = register_netdev(netdev);
-	if (rc) {
-		printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
-		goto err_netdev;
-	}
-
-	usb_device_reset(pDevice);
-
-	{
-		union iwreq_data wrqu;
-		memset(&wrqu, 0, sizeof(wrqu));
-		wrqu.data.flags = RT_INSMOD_EVENT_FLAG;
-		wrqu.data.length = IFNAMSIZ;
-		wireless_send_event(pDevice->dev,
-				    IWEVCUSTOM,
-				    &wrqu,
-				    pDevice->dev->name);
-	}
-
-	return 0;
-
-err_netdev:
-	free_netdev(netdev);
-err_nomem:
-	usb_put_dev(udev);
-
-	return rc;
-}
-
-static void device_free_tx_bufs(PSDevice pDevice)
-{
-    PUSB_SEND_CONTEXT pTxContext;
-    int ii;
-
-    for (ii = 0; ii < pDevice->cbTD; ii++) {
-
-        pTxContext = pDevice->apTD[ii];
-        //de-allocate URBs
-        if (pTxContext->pUrb) {
-            usb_kill_urb(pTxContext->pUrb);
-            usb_free_urb(pTxContext->pUrb);
-        }
-        kfree(pTxContext);
-    }
-    return;
-}
-
-
-static void device_free_rx_bufs(PSDevice pDevice)
-{
-    PRCB pRCB;
-    int ii;
-
-    for (ii = 0; ii < pDevice->cbRD; ii++) {
-
-        pRCB = pDevice->apRCB[ii];
-        //de-allocate URBs
-        if (pRCB->pUrb) {
-            usb_kill_urb(pRCB->pUrb);
-            usb_free_urb(pRCB->pUrb);
-        }
-        //de-allocate skb
-        if (pRCB->skb)
-            dev_kfree_skb(pRCB->skb);
-    }
-    kfree(pDevice->pRCBMem);
-
-    return;
-}
-
-static void usb_device_reset(PSDevice pDevice)
-{
- int status;
- status = usb_reset_device(pDevice->usb);
-	if (status)
-            printk("usb_device_reset fail status=%d\n",status);
-	return ;
-}
-
-static void device_free_int_bufs(PSDevice pDevice)
-{
-    kfree(pDevice->intBuf.pDataBuf);
-    return;
-}
-
-
-static BOOL device_alloc_bufs(PSDevice pDevice) {
-
-    PUSB_SEND_CONTEXT pTxContext;
-    PRCB pRCB;
-    int ii;
-
-
-    for (ii = 0; ii < pDevice->cbTD; ii++) {
-
-        pTxContext = kmalloc(sizeof(USB_SEND_CONTEXT), GFP_KERNEL);
-        if (pTxContext == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate tx usb context failed\n", pDevice->dev->name);
-            goto free_tx;
-        }
-        pDevice->apTD[ii] = pTxContext;
-	pTxContext->pDevice = (void *) pDevice;
-        //allocate URBs
-        pTxContext->pUrb = usb_alloc_urb(0, GFP_ATOMIC);
-        if (pTxContext->pUrb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "alloc tx urb failed\n");
-            goto free_tx;
-        }
-        pTxContext->bBoolInUse = FALSE;
-    }
-
-    // allocate rcb mem
-	pDevice->pRCBMem = kzalloc((sizeof(RCB) * pDevice->cbRD), GFP_KERNEL);
-    if (pDevice->pRCBMem == NULL) {
-        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : alloc rx usb context failed\n", pDevice->dev->name);
-        goto free_tx;
-    }
-
-
-    pDevice->FirstRecvFreeList = NULL;
-    pDevice->LastRecvFreeList = NULL;
-    pDevice->FirstRecvMngList = NULL;
-    pDevice->LastRecvMngList = NULL;
-    pDevice->NumRecvFreeList = 0;
-    pRCB = (PRCB) pDevice->pRCBMem;
-
-    for (ii = 0; ii < pDevice->cbRD; ii++) {
-
-        pDevice->apRCB[ii] = pRCB;
-	pRCB->pDevice = (void *) pDevice;
-        //allocate URBs
-        pRCB->pUrb = usb_alloc_urb(0, GFP_ATOMIC);
-
-        if (pRCB->pUrb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx urb\n");
-            goto free_rx_tx;
-        }
-        pRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-        if (pRCB->skb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx skb\n");
-            goto free_rx_tx;
-        }
-        pRCB->skb->dev = pDevice->dev;
-        pRCB->bBoolInUse = FALSE;
-        EnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);
-        pDevice->NumRecvFreeList++;
-        pRCB++;
-    }
-
-
-	pDevice->pControlURB = usb_alloc_urb(0, GFP_ATOMIC);
-	if (pDevice->pControlURB == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc control urb\n");
-	    goto free_rx_tx;
-	}
-
-	pDevice->pInterruptURB = usb_alloc_urb(0, GFP_ATOMIC);
-	if (pDevice->pInterruptURB == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int urb\n");
-	    usb_free_urb(pDevice->pControlURB);
-	    goto free_rx_tx;
-	}
-
-    pDevice->intBuf.pDataBuf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);
-	if (pDevice->intBuf.pDataBuf == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int buf\n");
-	    usb_free_urb(pDevice->pControlURB);
-	    usb_free_urb(pDevice->pInterruptURB);
-	    goto free_rx_tx;
-	}
-
-    return TRUE;
-
-free_rx_tx:
-    device_free_rx_bufs(pDevice);
-
-free_tx:
-    device_free_tx_bufs(pDevice);
-
-	return FALSE;
-}
-
-
-
-
-static BOOL device_init_defrag_cb(PSDevice pDevice) {
-    int i;
-    PSDeFragControlBlock pDeF;
-
-    /* Init the fragment ctl entries */
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-        pDeF = &(pDevice->sRxDFCB[i]);
-        if (!device_alloc_frag_buf(pDevice, pDeF)) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
-                pDevice->dev->name);
-            goto free_frag;
-        }
-    }
-    pDevice->cbDFCB = CB_MAX_RX_FRAG;
-    pDevice->cbFreeDFCB = pDevice->cbDFCB;
-    return TRUE;
-
-free_frag:
-    device_free_frag_bufs(pDevice);
-    return FALSE;
-}
-
-
-
-static void device_free_frag_bufs(PSDevice pDevice) {
-    PSDeFragControlBlock pDeF;
-    int i;
-
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-
-        pDeF = &(pDevice->sRxDFCB[i]);
-
-        if (pDeF->skb)
-            dev_kfree_skb(pDeF->skb);
-    }
-}
-
-
-
-BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
-
-    pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-    if (pDeF->skb == NULL)
-        return FALSE;
-    ASSERT(pDeF->skb);
-    pDeF->skb->dev = pDevice->dev;
-
-    return TRUE;
-}
-
-
-/*-----------------------------------------------------------------*/
-
-static int  device_open(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
-
-     extern SWPAResult wpa_Result;
-     memset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));
-     wpa_Result.proto = 0;
-     wpa_Result.key_mgmt = 0;
-     wpa_Result.eap_type = 0;
-     wpa_Result.authenticated = FALSE;
-     pDevice->fWPA_Authened = FALSE;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_open...\n");
-
-
-    pDevice->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
-
-    if (device_alloc_bufs(pDevice) == FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_alloc_bufs fail... \n");
-        return -ENOMEM;
-    }
-
-    if (device_init_defrag_cb(pDevice)== FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Initial defragement cb fail \n");
-        goto free_rx_tx;
-    }
-
-    MP_CLEAR_FLAG(pDevice, fMP_DISCONNECTED);
-    MP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);
-    MP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);
-    MP_SET_FLAG(pDevice, fMP_POST_READS);
-    MP_SET_FLAG(pDevice, fMP_POST_WRITES);
-
-   //read config file
-    Read_config_file(pDevice);
-
-    if (device_init_registers(pDevice, DEVICE_INIT_COLD) == FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " init register fail\n");
-        goto free_all;
-    }
-
-    device_set_multi(pDevice->dev);
-    // Init for Key Management
-
-    KeyvInitTable(pDevice,&pDevice->sKey);
-    memcpy(pDevice->sMgmtObj.abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
-    memcpy(pDevice->dev->dev_addr, pDevice->abyCurrentNetAddr, ETH_ALEN);
-    pDevice->bStopTx0Pkt = FALSE;
-    pDevice->bStopDataPkt = FALSE;
-    pDevice->bRoaming = FALSE;
-    pDevice->bIsRoaming = FALSE;
-    pDevice->bEnableRoaming = FALSE;
-    if (pDevice->bDiversityRegCtlON) {
-        device_init_diversity_timer(pDevice);
-    }
-
-    vMgrObjectInit(pDevice);
-    tasklet_init(&pDevice->RxMngWorkItem, (void *)RXvMngWorkItem, (unsigned long)pDevice);
-    tasklet_init(&pDevice->ReadWorkItem, (void *)RXvWorkItem, (unsigned long)pDevice);
-    tasklet_init(&pDevice->EventWorkItem, (void *)INTvWorkItem, (unsigned long)pDevice);
-    add_timer(&(pDevice->sMgmtObj.sTimerSecondCallback));
-    pDevice->int_interval = 100;  //Max 100 microframes.
-    pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
-
-    pDevice->bIsRxWorkItemQueued = TRUE;
-    pDevice->fKillEventPollingThread = FALSE;
-    pDevice->bEventAvailable = FALSE;
-
-   pDevice->bWPADEVUp = FALSE;
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-     pDevice->bwextstep0 = FALSE;
-     pDevice->bwextstep1 = FALSE;
-     pDevice->bwextstep2 = FALSE;
-     pDevice->bwextstep3 = FALSE;
-     pDevice->bWPASuppWextEnabled = FALSE;
-#endif
-    pDevice->byReAssocCount = 0;
-
-    RXvWorkItem(pDevice);
-    INTvWorkItem(pDevice);
-
-    // Patch: if WEP key already set by iwconfig but device not yet open
-    if ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {
-         spin_lock_irq(&pDevice->lock);
-         KeybSetDefaultKey( pDevice,
-                            &(pDevice->sKey),
-                            pDevice->byKeyIndex | (1 << 31),
-                            pDevice->uKeyLength,
-                            NULL,
-                            pDevice->abyKey,
-                            KEY_CTL_WEP
-                          );
-         spin_unlock_irq(&pDevice->lock);
-         pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
-    }
-
-    if (pDevice->sMgmtObj.eConfigMode == WMAC_CONFIG_AP) {
-		bScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);
-	}
-	else {
-	//mike:mark@2008-11-10
-	  bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-	  /* bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL); */
-    }
-
-
-    netif_stop_queue(pDevice->dev);
-    pDevice->flags |= DEVICE_FLAGS_OPENED;
-
-{
-  union iwreq_data      wrqu;
-  memset(&wrqu, 0, sizeof(wrqu));
-  wrqu.data.flags = RT_UPDEV_EVENT_FLAG;
-  wireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);
-}
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
-    return 0;
-
-free_all:
-    device_free_frag_bufs(pDevice);
-free_rx_tx:
-    device_free_rx_bufs(pDevice);
-    device_free_tx_bufs(pDevice);
-    device_free_int_bufs(pDevice);
-	usb_kill_urb(pDevice->pControlURB);
-	usb_kill_urb(pDevice->pInterruptURB);
-    usb_free_urb(pDevice->pControlURB);
-    usb_free_urb(pDevice->pInterruptURB);
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open fail.. \n");
-    return -ENOMEM;
-}
-
-
-
-static int  device_close(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
-    PSMgmtObject     pMgmt = &(pDevice->sMgmtObj);
-
-        int uu;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close1 \n");
-    if (pDevice == NULL)
-        return -ENODEV;
-
-{
-  union iwreq_data      wrqu;
-  memset(&wrqu, 0, sizeof(wrqu));
-  wrqu.data.flags = RT_DOWNDEV_EVENT_FLAG;
-  wireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);
-}
-
-    if (pDevice->bLinkPass) {
-	bScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-        mdelay(30);
-    }
-
-device_release_WPADEV(pDevice);
-
-        memset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-        pMgmt->bShareKeyAlgorithm = FALSE;
-        pDevice->bEncryptionEnable = FALSE;
-        pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
-	spin_lock_irq(&pDevice->lock);
-	for (uu = 0; uu < MAX_KEY_TABLE; uu++)
-                MACvDisableKeyEntry(pDevice,uu);
-	spin_unlock_irq(&pDevice->lock);
-
-    if ((pDevice->flags & DEVICE_FLAGS_UNPLUG) == FALSE) {
-        MACbShutdown(pDevice);
-    }
-    netif_stop_queue(pDevice->dev);
-    MP_SET_FLAG(pDevice, fMP_DISCONNECTED);
-    MP_CLEAR_FLAG(pDevice, fMP_POST_WRITES);
-    MP_CLEAR_FLAG(pDevice, fMP_POST_READS);
-    pDevice->fKillEventPollingThread = TRUE;
-    del_timer(&pDevice->sTimerCommand);
-    del_timer(&pMgmt->sTimerSecondCallback);
-
-    del_timer(&pDevice->sTimerTxData);
-
-    if (pDevice->bDiversityRegCtlON) {
-        del_timer(&pDevice->TimerSQ3Tmax1);
-        del_timer(&pDevice->TimerSQ3Tmax2);
-        del_timer(&pDevice->TimerSQ3Tmax3);
-    }
-    tasklet_kill(&pDevice->RxMngWorkItem);
-    tasklet_kill(&pDevice->ReadWorkItem);
-    tasklet_kill(&pDevice->EventWorkItem);
-
-   pDevice->bRoaming = FALSE;
-   pDevice->bIsRoaming = FALSE;
-   pDevice->bEnableRoaming = FALSE;
-    pDevice->bCmdRunning = FALSE;
-    pDevice->bLinkPass = FALSE;
-    memset(pMgmt->abyCurrBSSID, 0, 6);
-    pMgmt->eCurrState = WMAC_STATE_IDLE;
-
-    device_free_tx_bufs(pDevice);
-    device_free_rx_bufs(pDevice);
-    device_free_int_bufs(pDevice);
-    device_free_frag_bufs(pDevice);
-
-	usb_kill_urb(pDevice->pControlURB);
-	usb_kill_urb(pDevice->pInterruptURB);
-    usb_free_urb(pDevice->pControlURB);
-    usb_free_urb(pDevice->pInterruptURB);
-
-    BSSvClearNodeDBTable(pDevice, 0);
-    pDevice->flags &=(~DEVICE_FLAGS_OPENED);
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close2 \n");
-
-    return 0;
-}
-
-static void __devexit vt6656_disconnect(struct usb_interface *intf)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device)
-		return;
-
-	{
-		union iwreq_data req;
-		memset(&req, 0, sizeof(req));
-		req.data.flags = RT_RMMOD_EVENT_FLAG;
-		wireless_send_event(device->dev, IWEVCUSTOM, &req, NULL);
-	}
-
-	device_release_WPADEV(device);
-
-	if (device->firmware)
-		release_firmware(device->firmware);
-
-	usb_set_intfdata(intf, NULL);
-	usb_put_dev(interface_to_usbdev(intf));
-
-	device->flags |= DEVICE_FLAGS_UNPLUG;
-
-	if (device->dev) {
-		unregister_netdev(device->dev);
-		wpa_set_wpadev(device, 0);
-		free_netdev(device->dev);
-	}
-}
-
-static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
-{
-	PSDevice pDevice = netdev_priv(dev);
-
-	spin_lock_irq(&pDevice->lock);
-
-	if (unlikely(pDevice->bStopTx0Pkt))
-		dev_kfree_skb_irq(skb);
-	else
-		vDMA0_tx_80211(pDevice, skb);
-
-	spin_unlock_irq(&pDevice->lock);
-
-	return NETDEV_TX_OK;
-}
-
-static int device_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	PSDevice pDevice = netdev_priv(dev);
-	struct net_device_stats *stats = &pDevice->stats;
-
-	spin_lock_irq(&pDevice->lock);
-
-	netif_stop_queue(dev);
-
-	if (!pDevice->bLinkPass) {
-		dev_kfree_skb_irq(skb);
-		goto out;
-	}
-
-	if (pDevice->bStopDataPkt) {
-		dev_kfree_skb_irq(skb);
-		stats->tx_dropped++;
-		goto out;
-	}
-
-	if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb)) {
-		if (netif_queue_stopped(dev))
-			netif_wake_queue(dev);
-	}
-
-out:
-	spin_unlock_irq(&pDevice->lock);
-
-	return NETDEV_TX_OK;
-}
-
-static unsigned const ethernet_polynomial = 0x04c11db7U;
-static inline u32 ether_crc(int length, unsigned char *data)
-{
-    int crc = -1;
-
-    while(--length >= 0) {
-        unsigned char current_octet = *data++;
-        int bit;
-        for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
-            crc = (crc << 1) ^
-                ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
-        }
-    }
-    return crc;
-}
-
-//find out  the start  position of str2 from str1
-static unsigned char *kstrstr(const unsigned char *str1,
-			      const unsigned char *str2) {
-  int str1_len = strlen(str1);
-  int str2_len = strlen(str2);
-
-  while (str1_len >= str2_len) {
-       str1_len--;
-      if(memcmp(str1,str2,str2_len)==0)
-	return (unsigned char *) str1;
-        str1++;
-  }
-  return NULL;
-}
-
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest,
-				   unsigned char *source)
-{
-  unsigned char buf1[100];
-  unsigned char buf2[100];
-  unsigned char *start_p = NULL, *end_p = NULL, *tmp_p = NULL;
-  int ii;
-
-    memset(buf1,0,100);
-    strcat(buf1, string);
-    strcat(buf1, "=");
-    source+=strlen(buf1);
-
-//find target string start point
-    start_p = kstrstr(source,buf1);
-    if (start_p == NULL)
-	return FALSE;
-
-//check if current config line is marked by "#" ??
-    for (ii = 1; ; ii++) {
-	if (memcmp(start_p - ii, "\n", 1) == 0)
-		break;
-	if (memcmp(start_p - ii, "#", 1) == 0)
-		return FALSE;
-    }
-
-//find target string end point
-     end_p = kstrstr(start_p,"\n");
-     if (end_p == NULL) {       //can't find "\n",but don't care
-          end_p=start_p+strlen(start_p);   //no include "\n"
-       }
-
-   memset(buf2,0,100);
-   memcpy(buf2,start_p,end_p-start_p);    //get the tartget line
-   buf2[end_p-start_p]='\0';
-
-   //find value
-   start_p = kstrstr(buf2,"=");
-   if (start_p == NULL)
-      return FALSE;
-   memset(buf1,0,100);
-   strcpy(buf1,start_p+1);
-
-  //except space
-  tmp_p = buf1;
-  while(*tmp_p != 0x00) {
-  	if(*tmp_p==' ')
-	    tmp_p++;
-         else
-	  break;
-  }
-
-   memcpy(dest,tmp_p,strlen(tmp_p));
- return TRUE;
-}
-
-//if read fail,return NULL,or return data pointer;
-static unsigned char *Config_FileOperation(PSDevice pDevice)
-{
-    unsigned char *config_path = CONFIG_PATH;
-    unsigned char *buffer = NULL;
-    struct file   *filp=NULL;
-    mm_segment_t old_fs = get_fs();
-    //int oldfsuid=0,oldfsgid=0;
-    int result = 0;
-
-    set_fs (KERNEL_DS);
-    /* Can't do this anymore, so we rely on correct filesystem permissions:
-    //Make sure a caller can read or write power as root
-    oldfsuid=current->fsuid;
-    oldfsgid=current->fsgid;
-    current->fsuid = 0;
-    current->fsgid = 0;
-    */
-
-    //open file
-      filp = filp_open(config_path, O_RDWR, 0);
-        if (IS_ERR(filp)) {
-	     printk("Config_FileOperation file Not exist\n");
-	     result=-1;
-             goto error2;
-	  }
-
-     if(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {
-           printk("file %s cann't readable or writable?\n",config_path);
-	  result = -1;
-	  goto error1;
-     	}
-
-    buffer = kmalloc(1024, GFP_KERNEL);
-    if(buffer==NULL) {
-      printk("allocate mem for file fail?\n");
-      result = -1;
-      goto error1;
-    }
-
-    if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
-     printk("read file error?\n");
-     result = -1;
-    }
-
-error1:
-  if(filp_close(filp,NULL))
-       printk("Config_FileOperation:close file fail\n");
-
-error2:
-  set_fs (old_fs);
-
-  /*
-  current->fsuid=oldfsuid;
-  current->fsgid=oldfsgid;
-  */
-
-if(result!=0) {
-    kfree(buffer);
-    buffer=NULL;
-}
-  return buffer;
-}
-
-//return --->-1:fail;  >=0:successful
-static int Read_config_file(PSDevice pDevice) {
-  int result = 0;
-  unsigned char tmpbuffer[100];
-  unsigned char *buffer = NULL;
-
-  //init config setting
- pDevice->config_file.ZoneType = -1;
- pDevice->config_file.eAuthenMode = -1;
- pDevice->config_file.eEncryptionStatus = -1;
-
-  buffer = Config_FileOperation(pDevice);
-  if (buffer == NULL) {
-     result =-1;
-     return result;
-  }
-
-//get zonetype
-{
-    memset(tmpbuffer,0,sizeof(tmpbuffer));
-    if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer) ==TRUE) {
-    if(memcmp(tmpbuffer,"USA",3)==0) {
-      pDevice->config_file.ZoneType=ZoneType_USA;
-    }
-    else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
-      pDevice->config_file.ZoneType=ZoneType_Japan;
-    }
-    else if(memcmp(tmpbuffer,"EUROPE",6)==0) {
-     pDevice->config_file.ZoneType=ZoneType_Europe;
-    }
-    else {
-      printk("Unknown Zonetype[%s]?\n",tmpbuffer);
-   }
- }
-}
-
-//get other parameter
-  {
-	memset(tmpbuffer,0,sizeof(tmpbuffer));
-       if(Config_FileGetParameter("AUTHENMODE",tmpbuffer,buffer)==TRUE) {
-	 pDevice->config_file.eAuthenMode = (int) simple_strtol(tmpbuffer, NULL, 10);
-       }
-
-	memset(tmpbuffer,0,sizeof(tmpbuffer));
-       if(Config_FileGetParameter("ENCRYPTIONMODE",tmpbuffer,buffer)==TRUE) {
-	 pDevice->config_file.eEncryptionStatus= (int) simple_strtol(tmpbuffer, NULL, 10);
-       }
-  }
-
-  kfree(buffer);
-  return result;
-}
-
-static void device_set_multi(struct net_device *dev) {
-    PSDevice         pDevice = (PSDevice) netdev_priv(dev);
-    PSMgmtObject     pMgmt = &(pDevice->sMgmtObj);
-    u32              mc_filter[2];
-    int              ii;
-    struct netdev_hw_addr *ha;
-    BYTE             pbyData[8] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
-    BYTE             byTmpMode = 0;
-    int              rc;
-
-
-	spin_lock_irq(&pDevice->lock);
-    rc = CONTROLnsRequestIn(pDevice,
-                            MESSAGE_TYPE_READ,
-                            MAC_REG_RCR,
-                            MESSAGE_REQUEST_MACREG,
-                            1,
-                            &byTmpMode
-                            );
-    if (rc == 0) pDevice->byRxMode = byTmpMode;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode in= %x\n", pDevice->byRxMode);
-
-    if (dev->flags & IFF_PROMISC) {         // Set promiscuous.
-        DBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
-        // Unconditionally log net taps.
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
-    }
-    else if ((netdev_mc_count(dev) > pDevice->multicast_limit) ||
-	     (dev->flags & IFF_ALLMULTI)) {
-        CONTROLnsRequestOut(pDevice,
-                            MESSAGE_TYPE_WRITE,
-                            MAC_REG_MAR0,
-                            MESSAGE_REQUEST_MACREG,
-                            8,
-                            pbyData
-                            );
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-    else {
-        memset(mc_filter, 0, sizeof(mc_filter));
-	netdev_for_each_mc_addr(ha, dev) {
-            int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
-            mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
-        }
-        for (ii = 0; ii < 4; ii++) {
-             MACvWriteMultiAddr(pDevice, ii, *((PBYTE)&mc_filter[0] + ii));
-             MACvWriteMultiAddr(pDevice, ii+ 4, *((PBYTE)&mc_filter[1] + ii));
-        }
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-
-    if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-        // If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-    }
-    ControlvWriteByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, pDevice->byRxMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode out= %x\n", pDevice->byRxMode);
-	spin_unlock_irq(&pDevice->lock);
-
-}
-
-
-static struct net_device_stats *device_get_stats(struct net_device *dev) {
-    PSDevice pDevice=(PSDevice) netdev_priv(dev);
-
-    return &pDevice->stats;
-}
-
-
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
-	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
-    PSMgmtObject        pMgmt = &(pDevice->sMgmtObj);
-    PSCmdRequest        pReq;
-    //BOOL                bCommit = FALSE;
-	struct iwreq *wrq = (struct iwreq *) rq;
-	int                 rc =0;
-
-    if (pMgmt == NULL) {
-        rc = -EFAULT;
-        return rc;
-    }
-
-    switch(cmd) {
-
-	case SIOCGIWNAME:
-		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
-		break;
-
-	case SIOCSIWNWID:
-	case SIOCGIWNWID:     //0x8b03  support
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Set frequency/channel
-	case SIOCSIWFREQ:
-	    rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Get frequency/channel
-	case SIOCGIWFREQ:
-		rc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Set desired network name (ESSID)
-	case SIOCSIWESSID:
-
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
-				rc = -E2BIG;
-				break;
-			}
-			if (copy_from_user(essid, wrq->u.essid.pointer,
-					   wrq->u.essid.length)) {
-				rc = -EFAULT;
-				break;
-			}
-			rc = iwctl_siwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
-		}
-		break;
-
-
-		// Get current network name (ESSID)
-	case SIOCGIWESSID:
-
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.pointer) {
-				iwctl_giwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
-				if (copy_to_user(wrq->u.essid.pointer,
-						         essid,
-						         wrq->u.essid.length) )
-					rc = -EFAULT;
-			}
-		}
-		break;
-
-	case SIOCSIWAP:
-
-		rc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-
-		// Get current Access Point (BSSID)
-	case SIOCGIWAP:
-		rc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-
-		// Set desired station name
-	case SIOCSIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-		// Get current station name
-	case SIOCGIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-		// Set the desired bit-rate
-	case SIOCSIWRATE:
-		rc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-	// Get the current bit-rate
-	case SIOCGIWRATE:
-		iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-	// Set the desired RTS threshold
-	case SIOCSIWRTS:
-
-		rc = iwctl_siwrts(dev, &(wrq->u.rts));
-		break;
-
-	// Get the current RTS threshold
-	case SIOCGIWRTS:
-
-		rc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);
-		break;
-
-		// Set the desired fragmentation threshold
-	case SIOCSIWFRAG:
-
-		rc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);
-	    break;
-
-	// Get the current fragmentation threshold
-	case SIOCGIWFRAG:
-
-		rc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);
-		break;
-
-		// Set mode of operation
-	case SIOCSIWMODE:
-    	rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Get mode of operation
-	case SIOCGIWMODE:
-		iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Set WEP keys and mode
-	case SIOCSIWENCODE:
-		{
-            char abyKey[WLAN_WEP232_KEYLEN];
-
-			if (wrq->u.encoding.pointer) {
-
-
-				if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
-					rc = -E2BIG;
-					break;
-				}
-				memset(abyKey, 0, WLAN_WEP232_KEYLEN);
-				if (copy_from_user(abyKey,
-				                  wrq->u.encoding.pointer,
-				                  wrq->u.encoding.length)) {
-					rc = -EFAULT;
-					break;
-				}
-			} else if (wrq->u.encoding.length != 0) {
-				rc = -EINVAL;
-				break;
-			}
-			rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-		}
-		break;
-
-		// Get the WEP keys and mode
-	case SIOCGIWENCODE:
-
-		if (!capable(CAP_NET_ADMIN)) {
-			rc = -EPERM;
-			break;
-		}
-		{
-		    char abyKey[WLAN_WEP232_KEYLEN];
-
-		    rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-		    if (rc != 0) break;
-			if (wrq->u.encoding.pointer) {
-				if (copy_to_user(wrq->u.encoding.pointer,
-						        abyKey,
-						        wrq->u.encoding.length))
-					rc = -EFAULT;
-			}
-		}
-		break;
-
-		// Get the current Tx-Power
-	case SIOCGIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWRETRY:
-
-		rc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-	case SIOCGIWRETRY:
-
-		rc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-		// Get range of parameters
-	case SIOCGIWRANGE:
-
-		{
-			struct iw_range range;
-
-			iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);
-			if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
-				rc = -EFAULT;
-		}
-
-		break;
-
-	case SIOCGIWPOWER:
-
-		rc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-
-	case SIOCSIWPOWER:
-
-		rc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-
-	case SIOCGIWSENS:
-
-	    rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
-		break;
-
-	case SIOCSIWSENS:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCGIWAPLIST:
-	    {
-            char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
-
-		    if (wrq->u.data.pointer) {
-		        rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
-		        if (rc == 0) {
-                    if (copy_to_user(wrq->u.data.pointer,
-					                buffer,
-					               (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
-				        ))
-				    rc = -EFAULT;
-		        }
-            }
-        }
-		break;
-
-
-#ifdef WIRELESS_SPY
-		// Set the spy list
-	case SIOCSIWSPY:
-
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Get the spy list
-	case SIOCGIWSPY:
-
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-#endif // WIRELESS_SPY
-
-	case SIOCGIWPRIV:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
-		rc = -EOPNOTSUPP;
-/*
-		if(wrq->u.data.pointer) {
-			wrq->u.data.length = sizeof(iwctl_private_args) / sizeof( iwctl_private_args[0]);
-
-			if(copy_to_user(wrq->u.data.pointer,
-					(u_char *) iwctl_private_args,
-					sizeof(iwctl_private_args)))
-				rc = -EFAULT;
-		}
-*/
-		break;
-
-#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	case SIOCSIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH\n");
-		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCGIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
-		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCSIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
-		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCGIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
-		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCSIWENCODEEXT:
-		{
-			char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
-			if(wrq->u.encoding.pointer){
-				memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);
-				if(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){
-					rc = -E2BIG;
-					break;
-				}
-				if(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){
-					rc = -EFAULT;
-					break;
-				}
-			}else if(wrq->u.encoding.length != 0){
-				rc = -EINVAL;
-				break;
-			}
-			rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
-		}
-		break;
-
-	case SIOCGIWENCODEEXT:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
-		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
-		break;
-
-	case SIOCSIWMLME:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
-		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-#endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-
-    case IOCTL_CMD_TEST:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-        pReq = (PSCmdRequest)rq;
-
-   //20080130-01,<Remark> by Mike Liu
-      // if(pDevice->bLinkPass==TRUE)
-          pReq->wResult = MAGIC_CODE;         //Linking status:0x3142
-   //20080130-02,<Remark> by Mike Liu
-      //  else
-      //	 pReq->wResult = MAGIC_CODE+1;    //disconnect status:0x3143
-        break;
-
-    case IOCTL_CMD_SET:
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
-		       (((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))
-		{
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-	    if (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {
-		    return -EBUSY;
-	    }
-        rc = private_ioctl(pDevice, rq);
-        clear_bit( 0, (void*)&(pMgmt->uCmdBusy));
-        break;
-
-    case IOCTL_CMD_HOSTAPD:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-		rc = vt6656_hostap_ioctl(pDevice, &wrq->u.data);
-        break;
-
-    case IOCTL_CMD_WPA:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-		rc = wpa_ioctl(pDevice, &wrq->u.data);
-        break;
-
-	case SIOCETHTOOL:
-        return ethtool_ioctl(dev, (void *) rq->ifr_data);
-	// All other calls are currently unsupported
-
-	default:
-		rc = -EOPNOTSUPP;
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
-
-
-    }
-
-    if (pDevice->bCommit) {
-       if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-           netif_stop_queue(pDevice->dev);
-           spin_lock_irq(&pDevice->lock);
-	bScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);
-           spin_unlock_irq(&pDevice->lock);
-       }
-       else {
-           DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
-           spin_lock_irq(&pDevice->lock);
-//2007-1121-01<Modify>by EinsnLiu
-	    if (pDevice->bLinkPass &&
-		  memcmp(pMgmt->abyCurrSSID,pMgmt->abyDesireSSID,WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN)) {
-		bScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-	     } else {
-           pDevice->bLinkPass = FALSE;
-	   pMgmt->eCurrState = WMAC_STATE_IDLE;
-	   memset(pMgmt->abyCurrBSSID, 0, 6);
-		 }
-           ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
-//End Modify
-           netif_stop_queue(pDevice->dev);
-#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-           pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-	   if (!pDevice->bWPASuppWextEnabled)
-#endif
-		bScheduleCommand((void *) pDevice,
-				 WLAN_CMD_BSSID_SCAN,
-				 pMgmt->abyDesireSSID);
-		bScheduleCommand((void *) pDevice,
-				 WLAN_CMD_SSID,
-				 NULL);
-           spin_unlock_irq(&pDevice->lock);
-      }
-      pDevice->bCommit = FALSE;
-    }
-
-
-    return rc;
-}
-
-
-static int ethtool_ioctl(struct net_device *dev, void *useraddr)
-{
-	u32 ethcmd;
-
-	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
-		return -EFAULT;
-
-        switch (ethcmd) {
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
-		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
-		strncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);
-		if (copy_to_user(useraddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-
-        }
-
-	return -EOPNOTSUPP;
-}
-
-
-/*------------------------------------------------------------------*/
-
-MODULE_DEVICE_TABLE(usb, vt6656_table);
-
-static struct usb_driver vt6656_driver = {
-	.name =		DEVICE_NAME,
-	.probe =	vt6656_probe,
-	.disconnect =	vt6656_disconnect,
-	.id_table =	vt6656_table,
-#ifdef CONFIG_PM
-	.suspend = vt6656_suspend,
-	.resume = vt6656_resume,
-#endif /* CONFIG_PM */
-};
-
-module_usb_driver(vt6656_driver);
diff -urN flo-ElementalX-5.00/drivers/staging/xgifb/XGI_main.h flo-ElementalX-5.00-patched/drivers/staging/xgifb/XGI_main.h
--- flo-ElementalX-5.00/drivers/staging/xgifb/XGI_main.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/xgifb/XGI_main.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,504 +0,0 @@
-#ifndef _XGIFB_MAIN
-#define _XGIFB_MAIN
-
-
-/* ------------------- Constant Definitions ------------------------- */
-
-
-#include "XGIfb.h"
-#include "vb_struct.h"
-#include "../../video/sis/sis.h"
-#include "vb_def.h"
-
-#define XGIFAIL(x) do { printk(x "\n"); return -EINVAL; } while (0)
-
-#ifndef PCI_DEVICE_ID_XGI_41
-#define PCI_DEVICE_ID_XGI_41      0x041
-#endif
-#ifndef PCI_DEVICE_ID_XGI_42
-#define PCI_DEVICE_ID_XGI_42      0x042
-#endif
-#ifndef PCI_DEVICE_ID_XGI_27
-#define PCI_DEVICE_ID_XGI_27      0x027
-#endif
-
-static DEFINE_PCI_DEVICE_TABLE(xgifb_pci_table) = {
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_20)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_27)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_40)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_42)},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, xgifb_pci_table);
-
-/* To be included in fb.h */
-#define XGISR			  (xgifb_info->dev_info.P3c4)
-#define XGICR			  (xgifb_info->dev_info.P3d4)
-#define XGIDACA			  (xgifb_info->dev_info.P3c8)
-#define XGIDACD			  (xgifb_info->dev_info.P3c9)
-#define XGIPART1		  (xgifb_info->dev_info.Part1Port)
-#define XGIPART2		  (xgifb_info->dev_info.Part2Port)
-#define XGIPART3		  (xgifb_info->dev_info.Part3Port)
-#define XGIPART4		  (xgifb_info->dev_info.Part4Port)
-#define XGIPART5		  (xgifb_info->dev_info.Part5Port)
-#define XGIDAC2A                  XGIPART5
-#define XGIDAC2D                  (XGIPART5 + 1)
-
-#define IND_XGI_SCRATCH_REG_CR30  0x30  /* CRs */
-#define IND_XGI_SCRATCH_REG_CR31  0x31
-#define IND_XGI_SCRATCH_REG_CR32  0x32
-#define IND_XGI_SCRATCH_REG_CR33  0x33
-#define IND_XGI_LCD_PANEL         0x36
-#define IND_XGI_SCRATCH_REG_CR37  0x37
-
-#define XGI_DRAM_SIZE_MASK     0xF0  /*SR14 */
-#define XGI_DRAM_SIZE_1MB      0x00
-#define XGI_DRAM_SIZE_2MB      0x01
-#define XGI_DRAM_SIZE_4MB      0x02
-#define XGI_DRAM_SIZE_8MB      0x03
-#define XGI_DRAM_SIZE_16MB     0x04
-#define XGI_DRAM_SIZE_32MB     0x05
-#define XGI_DRAM_SIZE_64MB     0x06
-#define XGI_DRAM_SIZE_128MB    0x07
-#define XGI_DRAM_SIZE_256MB    0x08
-
-/* ------------------- Global Variables ----------------------------- */
-
-/* display status */
-static int XGIfb_crt1off;
-static int XGIfb_forcecrt1 = -1;
-
-/* global flags */
-static int XGIfb_tvmode;
-static int enable_dstn;
-static int XGIfb_ypan = -1;
-
-/* TW: CRT2 type (for overriding autodetection) */
-static int XGIfb_crt2type = -1;
-/* PR: Tv plug type (for overriding autodetection) */
-static int XGIfb_tvplug = -1;
-
-/* TW: For ioctl XGIFB_GET_INFO */
-/* XGIfb_info XGIfbinfo; */
-
-#define MD_XGI300 1
-#define MD_XGI315 2
-
-/* mode table */
-static const struct _XGIbios_mode {
-	char name[15];
-	u8 mode_no;
-	u16 vesa_mode_no_1;  /* "XGI defined" VESA mode number */
-	u16 vesa_mode_no_2;  /* Real VESA mode numbers */
-	u16 xres;
-	u16 yres;
-	u16 bpp;
-	u16 rate_idx;
-	u16 cols;
-	u16 rows;
-	u8  chipset;
-} XGIbios_mode[] = {
-	{"320x240x16",   0x56, 0x0000, 0x0000,  320,  240, 16, 1,  40, 15,
-	 MD_XGI315},
-	{"320x480x8",    0x5A, 0x0000, 0x0000,  320,  480,  8, 1,  40, 30,
-	 MD_XGI315},  /* TW: FSTN */
-	{"320x480x16",   0x5B, 0x0000, 0x0000,  320,  480, 16, 1,  40, 30,
-	 MD_XGI315},  /* TW: FSTN */
-	{"640x480x8",    0x2E, 0x0101, 0x0101,  640,  480,  8, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"640x480x16",   0x44, 0x0111, 0x0111,  640,  480, 16, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"640x480x24",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},  /* TW: That's for people who mix up color-
-					and fb depth */
-	{"640x480x32",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x8",    0x31, 0x0000, 0x0000,  720,  480,  8, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x16",   0x33, 0x0000, 0x0000,  720,  480, 16, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x24",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x32",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x8",    0x32, 0x0000, 0x0000,  720,  576,  8, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x16",   0x34, 0x0000, 0x0000,  720,  576, 16, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x24",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x32",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x8",    0x70, 0x0000, 0x0000,  800,  480,  8, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x16",   0x7a, 0x0000, 0x0000,  800,  480, 16, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x24",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x32",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x8",    0x30, 0x0103, 0x0103,  800,  600,  8, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-#define DEFAULT_MODE              20 /* index for 800x600x16 */
-	{"800x600x16",   0x47, 0x0114, 0x0114,  800,  600, 16, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x24",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x32",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x8",   0x71, 0x0000, 0x0000, 1024,  576,  8, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x16",  0x74, 0x0000, 0x0000, 1024,  576, 16, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x24",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x32",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x600x8",   0x20, 0x0000, 0x0000, 1024,  600,  8, 1, 128, 37,
-	 MD_XGI300          },  /* TW: 300 series only */
-	{"1024x600x16",  0x21, 0x0000, 0x0000, 1024,  600, 16, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x600x24",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x600x32",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x768x8",   0x38, 0x0105, 0x0105, 1024,  768,  8, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x16",  0x4A, 0x0117, 0x0117, 1024,  768, 16, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x24",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x32",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1152x768x8",   0x23, 0x0000, 0x0000, 1152,  768,  8, 1, 144, 48,
-	 MD_XGI300          },  /* TW: 300 series only */
-	{"1152x768x16",  0x24, 0x0000, 0x0000, 1152,  768, 16, 1, 144, 48,
-	 MD_XGI300          },
-	{"1152x768x24",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48,
-	 MD_XGI300          },
-	{"1152x768x32",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48,
-	 MD_XGI300          },
-	{"1280x720x8",   0x79, 0x0000, 0x0000, 1280,  720,  8, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x16",  0x75, 0x0000, 0x0000, 1280,  720, 16, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x24",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x32",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x768x8",   0x23, 0x0000, 0x0000, 1280,  768,  8, 1, 160, 48,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"1280x768x16",  0x24, 0x0000, 0x0000, 1280,  768, 16, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x768x24",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x768x32",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x960x8",   0x7C, 0x0000, 0x0000, 1280,  960,  8, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x16",  0x7D, 0x0000, 0x0000, 1280,  960, 16, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x24",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x32",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x8",  0x3A, 0x0107, 0x0107, 1280, 1024,  8, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x16", 0x4D, 0x011a, 0x011a, 1280, 1024, 16, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x24", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x32", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1400x1050x8",  0x26, 0x0000, 0x0000, 1400, 1050,  8, 1, 175, 65,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"1400x1050x16", 0x27, 0x0000, 0x0000, 1400, 1050, 16, 1, 175, 65,
-	 MD_XGI315},
-	{"1400x1050x24", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,
-	 MD_XGI315},
-	{"1400x1050x32", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,
-	 MD_XGI315},
-	{"1600x1200x8",  0x3C, 0x0130, 0x011c, 1600, 1200,  8, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x16", 0x3D, 0x0131, 0x011e, 1600, 1200, 16, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x24", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x32", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x8",  0x68, 0x013f, 0x0000, 1920, 1440,  8, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x16", 0x69, 0x0140, 0x0000, 1920, 1440, 16, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x24", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x32", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"2048x1536x8",  0x6c, 0x0000, 0x0000, 2048, 1536,  8, 1, 256, 96,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"2048x1536x16", 0x6d, 0x0000, 0x0000, 2048, 1536, 16, 1, 256, 96,
-	 MD_XGI315},
-	{"2048x1536x24", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,
-	 MD_XGI315},
-	{"2048x1536x32", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,
-	 MD_XGI315},
-	{"\0", 0x00, 0, 0, 0, 0, 0, 0, 0}
-};
-
-/* TW: CR36 evaluation */
-static const unsigned short XGI300paneltype[] = {
-	 LCD_UNKNOWN,  LCD_800x600, LCD_1024x768, LCD_1280x1024,
-	LCD_1280x960,  LCD_640x480, LCD_1024x600, LCD_1152x768,
-	LCD_1024x768, LCD_1024x768, LCD_1024x768,
-	LCD_1024x768, LCD_1024x768, LCD_1024x768, LCD_1024x768};
-
-static const unsigned short XGI310paneltype[] = {
-	 LCD_UNKNOWN,   LCD_800x600, LCD_1024x768, LCD_1280x1024,
-	 LCD_640x480,  LCD_1024x600, LCD_1152x864, LCD_1280x960,
-	LCD_1152x768, LCD_1400x1050, LCD_1280x768, LCD_1600x1200,
-	LCD_1024x768,  LCD_1024x768, LCD_1024x768};
-
-static const struct _XGI_crt2type {
-	char name[10];
-	int type_no;
-	int tvplug_no;
-} XGI_crt2type[] = {
-	{"NONE",	0,		-1},
-	{"LCD",		XGIFB_DISP_LCD,	-1},
-	{"TV",		XGIFB_DISP_TV,	-1},
-	{"VGA",		XGIFB_DISP_CRT,	-1},
-	{"SVIDEO",	XGIFB_DISP_TV,	TVPLUG_SVIDEO},
-	{"COMPOSITE",	XGIFB_DISP_TV,	TVPLUG_COMPOSITE},
-	{"SCART",	XGIFB_DISP_TV,	TVPLUG_SCART},
-	{"none",	0,		-1},
-	{"lcd",		XGIFB_DISP_LCD,	-1},
-	{"tv",		XGIFB_DISP_TV,	-1},
-	{"vga",		XGIFB_DISP_CRT,	-1},
-	{"svideo",	XGIFB_DISP_TV,	TVPLUG_SVIDEO},
-	{"composite",	XGIFB_DISP_TV,	TVPLUG_COMPOSITE},
-	{"scart",	XGIFB_DISP_TV,	TVPLUG_SCART},
-	{"\0",		-1,		-1}
-};
-
-/* TV standard */
-static const struct _XGI_tvtype {
-	char name[6];
-	int type_no;
-} XGI_tvtype[] = {
-	{"PAL",		1},
-	{"NTSC",	2},
-	{"pal",		1},
-	{"ntsc",	2},
-	{"\0",		-1}
-};
-
-static const struct _XGI_vrate {
-	u16 idx;
-	u16 xres;
-	u16 yres;
-	u16 refresh;
-} XGIfb_vrate[] = {
-	{1,  640,  480, 60}, {2,  640,  480,  72},
-	{3, 640,   480,  75}, {4,  640, 480,  85},
-
-	{5,  640,  480, 100}, {6,  640,  480, 120},
-	{7, 640,   480, 160}, {8,  640, 480, 200},
-
-	{1,  720,  480, 60},
-	{1,  720,  576, 58},
-	{1,  800,  480, 60}, {2,  800,  480,  75}, {3, 800,   480,  85},
-	{1,  800,  600,  60}, {2, 800,   600,  72}, {3,  800, 600,  75},
-	{4,  800,  600, 85}, {5,  800,  600, 100},
-	{6, 800,   600, 120}, {7,  800, 600, 160},
-
-	{1, 1024,  768,  60}, {2, 1024,  768,  70}, {3, 1024, 768,  75},
-	{4, 1024,  768, 85}, {5, 1024,  768, 100}, {6, 1024,  768, 120},
-	{1, 1024,  576, 60}, {2, 1024,  576,  75}, {3, 1024,  576,  85},
-	{1, 1024,  600, 60},
-	{1, 1152,  768, 60},
-	{1, 1280,  720, 60}, {2, 1280,  720,  75}, {3, 1280,  720,  85},
-	{1, 1280,  768, 60},
-	{1, 1280, 1024,  60}, {2, 1280, 1024,  75}, {3, 1280, 1024,  85},
-	{1, 1280,  960, 70},
-	{1, 1400, 1050, 60},
-	{1, 1600, 1200, 60}, {2, 1600, 1200,  65},
-	{3, 1600, 1200,  70}, {4, 1600, 1200,  75},
-
-	{5, 1600, 1200, 85}, {6, 1600, 1200, 100},
-	{7, 1600, 1200, 120},
-
-	{1, 1920, 1440, 60}, {2, 1920, 1440,  65},
-	{3, 1920, 1440,  70}, {4, 1920, 1440,  75},
-
-	{5, 1920, 1440, 85}, {6, 1920, 1440, 100},
-	{1, 2048, 1536, 60}, {2, 2048, 1536,  65},
-	{3, 2048, 1536,  70}, {4, 2048, 1536,  75},
-
-	{5, 2048, 1536, 85},
-	{0, 0, 0, 0}
-};
-
-static const struct _chswtable {
-	int subsysVendor;
-	int subsysCard;
-	char *vendorName;
-	char *cardName;
-} mychswtable[] = {
-	{ 0x1631, 0x1002, "Mitachi", "0x1002" },
-	{ 0,      0,      ""       , ""       }
-};
-
-/* Eden Chen */
-static const struct _XGI_TV_filter {
-	u8 filter[9][4];
-} XGI_TV_filter[] = {
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_0 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_1 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_2 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xF6, 0x06, 0x1A, 0x14},
-	    {0xFA, 0x06, 0x16, 0x14},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_3 */
-	    {0xF1, 0x04, 0x1F, 0x18},
-	    {0xEE, 0x0D, 0x22, 0x06},
-	    {0xF7, 0x06, 0x19, 0x14},
-	    {0xF4, 0x0B, 0x1C, 0x0A},
-	    {0xFA, 0x07, 0x16, 0x12},
-	    {0xF9, 0x0A, 0x17, 0x0C},
-	    {0x00, 0x07, 0x10, 0x12},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_4 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_5 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xF6, 0x06, 0x1A, 0x14},
-	    {0xFA, 0x06, 0x16, 0x14},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_6 */
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xE7, 0x0E, 0x29, 0x04},
-	    {0xEE, 0x0C, 0x22, 0x08},
-	    {0xF6, 0x0B, 0x1A, 0x0A},
-	    {0xF9, 0x0A, 0x17, 0x0C},
-	    {0xFC, 0x0A, 0x14, 0x0C},
-	    {0x00, 0x08, 0x10, 0x10},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_7 */
-	    {0xEC, 0x02, 0x24, 0x1C},
-	    {0xF2, 0x04, 0x1E, 0x18},
-	    {0xEB, 0x15, 0x25, 0xF6},
-	    {0xF4, 0x10, 0x1C, 0x00},
-	    {0xF8, 0x0F, 0x18, 0x02},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0x01, 0x06, 0x0F, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_0 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_1 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_2 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xF1, 0xF7, 0x01, 0x32},
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xF9, 0xFF, 0x17, 0x22},
-	    {0xFB, 0x01, 0x15, 0x1E},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_3 */
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xEE, 0xFE, 0x22, 0x24},
-	    {0xF3, 0x00, 0x1D, 0x20},
-	    {0xF9, 0x03, 0x17, 0x1A},
-	    {0xFB, 0x02, 0x14, 0x1E},
-	    {0xFB, 0x04, 0x15, 0x18},
-	    {0x00, 0x06, 0x10, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_4 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_5 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xF1, 0xF7, 0x1F, 0x32},
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xF9, 0xFF, 0x17, 0x22},
-	    {0xFB, 0x01, 0x15, 0x1E},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_6 */
-	    {0xF5, 0xEE, 0x1B, 0x2A},
-	    {0xEE, 0xFE, 0x22, 0x24},
-	    {0xF3, 0x00, 0x1D, 0x20},
-	    {0xF9, 0x03, 0x17, 0x1A},
-	    {0xFB, 0x02, 0x14, 0x1E},
-	    {0xFB, 0x04, 0x15, 0x18},
-	    {0x00, 0x06, 0x10, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_7 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0xEB, 0x05, 0x25, 0x16},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xFA, 0x07, 0x16, 0x12},
-	    {0x00, 0x07, 0x10, 0x12},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } }
-};
-
-static int           filter = -1;
-
-#endif
diff -urN flo-ElementalX-5.00/drivers/usb/host/ehci-sched.c flo-ElementalX-5.00-patched/drivers/usb/host/ehci-sched.c
--- flo-ElementalX-5.00/drivers/usb/host/ehci-sched.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/usb/host/ehci-sched.c	2016-06-01 16:28:43.000000000 +0000
@@ -829,7 +829,7 @@
 {
 	int		status;
 	unsigned	uframe;
-	__hc32		c_mask = 0;
+	__hc32		c_mask;
 	unsigned	frame;		/* 0..(qh->period - 1), or NO_FRAME */
 	struct ehci_qh_hw	*hw = qh->hw;
 
diff -urN flo-ElementalX-5.00/drivers/usb/otg/otg-wakelock.c flo-ElementalX-5.00-patched/drivers/usb/otg/otg-wakelock.c
--- flo-ElementalX-5.00/drivers/usb/otg/otg-wakelock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/usb/otg/otg-wakelock.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,170 +0,0 @@
-/*
- * otg-wakelock.c
- *
- * Copyright (C) 2011 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/notifier.h>
-#include <linux/wakelock.h>
-#include <linux/spinlock.h>
-#include <linux/usb/otg.h>
-
-#define TEMPORARY_HOLD_TIME	2000
-
-static bool enabled = true;
-static struct usb_phy *otgwl_xceiv;
-static struct notifier_block otgwl_nb;
-
-/*
- * otgwl_spinlock is held while the VBUS lock is grabbed or dropped and the
- * held field is updated to match.
- */
-
-static DEFINE_SPINLOCK(otgwl_spinlock);
-
-/*
- * Only one lock, but since these 3 fields are associated with each other...
- */
-
-struct otgwl_lock {
-	char name[40];
-	struct wake_lock wakelock;
-	bool held;
-};
-
-/*
- * VBUS present lock.  Also used as a timed lock on charger
- * connect/disconnect and USB host disconnect, to allow the system
- * to react to the change in power.
- */
-
-static struct otgwl_lock vbus_lock;
-
-static void otgwl_hold(struct otgwl_lock *lock)
-{
-	if (!lock->held) {
-		wake_lock(&lock->wakelock);
-		lock->held = true;
-	}
-}
-
-static void otgwl_temporary_hold(struct otgwl_lock *lock)
-{
-	wake_lock_timeout(&lock->wakelock,
-			  msecs_to_jiffies(TEMPORARY_HOLD_TIME));
-	lock->held = false;
-}
-
-static void otgwl_drop(struct otgwl_lock *lock)
-{
-	if (lock->held) {
-		wake_unlock(&lock->wakelock);
-		lock->held = false;
-	}
-}
-
-static void otgwl_handle_event(unsigned long event)
-{
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&otgwl_spinlock, irqflags);
-
-	if (!enabled) {
-		otgwl_drop(&vbus_lock);
-		spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
-		return;
-	}
-
-	switch (event) {
-	case USB_EVENT_VBUS:
-	case USB_EVENT_ENUMERATED:
-		otgwl_hold(&vbus_lock);
-		break;
-
-	case USB_EVENT_NONE:
-	case USB_EVENT_ID:
-	case USB_EVENT_CHARGER:
-		otgwl_temporary_hold(&vbus_lock);
-		break;
-
-	default:
-		break;
-	}
-
-	spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
-}
-
-static int otgwl_otg_notifications(struct notifier_block *nb,
-				   unsigned long event, void *unused)
-{
-	otgwl_handle_event(event);
-	return NOTIFY_OK;
-}
-
-static int set_enabled(const char *val, const struct kernel_param *kp)
-{
-	int rv = param_set_bool(val, kp);
-
-	if (rv)
-		return rv;
-
-	if (otgwl_xceiv)
-		otgwl_handle_event(otgwl_xceiv->last_event);
-
-	return 0;
-}
-
-static struct kernel_param_ops enabled_param_ops = {
-	.set = set_enabled,
-	.get = param_get_bool,
-};
-
-module_param_cb(enabled, &enabled_param_ops, &enabled, 0644);
-MODULE_PARM_DESC(enabled, "enable wakelock when VBUS present");
-
-static int __init otg_wakelock_init(void)
-{
-	int ret;
-
-	otgwl_xceiv = usb_get_transceiver();
-
-	if (!otgwl_xceiv) {
-		pr_err("%s: No USB transceiver found\n", __func__);
-		return -ENODEV;
-	}
-
-	snprintf(vbus_lock.name, sizeof(vbus_lock.name), "vbus-%s",
-		 dev_name(otgwl_xceiv->dev));
-	wake_lock_init(&vbus_lock.wakelock, WAKE_LOCK_SUSPEND,
-		       vbus_lock.name);
-
-	otgwl_nb.notifier_call = otgwl_otg_notifications;
-	ret = usb_register_notifier(otgwl_xceiv, &otgwl_nb);
-
-	if (ret) {
-		pr_err("%s: usb_register_notifier on transceiver %s"
-		       " failed\n", __func__,
-		       dev_name(otgwl_xceiv->dev));
-		otgwl_xceiv = NULL;
-		wake_lock_destroy(&vbus_lock.wakelock);
-		return ret;
-	}
-
-	otgwl_handle_event(otgwl_xceiv->last_event);
-	return ret;
-}
-
-late_initcall(otg_wakelock_init);
diff -urN flo-ElementalX-5.00/drivers/video/console/fbcon.c flo-ElementalX-5.00-patched/drivers/video/console/fbcon.c
--- flo-ElementalX-5.00/drivers/video/console/fbcon.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/console/fbcon.c	2014-12-03 03:07:30.000000000 +0000
@@ -3570,7 +3570,7 @@
 	return 0;
 }
 
-module_init(fb_console_init);
+late_initcall(fb_console_init);
 
 #ifdef MODULE
 
diff -urN flo-ElementalX-5.00/drivers/video/msm/Kconfig flo-ElementalX-5.00-patched/drivers/video/msm/Kconfig
--- flo-ElementalX-5.00/drivers/video/msm/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/Kconfig	2016-06-02 00:51:30.000000000 +0000
@@ -687,6 +687,9 @@
 config FB_MSM_DEFAULT_DEPTH_ARGB8888
 	bool "32 bits per pixel (ARGB8888)"
 
+config FB_MSM_DEFAULT_DEPTH_BGRA8888
+	bool "32 bits per pixel (BGRA8888) (actually ARGB/xRGB)"
+	
 config FB_MSM_DEFAULT_DEPTH_RGBA8888
 	bool "32 bits per pixel (RGBA8888)"
 
diff -urN flo-ElementalX-5.00/drivers/video/msm/mdp4_overlay.c flo-ElementalX-5.00-patched/drivers/video/msm/mdp4_overlay.c
--- flo-ElementalX-5.00/drivers/video/msm/mdp4_overlay.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/mdp4_overlay.c	2014-12-03 11:07:31.000000000 +0000
@@ -3045,10 +3045,10 @@
 		 ib_quota_total, perf_req->mdp_ib_bw);
 
 	if (ab_quota_total > mdp_max_bw)
-		pr_debug("%s: req ab bw=%llu is larger than max bw=%llu",
+		pr_warn("%s: req ab bw=%llu is larger than max bw=%llu",
 			__func__, ab_quota_total, mdp_max_bw);
 	if (ib_quota_total > mdp_max_bw)
-		pr_debug("%s: req ib bw=%llu is larger than max bw=%llu",
+		pr_warn("%s: req ib bw=%llu is larger than max bw=%llu",
 			__func__, ib_quota_total, mdp_max_bw);
 
 	pr_debug("%s %d: pid %d cnt %d clk %d ov0_blt %d, ov1_blt %d\n",
diff -urN flo-ElementalX-5.00/drivers/video/msm/mdss/mdss_fb.c flo-ElementalX-5.00-patched/drivers/video/msm/mdss/mdss_fb.c
--- flo-ElementalX-5.00/drivers/video/msm/mdss/mdss_fb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/mdss/mdss_fb.c	2014-12-03 11:07:31.000000000 +0000
@@ -741,6 +741,25 @@
 		bpp = 4;
 		break;
 
+	case MDP_BGRA_8888:
+		fix->type = FB_TYPE_PACKED_PIXELS;
+		fix->xpanstep = 1;
+		fix->ypanstep = 1;
+		var->vmode = FB_VMODE_NONINTERLACED;
+		var->blue.offset = 16;
+		var->green.offset = 8;
+		var->red.offset = 0;
+		var->blue.length = 8;
+		var->green.length = 8;
+		var->red.length = 8;
+		var->blue.msb_right = 0;
+		var->green.msb_right = 0;
+		var->red.msb_right = 0;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		bpp = 4;
+		break;
+
 	case MDP_YCRYCB_H2V1:
 		fix->type = FB_TYPE_INTERLEAVED_PLANES;
 		fix->xpanstep = 2;
@@ -1060,10 +1079,14 @@
 		break;
 
 	case 32:
-		if (var->transp.offset == 24)
+		if (var->transp.offset == 24) {
+			if (var->red.offset == 16)
+				mfd->fb_imgType	= MDP_BGRA_8888;
+			else
+				mfd->fb_imgType = MDP_RGBA_8888;
+		} else {
 			mfd->fb_imgType = MDP_ARGB_8888;
-		else
-			mfd->fb_imgType	= MDP_RGBA_8888;
+		}
 		break;
 
 	default:
diff -urN flo-ElementalX-5.00/drivers/video/msm/msm_fb.c flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb.c
--- flo-ElementalX-5.00/drivers/video/msm/msm_fb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb.c	2014-12-03 11:07:31.000000000 +0000
@@ -46,7 +46,6 @@
 #include <linux/sync.h>
 #include <linux/sw_sync.h>
 #include <linux/file.h>
-#include <linux/moduleparam.h>
 
 #define MSM_FB_C
 #include "msm_fb.h"
@@ -63,9 +62,6 @@
 #undef CONFIG_HAS_EARLYSUSPEND
 #endif
 
-int backlight_dimmer = 0;
-module_param(backlight_dimmer, int, 0755);
-
 static unsigned char *fbram;
 static unsigned char *fbram_phys;
 static int fbram_size;
@@ -204,21 +200,11 @@
 		bl_lvl = 0;
 	else if (value >= MAX_BACKLIGHT_BRIGHTNESS)
 		bl_lvl = mfd->panel_info.bl_max;
-	else if (backlight_dimmer > 0) {
-		if (value <= backlight_dimmer) {
-			bl_lvl = 1;
-		} else {
-			bl_lvl = (mfd->panel_info.bl_min + ((value - 1) * 2 *
-				(mfd->panel_info.bl_max - mfd->panel_info.bl_min) +
-				MAX_BACKLIGHT_BRIGHTNESS - 1) /
-				(MAX_BACKLIGHT_BRIGHTNESS - 1) / 2) - backlight_dimmer;
-		}
-	} else {
+	else
 		bl_lvl = mfd->panel_info.bl_min + ((value - 1) * 2 *
 			(mfd->panel_info.bl_max - mfd->panel_info.bl_min) +
 			MAX_BACKLIGHT_BRIGHTNESS - 1) /
 			(MAX_BACKLIGHT_BRIGHTNESS - 1) / 2;
-	}
 
 	down(&mfd->sem);
 	msm_fb_set_backlight(mfd, bl_lvl);
@@ -1366,6 +1352,25 @@
 		bpp = 4;
 		break;
 
+	case MDP_BGRA_8888:
+		fix->type = FB_TYPE_PACKED_PIXELS;
+		fix->xpanstep = 1;
+		fix->ypanstep = 1;
+		var->vmode = FB_VMODE_NONINTERLACED;
+		var->blue.offset = 16;
+		var->green.offset = 8;
+		var->red.offset = 0;
+		var->blue.length = 8;
+		var->green.length = 8;
+		var->red.length = 8;
+		var->blue.msb_right = 0;
+		var->green.msb_right = 0;
+		var->red.msb_right = 0;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		bpp = 4;
+		break;
+
 	case MDP_YCRYCB_H2V1:
 		/* ToDo: need to check TV-Out YUV422i framebuffer format */
 		/*       we might need to create new type define */
@@ -1618,11 +1623,6 @@
 	    ("FrameBuffer[%d] %dx%d size=%d bytes is registered successfully!\n",
 	     mfd->index, fbi->var.xres, fbi->var.yres, fbi->fix.smem_len);
 
-#ifdef CONFIG_UPDATE_LCDC_LUT
-	if (msm_fb_pdata->update_lcdc_lut)
-		msm_fb_pdata->update_lcdc_lut();
-#endif
-
 #ifdef CONFIG_FB_MSM_LOGO
 	/* Flip buffer */
 	if (!load_565rle_image(INIT_IMAGE_FILE, bf_supported))
@@ -2342,11 +2342,15 @@
 		break;
 
 	case 32:
-		if (var->transp.offset == 24)
+		if (var->transp.offset == 24) {
+			if (var->red.offset == 16)
+				mfd->fb_imgType	= MDP_BGRA_8888;
+			else
+				mfd->fb_imgType = MDP_RGBA_8888;
+		} else {
 			mfd->fb_imgType = MDP_ARGB_8888;
-		else
-			mfd->fb_imgType = MDP_RGBA_8888;
-		break;
+		}
+	break;
 
 	default:
 		return -EINVAL;
@@ -4068,6 +4072,10 @@
 		ret = msm_fb_resume_sw_refresher(mfd);
 		break;
 
+    case FBIO_WAITFORVSYNC:
+        ret = mdp4_overlay_wait4vsync(info);
+        break;
+
 	case MSMFB_CURSOR:
 		ret = copy_from_user(&cursor, argp, sizeof(cursor));
 		if (ret)
diff -urN flo-ElementalX-5.00/drivers/video/msm/msm_fb_def.h flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb_def.h
--- flo-ElementalX-5.00/drivers/video/msm/msm_fb_def.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb_def.h	2014-12-03 11:07:31.000000000 +0000
@@ -92,6 +92,8 @@
 #define MSMFB_DEFAULT_TYPE MDP_ARGB_8888
 #elif defined(CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888)
 #define MSMFB_DEFAULT_TYPE MDP_RGBA_8888
+#elif defined(CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888)
+#define MSMFB_DEFAULT_TYPE MDP_BGRA_8888
 #else
 #define MSMFB_DEFAULT_TYPE MDP_RGB_565
 #endif
diff -urN flo-ElementalX-5.00/fs/proc/namespaces.c flo-ElementalX-5.00-patched/fs/proc/namespaces.c
--- flo-ElementalX-5.00/fs/proc/namespaces.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/fs/proc/namespaces.c	2016-06-01 15:49:17.000000000 +0000
@@ -24,9 +24,9 @@
 #ifdef CONFIG_IPC_NS
 	&ipcns_operations,
 #endif
-#ifdef CONFIG_PID_NS
-	&pidns_operations,
-#endif
+//#ifdef CONFIG_PID_NS
+//	&pidns_operations,
+//#endif
 	&mntns_operations,
 };
 
diff -urN flo-ElementalX-5.00/include/config/auto.conf flo-ElementalX-5.00-patched/include/config/auto.conf
--- flo-ElementalX-5.00/include/config/auto.conf	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/auto.conf	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,1369 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_RING_BUFFER=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SCSI_DMA=y
+CONFIG_MSM_VIDC_VENC=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_RFS_ACCEL=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_CRC32=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_HAVE_AOUT=y
+CONFIG_VFP=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_AEABI=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SECCOMP=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_MSM_REMOTE_SPINLOCK_SFPB=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+CONFIG_MSM_IPC_ROUTER_SECURITY=y
+CONFIG_KERNEL_MSM_CONTIG_MEM_REGION=y
+CONFIG_BT_RFCOMM=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_INOTIFY_USER=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_RC_CORE=y
+CONFIG_BATTERY_ASUS_BQ27541=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_BINFMT_MISC=y
+CONFIG_MSM_BT_POWER=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_UHID=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_FSNOTIFY=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_INET6_TUNNEL=y
+CONFIG_USB_SUSPEND=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_HIDRAW=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_USB_HSIC_SMSC_HUB=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX=y
+CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_MSM_SMP=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_USB_EHCI_MSM_HOST4=y
+CONFIG_MSM_PM8X60=y
+CONFIG_FIB_RULES=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_HID_EMS_FF=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_IPV6=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_BQL=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_USB_DEVICEFS=y
+CONFIG_DEVTMPFS=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_WLAN=y
+CONFIG_NAMESPACES=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_SENSORS_CAP1106=y
+CONFIG_SMUX_CTL=y
+CONFIG_ATAGS_PROC=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_TUN=y
+CONFIG_USB_OTG_UTILS=y
+CONFIG_CFG80211=y
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_DM_CRYPT=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_HID_BELKIN=y
+CONFIG_VIDEO_IR_I2C=y
+CONFIG_MSM_XO=y
+CONFIG_FB_MSM_OVERLAY1_WRITEBACK=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_HID_ACRUX=y
+CONFIG_RD_LZMA=y
+CONFIG_USB=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_ETHERNET=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_DQL=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_TCP_CONG_LP=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_HID_CHERRY=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_MSM_PCIE=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_PICOLCD=y
+CONFIG_BCMA_POSSIBLE=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_VGA_ARB=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_SND_SOC=y
+CONFIG_SYNC=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_PRINTK=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_TIMERFD=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_FB_MSM_MIPI_DSI_NOVATEK=y
+CONFIG_DNS_RESOLVER=y
+CONFIG_TRACEPOINTS=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_IRDA=y
+CONFIG_BOUNCE=y
+CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
+CONFIG_SHMEM=y
+CONFIG_MIGRATION=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_HID_PRIMAX=y
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DNOTIFY=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_SND_SOC_CS8427=y
+CONFIG_CRYPTO_DES=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_MSM_SMD=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_NET_CLS_U32=y
+CONFIG_EXPORTFS=y
+CONFIG_ARM_GIC=y
+CONFIG_SERIO=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+CONFIG_MSM7X00A_USE_GP_TIMER=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_MA600_DONGLE=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_MSM_QDSP6_APR=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_I2C_QUP=y
+CONFIG_MFD_PM8XXX=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ENCRYPTED_KEYS=y
+CONFIG_HWMON=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_MSM_KRAIT_WFE_FIXUP=y
+CONFIG_STM_LIS3DH=y
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_MSM_L2_ERP_2BIT_PANIC=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_MSM_LPASS_8960=y
+CONFIG_PM_CLK=y
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_FB_MSM_DTV=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_CPU_VOLTAGE_TABLE=y
+CONFIG_SLIMPORT_ANX7808=y
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_LOCKD=y
+CONFIG_GPIO_PM8XXX=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ARM=y
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_HID_SAITEK=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_RPCSEC_GSS_KRB5=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_SPS_SUPPORT_BAMDMA=y
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_KERNEL_XZ=y
+CONFIG_USB_STORAGE=y
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_BOARD_HEADER_FILE=""
+CONFIG_STANDALONE=y
+CONFIG_SCHED_MC=y
+CONFIG_SPI_QUP=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_IR_LIRC_CODEC=y
+CONFIG_DONGLE=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_FB_MSM_EXT_INTERFACE_COMMON=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_ASHMEM=y
+CONFIG_BLOCK=y
+CONFIG_HAVE_IDE=y
+CONFIG_HID_APPLE=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_EXFAT_FS=y
+CONFIG_INPUT_MPU3050=y
+CONFIG_MSM_VIDC_1080P=y
+CONFIG_USER_NS=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_ASUSTEK_HEADSET=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_BUG=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_PM=y
+CONFIG_MACH_ASUSTEK=y
+CONFIG_SPI=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_SWITCH=y
+CONFIG_DEVKMEM=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_PPP_DEFLATE=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_VT=y
+CONFIG_USB_NET_NET1080=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_HID_TIVO=y
+CONFIG_REGMAP_SPI=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MFD_PM8038_CORE=y
+CONFIG_MSM_PIL_TZAPPS=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_WEXT_CORE=y
+CONFIG_MSM_DSPS=y
+CONFIG_NLS=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_SENSORS_PM8XXX_ADC=y
+CONFIG_PPPOE=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_IRQ_WORK=y
+CONFIG_PCI_MSI=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_CLEANCACHE=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_DIAG_OVER_USB=y
+CONFIG_USB_COMMON=y
+CONFIG_TASK_XACCT=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+CONFIG_INET_IPCOMP=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_EVENT_TRACING=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_CYPRESS=y
+CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
+CONFIG_FB_MSM_MIPI_DSI_JDI=y
+CONFIG_MSM_AUDIO_QDSP6=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_PPP_MPPE=y
+CONFIG_USB_IRDA=y
+CONFIG_RFKILL=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_KEY=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_MSM_SSBI=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_EVENTFD=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_IPV6_SIT=y
+CONFIG_XFRM=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT=y
+CONFIG_MSM_WFD=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_MMC_MSM_SDC1_SUPPORT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_CRYPTO_LZ4=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_RD_LZO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_HID_LCPOWER=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_PM_DEBUG=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_BT_HCISMD=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_MSM_AVS_HW=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MSM_QDSP6_CODECS=y
+CONFIG_INPUT_LID=y
+CONFIG_NET_VENDOR_RDC=y
+CONFIG_CPUSETS=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_MSM_PIL_VIDC=y
+CONFIG_MSM_DMA_TEST=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_FAT_FS=y
+CONFIG_WCD9304_CODEC=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HIGHMEM=y
+CONFIG_SPS=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED=y
+CONFIG_INET_TUNNEL=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_EEPROM_93CX6=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_LIB80211=y
+CONFIG_MFD_CORE=y
+CONFIG_REGULATOR_MSM_GPIO=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_STOP_MACHINE=y
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_SND_SOC_QDSP6=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_CPU_FREQ=y
+CONFIG_MSM_KGSL_DRM=y
+CONFIG_USB_GSPCA=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_NLS_ASCII=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_USB_CSW_HACK=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_USB_NET_CDC_SUBSET=y
+CONFIG_FB_MSM=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_BLK_CGROUP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
+CONFIG_SND_USB=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_RD_GZIP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_LBDAF=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_V4L_PCI_DRIVERS=y
+CONFIG_HID_ROCCAT=y
+CONFIG_NET_VENDOR_HP=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_N_SMUX=y
+CONFIG_BINFMT_ELF=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_HOTPLUG=y
+CONFIG_INET6_AH=y
+CONFIG_CPU_CP15=y
+CONFIG_USB_SERIAL=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_KEYS=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_KEXEC_HARDBOOT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_SLABINFO=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_MSM_CACHE_DUMP=y
+CONFIG_TIMER_STATS=y
+CONFIG_MSM_SMD_LOGGING=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_CRYPTO_HW=y
+CONFIG_GENLOCK_MISCDEVICE=y
+CONFIG_FB_MSM_TVOUT_NONE=y
+CONFIG_ION=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_PHYS_OFFSET=0x80200000
+CONFIG_HID_GREENASIA=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_SPI_MASTER=y
+CONFIG_FB_MSM_LCDC_HW=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_ANDROID_PERSISTENT_RAM=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_HID_GYRATION=y
+CONFIG_USB_WDM=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_INPUT_JOYDEV=y
+CONFIG_EARLYSUSPEND=y
+CONFIG_THERMAL_TSENS8960=y
+CONFIG_USB_ACM=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_CRC16=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_NET_CLS=y
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_TMPFS=y
+CONFIG_ANON_INODES=y
+CONFIG_FUTEX=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_VMSPLIT_3G=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_USB_HID=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_SND_SOC_WCD9310=y
+CONFIG_ANDROID=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_FB_MSM_NO_MDP_PIPE_CTRL=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_MSM_L1_ERR_PANIC=y
+CONFIG_FANOTIFY=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_SMC911X=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_SYSVIPC=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_SMSC911X=y
+CONFIG_GPIO_MSM_V2=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_MODULES=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_USB_GADGET=y
+CONFIG_SOUND=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_UNIX=y
+CONFIG_HAVE_CLK=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_LZ4HC=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_NFS_FS=y
+CONFIG_XPS=y
+CONFIG_INET_ESP=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_MD=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FONTS=y
+CONFIG_MEDIA_TUNER=y
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+CONFIG_RD_BZIP2=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_NF_NAT=y
+CONFIG_ION_MSM=y
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_MSM_KGSL_SIMPLE_GOV=y
+CONFIG_CPU_IDLE=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_MPM=y
+CONFIG_NFS_COMMON=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_REGULATOR=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_EFI_PARTITION=y
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_NET_VENDOR_8390=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_VFAT_FS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+CONFIG_PID_NS=y
+CONFIG_MSM_KGSL_2D=y
+CONFIG_KEXEC=y
+CONFIG_CRC32_SLICEBY8=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_CPU_RMAP=y
+CONFIG_SND_HWDEP=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_MFD_PM8XXX_SPK=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_WAKELOCK=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_INPUT_MISC=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_SUSPEND=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_AMSS_7X25_VERSION_2009=y
+CONFIG_MSM_PIL=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_CPU_FREQ_MSM=y
+CONFIG_MSM_PM_TIMEOUT_HALT=y
+CONFIG_FS_MBCACHE=y
+CONFIG_RTC_CLASS=y
+CONFIG_MFD_PM8XXX_IRQ=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CPU_PM=y
+CONFIG_MSM_VIDC_VDEC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_MSM_IOMMU=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_TCP_CONG_ILLINOIS=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_SLUB=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_SLIP=y
+CONFIG_PM_SLEEP=y
+CONFIG_I2C=y
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_MSM_SOC_REV_NONE=y
+CONFIG_FB_MSM_BACKLIGHT=y
+CONFIG_FRAME_POINTER=y
+CONFIG_BT_HIDP=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_MFD_PM8XXX_MISC=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_DEBUG_FS=y
+CONFIG_ARCH_MSM_KRAIT=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_BASE_FULL=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_SUNRPC=y
+CONFIG_MFD_PM8XXX_PWM=y
+CONFIG_QSEECOM=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_FW_LOADER=y
+CONFIG_KALLSYMS=y
+CONFIG_PCI=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_CRYPTO_XTS=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MII=y
+CONFIG_SIGNALFD=y
+CONFIG_NET_CORE=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_EXT4_FS=y
+CONFIG_WCNSS_CORE=m
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_XZ_DEC=y
+CONFIG_USB_BELKIN=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_LOCKD_V4=y
+CONFIG_DUMMY=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_MSM_CPU_PWRCTL=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_HAS_IOMEM=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_PPPOPNS=y
+CONFIG_UID_CPUTIME=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_MSM_RESET_MODEM=y
+CONFIG_IOSCHED_TEST=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_EPOLL=y
+CONFIG_SND_PCM=y
+CONFIG_CAP_SENSOR_RMNET_CTL=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NET=y
+CONFIG_LEDS_PM8XXX=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_SND_JACK=y
+CONFIG_USB_QCOM_DIAG_BRIDGE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_VFPv3=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_IOMMU_PGTABLES_L2=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_PACKET=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_BCM2079X=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NFS_V3=y
+CONFIG_FB_MSM_MIPI_LG_1080_HD_PT=y
+CONFIG_NOP_TRACER=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_INET=y
+CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_MSM_IOMMU_GPU_SYNC=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_FREEZER=y
+CONFIG_BT=y
+CONFIG_RFKILL_PM=y
+CONFIG_MACH_APQ8064_FLO=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_REED_SOLOMON=y
+CONFIG_PMIC8XXX_VIBRATOR=y
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_FB_MSM_HDMI_COMMON=y
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_CP_ACCESS=y
+CONFIG_HID_WACOM=y
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=y
+CONFIG_RTC_LIB=y
+CONFIG_MSM_WCNSS_SSR_8960=m
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_CRYPTO_AES=y
+CONFIG_GPIOLIB=y
+CONFIG_MODEM_SUPPORT=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_USER_RC_INPUT=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_SWP_EMULATE=y
+CONFIG_FB_MSM_MIPI_DSI=y
+CONFIG_UIO=y
+CONFIG_SND_ARM=y
+CONFIG_HID_WALTOP=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_FB_MSM_MIPI_DSI_LG=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_LIRC=y
+CONFIG_BT_BNEP=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_RD_XZ=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
+CONFIG_SND_DRIVERS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_LCD_KCAL=y
+CONFIG_NO_HZ=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_USB_MSM_OTG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_INET6_ESP=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MMC_MSM=y
+CONFIG_MSM_AMSS_VERSION_6225=y
+CONFIG_TASKSTATS=y
+CONFIG_SLIMBUS_MSM_CTRL=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_FONT_8x8=y
+CONFIG_SMC91X=y
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_CPU_V7=y
+CONFIG_HID_TWINHAN=y
+CONFIG_GPIO_SX150X=y
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_FB_MSM_OVERLAY=y
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_MSM_PIL_QDSP6V4=y
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_SMP=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_PRIMA_WLAN=m
+CONFIG_ARM_NR_BANKS=8
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_L2TP=y
+CONFIG_MSM_WATCHDOG=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_GENERIC_IO=y
+CONFIG_LIBCRC32C=y
+CONFIG_GPIO_PM8XXX_MPP=y
+CONFIG_KEYBOARD_MATRIX=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_MSM_DCVS=y
+CONFIG_GENERIC_BUG=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_HID_SONY=y
+CONFIG_HW_CONSOLE=y
+CONFIG_DEVMEM=y
+CONFIG_SND_SPI=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_EZKEY=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_MSM_GSS_SSR_8064=y
+CONFIG_NEON=y
+CONFIG_MSM_VCAP=y
+CONFIG_GENERIC_ACL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_COMPAT_BRK=y
+CONFIG_LOCALVERSION="-flo"
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_ADAPTERS=y
+CONFIG_CRYPTO=y
+CONFIG_MSM_SCM=y
+CONFIG_NET_VENDOR_BROCADE=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_CMDLINE=""
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_FB_VIRTUAL=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_MSM_RMNET_SMUX=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_SCSI_MOD=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_AUDIT_TREE=y
+CONFIG_VIDEOBUF2_DMA_SG=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_MSM_L1_ERR_LOG=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_SERIAL_CORE=y
+CONFIG_FUSE_FS=y
+CONFIG_UID16=y
+CONFIG_EMBEDDED=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_VIDEO_DEV=y
+CONFIG_NFS_V4=y
+CONFIG_PPP_FILTER=y
+CONFIG_FB_MSM_MDP_HW=y
+CONFIG_MSM_SMD_QMI=y
+CONFIG_HAS_DMA=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_SCSI=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_MSM_MDP40=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_MSM_SMD_NMEA=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_JBD2=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_PHYLIB=y
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_IPC_NS=y
+CONFIG_CPU_HAS_L2_PMU=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_DIAG_CHAR=y
+CONFIG_FTRACE=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_PPPOL2TP=y
+CONFIG_HID_TOPSEED=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_KSM=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
+CONFIG_NF_NAT_H323=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_HID_A4TECH=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_PROFILING=y
+CONFIG_SPARSEMEM=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_MSM_NATIVE_RESTART=y
+CONFIG_RTC_DRV_PM8XXX=y
+CONFIG_MSM7X00A_SLEEP_MODE=0
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_SLHC=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_HAVE_SMP=y
+CONFIG_SCSI_TGT=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_HID_ORTEK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_REGULATOR_PM8XXX=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_MMC_BLOCK=y
+CONFIG_NET_CLS_FW=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
+CONFIG_SND_PCI=y
+CONFIG_EXPERT=y
+CONFIG_RTAC=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
+CONFIG_ASUSTEK_PCBID=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_PROC=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FRAME_WARN=1024
+CONFIG_USB_NET_CDC_NCM=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_UPDATE_LCDC_LUT=y
+CONFIG_SND_SOC_WCD9304=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CGROUPS=y
+CONFIG_MMC=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_ARM_TICKET_LOCKS=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_HID_LOGITECH=y
+CONFIG_STACKTRACE=y
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_PPPOLAC=y
+CONFIG_MULTI_IRQ_HANDLER=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_MSM_PIL_DSPS=y
+CONFIG_HAS_IOPORT=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_HZ=100
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_FB_BACKLIGHT=y
+CONFIG_MSM_SMD_DEBUG=y
+CONFIG_QCACHE=y
+CONFIG_INET_AH=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_FB_MSM_OVERLAY0_WRITEBACK=y
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_IPV6_MIP6=y
+CONFIG_NLATTR=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_ARCH_MSM8960=y
+CONFIG_NR_CPUS=4
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+CONFIG_HID_KYE=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_SYSFS=y
+CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_ARM_THUMB=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_SLIMBUS=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_N_SMUX_LOOPBACK=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_FB_SYS_FOPS=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_FB=y
+CONFIG_TRACING=y
+CONFIG_I2C_COMPAT=y
+CONFIG_CPU_32v7=y
+CONFIG_MSM_BUSPM_DEV=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FRANDOM=y
+CONFIG_BT_HCIUART=y
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_THERMAL=y
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_HID_PETALYNX=y
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_MSM_VIDC=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_MSM_KGSL=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_RPS=y
+CONFIG_USB_NET_ZAURUS=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_WCD9310_CODEC=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_VIDEO_MEDIA=y
+CONFIG_IP_MULTICAST=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_MFD_PM8921_CORE=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_CPU_32v6K=y
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_TICK_ONESHOT=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_SW_SYNC=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_MSM_PIL_GSS=y
+CONFIG_HW_RANDOM=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USB_SERIAL_CSVT=y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_THERMAL_PM8XXX=y
+CONFIG_IRTTY_SIR=y
+CONFIG_CPUPOWER=y
+CONFIG_MSM_SPM_V2=y
+CONFIG_BASE_SMALL=0
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_MSM_SLEEPER=y
+CONFIG_PROC_FS=y
+CONFIG_NET_PACKET_ENGINE=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_RC_MAP=y
+CONFIG_WEXT_PRIV=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_SND_SOC_MSM8960=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_SND=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_ARCH_MSM8930=y
+CONFIG_MSM_TZ_LOG=y
+CONFIG_SND_SOC_MSM_STUB=y
+CONFIG_MSM_EVENT_TIMER=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_MSM_AMSS_VERSION=6225
+CONFIG_IKCONFIG=y
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_MSM_RPM=y
+CONFIG_SYSCTL=y
+CONFIG_ARCH_MSM=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_CIFS=y
+CONFIG_XFRM_USER=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_MACH_APQ8064_DEB=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT=y
+CONFIG_GENLOCK=y
+CONFIG_MSM_HSIC_SYSMON=y
+CONFIG_NET_NS=y
+CONFIG_SOUND_CONTROL_HAX_GPL=y
+CONFIG_MSM_EBI_ERP=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_MSM_ULTRASOUND=y
+CONFIG_PPP_ASYNC=y
+CONFIG_MSM_SMD_TTY=y
+CONFIG_UID_STAT=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_AUDIT=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+CONFIG_ASUSTEK_KEYPAD=y
+CONFIG_CMA_AREAS=7
+CONFIG_HID_MULTITOUCH=y
+CONFIG_SECURITY=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_HID_ELECOM=y
+CONFIG_SND_TIMER=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_BLK_DEV=y
+CONFIG_MFD_PM8821_CORE=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_SENSORS_EPM_ADC=y
+CONFIG_PRIMA_WLAN_LFR=y
+CONFIG_IOMMU_API=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_NET_SCHED=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_FB_MSM_MIPI_JDI_CMD_MODE=y
+CONFIG_PRINTK_TIME=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_SECCOMP_FILTER=y
+CONFIG_PPP=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_ARCH_APQ8064=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_INET_DIAG=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_ELF_CORE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_MSM_CACHE_ERP=y
+CONFIG_USB_SUPPORT=y
+CONFIG_SND_SOC_MSM_QDSP6_INTF=y
+CONFIG_DIAGFWD_BRIDGE_CODE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_STAGING=y
+CONFIG_USB_QCOM_MDM_BRIDGE=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_MSM_IDLE_STATS=y
+CONFIG_BT_HCIUART_IBS=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MSM_RMNET_USB=y
+CONFIG_USB_QCOM_KS_BRIDGE=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_DRM=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=y
+CONFIG_PREEMPT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_MSM_CACHE_DUMP_ON_PANIC=y
+CONFIG_BINARY_PRINTF=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_FB_MSM_HDMI_MSM_PANEL=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_MSM_N_WAY_SMD=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HID_NTRIG=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CIFS_POSIX=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_CROSS_COMPILE=""
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_HID_HOLTEK=y
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_MSM_PIL_RIVA=y
+CONFIG_REGMAP=y
+CONFIG_NLS_UTF8=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_MSM_RUN_QUEUE_STATS=y
+CONFIG_USB_USBNET=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_FHANDLE=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_NEW_LEDS=y
+CONFIG_SWAP=y
+CONFIG_SND_SOC_VOICE=y
+CONFIG_CRC_CCITT=y
+CONFIG_ANDROID_PMEM=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_WAKE_TIMEOUT=y
+CONFIG_AVERAGE=y
+CONFIG_MSM_RPM_REGULATOR=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_MSM_HSIC_TTY=y
+CONFIG_ARCH_MSM_KRAITMP=y
+CONFIG_CMA=y
+CONFIG_CHARGER_SMB345=y
+CONFIG_RCU_FANOUT=32
+CONFIG_BITREVERSE=y
+CONFIG_DEVPORT=y
+CONFIG_MSM_ROTATOR=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_PRIMA_WLAN_OKC=y
+CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_MSM_GPIOMUX=y
+CONFIG_MFD_PM8XXX_DEBUG=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_MSM_N_WAY_SMSM=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_IOSCHED_FIOPS=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_FILE_LOCKING=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_MSM_MULTIMEDIA_USE_ION=y
+CONFIG_AIO=y
+CONFIG_NET_EMATCH=y
+CONFIG_PERF_EVENTS=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_LEDS_CLASS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_HID_SUPPORT=y
+CONFIG_FB_MSM_HDMI_3D=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_MSM_MODEM_8960=y
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_UTS_NS=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_MOUSE_PS2=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_WEXT_SPY=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_INPUT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_RD_LZ4=y
+CONFIG_MMU=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_USB_SIERRA_NET=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
+CONFIG_MFD_PM8821_IRQ=y
diff -urN flo-ElementalX-5.00/include/config/auto.conf.cmd flo-ElementalX-5.00-patched/include/config/auto.conf.cmd
--- flo-ElementalX-5.00/include/config/auto.conf.cmd	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/auto.conf.cmd	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,816 @@
+deps_config := \
+	lib/xz/Kconfig \
+	lib/Kconfig \
+	drivers/crypto/caam/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/evm/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/integrity/Kconfig \
+	security/yama/Kconfig \
+	security/apparmor/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/ceph/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig.ore \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/pstore/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx6/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/logfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/yaffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/exfat/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/fanotify/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/f2fs/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/coresight/Kconfig \
+	drivers/gud/Kconfig \
+	drivers/devfreq/Kconfig \
+	drivers/virt/Kconfig \
+	drivers/rpmsg/Kconfig \
+	drivers/remoteproc/Kconfig \
+	drivers/iommu/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/hwspinlock/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/platform/msm/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/cpupower/Kconfig \
+	drivers/staging/prima/Kconfig \
+	drivers/staging/ozwpan/Kconfig \
+	drivers/staging/ramster/Kconfig \
+	drivers/staging/telephony/Kconfig \
+	drivers/staging/android/switch/Kconfig \
+	drivers/staging/android/Kconfig \
+	drivers/staging/omapdrm/Kconfig \
+	drivers/staging/media/lirc/Kconfig \
+	drivers/staging/media/solo6x10/Kconfig \
+	drivers/staging/media/go7007/Kconfig \
+	drivers/staging/media/easycap/Kconfig \
+	drivers/staging/media/dt3155v4l/Kconfig \
+	drivers/staging/media/cxd2099/Kconfig \
+	drivers/staging/media/as102/Kconfig \
+	drivers/staging/media/Kconfig \
+	drivers/staging/nvec/Kconfig \
+	drivers/staging/mei/Kconfig \
+	drivers/staging/ste_rmi4/Kconfig \
+	drivers/staging/cptm1217/Kconfig \
+	drivers/staging/speakup/Kconfig \
+	drivers/staging/ft1000/Kconfig \
+	drivers/staging/bcm/Kconfig \
+	drivers/staging/keucr/Kconfig \
+	drivers/staging/sbe-2t3e3/Kconfig \
+	drivers/staging/quickstart/Kconfig \
+	drivers/staging/tidspbridge/Kconfig \
+	drivers/staging/xgifb/Kconfig \
+	drivers/staging/cxt1e1/Kconfig \
+	drivers/staging/crystalhd/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/zsmalloc/Kconfig \
+	drivers/staging/qcache/Kconfig \
+	drivers/staging/zcache/Kconfig \
+	drivers/staging/zram/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/resolver/Kconfig \
+	drivers/staging/iio/meter/Kconfig \
+	drivers/staging/iio/magnetometer/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/imu/Kconfig \
+	drivers/staging/iio/impedance-analyzer/Kconfig \
+	drivers/staging/iio/gyro/Kconfig \
+	drivers/staging/iio/dds/Kconfig \
+	drivers/staging/iio/dac/Kconfig \
+	drivers/staging/iio/cdc/Kconfig \
+	drivers/staging/iio/addac/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/vme/boards/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/rts5139/Kconfig \
+	drivers/staging/rts_pstor/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/rtl8192e/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/olpc_dcon/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/serial/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/hv/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srpt/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/qib/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/switch/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/renesas_usbhs/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/dwc3/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/tegra/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/samsung/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/mxs/Kconfig \
+	sound/soc/msm/Kconfig \
+	sound/soc/mid-x86/Kconfig \
+	sound/soc/kirkwood/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/nuc900/Kconfig \
+	sound/soc/jz4740/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/ep93xx/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/firewire/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/exynos/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/msm/mdss/Kconfig \
+	drivers/video/msm/vidc/Kconfig \
+	drivers/video/msm/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/msm/Kconfig \
+	drivers/gpu/ion/Kconfig \
+	drivers/gpu/stub/Kconfig \
+	drivers/gpu/drm/udl/Kconfig \
+	drivers/gpu/drm/gma500/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/gpu/drm/exynos/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/mpq/demux/Kconfig \
+	drivers/media/dvb/mpq/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/ddbridge/Kconfig \
+	drivers/media/dvb/ngene/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/wl128x/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/msm_wfd/Kconfig \
+	drivers/media/video/msm_vidc/Kconfig \
+	drivers/media/video/s5p-tv/Kconfig \
+	drivers/media/video/blackfin/Kconfig \
+	drivers/media/video/omap/Kconfig \
+	drivers/media/video/davinci/Kconfig \
+	drivers/media/video/marvell-ccic/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/cx25821/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/tm6000/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/tlg2300/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/m5mols/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/platform/msm/camera_v2/Kconfig \
+	drivers/media/platform/msm/camera_v1/Kconfig \
+	drivers/media/platform/msm/Kconfig \
+	drivers/media/platform/Kconfig \
+	drivers/media/rc/keymaps/Kconfig \
+	drivers/media/rc/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/bcma/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/pmbus/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/pinctrl/Kconfig \
+	drivers/ptp/Kconfig \
+	drivers/pps/generators/Kconfig \
+	drivers/pps/clients/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/hsi/clients/Kconfig \
+	drivers/hsi/Kconfig \
+	drivers/slimbus/Kconfig \
+	drivers/spmi/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/tty/hvc/Kconfig \
+	drivers/char/diag/Kconfig \
+	drivers/tty/serial/8250/Kconfig \
+	drivers/tty/serial/Kconfig \
+	drivers/tty/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/net/hyperv/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/mwifiex/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/wl1251/Kconfig \
+	drivers/net/wireless/rtlwifi/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlegacy/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/brcm80211/Kconfig \
+	drivers/net/wireless/bcmdhd/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/ath6kl/Kconfig \
+	drivers/net/wireless/ath/carl9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/rtl818x/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/net/slip/Kconfig \
+	drivers/net/ppp/Kconfig \
+	drivers/net/plip/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/hippi/Kconfig \
+	drivers/net/fddi/Kconfig \
+	drivers/net/ethernet/xircom/Kconfig \
+	drivers/net/ethernet/xilinx/Kconfig \
+	drivers/net/ethernet/via/Kconfig \
+	drivers/net/ethernet/tundra/Kconfig \
+	drivers/net/ethernet/toshiba/Kconfig \
+	drivers/net/ethernet/tile/Kconfig \
+	drivers/net/ethernet/ti/Kconfig \
+	drivers/net/ethernet/tehuti/Kconfig \
+	drivers/net/ethernet/sun/Kconfig \
+	drivers/net/ethernet/stmicro/stmmac/Kconfig \
+	drivers/net/ethernet/stmicro/Kconfig \
+	drivers/net/ethernet/smsc/Kconfig \
+	drivers/net/ethernet/sgi/Kconfig \
+	drivers/net/ethernet/sfc/Kconfig \
+	drivers/net/ethernet/sis/Kconfig \
+	drivers/net/ethernet/silan/Kconfig \
+	drivers/net/ethernet/seeq/Kconfig \
+	drivers/net/ethernet/rdc/Kconfig \
+	drivers/net/ethernet/renesas/Kconfig \
+	drivers/net/ethernet/realtek/Kconfig \
+	drivers/net/ethernet/racal/Kconfig \
+	drivers/net/ethernet/qlogic/Kconfig \
+	drivers/net/ethernet/pasemi/Kconfig \
+	drivers/net/ethernet/packetengines/Kconfig \
+	drivers/net/ethernet/oki-semi/pch_gbe/Kconfig \
+	drivers/net/ethernet/oki-semi/Kconfig \
+	drivers/net/ethernet/octeon/Kconfig \
+	drivers/net/ethernet/nxp/Kconfig \
+	drivers/net/ethernet/nvidia/Kconfig \
+	drivers/net/ethernet/nuvoton/Kconfig \
+	drivers/net/ethernet/8390/Kconfig \
+	drivers/net/ethernet/natsemi/Kconfig \
+	drivers/net/ethernet/myricom/Kconfig \
+	drivers/net/ethernet/msm/Kconfig \
+	drivers/net/ethernet/microchip/Kconfig \
+	drivers/net/ethernet/micrel/Kconfig \
+	drivers/net/ethernet/mellanox/mlx4/Kconfig \
+	drivers/net/ethernet/mellanox/Kconfig \
+	drivers/net/ethernet/marvell/Kconfig \
+	drivers/net/ethernet/icplus/Kconfig \
+	drivers/net/ethernet/xscale/ixp2000/Kconfig \
+	drivers/net/ethernet/xscale/Kconfig \
+	drivers/net/ethernet/i825xx/Kconfig \
+	drivers/net/ethernet/intel/Kconfig \
+	drivers/net/ethernet/ibm/emac/Kconfig \
+	drivers/net/ethernet/ibm/Kconfig \
+	drivers/net/ethernet/hp/Kconfig \
+	drivers/net/ethernet/fujitsu/Kconfig \
+	drivers/net/ethernet/freescale/fs_enet/Kconfig \
+	drivers/net/ethernet/freescale/Kconfig \
+	drivers/net/ethernet/faraday/Kconfig \
+	drivers/net/ethernet/neterion/Kconfig \
+	drivers/net/ethernet/emulex/benet/Kconfig \
+	drivers/net/ethernet/emulex/Kconfig \
+	drivers/net/ethernet/dlink/Kconfig \
+	drivers/net/ethernet/dec/tulip/Kconfig \
+	drivers/net/ethernet/dec/Kconfig \
+	drivers/net/ethernet/davicom/Kconfig \
+	drivers/net/ethernet/cisco/enic/Kconfig \
+	drivers/net/ethernet/cisco/Kconfig \
+	drivers/net/ethernet/cirrus/Kconfig \
+	drivers/net/ethernet/chelsio/Kconfig \
+	drivers/net/ethernet/calxeda/Kconfig \
+	drivers/net/ethernet/brocade/bna/Kconfig \
+	drivers/net/ethernet/brocade/Kconfig \
+	drivers/net/ethernet/broadcom/Kconfig \
+	drivers/net/ethernet/adi/Kconfig \
+	drivers/net/ethernet/cadence/Kconfig \
+	drivers/net/ethernet/atheros/Kconfig \
+	drivers/net/ethernet/apple/Kconfig \
+	drivers/net/ethernet/amd/Kconfig \
+	drivers/net/ethernet/alteon/Kconfig \
+	drivers/net/ethernet/aeroflex/Kconfig \
+	drivers/net/ethernet/adaptec/Kconfig \
+	drivers/net/ethernet/3com/Kconfig \
+	drivers/net/ethernet/Kconfig \
+	drivers/net/dsa/Kconfig \
+	drivers/net/caif/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/team/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/target/iscsi/Kconfig \
+	drivers/target/tcm_fc/Kconfig \
+	drivers/target/loopback/Kconfig \
+	drivers/target/Kconfig \
+	drivers/md/persistent-data/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/ufs/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2fc/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgbi/cxgb4i/Kconfig \
+	drivers/scsi/cxgbi/cxgb3i/Kconfig \
+	drivers/scsi/cxgbi/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/slimport_anx7808/Kconfig \
+	drivers/misc/altera-stapl/Kconfig \
+	drivers/misc/carma/Kconfig \
+	drivers/misc/lis3lv02d/Kconfig \
+	drivers/misc/ti-st/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/mtip32xx/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/regmap/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	drivers/nfc/Kconfig \
+	net/nfc/llcp/Kconfig \
+	net/nfc/nci/Kconfig \
+	net/nfc/Kconfig \
+	net/ceph/Kconfig \
+	net/caif/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/softing/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/cc770/Kconfig \
+	drivers/net/can/c_can/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/openvswitch/Kconfig \
+	net/batman-adv/Kconfig \
+	net/dns_resolver/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/l2tp/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/ipset/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig.powerpc \
+	drivers/cpufreq/Kconfig.arm \
+	drivers/cpufreq/Kconfig.x86 \
+	drivers/cpufreq/Kconfig \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	kernel/time/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	arch/arm/mach-w90x900/Kconfig \
+	arch/arm/mach-vt8500/Kconfig \
+	arch/arm/plat-versatile/Kconfig \
+	arch/arm/mach-vexpress/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-ux500/Kconfig \
+	arch/arm/mach-u300/Kconfig \
+	arch/arm/mach-tegra/Kconfig \
+	drivers/sh/intc/Kconfig \
+	drivers/sh/Kconfig \
+	arch/arm/mach-shmobile/Kconfig \
+	arch/arm/mach-exynos/Kconfig \
+	arch/arm/mach-s5pv210/Kconfig \
+	arch/arm/mach-s5pc100/Kconfig \
+	arch/arm/mach-s5p64x0/Kconfig \
+	arch/arm/mach-s3c64xx/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c24xx/Kconfig \
+	arch/arm/mach-spear6xx/Kconfig \
+	arch/arm/mach-spear3xx/Kconfig \
+	arch/arm/plat-spear/Kconfig \
+	arch/arm/plat-s5p/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/plat-samsung/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-mmp/Kconfig \
+	arch/arm/plat-pxa/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/plat-nomadik/Kconfig \
+	arch/arm/mach-nomadik/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-mxs/devices/Kconfig \
+	arch/arm/mach-mxs/Kconfig \
+	arch/arm/mach-imx/Kconfig \
+	arch/arm/plat-mxc/devices/Kconfig \
+	arch/arm/plat-mxc/Kconfig \
+	arch/arm/mach-mv78xx0/Kconfig \
+	arch/arm/mach-msm/asustek/flo/Kconfig \
+	arch/arm/mach-msm/asustek/Kconfig.board \
+	arch/arm/mach-msm/asustek/Kconfig \
+	arch/arm/mach-msm/lge/mako/Kconfig \
+	arch/arm/mach-msm/lge/Kconfig.board \
+	arch/arm/mach-msm/lge/Kconfig \
+	arch/arm/mach-msm/Kconfig \
+	arch/arm/mach-lpc32xx/Kconfig \
+	arch/arm/mach-ks8695/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-gemini/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-dove/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-cns3xxx/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	arch/arm/mach-bcmring/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/partitions/Kconfig \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	kernel/irq/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "3.4.0"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(SRCARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -urN flo-ElementalX-5.00/include/config/kernel.release flo-ElementalX-5.00-patched/include/config/kernel.release
--- flo-ElementalX-5.00/include/config/kernel.release	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/kernel.release	2016-06-03 17:55:19.000000000 +0000
@@ -0,0 +1 @@
+3.4.0-flo
diff -urN flo-ElementalX-5.00/include/config/tristate.conf flo-ElementalX-5.00-patched/include/config/tristate.conf
--- flo-ElementalX-5.00/include/config/tristate.conf	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/tristate.conf	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,572 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_NF_CONNTRACK_H323=Y
+CONFIG_MSM_VIDC_VENC=Y
+CONFIG_IP_NF_TARGET_REDIRECT=Y
+CONFIG_CRC32=Y
+CONFIG_NF_NAT_PROTO_SCTP=Y
+CONFIG_IR_JVC_DECODER=Y
+CONFIG_IR_MCE_KBD_DECODER=Y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=Y
+CONFIG_BLK_DEV_DM=Y
+CONFIG_MSM_RPM_LOG=Y
+CONFIG_BT_RFCOMM=Y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=Y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=Y
+CONFIG_CRYPTO_MD4=Y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=Y
+CONFIG_PPP_SYNC_TTY=Y
+CONFIG_RC_CORE=Y
+CONFIG_BATTERY_ASUS_BQ27541=Y
+CONFIG_HID_SPEEDLINK=Y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=Y
+CONFIG_TCP_CONG_HTCP=Y
+CONFIG_BINFMT_MISC=Y
+CONFIG_MSM_BT_POWER=Y
+CONFIG_NETFILTER_XT_MATCH_HELPER=Y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=Y
+CONFIG_UHID=Y
+CONFIG_INET6_TUNNEL=Y
+CONFIG_HID_PRODIKEYS=Y
+CONFIG_VIDEOBUF2_MSM_MEM=Y
+CONFIG_USB_HSIC_SMSC_HUB=Y
+CONFIG_HID_EMS_FF=Y
+CONFIG_IP6_NF_MANGLE=Y
+CONFIG_IPV6=Y
+CONFIG_CRYPTO_AEAD=Y
+CONFIG_NET_CLS_FLOW=Y
+CONFIG_USB_STORAGE_USBAT=Y
+CONFIG_NF_NAT_PROTO_GRE=Y
+CONFIG_IP6_NF_TARGET_REJECT=Y
+CONFIG_IR_NEC_DECODER=Y
+CONFIG_SENSORS_CAP1106=Y
+CONFIG_SMUX_CTL=Y
+CONFIG_XFRM_IPCOMP=Y
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_NETFILTER_NETLINK_QUEUE=Y
+CONFIG_TUN=Y
+CONFIG_CFG80211=Y
+CONFIG_DM_CRYPT=Y
+CONFIG_LZO_DECOMPRESS=Y
+CONFIG_HID_BELKIN=Y
+CONFIG_VIDEO_IR_I2C=Y
+CONFIG_USB_SERIAL_OPTION=Y
+CONFIG_HID_ACRUX=Y
+CONFIG_USB=Y
+CONFIG_CRYPTO_HMAC=Y
+CONFIG_FRAMEBUFFER_CONSOLE=M
+CONFIG_TCP_CONG_LP=Y
+CONFIG_IP_NF_ARPTABLES=Y
+CONFIG_HID_CHERRY=Y
+CONFIG_HID_SUNPLUS=Y
+CONFIG_HID_PICOLCD=Y
+CONFIG_SND_SOC=Y
+CONFIG_MEDIA_TUNER_XC5000=Y
+CONFIG_FB_SYS_FILLRECT=Y
+CONFIG_HID_THRUSTMASTER=Y
+CONFIG_DNS_RESOLVER=Y
+CONFIG_CRYPTO_AUTHENC=Y
+CONFIG_IRDA=Y
+CONFIG_HID_PRIMAX=Y
+CONFIG_DECOMPRESS_LZMA=Y
+CONFIG_CRYPTO_CTS=Y
+CONFIG_INPUT_MOUSEDEV=Y
+CONFIG_SND_SOC_CS8427=Y
+CONFIG_CRYPTO_DES=Y
+CONFIG_NLS_CODEPAGE_437=Y
+CONFIG_NET_CLS_U32=Y
+CONFIG_EXPORTFS=Y
+CONFIG_SERIO=Y
+CONFIG_FB_SYS_IMAGEBLIT=Y
+CONFIG_SUNRPC_GSS=Y
+CONFIG_MA600_DONGLE=Y
+CONFIG_NET_EMATCH_U32=Y
+CONFIG_I2C_QUP=Y
+CONFIG_MFD_PM8XXX=Y
+CONFIG_NF_CONNTRACK_SANE=Y
+CONFIG_NF_CT_PROTO_DCCP=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_ENCRYPTED_KEYS=Y
+CONFIG_HWMON=Y
+CONFIG_CRYPTO_TWOFISH_COMMON=Y
+CONFIG_STM_LIS3DH=Y
+CONFIG_USB_VIDEO_CLASS=Y
+CONFIG_MSM_LPASS_8960=Y
+CONFIG_USB_EHSET_TEST_FIXTURE=Y
+CONFIG_SLIMPORT_ANX7808=Y
+CONFIG_LOCKD=Y
+CONFIG_GPIO_PM8XXX=Y
+CONFIG_ANDROID_TIMED_GPIO=Y
+CONFIG_HID_SAITEK=Y
+CONFIG_RPCSEC_GSS_KRB5=Y
+CONFIG_NETFILTER_XT_MATCH_STRING=Y
+CONFIG_USB_STORAGE=Y
+CONFIG_SPI_QUP=Y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=Y
+CONFIG_IR_LIRC_CODEC=Y
+CONFIG_SND_USB_AUDIO=Y
+CONFIG_TCP_CONG_YEAH=Y
+CONFIG_HID_APPLE=Y
+CONFIG_MEDIA_TUNER_TDA827X=Y
+CONFIG_IP_NF_ARP_MANGLE=Y
+CONFIG_EXFAT_FS=Y
+CONFIG_INPUT_MPU3050=Y
+CONFIG_ASUSTEK_HEADSET=Y
+CONFIG_NF_CONNTRACK_PPTP=Y
+CONFIG_NET_EMATCH_META=Y
+CONFIG_NF_CONNTRACK_IRC=Y
+CONFIG_SWITCH=Y
+CONFIG_PPP_DEFLATE=Y
+CONFIG_TEXTSEARCH_KMP=Y
+CONFIG_USB_NET_NET1080=Y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=Y
+CONFIG_HID_TIVO=Y
+CONFIG_REGMAP_SPI=Y
+CONFIG_MFD_PM8038_CORE=Y
+CONFIG_MSM_PIL_TZAPPS=Y
+CONFIG_POWER_SUPPLY=Y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=Y
+CONFIG_NLS=Y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=Y
+CONFIG_HID_MAGICMOUSE=Y
+CONFIG_SENSORS_PM8XXX_ADC=Y
+CONFIG_PPPOE=Y
+CONFIG_FB_SYS_COPYAREA=Y
+CONFIG_USB_STORAGE_ALAUDA=Y
+CONFIG_USB_COMMON=Y
+CONFIG_MEDIA_TUNER_TDA18271=Y
+CONFIG_IP6_NF_IPTABLES=Y
+CONFIG_LZ4_COMPRESS=Y
+CONFIG_CPU_FREQ_GOV_USERSPACE=Y
+CONFIG_INET_IPCOMP=Y
+CONFIG_HID_KEYTOUCH=Y
+CONFIG_HID_CYPRESS=Y
+CONFIG_NLS_ISO8859_1=Y
+CONFIG_CRYPTO_WORKQUEUE=Y
+CONFIG_TCP_CONG_HYBLA=Y
+CONFIG_HID_KENSINGTON=Y
+CONFIG_BACKLIGHT_GENERIC=Y
+CONFIG_USB_EHCI_HCD=Y
+CONFIG_CPU_FREQ_TABLE=Y
+CONFIG_TEXTSEARCH_BM=Y
+CONFIG_HID_ZYDACRON=Y
+CONFIG_PPP_MPPE=Y
+CONFIG_USB_IRDA=Y
+CONFIG_RFKILL=Y
+CONFIG_NET_KEY=Y
+CONFIG_IOSCHED_DEADLINE=Y
+CONFIG_IPV6_SIT=Y
+CONFIG_CRYPTO_SHA1_ARM=Y
+CONFIG_IP_NF_TARGET_MASQUERADE=Y
+CONFIG_NF_CONNTRACK_BROADCAST=Y
+CONFIG_CRYPTO_LZ4=Y
+CONFIG_IR_RC5_SZ_DECODER=Y
+CONFIG_NF_NAT_PROTO_DCCP=Y
+CONFIG_SCSI_WAIT_SCAN=M
+CONFIG_BACKLIGHT_CLASS_DEVICE=Y
+CONFIG_NF_DEFRAG_IPV4=Y
+CONFIG_INET_XFRM_MODE_BEET=Y
+CONFIG_HID_LCPOWER=Y
+CONFIG_CRYPTO_DEFLATE=Y
+CONFIG_BT_HCISMD=Y
+CONFIG_NETFILTER_NETLINK_LOG=Y
+CONFIG_INPUT_LID=Y
+CONFIG_NETFILTER_XT_MATCH_MARK=Y
+CONFIG_MSM_PIL_VIDC=Y
+CONFIG_MSM_DMA_TEST=Y
+CONFIG_IP_NF_MANGLE=Y
+CONFIG_INET6_XFRM_MODE_TUNNEL=Y
+CONFIG_MEDIA_SUPPORT=Y
+CONFIG_IP_NF_FILTER=Y
+CONFIG_HID_ZEROPLUS=Y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=Y
+CONFIG_FAT_FS=Y
+CONFIG_WCD9304_CODEC=Y
+CONFIG_TEXTSEARCH_FSM=Y
+CONFIG_IP6_NF_RAW=Y
+CONFIG_INET_TUNNEL=Y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=Y
+CONFIG_EEPROM_93CX6=Y
+CONFIG_IOSCHED_CFQ=Y
+CONFIG_LIB80211=Y
+CONFIG_MFD_CORE=Y
+CONFIG_REGULATOR_MSM_GPIO=Y
+CONFIG_SND_SOC_QDSP6=Y
+CONFIG_USB_GSPCA=Y
+CONFIG_NLS_ASCII=Y
+CONFIG_USB_NET_CDC_SUBSET=Y
+CONFIG_FB_MSM=Y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=Y
+CONFIG_BLK_CGROUP=Y
+CONFIG_CRYPTO_RNG=Y
+CONFIG_VIDEOBUF2_MEMOPS=Y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=Y
+CONFIG_HID_ROCCAT=Y
+CONFIG_INET_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_MD5=Y
+CONFIG_MEDIA_TUNER_TEA5767=Y
+CONFIG_N_SMUX=Y
+CONFIG_INET6_AH=Y
+CONFIG_USB_SERIAL=Y
+CONFIG_INET_XFRM_TUNNEL=Y
+CONFIG_NETFILTER_XT_MARK=Y
+CONFIG_NETFILTER_XTABLES=Y
+CONFIG_USB_STORAGE_DATAFAB=Y
+CONFIG_TCP_CONG_VEGAS=Y
+CONFIG_ION=Y
+CONFIG_USB_STORAGE_KARMA=Y
+CONFIG_HID_GREENASIA=Y
+CONFIG_HID_GYRATION=Y
+CONFIG_USB_WDM=Y
+CONFIG_INPUT_JOYDEV=Y
+CONFIG_THERMAL_TSENS8960=Y
+CONFIG_USB_ACM=Y
+CONFIG_CRC16=Y
+CONFIG_USB_NET_AX8817X=Y
+CONFIG_CRYPTO_GF128MUL=Y
+CONFIG_REGMAP_I2C=Y
+CONFIG_USB_HID=Y
+CONFIG_IOSCHED_SIO=Y
+CONFIG_SND_SOC_WCD9310=Y
+CONFIG_IOSCHED_ROW=Y
+CONFIG_SMC911X=Y
+CONFIG_CRYPTO_PCOMP2=Y
+CONFIG_SMSC911X=Y
+CONFIG_GPIO_MSM_V2=Y
+CONFIG_KEYBOARD_GPIO=Y
+CONFIG_NF_CONNTRACK_FTP=Y
+CONFIG_IP_NF_MATCH_ECN=Y
+CONFIG_USB_GADGET=Y
+CONFIG_SOUND=Y
+CONFIG_MEDIA_TUNER_TDA9887=Y
+CONFIG_UNIX=Y
+CONFIG_CRYPTO_HASH2=Y
+CONFIG_CRYPTO_LZ4HC=Y
+CONFIG_USB_STORAGE_ISD200=Y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=Y
+CONFIG_NFS_FS=Y
+CONFIG_INET_ESP=Y
+CONFIG_LZ4_DECOMPRESS=Y
+CONFIG_NF_CONNTRACK_IPV6=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_MEDIA_TUNER=Y
+CONFIG_INPUT_UINPUT=Y
+CONFIG_MEDIA_TUNER_SIMPLE=Y
+CONFIG_KEYBOARD_ATKBD=Y
+CONFIG_NF_NAT=Y
+CONFIG_ION_MSM=Y
+CONFIG_MSM_ADSP_LOADER=Y
+CONFIG_CHR_DEV_SCH=Y
+CONFIG_CRYPTO_HASH=Y
+CONFIG_VFAT_FS=Y
+CONFIG_MSM_KGSL_2D=Y
+CONFIG_MSM_ADSPRPC=Y
+CONFIG_SND_HWDEP=Y
+CONFIG_BLK_DEV_LOOP=Y
+CONFIG_MFD_PM8XXX_SPK=Y
+CONFIG_NF_NAT_IRC=Y
+CONFIG_MEDIA_TUNER_XC2028=Y
+CONFIG_SND_COMPRESS_OFFLOAD=Y
+CONFIG_CRYPTO_CBC=Y
+CONFIG_FS_MBCACHE=Y
+CONFIG_MSM_VIDC_VDEC=Y
+CONFIG_NF_NAT_TFTP=Y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=Y
+CONFIG_TCP_CONG_ILLINOIS=Y
+CONFIG_CRYPTO_MANAGER2=Y
+CONFIG_NETFILTER_XT_TARGET_LOG=Y
+CONFIG_SLIP=Y
+CONFIG_I2C=Y
+CONFIG_BT_HIDP=Y
+CONFIG_MFD_PM8XXX_MISC=Y
+CONFIG_CRYPTO_ECB=Y
+CONFIG_NF_CONNTRACK_AMANDA=Y
+CONFIG_FB_CFB_IMAGEBLIT=Y
+CONFIG_ZLIB_DEFLATE=Y
+CONFIG_SUNRPC=Y
+CONFIG_MFD_PM8XXX_PWM=Y
+CONFIG_QSEECOM=Y
+CONFIG_FW_LOADER=Y
+CONFIG_CRYPTO_XTS=Y
+CONFIG_DECOMPRESS_XZ=Y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=Y
+CONFIG_MII=Y
+CONFIG_EXT4_FS=Y
+CONFIG_WCNSS_CORE=M
+CONFIG_CRYPTO_SHA1=Y
+CONFIG_XZ_DEC=Y
+CONFIG_DUMMY=Y
+CONFIG_SND_RAWMIDI=Y
+CONFIG_PPPOPNS=Y
+CONFIG_UID_CPUTIME=Y
+CONFIG_USB_STORAGE_SDDR09=Y
+CONFIG_IP_NF_MATCH_TTL=Y
+CONFIG_MSM_RESET_MODEM=Y
+CONFIG_IOSCHED_TEST=Y
+CONFIG_NET_SCH_PRIO=Y
+CONFIG_SND_PCM=Y
+CONFIG_IR_SONY_DECODER=Y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=Y
+CONFIG_LEDS_PM8XXX=Y
+CONFIG_INPUT_EVDEV=Y
+CONFIG_USB_QCOM_DIAG_BRIDGE=Y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=Y
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=Y
+CONFIG_NETFILTER_XT_MATCH_DSCP=Y
+CONFIG_HID_DRAGONRISE=Y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=Y
+CONFIG_USB_NET_CDCETHER=Y
+CONFIG_PACKET=Y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=Y
+CONFIG_NF_CONNTRACK_TFTP=Y
+CONFIG_CRYPTO_TWOFISH=Y
+CONFIG_BT=Y
+CONFIG_REED_SOLOMON=Y
+CONFIG_PMIC8XXX_VIBRATOR=Y
+CONFIG_LZ4HC_COMPRESS=Y
+CONFIG_CP_ACCESS=Y
+CONFIG_HID_WACOM=Y
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=Y
+CONFIG_MSM_WCNSS_SSR_8960=M
+CONFIG_NETFILTER_XT_MATCH_POLICY=Y
+CONFIG_CRYPTO_AES=Y
+CONFIG_USER_RC_INPUT=Y
+CONFIG_UIO=Y
+CONFIG_HID_WALTOP=Y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=Y
+CONFIG_SERIO_SERPORT=Y
+CONFIG_LIRC=Y
+CONFIG_BT_BNEP=Y
+CONFIG_SERIAL_MSM_HS=Y
+CONFIG_INET_XFRM_MODE_TUNNEL=Y
+CONFIG_LCD_KCAL=Y
+CONFIG_CPU_FREQ_STAT=Y
+CONFIG_USB_MSM_OTG=Y
+CONFIG_INET6_ESP=Y
+CONFIG_AUTOFS4_FS=Y
+CONFIG_MMC_MSM=Y
+CONFIG_SLIMBUS_MSM_CTRL=Y
+CONFIG_IP6_NF_FILTER=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=Y
+CONFIG_SMC91X=Y
+CONFIG_HID_TWINHAN=Y
+CONFIG_NETFILTER_XT_MATCH_ECN=Y
+CONFIG_USB_STORAGE_SDDR55=Y
+CONFIG_DECOMPRESS_LZ4=Y
+CONFIG_MSM_PIL_QDSP6V4=Y
+CONFIG_NETFILTER_XT_MATCH_TIME=Y
+CONFIG_NETFILTER_XT_MATCH_MAC=Y
+CONFIG_PRIMA_WLAN=M
+CONFIG_NETFILTER_XT_TARGET_NFLOG=Y
+CONFIG_L2TP=Y
+CONFIG_TCP_CONG_WESTWOOD=Y
+CONFIG_LIBCRC32C=Y
+CONFIG_GPIO_PM8XXX_MPP=Y
+CONFIG_KEYBOARD_MATRIX=Y
+CONFIG_CRYPTO_SHA256=Y
+CONFIG_INET_TCP_DIAG=Y
+CONFIG_HID_SONY=Y
+CONFIG_HID_MONTEREY=Y
+CONFIG_HID_EZKEY=Y
+CONFIG_MSM_VCAP=Y
+CONFIG_RADIO_IRIS=Y
+CONFIG_CRYPTO=Y
+CONFIG_IP_NF_IPTABLES=Y
+CONFIG_FB_VIRTUAL=Y
+CONFIG_VIDEOBUF2_DMA_CONTIG=Y
+CONFIG_HID_SAMSUNG=Y
+CONFIG_TCP_CONG_HSTCP=Y
+CONFIG_SCSI_MOD=Y
+CONFIG_VIDEOBUF2_DMA_SG=Y
+CONFIG_CRYPTO_CRC32C=Y
+CONFIG_SERIAL_CORE=Y
+CONFIG_FUSE_FS=Y
+CONFIG_HID_MICROSOFT=Y
+CONFIG_MFD_PM8XXX_BATT_ALARM=Y
+CONFIG_NF_DEFRAG_IPV6=Y
+CONFIG_VIDEO_DEV=Y
+CONFIG_NF_CT_PROTO_SCTP=Y
+CONFIG_SCSI=Y
+CONFIG_FB_CFB_FILLRECT=Y
+CONFIG_NF_NAT_PPTP=Y
+CONFIG_HID_CHICONY=Y
+CONFIG_HID=Y
+CONFIG_MEDIA_TUNER_TDA8290=Y
+CONFIG_JBD2=Y
+CONFIG_INET6_IPCOMP=Y
+CONFIG_PHYLIB=Y
+CONFIG_MEDIA_TUNER_MT20XX=Y
+CONFIG_DIAG_CHAR=Y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=Y
+CONFIG_IP_NF_SECURITY=Y
+CONFIG_IP_NF_RAW=Y
+CONFIG_IP_NF_ARPFILTER=Y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=Y
+CONFIG_PPPOL2TP=Y
+CONFIG_HID_TOPSEED=Y
+CONFIG_DECOMPRESS_BZIP2=Y
+CONFIG_NF_NAT_H323=Y
+CONFIG_HID_A4TECH=Y
+CONFIG_MEDIA_TUNER_MC44S803=Y
+CONFIG_IP_NF_TARGET_NETMAP=Y
+CONFIG_INPUT_FF_MEMLESS=Y
+CONFIG_CHR_DEV_SG=Y
+CONFIG_NF_NAT_AMANDA=Y
+CONFIG_IR_GPIO_CIR=Y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_ARC4=Y
+CONFIG_RTC_DRV_PM8XXX=Y
+CONFIG_USB_CI13XXX_MSM=Y
+CONFIG_SLHC=Y
+CONFIG_SCSI_TGT=Y
+CONFIG_CRYPTO_MANAGER=Y
+CONFIG_NET_SCH_HTB=Y
+CONFIG_PPP_BSDCOMP=Y
+CONFIG_HID_ORTEK=Y
+CONFIG_NETFILTER_XT_TARGET_MARK=Y
+CONFIG_REGULATOR_PM8XXX=Y
+CONFIG_I2C_ALGOBIT=Y
+CONFIG_MMC_BLOCK=Y
+CONFIG_NET_CLS_FW=Y
+CONFIG_IR_SANYO_DECODER=Y
+CONFIG_USB_NET_CDC_NCM=Y
+CONFIG_SND_SOC_WCD9304=Y
+CONFIG_MMC=Y
+CONFIG_LZO_COMPRESS=Y
+CONFIG_CRYPTO_SEQIV=Y
+CONFIG_HID_LOGITECH=Y
+CONFIG_PPPOLAC=Y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=Y
+CONFIG_MSM_PIL_DSPS=Y
+CONFIG_NETFILTER_XT_MATCH_U32=Y
+CONFIG_QCACHE=Y
+CONFIG_INET_AH=Y
+CONFIG_IPV6_MIP6=Y
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_NETFILTER_XT_CONNMARK=Y
+CONFIG_HID_KYE=Y
+CONFIG_IP_NF_MATCH_AH=Y
+CONFIG_TCP_CONG_VENO=Y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=Y
+CONFIG_N_SMUX_LOOPBACK=Y
+CONFIG_FB_SYS_FOPS=Y
+CONFIG_MEDIA_TUNER_XC4000=Y
+CONFIG_FB=Y
+CONFIG_MSM_BUSPM_DEV=Y
+CONFIG_BT_HCIUART=Y
+CONFIG_THERMAL=Y
+CONFIG_HID_PETALYNX=Y
+CONFIG_NF_CONNTRACK_IPV4=Y
+CONFIG_MSM_KGSL=Y
+CONFIG_SERIAL_MSM_HSL=Y
+CONFIG_USB_NET_ZAURUS=Y
+CONFIG_INET6_XFRM_TUNNEL=Y
+CONFIG_WCD9310_CODEC=Y
+CONFIG_MSM_RPM_STATS_LOG=Y
+CONFIG_NET_EMATCH_NBYTE=Y
+CONFIG_VIDEO_MEDIA=Y
+CONFIG_INPUT_KEYCHORD=Y
+CONFIG_MFD_PM8921_CORE=Y
+CONFIG_HID_LOGITECH_DJ=Y
+CONFIG_NF_NAT_PROTO_UDPLITE=Y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=Y
+CONFIG_CRYPTO_CTR=Y
+CONFIG_MSM_PIL_GSS=Y
+CONFIG_HW_RANDOM=Y
+CONFIG_USB_SERIAL_CSVT=Y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=Y
+CONFIG_VIDEOBUF2_CORE=Y
+CONFIG_THERMAL_PM8XXX=Y
+CONFIG_IRTTY_SIR=Y
+CONFIG_CPUPOWER=Y
+CONFIG_CRYPTO_BLKCIPHER2=Y
+CONFIG_VIDEOBUF2_VMALLOC=Y
+CONFIG_RC_MAP=Y
+CONFIG_SND_SOC_MSM8960=Y
+CONFIG_HID_PANTHERLORD=Y
+CONFIG_SND=Y
+CONFIG_IR_RC6_DECODER=Y
+CONFIG_MSM_TZ_LOG=Y
+CONFIG_SND_SOC_MSM_STUB=Y
+CONFIG_IKCONFIG=Y
+CONFIG_HW_RANDOM_MSM=Y
+CONFIG_CIFS=Y
+CONFIG_XFRM_USER=Y
+CONFIG_TCP_CONG_BIC=Y
+CONFIG_MSM_HSIC_SYSMON=Y
+CONFIG_SOUND_CONTROL_HAX_GPL=Y
+CONFIG_NET_EMATCH_CMP=Y
+CONFIG_PPP_ASYNC=Y
+CONFIG_HID_MULTITOUCH=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=Y
+CONFIG_HID_ELECOM=Y
+CONFIG_SND_TIMER=Y
+CONFIG_MFD_PM8821_CORE=Y
+CONFIG_NFS_ACL_SUPPORT=Y
+CONFIG_TCP_CONG_SCALABLE=Y
+CONFIG_SENSORS_EPM_ADC=Y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=Y
+CONFIG_CRYPTO_ANSI_CPRNG=Y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=Y
+CONFIG_PPP=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=Y
+CONFIG_INET_DIAG=Y
+CONFIG_NF_NAT_FTP=Y
+CONFIG_NF_CT_PROTO_UDPLITE=Y
+CONFIG_USB_QCOM_MDM_BRIDGE=Y
+CONFIG_HID_UCLOGIC=Y
+CONFIG_MSM_RMNET_USB=Y
+CONFIG_USB_QCOM_KS_BRIDGE=Y
+CONFIG_BLK_DEV_RAM=Y
+CONFIG_NETFILTER_XT_MATCH_STATE=Y
+CONFIG_USB_STORAGE_FREECOM=Y
+CONFIG_IR_RC5_DECODER=Y
+CONFIG_DRM=Y
+CONFIG_INET6_XFRM_MODE_BEET=Y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=Y
+CONFIG_FB_CFB_COPYAREA=Y
+CONFIG_USB_STORAGE_JUMPSHOT=Y
+CONFIG_VIDEO_V4L2=Y
+CONFIG_HID_NTRIG=Y
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_DECOMPRESS_LZO=Y
+CONFIG_I2C_CHARDEV=Y
+CONFIG_MEDIA_TUNER_TEA5761=Y
+CONFIG_HID_HOLTEK=Y
+CONFIG_CRYPTO_AES_ARM=Y
+CONFIG_MSM_PIL_RIVA=Y
+CONFIG_NLS_UTF8=Y
+CONFIG_JOYSTICK_XPAD=Y
+CONFIG_NETFILTER_TPROXY=Y
+CONFIG_USB_USBNET=Y
+CONFIG_HID_SMARTJOYPLUS=Y
+CONFIG_CRC_CCITT=Y
+CONFIG_BLK_DEV_SD=Y
+CONFIG_NETFILTER_NETLINK=Y
+CONFIG_WAKE_TIMEOUT=Y
+CONFIG_CHARGER_SMB345=Y
+CONFIG_BITREVERSE=Y
+CONFIG_MSM_ROTATOR=Y
+CONFIG_USB_SERIAL_WWAN=Y
+CONFIG_VIDEO_V4L2_COMMON=Y
+CONFIG_CRYPTO_BLKCIPHER=Y
+CONFIG_MFD_PM8XXX_DEBUG=Y
+CONFIG_USB_STORAGE_ONETOUCH=Y
+CONFIG_NF_CONNTRACK=Y
+CONFIG_IOSCHED_FIOPS=Y
+CONFIG_LCD_CLASS_DEVICE=Y
+CONFIG_SND_SOC_I2C_AND_SPI=Y
+CONFIG_IP_NF_TARGET_REJECT=Y
+CONFIG_LEDS_CLASS=Y
+CONFIG_NF_CT_PROTO_GRE=Y
+CONFIG_NF_CT_NETLINK=Y
+CONFIG_NET_EMATCH_TEXT=Y
+CONFIG_CRYPTO_AEAD2=Y
+CONFIG_MOUSE_PS2=Y
+CONFIG_NETFILTER_XT_MATCH_HL=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_INPUT=Y
+CONFIG_USB_SIERRA_NET=Y
diff -urN flo-ElementalX-5.00/include/generated/asm-offsets.h flo-ElementalX-5.00-patched/include/generated/asm-offsets.h
--- flo-ElementalX-5.00/include/generated/asm-offsets.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/asm-offsets.h	2016-06-02 09:34:02.000000000 +0000
@@ -0,0 +1,73 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 280 /* offsetof(struct task_struct, active_mm)	@ */
+#define TSK_STACK_CANARY 344 /* offsetof(struct task_struct, stack_canary)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 80 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 96 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 288 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+#define VFP_CPU 272 /* offsetof(union vfp_state, hard.cpu)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define MM_CONTEXT_ID 348 /* offsetof(struct mm_struct, context.id)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 24 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 72 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 4 /* offsetof(struct machine_desc, name)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#define CACHE_FLUSH_KERN_ALL 4 /* offsetof(struct cpu_cache_fns, flush_kern_all)	@ */
+
+#define DMA_BIDIRECTIONAL 0 /* DMA_BIDIRECTIONAL	@ */
+#define DMA_TO_DEVICE 1 /* DMA_TO_DEVICE	@ */
+#define DMA_FROM_DEVICE 2 /* DMA_FROM_DEVICE	@ */
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/autoconf.h flo-ElementalX-5.00-patched/include/generated/autoconf.h
--- flo-ElementalX-5.00/include/generated/autoconf.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/autoconf.h	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,1371 @@
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * Linux/arm 3.4.0 Kernel Configuration
+ *
+ */
+#define CONFIG_RING_BUFFER 1
+#define CONFIG_NF_CONNTRACK_H323 1
+#define CONFIG_HAVE_ARCH_SECCOMP_FILTER 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_MSM_VIDC_VENC 1
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_RFS_ACCEL 1
+#define CONFIG_IP_NF_TARGET_REDIRECT 1
+#define CONFIG_CRC32 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_NF_NAT_PROTO_SCTP 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_VFP 1
+#define CONFIG_IR_JVC_DECODER 1
+#define CONFIG_AEABI 1
+#define CONFIG_IR_MCE_KBD_DECODER 1
+#define CONFIG_CPU_FREQ_GOV_CONSERVATIVE 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_SECCOMP 1
+#define CONFIG_BLK_DEV_DM 1
+#define CONFIG_MSM_REMOTE_SPINLOCK_SFPB 1
+#define CONFIG_MSM_RPM_LOG 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_MSM_SHOW_RESUME_IRQ 1
+#define CONFIG_MSM_IPC_ROUTER_SECURITY 1
+#define CONFIG_KERNEL_MSM_CONTIG_MEM_REGION 1
+#define CONFIG_BT_RFCOMM 1
+#define CONFIG_LEDS_TRIGGER_HEARTBEAT 1
+#define CONFIG_UACCESS_WITH_MEMCPY 1
+#define CONFIG_XZ_DEC_IA64 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_NF_CONNTRACK_NETBIOS_NS 1
+#define CONFIG_SCSI_LOGGING 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define CONFIG_CRYPTO_MD4 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_CGROUP_DEVICE 1
+#define CONFIG_PPP_SYNC_TTY 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_RC_CORE 1
+#define CONFIG_BATTERY_ASUS_BQ27541 1
+#define CONFIG_HID_SPEEDLINK 1
+#define CONFIG_CPU_FREQ_GOV_ELEMENTALX 1
+#define CONFIG_TCP_CONG_HTCP 1
+#define CONFIG_EXT4_FS_POSIX_ACL 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_MSM_BT_POWER 1
+#define CONFIG_NETFILTER_XT_MATCH_HELPER 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATISTIC 1
+#define CONFIG_MSM_L2_SPM 1
+#define CONFIG_UHID 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_BLK_DEV_LOOP_MIN_COUNT 8
+#define CONFIG_INET6_TUNNEL 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_CRYPTO_MANAGER_DISABLE_TESTS 1
+#define CONFIG_HIDRAW 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_HID_PRODIKEYS 1
+#define CONFIG_VIDEOBUF2_MSM_MEM 1
+#define CONFIG_USB_HSIC_SMSC_HUB 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX 1
+#define CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER 1
+#define CONFIG_DYNAMIC_DEBUG 1
+#define CONFIG_MSM_SMP 1
+#define CONFIG_HAVE_MEMORY_PRESENT 1
+#define CONFIG_USB_EHCI_MSM_HOST4 1
+#define CONFIG_MSM_PM8X60 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_HID_ACRUX_FF 1
+#define CONFIG_RT_GROUP_SCHED 1
+#define CONFIG_HID_EMS_FF 1
+#define CONFIG_KTIME_SCALAR 1
+#define CONFIG_IP6_NF_MANGLE 1
+#define CONFIG_SCSI_CONSTANTS 1
+#define CONFIG_IPV6 1
+#define CONFIG_CRYPTO_AEAD 1
+#define CONFIG_BQL 1
+#define CONFIG_INPUT_MOUSEDEV_PSAUX 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_UEVENT_HELPER_PATH ""
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_DEVTMPFS 1
+#define CONFIG_NET_CLS_FLOW 1
+#define CONFIG_USB_STORAGE_USBAT 1
+#define CONFIG_NF_NAT_PROTO_GRE 1
+#define CONFIG_ANDROID_BINDER_IPC 1
+#define CONFIG_IP6_NF_TARGET_REJECT 1
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_IR_NEC_DECODER 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_WLAN 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
+#define CONFIG_HAVE_ARM_SCU 1
+#define CONFIG_BLK_DEV_BSG 1
+#define CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG 1
+#define CONFIG_SENSORS_CAP1106 1
+#define CONFIG_SMUX_CTL 1
+#define CONFIG_ATAGS_PROC 1
+#define CONFIG_XFRM_IPCOMP 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_NETFILTER_NETLINK_QUEUE 1
+#define CONFIG_TUN 1
+#define CONFIG_USB_OTG_UTILS 1
+#define CONFIG_CFG80211 1
+#define CONFIG_TREE_PREEMPT_RCU 1
+#define CONFIG_DM_CRYPT 1
+#define CONFIG_REED_SOLOMON_ENC8 1
+#define CONFIG_HAVE_PROC_CPU 1
+#define CONFIG_LZO_DECOMPRESS 1
+#define CONFIG_USB_EHCI_ROOT_HUB_TT 1
+#define CONFIG_IOMMU_SUPPORT 1
+#define CONFIG_HID_BELKIN 1
+#define CONFIG_VIDEO_IR_I2C 1
+#define CONFIG_MSM_XO 1
+#define CONFIG_FB_MSM_OVERLAY1_WRITEBACK 1
+#define CONFIG_USB_SERIAL_OPTION 1
+#define CONFIG_HID_ACRUX 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_USB 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_ETHERNET 1
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define CONFIG_SCSI_SCAN_ASYNC 1
+#define CONFIG_HAVE_DMA_CONTIGUOUS 1
+#define CONFIG_DQL 1
+#define CONFIG_FRAMEBUFFER_CONSOLE_MODULE 1
+#define CONFIG_TCP_CONG_LP 1
+#define CONFIG_IP_NF_ARPTABLES 1
+#define CONFIG_USB_EHCI_MSM_HSIC 1
+#define CONFIG_HID_CHERRY 1
+#define CONFIG_USB_EHCI_MSM 1
+#define CONFIG_MSM_PCIE 1
+#define CONFIG_HID_SUNPLUS 1
+#define CONFIG_HID_PICOLCD 1
+#define CONFIG_BCMA_POSSIBLE 1
+#define CONFIG_NET_VENDOR_CIRRUS 1
+#define CONFIG_VGA_ARB 1
+#define CONFIG_FORCE_MAX_ZONEORDER 11
+#define CONFIG_SND_SOC 1
+#define CONFIG_SYNC 1
+#define CONFIG_CAN_PM_TRACE 1
+#define CONFIG_MEDIA_TUNER_XC5000 1
+#define CONFIG_PRINTK 1
+#define CONFIG_NF_CONNTRACK_PROC_COMPAT 1
+#define CONFIG_FB_SYS_FILLRECT 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_HID_THRUSTMASTER 1
+#define CONFIG_FB_MSM_MIPI_DSI_NOVATEK 1
+#define CONFIG_DNS_RESOLVER 1
+#define CONFIG_TRACEPOINTS 1
+#define CONFIG_CRYPTO_AUTHENC 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_VIDEO_V4L2_SUBDEV_API 1
+#define CONFIG_IRDA 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_MSM_KGSL_PAGE_TABLE_SIZE 0xFFF0000
+#define CONFIG_SHMEM 1
+#define CONFIG_MIGRATION 1
+#define CONFIG_HAVE_ARCH_JUMP_LABEL 1
+#define CONFIG_MMC_BLOCK_MINORS 32
+#define CONFIG_HID_PRIMAX 1
+#define CONFIG_RMNET_SMD_DATA_CHANNEL ""
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_CRYPTO_CTS 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_SND_SOC_CS8427 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_MSM_IPC_ROUTER_SMD_XPRT 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_MSM_SMD 1
+#define CONFIG_CFG80211_INTERNAL_REGDB 1
+#define CONFIG_NET_CLS_U32 1
+#define CONFIG_EXPORTFS 1
+#define CONFIG_ARM_GIC 1
+#define CONFIG_SERIO 1
+#define CONFIG_INPUT_MOUSE 1
+#define CONFIG_FB_SYS_IMAGEBLIT 1
+#define CONFIG_MSM7X00A_USE_GP_TIMER 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_MA600_DONGLE 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_MSM_QDSP6_APR 1
+#define CONFIG_NET_EMATCH_U32 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_I2C_QUP 1
+#define CONFIG_MFD_PM8XXX 1
+#define CONFIG_NF_CONNTRACK_SANE 1
+#define CONFIG_HAVE_BPF_JIT 1
+#define CONFIG_NF_CT_PROTO_DCCP 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_ENCRYPTED_KEYS 1
+#define CONFIG_HWMON 1
+#define CONFIG_USB_G_ANDROID 1
+#define CONFIG_NET_VENDOR_DLINK 1
+#define CONFIG_CRYPTO_TWOFISH_COMMON 1
+#define CONFIG_AUDITSYSCALL 1
+#define CONFIG_MSM_KRAIT_WFE_FIXUP 1
+#define CONFIG_STM_LIS3DH 1
+#define CONFIG_MSM_IPC_ROUTER 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_MSM_L2_ERP_2BIT_PANIC 1
+#define CONFIG_USB_VIDEO_CLASS 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_MSM_LPASS_8960 1
+#define CONFIG_PM_CLK 1
+#define CONFIG_CMA_SIZE_SEL_MBYTES 1
+#define CONFIG_CPU_IDLE_GOV_MENU 1
+#define CONFIG_FB_MSM_DTV 1
+#define CONFIG_USB_EHSET_TEST_FIXTURE 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_CPU_VOLTAGE_TABLE 1
+#define CONFIG_SLIMPORT_ANX7808 1
+#define CONFIG_USB_DEVICE_CLASS 1
+#define CONFIG_LOCKD 1
+#define CONFIG_GPIO_PM8XXX 1
+#define CONFIG_ANDROID_TIMED_GPIO 1
+#define CONFIG_ARM 1
+#define CONFIG_NET_VENDOR_MICROCHIP 1
+#define CONFIG_HID_SAITEK 1
+#define CONFIG_ARM_L1_CACHE_SHIFT 6
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_NET_VENDOR_ADAPTEC 1
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_NETFILTER_XT_MATCH_STRING 1
+#define CONFIG_ARM_CPU_TOPOLOGY 1
+#define CONFIG_HAS_WAKELOCK 1
+#define CONFIG_SPS_SUPPORT_BAMDMA 1
+#define CONFIG_NET_VENDOR_SILAN 1
+#define CONFIG_KERNEL_XZ 1
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_NET_VENDOR_BROADCOM 1
+#define CONFIG_BOARD_HEADER_FILE ""
+#define CONFIG_STANDALONE 1
+#define CONFIG_SCHED_MC 1
+#define CONFIG_SPI_QUP 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_IR_LIRC_CODEC 1
+#define CONFIG_DONGLE 1
+#define CONFIG_ARCH_HAS_CPUFREQ 1
+#define CONFIG_FB_MSM_EXT_INTERFACE_COMMON 1
+#define CONFIG_SND_USB_AUDIO 1
+#define CONFIG_TCP_CONG_YEAH 1
+#define CONFIG_ASHMEM 1
+#define CONFIG_BLOCK 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_HID_APPLE 1
+#define CONFIG_MEDIA_TUNER_TDA827X 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_IP_NF_ARP_MANGLE 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_EXFAT_FS 1
+#define CONFIG_INPUT_MPU3050 1
+#define CONFIG_MSM_VIDC_1080P 1
+#define CONFIG_USER_NS 1
+#define CONFIG_MSM_BAM_DMUX 1
+#define CONFIG_ASUSTEK_HEADSET 1
+#define CONFIG_NF_CONNTRACK_PPTP 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_BUG 1
+#define CONFIG_CONTEXT_SWITCH_TRACER 1
+#define CONFIG_NET_EMATCH_META 1
+#define CONFIG_PM 1
+#define CONFIG_MACH_ASUSTEK 1
+#define CONFIG_SPI 1
+#define CONFIG_NF_CONNTRACK_IRC 1
+#define CONFIG_SWITCH 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
+#define CONFIG_PPP_DEFLATE 1
+#define CONFIG_TEXTSEARCH_KMP 1
+#define CONFIG_VT 1
+#define CONFIG_USB_NET_NET1080 1
+#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY 1
+#define CONFIG_HID_TIVO 1
+#define CONFIG_REGMAP_SPI 1
+#define CONFIG_MSM_SYSMON_COMM 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_MFD_PM8038_CORE 1
+#define CONFIG_MSM_PIL_TZAPPS 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_CIFS_XATTR 1
+#define CONFIG_CPU_CACHE_VIPT 1
+#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM 1
+#define CONFIG_V4L_USB_DRIVERS 1
+#define CONFIG_WEXT_CORE 1
+#define CONFIG_MSM_DSPS 1
+#define CONFIG_NLS 1
+#define CONFIG_NETFILTER_XT_TARGET_SECMARK 1
+#define CONFIG_HID_MAGICMOUSE 1
+#define CONFIG_SENSORS_PM8XXX_ADC 1
+#define CONFIG_PPPOE 1
+#define CONFIG_REED_SOLOMON_DEC8 1
+#define CONFIG_IRQ_WORK 1
+#define CONFIG_PCI_MSI 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_FB_SYS_COPYAREA 1
+#define CONFIG_CLEANCACHE 1
+#define CONFIG_USB_STORAGE_ALAUDA 1
+#define CONFIG_SPARSEMEM_EXTREME 1
+#define CONFIG_DIAG_OVER_USB 1
+#define CONFIG_USB_COMMON 1
+#define CONFIG_TASK_XACCT 1
+#define CONFIG_MEDIA_TUNER_TDA18271 1
+#define CONFIG_IP6_NF_IPTABLES 1
+#define CONFIG_LZ4_COMPRESS 1
+#define CONFIG_CPU_FREQ_GOV_USERSPACE 1
+#define CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES 1
+#define CONFIG_INET_IPCOMP 1
+#define CONFIG_VGA_ARB_MAX_GPUS 16
+#define CONFIG_EVENT_TRACING 1
+#define CONFIG_HID_KEYTOUCH 1
+#define CONFIG_HID_CYPRESS 1
+#define CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET 1000000000
+#define CONFIG_FB_MSM_MIPI_DSI_JDI 1
+#define CONFIG_MSM_AUDIO_QDSP6 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_TCP_CONG_HYBLA 1
+#define CONFIG_HID_KENSINGTON 1
+#define CONFIG_BACKLIGHT_GENERIC 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_TEXTSEARCH_BM 1
+#define CONFIG_NF_CONNTRACK_PROCFS 1
+#define CONFIG_HID_ZYDACRON 1
+#define CONFIG_PPP_MPPE 1
+#define CONFIG_USB_IRDA 1
+#define CONFIG_RFKILL 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_MSM_SSBI 1
+#define CONFIG_CGROUP_FREEZER 1
+#define CONFIG_CPU_TLB_V7 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_XFRM 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT 1
+#define CONFIG_MSM_WFD 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_CRYPTO_SHA1_ARM 1
+#define CONFIG_MMC_MSM_SDC1_SUPPORT 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE 1
+#define CONFIG_NF_CONNTRACK_BROADCAST 1
+#define CONFIG_CRYPTO_LZ4 1
+#define CONFIG_IR_RC5_SZ_DECODER 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_NF_NAT_PROTO_DCCP 1
+#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
+#define CONFIG_DEBUG_GPIO 1
+#define CONFIG_RD_LZO 1
+#define CONFIG_ANDROID_LOW_MEMORY_KILLER 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_NF_CONNTRACK_SECMARK 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_NET_VENDOR_EXAR 1
+#define CONFIG_NET_VENDOR_SEEQ 1
+#define CONFIG_NF_DEFRAG_IPV4 1
+#define CONFIG_MIGHT_HAVE_PCI 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_HID_LCPOWER 1
+#define CONFIG_MMC_UNSAFE_RESUME 1
+#define CONFIG_HAVE_ARCH_PFN_VALID 1
+#define CONFIG_CPU_COPY_V6 1
+#define CONFIG_PM_DEBUG 1
+#define CONFIG_IPV6_ROUTE_INFO 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_CRYPTO_DEFLATE 1
+#define CONFIG_BT_HCISMD 1
+#define CONFIG_IPV6_ROUTER_PREF 1
+#define CONFIG_SERIAL_MSM_HSL_CONSOLE 1
+#define CONFIG_SLIP_COMPRESSED 1
+#define CONFIG_MSM_AVS_HW 1
+#define CONFIG_NETFILTER_NETLINK_LOG 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_MSM_QDSP6_CODECS 1
+#define CONFIG_INPUT_LID 1
+#define CONFIG_NET_VENDOR_RDC 1
+#define CONFIG_CPUSETS 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK 1
+#define CONFIG_MSM_PIL_VIDC 1
+#define CONFIG_MSM_DMA_TEST 1
+#define CONFIG_IP_NF_MANGLE 1
+#define CONFIG_MSM_DLOAD_MODE 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_MEDIA_SUPPORT 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_IP_NF_FILTER 1
+#define CONFIG_HID_ZEROPLUS 1
+#define CONFIG_NETFILTER_XT_MATCH_LENGTH 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_WCD9304_CODEC 1
+#define CONFIG_TEXTSEARCH_FSM 1
+#define CONFIG_HIGHMEM 1
+#define CONFIG_SPS 1
+#define CONFIG_IP6_NF_RAW 1
+#define CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_NETFILTER_XT_TARGET_NOTRACK 1
+#define CONFIG_EEPROM_93CX6 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_LIB80211 1
+#define CONFIG_MFD_CORE 1
+#define CONFIG_REGULATOR_MSM_GPIO 1
+#define CONFIG_HAVE_KERNEL_XZ 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_RFKILL_LEDS 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_VIDEO_HELPER_CHIPS_AUTO 1
+#define CONFIG_SND_SOC_QDSP6 1
+#define CONFIG_CLS_U32_MARK 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_MSM_KGSL_DRM 1
+#define CONFIG_USB_GSPCA 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_MODULE_FORCE_LOAD 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_NFS_V3_ACL 1
+#define CONFIG_USB_CSW_HACK 1
+#define CONFIG_DETECT_HUNG_TASK 1
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_USB_NET_CDC_SUBSET 1
+#define CONFIG_FB_MSM 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNMARK 1
+#define CONFIG_BLK_CGROUP 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_CRYPTO_RNG 1
+#define CONFIG_MSM_IDLE_WAIT_ON_MODEM 0
+#define CONFIG_SND_USB 1
+#define CONFIG_VIDEOBUF2_MEMOPS 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define CONFIG_LBDAF 1
+#define CONFIG_USB_STORAGE_CYPRESS_ATACB 1
+#define CONFIG_EXT4_FS_SECURITY 1
+#define CONFIG_V4L_PCI_DRIVERS 1
+#define CONFIG_HID_ROCCAT 1
+#define CONFIG_NET_VENDOR_HP 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_MSM_IPC_LOGGING 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE 1
+#define CONFIG_MEDIA_TUNER_TEA5767 1
+#define CONFIG_OABI_COMPAT 1
+#define CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define CONFIG_N_SMUX 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_AUDIT_GENERIC 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_NEED_MACH_MEMORY_H 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_INET6_AH 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_USB_SERIAL 1
+#define CONFIG_NET_VENDOR_ALTEON 1
+#define CONFIG_KEYS 1
+#define CONFIG_INET_XFRM_TUNNEL 1
+#define CONFIG_NETFILTER_XT_MARK 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_KEXEC_HARDBOOT 1
+#define CONFIG_RESOURCE_COUNTERS 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_USB_STORAGE_DATAFAB 1
+#define CONFIG_TCP_CONG_VEGAS 1
+#define CONFIG_MSM_CACHE_DUMP 1
+#define CONFIG_TIMER_STATS 1
+#define CONFIG_MSM_SMD_LOGGING 1
+#define CONFIG_PM_SLEEP_SMP 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_GENLOCK_MISCDEVICE 1
+#define CONFIG_FB_MSM_TVOUT_NONE 1
+#define CONFIG_ION 1
+#define CONFIG_USB_STORAGE_KARMA 1
+#define CONFIG_PHYS_OFFSET 0x80200000
+#define CONFIG_HID_GREENASIA 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_FB_MSM_LCDC_HW 1
+#define CONFIG_VT_HW_CONSOLE_BINDING 1
+#define CONFIG_ANDROID_PERSISTENT_RAM 1
+#define CONFIG_SLIP_MODE_SLIP6 1
+#define CONFIG_HID_GYRATION 1
+#define CONFIG_USB_WDM 1
+#define CONFIG_THERMAL_HWMON 1
+#define CONFIG_XZ_DEC_X86 1
+#define CONFIG_INPUT_JOYDEV 1
+#define CONFIG_EARLYSUSPEND 1
+#define CONFIG_THERMAL_TSENS8960 1
+#define CONFIG_USB_ACM 1
+#define CONFIG_MSM_SMD_PKT 1
+#define CONFIG_CRC16 1
+#define CONFIG_USB_NET_AX8817X 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_CRYPTO_GF128MUL 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_CPU_HAS_PMU 1
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_FUTEX 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_REGMAP_I2C 1
+#define CONFIG_NET_VENDOR_REALTEK 1
+#define CONFIG_JOYSTICK_XPAD_FF 1
+#define CONFIG_VMSPLIT_3G 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_SECURITY_NETWORK 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_MSM_DIRECT_SCLK_ACCESS 1
+#define CONFIG_NET_VENDOR_EMULEX 1
+#define CONFIG_USB_HID 1
+#define CONFIG_IOSCHED_SIO 1
+#define CONFIG_SND_SOC_WCD9310 1
+#define CONFIG_ANDROID 1
+#define CONFIG_SLUB_DEBUG 1
+#define CONFIG_NF_CONNTRACK_EVENTS 1
+#define CONFIG_FB_MSM_NO_MDP_PIPE_CTRL 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_MSM_L1_ERR_PANIC 1
+#define CONFIG_FANOTIFY 1
+#define CONFIG_IOSCHED_ROW 1
+#define CONFIG_SMC911X 1
+#define CONFIG_CGROUP_SCHED 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_CRYPTO_PCOMP2 1
+#define CONFIG_SMSC911X 1
+#define CONFIG_GPIO_MSM_V2 1
+#define CONFIG_KEYBOARD_GPIO 1
+#define CONFIG_NF_CONNTRACK_FTP 1
+#define CONFIG_MODULES 1
+#define CONFIG_IP_NF_MATCH_ECN 1
+#define CONFIG_CPU_HAS_ASID 1
+#define CONFIG_USB_GADGET 1
+#define CONFIG_SOUND 1
+#define CONFIG_EVENT_POWER_TRACING_DEPRECATED 1
+#define CONFIG_MEDIA_TUNER_TDA9887 1
+#define CONFIG_AUDIT_WATCH 1
+#define CONFIG_UNIX 1
+#define CONFIG_HAVE_CLK 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_CRYPTO_LZ4HC 1
+#define CONFIG_DEFAULT_HOSTNAME "(none)"
+#define CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS 2
+#define CONFIG_USB_STORAGE_ISD200 1
+#define CONFIG_CPU_FREQ_GOV_POWERSAVE 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_XPS 1
+#define CONFIG_INET_ESP 1
+#define CONFIG_SECURITY_SELINUX_DEVELOP 1
+#define CONFIG_LZ4_DECOMPRESS 1
+#define CONFIG_NF_CONNTRACK_IPV6 1
+#define CONFIG_MD 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_BSD_PROCESS_ACCT_V3 1
+#define CONFIG_FONTS 1
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_MMC_MSM_SPS_SUPPORT 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_INPUT_UINPUT 1
+#define CONFIG_ARCH_SUPPORTS_MSI 1
+#define CONFIG_MEDIA_TUNER_SIMPLE 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_NF_NAT 1
+#define CONFIG_ION_MSM 1
+#define CONFIG_NET_VENDOR_OKI 1
+#define CONFIG_MSM_KGSL_SIMPLE_GOV 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_MSM_ADSP_LOADER 1
+#define CONFIG_MSM_MPM 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_CHR_DEV_SCH 1
+#define CONFIG_REGULATOR 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_LOG_BUF_SHIFT 21
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_NET_VENDOR_8390 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE 1
+#define CONFIG_PID_NS 1
+#define CONFIG_MSM_KGSL_2D 1
+#define CONFIG_KEXEC 1
+#define CONFIG_CRC32_SLICEBY8 1
+#define CONFIG_MSM_ADSPRPC 1
+#define CONFIG_CPU_RMAP 1
+#define CONFIG_SND_HWDEP 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_DEFAULT_HUNG_TASK_TIMEOUT 120
+#define CONFIG_MFD_PM8XXX_SPK 1
+#define CONFIG_CFQ_GROUP_IOSCHED 1
+#define CONFIG_WAKELOCK 1
+#define CONFIG_NF_NAT_IRC 1
+#define CONFIG_MEDIA_TUNER_XC2028 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_SND_COMPRESS_OFFLOAD 1
+#define CONFIG_CPU_PABRT_V7 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_AMSS_7X25_VERSION_2009 1
+#define CONFIG_MSM_PIL 1
+#define CONFIG_FB_MSM_TRIPLE_BUFFER 1
+#define CONFIG_MEDIA_CONTROLLER 1
+#define CONFIG_CPU_FREQ_MSM 1
+#define CONFIG_MSM_PM_TIMEOUT_HALT 1
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_MFD_PM8XXX_IRQ 1
+#define CONFIG_TMPFS_XATTR 1
+#define CONFIG_CPU_PM 1
+#define CONFIG_MSM_VIDC_VDEC 1
+#define CONFIG_NF_NAT_TFTP 1
+#define CONFIG_NETFILTER_XT_MATCH_MULTIPORT 1
+#define CONFIG_CPU_CACHE_V7 1
+#define CONFIG_MSM_IOMMU 1
+#define CONFIG_ARCH_SELECT_MEMORY_MODEL 1
+#define CONFIG_TCP_CONG_ILLINOIS 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_USB_GADGET_VBUS_DRAW 500
+#define CONFIG_NET_VENDOR_MYRI 1
+#define CONFIG_GENERIC_PCI_IOMAP 1
+#define CONFIG_NETFILTER_XT_TARGET_LOG 1
+#define CONFIG_SLUB 1
+#define CONFIG_XZ_DEC_BCJ 1
+#define CONFIG_SLIP 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_I2C 1
+#define CONFIG_MSM_RMNET_BAM 1
+#define CONFIG_PPP_MULTILINK 1
+#define CONFIG_MSM_SOC_REV_NONE 1
+#define CONFIG_FB_MSM_BACKLIGHT 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_BT_HIDP 1
+#define CONFIG_CPU_ABRT_EV7 1
+#define CONFIG_MFD_PM8XXX_MISC 1
+#define CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_SND_DYNAMIC_MINORS 1
+#define CONFIG_BT_HCIUART_ATH3K 1
+#define CONFIG_NF_CONNTRACK_AMANDA 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_ARCH_MSM_KRAIT 1
+#define CONFIG_NET_VENDOR_AMD 1
+#define CONFIG_HAVE_KERNEL_LZ4 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_MFD_PM8XXX_PWM 1
+#define CONFIG_QSEECOM 1
+#define CONFIG_GPIO_SYSFS 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_PCI 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_CRYPTO_XTS 1
+#define CONFIG_DECOMPRESS_XZ 1
+#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE 1
+#define CONFIG_PCI_QUIRKS 1
+#define CONFIG_MII 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_NET_CORE 1
+#define CONFIG_MOUSE_PS2_ALPS 1
+#define CONFIG_EXT4_FS 1
+#define CONFIG_WCNSS_CORE_MODULE 1
+#define CONFIG_UNINLINE_SPIN_UNLOCK 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_ARM_DMA_MEM_BUFFERABLE 1
+#define CONFIG_IPV6_PRIVACY 1
+#define CONFIG_XZ_DEC 1
+#define CONFIG_USB_BELKIN 1
+#define CONFIG_NET_VENDOR_TI 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_DUMMY 1
+#define CONFIG_USB_GADGET_DUALSPEED 1
+#define CONFIG_MSM_CPU_PWRCTL 1
+#define CONFIG_STRICT_MEMORY_RWX 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_SND_RAWMIDI 1
+#define CONFIG_PPPOPNS 1
+#define CONFIG_UID_CPUTIME 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER 1
+#define CONFIG_USB_STORAGE_SDDR09 1
+#define CONFIG_IP_NF_MATCH_TTL 1
+#define CONFIG_MSM_RESET_MODEM 1
+#define CONFIG_IOSCHED_TEST 1
+#define CONFIG_NET_SCH_PRIO 1
+#define CONFIG_EPOLL 1
+#define CONFIG_SND_PCM 1
+#define CONFIG_CAP_SENSOR_RMNET_CTL 1
+#define CONFIG_PM_RUNTIME 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_BT_BNEP_MC_FILTER 1
+#define CONFIG_IR_SONY_DECODER 1
+#define CONFIG_NETFILTER_XT_MATCH_COMMENT 1
+#define CONFIG_NET 1
+#define CONFIG_LEDS_PM8XXX 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_SND_JACK 1
+#define CONFIG_USB_QCOM_DIAG_BRIDGE 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPMSS 1
+#define CONFIG_TOUCHSCREEN_ELAN_TF_3K 1
+#define CONFIG_NETFILTER_XT_MATCH_DSCP 1
+#define CONFIG_HID_DRAGONRISE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK 1
+#define CONFIG_MMC_PARANOID_SD_INIT 1
+#define CONFIG_VFPv3 1
+#define CONFIG_FW_LOADER_USER_HELPER 1
+#define CONFIG_IOMMU_PGTABLES_L2 1
+#define CONFIG_USB_NET_CDCETHER 1
+#define CONFIG_PACKET 1
+#define CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE 1
+#define CONFIG_HAVE_CLK_PREPARE 1
+#define CONFIG_NETFILTER_XT_MATCH_IPRANGE 1
+#define CONFIG_BCM2079X 1
+#define CONFIG_NF_CONNTRACK_TFTP 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_FB_MSM_MIPI_LG_1080_HD_PT 1
+#define CONFIG_NOP_TRACER 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_INET 1
+#define CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_XZ_DEC_POWERPC 1
+#define CONFIG_MSM_IOMMU_GPU_SYNC 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_CRYPTO_TWOFISH 1
+#define CONFIG_FREEZER 1
+#define CONFIG_BT 1
+#define CONFIG_RFKILL_PM 1
+#define CONFIG_MACH_APQ8064_FLO 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_REED_SOLOMON 1
+#define CONFIG_PMIC8XXX_VIBRATOR 1
+#define CONFIG_EXFAT_DEFAULT_CODEPAGE 437
+#define CONFIG_FB_MSM_HDMI_COMMON 1
+#define CONFIG_NET_VENDOR_CHELSIO 1
+#define CONFIG_LZ4HC_COMPRESS 1
+#define CONFIG_CP_ACCESS 1
+#define CONFIG_HID_WACOM 1
+#define CONFIG_SND_SOC_MSM_HOSTLESS_PCM 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_MSM_WCNSS_SSR_8960_MODULE 1
+#define CONFIG_USB_EHCI_EHSET 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_MODEM_SUPPORT 1
+#define CONFIG_EXT4_USE_FOR_EXT23 1
+#define CONFIG_USER_RC_INPUT 1
+#define CONFIG_BT_HCIUART_H4 1
+#define CONFIG_SWP_EMULATE 1
+#define CONFIG_FB_MSM_MIPI_DSI 1
+#define CONFIG_UIO 1
+#define CONFIG_SND_ARM 1
+#define CONFIG_HID_WALTOP 1
+#define CONFIG_NF_CONNTRACK_MARK 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT 1
+#define CONFIG_NET_VENDOR_SMSC 1
+#define CONFIG_USE_GENERIC_SMP_HELPERS 1
+#define CONFIG_FB_MSM_MIPI_DSI_LG 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_LIRC 1
+#define CONFIG_BT_BNEP 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_SERIAL_MSM_HS 1
+#define CONFIG_RD_XZ 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_PREEMPT_RCU 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_MSM_SLEEP_TIME_OVERRIDE 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_LCD_KCAL 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_RTC_INTF_ALARM 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_CPU_FREQ_STAT 1
+#define CONFIG_ARM_HAS_SG_CHAIN 1
+#define CONFIG_USB_MSM_OTG 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_NET_VENDOR_DEC 1
+#define CONFIG_INET6_ESP 1
+#define CONFIG_AUTOFS4_FS 1
+#define CONFIG_MMC_MSM 1
+#define CONFIG_MSM_AMSS_VERSION_6225 1
+#define CONFIG_TASKSTATS 1
+#define CONFIG_SLIMBUS_MSM_CTRL 1
+#define CONFIG_IP6_NF_FILTER 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_NEED_DMA_MAP_STATE 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_SOUND_CONTROL_HAX_3_GPL 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_FONT_8x8 1
+#define CONFIG_SMC91X 1
+#define CONFIG_NET_VENDOR_ATHEROS 1
+#define CONFIG_CPU_V7 1
+#define CONFIG_HID_TWINHAN 1
+#define CONFIG_GPIO_SX150X 1
+#define CONFIG_NET_VENDOR_SUN 1
+#define CONFIG_PANIC_TIMEOUT 0
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_FB_MSM_OVERLAY 1
+#define CONFIG_INPUT_JOYSTICK 1
+#define CONFIG_MSM_IDLE_STATS_FIRST_BUCKET 62500
+#define CONFIG_NETFILTER_XT_MATCH_ECN 1
+#define CONFIG_USB_STORAGE_SDDR55 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_DECOMPRESS_LZ4 1
+#define CONFIG_SPARSEMEM_MANUAL 1
+#define CONFIG_MSM_PIL_QDSP6V4 1
+#define CONFIG_NEED_MACH_IO_H 1
+#define CONFIG_SMP 1
+#define CONFIG_NETFILTER_XT_MATCH_TIME 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_NET_VENDOR_I825XX 1
+#define CONFIG_NETFILTER_XT_MATCH_MAC 1
+#define CONFIG_PRIMA_WLAN_MODULE 1
+#define CONFIG_ARM_NR_BANKS 8
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG 1
+#define CONFIG_GENERIC_ALLOCATOR 1
+#define CONFIG_L2TP 1
+#define CONFIG_MSM_WATCHDOG 1
+#define CONFIG_TCP_CONG_WESTWOOD 1
+#define CONFIG_KALLSYMS_ALL 1
+#define CONFIG_ANDROID_TIMED_OUTPUT 1
+#define CONFIG_GENERIC_IO 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_GPIO_PM8XXX_MPP 1
+#define CONFIG_KEYBOARD_MATRIX 1
+#define CONFIG_ARCH_NR_GPIO 0
+#define CONFIG_MSM_DCVS 1
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_CRYPTO_SHA256 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_HID_SONY 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_DEVMEM 1
+#define CONFIG_SND_SPI 1
+#define CONFIG_HID_MONTEREY 1
+#define CONFIG_HID_EZKEY 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_JOYSTICK_XPAD_LEDS 1
+#define CONFIG_MSM_GSS_SSR_8064 1
+#define CONFIG_NEON 1
+#define CONFIG_MSM_VCAP 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_LOCALVERSION "-flo"
+#define CONFIG_RADIO_IRIS 1
+#define CONFIG_RADIO_ADAPTERS 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_MSM_SCM 1
+#define CONFIG_NET_VENDOR_BROCADE 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_IP_NF_IPTABLES 1
+#define CONFIG_MSM_SUBSYSTEM_RESTART 1
+#define CONFIG_CMDLINE ""
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+#define CONFIG_FB_VIRTUAL 1
+#define CONFIG_NET_VENDOR_QLOGIC 1
+#define CONFIG_VIDEOBUF2_DMA_CONTIG 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_DEFAULT_CUBIC 1
+#define CONFIG_HID_SAMSUNG 1
+#define CONFIG_HW_PERF_EVENTS 1
+#define CONFIG_MSM_RMNET_SMUX 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_GENERIC_IRQ_SHOW 1
+#define CONFIG_IPV6_OPTIMISTIC_DAD 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_TCP_CONG_HSTCP 1
+#define CONFIG_SCSI_MOD 1
+#define CONFIG_NET_VENDOR_MICREL 1
+#define CONFIG_AUDIT_TREE 1
+#define CONFIG_VIDEOBUF2_DMA_SG 1
+#define CONFIG_THERMAL_MONITOR 1
+#define CONFIG_MSM_L1_ERR_LOG 1
+#define CONFIG_CRYPTO_CRC32C 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_FUSE_FS 1
+#define CONFIG_UID16 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_HID_MICROSOFT 1
+#define CONFIG_EXFAT_DEFAULT_IOCHARSET "utf8"
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_MFD_PM8XXX_BATT_ALARM 1
+#define CONFIG_NF_DEFRAG_IPV6 1
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_PPP_FILTER 1
+#define CONFIG_FB_MSM_MDP_HW 1
+#define CONFIG_MSM_SMD_QMI 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_NF_CT_PROTO_SCTP 1
+#define CONFIG_SCSI 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_FB_MSM_MDP40 1
+#define CONFIG_NF_NAT_PPTP 1
+#define CONFIG_HID_CHICONY 1
+#define CONFIG_HID 1
+#define CONFIG_USB_ARMLINUX 1
+#define CONFIG_CLKDEV_LOOKUP 1
+#define CONFIG_NET_VENDOR_MELLANOX 1
+#define CONFIG_VT_CONSOLE_SLEEP 1
+#define CONFIG_MSM_SMD_NMEA 1
+#define CONFIG_MEDIA_TUNER_TDA8290 1
+#define CONFIG_JBD2 1
+#define CONFIG_INET6_IPCOMP 1
+#define CONFIG_ANDROID_RAM_CONSOLE 1
+#define CONFIG_NET_VENDOR_MARVELL 1
+#define CONFIG_PHYLIB 1
+#define CONFIG_NET_VENDOR_NVIDIA 1
+#define CONFIG_NET_VENDOR_FARADAY 1
+#define CONFIG_ARCH_HAS_HOLES_MEMORYMODEL 1
+#define CONFIG_IRQ_DOMAIN 1
+#define CONFIG_LSM_MMAP_MIN_ADDR 4096
+#define CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE 1
+#define CONFIG_MEDIA_TUNER_MT20XX 1
+#define CONFIG_IPC_NS 1
+#define CONFIG_CPU_HAS_L2_PMU 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_DIAG_CHAR 1
+#define CONFIG_FTRACE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNLIMIT 1
+#define CONFIG_IP_NF_SECURITY 1
+#define CONFIG_IP_NF_RAW 1
+#define CONFIG_IP_NF_ARPFILTER 1
+#define CONFIG_ARM_L1_CACHE_SHIFT_6 1
+#define CONFIG_NETFILTER_XT_MATCH_SOCKET 1
+#define CONFIG_PPPOL2TP 1
+#define CONFIG_HID_TOPSEED 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_KSM 1
+#define CONFIG_NET_VENDOR_STMICRO 1
+#define CONFIG_MSM_IDLE_STATS_BUCKET_COUNT 10
+#define CONFIG_NF_NAT_H323 1
+#define CONFIG_XZ_DEC_SPARC 1
+#define CONFIG_ARCH_SPARSEMEM_DEFAULT 1
+#define CONFIG_HID_A4TECH 1
+#define CONFIG_MEDIA_TUNER_MC44S803 1
+#define CONFIG_IP_NF_TARGET_NETMAP 1
+#define CONFIG_RCU_CPU_STALL_TIMEOUT 60
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS 1
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_HOLES_IN_ZONE 1
+#define CONFIG_MSM_BUS_SCALING 1
+#define CONFIG_ARM_CPU_SUSPEND 1
+#define CONFIG_NF_NAT_AMANDA 1
+#define CONFIG_IR_GPIO_CIR 1
+#define CONFIG_PROFILING 1
+#define CONFIG_SPARSEMEM 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_MSM_NATIVE_RESTART 1
+#define CONFIG_RTC_DRV_PM8XXX 1
+#define CONFIG_MSM7X00A_SLEEP_MODE 0
+#define CONFIG_USB_CI13XXX_MSM 1
+#define CONFIG_SLHC 1
+#define CONFIG_NET_VENDOR_TEHUTI 1
+#define CONFIG_HAVE_SMP 1
+#define CONFIG_SCSI_TGT 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_NET_SCH_HTB 1
+#define CONFIG_PPP_BSDCOMP 1
+#define CONFIG_SCHED_SMT 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_HID_ORTEK 1
+#define CONFIG_NETFILTER_XT_TARGET_MARK 1
+#define CONFIG_REGULATOR_PM8XXX 1
+#define CONFIG_PCI_SYSCALL 1
+#define CONFIG_IPV6_SUBTREES 1
+#define CONFIG_I2C_ALGOBIT 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_NET_CLS_FW 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME 20000000
+#define CONFIG_SND_PCI 1
+#define CONFIG_EXPERT 1
+#define CONFIG_RTAC 1
+#define CONFIG_IR_SANYO_DECODER 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE 1
+#define CONFIG_ASUSTEK_PCBID 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_WEXT_PROC 1
+#define CONFIG_PERF_USE_VMALLOC 1
+#define CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE 1
+#define CONFIG_TASK_IO_ACCOUNTING 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_USB_NET_CDC_NCM 1
+#define CONFIG_CFG80211_REG_DEBUG 1
+#define CONFIG_RCU_CPU_STALL_VERBOSE 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_UPDATE_LCDC_LUT 1
+#define CONFIG_SND_SOC_WCD9304 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_CGROUPS 1
+#define CONFIG_MMC 1
+#define CONFIG_LZO_COMPRESS 1
+#define CONFIG_ARM_TICKET_LOCKS 1
+#define CONFIG_CRYPTO_SEQIV 1
+#define CONFIG_HID_LOGITECH 1
+#define CONFIG_STACKTRACE 1
+#define CONFIG_MSM_SMD_PKG4 1
+#define CONFIG_PPPOLAC 1
+#define CONFIG_MULTI_IRQ_HANDLER 1
+#define CONFIG_NETFILTER_XT_TARGET_IDLETIMER 1
+#define CONFIG_MSM_PIL_DSPS 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_CGROUP_CPUACCT 1
+#define CONFIG_FB_EARLYSUSPEND 1
+#define CONFIG_NET_VENDOR_VIA 1
+#define CONFIG_HZ 100
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_NETFILTER_XT_MATCH_U32 1
+#define CONFIG_FB_BACKLIGHT 1
+#define CONFIG_MSM_SMD_DEBUG 1
+#define CONFIG_QCACHE 1
+#define CONFIG_INET_AH 1
+#define CONFIG_MMC_PERF_PROFILING 1
+#define CONFIG_FB_MSM_OVERLAY0_WRITEBACK 1
+#define CONFIG_DEFAULT_IOSCHED "deadline"
+#define CONFIG_IPV6_MIP6 1
+#define CONFIG_NLATTR 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_ARCH_MSM8960 1
+#define CONFIG_NR_CPUS 4
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_NETFILTER_XT_CONNMARK 1
+#define CONFIG_HID_KYE 1
+#define CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define CONFIG_FIRMWARE_IN_KERNEL 1
+#define CONFIG_SYSFS 1
+#define CONFIG_MSM7X00A_IDLE_SPIN_TIME 80000
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_IP_NF_MATCH_AH 1
+#define CONFIG_TCP_CONG_VENO 1
+#define CONFIG_SLIMBUS 1
+#define CONFIG_NETFILTER_XT_MATCH_LIMIT 1
+#define CONFIG_N_SMUX_LOOPBACK 1
+#define CONFIG_CC_STACKPROTECTOR 1
+#define CONFIG_XZ_DEC_ARM 1
+#define CONFIG_FB_SYS_FOPS 1
+#define CONFIG_MEDIA_TUNER_XC4000 1
+#define CONFIG_FB 1
+#define CONFIG_TRACING 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_CPU_32v7 1
+#define CONFIG_MSM_BUSPM_DEV 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FRANDOM 1
+#define CONFIG_BT_HCIUART 1
+#define CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE 0
+#define CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_THERMAL 1
+#define CONFIG_NET_VENDOR_3COM 1
+#define CONFIG_HID_PETALYNX 1
+#define CONFIG_CMA_SIZE_MBYTES 16
+#define CONFIG_MSM_VIDC 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_NF_CONNTRACK_IPV4 1
+#define CONFIG_ZONE_DMA_FLAG 0
+#define CONFIG_MSM_KGSL 1
+#define CONFIG_SERIAL_MSM_HSL 1
+#define CONFIG_NET_VENDOR_INTEL 1
+#define CONFIG_RPS 1
+#define CONFIG_USB_NET_ZAURUS 1
+#define CONFIG_INET6_XFRM_TUNNEL 1
+#define CONFIG_PROC_PID_CPUSET 1
+#define CONFIG_WCD9310_CODEC 1
+#define CONFIG_MSM_RPM_STATS_LOG 1
+#define CONFIG_NET_EMATCH_NBYTE 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_WAKELOCK_STAT 1
+#define CONFIG_INPUT_KEYCHORD 1
+#define CONFIG_MFD_PM8921_CORE 1
+#define CONFIG_HAS_EARLYSUSPEND 1
+#define CONFIG_CPU_32v6K 1
+#define CONFIG_NET_VENDOR_CISCO 1
+#define CONFIG_HID_LOGITECH_DJ 1
+#define CONFIG_DEFAULT_SECURITY "selinux"
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_NF_NAT_PROTO_UDPLITE 1
+#define CONFIG_USB_SERIAL_SIERRAWIRELESS 1
+#define CONFIG_CRYPTO_CTR 1
+#define CONFIG_CGROUP_DEBUG 1
+#define CONFIG_RMNET_SMD_CTL_CHANNEL ""
+#define CONFIG_SW_SYNC 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_MSM_PIL_GSS 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_MUTEX_SPIN_ON_OWNER 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_HAVE_DMA_ATTRS 1
+#define CONFIG_USB_SERIAL_CSVT 1
+#define CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO 1
+#define CONFIG_VIDEOBUF2_CORE 1
+#define CONFIG_THERMAL_PM8XXX 1
+#define CONFIG_IRTTY_SIR 1
+#define CONFIG_CPUPOWER 1
+#define CONFIG_MSM_SPM_V2 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_SECURITY_SELINUX_AVC_STATS 1
+#define CONFIG_DEVPTS_MULTIPLE_INSTANCES 1
+#define CONFIG_MSM_SLEEPER 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_NET_PACKET_ENGINE 1
+#define CONFIG_VIDEOBUF2_VMALLOC 1
+#define CONFIG_RC_MAP 1
+#define CONFIG_WEXT_PRIV 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_SND_SOC_MSM8960 1
+#define CONFIG_HID_PANTHERLORD 1
+#define CONFIG_SND 1
+#define CONFIG_IR_RC6_DECODER 1
+#define CONFIG_ARCH_MSM8930 1
+#define CONFIG_MSM_TZ_LOG 1
+#define CONFIG_SND_SOC_MSM_STUB 1
+#define CONFIG_MSM_EVENT_TIMER 1
+#define CONFIG_V4L_PLATFORM_DRIVERS 1
+#define CONFIG_NET_VENDOR_NATSEMI 1
+#define CONFIG_MSM_AMSS_VERSION 6225
+#define CONFIG_IKCONFIG 1
+#define CONFIG_NFS_USE_KERNEL_DNS 1
+#define CONFIG_MSM_RPM 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_ARCH_MSM 1
+#define CONFIG_LOCAL_TIMERS 1
+#define CONFIG_HAVE_C_RECORDMCOUNT 1
+#define CONFIG_HW_RANDOM_MSM 1
+#define CONFIG_CIFS 1
+#define CONFIG_XFRM_USER 1
+#define CONFIG_TCP_CONG_BIC 1
+#define CONFIG_MACH_APQ8064_DEB 1
+#define CONFIG_TASK_DELAY_ACCT 1
+#define CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT 1
+#define CONFIG_GENLOCK 1
+#define CONFIG_MSM_HSIC_SYSMON 1
+#define CONFIG_NET_NS 1
+#define CONFIG_SOUND_CONTROL_HAX_GPL 1
+#define CONFIG_MSM_EBI_ERP 1
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_NET_EMATCH_CMP 1
+#define CONFIG_MSM_ULTRASOUND 1
+#define CONFIG_PPP_ASYNC 1
+#define CONFIG_MSM_SMD_TTY 1
+#define CONFIG_UID_STAT 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_AUDIT 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_RTC_INTF_ALARM_DEV 1
+#define CONFIG_ASUSTEK_KEYPAD 1
+#define CONFIG_CMA_AREAS 7
+#define CONFIG_HID_MULTITOUCH 1
+#define CONFIG_SECURITY 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2 1
+#define CONFIG_HID_ELECOM 1
+#define CONFIG_SND_TIMER 1
+#define CONFIG_USB_EHCI_TT_NEWSCHED 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_BLK_DEV 1
+#define CONFIG_MFD_PM8821_CORE 1
+#define CONFIG_NFS_ACL_SUPPORT 1
+#define CONFIG_TCP_CONG_SCALABLE 1
+#define CONFIG_SENSORS_EPM_ADC 1
+#define CONFIG_PRIMA_WLAN_LFR 1
+#define CONFIG_IOMMU_API 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNMARK 1
+#define CONFIG_CRYPTO_ANSI_CPRNG 1
+#define CONFIG_SECURITY_SELINUX 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNSECMARK 1
+#define CONFIG_FB_MSM_MIPI_JDI_CMD_MODE 1
+#define CONFIG_PRINTK_TIME 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_SECCOMP_FILTER 1
+#define CONFIG_PPP 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA 1
+#define CONFIG_ARCH_APQ8064 1
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NF_NAT_FTP 1
+#define CONFIG_NF_CT_PROTO_UDPLITE 1
+#define CONFIG_IKCONFIG_PROC 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_TEXTSEARCH 1
+#define CONFIG_MSM_CACHE_ERP 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_SOC_MSM_QDSP6_INTF 1
+#define CONFIG_DIAGFWD_BRIDGE_CODE 1
+#define CONFIG_NETFILTER_XT_MATCH_QTAGUID 1
+#define CONFIG_STAGING 1
+#define CONFIG_USB_QCOM_MDM_BRIDGE 1
+#define CONFIG_NET_VENDOR_SIS 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_HID_UCLOGIC 1
+#define CONFIG_MSM_IDLE_STATS 1
+#define CONFIG_BT_HCIUART_IBS 1
+#define CONFIG_FANOTIFY_ACCESS_PERMISSIONS 1
+#define CONFIG_CFG80211_WEXT 1
+#define CONFIG_MSM_RMNET_USB 1
+#define CONFIG_USB_QCOM_KS_BRIDGE 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE 1
+#define CONFIG_USB_STORAGE_FREECOM 1
+#define CONFIG_IR_RC5_DECODER 1
+#define CONFIG_DRM 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define CONFIG_MSM_RPM_RBCPR_STATS_LOG 1
+#define CONFIG_PREEMPT 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MSM_CACHE_DUMP_ON_PANIC 1
+#define CONFIG_BINARY_PRINTF 1
+#define CONFIG_USB_STORAGE_JUMPSHOT 1
+#define CONFIG_FB_MSM_HDMI_MSM_PANEL 1
+#define CONFIG_MMC_CLKGATE 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_MSM_N_WAY_SMD 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_HID_NTRIG 1
+#define CONFIG_DMA_SHARED_BUFFER 1
+#define CONFIG_CIFS_POSIX 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_DECOMPRESS_LZO 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_CROSS_COMPILE ""
+#define CONFIG_MEDIA_TUNER_TEA5761 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_HID_HOLTEK 1
+#define CONFIG_CRYPTO_AES_ARM 1
+#define CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define CONFIG_XZ_DEC_ARMTHUMB 1
+#define CONFIG_MSM_PIL_RIVA 1
+#define CONFIG_REGMAP 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_JOYSTICK_XPAD 1
+#define CONFIG_NETFILTER_TPROXY 1
+#define CONFIG_MSM_RUN_QUEUE_STATS 1
+#define CONFIG_USB_USBNET 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_FHANDLE 1
+#define CONFIG_HID_SMARTJOYPLUS 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_SWAP 1
+#define CONFIG_SND_SOC_VOICE 1
+#define CONFIG_CRC_CCITT 1
+#define CONFIG_ANDROID_PMEM 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_NETFILTER_NETLINK 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_WAKE_TIMEOUT 1
+#define CONFIG_AVERAGE 1
+#define CONFIG_MSM_RPM_REGULATOR 1
+#define CONFIG_PREEMPT_COUNT 1
+#define CONFIG_USB_ARCH_HAS_XHCI 1
+#define CONFIG_USB_GADGET_DEBUG_FILES 1
+#define CONFIG_MSM_HSIC_TTY 1
+#define CONFIG_ARCH_MSM_KRAITMP 1
+#define CONFIG_CMA 1
+#define CONFIG_CHARGER_SMB345 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_BITREVERSE 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_MSM_ROTATOR 1
+#define CONFIG_BLK_DEV_RAM_SIZE 4096
+#define CONFIG_USB_SERIAL_WWAN 1
+#define CONFIG_PRIMA_WLAN_OKC 1
+#define CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT 2
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_UIO_MSM_SHAREDMEM 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_MSM_GPIOMUX 1
+#define CONFIG_MFD_PM8XXX_DEBUG 1
+#define CONFIG_USB_STORAGE_ONETOUCH 1
+#define CONFIG_MSM_N_WAY_SMSM 1
+#define CONFIG_NF_CONNTRACK 1
+#define CONFIG_IOSCHED_FIOPS 1
+#define CONFIG_LCD_CLASS_DEVICE 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_SND_SOC_I2C_AND_SPI 1
+#define CONFIG_MSM_MULTIMEDIA_USE_ION 1
+#define CONFIG_AIO 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_PERF_EVENTS 1
+#define CONFIG_IP_NF_TARGET_REJECT 1
+#define CONFIG_LEDS_CLASS 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_FB_MSM_HDMI_3D 1
+#define CONFIG_DEFAULT_DEADLINE 1
+#define CONFIG_EXT4_FS_XATTR 1
+#define CONFIG_MSM_MODEM_8960 1
+#define CONFIG_LOCKUP_DETECTOR 1
+#define CONFIG_NET_ACTIVITY_STATS 1
+#define CONFIG_CMA_ALIGNMENT 8
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_UTS_NS 1
+#define CONFIG_NF_CT_PROTO_GRE 1
+#define CONFIG_NF_CT_NETLINK 1
+#define CONFIG_NET_EMATCH_TEXT 1
+#define CONFIG_DEFAULT_SECURITY_SELINUX 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_MOUSE_PS2 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_NETFILTER_XT_MATCH_HL 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_WEXT_SPY 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_HAVE_MEMBLOCK 1
+#define CONFIG_INPUT 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RD_LZ4 1
+#define CONFIG_MMU 1
+#define CONFIG_HAVE_IRQ_WORK 1
+#define CONFIG_USER_WAKELOCK 1
+#define CONFIG_USB_SIERRA_NET 1
+#define CONFIG_ENABLE_DEFAULT_TRACERS 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MODE 1
+#define CONFIG_MFD_PM8821_IRQ 1
diff -urN flo-ElementalX-5.00/include/generated/bounds.h flo-ElementalX-5.00-patched/include/generated/bounds.h
--- flo-ElementalX-5.00/include/generated/bounds.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/bounds.h	2016-06-01 21:26:31.000000000 +0000
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define NR_PAGEFLAGS 22 /* __NR_PAGEFLAGS	@ */
+#define MAX_NR_ZONES 3 /* __MAX_NR_ZONES	@ */
+#define NR_PCG_FLAGS 3 /* __NR_PCG_FLAGS	@ */
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/compile.h flo-ElementalX-5.00-patched/include/generated/compile.h
--- flo-ElementalX-5.00/include/generated/compile.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/compile.h	2016-06-03 17:56:07.000000000 +0000
@@ -0,0 +1,7 @@
+/* This file is auto generated, version 37 */
+/* SMP PREEMPT */
+#define UTS_MACHINE "arm"
+#define UTS_VERSION "#37 SMP PREEMPT Fri Jun 3 17:56:07 Local time zone must be set--"
+#define LINUX_COMPILE_BY "root"
+#define LINUX_COMPILE_HOST "porteus"
+#define LINUX_COMPILER "gcc version 4.9.4 20151028 (prerelease) (Linaro GCC 4.9-2016.02) "
diff -urN flo-ElementalX-5.00/include/generated/mach-types.h flo-ElementalX-5.00-patched/include/generated/mach-types.h
--- flo-ElementalX-5.00/include/generated/mach-types.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/mach-types.h	2016-06-01 15:48:31.000000000 +0000
@@ -0,0 +1,15351 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_GUMSTIX              373
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_PALMLD               835
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_PALMTE2              844
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_PALMTX               885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_OMAP_3430SDP         1138
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_TREO680              1230
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COLIBRI320           1340
+#define MACH_TYPE_CAM60                1351
+#define MACH_TYPE_AT91EB01             1354
+#define MACH_TYPE_DB88F5281            1358
+#define MACH_TYPE_CSB726               1359
+#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
+#define MACH_TYPE_LITTLETON            1388
+#define MACH_TYPE_REALVIEW_PB11MP      1407
+#define MACH_TYPE_MX27_3DS             1430
+#define MACH_TYPE_HALIBUT              1439
+#define MACH_TYPE_TROUT                1440
+#define MACH_TYPE_TCT_HAMMER           1460
+#define MACH_TYPE_HERALD               1461
+#define MACH_TYPE_SIM_ONE              1476
+#define MACH_TYPE_JIVE                 1490
+#define MACH_TYPE_SAM9_L9260           1501
+#define MACH_TYPE_REALVIEW_PB1176      1504
+#define MACH_TYPE_YL9200               1507
+#define MACH_TYPE_RD88F5182            1508
+#define MACH_TYPE_KUROBOX_PRO          1509
+#define MACH_TYPE_MX31_3DS             1511
+#define MACH_TYPE_QONG                 1524
+#define MACH_TYPE_OMAP2EVM             1534
+#define MACH_TYPE_OMAP3EVM             1535
+#define MACH_TYPE_DNS323               1542
+#define MACH_TYPE_OMAP3_BEAGLE         1546
+#define MACH_TYPE_NOKIA_N810           1548
+#define MACH_TYPE_PCM038               1551
+#define MACH_TYPE_TS209                1565
+#define MACH_TYPE_AT91CAP9ADK          1566
+#define MACH_TYPE_MX31MOBOARD          1574
+#define MACH_TYPE_VISION_EP9307        1578
+#define MACH_TYPE_TERASTATION_PRO2     1584
+#define MACH_TYPE_LINKSTATION_PRO      1585
+#define MACH_TYPE_E350                 1596
+#define MACH_TYPE_TS409                1601
+#define MACH_TYPE_RSI_EWS              1609
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_NEUROS_OSD2          1647
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_DAVINCI_DA830_EVM    1781
+#define MACH_TYPE_DOVE_DB              1788
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_USB_A9G20            1841
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_EUKREA_CPUIMX27      1975
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_TX37                 2127
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_TX25                 2177
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_VEXPRESS             2272
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_SMDK6442             2324
+#define MACH_TYPE_OPENRD_BASE          2325
+#define MACH_TYPE_DEVKIT8000           2330
+#define MACH_TYPE_MX51_EFIKAMX         2336
+#define MACH_TYPE_CM_T35               2341
+#define MACH_TYPE_NET2BIG              2342
+#define MACH_TYPE_IGEP0020             2344
+#define MACH_TYPE_NUC932EVB            2356
+#define MACH_TYPE_OPENRD_CLIENT        2361
+#define MACH_TYPE_U8500                2368
+#define MACH_TYPE_MX51_EFIKASB         2370
+#define MACH_TYPE_MARVELL_JASPER       2382
+#define MACH_TYPE_FLINT                2383
+#define MACH_TYPE_TAVOREVB3            2384
+#define MACH_TYPE_TOUCHBOOK            2393
+#define MACH_TYPE_RAUMFELD_RC          2413
+#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
+#define MACH_TYPE_RAUMFELD_SPEAKER     2415
+#define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_MX51_M2ID            2428
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_TX51                 2529
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_RIOT_BEI2            2576
+#define MACH_TYPE_RIOT_X37             2578
+#define MACH_TYPE_PCA101               2595
+#define MACH_TYPE_CAPC7117             2612
+#define MACH_TYPE_ICONTROL             2624
+#define MACH_TYPE_GPLUGD               2625
+#define MACH_TYPE_QSD8X50A_ST1_5       2627
+#define MACH_TYPE_MX23EVK              2629
+#define MACH_TYPE_AP4EVB               2630
+#define MACH_TYPE_MITYOMAPL138         2650
+#define MACH_TYPE_GURUPLUG             2659
+#define MACH_TYPE_SPEAR310             2660
+#define MACH_TYPE_SPEAR320             2661
+#define MACH_TYPE_AQUILA               2676
+#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
+#define MACH_TYPE_MSM7X30_SURF         2679
+#define MACH_TYPE_EA2478DEVKIT         2683
+#define MACH_TYPE_TERASTATION_WXL      2697
+#define MACH_TYPE_MSM7X25_SURF         2703
+#define MACH_TYPE_MSM7X25_FFA          2704
+#define MACH_TYPE_MSM7X27_SURF         2705
+#define MACH_TYPE_MSM7X27_FFA          2706
+#define MACH_TYPE_MSM7X30_FFA          2707
+#define MACH_TYPE_QSD8X50_SURF         2708
+#define MACH_TYPE_QSD8X50_FFA          2710
+#define MACH_TYPE_MX53_EVK             2716
+#define MACH_TYPE_IGEP0030             2717
+#define MACH_TYPE_SBC3530              2722
+#define MACH_TYPE_SAARB                2727
+#define MACH_TYPE_HARMONY              2731
+#define MACH_TYPE_MSM7X30_FLUID        2741
+#define MACH_TYPE_CM_T3517             2750
+#define MACH_TYPE_WBD222               2753
+#define MACH_TYPE_MSM8X60_SURF         2755
+#define MACH_TYPE_MSM8X60_SIM          2756
+#define MACH_TYPE_TCC8000_SDK          2758
+#define MACH_TYPE_NANOS                2759
+#define MACH_TYPE_STAMP9G45            2761
+#define MACH_TYPE_MSM8X55_SURF         2768
+#define MACH_TYPE_MSM8X55_FFA          2769
+#define MACH_TYPE_CNS3420VB            2776
+#define MACH_TYPE_OMAP4_PANDA          2791
+#define MACH_TYPE_TI8168EVM            2800
+#define MACH_TYPE_TETON_BGA            2816
+#define MACH_TYPE_EUKREA_CPUIMX25SD    2820
+#define MACH_TYPE_EUKREA_CPUIMX35SD    2821
+#define MACH_TYPE_EUKREA_CPUIMX51SD    2822
+#define MACH_TYPE_EUKREA_CPUIMX51      2823
+#define MACH_TYPE_SMDKC210             2838
+#define MACH_TYPE_PCA102               2843
+#define MACH_TYPE_T5325                2846
+#define MACH_TYPE_INCOME               2849
+#define MACH_TYPE_VVBOX_SDORIG2        2857
+#define MACH_TYPE_VVBOX_SDLITE2        2858
+#define MACH_TYPE_VVBOX_SDPRO4         2859
+#define MACH_TYPE_MX257SX              2861
+#define MACH_TYPE_GONI                 2862
+#define MACH_TYPE_MSM8X55_SVLTE_FFA    2863
+#define MACH_TYPE_MSM8X55_SVLTE_SURF   2864
+#define MACH_TYPE_BV07                 2882
+#define MACH_TYPE_OPENRD_ULTIMATE      2884
+#define MACH_TYPE_DEVIXP               2885
+#define MACH_TYPE_MICCPT               2886
+#define MACH_TYPE_MIC256               2887
+#define MACH_TYPE_U5500                2890
+#define MACH_TYPE_LINKSTATION_LSCHL    2913
+#define MACH_TYPE_SMDKV310             2925
+#define MACH_TYPE_WM8505_7IN_NETBOOK   2928
+#define MACH_TYPE_CRANEBOARD           2932
+#define MACH_TYPE_SMDK6450             2938
+#define MACH_TYPE_BROWNSTONE           2957
+#define MACH_TYPE_FLEXIBITY            2965
+#define MACH_TYPE_MX50_RDP             2988
+#define MACH_TYPE_UNIVERSAL_C210       2989
+#define MACH_TYPE_REAL6410             2990
+#define MACH_TYPE_DOCKSTAR             2998
+#define MACH_TYPE_TI8148EVM            3004
+#define MACH_TYPE_SEABOARD             3005
+#define MACH_TYPE_MX53_ARD             3010
+#define MACH_TYPE_MX53_SMD             3011
+#define MACH_TYPE_MSM8X60_RUMI3        3016
+#define MACH_TYPE_MSM8X60_FFA          3017
+#define MACH_TYPE_CM_A510              3020
+#define MACH_TYPE_FSM9XXX_SURF         3028
+#define MACH_TYPE_FSM9XXX_FFA          3029
+#define MACH_TYPE_TX28                 3043
+#define MACH_TYPE_PCONTROL_G20         3062
+#define MACH_TYPE_VPR200               3087
+#define MACH_TYPE_TORBRECK             3090
+#define MACH_TYPE_PRIMA2_EVB           3103
+#define MACH_TYPE_MSM8X60_FLUID        3124
+#define MACH_TYPE_PAZ00                3128
+#define MACH_TYPE_ACMENETUSFOXG20      3129
+#define MACH_TYPE_MSM8X60_FUSION       3181
+#define MACH_TYPE_AG5EVM               3189
+#define MACH_TYPE_TSUNAGI              3197
+#define MACH_TYPE_MSM8X60_FUSN_FFA     3199
+#define MACH_TYPE_ICS_IF_VOIP          3206
+#define MACH_TYPE_WLF_CRAGG_6410       3207
+#define MACH_TYPE_TRIMSLICE            3209
+#define MACH_TYPE_MACKEREL             3211
+#define MACH_TYPE_KAEN                 3217
+#define MACH_TYPE_NOKIA_RM680          3220
+#define MACH_TYPE_DM6446_ADBOX         3226
+#define MACH_TYPE_QUAD_SALSA           3227
+#define MACH_TYPE_ABB_GMA_1_1          3228
+#define MACH_TYPE_SVCID                3229
+#define MACH_TYPE_MSM8960_SIM          3230
+#define MACH_TYPE_MSM8960_RUMI3        3231
+#define MACH_TYPE_ICON_G               3232
+#define MACH_TYPE_MB3                  3233
+#define MACH_TYPE_GSIA18S              3234
+#define MACH_TYPE_PIVICC               3235
+#define MACH_TYPE_PCM048               3236
+#define MACH_TYPE_DDS                  3237
+#define MACH_TYPE_CHALTEN_XA1          3238
+#define MACH_TYPE_TS48XX               3239
+#define MACH_TYPE_TONGA2_TFTTIMER      3240
+#define MACH_TYPE_WHISTLER             3241
+#define MACH_TYPE_ASL_PHOENIX          3242
+#define MACH_TYPE_AT91SAM9263OTLITE    3243
+#define MACH_TYPE_DDPLUG               3244
+#define MACH_TYPE_D2PLUG               3245
+#define MACH_TYPE_KZM9D                3246
+#define MACH_TYPE_VERDI_LTE            3247
+#define MACH_TYPE_NANOZOOM             3248
+#define MACH_TYPE_DM3730_SOM_LV        3249
+#define MACH_TYPE_DM3730_TORPEDO       3250
+#define MACH_TYPE_ANCHOVY              3251
+#define MACH_TYPE_RE2REV20             3253
+#define MACH_TYPE_RE2REV21             3254
+#define MACH_TYPE_CNS21XX              3255
+#define MACH_TYPE_RIDER                3257
+#define MACH_TYPE_NSK330               3258
+#define MACH_TYPE_CNS2133EVB           3259
+#define MACH_TYPE_Z3_816X_MOD          3260
+#define MACH_TYPE_Z3_814X_MOD          3261
+#define MACH_TYPE_BEECT                3262
+#define MACH_TYPE_DMA_THUNDERBUG       3263
+#define MACH_TYPE_OMN_AT91SAM9G20      3264
+#define MACH_TYPE_MX25_E2S_UC          3265
+#define MACH_TYPE_MIONE                3266
+#define MACH_TYPE_TOP9000_TCU          3267
+#define MACH_TYPE_TOP9000_BSL          3268
+#define MACH_TYPE_KINGDOM              3269
+#define MACH_TYPE_ARMADILLO460         3270
+#define MACH_TYPE_LQ2                  3271
+#define MACH_TYPE_SWEDA_TMS2           3272
+#define MACH_TYPE_MX53_LOCO            3273
+#define MACH_TYPE_ACER_A8              3275
+#define MACH_TYPE_ACER_GAUGUIN         3276
+#define MACH_TYPE_GUPPY                3277
+#define MACH_TYPE_MX61_ARD             3278
+#define MACH_TYPE_TX53                 3279
+#define MACH_TYPE_OMAPL138_CASE_A3     3280
+#define MACH_TYPE_UEMD                 3281
+#define MACH_TYPE_CCWMX51MUT           3282
+#define MACH_TYPE_ROCKHOPPER           3283
+#define MACH_TYPE_ENCORE               3284
+#define MACH_TYPE_HKDKC100             3285
+#define MACH_TYPE_TS42XX               3286
+#define MACH_TYPE_AEBL                 3287
+#define MACH_TYPE_WARIO                3288
+#define MACH_TYPE_GFS_SPM              3289
+#define MACH_TYPE_CM_T3730             3290
+#define MACH_TYPE_ISC3                 3291
+#define MACH_TYPE_RASCAL               3292
+#define MACH_TYPE_HREFV60              3293
+#define MACH_TYPE_TPT_2_0              3294
+#define MACH_TYPE_SPLENDOR             3296
+#define MACH_TYPE_MSM8X60_QT           3298
+#define MACH_TYPE_HTC_HD_MINI          3299
+#define MACH_TYPE_ATHENE               3300
+#define MACH_TYPE_DEEP_R_EK_1          3301
+#define MACH_TYPE_VIVOW_CT             3302
+#define MACH_TYPE_NERY_1000            3303
+#define MACH_TYPE_RFL109145_SSRV       3304
+#define MACH_TYPE_NMH                  3305
+#define MACH_TYPE_WN802T               3306
+#define MACH_TYPE_DRAGONET             3307
+#define MACH_TYPE_AT91SAM9263DESK16L   3309
+#define MACH_TYPE_BCMHANA_SV           3310
+#define MACH_TYPE_BCMHANA_TABLET       3311
+#define MACH_TYPE_KOI                  3312
+#define MACH_TYPE_TS4800               3313
+#define MACH_TYPE_TQMA9263             3314
+#define MACH_TYPE_HOLIDAY              3315
+#define MACH_TYPE_PCATS_OVERLAY        3317
+#define MACH_TYPE_HWGW6410             3318
+#define MACH_TYPE_SHENZHOU             3319
+#define MACH_TYPE_CWME9210             3320
+#define MACH_TYPE_CWME9210JS           3321
+#define MACH_TYPE_COLIBRI_TEGRA2       3323
+#define MACH_TYPE_W21                  3324
+#define MACH_TYPE_POLYSAT1             3325
+#define MACH_TYPE_DATAWAY              3326
+#define MACH_TYPE_COBRAL138            3327
+#define MACH_TYPE_ROVERPCS8            3328
+#define MACH_TYPE_MARVELC              3329
+#define MACH_TYPE_NAVEFIHID            3330
+#define MACH_TYPE_DM365_CV100          3331
+#define MACH_TYPE_ABLE                 3332
+#define MACH_TYPE_LEGACY               3333
+#define MACH_TYPE_ICONG                3334
+#define MACH_TYPE_ROVER_G8             3335
+#define MACH_TYPE_T5388P               3336
+#define MACH_TYPE_DINGO                3337
+#define MACH_TYPE_GOFLEXHOME           3338
+#define MACH_TYPE_LANREADYFN511        3340
+#define MACH_TYPE_OMAP3_BAIA           3341
+#define MACH_TYPE_OMAP3SMARTDISPLAY    3342
+#define MACH_TYPE_XILINX               3343
+#define MACH_TYPE_A2F                  3344
+#define MACH_TYPE_SKY25                3345
+#define MACH_TYPE_CCMX53               3346
+#define MACH_TYPE_CCMX53JS             3347
+#define MACH_TYPE_CCWMX53              3348
+#define MACH_TYPE_CCWMX53JS            3349
+#define MACH_TYPE_FRISMS               3350
+#define MACH_TYPE_MSM7X27A_FFA         3351
+#define MACH_TYPE_MSM7X27A_SURF        3352
+#define MACH_TYPE_MSM7X27A_RUMI3       3353
+#define MACH_TYPE_DIMMSAM9G20          3354
+#define MACH_TYPE_DIMM_IMX28           3355
+#define MACH_TYPE_AMK_A4               3356
+#define MACH_TYPE_GNET_SGME            3357
+#define MACH_TYPE_SHOOTER_U            3358
+#define MACH_TYPE_VMX53                3359
+#define MACH_TYPE_RHINO                3360
+#define MACH_TYPE_ARMLEX4210           3361
+#define MACH_TYPE_SWARCOEXTMODEM       3362
+#define MACH_TYPE_SNOWBALL             3363
+#define MACH_TYPE_PCM049               3364
+#define MACH_TYPE_VIGOR                3365
+#define MACH_TYPE_OSLO_AMUNDSEN        3366
+#define MACH_TYPE_GSL_DIAMOND          3367
+#define MACH_TYPE_CV2201               3368
+#define MACH_TYPE_CV2202               3369
+#define MACH_TYPE_CV2203               3370
+#define MACH_TYPE_VIT_IBOX             3371
+#define MACH_TYPE_DM6441_ESP           3372
+#define MACH_TYPE_AT91SAM9X5EK         3373
+#define MACH_TYPE_LIBRA                3374
+#define MACH_TYPE_EASYCRRH             3375
+#define MACH_TYPE_TRIPEL               3376
+#define MACH_TYPE_ENDIAN_MINI          3377
+#define MACH_TYPE_XILINX_EP107         3378
+#define MACH_TYPE_NURI                 3379
+#define MACH_TYPE_JANUS                3380
+#define MACH_TYPE_DDNAS                3381
+#define MACH_TYPE_TAG                  3382
+#define MACH_TYPE_TAGW                 3383
+#define MACH_TYPE_NITROGEN_VM_IMX51    3384
+#define MACH_TYPE_VIPRINET             3385
+#define MACH_TYPE_BOCKW                3386
+#define MACH_TYPE_EVA2000              3387
+#define MACH_TYPE_STEELYARD            3388
+#define MACH_TYPE_NSSLSBOARD           3392
+#define MACH_TYPE_GENEVA_B5            3393
+#define MACH_TYPE_SPEAR1340            3394
+#define MACH_TYPE_REXMAS               3395
+#define MACH_TYPE_MSM8960_CDP          3396
+#define MACH_TYPE_MSM8960_MTP          3397
+#define MACH_TYPE_MSM8960_FLUID        3398
+#define MACH_TYPE_MSM8960_APQ          3399
+#define MACH_TYPE_HELIOS_V2            3400
+#define MACH_TYPE_MIF10P               3401
+#define MACH_TYPE_IAM28                3402
+#define MACH_TYPE_PICASSO              3403
+#define MACH_TYPE_MR301A               3404
+#define MACH_TYPE_NOTLE                3405
+#define MACH_TYPE_EELX2                3406
+#define MACH_TYPE_MOON                 3407
+#define MACH_TYPE_RUBY                 3408
+#define MACH_TYPE_GOLDENGATE           3409
+#define MACH_TYPE_CTBU_GEN2            3410
+#define MACH_TYPE_KMP_AM17_01          3411
+#define MACH_TYPE_WTPLUG               3412
+#define MACH_TYPE_MX27SU2              3413
+#define MACH_TYPE_NB31                 3414
+#define MACH_TYPE_HJSDU                3415
+#define MACH_TYPE_TD3_REV1             3416
+#define MACH_TYPE_EAG_CI4000           3417
+#define MACH_TYPE_NET5BIG_NAND_V2      3418
+#define MACH_TYPE_CPX2                 3419
+#define MACH_TYPE_NET2BIG_NAND_V2      3420
+#define MACH_TYPE_ECUV5                3421
+#define MACH_TYPE_HSGX6D               3422
+#define MACH_TYPE_DAWAD7               3423
+#define MACH_TYPE_SAM9REPEATER         3424
+#define MACH_TYPE_GT_I5700             3425
+#define MACH_TYPE_CTERA_PLUG_C2        3426
+#define MACH_TYPE_MARVELCT             3427
+#define MACH_TYPE_AG11005              3428
+#define MACH_TYPE_VANGOGH              3430
+#define MACH_TYPE_MATRIX505            3431
+#define MACH_TYPE_OCE_NIGMA            3432
+#define MACH_TYPE_T55                  3433
+#define MACH_TYPE_BIO3K                3434
+#define MACH_TYPE_EXPRESSCT            3435
+#define MACH_TYPE_CARDHU               3436
+#define MACH_TYPE_ARUBA                3437
+#define MACH_TYPE_BONAIRE              3438
+#define MACH_TYPE_NUC700EVB            3439
+#define MACH_TYPE_NUC710EVB            3440
+#define MACH_TYPE_NUC740EVB            3441
+#define MACH_TYPE_NUC745EVB            3442
+#define MACH_TYPE_TRANSCEDE            3443
+#define MACH_TYPE_MORA                 3444
+#define MACH_TYPE_NDA_EVM              3445
+#define MACH_TYPE_TIMU                 3446
+#define MACH_TYPE_EXPRESSH             3447
+#define MACH_TYPE_VERIDIS_A300         3448
+#define MACH_TYPE_DM368_LEOPARD        3449
+#define MACH_TYPE_OMAP_MCOP            3450
+#define MACH_TYPE_TRITIP               3451
+#define MACH_TYPE_SM1K                 3452
+#define MACH_TYPE_MONCH                3453
+#define MACH_TYPE_CURACAO              3454
+#define MACH_TYPE_ORIGEN               3455
+#define MACH_TYPE_EPC10                3456
+#define MACH_TYPE_SGH_I740             3457
+#define MACH_TYPE_TUNA                 3458
+#define MACH_TYPE_MX51_TULIP           3459
+#define MACH_TYPE_MX51_ASTER7          3460
+#define MACH_TYPE_ACRO37XBRD           3461
+#define MACH_TYPE_ELKE                 3462
+#define MACH_TYPE_SBC6000X             3463
+#define MACH_TYPE_R1801E               3464
+#define MACH_TYPE_H1600                3465
+#define MACH_TYPE_MINI210              3466
+#define MACH_TYPE_MINI8168             3467
+#define MACH_TYPE_PC7308               3468
+#define MACH_TYPE_KMM2M01              3470
+#define MACH_TYPE_MX51EREBUS           3471
+#define MACH_TYPE_WM8650REFBOARD       3472
+#define MACH_TYPE_TUXRAIL              3473
+#define MACH_TYPE_ARTHUR               3474
+#define MACH_TYPE_DOORBOY              3475
+#define MACH_TYPE_XARINA               3476
+#define MACH_TYPE_ROVERX7              3477
+#define MACH_TYPE_SDVR                 3478
+#define MACH_TYPE_ACER_MAYA            3479
+#define MACH_TYPE_PICO                 3480
+#define MACH_TYPE_CWMX233              3481
+#define MACH_TYPE_CWAM1808             3482
+#define MACH_TYPE_CWDM365              3483
+#define MACH_TYPE_MX51_MORAY           3484
+#define MACH_TYPE_THALES_CBC           3485
+#define MACH_TYPE_BLUEPOINT            3486
+#define MACH_TYPE_DIR665               3487
+#define MACH_TYPE_ACMEROVER1           3488
+#define MACH_TYPE_SHOOTER_CT           3489
+#define MACH_TYPE_BLISS                3490
+#define MACH_TYPE_BLISSC               3491
+#define MACH_TYPE_THALES_ADC           3492
+#define MACH_TYPE_UBISYS_P9D_EVP       3493
+#define MACH_TYPE_ATDGP318             3494
+#define MACH_TYPE_DMA210U              3495
+#define MACH_TYPE_EM_T3                3496
+#define MACH_TYPE_HTX3250              3497
+#define MACH_TYPE_G50                  3498
+#define MACH_TYPE_ECO5                 3499
+#define MACH_TYPE_WINTERGRASP          3500
+#define MACH_TYPE_PURO                 3501
+#define MACH_TYPE_SHOOTER_K            3502
+#define MACH_TYPE_NSPIRE               3503
+#define MACH_TYPE_MICKXX               3504
+#define MACH_TYPE_LXMB                 3505
+#define MACH_TYPE_ADAM                 3507
+#define MACH_TYPE_B1004                3508
+#define MACH_TYPE_OBOEA                3509
+#define MACH_TYPE_A1015                3510
+#define MACH_TYPE_ROBIN_VBDT30         3511
+#define MACH_TYPE_TEGRA_ENTERPRISE     3512
+#define MACH_TYPE_RFL108200_MK10       3513
+#define MACH_TYPE_RFL108300_MK16       3514
+#define MACH_TYPE_ROVER_V7             3515
+#define MACH_TYPE_MIPHONE              3516
+#define MACH_TYPE_FEMTOBTS             3517
+#define MACH_TYPE_MONOPOLI             3518
+#define MACH_TYPE_BOSS                 3519
+#define MACH_TYPE_DAVINCI_DM368_VTAM   3520
+#define MACH_TYPE_CLCON                3521
+#define MACH_TYPE_NOKIA_RM696          3522
+#define MACH_TYPE_TAHITI               3523
+#define MACH_TYPE_FIGHTER              3524
+#define MACH_TYPE_SGH_I710             3525
+#define MACH_TYPE_INTEGREPROSCB        3526
+#define MACH_TYPE_MONZA                3527
+#define MACH_TYPE_CALIMAIN             3528
+#define MACH_TYPE_MX6Q_SABREAUTO       3529
+#define MACH_TYPE_GMA01X               3530
+#define MACH_TYPE_SBC51                3531
+#define MACH_TYPE_FIT                  3532
+#define MACH_TYPE_STEELHEAD            3533
+#define MACH_TYPE_PANTHER              3534
+#define MACH_TYPE_MSM8960_LIQUID       3535
+#define MACH_TYPE_LEXIKONCT            3536
+#define MACH_TYPE_NS2816_STB           3537
+#define MACH_TYPE_SEI_MM2_LPC3250      3538
+#define MACH_TYPE_CMIMX53              3539
+#define MACH_TYPE_SANDWICH             3540
+#define MACH_TYPE_CHIEF                3541
+#define MACH_TYPE_POGO_E02             3542
+#define MACH_TYPE_MIKRAP_X168          3543
+#define MACH_TYPE_HTCMOZART            3544
+#define MACH_TYPE_HTCGOLD              3545
+#define MACH_TYPE_MT72XX               3546
+#define MACH_TYPE_MX51_IVY             3547
+#define MACH_TYPE_MX51_LVD             3548
+#define MACH_TYPE_OMAP3_WISER2         3549
+#define MACH_TYPE_DREAMPLUG            3550
+#define MACH_TYPE_COBAS_C_111          3551
+#define MACH_TYPE_COBAS_U_411          3552
+#define MACH_TYPE_HSSD                 3553
+#define MACH_TYPE_IOM35X               3554
+#define MACH_TYPE_PSOM_OMAP            3555
+#define MACH_TYPE_IPHONE_2G            3556
+#define MACH_TYPE_IPHONE_3G            3557
+#define MACH_TYPE_IPOD_TOUCH_1G        3558
+#define MACH_TYPE_PHAROS_TPC           3559
+#define MACH_TYPE_MX53_HYDRA           3560
+#define MACH_TYPE_NS2816_DEV_BOARD     3561
+#define MACH_TYPE_IPHONE_3GS           3562
+#define MACH_TYPE_IPHONE_4             3563
+#define MACH_TYPE_IPOD_TOUCH_4G        3564
+#define MACH_TYPE_DRAGON_E1100         3565
+#define MACH_TYPE_TOPSIDE              3566
+#define MACH_TYPE_IRISIII              3567
+#define MACH_TYPE_DETO_MACARM9         3568
+#define MACH_TYPE_ETI_D1               3569
+#define MACH_TYPE_SOM3530SDK           3570
+#define MACH_TYPE_OC_ENGINE            3571
+#define MACH_TYPE_APQ8064_SIM          3572
+#define MACH_TYPE_ALPS                 3575
+#define MACH_TYPE_TNY_T3730            3576
+#define MACH_TYPE_GERYON_NFE           3577
+#define MACH_TYPE_NS2816_REF_BOARD     3578
+#define MACH_TYPE_SILVERSTONE          3579
+#define MACH_TYPE_MTT2440              3580
+#define MACH_TYPE_YNICDB               3581
+#define MACH_TYPE_BCT                  3582
+#define MACH_TYPE_TUSCAN               3583
+#define MACH_TYPE_XBT_SAM9G45          3584
+#define MACH_TYPE_ENBW_CMC             3585
+#define MACH_TYPE_MSM8X60_DRAGON       3586
+#define MACH_TYPE_CH104MX257           3587
+#define MACH_TYPE_OPENPRI              3588
+#define MACH_TYPE_AM335XEVM            3589
+#define MACH_TYPE_PICODMB              3590
+#define MACH_TYPE_WALUIGI              3591
+#define MACH_TYPE_PUNICAG7             3592
+#define MACH_TYPE_IPAD_1G              3593
+#define MACH_TYPE_APPLETV_2G           3594
+#define MACH_TYPE_MACH_ECOG45          3595
+#define MACH_TYPE_AIT_CAM_ENC_4XX      3596
+#define MACH_TYPE_RUNNYMEDE            3597
+#define MACH_TYPE_PLAY                 3598
+#define MACH_TYPE_HW90260              3599
+#define MACH_TYPE_TAGH                 3600
+#define MACH_TYPE_FILBERT              3601
+#define MACH_TYPE_GETINGE_NETCOMV3     3602
+#define MACH_TYPE_CW20                 3603
+#define MACH_TYPE_CINEMA               3604
+#define MACH_TYPE_CINEMA_TEA           3605
+#define MACH_TYPE_CINEMA_COFFEE        3606
+#define MACH_TYPE_CINEMA_JUICE         3607
+#define MACH_TYPE_MX53_MIRAGE2         3609
+#define MACH_TYPE_MX53_EFIKASB         3610
+#define MACH_TYPE_STM_B2000            3612
+#define MACH_TYPE_M28EVK               3613
+#define MACH_TYPE_PDA                  3614
+#define MACH_TYPE_MERAKI_MR58          3615
+#define MACH_TYPE_KOTA2                3616
+#define MACH_TYPE_LETCOOL              3617
+#define MACH_TYPE_MX27IAT              3618
+#define MACH_TYPE_APOLLO_TD            3619
+#define MACH_TYPE_ARENA                3620
+#define MACH_TYPE_GSNGATEWAY           3621
+#define MACH_TYPE_LF2000               3622
+#define MACH_TYPE_BONITO               3623
+#define MACH_TYPE_ASYMPTOTE            3624
+#define MACH_TYPE_BST2BRD              3625
+#define MACH_TYPE_TX335S               3626
+#define MACH_TYPE_PELCO_TESLA          3627
+#define MACH_TYPE_RRHTESTPLAT          3628
+#define MACH_TYPE_VIDTONIC_PRO         3629
+#define MACH_TYPE_PL_APOLLO            3630
+#define MACH_TYPE_PL_PHOENIX           3631
+#define MACH_TYPE_M28CU3               3632
+#define MACH_TYPE_VVBOX_HD             3633
+#define MACH_TYPE_COREWARE_SAM9260_    3634
+#define MACH_TYPE_MARMADUKE            3635
+#define MACH_TYPE_AMG_XLCORE_CAMERA    3636
+#define MACH_TYPE_OMAP3_EGF            3637
+#define MACH_TYPE_SMDK4212             3638
+#define MACH_TYPE_DNP9200              3639
+#define MACH_TYPE_TF101                3640
+#define MACH_TYPE_OMAP3SILVIO          3641
+#define MACH_TYPE_PICASSO2             3642
+#define MACH_TYPE_VANGOGH2             3643
+#define MACH_TYPE_OLPC_XO_1_75         3644
+#define MACH_TYPE_GX400                3645
+#define MACH_TYPE_GS300                3646
+#define MACH_TYPE_ACER_A9              3647
+#define MACH_TYPE_VIVOW_EVM            3648
+#define MACH_TYPE_VELOCE_CXQ           3649
+#define MACH_TYPE_VELOCE_CXM           3650
+#define MACH_TYPE_P1852                3651
+#define MACH_TYPE_NAXY100              3652
+#define MACH_TYPE_TAISHAN              3653
+#define MACH_TYPE_TOUCHLINK            3654
+#define MACH_TYPE_STM32F103ZE          3655
+#define MACH_TYPE_MCX                  3656
+#define MACH_TYPE_STM_NMHDK_FLI7610    3657
+#define MACH_TYPE_TOP28X               3658
+#define MACH_TYPE_OKL4VP_MICROVISOR    3659
+#define MACH_TYPE_POP                  3660
+#define MACH_TYPE_LAYER                3661
+#define MACH_TYPE_TRONDHEIM            3662
+#define MACH_TYPE_EVA                  3663
+#define MACH_TYPE_TRUST_TAURUS         3664
+#define MACH_TYPE_NS2816_HUASHAN       3665
+#define MACH_TYPE_NS2816_YANGCHENG     3666
+#define MACH_TYPE_P852                 3667
+#define MACH_TYPE_FLEA3                3668
+#define MACH_TYPE_BOWFIN               3669
+#define MACH_TYPE_MV88DE3100           3670
+#define MACH_TYPE_PIA_AM35X            3671
+#define MACH_TYPE_CEDAR                3672
+#define MACH_TYPE_PICASSO_E            3673
+#define MACH_TYPE_SAMSUNG_E60          3674
+#define MACH_TYPE_MSM9615_CDP          3675
+#define MACH_TYPE_SDVR_MINI            3676
+#define MACH_TYPE_OMAP3_IJ3K           3677
+#define MACH_TYPE_MODASMC1             3678
+#define MACH_TYPE_APQ8064_RUMI3        3679
+#define MACH_TYPE_MATRIX506            3680
+#define MACH_TYPE_MSM9615_MTP          3681
+#define MACH_TYPE_DM36X_SPAWNDC        3682
+#define MACH_TYPE_SFF792               3683
+#define MACH_TYPE_AM335XIAEVM          3684
+#define MACH_TYPE_G3C2440              3685
+#define MACH_TYPE_TION270              3686
+#define MACH_TYPE_W22Q7ARM02           3687
+#define MACH_TYPE_OMAP_CAT             3688
+#define MACH_TYPE_AT91SAM9N12EK        3689
+#define MACH_TYPE_MORRISON             3690
+#define MACH_TYPE_SVDU                 3691
+#define MACH_TYPE_LPP01                3692
+#define MACH_TYPE_UBC283               3693
+#define MACH_TYPE_ZEPPELIN             3694
+#define MACH_TYPE_MOTUS                3695
+#define MACH_TYPE_NEOMAINBOARD         3696
+#define MACH_TYPE_DEVKIT3250           3697
+#define MACH_TYPE_DEVKIT7000           3698
+#define MACH_TYPE_FMC_UIC              3699
+#define MACH_TYPE_FMC_DCM              3700
+#define MACH_TYPE_BATWM                3701
+#define MACH_TYPE_ATLAS6CB             3702
+#define MACH_TYPE_BLUE                 3705
+#define MACH_TYPE_COLORADO             3706
+#define MACH_TYPE_POPC                 3707
+#define MACH_TYPE_PROMWAD_JADE         3708
+#define MACH_TYPE_AMP                  3709
+#define MACH_TYPE_GNET_AMP             3710
+#define MACH_TYPE_TOQUES               3711
+#define MACH_TYPE_DCT_STORM            3713
+#define MACH_TYPE_OWL                  3715
+#define MACH_TYPE_COGENT_CSB1741       3716
+#define MACH_TYPE_ADILLUSTRA610        3718
+#define MACH_TYPE_ECAFE_NA04           3719
+#define MACH_TYPE_POPCT                3720
+#define MACH_TYPE_OMAP3_HELENA         3721
+#define MACH_TYPE_ACH                  3722
+#define MACH_TYPE_MODULE_DTB           3723
+#define MACH_TYPE_OSLO_ELISABETH       3725
+#define MACH_TYPE_TT01                 3726
+#define MACH_TYPE_MSM8930_CDP          3727
+#define MACH_TYPE_MSM8930_MTP          3728
+#define MACH_TYPE_MSM8930_FLUID        3729
+#define MACH_TYPE_LTU11                3730
+#define MACH_TYPE_AM1808_SPAWNCO       3731
+#define MACH_TYPE_FLX6410              3732
+#define MACH_TYPE_MX6Q_QSB             3733
+#define MACH_TYPE_MX53_PLT424          3734
+#define MACH_TYPE_JASMINE              3735
+#define MACH_TYPE_L138_OWLBOARD_PLUS   3736
+#define MACH_TYPE_WR21                 3737
+#define MACH_TYPE_PEABOY               3739
+#define MACH_TYPE_MX28_PLATO           3740
+#define MACH_TYPE_KACOM2               3741
+#define MACH_TYPE_SLCO                 3742
+#define MACH_TYPE_IMX51PICO            3743
+#define MACH_TYPE_GLINK1               3744
+#define MACH_TYPE_DIAMOND              3745
+#define MACH_TYPE_D9000                3746
+#define MACH_TYPE_W5300E01             3747
+#define MACH_TYPE_IM6000               3748
+#define MACH_TYPE_MX51_FRED51          3749
+#define MACH_TYPE_STM32F2              3750
+#define MACH_TYPE_VILLE                3751
+#define MACH_TYPE_PTIP_MURNAU          3752
+#define MACH_TYPE_PTIP_CLASSIC         3753
+#define MACH_TYPE_MX53GRB              3754
+#define MACH_TYPE_GAGARIN              3755
+#define MACH_TYPE_MSM7627A_QRD1        3756
+#define MACH_TYPE_NAS2BIG              3757
+#define MACH_TYPE_SUPERFEMTO           3758
+#define MACH_TYPE_TEUFEL               3759
+#define MACH_TYPE_DINARA               3760
+#define MACH_TYPE_VANQUISH             3761
+#define MACH_TYPE_ZIPABOX1             3762
+#define MACH_TYPE_U9540                3763
+#define MACH_TYPE_JET                  3764
+#define MACH_TYPE_SMDK4412             3765
+#define MACH_TYPE_ELITE                3766
+#define MACH_TYPE_SPEAR320_HMI         3767
+#define MACH_TYPE_ONTARIO              3768
+#define MACH_TYPE_MX6Q_SABRELITE       3769
+#define MACH_TYPE_VC200                3770
+#define MACH_TYPE_MSM7625A_FFA         3771
+#define MACH_TYPE_MSM7625A_SURF        3772
+#define MACH_TYPE_BENTHOSSBP           3773
+#define MACH_TYPE_SMDK5210             3774
+#define MACH_TYPE_EMPQ2300             3775
+#define MACH_TYPE_MINIPOS              3776
+#define MACH_TYPE_OMAP5_SEVM           3777
+#define MACH_TYPE_SHELTER              3778
+#define MACH_TYPE_OMAP3_DEVKIT8500     3779
+#define MACH_TYPE_EDGETD               3780
+#define MACH_TYPE_COPPERYARD           3781
+#define MACH_TYPE_EDGE                 3782
+#define MACH_TYPE_EDGE_U               3783
+#define MACH_TYPE_EDGE_TD              3784
+#define MACH_TYPE_WDSS                 3785
+#define MACH_TYPE_DL_PB25              3786
+#define MACH_TYPE_DSS11                3787
+#define MACH_TYPE_CPA                  3788
+#define MACH_TYPE_APTP2000             3789
+#define MACH_TYPE_MARZEN               3790
+#define MACH_TYPE_ST_TURBINE           3791
+#define MACH_TYPE_GTL_IT3300           3792
+#define MACH_TYPE_MX6_MULE             3793
+#define MACH_TYPE_V7PXA_DT             3794
+#define MACH_TYPE_V7MMP_DT             3795
+#define MACH_TYPE_DRAGON7              3796
+#define MACH_TYPE_KROME                3797
+#define MACH_TYPE_ORATISDANTE          3798
+#define MACH_TYPE_FATHOM               3799
+#define MACH_TYPE_DNS325               3800
+#define MACH_TYPE_SARNEN               3801
+#define MACH_TYPE_UBISYS_G1            3802
+#define MACH_TYPE_MX53_PF1             3803
+#define MACH_TYPE_ASANTI               3804
+#define MACH_TYPE_VOLTA                3805
+#define MACH_TYPE_KNIGHT               3807
+#define MACH_TYPE_BEAGLEBONE           3808
+#define MACH_TYPE_BECKER               3809
+#define MACH_TYPE_FC360                3810
+#define MACH_TYPE_PMI2_XLS             3811
+#define MACH_TYPE_TARANTO              3812
+#define MACH_TYPE_PLUTUX               3813
+#define MACH_TYPE_IPMP_MEDCOM          3814
+#define MACH_TYPE_ABSOLUT              3815
+#define MACH_TYPE_AWPB3                3816
+#define MACH_TYPE_NFP32XX_DT           3817
+#define MACH_TYPE_DL_PB53              3818
+#define MACH_TYPE_ACU_II               3819
+#define MACH_TYPE_AVALON               3820
+#define MACH_TYPE_SPHINX               3821
+#define MACH_TYPE_TITAN_T              3822
+#define MACH_TYPE_HARVEST_BORIS        3823
+#define MACH_TYPE_MACH_MSM7X30_M3S     3824
+#define MACH_TYPE_SMDK5250             3825
+#define MACH_TYPE_IMXT_LITE            3826
+#define MACH_TYPE_IMXT_STD             3827
+#define MACH_TYPE_IMXT_LOG             3828
+#define MACH_TYPE_IMXT_NAV             3829
+#define MACH_TYPE_IMXT_FULL            3830
+#define MACH_TYPE_AG09015              3831
+#define MACH_TYPE_AM3517_MT_VENTOUX    3832
+#define MACH_TYPE_DP1ARM9              3833
+#define MACH_TYPE_PICASSO_M            3834
+#define MACH_TYPE_VIDEO_GADGET         3835
+#define MACH_TYPE_MTT_OM3X             3836
+#define MACH_TYPE_MX6Q_ARM2            3837
+#define MACH_TYPE_PICOSAM9G45          3838
+#define MACH_TYPE_VPM_DM365            3839
+#define MACH_TYPE_BONFIRE              3840
+#define MACH_TYPE_MT2P2D               3841
+#define MACH_TYPE_SIGPDA01             3842
+#define MACH_TYPE_CN27                 3843
+#define MACH_TYPE_MX25_CWTAP           3844
+#define MACH_TYPE_APF28                3845
+#define MACH_TYPE_PELCO_MAXWELL        3846
+#define MACH_TYPE_GE_PHOENIX           3847
+#define MACH_TYPE_EMPC_A500            3848
+#define MACH_TYPE_IMS_ARM9             3849
+#define MACH_TYPE_MINI2416             3850
+#define MACH_TYPE_MINI2450             3851
+#define MACH_TYPE_MINI310              3852
+#define MACH_TYPE_SPEAR_HURRICANE      3853
+#define MACH_TYPE_MT7208               3854
+#define MACH_TYPE_LPC178X              3855
+#define MACH_TYPE_FARLEYS              3856
+#define MACH_TYPE_EFM32GG_DK3750       3857
+#define MACH_TYPE_ZEUS_BOARD           3858
+#define MACH_TYPE_CC51                 3859
+#define MACH_TYPE_FXI_C210             3860
+#define MACH_TYPE_MSM8627_CDP          3861
+#define MACH_TYPE_MSM8627_MTP          3862
+#define MACH_TYPE_ARMADILLO800EVA      3863
+#define MACH_TYPE_PRIMOU               3864
+#define MACH_TYPE_PRIMOC               3865
+#define MACH_TYPE_PRIMOCT              3866
+#define MACH_TYPE_A9500                3867
+#define MACH_TYPE_PLUTO                3869
+#define MACH_TYPE_ACFX100              3870
+#define MACH_TYPE_MSM8625_RUMI3        3871
+#define MACH_TYPE_VALENTE              3872
+#define MACH_TYPE_CRFS_RFEYE           3873
+#define MACH_TYPE_RFEYE                3874
+#define MACH_TYPE_PHIDGET_SBC3         3875
+#define MACH_TYPE_TCW_MIKA             3876
+#define MACH_TYPE_IMX28_EGF            3877
+#define MACH_TYPE_VALENTE_WX           3878
+#define MACH_TYPE_HUANGSHANS           3879
+#define MACH_TYPE_BOSPHORUS1           3880
+#define MACH_TYPE_PRIMA                3881
+#define MACH_TYPE_EVITA_ULK            3884
+#define MACH_TYPE_MERISC600            3885
+#define MACH_TYPE_DOLAK                3886
+#define MACH_TYPE_SBC53                3887
+#define MACH_TYPE_ELITE_ULK            3888
+#define MACH_TYPE_POV2                 3889
+#define MACH_TYPE_IPOD_TOUCH_2G        3890
+#define MACH_TYPE_DA850_PQAB           3891
+#define MACH_TYPE_MSM7627A_EVB         3934
+#define MACH_TYPE_APQ8064_CDP          3948
+#define MACH_TYPE_APQ8064_MTP          3949
+#define MACH_TYPE_APQ8064_LIQUID       3951
+#define MACH_TYPE_MPQ8064_CDP          3993
+#define MACH_TYPE_MPQ8064_HRD          3994
+#define MACH_TYPE_MPQ8064_DTV          3995
+#define MACH_TYPE_MSM7627A_QRD3        4005
+#define MACH_TYPE_MSM8625_SURF         4037
+#define MACH_TYPE_MSM8625_EVB          4042
+#define MACH_TYPE_MSM8625_QRD7         4095
+#define MACH_TYPE_MSM8625_FFA          4166
+#define MACH_TYPE_MSM8625_EVT          4193
+#define MACH_TYPE_APQ8064_MAKO         7800
+#define MACH_TYPE_APQ8064_FLO          7801
+#define MACH_TYPE_APQ8064_DEB          7802
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMLD
+# endif
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
+#else
+# define machine_is_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTE2
+# endif
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
+#else
+# define machine_is_palmte2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTX
+# endif
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
+#else
+# define machine_is_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT5
+# endif
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
+#else
+# define machine_is_palmt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTC
+# endif
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
+#else
+# define machine_is_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
+# endif
+# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
+#else
+# define machine_is_omap_3430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO680
+# endif
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
+#else
+# define machine_is_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI320
+# endif
+# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
+#else
+# define machine_is_colibri320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAM60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAM60
+# endif
+# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
+#else
+# define machine_is_cam60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91EB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91EB01
+# endif
+# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
+#else
+# define machine_is_at91eb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F5281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F5281
+# endif
+# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
+#else
+# define machine_is_db88f5281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB726
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB726
+# endif
+# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
+#else
+# define machine_is_csb726()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
+# endif
+# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
+#else
+# define machine_is_davinci_dm6467_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
+# endif
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
+#else
+# define machine_is_davinci_dm355_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITTLETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITTLETON
+# endif
+# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
+#else
+# define machine_is_littleton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB11MP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
+# endif
+# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
+#else
+# define machine_is_realview_pb11mp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_3DS
+# endif
+# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
+#else
+# define machine_is_mx27_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALIBUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALIBUT
+# endif
+# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
+#else
+# define machine_is_halibut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROUT
+# endif
+# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
+#else
+# define machine_is_trout()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCT_HAMMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
+# endif
+# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
+#else
+# define machine_is_tct_hammer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERALD
+# endif
+# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
+#else
+# define machine_is_herald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIM_ONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIM_ONE
+# endif
+# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
+#else
+# define machine_is_sim_one()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIVE
+# endif
+# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
+#else
+# define machine_is_jive()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9260
+# endif
+# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
+#else
+# define machine_is_sam9_l9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
+# endif
+# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
+#else
+# define machine_is_realview_pb1176()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL9200
+# endif
+# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
+#else
+# define machine_is_yl9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5182
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5182
+# endif
+# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
+#else
+# define machine_is_rd88f5182()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KUROBOX_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
+# endif
+# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
+#else
+# define machine_is_kurobox_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_3DS
+# endif
+# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
+#else
+# define machine_is_mx31_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QONG
+# endif
+# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
+#else
+# define machine_is_qong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP2EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP2EVM
+# endif
+# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
+#else
+# define machine_is_omap2evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3EVM
+# endif
+# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
+#else
+# define machine_is_omap3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS323
+# endif
+# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
+#else
+# define machine_is_dns323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BEAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
+# endif
+# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
+#else
+# define machine_is_omap3_beagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810
+# endif
+# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
+#else
+# define machine_is_nokia_n810()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM038
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM038
+# endif
+# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
+#else
+# define machine_is_pcm038()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS209
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS209
+# endif
+# define machine_is_ts209()	(machine_arch_type == MACH_TYPE_TS209)
+#else
+# define machine_is_ts209()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9ADK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
+# endif
+# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
+#else
+# define machine_is_at91cap9adk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31MOBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
+# endif
+# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
+#else
+# define machine_is_mx31moboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VISION_EP9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VISION_EP9307
+# endif
+# define machine_is_vision_ep9307()	(machine_arch_type == MACH_TYPE_VISION_EP9307)
+#else
+# define machine_is_vision_ep9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_PRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
+# endif
+# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
+#else
+# define machine_is_terastation_pro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
+# endif
+# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
+#else
+# define machine_is_linkstation_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E350
+# endif
+# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
+#else
+# define machine_is_e350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS409
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS409
+# endif
+# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
+#else
+# define machine_is_ts409()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSI_EWS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSI_EWS
+# endif
+# define machine_is_rsi_ews()	(machine_arch_type == MACH_TYPE_RSI_EWS)
+#else
+# define machine_is_rsi_ews()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEUROS_OSD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
+# endif
+# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
+#else
+# define machine_is_neuros_osd2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
+# endif
+# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
+#else
+# define machine_is_davinci_da830_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB
+# endif
+# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
+#else
+# define machine_is_dove_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9G20
+# endif
+# define machine_is_usb_a9g20()	(machine_arch_type == MACH_TYPE_USB_A9G20)
+#else
+# define machine_is_usb_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX27
+# endif
+# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX27)
+#else
+# define machine_is_eukrea_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX37
+# endif
+# define machine_is_tx37()	(machine_arch_type == MACH_TYPE_TX37)
+#else
+# define machine_is_tx37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX25
+# endif
+# define machine_is_tx25()	(machine_arch_type == MACH_TYPE_TX25)
+#else
+# define machine_is_tx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEXPRESS
+# endif
+# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
+#else
+# define machine_is_vexpress()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6442
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6442
+# endif
+# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
+#else
+# define machine_is_smdk6442()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
+# endif
+# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
+#else
+# define machine_is_openrd_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT8000
+# endif
+# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
+#else
+# define machine_is_devkit8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
+# endif
+# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
+#else
+# define machine_is_mx51_efikamx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T35
+# endif
+# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
+#else
+# define machine_is_cm_t35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG
+# endif
+# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
+#else
+# define machine_is_net2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0020
+# endif
+# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
+#else
+# define machine_is_igep0020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC932EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC932EVB
+# endif
+# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
+#else
+# define machine_is_nuc932evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_CLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
+# endif
+# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
+#else
+# define machine_is_openrd_client()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U8500
+# endif
+# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
+#else
+# define machine_is_u8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
+# endif
+# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
+#else
+# define machine_is_mx51_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
+# endif
+# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
+#else
+# define machine_is_marvell_jasper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLINT
+# endif
+# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
+#else
+# define machine_is_flint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB3
+# endif
+# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
+#else
+# define machine_is_tavorevb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
+# endif
+# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
+#else
+# define machine_is_touchbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_RC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
+# endif
+# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
+#else
+# define machine_is_raumfeld_rc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
+# endif
+# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
+#else
+# define machine_is_raumfeld_connector()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
+# endif
+# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
+#else
+# define machine_is_raumfeld_speaker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNETV107X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNETV107X
+# endif
+# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
+#else
+# define machine_is_tnetv107x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_M2ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_M2ID
+# endif
+# define machine_is_mx51_m2id()	(machine_arch_type == MACH_TYPE_MX51_M2ID)
+#else
+# define machine_is_mx51_m2id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX51
+# endif
+# define machine_is_tx51()	(machine_arch_type == MACH_TYPE_TX51)
+#else
+# define machine_is_tx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_BEI2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_BEI2
+# endif
+# define machine_is_riot_bei2()	(machine_arch_type == MACH_TYPE_RIOT_BEI2)
+#else
+# define machine_is_riot_bei2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_X37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_X37
+# endif
+# define machine_is_riot_x37()	(machine_arch_type == MACH_TYPE_RIOT_X37)
+#else
+# define machine_is_riot_x37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA101
+# endif
+# define machine_is_pca101()	(machine_arch_type == MACH_TYPE_PCA101)
+#else
+# define machine_is_pca101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAPC7117
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAPC7117
+# endif
+# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
+#else
+# define machine_is_capc7117()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTROL
+# endif
+# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
+#else
+# define machine_is_icontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPLUGD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPLUGD
+# endif
+# define machine_is_gplugd()	(machine_arch_type == MACH_TYPE_GPLUGD)
+#else
+# define machine_is_gplugd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
+# endif
+# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
+#else
+# define machine_is_qsd8x50a_st1_5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX23EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX23EVK
+# endif
+# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
+#else
+# define machine_is_mx23evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP4EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP4EVB
+# endif
+# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
+#else
+# define machine_is_ap4evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MITYOMAPL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
+# endif
+# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
+#else
+# define machine_is_mityomapl138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURUPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURUPLUG
+# endif
+# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
+#else
+# define machine_is_guruplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR310
+# endif
+# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
+#else
+# define machine_is_spear310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320
+# endif
+# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
+#else
+# define machine_is_spear320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUILA
+# endif
+# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
+#else
+# define machine_is_aquila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
+# endif
+# define machine_is_esata_sheevaplug()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
+#else
+# define machine_is_esata_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
+# endif
+# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
+#else
+# define machine_is_msm7x30_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA2478DEVKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA2478DEVKIT
+# endif
+# define machine_is_ea2478devkit()	(machine_arch_type == MACH_TYPE_EA2478DEVKIT)
+#else
+# define machine_is_ea2478devkit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_WXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
+# endif
+# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
+#else
+# define machine_is_terastation_wxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
+# endif
+# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
+#else
+# define machine_is_msm7x25_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
+# endif
+# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
+#else
+# define machine_is_msm7x25_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
+# endif
+# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
+#else
+# define machine_is_msm7x27_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
+# endif
+# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
+#else
+# define machine_is_msm7x27_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
+# endif
+# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
+#else
+# define machine_is_msm7x30_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
+# endif
+# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
+#else
+# define machine_is_qsd8x50_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_FFA
+# endif
+# define machine_is_qsd8x50_ffa()	(machine_arch_type == MACH_TYPE_QSD8X50_FFA)
+#else
+# define machine_is_qsd8x50_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EVK
+# endif
+# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
+#else
+# define machine_is_mx53_evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0030
+# endif
+# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
+#else
+# define machine_is_igep0030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC3530
+# endif
+# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
+#else
+# define machine_is_sbc3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB
+# endif
+# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
+#else
+# define machine_is_saarb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARMONY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARMONY
+# endif
+# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
+#else
+# define machine_is_harmony()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
+# endif
+# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
+#else
+# define machine_is_msm7x30_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3517
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3517
+# endif
+# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
+#else
+# define machine_is_cm_t3517()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD222
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD222
+# endif
+# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
+#else
+# define machine_is_wbd222()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
+# endif
+# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
+#else
+# define machine_is_msm8x60_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
+# endif
+# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
+#else
+# define machine_is_msm8x60_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC8000_SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
+# endif
+# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
+#else
+# define machine_is_tcc8000_sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOS
+# endif
+# define machine_is_nanos()	(machine_arch_type == MACH_TYPE_NANOS)
+#else
+# define machine_is_nanos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G45
+# endif
+# define machine_is_stamp9g45()	(machine_arch_type == MACH_TYPE_STAMP9G45)
+#else
+# define machine_is_stamp9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SURF
+# endif
+# define machine_is_msm8x55_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SURF)
+#else
+# define machine_is_msm8x55_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_FFA
+# endif
+# define machine_is_msm8x55_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_FFA)
+#else
+# define machine_is_msm8x55_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS3420VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS3420VB
+# endif
+# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
+#else
+# define machine_is_cns3420vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP4_PANDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
+# endif
+# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
+#else
+# define machine_is_omap4_panda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8168EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8168EVM
+# endif
+# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
+#else
+# define machine_is_ti8168evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON_BGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON_BGA
+# endif
+# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
+#else
+# define machine_is_teton_bga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX25SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25SD
+# endif
+# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25SD)
+#else
+# define machine_is_eukrea_cpuimx25sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX35SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35SD
+# endif
+# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35SD)
+#else
+# define machine_is_eukrea_cpuimx35sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
+# endif
+# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
+#else
+# define machine_is_eukrea_cpuimx51sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
+# endif
+# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
+#else
+# define machine_is_eukrea_cpuimx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC210
+# endif
+# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
+#else
+# define machine_is_smdkc210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA102
+# endif
+# define machine_is_pca102()	(machine_arch_type == MACH_TYPE_PCA102)
+#else
+# define machine_is_pca102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5325
+# endif
+# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
+#else
+# define machine_is_t5325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCOME
+# endif
+# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
+#else
+# define machine_is_income()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDORIG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDORIG2
+# endif
+# define machine_is_vvbox_sdorig2()	(machine_arch_type == MACH_TYPE_VVBOX_SDORIG2)
+#else
+# define machine_is_vvbox_sdorig2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDLITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDLITE2
+# endif
+# define machine_is_vvbox_sdlite2()	(machine_arch_type == MACH_TYPE_VVBOX_SDLITE2)
+#else
+# define machine_is_vvbox_sdlite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDPRO4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDPRO4
+# endif
+# define machine_is_vvbox_sdpro4()	(machine_arch_type == MACH_TYPE_VVBOX_SDPRO4)
+#else
+# define machine_is_vvbox_sdpro4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SX
+# endif
+# define machine_is_mx257sx()	(machine_arch_type == MACH_TYPE_MX257SX)
+#else
+# define machine_is_mx257sx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GONI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONI
+# endif
+# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
+#else
+# define machine_is_goni()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_FFA
+# endif
+# define machine_is_msm8x55_svlte_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_FFA)
+#else
+# define machine_is_msm8x55_svlte_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_SURF
+# endif
+# define machine_is_msm8x55_svlte_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_SURF)
+#else
+# define machine_is_msm8x55_svlte_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BV07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BV07
+# endif
+# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
+#else
+# define machine_is_bv07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_ULTIMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
+# endif
+# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
+#else
+# define machine_is_openrd_ultimate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVIXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVIXP
+# endif
+# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
+#else
+# define machine_is_devixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICCPT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICCPT
+# endif
+# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
+#else
+# define machine_is_miccpt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIC256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIC256
+# endif
+# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
+#else
+# define machine_is_mic256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U5500
+# endif
+# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
+#else
+# define machine_is_u5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LSCHL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
+# endif
+# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
+#else
+# define machine_is_linkstation_lschl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV310
+# endif
+# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
+#else
+# define machine_is_smdkv310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
+# endif
+# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
+#else
+# define machine_is_wm8505_7in_netbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRANEBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRANEBOARD
+# endif
+# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
+#else
+# define machine_is_craneboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6450
+# endif
+# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
+#else
+# define machine_is_smdk6450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BROWNSTONE
+# endif
+# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
+#else
+# define machine_is_brownstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEXIBITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXIBITY
+# endif
+# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
+#else
+# define machine_is_flexibity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_RDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_RDP
+# endif
+# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
+#else
+# define machine_is_mx50_rdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSAL_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
+# endif
+# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
+#else
+# define machine_is_universal_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REAL6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REAL6410
+# endif
+# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
+#else
+# define machine_is_real6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOCKSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOCKSTAR
+# endif
+# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
+#else
+# define machine_is_dockstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8148EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8148EVM
+# endif
+# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
+#else
+# define machine_is_ti8148evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABOARD
+# endif
+# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
+#else
+# define machine_is_seaboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_ARD
+# endif
+# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
+#else
+# define machine_is_mx53_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_SMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_SMD
+# endif
+# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
+#else
+# define machine_is_mx53_smd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
+# endif
+# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
+#else
+# define machine_is_msm8x60_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
+# endif
+# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
+#else
+# define machine_is_msm8x60_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_A510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_A510
+# endif
+# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
+#else
+# define machine_is_cm_a510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_SURF
+# endif
+# define machine_is_fsm9xxx_surf()	(machine_arch_type == MACH_TYPE_FSM9XXX_SURF)
+#else
+# define machine_is_fsm9xxx_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_FFA
+# endif
+# define machine_is_fsm9xxx_ffa()	(machine_arch_type == MACH_TYPE_FSM9XXX_FFA)
+#else
+# define machine_is_fsm9xxx_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX28
+# endif
+# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
+#else
+# define machine_is_tx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCONTROL_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
+# endif
+# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
+#else
+# define machine_is_pcontrol_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPR200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPR200
+# endif
+# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
+#else
+# define machine_is_vpr200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORBRECK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORBRECK
+# endif
+# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
+#else
+# define machine_is_torbreck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA2_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
+# endif
+# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
+#else
+# define machine_is_prima2_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FLUID
+# endif
+# define machine_is_msm8x60_fluid()	(machine_arch_type == MACH_TYPE_MSM8X60_FLUID)
+#else
+# define machine_is_msm8x60_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PAZ00
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PAZ00
+# endif
+# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
+#else
+# define machine_is_paz00()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMENETUSFOXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
+# endif
+# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
+#else
+# define machine_is_acmenetusfoxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FUSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FUSION
+# endif
+# define machine_is_msm8x60_fusion()	(machine_arch_type == MACH_TYPE_MSM8X60_FUSION)
+#else
+# define machine_is_msm8x60_fusion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG5EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG5EVM
+# endif
+# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
+#else
+# define machine_is_ag5evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSUNAGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSUNAGI
+# endif
+# define machine_is_tsunagi()	(machine_arch_type == MACH_TYPE_TSUNAGI)
+#else
+# define machine_is_tsunagi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FUSN_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FUSN_FFA
+# endif
+# define machine_is_msm8x60_fusn_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FUSN_FFA)
+#else
+# define machine_is_msm8x60_fusn_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICS_IF_VOIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
+# endif
+# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
+#else
+# define machine_is_ics_if_voip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLF_CRAGG_6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
+# endif
+# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
+#else
+# define machine_is_wlf_cragg_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIMSLICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIMSLICE
+# endif
+# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
+#else
+# define machine_is_trimslice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACKEREL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACKEREL
+# endif
+# define machine_is_mackerel()	(machine_arch_type == MACH_TYPE_MACKEREL)
+#else
+# define machine_is_mackerel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAEN
+# endif
+# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
+#else
+# define machine_is_kaen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
+# endif
+# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
+#else
+# define machine_is_nokia_rm680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6446_ADBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6446_ADBOX
+# endif
+# define machine_is_dm6446_adbox()	(machine_arch_type == MACH_TYPE_DM6446_ADBOX)
+#else
+# define machine_is_dm6446_adbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUAD_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUAD_SALSA
+# endif
+# define machine_is_quad_salsa()	(machine_arch_type == MACH_TYPE_QUAD_SALSA)
+#else
+# define machine_is_quad_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABB_GMA_1_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABB_GMA_1_1
+# endif
+# define machine_is_abb_gma_1_1()	(machine_arch_type == MACH_TYPE_ABB_GMA_1_1)
+#else
+# define machine_is_abb_gma_1_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVCID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVCID
+# endif
+# define machine_is_svcid()	(machine_arch_type == MACH_TYPE_SVCID)
+#else
+# define machine_is_svcid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
+# endif
+# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
+#else
+# define machine_is_msm8960_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
+# endif
+# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
+#else
+# define machine_is_msm8960_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON_G
+# endif
+# define machine_is_icon_g()	(machine_arch_type == MACH_TYPE_ICON_G)
+#else
+# define machine_is_icon_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB3
+# endif
+# define machine_is_mb3()	(machine_arch_type == MACH_TYPE_MB3)
+#else
+# define machine_is_mb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSIA18S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSIA18S
+# endif
+# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
+#else
+# define machine_is_gsia18s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIVICC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIVICC
+# endif
+# define machine_is_pivicc()	(machine_arch_type == MACH_TYPE_PIVICC)
+#else
+# define machine_is_pivicc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM048
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM048
+# endif
+# define machine_is_pcm048()	(machine_arch_type == MACH_TYPE_PCM048)
+#else
+# define machine_is_pcm048()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDS
+# endif
+# define machine_is_dds()	(machine_arch_type == MACH_TYPE_DDS)
+#else
+# define machine_is_dds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHALTEN_XA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHALTEN_XA1
+# endif
+# define machine_is_chalten_xa1()	(machine_arch_type == MACH_TYPE_CHALTEN_XA1)
+#else
+# define machine_is_chalten_xa1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS48XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS48XX
+# endif
+# define machine_is_ts48xx()	(machine_arch_type == MACH_TYPE_TS48XX)
+#else
+# define machine_is_ts48xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TONGA2_TFTTIMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TONGA2_TFTTIMER
+# endif
+# define machine_is_tonga2_tfttimer()	(machine_arch_type == MACH_TYPE_TONGA2_TFTTIMER)
+#else
+# define machine_is_tonga2_tfttimer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHISTLER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHISTLER
+# endif
+# define machine_is_whistler()	(machine_arch_type == MACH_TYPE_WHISTLER)
+#else
+# define machine_is_whistler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASL_PHOENIX
+# endif
+# define machine_is_asl_phoenix()	(machine_arch_type == MACH_TYPE_ASL_PHOENIX)
+#else
+# define machine_is_asl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263OTLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263OTLITE
+# endif
+# define machine_is_at91sam9263otlite()	(machine_arch_type == MACH_TYPE_AT91SAM9263OTLITE)
+#else
+# define machine_is_at91sam9263otlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDPLUG
+# endif
+# define machine_is_ddplug()	(machine_arch_type == MACH_TYPE_DDPLUG)
+#else
+# define machine_is_ddplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2PLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2PLUG
+# endif
+# define machine_is_d2plug()	(machine_arch_type == MACH_TYPE_D2PLUG)
+#else
+# define machine_is_d2plug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM9D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM9D
+# endif
+# define machine_is_kzm9d()	(machine_arch_type == MACH_TYPE_KZM9D)
+#else
+# define machine_is_kzm9d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI_LTE
+# endif
+# define machine_is_verdi_lte()	(machine_arch_type == MACH_TYPE_VERDI_LTE)
+#else
+# define machine_is_verdi_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOZOOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOZOOM
+# endif
+# define machine_is_nanozoom()	(machine_arch_type == MACH_TYPE_NANOZOOM)
+#else
+# define machine_is_nanozoom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_SOM_LV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_SOM_LV
+# endif
+# define machine_is_dm3730_som_lv()	(machine_arch_type == MACH_TYPE_DM3730_SOM_LV)
+#else
+# define machine_is_dm3730_som_lv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_TORPEDO
+# endif
+# define machine_is_dm3730_torpedo()	(machine_arch_type == MACH_TYPE_DM3730_TORPEDO)
+#else
+# define machine_is_dm3730_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANCHOVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANCHOVY
+# endif
+# define machine_is_anchovy()	(machine_arch_type == MACH_TYPE_ANCHOVY)
+#else
+# define machine_is_anchovy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV20
+# endif
+# define machine_is_re2rev20()	(machine_arch_type == MACH_TYPE_RE2REV20)
+#else
+# define machine_is_re2rev20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV21
+# endif
+# define machine_is_re2rev21()	(machine_arch_type == MACH_TYPE_RE2REV21)
+#else
+# define machine_is_re2rev21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS21XX
+# endif
+# define machine_is_cns21xx()	(machine_arch_type == MACH_TYPE_CNS21XX)
+#else
+# define machine_is_cns21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIDER
+# endif
+# define machine_is_rider()	(machine_arch_type == MACH_TYPE_RIDER)
+#else
+# define machine_is_rider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSK330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSK330
+# endif
+# define machine_is_nsk330()	(machine_arch_type == MACH_TYPE_NSK330)
+#else
+# define machine_is_nsk330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS2133EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS2133EVB
+# endif
+# define machine_is_cns2133evb()	(machine_arch_type == MACH_TYPE_CNS2133EVB)
+#else
+# define machine_is_cns2133evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_816X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_816X_MOD
+# endif
+# define machine_is_z3_816x_mod()	(machine_arch_type == MACH_TYPE_Z3_816X_MOD)
+#else
+# define machine_is_z3_816x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_814X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_814X_MOD
+# endif
+# define machine_is_z3_814x_mod()	(machine_arch_type == MACH_TYPE_Z3_814X_MOD)
+#else
+# define machine_is_z3_814x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEECT
+# endif
+# define machine_is_beect()	(machine_arch_type == MACH_TYPE_BEECT)
+#else
+# define machine_is_beect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA_THUNDERBUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA_THUNDERBUG
+# endif
+# define machine_is_dma_thunderbug()	(machine_arch_type == MACH_TYPE_DMA_THUNDERBUG)
+#else
+# define machine_is_dma_thunderbug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMN_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMN_AT91SAM9G20
+# endif
+# define machine_is_omn_at91sam9g20()	(machine_arch_type == MACH_TYPE_OMN_AT91SAM9G20)
+#else
+# define machine_is_omn_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_E2S_UC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_E2S_UC
+# endif
+# define machine_is_mx25_e2s_uc()	(machine_arch_type == MACH_TYPE_MX25_E2S_UC)
+#else
+# define machine_is_mx25_e2s_uc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIONE
+# endif
+# define machine_is_mione()	(machine_arch_type == MACH_TYPE_MIONE)
+#else
+# define machine_is_mione()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_TCU
+# endif
+# define machine_is_top9000_tcu()	(machine_arch_type == MACH_TYPE_TOP9000_TCU)
+#else
+# define machine_is_top9000_tcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_BSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_BSL
+# endif
+# define machine_is_top9000_bsl()	(machine_arch_type == MACH_TYPE_TOP9000_BSL)
+#else
+# define machine_is_top9000_bsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KINGDOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGDOM
+# endif
+# define machine_is_kingdom()	(machine_arch_type == MACH_TYPE_KINGDOM)
+#else
+# define machine_is_kingdom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO460
+# endif
+# define machine_is_armadillo460()	(machine_arch_type == MACH_TYPE_ARMADILLO460)
+#else
+# define machine_is_armadillo460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LQ2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LQ2
+# endif
+# define machine_is_lq2()	(machine_arch_type == MACH_TYPE_LQ2)
+#else
+# define machine_is_lq2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDA_TMS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDA_TMS2
+# endif
+# define machine_is_sweda_tms2()	(machine_arch_type == MACH_TYPE_SWEDA_TMS2)
+#else
+# define machine_is_sweda_tms2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_LOCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_LOCO
+# endif
+# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
+#else
+# define machine_is_mx53_loco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A8
+# endif
+# define machine_is_acer_a8()	(machine_arch_type == MACH_TYPE_ACER_A8)
+#else
+# define machine_is_acer_a8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_GAUGUIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_GAUGUIN
+# endif
+# define machine_is_acer_gauguin()	(machine_arch_type == MACH_TYPE_ACER_GAUGUIN)
+#else
+# define machine_is_acer_gauguin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUPPY
+# endif
+# define machine_is_guppy()	(machine_arch_type == MACH_TYPE_GUPPY)
+#else
+# define machine_is_guppy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX61_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX61_ARD
+# endif
+# define machine_is_mx61_ard()	(machine_arch_type == MACH_TYPE_MX61_ARD)
+#else
+# define machine_is_mx61_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX53
+# endif
+# define machine_is_tx53()	(machine_arch_type == MACH_TYPE_TX53)
+#else
+# define machine_is_tx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_CASE_A3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_CASE_A3
+# endif
+# define machine_is_omapl138_case_a3()	(machine_arch_type == MACH_TYPE_OMAPL138_CASE_A3)
+#else
+# define machine_is_omapl138_case_a3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEMD
+# endif
+# define machine_is_uemd()	(machine_arch_type == MACH_TYPE_UEMD)
+#else
+# define machine_is_uemd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51MUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51MUT
+# endif
+# define machine_is_ccwmx51mut()	(machine_arch_type == MACH_TYPE_CCWMX51MUT)
+#else
+# define machine_is_ccwmx51mut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROCKHOPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROCKHOPPER
+# endif
+# define machine_is_rockhopper()	(machine_arch_type == MACH_TYPE_ROCKHOPPER)
+#else
+# define machine_is_rockhopper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENCORE
+# endif
+# define machine_is_encore()	(machine_arch_type == MACH_TYPE_ENCORE)
+#else
+# define machine_is_encore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HKDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HKDKC100
+# endif
+# define machine_is_hkdkc100()	(machine_arch_type == MACH_TYPE_HKDKC100)
+#else
+# define machine_is_hkdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS42XX
+# endif
+# define machine_is_ts42xx()	(machine_arch_type == MACH_TYPE_TS42XX)
+#else
+# define machine_is_ts42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AEBL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AEBL
+# endif
+# define machine_is_aebl()	(machine_arch_type == MACH_TYPE_AEBL)
+#else
+# define machine_is_aebl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WARIO
+# endif
+# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
+#else
+# define machine_is_wario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GFS_SPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GFS_SPM
+# endif
+# define machine_is_gfs_spm()	(machine_arch_type == MACH_TYPE_GFS_SPM)
+#else
+# define machine_is_gfs_spm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3730
+# endif
+# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
+#else
+# define machine_is_cm_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISC3
+# endif
+# define machine_is_isc3()	(machine_arch_type == MACH_TYPE_ISC3)
+#else
+# define machine_is_isc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RASCAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RASCAL
+# endif
+# define machine_is_rascal()	(machine_arch_type == MACH_TYPE_RASCAL)
+#else
+# define machine_is_rascal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HREFV60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HREFV60
+# endif
+# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
+#else
+# define machine_is_hrefv60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPT_2_0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPT_2_0
+# endif
+# define machine_is_tpt_2_0()	(machine_arch_type == MACH_TYPE_TPT_2_0)
+#else
+# define machine_is_tpt_2_0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPLENDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPLENDOR
+# endif
+# define machine_is_splendor()	(machine_arch_type == MACH_TYPE_SPLENDOR)
+#else
+# define machine_is_splendor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QT
+# endif
+# define machine_is_msm8x60_qt()	(machine_arch_type == MACH_TYPE_MSM8X60_QT)
+#else
+# define machine_is_msm8x60_qt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_HD_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_HD_MINI
+# endif
+# define machine_is_htc_hd_mini()	(machine_arch_type == MACH_TYPE_HTC_HD_MINI)
+#else
+# define machine_is_htc_hd_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATHENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATHENE
+# endif
+# define machine_is_athene()	(machine_arch_type == MACH_TYPE_ATHENE)
+#else
+# define machine_is_athene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEEP_R_EK_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEEP_R_EK_1
+# endif
+# define machine_is_deep_r_ek_1()	(machine_arch_type == MACH_TYPE_DEEP_R_EK_1)
+#else
+# define machine_is_deep_r_ek_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_CT
+# endif
+# define machine_is_vivow_ct()	(machine_arch_type == MACH_TYPE_VIVOW_CT)
+#else
+# define machine_is_vivow_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NERY_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NERY_1000
+# endif
+# define machine_is_nery_1000()	(machine_arch_type == MACH_TYPE_NERY_1000)
+#else
+# define machine_is_nery_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL109145_SSRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL109145_SSRV
+# endif
+# define machine_is_rfl109145_ssrv()	(machine_arch_type == MACH_TYPE_RFL109145_SSRV)
+#else
+# define machine_is_rfl109145_ssrv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NMH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMH
+# endif
+# define machine_is_nmh()	(machine_arch_type == MACH_TYPE_NMH)
+#else
+# define machine_is_nmh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WN802T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WN802T
+# endif
+# define machine_is_wn802t()	(machine_arch_type == MACH_TYPE_WN802T)
+#else
+# define machine_is_wn802t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGONET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGONET
+# endif
+# define machine_is_dragonet()	(machine_arch_type == MACH_TYPE_DRAGONET)
+#else
+# define machine_is_dragonet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263DESK16L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESK16L
+# endif
+# define machine_is_at91sam9263desk16l()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESK16L)
+#else
+# define machine_is_at91sam9263desk16l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_SV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_SV
+# endif
+# define machine_is_bcmhana_sv()	(machine_arch_type == MACH_TYPE_BCMHANA_SV)
+#else
+# define machine_is_bcmhana_sv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_TABLET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_TABLET
+# endif
+# define machine_is_bcmhana_tablet()	(machine_arch_type == MACH_TYPE_BCMHANA_TABLET)
+#else
+# define machine_is_bcmhana_tablet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOI
+# endif
+# define machine_is_koi()	(machine_arch_type == MACH_TYPE_KOI)
+#else
+# define machine_is_koi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS4800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS4800
+# endif
+# define machine_is_ts4800()	(machine_arch_type == MACH_TYPE_TS4800)
+#else
+# define machine_is_ts4800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA9263
+# endif
+# define machine_is_tqma9263()	(machine_arch_type == MACH_TYPE_TQMA9263)
+#else
+# define machine_is_tqma9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOLIDAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOLIDAY
+# endif
+# define machine_is_holiday()	(machine_arch_type == MACH_TYPE_HOLIDAY)
+#else
+# define machine_is_holiday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCATS_OVERLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCATS_OVERLAY
+# endif
+# define machine_is_pcats_overlay()	(machine_arch_type == MACH_TYPE_PCATS_OVERLAY)
+#else
+# define machine_is_pcats_overlay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HWGW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HWGW6410
+# endif
+# define machine_is_hwgw6410()	(machine_arch_type == MACH_TYPE_HWGW6410)
+#else
+# define machine_is_hwgw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHENZHOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHENZHOU
+# endif
+# define machine_is_shenzhou()	(machine_arch_type == MACH_TYPE_SHENZHOU)
+#else
+# define machine_is_shenzhou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210
+# endif
+# define machine_is_cwme9210()	(machine_arch_type == MACH_TYPE_CWME9210)
+#else
+# define machine_is_cwme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210JS
+# endif
+# define machine_is_cwme9210js()	(machine_arch_type == MACH_TYPE_CWME9210JS)
+#else
+# define machine_is_cwme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI_TEGRA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI_TEGRA2
+# endif
+# define machine_is_colibri_tegra2()	(machine_arch_type == MACH_TYPE_COLIBRI_TEGRA2)
+#else
+# define machine_is_colibri_tegra2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W21
+# endif
+# define machine_is_w21()	(machine_arch_type == MACH_TYPE_W21)
+#else
+# define machine_is_w21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLYSAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLYSAT1
+# endif
+# define machine_is_polysat1()	(machine_arch_type == MACH_TYPE_POLYSAT1)
+#else
+# define machine_is_polysat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATAWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATAWAY
+# endif
+# define machine_is_dataway()	(machine_arch_type == MACH_TYPE_DATAWAY)
+#else
+# define machine_is_dataway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBRAL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBRAL138
+# endif
+# define machine_is_cobral138()	(machine_arch_type == MACH_TYPE_COBRAL138)
+#else
+# define machine_is_cobral138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERPCS8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERPCS8
+# endif
+# define machine_is_roverpcs8()	(machine_arch_type == MACH_TYPE_ROVERPCS8)
+#else
+# define machine_is_roverpcs8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELC
+# endif
+# define machine_is_marvelc()	(machine_arch_type == MACH_TYPE_MARVELC)
+#else
+# define machine_is_marvelc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVEFIHID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVEFIHID
+# endif
+# define machine_is_navefihid()	(machine_arch_type == MACH_TYPE_NAVEFIHID)
+#else
+# define machine_is_navefihid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM365_CV100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM365_CV100
+# endif
+# define machine_is_dm365_cv100()	(machine_arch_type == MACH_TYPE_DM365_CV100)
+#else
+# define machine_is_dm365_cv100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABLE
+# endif
+# define machine_is_able()	(machine_arch_type == MACH_TYPE_ABLE)
+#else
+# define machine_is_able()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGACY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGACY
+# endif
+# define machine_is_legacy()	(machine_arch_type == MACH_TYPE_LEGACY)
+#else
+# define machine_is_legacy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONG
+# endif
+# define machine_is_icong()	(machine_arch_type == MACH_TYPE_ICONG)
+#else
+# define machine_is_icong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_G8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_G8
+# endif
+# define machine_is_rover_g8()	(machine_arch_type == MACH_TYPE_ROVER_G8)
+#else
+# define machine_is_rover_g8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5388P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5388P
+# endif
+# define machine_is_t5388p()	(machine_arch_type == MACH_TYPE_T5388P)
+#else
+# define machine_is_t5388p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINGO
+# endif
+# define machine_is_dingo()	(machine_arch_type == MACH_TYPE_DINGO)
+#else
+# define machine_is_dingo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXHOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXHOME
+# endif
+# define machine_is_goflexhome()	(machine_arch_type == MACH_TYPE_GOFLEXHOME)
+#else
+# define machine_is_goflexhome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN511
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN511
+# endif
+# define machine_is_lanreadyfn511()	(machine_arch_type == MACH_TYPE_LANREADYFN511)
+#else
+# define machine_is_lanreadyfn511()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BAIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BAIA
+# endif
+# define machine_is_omap3_baia()	(machine_arch_type == MACH_TYPE_OMAP3_BAIA)
+#else
+# define machine_is_omap3_baia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SMARTDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SMARTDISPLAY
+# endif
+# define machine_is_omap3smartdisplay()	(machine_arch_type == MACH_TYPE_OMAP3SMARTDISPLAY)
+#else
+# define machine_is_omap3smartdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX
+# endif
+# define machine_is_xilinx()	(machine_arch_type == MACH_TYPE_XILINX)
+#else
+# define machine_is_xilinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A2F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A2F
+# endif
+# define machine_is_a2f()	(machine_arch_type == MACH_TYPE_A2F)
+#else
+# define machine_is_a2f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY25
+# endif
+# define machine_is_sky25()	(machine_arch_type == MACH_TYPE_SKY25)
+#else
+# define machine_is_sky25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53
+# endif
+# define machine_is_ccmx53()	(machine_arch_type == MACH_TYPE_CCMX53)
+#else
+# define machine_is_ccmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53JS
+# endif
+# define machine_is_ccmx53js()	(machine_arch_type == MACH_TYPE_CCMX53JS)
+#else
+# define machine_is_ccmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53
+# endif
+# define machine_is_ccwmx53()	(machine_arch_type == MACH_TYPE_CCWMX53)
+#else
+# define machine_is_ccwmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53JS
+# endif
+# define machine_is_ccwmx53js()	(machine_arch_type == MACH_TYPE_CCWMX53JS)
+#else
+# define machine_is_ccwmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRISMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRISMS
+# endif
+# define machine_is_frisms()	(machine_arch_type == MACH_TYPE_FRISMS)
+#else
+# define machine_is_frisms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_FFA
+# endif
+# define machine_is_msm7x27a_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27A_FFA)
+#else
+# define machine_is_msm7x27a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_SURF
+# endif
+# define machine_is_msm7x27a_surf()	(machine_arch_type == MACH_TYPE_MSM7X27A_SURF)
+#else
+# define machine_is_msm7x27a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_RUMI3
+# endif
+# define machine_is_msm7x27a_rumi3()	(machine_arch_type == MACH_TYPE_MSM7X27A_RUMI3)
+#else
+# define machine_is_msm7x27a_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMSAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMSAM9G20
+# endif
+# define machine_is_dimmsam9g20()	(machine_arch_type == MACH_TYPE_DIMMSAM9G20)
+#else
+# define machine_is_dimmsam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_IMX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_IMX28
+# endif
+# define machine_is_dimm_imx28()	(machine_arch_type == MACH_TYPE_DIMM_IMX28)
+#else
+# define machine_is_dimm_imx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMK_A4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMK_A4
+# endif
+# define machine_is_amk_a4()	(machine_arch_type == MACH_TYPE_AMK_A4)
+#else
+# define machine_is_amk_a4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGME
+# endif
+# define machine_is_gnet_sgme()	(machine_arch_type == MACH_TYPE_GNET_SGME)
+#else
+# define machine_is_gnet_sgme()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_U
+# endif
+# define machine_is_shooter_u()	(machine_arch_type == MACH_TYPE_SHOOTER_U)
+#else
+# define machine_is_shooter_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX53
+# endif
+# define machine_is_vmx53()	(machine_arch_type == MACH_TYPE_VMX53)
+#else
+# define machine_is_vmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHINO
+# endif
+# define machine_is_rhino()	(machine_arch_type == MACH_TYPE_RHINO)
+#else
+# define machine_is_rhino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLEX4210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLEX4210
+# endif
+# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
+#else
+# define machine_is_armlex4210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOEXTMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOEXTMODEM
+# endif
+# define machine_is_swarcoextmodem()	(machine_arch_type == MACH_TYPE_SWARCOEXTMODEM)
+#else
+# define machine_is_swarcoextmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNOWBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNOWBALL
+# endif
+# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
+#else
+# define machine_is_snowball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM049
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM049
+# endif
+# define machine_is_pcm049()	(machine_arch_type == MACH_TYPE_PCM049)
+#else
+# define machine_is_pcm049()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIGOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIGOR
+# endif
+# define machine_is_vigor()	(machine_arch_type == MACH_TYPE_VIGOR)
+#else
+# define machine_is_vigor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_AMUNDSEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_AMUNDSEN
+# endif
+# define machine_is_oslo_amundsen()	(machine_arch_type == MACH_TYPE_OSLO_AMUNDSEN)
+#else
+# define machine_is_oslo_amundsen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSL_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSL_DIAMOND
+# endif
+# define machine_is_gsl_diamond()	(machine_arch_type == MACH_TYPE_GSL_DIAMOND)
+#else
+# define machine_is_gsl_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2201
+# endif
+# define machine_is_cv2201()	(machine_arch_type == MACH_TYPE_CV2201)
+#else
+# define machine_is_cv2201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2202
+# endif
+# define machine_is_cv2202()	(machine_arch_type == MACH_TYPE_CV2202)
+#else
+# define machine_is_cv2202()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2203
+# endif
+# define machine_is_cv2203()	(machine_arch_type == MACH_TYPE_CV2203)
+#else
+# define machine_is_cv2203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIT_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIT_IBOX
+# endif
+# define machine_is_vit_ibox()	(machine_arch_type == MACH_TYPE_VIT_IBOX)
+#else
+# define machine_is_vit_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6441_ESP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6441_ESP
+# endif
+# define machine_is_dm6441_esp()	(machine_arch_type == MACH_TYPE_DM6441_ESP)
+#else
+# define machine_is_dm6441_esp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9X5EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9X5EK
+# endif
+# define machine_is_at91sam9x5ek()	(machine_arch_type == MACH_TYPE_AT91SAM9X5EK)
+#else
+# define machine_is_at91sam9x5ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBRA
+# endif
+# define machine_is_libra()	(machine_arch_type == MACH_TYPE_LIBRA)
+#else
+# define machine_is_libra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EASYCRRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EASYCRRH
+# endif
+# define machine_is_easycrrh()	(machine_arch_type == MACH_TYPE_EASYCRRH)
+#else
+# define machine_is_easycrrh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIPEL
+# endif
+# define machine_is_tripel()	(machine_arch_type == MACH_TYPE_TRIPEL)
+#else
+# define machine_is_tripel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDIAN_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDIAN_MINI
+# endif
+# define machine_is_endian_mini()	(machine_arch_type == MACH_TYPE_ENDIAN_MINI)
+#else
+# define machine_is_endian_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX_EP107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX_EP107
+# endif
+# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
+#else
+# define machine_is_xilinx_ep107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NURI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NURI
+# endif
+# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
+#else
+# define machine_is_nuri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JANUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS
+# endif
+# define machine_is_janus()	(machine_arch_type == MACH_TYPE_JANUS)
+#else
+# define machine_is_janus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDNAS
+# endif
+# define machine_is_ddnas()	(machine_arch_type == MACH_TYPE_DDNAS)
+#else
+# define machine_is_ddnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAG
+# endif
+# define machine_is_tag()	(machine_arch_type == MACH_TYPE_TAG)
+#else
+# define machine_is_tag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGW
+# endif
+# define machine_is_tagw()	(machine_arch_type == MACH_TYPE_TAGW)
+#else
+# define machine_is_tagw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_VM_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_VM_IMX51
+# endif
+# define machine_is_nitrogen_vm_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_VM_IMX51)
+#else
+# define machine_is_nitrogen_vm_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIPRINET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPRINET
+# endif
+# define machine_is_viprinet()	(machine_arch_type == MACH_TYPE_VIPRINET)
+#else
+# define machine_is_viprinet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOCKW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOCKW
+# endif
+# define machine_is_bockw()	(machine_arch_type == MACH_TYPE_BOCKW)
+#else
+# define machine_is_bockw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA2000
+# endif
+# define machine_is_eva2000()	(machine_arch_type == MACH_TYPE_EVA2000)
+#else
+# define machine_is_eva2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELYARD
+# endif
+# define machine_is_steelyard()	(machine_arch_type == MACH_TYPE_STEELYARD)
+#else
+# define machine_is_steelyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSSLSBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSSLSBOARD
+# endif
+# define machine_is_nsslsboard()	(machine_arch_type == MACH_TYPE_NSSLSBOARD)
+#else
+# define machine_is_nsslsboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA_B5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA_B5
+# endif
+# define machine_is_geneva_b5()	(machine_arch_type == MACH_TYPE_GENEVA_B5)
+#else
+# define machine_is_geneva_b5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1340
+# endif
+# define machine_is_spear1340()	(machine_arch_type == MACH_TYPE_SPEAR1340)
+#else
+# define machine_is_spear1340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REXMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REXMAS
+# endif
+# define machine_is_rexmas()	(machine_arch_type == MACH_TYPE_REXMAS)
+#else
+# define machine_is_rexmas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_CDP
+# endif
+# define machine_is_msm8960_cdp()	(machine_arch_type == MACH_TYPE_MSM8960_CDP)
+#else
+# define machine_is_msm8960_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_MTP
+# endif
+# define machine_is_msm8960_mtp()	(machine_arch_type == MACH_TYPE_MSM8960_MTP)
+#else
+# define machine_is_msm8960_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_FLUID
+# endif
+# define machine_is_msm8960_fluid()	(machine_arch_type == MACH_TYPE_MSM8960_FLUID)
+#else
+# define machine_is_msm8960_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_APQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_APQ
+# endif
+# define machine_is_msm8960_apq()	(machine_arch_type == MACH_TYPE_MSM8960_APQ)
+#else
+# define machine_is_msm8960_apq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V2
+# endif
+# define machine_is_helios_v2()	(machine_arch_type == MACH_TYPE_HELIOS_V2)
+#else
+# define machine_is_helios_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIF10P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIF10P
+# endif
+# define machine_is_mif10p()	(machine_arch_type == MACH_TYPE_MIF10P)
+#else
+# define machine_is_mif10p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IAM28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM28
+# endif
+# define machine_is_iam28()	(machine_arch_type == MACH_TYPE_IAM28)
+#else
+# define machine_is_iam28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO
+# endif
+# define machine_is_picasso()	(machine_arch_type == MACH_TYPE_PICASSO)
+#else
+# define machine_is_picasso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MR301A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MR301A
+# endif
+# define machine_is_mr301a()	(machine_arch_type == MACH_TYPE_MR301A)
+#else
+# define machine_is_mr301a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTLE
+# endif
+# define machine_is_notle()	(machine_arch_type == MACH_TYPE_NOTLE)
+#else
+# define machine_is_notle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EELX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EELX2
+# endif
+# define machine_is_eelx2()	(machine_arch_type == MACH_TYPE_EELX2)
+#else
+# define machine_is_eelx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOON
+# endif
+# define machine_is_moon()	(machine_arch_type == MACH_TYPE_MOON)
+#else
+# define machine_is_moon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBY
+# endif
+# define machine_is_ruby()	(machine_arch_type == MACH_TYPE_RUBY)
+#else
+# define machine_is_ruby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOLDENGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOLDENGATE
+# endif
+# define machine_is_goldengate()	(machine_arch_type == MACH_TYPE_GOLDENGATE)
+#else
+# define machine_is_goldengate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTBU_GEN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTBU_GEN2
+# endif
+# define machine_is_ctbu_gen2()	(machine_arch_type == MACH_TYPE_CTBU_GEN2)
+#else
+# define machine_is_ctbu_gen2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMP_AM17_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMP_AM17_01
+# endif
+# define machine_is_kmp_am17_01()	(machine_arch_type == MACH_TYPE_KMP_AM17_01)
+#else
+# define machine_is_kmp_am17_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WTPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WTPLUG
+# endif
+# define machine_is_wtplug()	(machine_arch_type == MACH_TYPE_WTPLUG)
+#else
+# define machine_is_wtplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27SU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27SU2
+# endif
+# define machine_is_mx27su2()	(machine_arch_type == MACH_TYPE_MX27SU2)
+#else
+# define machine_is_mx27su2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB31
+# endif
+# define machine_is_nb31()	(machine_arch_type == MACH_TYPE_NB31)
+#else
+# define machine_is_nb31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HJSDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HJSDU
+# endif
+# define machine_is_hjsdu()	(machine_arch_type == MACH_TYPE_HJSDU)
+#else
+# define machine_is_hjsdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TD3_REV1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TD3_REV1
+# endif
+# define machine_is_td3_rev1()	(machine_arch_type == MACH_TYPE_TD3_REV1)
+#else
+# define machine_is_td3_rev1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAG_CI4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAG_CI4000
+# endif
+# define machine_is_eag_ci4000()	(machine_arch_type == MACH_TYPE_EAG_CI4000)
+#else
+# define machine_is_eag_ci4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_NAND_V2
+# endif
+# define machine_is_net5big_nand_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_NAND_V2)
+#else
+# define machine_is_net5big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPX2
+# endif
+# define machine_is_cpx2()	(machine_arch_type == MACH_TYPE_CPX2)
+#else
+# define machine_is_cpx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_NAND_V2
+# endif
+# define machine_is_net2big_nand_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_NAND_V2)
+#else
+# define machine_is_net2big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECUV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECUV5
+# endif
+# define machine_is_ecuv5()	(machine_arch_type == MACH_TYPE_ECUV5)
+#else
+# define machine_is_ecuv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSGX6D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSGX6D
+# endif
+# define machine_is_hsgx6d()	(machine_arch_type == MACH_TYPE_HSGX6D)
+#else
+# define machine_is_hsgx6d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAWAD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAWAD7
+# endif
+# define machine_is_dawad7()	(machine_arch_type == MACH_TYPE_DAWAD7)
+#else
+# define machine_is_dawad7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9REPEATER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9REPEATER
+# endif
+# define machine_is_sam9repeater()	(machine_arch_type == MACH_TYPE_SAM9REPEATER)
+#else
+# define machine_is_sam9repeater()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GT_I5700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GT_I5700
+# endif
+# define machine_is_gt_i5700()	(machine_arch_type == MACH_TYPE_GT_I5700)
+#else
+# define machine_is_gt_i5700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C2
+# endif
+# define machine_is_ctera_plug_c2()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C2)
+#else
+# define machine_is_ctera_plug_c2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELCT
+# endif
+# define machine_is_marvelct()	(machine_arch_type == MACH_TYPE_MARVELCT)
+#else
+# define machine_is_marvelct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG11005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG11005
+# endif
+# define machine_is_ag11005()	(machine_arch_type == MACH_TYPE_AG11005)
+#else
+# define machine_is_ag11005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH
+# endif
+# define machine_is_vangogh()	(machine_arch_type == MACH_TYPE_VANGOGH)
+#else
+# define machine_is_vangogh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX505
+# endif
+# define machine_is_matrix505()	(machine_arch_type == MACH_TYPE_MATRIX505)
+#else
+# define machine_is_matrix505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_NIGMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_NIGMA
+# endif
+# define machine_is_oce_nigma()	(machine_arch_type == MACH_TYPE_OCE_NIGMA)
+#else
+# define machine_is_oce_nigma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T55
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T55
+# endif
+# define machine_is_t55()	(machine_arch_type == MACH_TYPE_T55)
+#else
+# define machine_is_t55()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIO3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIO3K
+# endif
+# define machine_is_bio3k()	(machine_arch_type == MACH_TYPE_BIO3K)
+#else
+# define machine_is_bio3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSCT
+# endif
+# define machine_is_expressct()	(machine_arch_type == MACH_TYPE_EXPRESSCT)
+#else
+# define machine_is_expressct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARDHU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARDHU
+# endif
+# define machine_is_cardhu()	(machine_arch_type == MACH_TYPE_CARDHU)
+#else
+# define machine_is_cardhu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARUBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARUBA
+# endif
+# define machine_is_aruba()	(machine_arch_type == MACH_TYPE_ARUBA)
+#else
+# define machine_is_aruba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONAIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONAIRE
+# endif
+# define machine_is_bonaire()	(machine_arch_type == MACH_TYPE_BONAIRE)
+#else
+# define machine_is_bonaire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC700EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC700EVB
+# endif
+# define machine_is_nuc700evb()	(machine_arch_type == MACH_TYPE_NUC700EVB)
+#else
+# define machine_is_nuc700evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC710EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC710EVB
+# endif
+# define machine_is_nuc710evb()	(machine_arch_type == MACH_TYPE_NUC710EVB)
+#else
+# define machine_is_nuc710evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC740EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC740EVB
+# endif
+# define machine_is_nuc740evb()	(machine_arch_type == MACH_TYPE_NUC740EVB)
+#else
+# define machine_is_nuc740evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC745EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC745EVB
+# endif
+# define machine_is_nuc745evb()	(machine_arch_type == MACH_TYPE_NUC745EVB)
+#else
+# define machine_is_nuc745evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRANSCEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRANSCEDE
+# endif
+# define machine_is_transcede()	(machine_arch_type == MACH_TYPE_TRANSCEDE)
+#else
+# define machine_is_transcede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORA
+# endif
+# define machine_is_mora()	(machine_arch_type == MACH_TYPE_MORA)
+#else
+# define machine_is_mora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NDA_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NDA_EVM
+# endif
+# define machine_is_nda_evm()	(machine_arch_type == MACH_TYPE_NDA_EVM)
+#else
+# define machine_is_nda_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIMU
+# endif
+# define machine_is_timu()	(machine_arch_type == MACH_TYPE_TIMU)
+#else
+# define machine_is_timu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSH
+# endif
+# define machine_is_expressh()	(machine_arch_type == MACH_TYPE_EXPRESSH)
+#else
+# define machine_is_expressh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERIDIS_A300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERIDIS_A300
+# endif
+# define machine_is_veridis_a300()	(machine_arch_type == MACH_TYPE_VERIDIS_A300)
+#else
+# define machine_is_veridis_a300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM368_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM368_LEOPARD
+# endif
+# define machine_is_dm368_leopard()	(machine_arch_type == MACH_TYPE_DM368_LEOPARD)
+#else
+# define machine_is_dm368_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_MCOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_MCOP
+# endif
+# define machine_is_omap_mcop()	(machine_arch_type == MACH_TYPE_OMAP_MCOP)
+#else
+# define machine_is_omap_mcop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRITIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRITIP
+# endif
+# define machine_is_tritip()	(machine_arch_type == MACH_TYPE_TRITIP)
+#else
+# define machine_is_tritip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM1K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM1K
+# endif
+# define machine_is_sm1k()	(machine_arch_type == MACH_TYPE_SM1K)
+#else
+# define machine_is_sm1k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONCH
+# endif
+# define machine_is_monch()	(machine_arch_type == MACH_TYPE_MONCH)
+#else
+# define machine_is_monch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CURACAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CURACAO
+# endif
+# define machine_is_curacao()	(machine_arch_type == MACH_TYPE_CURACAO)
+#else
+# define machine_is_curacao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORIGEN
+# endif
+# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
+#else
+# define machine_is_origen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPC10
+# endif
+# define machine_is_epc10()	(machine_arch_type == MACH_TYPE_EPC10)
+#else
+# define machine_is_epc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I740
+# endif
+# define machine_is_sgh_i740()	(machine_arch_type == MACH_TYPE_SGH_I740)
+#else
+# define machine_is_sgh_i740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNA
+# endif
+# define machine_is_tuna()	(machine_arch_type == MACH_TYPE_TUNA)
+#else
+# define machine_is_tuna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_TULIP
+# endif
+# define machine_is_mx51_tulip()	(machine_arch_type == MACH_TYPE_MX51_TULIP)
+#else
+# define machine_is_mx51_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_ASTER7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_ASTER7
+# endif
+# define machine_is_mx51_aster7()	(machine_arch_type == MACH_TYPE_MX51_ASTER7)
+#else
+# define machine_is_mx51_aster7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACRO37XBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACRO37XBRD
+# endif
+# define machine_is_acro37xbrd()	(machine_arch_type == MACH_TYPE_ACRO37XBRD)
+#else
+# define machine_is_acro37xbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELKE
+# endif
+# define machine_is_elke()	(machine_arch_type == MACH_TYPE_ELKE)
+#else
+# define machine_is_elke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC6000X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC6000X
+# endif
+# define machine_is_sbc6000x()	(machine_arch_type == MACH_TYPE_SBC6000X)
+#else
+# define machine_is_sbc6000x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1801E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1801E
+# endif
+# define machine_is_r1801e()	(machine_arch_type == MACH_TYPE_R1801E)
+#else
+# define machine_is_r1801e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1600
+# endif
+# define machine_is_h1600()	(machine_arch_type == MACH_TYPE_H1600)
+#else
+# define machine_is_h1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI210
+# endif
+# define machine_is_mini210()	(machine_arch_type == MACH_TYPE_MINI210)
+#else
+# define machine_is_mini210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI8168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI8168
+# endif
+# define machine_is_mini8168()	(machine_arch_type == MACH_TYPE_MINI8168)
+#else
+# define machine_is_mini8168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7308
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7308
+# endif
+# define machine_is_pc7308()	(machine_arch_type == MACH_TYPE_PC7308)
+#else
+# define machine_is_pc7308()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMM2M01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMM2M01
+# endif
+# define machine_is_kmm2m01()	(machine_arch_type == MACH_TYPE_KMM2M01)
+#else
+# define machine_is_kmm2m01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51EREBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51EREBUS
+# endif
+# define machine_is_mx51erebus()	(machine_arch_type == MACH_TYPE_MX51EREBUS)
+#else
+# define machine_is_mx51erebus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8650REFBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8650REFBOARD
+# endif
+# define machine_is_wm8650refboard()	(machine_arch_type == MACH_TYPE_WM8650REFBOARD)
+#else
+# define machine_is_wm8650refboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUXRAIL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUXRAIL
+# endif
+# define machine_is_tuxrail()	(machine_arch_type == MACH_TYPE_TUXRAIL)
+#else
+# define machine_is_tuxrail()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARTHUR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARTHUR
+# endif
+# define machine_is_arthur()	(machine_arch_type == MACH_TYPE_ARTHUR)
+#else
+# define machine_is_arthur()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOORBOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOORBOY
+# endif
+# define machine_is_doorboy()	(machine_arch_type == MACH_TYPE_DOORBOY)
+#else
+# define machine_is_doorboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARINA
+# endif
+# define machine_is_xarina()	(machine_arch_type == MACH_TYPE_XARINA)
+#else
+# define machine_is_xarina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERX7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERX7
+# endif
+# define machine_is_roverx7()	(machine_arch_type == MACH_TYPE_ROVERX7)
+#else
+# define machine_is_roverx7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR
+# endif
+# define machine_is_sdvr()	(machine_arch_type == MACH_TYPE_SDVR)
+#else
+# define machine_is_sdvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_MAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_MAYA
+# endif
+# define machine_is_acer_maya()	(machine_arch_type == MACH_TYPE_ACER_MAYA)
+#else
+# define machine_is_acer_maya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICO
+# endif
+# define machine_is_pico()	(machine_arch_type == MACH_TYPE_PICO)
+#else
+# define machine_is_pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX233
+# endif
+# define machine_is_cwmx233()	(machine_arch_type == MACH_TYPE_CWMX233)
+#else
+# define machine_is_cwmx233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWAM1808
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWAM1808
+# endif
+# define machine_is_cwam1808()	(machine_arch_type == MACH_TYPE_CWAM1808)
+#else
+# define machine_is_cwam1808()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWDM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWDM365
+# endif
+# define machine_is_cwdm365()	(machine_arch_type == MACH_TYPE_CWDM365)
+#else
+# define machine_is_cwdm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_MORAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_MORAY
+# endif
+# define machine_is_mx51_moray()	(machine_arch_type == MACH_TYPE_MX51_MORAY)
+#else
+# define machine_is_mx51_moray()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_CBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_CBC
+# endif
+# define machine_is_thales_cbc()	(machine_arch_type == MACH_TYPE_THALES_CBC)
+#else
+# define machine_is_thales_cbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEPOINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEPOINT
+# endif
+# define machine_is_bluepoint()	(machine_arch_type == MACH_TYPE_BLUEPOINT)
+#else
+# define machine_is_bluepoint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIR665
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIR665
+# endif
+# define machine_is_dir665()	(machine_arch_type == MACH_TYPE_DIR665)
+#else
+# define machine_is_dir665()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMEROVER1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMEROVER1
+# endif
+# define machine_is_acmerover1()	(machine_arch_type == MACH_TYPE_ACMEROVER1)
+#else
+# define machine_is_acmerover1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_CT
+# endif
+# define machine_is_shooter_ct()	(machine_arch_type == MACH_TYPE_SHOOTER_CT)
+#else
+# define machine_is_shooter_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISS
+# endif
+# define machine_is_bliss()	(machine_arch_type == MACH_TYPE_BLISS)
+#else
+# define machine_is_bliss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISSC
+# endif
+# define machine_is_blissc()	(machine_arch_type == MACH_TYPE_BLISSC)
+#else
+# define machine_is_blissc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_ADC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_ADC
+# endif
+# define machine_is_thales_adc()	(machine_arch_type == MACH_TYPE_THALES_ADC)
+#else
+# define machine_is_thales_adc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9D_EVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9D_EVP
+# endif
+# define machine_is_ubisys_p9d_evp()	(machine_arch_type == MACH_TYPE_UBISYS_P9D_EVP)
+#else
+# define machine_is_ubisys_p9d_evp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATDGP318
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATDGP318
+# endif
+# define machine_is_atdgp318()	(machine_arch_type == MACH_TYPE_ATDGP318)
+#else
+# define machine_is_atdgp318()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA210U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA210U
+# endif
+# define machine_is_dma210u()	(machine_arch_type == MACH_TYPE_DMA210U)
+#else
+# define machine_is_dma210u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_T3
+# endif
+# define machine_is_em_t3()	(machine_arch_type == MACH_TYPE_EM_T3)
+#else
+# define machine_is_em_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTX3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTX3250
+# endif
+# define machine_is_htx3250()	(machine_arch_type == MACH_TYPE_HTX3250)
+#else
+# define machine_is_htx3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G50
+# endif
+# define machine_is_g50()	(machine_arch_type == MACH_TYPE_G50)
+#else
+# define machine_is_g50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO5
+# endif
+# define machine_is_eco5()	(machine_arch_type == MACH_TYPE_ECO5)
+#else
+# define machine_is_eco5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WINTERGRASP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WINTERGRASP
+# endif
+# define machine_is_wintergrasp()	(machine_arch_type == MACH_TYPE_WINTERGRASP)
+#else
+# define machine_is_wintergrasp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PURO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PURO
+# endif
+# define machine_is_puro()	(machine_arch_type == MACH_TYPE_PURO)
+#else
+# define machine_is_puro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_K
+# endif
+# define machine_is_shooter_k()	(machine_arch_type == MACH_TYPE_SHOOTER_K)
+#else
+# define machine_is_shooter_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSPIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSPIRE
+# endif
+# define machine_is_nspire()	(machine_arch_type == MACH_TYPE_NSPIRE)
+#else
+# define machine_is_nspire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICKXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICKXX
+# endif
+# define machine_is_mickxx()	(machine_arch_type == MACH_TYPE_MICKXX)
+#else
+# define machine_is_mickxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LXMB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LXMB
+# endif
+# define machine_is_lxmb()	(machine_arch_type == MACH_TYPE_LXMB)
+#else
+# define machine_is_lxmb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAM
+# endif
+# define machine_is_adam()	(machine_arch_type == MACH_TYPE_ADAM)
+#else
+# define machine_is_adam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B1004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B1004
+# endif
+# define machine_is_b1004()	(machine_arch_type == MACH_TYPE_B1004)
+#else
+# define machine_is_b1004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OBOEA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OBOEA
+# endif
+# define machine_is_oboea()	(machine_arch_type == MACH_TYPE_OBOEA)
+#else
+# define machine_is_oboea()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A1015
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A1015
+# endif
+# define machine_is_a1015()	(machine_arch_type == MACH_TYPE_A1015)
+#else
+# define machine_is_a1015()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROBIN_VBDT30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROBIN_VBDT30
+# endif
+# define machine_is_robin_vbdt30()	(machine_arch_type == MACH_TYPE_ROBIN_VBDT30)
+#else
+# define machine_is_robin_vbdt30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_ENTERPRISE
+# endif
+# define machine_is_tegra_enterprise()	(machine_arch_type == MACH_TYPE_TEGRA_ENTERPRISE)
+#else
+# define machine_is_tegra_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL108200_MK10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL108200_MK10
+# endif
+# define machine_is_rfl108200_mk10()	(machine_arch_type == MACH_TYPE_RFL108200_MK10)
+#else
+# define machine_is_rfl108200_mk10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL108300_MK16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL108300_MK16
+# endif
+# define machine_is_rfl108300_mk16()	(machine_arch_type == MACH_TYPE_RFL108300_MK16)
+#else
+# define machine_is_rfl108300_mk16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_V7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_V7
+# endif
+# define machine_is_rover_v7()	(machine_arch_type == MACH_TYPE_ROVER_V7)
+#else
+# define machine_is_rover_v7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPHONE
+# endif
+# define machine_is_miphone()	(machine_arch_type == MACH_TYPE_MIPHONE)
+#else
+# define machine_is_miphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FEMTOBTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FEMTOBTS
+# endif
+# define machine_is_femtobts()	(machine_arch_type == MACH_TYPE_FEMTOBTS)
+#else
+# define machine_is_femtobts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONOPOLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONOPOLI
+# endif
+# define machine_is_monopoli()	(machine_arch_type == MACH_TYPE_MONOPOLI)
+#else
+# define machine_is_monopoli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOSS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOSS
+# endif
+# define machine_is_boss()	(machine_arch_type == MACH_TYPE_BOSS)
+#else
+# define machine_is_boss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM368_VTAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM368_VTAM
+# endif
+# define machine_is_davinci_dm368_vtam()	(machine_arch_type == MACH_TYPE_DAVINCI_DM368_VTAM)
+#else
+# define machine_is_davinci_dm368_vtam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLCON
+# endif
+# define machine_is_clcon()	(machine_arch_type == MACH_TYPE_CLCON)
+#else
+# define machine_is_clcon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM696
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM696
+# endif
+# define machine_is_nokia_rm696()	(machine_arch_type == MACH_TYPE_NOKIA_RM696)
+#else
+# define machine_is_nokia_rm696()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAHITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAHITI
+# endif
+# define machine_is_tahiti()	(machine_arch_type == MACH_TYPE_TAHITI)
+#else
+# define machine_is_tahiti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIGHTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIGHTER
+# endif
+# define machine_is_fighter()	(machine_arch_type == MACH_TYPE_FIGHTER)
+#else
+# define machine_is_fighter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I710
+# endif
+# define machine_is_sgh_i710()	(machine_arch_type == MACH_TYPE_SGH_I710)
+#else
+# define machine_is_sgh_i710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTEGREPROSCB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGREPROSCB
+# endif
+# define machine_is_integreproscb()	(machine_arch_type == MACH_TYPE_INTEGREPROSCB)
+#else
+# define machine_is_integreproscb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONZA
+# endif
+# define machine_is_monza()	(machine_arch_type == MACH_TYPE_MONZA)
+#else
+# define machine_is_monza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CALIMAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CALIMAIN
+# endif
+# define machine_is_calimain()	(machine_arch_type == MACH_TYPE_CALIMAIN)
+#else
+# define machine_is_calimain()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_SABREAUTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_SABREAUTO
+# endif
+# define machine_is_mx6q_sabreauto()	(machine_arch_type == MACH_TYPE_MX6Q_SABREAUTO)
+#else
+# define machine_is_mx6q_sabreauto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GMA01X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMA01X
+# endif
+# define machine_is_gma01x()	(machine_arch_type == MACH_TYPE_GMA01X)
+#else
+# define machine_is_gma01x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC51
+# endif
+# define machine_is_sbc51()	(machine_arch_type == MACH_TYPE_SBC51)
+#else
+# define machine_is_sbc51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIT
+# endif
+# define machine_is_fit()	(machine_arch_type == MACH_TYPE_FIT)
+#else
+# define machine_is_fit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELHEAD
+# endif
+# define machine_is_steelhead()	(machine_arch_type == MACH_TYPE_STEELHEAD)
+#else
+# define machine_is_steelhead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PANTHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTHER
+# endif
+# define machine_is_panther()	(machine_arch_type == MACH_TYPE_PANTHER)
+#else
+# define machine_is_panther()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_LIQUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_LIQUID
+# endif
+# define machine_is_msm8960_liquid()	(machine_arch_type == MACH_TYPE_MSM8960_LIQUID)
+#else
+# define machine_is_msm8960_liquid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXIKONCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXIKONCT
+# endif
+# define machine_is_lexikonct()	(machine_arch_type == MACH_TYPE_LEXIKONCT)
+#else
+# define machine_is_lexikonct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_STB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_STB
+# endif
+# define machine_is_ns2816_stb()	(machine_arch_type == MACH_TYPE_NS2816_STB)
+#else
+# define machine_is_ns2816_stb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEI_MM2_LPC3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEI_MM2_LPC3250
+# endif
+# define machine_is_sei_mm2_lpc3250()	(machine_arch_type == MACH_TYPE_SEI_MM2_LPC3250)
+#else
+# define machine_is_sei_mm2_lpc3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMIMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMIMX53
+# endif
+# define machine_is_cmimx53()	(machine_arch_type == MACH_TYPE_CMIMX53)
+#else
+# define machine_is_cmimx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDWICH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDWICH
+# endif
+# define machine_is_sandwich()	(machine_arch_type == MACH_TYPE_SANDWICH)
+#else
+# define machine_is_sandwich()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHIEF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIEF
+# endif
+# define machine_is_chief()	(machine_arch_type == MACH_TYPE_CHIEF)
+#else
+# define machine_is_chief()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POGO_E02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POGO_E02
+# endif
+# define machine_is_pogo_e02()	(machine_arch_type == MACH_TYPE_POGO_E02)
+#else
+# define machine_is_pogo_e02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIKRAP_X168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIKRAP_X168
+# endif
+# define machine_is_mikrap_x168()	(machine_arch_type == MACH_TYPE_MIKRAP_X168)
+#else
+# define machine_is_mikrap_x168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCMOZART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCMOZART
+# endif
+# define machine_is_htcmozart()	(machine_arch_type == MACH_TYPE_HTCMOZART)
+#else
+# define machine_is_htcmozart()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCGOLD
+# endif
+# define machine_is_htcgold()	(machine_arch_type == MACH_TYPE_HTCGOLD)
+#else
+# define machine_is_htcgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT72XX
+# endif
+# define machine_is_mt72xx()	(machine_arch_type == MACH_TYPE_MT72XX)
+#else
+# define machine_is_mt72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_IVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_IVY
+# endif
+# define machine_is_mx51_ivy()	(machine_arch_type == MACH_TYPE_MX51_IVY)
+#else
+# define machine_is_mx51_ivy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_LVD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_LVD
+# endif
+# define machine_is_mx51_lvd()	(machine_arch_type == MACH_TYPE_MX51_LVD)
+#else
+# define machine_is_mx51_lvd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WISER2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WISER2
+# endif
+# define machine_is_omap3_wiser2()	(machine_arch_type == MACH_TYPE_OMAP3_WISER2)
+#else
+# define machine_is_omap3_wiser2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREAMPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREAMPLUG
+# endif
+# define machine_is_dreamplug()	(machine_arch_type == MACH_TYPE_DREAMPLUG)
+#else
+# define machine_is_dreamplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBAS_C_111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBAS_C_111
+# endif
+# define machine_is_cobas_c_111()	(machine_arch_type == MACH_TYPE_COBAS_C_111)
+#else
+# define machine_is_cobas_c_111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBAS_U_411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBAS_U_411
+# endif
+# define machine_is_cobas_u_411()	(machine_arch_type == MACH_TYPE_COBAS_U_411)
+#else
+# define machine_is_cobas_u_411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSSD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSSD
+# endif
+# define machine_is_hssd()	(machine_arch_type == MACH_TYPE_HSSD)
+#else
+# define machine_is_hssd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IOM35X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IOM35X
+# endif
+# define machine_is_iom35x()	(machine_arch_type == MACH_TYPE_IOM35X)
+#else
+# define machine_is_iom35x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PSOM_OMAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSOM_OMAP
+# endif
+# define machine_is_psom_omap()	(machine_arch_type == MACH_TYPE_PSOM_OMAP)
+#else
+# define machine_is_psom_omap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_2G
+# endif
+# define machine_is_iphone_2g()	(machine_arch_type == MACH_TYPE_IPHONE_2G)
+#else
+# define machine_is_iphone_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_3G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_3G
+# endif
+# define machine_is_iphone_3g()	(machine_arch_type == MACH_TYPE_IPHONE_3G)
+#else
+# define machine_is_iphone_3g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_1G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_1G
+# endif
+# define machine_is_ipod_touch_1g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_1G)
+#else
+# define machine_is_ipod_touch_1g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHAROS_TPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHAROS_TPC
+# endif
+# define machine_is_pharos_tpc()	(machine_arch_type == MACH_TYPE_PHAROS_TPC)
+#else
+# define machine_is_pharos_tpc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_HYDRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_HYDRA
+# endif
+# define machine_is_mx53_hydra()	(machine_arch_type == MACH_TYPE_MX53_HYDRA)
+#else
+# define machine_is_mx53_hydra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_DEV_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_DEV_BOARD
+# endif
+# define machine_is_ns2816_dev_board()	(machine_arch_type == MACH_TYPE_NS2816_DEV_BOARD)
+#else
+# define machine_is_ns2816_dev_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_3GS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_3GS
+# endif
+# define machine_is_iphone_3gs()	(machine_arch_type == MACH_TYPE_IPHONE_3GS)
+#else
+# define machine_is_iphone_3gs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_4
+# endif
+# define machine_is_iphone_4()	(machine_arch_type == MACH_TYPE_IPHONE_4)
+#else
+# define machine_is_iphone_4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_4G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_4G
+# endif
+# define machine_is_ipod_touch_4g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_4G)
+#else
+# define machine_is_ipod_touch_4g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON_E1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON_E1100
+# endif
+# define machine_is_dragon_e1100()	(machine_arch_type == MACH_TYPE_DRAGON_E1100)
+#else
+# define machine_is_dragon_e1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPSIDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPSIDE
+# endif
+# define machine_is_topside()	(machine_arch_type == MACH_TYPE_TOPSIDE)
+#else
+# define machine_is_topside()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IRISIII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IRISIII
+# endif
+# define machine_is_irisiii()	(machine_arch_type == MACH_TYPE_IRISIII)
+#else
+# define machine_is_irisiii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DETO_MACARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DETO_MACARM9
+# endif
+# define machine_is_deto_macarm9()	(machine_arch_type == MACH_TYPE_DETO_MACARM9)
+#else
+# define machine_is_deto_macarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_D1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_D1
+# endif
+# define machine_is_eti_d1()	(machine_arch_type == MACH_TYPE_ETI_D1)
+#else
+# define machine_is_eti_d1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOM3530SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOM3530SDK
+# endif
+# define machine_is_som3530sdk()	(machine_arch_type == MACH_TYPE_SOM3530SDK)
+#else
+# define machine_is_som3530sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OC_ENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OC_ENGINE
+# endif
+# define machine_is_oc_engine()	(machine_arch_type == MACH_TYPE_OC_ENGINE)
+#else
+# define machine_is_oc_engine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_SIM
+# endif
+# define machine_is_apq8064_sim()	(machine_arch_type == MACH_TYPE_APQ8064_SIM)
+#else
+# define machine_is_apq8064_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPS
+# endif
+# define machine_is_alps()	(machine_arch_type == MACH_TYPE_ALPS)
+#else
+# define machine_is_alps()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_T3730
+# endif
+# define machine_is_tny_t3730()	(machine_arch_type == MACH_TYPE_TNY_T3730)
+#else
+# define machine_is_tny_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GERYON_NFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GERYON_NFE
+# endif
+# define machine_is_geryon_nfe()	(machine_arch_type == MACH_TYPE_GERYON_NFE)
+#else
+# define machine_is_geryon_nfe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_REF_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_REF_BOARD
+# endif
+# define machine_is_ns2816_ref_board()	(machine_arch_type == MACH_TYPE_NS2816_REF_BOARD)
+#else
+# define machine_is_ns2816_ref_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SILVERSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SILVERSTONE
+# endif
+# define machine_is_silverstone()	(machine_arch_type == MACH_TYPE_SILVERSTONE)
+#else
+# define machine_is_silverstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT2440
+# endif
+# define machine_is_mtt2440()	(machine_arch_type == MACH_TYPE_MTT2440)
+#else
+# define machine_is_mtt2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YNICDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YNICDB
+# endif
+# define machine_is_ynicdb()	(machine_arch_type == MACH_TYPE_YNICDB)
+#else
+# define machine_is_ynicdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCT
+# endif
+# define machine_is_bct()	(machine_arch_type == MACH_TYPE_BCT)
+#else
+# define machine_is_bct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUSCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUSCAN
+# endif
+# define machine_is_tuscan()	(machine_arch_type == MACH_TYPE_TUSCAN)
+#else
+# define machine_is_tuscan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBT_SAM9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBT_SAM9G45
+# endif
+# define machine_is_xbt_sam9g45()	(machine_arch_type == MACH_TYPE_XBT_SAM9G45)
+#else
+# define machine_is_xbt_sam9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENBW_CMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENBW_CMC
+# endif
+# define machine_is_enbw_cmc()	(machine_arch_type == MACH_TYPE_ENBW_CMC)
+#else
+# define machine_is_enbw_cmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_DRAGON
+# endif
+# define machine_is_msm8x60_dragon()	(machine_arch_type == MACH_TYPE_MSM8X60_DRAGON)
+#else
+# define machine_is_msm8x60_dragon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CH104MX257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CH104MX257
+# endif
+# define machine_is_ch104mx257()	(machine_arch_type == MACH_TYPE_CH104MX257)
+#else
+# define machine_is_ch104mx257()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENPRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENPRI
+# endif
+# define machine_is_openpri()	(machine_arch_type == MACH_TYPE_OPENPRI)
+#else
+# define machine_is_openpri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM335XEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM335XEVM
+# endif
+# define machine_is_am335xevm()	(machine_arch_type == MACH_TYPE_AM335XEVM)
+#else
+# define machine_is_am335xevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICODMB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICODMB
+# endif
+# define machine_is_picodmb()	(machine_arch_type == MACH_TYPE_PICODMB)
+#else
+# define machine_is_picodmb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WALUIGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WALUIGI
+# endif
+# define machine_is_waluigi()	(machine_arch_type == MACH_TYPE_WALUIGI)
+#else
+# define machine_is_waluigi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUNICAG7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUNICAG7
+# endif
+# define machine_is_punicag7()	(machine_arch_type == MACH_TYPE_PUNICAG7)
+#else
+# define machine_is_punicag7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAD_1G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAD_1G
+# endif
+# define machine_is_ipad_1g()	(machine_arch_type == MACH_TYPE_IPAD_1G)
+#else
+# define machine_is_ipad_1g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APPLETV_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APPLETV_2G
+# endif
+# define machine_is_appletv_2g()	(machine_arch_type == MACH_TYPE_APPLETV_2G)
+#else
+# define machine_is_appletv_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_ECOG45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_ECOG45
+# endif
+# define machine_is_mach_ecog45()	(machine_arch_type == MACH_TYPE_MACH_ECOG45)
+#else
+# define machine_is_mach_ecog45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIT_CAM_ENC_4XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIT_CAM_ENC_4XX
+# endif
+# define machine_is_ait_cam_enc_4xx()	(machine_arch_type == MACH_TYPE_AIT_CAM_ENC_4XX)
+#else
+# define machine_is_ait_cam_enc_4xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUNNYMEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUNNYMEDE
+# endif
+# define machine_is_runnymede()	(machine_arch_type == MACH_TYPE_RUNNYMEDE)
+#else
+# define machine_is_runnymede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLAY
+# endif
+# define machine_is_play()	(machine_arch_type == MACH_TYPE_PLAY)
+#else
+# define machine_is_play()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90260
+# endif
+# define machine_is_hw90260()	(machine_arch_type == MACH_TYPE_HW90260)
+#else
+# define machine_is_hw90260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGH
+# endif
+# define machine_is_tagh()	(machine_arch_type == MACH_TYPE_TAGH)
+#else
+# define machine_is_tagh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FILBERT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILBERT
+# endif
+# define machine_is_filbert()	(machine_arch_type == MACH_TYPE_FILBERT)
+#else
+# define machine_is_filbert()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GETINGE_NETCOMV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GETINGE_NETCOMV3
+# endif
+# define machine_is_getinge_netcomv3()	(machine_arch_type == MACH_TYPE_GETINGE_NETCOMV3)
+#else
+# define machine_is_getinge_netcomv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CW20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CW20
+# endif
+# define machine_is_cw20()	(machine_arch_type == MACH_TYPE_CW20)
+#else
+# define machine_is_cw20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA
+# endif
+# define machine_is_cinema()	(machine_arch_type == MACH_TYPE_CINEMA)
+#else
+# define machine_is_cinema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_TEA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_TEA
+# endif
+# define machine_is_cinema_tea()	(machine_arch_type == MACH_TYPE_CINEMA_TEA)
+#else
+# define machine_is_cinema_tea()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_COFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_COFFEE
+# endif
+# define machine_is_cinema_coffee()	(machine_arch_type == MACH_TYPE_CINEMA_COFFEE)
+#else
+# define machine_is_cinema_coffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_JUICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_JUICE
+# endif
+# define machine_is_cinema_juice()	(machine_arch_type == MACH_TYPE_CINEMA_JUICE)
+#else
+# define machine_is_cinema_juice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_MIRAGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_MIRAGE2
+# endif
+# define machine_is_mx53_mirage2()	(machine_arch_type == MACH_TYPE_MX53_MIRAGE2)
+#else
+# define machine_is_mx53_mirage2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EFIKASB
+# endif
+# define machine_is_mx53_efikasb()	(machine_arch_type == MACH_TYPE_MX53_EFIKASB)
+#else
+# define machine_is_mx53_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM_B2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM_B2000
+# endif
+# define machine_is_stm_b2000()	(machine_arch_type == MACH_TYPE_STM_B2000)
+#else
+# define machine_is_stm_b2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M28EVK
+# endif
+# define machine_is_m28evk()	(machine_arch_type == MACH_TYPE_M28EVK)
+#else
+# define machine_is_m28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA
+# endif
+# define machine_is_pda()	(machine_arch_type == MACH_TYPE_PDA)
+#else
+# define machine_is_pda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERAKI_MR58
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERAKI_MR58
+# endif
+# define machine_is_meraki_mr58()	(machine_arch_type == MACH_TYPE_MERAKI_MR58)
+#else
+# define machine_is_meraki_mr58()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOTA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOTA2
+# endif
+# define machine_is_kota2()	(machine_arch_type == MACH_TYPE_KOTA2)
+#else
+# define machine_is_kota2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LETCOOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LETCOOL
+# endif
+# define machine_is_letcool()	(machine_arch_type == MACH_TYPE_LETCOOL)
+#else
+# define machine_is_letcool()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27IAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27IAT
+# endif
+# define machine_is_mx27iat()	(machine_arch_type == MACH_TYPE_MX27IAT)
+#else
+# define machine_is_mx27iat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APOLLO_TD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APOLLO_TD
+# endif
+# define machine_is_apollo_td()	(machine_arch_type == MACH_TYPE_APOLLO_TD)
+#else
+# define machine_is_apollo_td()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARENA
+# endif
+# define machine_is_arena()	(machine_arch_type == MACH_TYPE_ARENA)
+#else
+# define machine_is_arena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSNGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSNGATEWAY
+# endif
+# define machine_is_gsngateway()	(machine_arch_type == MACH_TYPE_GSNGATEWAY)
+#else
+# define machine_is_gsngateway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LF2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LF2000
+# endif
+# define machine_is_lf2000()	(machine_arch_type == MACH_TYPE_LF2000)
+#else
+# define machine_is_lf2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONITO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONITO
+# endif
+# define machine_is_bonito()	(machine_arch_type == MACH_TYPE_BONITO)
+#else
+# define machine_is_bonito()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASYMPTOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASYMPTOTE
+# endif
+# define machine_is_asymptote()	(machine_arch_type == MACH_TYPE_ASYMPTOTE)
+#else
+# define machine_is_asymptote()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BST2BRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BST2BRD
+# endif
+# define machine_is_bst2brd()	(machine_arch_type == MACH_TYPE_BST2BRD)
+#else
+# define machine_is_bst2brd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX335S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX335S
+# endif
+# define machine_is_tx335s()	(machine_arch_type == MACH_TYPE_TX335S)
+#else
+# define machine_is_tx335s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_TESLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_TESLA
+# endif
+# define machine_is_pelco_tesla()	(machine_arch_type == MACH_TYPE_PELCO_TESLA)
+#else
+# define machine_is_pelco_tesla()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RRHTESTPLAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RRHTESTPLAT
+# endif
+# define machine_is_rrhtestplat()	(machine_arch_type == MACH_TYPE_RRHTESTPLAT)
+#else
+# define machine_is_rrhtestplat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIDTONIC_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIDTONIC_PRO
+# endif
+# define machine_is_vidtonic_pro()	(machine_arch_type == MACH_TYPE_VIDTONIC_PRO)
+#else
+# define machine_is_vidtonic_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PL_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PL_APOLLO
+# endif
+# define machine_is_pl_apollo()	(machine_arch_type == MACH_TYPE_PL_APOLLO)
+#else
+# define machine_is_pl_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PL_PHOENIX
+# endif
+# define machine_is_pl_phoenix()	(machine_arch_type == MACH_TYPE_PL_PHOENIX)
+#else
+# define machine_is_pl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M28CU3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M28CU3
+# endif
+# define machine_is_m28cu3()	(machine_arch_type == MACH_TYPE_M28CU3)
+#else
+# define machine_is_m28cu3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_HD
+# endif
+# define machine_is_vvbox_hd()	(machine_arch_type == MACH_TYPE_VVBOX_HD)
+#else
+# define machine_is_vvbox_hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREWARE_SAM9260_
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREWARE_SAM9260_
+# endif
+# define machine_is_coreware_sam9260_()	(machine_arch_type == MACH_TYPE_COREWARE_SAM9260_)
+#else
+# define machine_is_coreware_sam9260_()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARMADUKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARMADUKE
+# endif
+# define machine_is_marmaduke()	(machine_arch_type == MACH_TYPE_MARMADUKE)
+#else
+# define machine_is_marmaduke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMG_XLCORE_CAMERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMG_XLCORE_CAMERA
+# endif
+# define machine_is_amg_xlcore_camera()	(machine_arch_type == MACH_TYPE_AMG_XLCORE_CAMERA)
+#else
+# define machine_is_amg_xlcore_camera()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_EGF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_EGF
+# endif
+# define machine_is_omap3_egf()	(machine_arch_type == MACH_TYPE_OMAP3_EGF)
+#else
+# define machine_is_omap3_egf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4212
+# endif
+# define machine_is_smdk4212()	(machine_arch_type == MACH_TYPE_SMDK4212)
+#else
+# define machine_is_smdk4212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNP9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP9200
+# endif
+# define machine_is_dnp9200()	(machine_arch_type == MACH_TYPE_DNP9200)
+#else
+# define machine_is_dnp9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TF101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TF101
+# endif
+# define machine_is_tf101()	(machine_arch_type == MACH_TYPE_TF101)
+#else
+# define machine_is_tf101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SILVIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SILVIO
+# endif
+# define machine_is_omap3silvio()	(machine_arch_type == MACH_TYPE_OMAP3SILVIO)
+#else
+# define machine_is_omap3silvio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO2
+# endif
+# define machine_is_picasso2()	(machine_arch_type == MACH_TYPE_PICASSO2)
+#else
+# define machine_is_picasso2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH2
+# endif
+# define machine_is_vangogh2()	(machine_arch_type == MACH_TYPE_VANGOGH2)
+#else
+# define machine_is_vangogh2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLPC_XO_1_75
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLPC_XO_1_75
+# endif
+# define machine_is_olpc_xo_1_75()	(machine_arch_type == MACH_TYPE_OLPC_XO_1_75)
+#else
+# define machine_is_olpc_xo_1_75()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GX400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GX400
+# endif
+# define machine_is_gx400()	(machine_arch_type == MACH_TYPE_GX400)
+#else
+# define machine_is_gx400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GS300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GS300
+# endif
+# define machine_is_gs300()	(machine_arch_type == MACH_TYPE_GS300)
+#else
+# define machine_is_gs300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A9
+# endif
+# define machine_is_acer_a9()	(machine_arch_type == MACH_TYPE_ACER_A9)
+#else
+# define machine_is_acer_a9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_EVM
+# endif
+# define machine_is_vivow_evm()	(machine_arch_type == MACH_TYPE_VIVOW_EVM)
+#else
+# define machine_is_vivow_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VELOCE_CXQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VELOCE_CXQ
+# endif
+# define machine_is_veloce_cxq()	(machine_arch_type == MACH_TYPE_VELOCE_CXQ)
+#else
+# define machine_is_veloce_cxq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VELOCE_CXM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VELOCE_CXM
+# endif
+# define machine_is_veloce_cxm()	(machine_arch_type == MACH_TYPE_VELOCE_CXM)
+#else
+# define machine_is_veloce_cxm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P1852
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P1852
+# endif
+# define machine_is_p1852()	(machine_arch_type == MACH_TYPE_P1852)
+#else
+# define machine_is_p1852()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY100
+# endif
+# define machine_is_naxy100()	(machine_arch_type == MACH_TYPE_NAXY100)
+#else
+# define machine_is_naxy100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAISHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAISHAN
+# endif
+# define machine_is_taishan()	(machine_arch_type == MACH_TYPE_TAISHAN)
+#else
+# define machine_is_taishan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHLINK
+# endif
+# define machine_is_touchlink()	(machine_arch_type == MACH_TYPE_TOUCHLINK)
+#else
+# define machine_is_touchlink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM32F103ZE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM32F103ZE
+# endif
+# define machine_is_stm32f103ze()	(machine_arch_type == MACH_TYPE_STM32F103ZE)
+#else
+# define machine_is_stm32f103ze()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCX
+# endif
+# define machine_is_mcx()	(machine_arch_type == MACH_TYPE_MCX)
+#else
+# define machine_is_mcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM_NMHDK_FLI7610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM_NMHDK_FLI7610
+# endif
+# define machine_is_stm_nmhdk_fli7610()	(machine_arch_type == MACH_TYPE_STM_NMHDK_FLI7610)
+#else
+# define machine_is_stm_nmhdk_fli7610()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP28X
+# endif
+# define machine_is_top28x()	(machine_arch_type == MACH_TYPE_TOP28X)
+#else
+# define machine_is_top28x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OKL4VP_MICROVISOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OKL4VP_MICROVISOR
+# endif
+# define machine_is_okl4vp_microvisor()	(machine_arch_type == MACH_TYPE_OKL4VP_MICROVISOR)
+#else
+# define machine_is_okl4vp_microvisor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POP
+# endif
+# define machine_is_pop()	(machine_arch_type == MACH_TYPE_POP)
+#else
+# define machine_is_pop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAYER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAYER
+# endif
+# define machine_is_layer()	(machine_arch_type == MACH_TYPE_LAYER)
+#else
+# define machine_is_layer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRONDHEIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRONDHEIM
+# endif
+# define machine_is_trondheim()	(machine_arch_type == MACH_TYPE_TRONDHEIM)
+#else
+# define machine_is_trondheim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA
+# endif
+# define machine_is_eva()	(machine_arch_type == MACH_TYPE_EVA)
+#else
+# define machine_is_eva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRUST_TAURUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRUST_TAURUS
+# endif
+# define machine_is_trust_taurus()	(machine_arch_type == MACH_TYPE_TRUST_TAURUS)
+#else
+# define machine_is_trust_taurus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_HUASHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_HUASHAN
+# endif
+# define machine_is_ns2816_huashan()	(machine_arch_type == MACH_TYPE_NS2816_HUASHAN)
+#else
+# define machine_is_ns2816_huashan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_YANGCHENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_YANGCHENG
+# endif
+# define machine_is_ns2816_yangcheng()	(machine_arch_type == MACH_TYPE_NS2816_YANGCHENG)
+#else
+# define machine_is_ns2816_yangcheng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P852
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P852
+# endif
+# define machine_is_p852()	(machine_arch_type == MACH_TYPE_P852)
+#else
+# define machine_is_p852()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEA3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEA3
+# endif
+# define machine_is_flea3()	(machine_arch_type == MACH_TYPE_FLEA3)
+#else
+# define machine_is_flea3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOWFIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOWFIN
+# endif
+# define machine_is_bowfin()	(machine_arch_type == MACH_TYPE_BOWFIN)
+#else
+# define machine_is_bowfin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88DE3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88DE3100
+# endif
+# define machine_is_mv88de3100()	(machine_arch_type == MACH_TYPE_MV88DE3100)
+#else
+# define machine_is_mv88de3100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIA_AM35X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIA_AM35X
+# endif
+# define machine_is_pia_am35x()	(machine_arch_type == MACH_TYPE_PIA_AM35X)
+#else
+# define machine_is_pia_am35x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEDAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEDAR
+# endif
+# define machine_is_cedar()	(machine_arch_type == MACH_TYPE_CEDAR)
+#else
+# define machine_is_cedar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO_E
+# endif
+# define machine_is_picasso_e()	(machine_arch_type == MACH_TYPE_PICASSO_E)
+#else
+# define machine_is_picasso_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSUNG_E60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSUNG_E60
+# endif
+# define machine_is_samsung_e60()	(machine_arch_type == MACH_TYPE_SAMSUNG_E60)
+#else
+# define machine_is_samsung_e60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM9615_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM9615_CDP
+# endif
+# define machine_is_msm9615_cdp()	(machine_arch_type == MACH_TYPE_MSM9615_CDP)
+#else
+# define machine_is_msm9615_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR_MINI
+# endif
+# define machine_is_sdvr_mini()	(machine_arch_type == MACH_TYPE_SDVR_MINI)
+#else
+# define machine_is_sdvr_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_IJ3K
+# endif
+# define machine_is_omap3_ij3k()	(machine_arch_type == MACH_TYPE_OMAP3_IJ3K)
+#else
+# define machine_is_omap3_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MODASMC1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MODASMC1
+# endif
+# define machine_is_modasmc1()	(machine_arch_type == MACH_TYPE_MODASMC1)
+#else
+# define machine_is_modasmc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_RUMI3
+# endif
+# define machine_is_apq8064_rumi3()	(machine_arch_type == MACH_TYPE_APQ8064_RUMI3)
+#else
+# define machine_is_apq8064_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX506
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX506
+# endif
+# define machine_is_matrix506()	(machine_arch_type == MACH_TYPE_MATRIX506)
+#else
+# define machine_is_matrix506()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM9615_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM9615_MTP
+# endif
+# define machine_is_msm9615_mtp()	(machine_arch_type == MACH_TYPE_MSM9615_MTP)
+#else
+# define machine_is_msm9615_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM36X_SPAWNDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM36X_SPAWNDC
+# endif
+# define machine_is_dm36x_spawndc()	(machine_arch_type == MACH_TYPE_DM36X_SPAWNDC)
+#else
+# define machine_is_dm36x_spawndc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFF792
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFF792
+# endif
+# define machine_is_sff792()	(machine_arch_type == MACH_TYPE_SFF792)
+#else
+# define machine_is_sff792()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM335XIAEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM335XIAEVM
+# endif
+# define machine_is_am335xiaevm()	(machine_arch_type == MACH_TYPE_AM335XIAEVM)
+#else
+# define machine_is_am335xiaevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3C2440
+# endif
+# define machine_is_g3c2440()	(machine_arch_type == MACH_TYPE_G3C2440)
+#else
+# define machine_is_g3c2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TION270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TION270
+# endif
+# define machine_is_tion270()	(machine_arch_type == MACH_TYPE_TION270)
+#else
+# define machine_is_tion270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W22Q7ARM02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W22Q7ARM02
+# endif
+# define machine_is_w22q7arm02()	(machine_arch_type == MACH_TYPE_W22Q7ARM02)
+#else
+# define machine_is_w22q7arm02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_CAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_CAT
+# endif
+# define machine_is_omap_cat()	(machine_arch_type == MACH_TYPE_OMAP_CAT)
+#else
+# define machine_is_omap_cat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9N12EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9N12EK
+# endif
+# define machine_is_at91sam9n12ek()	(machine_arch_type == MACH_TYPE_AT91SAM9N12EK)
+#else
+# define machine_is_at91sam9n12ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORRISON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORRISON
+# endif
+# define machine_is_morrison()	(machine_arch_type == MACH_TYPE_MORRISON)
+#else
+# define machine_is_morrison()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVDU
+# endif
+# define machine_is_svdu()	(machine_arch_type == MACH_TYPE_SVDU)
+#else
+# define machine_is_svdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPP01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPP01
+# endif
+# define machine_is_lpp01()	(machine_arch_type == MACH_TYPE_LPP01)
+#else
+# define machine_is_lpp01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBC283
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBC283
+# endif
+# define machine_is_ubc283()	(machine_arch_type == MACH_TYPE_UBC283)
+#else
+# define machine_is_ubc283()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEPPELIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEPPELIN
+# endif
+# define machine_is_zeppelin()	(machine_arch_type == MACH_TYPE_ZEPPELIN)
+#else
+# define machine_is_zeppelin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTUS
+# endif
+# define machine_is_motus()	(machine_arch_type == MACH_TYPE_MOTUS)
+#else
+# define machine_is_motus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOMAINBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOMAINBOARD
+# endif
+# define machine_is_neomainboard()	(machine_arch_type == MACH_TYPE_NEOMAINBOARD)
+#else
+# define machine_is_neomainboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT3250
+# endif
+# define machine_is_devkit3250()	(machine_arch_type == MACH_TYPE_DEVKIT3250)
+#else
+# define machine_is_devkit3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT7000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT7000
+# endif
+# define machine_is_devkit7000()	(machine_arch_type == MACH_TYPE_DEVKIT7000)
+#else
+# define machine_is_devkit7000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMC_UIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMC_UIC
+# endif
+# define machine_is_fmc_uic()	(machine_arch_type == MACH_TYPE_FMC_UIC)
+#else
+# define machine_is_fmc_uic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMC_DCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMC_DCM
+# endif
+# define machine_is_fmc_dcm()	(machine_arch_type == MACH_TYPE_FMC_DCM)
+#else
+# define machine_is_fmc_dcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATWM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATWM
+# endif
+# define machine_is_batwm()	(machine_arch_type == MACH_TYPE_BATWM)
+#else
+# define machine_is_batwm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS6CB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS6CB
+# endif
+# define machine_is_atlas6cb()	(machine_arch_type == MACH_TYPE_ATLAS6CB)
+#else
+# define machine_is_atlas6cb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE
+# endif
+# define machine_is_blue()	(machine_arch_type == MACH_TYPE_BLUE)
+#else
+# define machine_is_blue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLORADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLORADO
+# endif
+# define machine_is_colorado()	(machine_arch_type == MACH_TYPE_COLORADO)
+#else
+# define machine_is_colorado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POPC
+# endif
+# define machine_is_popc()	(machine_arch_type == MACH_TYPE_POPC)
+#else
+# define machine_is_popc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PROMWAD_JADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PROMWAD_JADE
+# endif
+# define machine_is_promwad_jade()	(machine_arch_type == MACH_TYPE_PROMWAD_JADE)
+#else
+# define machine_is_promwad_jade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMP
+# endif
+# define machine_is_amp()	(machine_arch_type == MACH_TYPE_AMP)
+#else
+# define machine_is_amp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_AMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_AMP
+# endif
+# define machine_is_gnet_amp()	(machine_arch_type == MACH_TYPE_GNET_AMP)
+#else
+# define machine_is_gnet_amp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOQUES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOQUES
+# endif
+# define machine_is_toques()	(machine_arch_type == MACH_TYPE_TOQUES)
+#else
+# define machine_is_toques()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCT_STORM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCT_STORM
+# endif
+# define machine_is_dct_storm()	(machine_arch_type == MACH_TYPE_DCT_STORM)
+#else
+# define machine_is_dct_storm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OWL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OWL
+# endif
+# define machine_is_owl()	(machine_arch_type == MACH_TYPE_OWL)
+#else
+# define machine_is_owl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COGENT_CSB1741
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT_CSB1741
+# endif
+# define machine_is_cogent_csb1741()	(machine_arch_type == MACH_TYPE_COGENT_CSB1741)
+#else
+# define machine_is_cogent_csb1741()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADILLUSTRA610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADILLUSTRA610
+# endif
+# define machine_is_adillustra610()	(machine_arch_type == MACH_TYPE_ADILLUSTRA610)
+#else
+# define machine_is_adillustra610()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECAFE_NA04
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECAFE_NA04
+# endif
+# define machine_is_ecafe_na04()	(machine_arch_type == MACH_TYPE_ECAFE_NA04)
+#else
+# define machine_is_ecafe_na04()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POPCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POPCT
+# endif
+# define machine_is_popct()	(machine_arch_type == MACH_TYPE_POPCT)
+#else
+# define machine_is_popct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_HELENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_HELENA
+# endif
+# define machine_is_omap3_helena()	(machine_arch_type == MACH_TYPE_OMAP3_HELENA)
+#else
+# define machine_is_omap3_helena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACH
+# endif
+# define machine_is_ach()	(machine_arch_type == MACH_TYPE_ACH)
+#else
+# define machine_is_ach()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MODULE_DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MODULE_DTB
+# endif
+# define machine_is_module_dtb()	(machine_arch_type == MACH_TYPE_MODULE_DTB)
+#else
+# define machine_is_module_dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_ELISABETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_ELISABETH
+# endif
+# define machine_is_oslo_elisabeth()	(machine_arch_type == MACH_TYPE_OSLO_ELISABETH)
+#else
+# define machine_is_oslo_elisabeth()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT01
+# endif
+# define machine_is_tt01()	(machine_arch_type == MACH_TYPE_TT01)
+#else
+# define machine_is_tt01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_CDP
+# endif
+# define machine_is_msm8930_cdp()	(machine_arch_type == MACH_TYPE_MSM8930_CDP)
+#else
+# define machine_is_msm8930_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_MTP
+# endif
+# define machine_is_msm8930_mtp()	(machine_arch_type == MACH_TYPE_MSM8930_MTP)
+#else
+# define machine_is_msm8930_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_FLUID
+# endif
+# define machine_is_msm8930_fluid()	(machine_arch_type == MACH_TYPE_MSM8930_FLUID)
+#else
+# define machine_is_msm8930_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LTU11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LTU11
+# endif
+# define machine_is_ltu11()	(machine_arch_type == MACH_TYPE_LTU11)
+#else
+# define machine_is_ltu11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM1808_SPAWNCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM1808_SPAWNCO
+# endif
+# define machine_is_am1808_spawnco()	(machine_arch_type == MACH_TYPE_AM1808_SPAWNCO)
+#else
+# define machine_is_am1808_spawnco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLX6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLX6410
+# endif
+# define machine_is_flx6410()	(machine_arch_type == MACH_TYPE_FLX6410)
+#else
+# define machine_is_flx6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_QSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_QSB
+# endif
+# define machine_is_mx6q_qsb()	(machine_arch_type == MACH_TYPE_MX6Q_QSB)
+#else
+# define machine_is_mx6q_qsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_PLT424
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_PLT424
+# endif
+# define machine_is_mx53_plt424()	(machine_arch_type == MACH_TYPE_MX53_PLT424)
+#else
+# define machine_is_mx53_plt424()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JASMINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASMINE
+# endif
+# define machine_is_jasmine()	(machine_arch_type == MACH_TYPE_JASMINE)
+#else
+# define machine_is_jasmine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L138_OWLBOARD_PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L138_OWLBOARD_PLUS
+# endif
+# define machine_is_l138_owlboard_plus()	(machine_arch_type == MACH_TYPE_L138_OWLBOARD_PLUS)
+#else
+# define machine_is_l138_owlboard_plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WR21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WR21
+# endif
+# define machine_is_wr21()	(machine_arch_type == MACH_TYPE_WR21)
+#else
+# define machine_is_wr21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEABOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEABOY
+# endif
+# define machine_is_peaboy()	(machine_arch_type == MACH_TYPE_PEABOY)
+#else
+# define machine_is_peaboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28_PLATO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28_PLATO
+# endif
+# define machine_is_mx28_plato()	(machine_arch_type == MACH_TYPE_MX28_PLATO)
+#else
+# define machine_is_mx28_plato()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM2
+# endif
+# define machine_is_kacom2()	(machine_arch_type == MACH_TYPE_KACOM2)
+#else
+# define machine_is_kacom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLCO
+# endif
+# define machine_is_slco()	(machine_arch_type == MACH_TYPE_SLCO)
+#else
+# define machine_is_slco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX51PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX51PICO
+# endif
+# define machine_is_imx51pico()	(machine_arch_type == MACH_TYPE_IMX51PICO)
+#else
+# define machine_is_imx51pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLINK1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLINK1
+# endif
+# define machine_is_glink1()	(machine_arch_type == MACH_TYPE_GLINK1)
+#else
+# define machine_is_glink1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIAMOND
+# endif
+# define machine_is_diamond()	(machine_arch_type == MACH_TYPE_DIAMOND)
+#else
+# define machine_is_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D9000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D9000
+# endif
+# define machine_is_d9000()	(machine_arch_type == MACH_TYPE_D9000)
+#else
+# define machine_is_d9000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W5300E01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W5300E01
+# endif
+# define machine_is_w5300e01()	(machine_arch_type == MACH_TYPE_W5300E01)
+#else
+# define machine_is_w5300e01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM6000
+# endif
+# define machine_is_im6000()	(machine_arch_type == MACH_TYPE_IM6000)
+#else
+# define machine_is_im6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_FRED51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_FRED51
+# endif
+# define machine_is_mx51_fred51()	(machine_arch_type == MACH_TYPE_MX51_FRED51)
+#else
+# define machine_is_mx51_fred51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM32F2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM32F2
+# endif
+# define machine_is_stm32f2()	(machine_arch_type == MACH_TYPE_STM32F2)
+#else
+# define machine_is_stm32f2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VILLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VILLE
+# endif
+# define machine_is_ville()	(machine_arch_type == MACH_TYPE_VILLE)
+#else
+# define machine_is_ville()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTIP_MURNAU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTIP_MURNAU
+# endif
+# define machine_is_ptip_murnau()	(machine_arch_type == MACH_TYPE_PTIP_MURNAU)
+#else
+# define machine_is_ptip_murnau()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTIP_CLASSIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTIP_CLASSIC
+# endif
+# define machine_is_ptip_classic()	(machine_arch_type == MACH_TYPE_PTIP_CLASSIC)
+#else
+# define machine_is_ptip_classic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53GRB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53GRB
+# endif
+# define machine_is_mx53grb()	(machine_arch_type == MACH_TYPE_MX53GRB)
+#else
+# define machine_is_mx53grb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GAGARIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GAGARIN
+# endif
+# define machine_is_gagarin()	(machine_arch_type == MACH_TYPE_GAGARIN)
+#else
+# define machine_is_gagarin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_QRD1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_QRD1
+# endif
+# define machine_is_msm7627a_qrd1()	(machine_arch_type == MACH_TYPE_MSM7627A_QRD1)
+#else
+# define machine_is_msm7627a_qrd1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS2BIG
+# endif
+# define machine_is_nas2big()	(machine_arch_type == MACH_TYPE_NAS2BIG)
+#else
+# define machine_is_nas2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUPERFEMTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUPERFEMTO
+# endif
+# define machine_is_superfemto()	(machine_arch_type == MACH_TYPE_SUPERFEMTO)
+#else
+# define machine_is_superfemto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEUFEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEUFEL
+# endif
+# define machine_is_teufel()	(machine_arch_type == MACH_TYPE_TEUFEL)
+#else
+# define machine_is_teufel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINARA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINARA
+# endif
+# define machine_is_dinara()	(machine_arch_type == MACH_TYPE_DINARA)
+#else
+# define machine_is_dinara()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANQUISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANQUISH
+# endif
+# define machine_is_vanquish()	(machine_arch_type == MACH_TYPE_VANQUISH)
+#else
+# define machine_is_vanquish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPABOX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPABOX1
+# endif
+# define machine_is_zipabox1()	(machine_arch_type == MACH_TYPE_ZIPABOX1)
+#else
+# define machine_is_zipabox1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U9540
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U9540
+# endif
+# define machine_is_u9540()	(machine_arch_type == MACH_TYPE_U9540)
+#else
+# define machine_is_u9540()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JET
+# endif
+# define machine_is_jet()	(machine_arch_type == MACH_TYPE_JET)
+#else
+# define machine_is_jet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4412
+# endif
+# define machine_is_smdk4412()	(machine_arch_type == MACH_TYPE_SMDK4412)
+#else
+# define machine_is_smdk4412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELITE
+# endif
+# define machine_is_elite()	(machine_arch_type == MACH_TYPE_ELITE)
+#else
+# define machine_is_elite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320_HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320_HMI
+# endif
+# define machine_is_spear320_hmi()	(machine_arch_type == MACH_TYPE_SPEAR320_HMI)
+#else
+# define machine_is_spear320_hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTARIO
+# endif
+# define machine_is_ontario()	(machine_arch_type == MACH_TYPE_ONTARIO)
+#else
+# define machine_is_ontario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_SABRELITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_SABRELITE
+# endif
+# define machine_is_mx6q_sabrelite()	(machine_arch_type == MACH_TYPE_MX6Q_SABRELITE)
+#else
+# define machine_is_mx6q_sabrelite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC200
+# endif
+# define machine_is_vc200()	(machine_arch_type == MACH_TYPE_VC200)
+#else
+# define machine_is_vc200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7625A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7625A_FFA
+# endif
+# define machine_is_msm7625a_ffa()	(machine_arch_type == MACH_TYPE_MSM7625A_FFA)
+#else
+# define machine_is_msm7625a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7625A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7625A_SURF
+# endif
+# define machine_is_msm7625a_surf()	(machine_arch_type == MACH_TYPE_MSM7625A_SURF)
+#else
+# define machine_is_msm7625a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENTHOSSBP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENTHOSSBP
+# endif
+# define machine_is_benthossbp()	(machine_arch_type == MACH_TYPE_BENTHOSSBP)
+#else
+# define machine_is_benthossbp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5210
+# endif
+# define machine_is_smdk5210()	(machine_arch_type == MACH_TYPE_SMDK5210)
+#else
+# define machine_is_smdk5210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPQ2300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPQ2300
+# endif
+# define machine_is_empq2300()	(machine_arch_type == MACH_TYPE_EMPQ2300)
+#else
+# define machine_is_empq2300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIPOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPOS
+# endif
+# define machine_is_minipos()	(machine_arch_type == MACH_TYPE_MINIPOS)
+#else
+# define machine_is_minipos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP5_SEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP5_SEVM
+# endif
+# define machine_is_omap5_sevm()	(machine_arch_type == MACH_TYPE_OMAP5_SEVM)
+#else
+# define machine_is_omap5_sevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHELTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHELTER
+# endif
+# define machine_is_shelter()	(machine_arch_type == MACH_TYPE_SHELTER)
+#else
+# define machine_is_shelter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_DEVKIT8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_DEVKIT8500
+# endif
+# define machine_is_omap3_devkit8500()	(machine_arch_type == MACH_TYPE_OMAP3_DEVKIT8500)
+#else
+# define machine_is_omap3_devkit8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGETD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGETD
+# endif
+# define machine_is_edgetd()	(machine_arch_type == MACH_TYPE_EDGETD)
+#else
+# define machine_is_edgetd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COPPERYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COPPERYARD
+# endif
+# define machine_is_copperyard()	(machine_arch_type == MACH_TYPE_COPPERYARD)
+#else
+# define machine_is_copperyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE
+# endif
+# define machine_is_edge()	(machine_arch_type == MACH_TYPE_EDGE)
+#else
+# define machine_is_edge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE_U
+# endif
+# define machine_is_edge_u()	(machine_arch_type == MACH_TYPE_EDGE_U)
+#else
+# define machine_is_edge_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE_TD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE_TD
+# endif
+# define machine_is_edge_td()	(machine_arch_type == MACH_TYPE_EDGE_TD)
+#else
+# define machine_is_edge_td()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WDSS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WDSS
+# endif
+# define machine_is_wdss()	(machine_arch_type == MACH_TYPE_WDSS)
+#else
+# define machine_is_wdss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DL_PB25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DL_PB25
+# endif
+# define machine_is_dl_pb25()	(machine_arch_type == MACH_TYPE_DL_PB25)
+#else
+# define machine_is_dl_pb25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSS11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSS11
+# endif
+# define machine_is_dss11()	(machine_arch_type == MACH_TYPE_DSS11)
+#else
+# define machine_is_dss11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPA
+# endif
+# define machine_is_cpa()	(machine_arch_type == MACH_TYPE_CPA)
+#else
+# define machine_is_cpa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APTP2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APTP2000
+# endif
+# define machine_is_aptp2000()	(machine_arch_type == MACH_TYPE_APTP2000)
+#else
+# define machine_is_aptp2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARZEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARZEN
+# endif
+# define machine_is_marzen()	(machine_arch_type == MACH_TYPE_MARZEN)
+#else
+# define machine_is_marzen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ST_TURBINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ST_TURBINE
+# endif
+# define machine_is_st_turbine()	(machine_arch_type == MACH_TYPE_ST_TURBINE)
+#else
+# define machine_is_st_turbine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTL_IT3300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTL_IT3300
+# endif
+# define machine_is_gtl_it3300()	(machine_arch_type == MACH_TYPE_GTL_IT3300)
+#else
+# define machine_is_gtl_it3300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6_MULE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6_MULE
+# endif
+# define machine_is_mx6_mule()	(machine_arch_type == MACH_TYPE_MX6_MULE)
+#else
+# define machine_is_mx6_mule()	(0)
+#endif
+
+#ifdef CONFIG_MACH_V7PXA_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_V7PXA_DT
+# endif
+# define machine_is_v7pxa_dt()	(machine_arch_type == MACH_TYPE_V7PXA_DT)
+#else
+# define machine_is_v7pxa_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_V7MMP_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_V7MMP_DT
+# endif
+# define machine_is_v7mmp_dt()	(machine_arch_type == MACH_TYPE_V7MMP_DT)
+#else
+# define machine_is_v7mmp_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON7
+# endif
+# define machine_is_dragon7()	(machine_arch_type == MACH_TYPE_DRAGON7)
+#else
+# define machine_is_dragon7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KROME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KROME
+# endif
+# define machine_is_krome()	(machine_arch_type == MACH_TYPE_KROME)
+#else
+# define machine_is_krome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISDANTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISDANTE
+# endif
+# define machine_is_oratisdante()	(machine_arch_type == MACH_TYPE_ORATISDANTE)
+#else
+# define machine_is_oratisdante()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FATHOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FATHOM
+# endif
+# define machine_is_fathom()	(machine_arch_type == MACH_TYPE_FATHOM)
+#else
+# define machine_is_fathom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS325
+# endif
+# define machine_is_dns325()	(machine_arch_type == MACH_TYPE_DNS325)
+#else
+# define machine_is_dns325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SARNEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SARNEN
+# endif
+# define machine_is_sarnen()	(machine_arch_type == MACH_TYPE_SARNEN)
+#else
+# define machine_is_sarnen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_G1
+# endif
+# define machine_is_ubisys_g1()	(machine_arch_type == MACH_TYPE_UBISYS_G1)
+#else
+# define machine_is_ubisys_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_PF1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_PF1
+# endif
+# define machine_is_mx53_pf1()	(machine_arch_type == MACH_TYPE_MX53_PF1)
+#else
+# define machine_is_mx53_pf1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASANTI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASANTI
+# endif
+# define machine_is_asanti()	(machine_arch_type == MACH_TYPE_ASANTI)
+#else
+# define machine_is_asanti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOLTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOLTA
+# endif
+# define machine_is_volta()	(machine_arch_type == MACH_TYPE_VOLTA)
+#else
+# define machine_is_volta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KNIGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KNIGHT
+# endif
+# define machine_is_knight()	(machine_arch_type == MACH_TYPE_KNIGHT)
+#else
+# define machine_is_knight()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEAGLEBONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEAGLEBONE
+# endif
+# define machine_is_beaglebone()	(machine_arch_type == MACH_TYPE_BEAGLEBONE)
+#else
+# define machine_is_beaglebone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BECKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BECKER
+# endif
+# define machine_is_becker()	(machine_arch_type == MACH_TYPE_BECKER)
+#else
+# define machine_is_becker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FC360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FC360
+# endif
+# define machine_is_fc360()	(machine_arch_type == MACH_TYPE_FC360)
+#else
+# define machine_is_fc360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PMI2_XLS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PMI2_XLS
+# endif
+# define machine_is_pmi2_xls()	(machine_arch_type == MACH_TYPE_PMI2_XLS)
+#else
+# define machine_is_pmi2_xls()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TARANTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARANTO
+# endif
+# define machine_is_taranto()	(machine_arch_type == MACH_TYPE_TARANTO)
+#else
+# define machine_is_taranto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLUTUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLUTUX
+# endif
+# define machine_is_plutux()	(machine_arch_type == MACH_TYPE_PLUTUX)
+#else
+# define machine_is_plutux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPMP_MEDCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPMP_MEDCOM
+# endif
+# define machine_is_ipmp_medcom()	(machine_arch_type == MACH_TYPE_IPMP_MEDCOM)
+#else
+# define machine_is_ipmp_medcom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABSOLUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABSOLUT
+# endif
+# define machine_is_absolut()	(machine_arch_type == MACH_TYPE_ABSOLUT)
+#else
+# define machine_is_absolut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWPB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWPB3
+# endif
+# define machine_is_awpb3()	(machine_arch_type == MACH_TYPE_AWPB3)
+#else
+# define machine_is_awpb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NFP32XX_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NFP32XX_DT
+# endif
+# define machine_is_nfp32xx_dt()	(machine_arch_type == MACH_TYPE_NFP32XX_DT)
+#else
+# define machine_is_nfp32xx_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DL_PB53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DL_PB53
+# endif
+# define machine_is_dl_pb53()	(machine_arch_type == MACH_TYPE_DL_PB53)
+#else
+# define machine_is_dl_pb53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACU_II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACU_II
+# endif
+# define machine_is_acu_ii()	(machine_arch_type == MACH_TYPE_ACU_II)
+#else
+# define machine_is_acu_ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVALON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVALON
+# endif
+# define machine_is_avalon()	(machine_arch_type == MACH_TYPE_AVALON)
+#else
+# define machine_is_avalon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPHINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPHINX
+# endif
+# define machine_is_sphinx()	(machine_arch_type == MACH_TYPE_SPHINX)
+#else
+# define machine_is_sphinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TITAN_T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TITAN_T
+# endif
+# define machine_is_titan_t()	(machine_arch_type == MACH_TYPE_TITAN_T)
+#else
+# define machine_is_titan_t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARVEST_BORIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARVEST_BORIS
+# endif
+# define machine_is_harvest_boris()	(machine_arch_type == MACH_TYPE_HARVEST_BORIS)
+#else
+# define machine_is_harvest_boris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_MSM7X30_M3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_MSM7X30_M3S
+# endif
+# define machine_is_mach_msm7x30_m3s()	(machine_arch_type == MACH_TYPE_MACH_MSM7X30_M3S)
+#else
+# define machine_is_mach_msm7x30_m3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5250
+# endif
+# define machine_is_smdk5250()	(machine_arch_type == MACH_TYPE_SMDK5250)
+#else
+# define machine_is_smdk5250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_LITE
+# endif
+# define machine_is_imxt_lite()	(machine_arch_type == MACH_TYPE_IMXT_LITE)
+#else
+# define machine_is_imxt_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_STD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_STD
+# endif
+# define machine_is_imxt_std()	(machine_arch_type == MACH_TYPE_IMXT_STD)
+#else
+# define machine_is_imxt_std()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_LOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_LOG
+# endif
+# define machine_is_imxt_log()	(machine_arch_type == MACH_TYPE_IMXT_LOG)
+#else
+# define machine_is_imxt_log()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_NAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_NAV
+# endif
+# define machine_is_imxt_nav()	(machine_arch_type == MACH_TYPE_IMXT_NAV)
+#else
+# define machine_is_imxt_nav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_FULL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_FULL
+# endif
+# define machine_is_imxt_full()	(machine_arch_type == MACH_TYPE_IMXT_FULL)
+#else
+# define machine_is_imxt_full()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG09015
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG09015
+# endif
+# define machine_is_ag09015()	(machine_arch_type == MACH_TYPE_AG09015)
+#else
+# define machine_is_ag09015()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM3517_MT_VENTOUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM3517_MT_VENTOUX
+# endif
+# define machine_is_am3517_mt_ventoux()	(machine_arch_type == MACH_TYPE_AM3517_MT_VENTOUX)
+#else
+# define machine_is_am3517_mt_ventoux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1ARM9
+# endif
+# define machine_is_dp1arm9()	(machine_arch_type == MACH_TYPE_DP1ARM9)
+#else
+# define machine_is_dp1arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO_M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO_M
+# endif
+# define machine_is_picasso_m()	(machine_arch_type == MACH_TYPE_PICASSO_M)
+#else
+# define machine_is_picasso_m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIDEO_GADGET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIDEO_GADGET
+# endif
+# define machine_is_video_gadget()	(machine_arch_type == MACH_TYPE_VIDEO_GADGET)
+#else
+# define machine_is_video_gadget()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_OM3X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_OM3X
+# endif
+# define machine_is_mtt_om3x()	(machine_arch_type == MACH_TYPE_MTT_OM3X)
+#else
+# define machine_is_mtt_om3x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_ARM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_ARM2
+# endif
+# define machine_is_mx6q_arm2()	(machine_arch_type == MACH_TYPE_MX6Q_ARM2)
+#else
+# define machine_is_mx6q_arm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOSAM9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOSAM9G45
+# endif
+# define machine_is_picosam9g45()	(machine_arch_type == MACH_TYPE_PICOSAM9G45)
+#else
+# define machine_is_picosam9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPM_DM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPM_DM365
+# endif
+# define machine_is_vpm_dm365()	(machine_arch_type == MACH_TYPE_VPM_DM365)
+#else
+# define machine_is_vpm_dm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONFIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONFIRE
+# endif
+# define machine_is_bonfire()	(machine_arch_type == MACH_TYPE_BONFIRE)
+#else
+# define machine_is_bonfire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT2P2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT2P2D
+# endif
+# define machine_is_mt2p2d()	(machine_arch_type == MACH_TYPE_MT2P2D)
+#else
+# define machine_is_mt2p2d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGPDA01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGPDA01
+# endif
+# define machine_is_sigpda01()	(machine_arch_type == MACH_TYPE_SIGPDA01)
+#else
+# define machine_is_sigpda01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CN27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CN27
+# endif
+# define machine_is_cn27()	(machine_arch_type == MACH_TYPE_CN27)
+#else
+# define machine_is_cn27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_CWTAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_CWTAP
+# endif
+# define machine_is_mx25_cwtap()	(machine_arch_type == MACH_TYPE_MX25_CWTAP)
+#else
+# define machine_is_mx25_cwtap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF28
+# endif
+# define machine_is_apf28()	(machine_arch_type == MACH_TYPE_APF28)
+#else
+# define machine_is_apf28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MAXWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MAXWELL
+# endif
+# define machine_is_pelco_maxwell()	(machine_arch_type == MACH_TYPE_PELCO_MAXWELL)
+#else
+# define machine_is_pelco_maxwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GE_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GE_PHOENIX
+# endif
+# define machine_is_ge_phoenix()	(machine_arch_type == MACH_TYPE_GE_PHOENIX)
+#else
+# define machine_is_ge_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC_A500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC_A500
+# endif
+# define machine_is_empc_a500()	(machine_arch_type == MACH_TYPE_EMPC_A500)
+#else
+# define machine_is_empc_a500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMS_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMS_ARM9
+# endif
+# define machine_is_ims_arm9()	(machine_arch_type == MACH_TYPE_IMS_ARM9)
+#else
+# define machine_is_ims_arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2416
+# endif
+# define machine_is_mini2416()	(machine_arch_type == MACH_TYPE_MINI2416)
+#else
+# define machine_is_mini2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2450
+# endif
+# define machine_is_mini2450()	(machine_arch_type == MACH_TYPE_MINI2450)
+#else
+# define machine_is_mini2450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI310
+# endif
+# define machine_is_mini310()	(machine_arch_type == MACH_TYPE_MINI310)
+#else
+# define machine_is_mini310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR_HURRICANE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR_HURRICANE
+# endif
+# define machine_is_spear_hurricane()	(machine_arch_type == MACH_TYPE_SPEAR_HURRICANE)
+#else
+# define machine_is_spear_hurricane()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT7208
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT7208
+# endif
+# define machine_is_mt7208()	(machine_arch_type == MACH_TYPE_MT7208)
+#else
+# define machine_is_mt7208()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC178X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC178X
+# endif
+# define machine_is_lpc178x()	(machine_arch_type == MACH_TYPE_LPC178X)
+#else
+# define machine_is_lpc178x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARLEYS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARLEYS
+# endif
+# define machine_is_farleys()	(machine_arch_type == MACH_TYPE_FARLEYS)
+#else
+# define machine_is_farleys()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFM32GG_DK3750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFM32GG_DK3750
+# endif
+# define machine_is_efm32gg_dk3750()	(machine_arch_type == MACH_TYPE_EFM32GG_DK3750)
+#else
+# define machine_is_efm32gg_dk3750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEUS_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEUS_BOARD
+# endif
+# define machine_is_zeus_board()	(machine_arch_type == MACH_TYPE_ZEUS_BOARD)
+#else
+# define machine_is_zeus_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC51
+# endif
+# define machine_is_cc51()	(machine_arch_type == MACH_TYPE_CC51)
+#else
+# define machine_is_cc51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FXI_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FXI_C210
+# endif
+# define machine_is_fxi_c210()	(machine_arch_type == MACH_TYPE_FXI_C210)
+#else
+# define machine_is_fxi_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8627_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8627_CDP
+# endif
+# define machine_is_msm8627_cdp()	(machine_arch_type == MACH_TYPE_MSM8627_CDP)
+#else
+# define machine_is_msm8627_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8627_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8627_MTP
+# endif
+# define machine_is_msm8627_mtp()	(machine_arch_type == MACH_TYPE_MSM8627_MTP)
+#else
+# define machine_is_msm8627_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO800EVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO800EVA
+# endif
+# define machine_is_armadillo800eva()	(machine_arch_type == MACH_TYPE_ARMADILLO800EVA)
+#else
+# define machine_is_armadillo800eva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOU
+# endif
+# define machine_is_primou()	(machine_arch_type == MACH_TYPE_PRIMOU)
+#else
+# define machine_is_primou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOC
+# endif
+# define machine_is_primoc()	(machine_arch_type == MACH_TYPE_PRIMOC)
+#else
+# define machine_is_primoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOCT
+# endif
+# define machine_is_primoct()	(machine_arch_type == MACH_TYPE_PRIMOCT)
+#else
+# define machine_is_primoct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9500
+# endif
+# define machine_is_a9500()	(machine_arch_type == MACH_TYPE_A9500)
+#else
+# define machine_is_a9500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLUTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLUTO
+# endif
+# define machine_is_pluto()	(machine_arch_type == MACH_TYPE_PLUTO)
+#else
+# define machine_is_pluto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACFX100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACFX100
+# endif
+# define machine_is_acfx100()	(machine_arch_type == MACH_TYPE_ACFX100)
+#else
+# define machine_is_acfx100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_RUMI3
+# endif
+# define machine_is_msm8625_rumi3()	(machine_arch_type == MACH_TYPE_MSM8625_RUMI3)
+#else
+# define machine_is_msm8625_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALENTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALENTE
+# endif
+# define machine_is_valente()	(machine_arch_type == MACH_TYPE_VALENTE)
+#else
+# define machine_is_valente()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRFS_RFEYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRFS_RFEYE
+# endif
+# define machine_is_crfs_rfeye()	(machine_arch_type == MACH_TYPE_CRFS_RFEYE)
+#else
+# define machine_is_crfs_rfeye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFEYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFEYE
+# endif
+# define machine_is_rfeye()	(machine_arch_type == MACH_TYPE_RFEYE)
+#else
+# define machine_is_rfeye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC3
+# endif
+# define machine_is_phidget_sbc3()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC3)
+#else
+# define machine_is_phidget_sbc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCW_MIKA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCW_MIKA
+# endif
+# define machine_is_tcw_mika()	(machine_arch_type == MACH_TYPE_TCW_MIKA)
+#else
+# define machine_is_tcw_mika()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX28_EGF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX28_EGF
+# endif
+# define machine_is_imx28_egf()	(machine_arch_type == MACH_TYPE_IMX28_EGF)
+#else
+# define machine_is_imx28_egf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALENTE_WX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALENTE_WX
+# endif
+# define machine_is_valente_wx()	(machine_arch_type == MACH_TYPE_VALENTE_WX)
+#else
+# define machine_is_valente_wx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUANGSHANS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUANGSHANS
+# endif
+# define machine_is_huangshans()	(machine_arch_type == MACH_TYPE_HUANGSHANS)
+#else
+# define machine_is_huangshans()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOSPHORUS1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOSPHORUS1
+# endif
+# define machine_is_bosphorus1()	(machine_arch_type == MACH_TYPE_BOSPHORUS1)
+#else
+# define machine_is_bosphorus1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA
+# endif
+# define machine_is_prima()	(machine_arch_type == MACH_TYPE_PRIMA)
+#else
+# define machine_is_prima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVITA_ULK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVITA_ULK
+# endif
+# define machine_is_evita_ulk()	(machine_arch_type == MACH_TYPE_EVITA_ULK)
+#else
+# define machine_is_evita_ulk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERISC600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERISC600
+# endif
+# define machine_is_merisc600()	(machine_arch_type == MACH_TYPE_MERISC600)
+#else
+# define machine_is_merisc600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOLAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOLAK
+# endif
+# define machine_is_dolak()	(machine_arch_type == MACH_TYPE_DOLAK)
+#else
+# define machine_is_dolak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC53
+# endif
+# define machine_is_sbc53()	(machine_arch_type == MACH_TYPE_SBC53)
+#else
+# define machine_is_sbc53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELITE_ULK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELITE_ULK
+# endif
+# define machine_is_elite_ulk()	(machine_arch_type == MACH_TYPE_ELITE_ULK)
+#else
+# define machine_is_elite_ulk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POV2
+# endif
+# define machine_is_pov2()	(machine_arch_type == MACH_TYPE_POV2)
+#else
+# define machine_is_pov2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_2G
+# endif
+# define machine_is_ipod_touch_2g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_2G)
+#else
+# define machine_is_ipod_touch_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DA850_PQAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DA850_PQAB
+# endif
+# define machine_is_da850_pqab()	(machine_arch_type == MACH_TYPE_DA850_PQAB)
+#else
+# define machine_is_da850_pqab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_EVB
+# endif
+# define machine_is_msm7627a_evb()	(machine_arch_type == MACH_TYPE_MSM7627A_EVB)
+#else
+# define machine_is_msm7627a_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_CDP
+# endif
+# define machine_is_apq8064_cdp()	(machine_arch_type == MACH_TYPE_APQ8064_CDP)
+#else
+# define machine_is_apq8064_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_MTP
+# endif
+# define machine_is_apq8064_mtp()	(machine_arch_type == MACH_TYPE_APQ8064_MTP)
+#else
+# define machine_is_apq8064_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_LIQUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_LIQUID
+# endif
+# define machine_is_apq8064_liquid()	(machine_arch_type == MACH_TYPE_APQ8064_LIQUID)
+#else
+# define machine_is_apq8064_liquid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_CDP
+# endif
+# define machine_is_mpq8064_cdp()	(machine_arch_type == MACH_TYPE_MPQ8064_CDP)
+#else
+# define machine_is_mpq8064_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_HRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_HRD
+# endif
+# define machine_is_mpq8064_hrd()	(machine_arch_type == MACH_TYPE_MPQ8064_HRD)
+#else
+# define machine_is_mpq8064_hrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_DTV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_DTV
+# endif
+# define machine_is_mpq8064_dtv()	(machine_arch_type == MACH_TYPE_MPQ8064_DTV)
+#else
+# define machine_is_mpq8064_dtv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_QRD3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_QRD3
+# endif
+# define machine_is_msm7627a_qrd3()	(machine_arch_type == MACH_TYPE_MSM7627A_QRD3)
+#else
+# define machine_is_msm7627a_qrd3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_SURF
+# endif
+# define machine_is_msm8625_surf()	(machine_arch_type == MACH_TYPE_MSM8625_SURF)
+#else
+# define machine_is_msm8625_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_EVB
+# endif
+# define machine_is_msm8625_evb()	(machine_arch_type == MACH_TYPE_MSM8625_EVB)
+#else
+# define machine_is_msm8625_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_QRD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_QRD7
+# endif
+# define machine_is_msm8625_qrd7()	(machine_arch_type == MACH_TYPE_MSM8625_QRD7)
+#else
+# define machine_is_msm8625_qrd7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_FFA
+# endif
+# define machine_is_msm8625_ffa()	(machine_arch_type == MACH_TYPE_MSM8625_FFA)
+#else
+# define machine_is_msm8625_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_EVT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_EVT
+# endif
+# define machine_is_msm8625_evt()	(machine_arch_type == MACH_TYPE_MSM8625_EVT)
+#else
+# define machine_is_msm8625_evt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_MAKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_MAKO
+# endif
+# define machine_is_apq8064_mako()	(machine_arch_type == MACH_TYPE_APQ8064_MAKO)
+#else
+# define machine_is_apq8064_mako()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_FLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_FLO
+# endif
+# define machine_is_apq8064_flo()	(machine_arch_type == MACH_TYPE_APQ8064_FLO)
+#else
+# define machine_is_apq8064_flo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_DEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_DEB
+# endif
+# define machine_is_apq8064_deb()	(machine_arch_type == MACH_TYPE_APQ8064_DEB)
+#else
+# define machine_is_apq8064_deb()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/utsrelease.h flo-ElementalX-5.00-patched/include/generated/utsrelease.h
--- flo-ElementalX-5.00/include/generated/utsrelease.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/utsrelease.h	2016-06-01 15:48:28.000000000 +0000
@@ -0,0 +1 @@
+#define UTS_RELEASE "3.4.0-flo"
diff -urN flo-ElementalX-5.00/include/linux/device.h flo-ElementalX-5.00-patched/include/linux/device.h
--- flo-ElementalX-5.00/include/linux/device.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/device.h	2014-12-03 11:07:31.000000000 +0000
@@ -531,6 +531,10 @@
 #else
 extern void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp);
 #endif
+extern void devres_for_each_res(struct device *dev, dr_release_t release,
+				dr_match_t match, void *match_data,
+				void (*fn)(struct device *, void *, void *),
+				void *data);
 extern void devres_free(void *res);
 extern void devres_add(struct device *dev, void *res);
 extern void *devres_find(struct device *dev, dr_release_t release,
@@ -683,6 +687,11 @@
 	void	(*release)(struct device *dev);
 };
 
+static inline struct device *kobj_to_dev(struct kobject *kobj)
+{
+	return container_of(kobj, struct device, kobj);
+}
+
 /* Get the wakeup routines, which depend on struct device */
 #include <linux/pm_wakeup.h>
 
diff -urN flo-ElementalX-5.00/include/linux/firmware.h flo-ElementalX-5.00-patched/include/linux/firmware.h
--- flo-ElementalX-5.00/include/linux/firmware.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/firmware.h	2016-06-01 15:47:50.000000000 +0000
@@ -12,6 +12,9 @@
 	size_t size;
 	const u8 *data;
 	struct page **pages;
+
+	/* firmware loader private fields */
+	void *priv;
 };
 
 struct module;
@@ -44,6 +47,8 @@
 	void (*cont)(const struct firmware *fw, void *context));
 
 void release_firmware(const struct firmware *fw);
+int cache_firmware(const char *name);
+int uncache_firmware(const char *name);
 #else
 static inline int request_firmware(const struct firmware **fw,
 				   const char *name,
@@ -62,6 +67,16 @@
 static inline void release_firmware(const struct firmware *fw)
 {
 }
+
+static inline int cache_firmware(const char *name)
+{
+	return -ENOENT;
+}
+
+static inline int uncache_firmware(const char *name)
+{
+	return -EINVAL;
+}
 #endif
 
 #endif
diff -urN flo-ElementalX-5.00/include/linux/genhd.h flo-ElementalX-5.00-patched/include/linux/genhd.h
--- flo-ElementalX-5.00/include/linux/genhd.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/genhd.h	2016-06-01 16:13:59.000000000 +0000
@@ -16,7 +16,7 @@
 
 #ifdef CONFIG_BLOCK
 
-#define kobj_to_dev(k)		container_of((k), struct device, kobj)
+//#define kobj_to_dev(k)		container_of((k), struct device, kobj)
 #define dev_to_disk(device)	container_of((device), struct gendisk, part0.__dev)
 #define dev_to_part(device)	container_of((device), struct hd_struct, __dev)
 #define disk_to_dev(disk)	(&(disk)->part0.__dev)
diff -urN flo-ElementalX-5.00/include/linux/genlock.h flo-ElementalX-5.00-patched/include/linux/genlock.h
--- flo-ElementalX-5.00/include/linux/genlock.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/genlock.h	2016-06-03 17:13:57.000000000 +0000
@@ -8,6 +8,7 @@
 
 struct genlock_handle *genlock_get_handle(void);
 struct genlock_handle *genlock_get_handle_fd(int fd);
+int genlock_get_fd_handle(struct genlock_handle *handle);
 void genlock_put_handle(struct genlock_handle *handle);
 struct genlock *genlock_create_lock(struct genlock_handle *);
 struct genlock *genlock_attach_lock(struct genlock_handle *, int fd);
diff -urN flo-ElementalX-5.00/include/linux/ion.h flo-ElementalX-5.00-patched/include/linux/ion.h
--- flo-ElementalX-5.00/include/linux/ion.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/ion.h	2016-06-03 17:03:09.000000000 +0000
@@ -243,11 +243,19 @@
 void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
 
 /**
- * ion_share_dma_buf() - given an ion client, create a dma-buf fd
+ * ion_share_dma_buf() - share buffer as dma-buf
  * @client:	the client
  * @handle:	the handle
  */
-int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle);
+struct dma_buf *ion_share_dma_buf(struct ion_client *client,
+						struct ion_handle *handle);
+
+/**
+ * ion_share_dma_buf_fd() - given an ion client, create a dma-buf fd
+ * @client:	the client
+ * @handle:	the handle
+ */
+int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle);
 
 /**
  * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
diff -urN flo-ElementalX-5.00/include/linux/pm.h flo-ElementalX-5.00-patched/include/linux/pm.h
--- flo-ElementalX-5.00/include/linux/pm.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/pm.h	2016-06-01 15:47:50.000000000 +0000
@@ -640,6 +640,7 @@
 	} while (0)
 
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
+extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));
 
 extern int pm_generic_prepare(struct device *dev);
 extern int pm_generic_suspend_late(struct device *dev);
@@ -679,6 +680,10 @@
 	return 0;
 }
 
+static inline void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))
+{
+}
+
 #define pm_generic_prepare	NULL
 #define pm_generic_suspend	NULL
 #define pm_generic_resume	NULL
diff -urN flo-ElementalX-5.00/include/linux/version.h flo-ElementalX-5.00-patched/include/linux/version.h
--- flo-ElementalX-5.00/include/linux/version.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/version.h	2016-06-01 15:48:26.000000000 +0000
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 197632
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -urN flo-ElementalX-5.00/include/net/bluetooth/amp.h flo-ElementalX-5.00-patched/include/net/bluetooth/amp.h
--- flo-ElementalX-5.00/include/net/bluetooth/amp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/amp.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,293 +0,0 @@
-/*
-   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 and
-   only version 2 as published by the Free Software Foundation.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-*/
-
-#ifndef __AMP_H
-#define __AMP_H
-
-/* AMP defaults */
-
-#define A2MP_RSP_TIMEOUT        (8000)  /*  8 seconds */
-
-/* A2MP Protocol */
-
-/* A2MP command codes */
-#define A2MP_COMMAND_REJ         0x01
-#define A2MP_DISCOVER_REQ        0x02
-#define A2MP_DISCOVER_RSP        0x03
-#define A2MP_CHANGE_NOTIFY       0x04
-#define A2MP_CHANGE_RSP          0x05
-#define A2MP_GETINFO_REQ         0x06
-#define A2MP_GETINFO_RSP         0x07
-#define A2MP_GETAMPASSOC_REQ     0x08
-#define A2MP_GETAMPASSOC_RSP     0x09
-#define A2MP_CREATEPHYSLINK_REQ  0x0A
-#define A2MP_CREATEPHYSLINK_RSP  0x0B
-#define A2MP_DISCONNPHYSLINK_REQ 0x0C
-#define A2MP_DISCONNPHYSLINK_RSP 0x0D
-
-struct a2mp_cmd_hdr {
-	__u8       code;
-	__u8       ident;
-	__le16     len;
-} __packed;
-
-struct a2mp_cmd_rej {
-	__le16     reason;
-} __packed;
-
-struct a2mp_discover_req {
-	__le16     mtu;
-	__le16     ext_feat;
-} __packed;
-
-struct a2mp_cl {
-	__u8       id;
-	__u8       type;
-	__u8       status;
-} __packed;
-
-struct a2mp_discover_rsp {
-	__le16     mtu;
-	__le16     ext_feat;
-	struct a2mp_cl cl[0];
-} __packed;
-
-struct a2mp_getinfo_req {
-	__u8       id;
-} __packed;
-
-struct a2mp_getinfo_rsp {
-	__u8       id;
-	__u8       status;
-	__le32     total_bw;
-	__le32     max_bw;
-	__le32     min_latency;
-	__le16     pal_cap;
-	__le16     assoc_size;
-} __packed;
-
-struct a2mp_getampassoc_req {
-	__u8       id;
-} __packed;
-
-struct a2mp_getampassoc_rsp {
-	__u8       id;
-	__u8       status;
-	__u8       amp_assoc[0];
-} __packed;
-
-struct a2mp_createphyslink_req {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       amp_assoc[0];
-} __packed;
-
-struct a2mp_createphyslink_rsp {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       status;
-} __packed;
-
-struct a2mp_disconnphyslink_req {
-	__u8       local_id;
-	__u8       remote_id;
-} __packed;
-
-struct a2mp_disconnphyslink_rsp {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       status;
-} __packed;
-
-
-/* L2CAP-AMP module interface */
-int amp_init(void);
-void amp_exit(void);
-
-/* L2CAP-AMP fixed channel interface */
-void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb);
-
-/* L2CAP-AMP link interface */
-void amp_create_physical(struct l2cap_conn *conn, struct sock *sk);
-void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk);
-
-/* AMP manager internals */
-struct amp_ctrl {
-	struct  amp_mgr *mgr;
-	__u8    id;
-	__u8    type;
-	__u8    status;
-	__u32   total_bw;
-	__u32   max_bw;
-	__u32   min_latency;
-	__u16   pal_cap;
-	__u16   max_assoc_size;
-};
-
-struct amp_mgr {
-	struct list_head list;
-	__u8    discovered;
-	__u8    next_ident;
-	struct l2cap_conn *l2cap_conn;
-	struct socket *a2mp_sock;
-	struct list_head  ctx_list;
-	rwlock_t       ctx_list_lock;
-	struct amp_ctrl *ctrls;          /* @@ TODO s.b. list of controllers */
-	struct sk_buff *skb;
-	__u8   connected;
-};
-
-/* AMP Manager signalling contexts */
-#define AMP_GETAMPASSOC       1
-#define AMP_CREATEPHYSLINK    2
-#define AMP_ACCEPTPHYSLINK    3
-#define AMP_CREATELOGLINK     4
-#define AMP_ACCEPTLOGLINK     5
-
-/* Get AMP Assoc sequence */
-#define AMP_GAA_INIT           0
-#define AMP_GAA_RLAA_COMPLETE  1
-struct amp_gaa_state {
-	__u8       req_ident;
-	__u16      len_so_far;
-	__u8      *assoc;
-};
-
-/* Create Physical Link sequence */
-#define AMP_CPL_INIT           0
-#define AMP_CPL_DISC_RSP       1
-#define AMP_CPL_GETINFO_RSP    2
-#define AMP_CPL_GAA_RSP        3
-#define AMP_CPL_CPL_STATUS     4
-#define AMP_CPL_WRA_COMPLETE   5
-#define AMP_CPL_CHANNEL_SELECT 6
-#define AMP_CPL_RLA_COMPLETE   7
-#define AMP_CPL_PL_COMPLETE    8
-#define AMP_CPL_PL_CANCEL      9
-struct amp_cpl_state {
-	__u8       remote_id;
-	__u16      max_len;
-	__u8      *remote_assoc;
-	__u8      *local_assoc;
-	__u16      len_so_far;
-	__u16      rem_len;
-	__u8       phy_handle;
-};
-
-/* Accept Physical Link sequence */
-#define AMP_APL_INIT           0
-#define AMP_APL_APL_STATUS     1
-#define AMP_APL_WRA_COMPLETE   2
-#define AMP_APL_PL_COMPLETE    3
-struct amp_apl_state {
-	__u8       remote_id;
-	__u8       req_ident;
-	__u8      *remote_assoc;
-	__u16      len_so_far;
-	__u16      rem_len;
-	__u8       phy_handle;
-};
-
-/* Create/Accept Logical Link sequence */
-#define AMP_LOG_INIT         0
-#define AMP_LOG_LL_STATUS    1
-#define AMP_LOG_LL_COMPLETE  2
-struct amp_log_state {
-	__u8       remote_id;
-};
-
-/* Possible event types a context may wait for */
-#define AMP_INIT            0x01
-#define AMP_HCI_EVENT       0x02
-#define AMP_HCI_CMD_CMPLT   0x04
-#define AMP_HCI_CMD_STATUS  0x08
-#define AMP_A2MP_RSP        0x10
-#define AMP_KILLED          0x20
-#define AMP_CANCEL          0x40
-struct amp_ctx {
-	struct list_head list;
-	struct amp_mgr *mgr;
-	struct hci_dev *hdev;
-	__u8       type;
-	__u8       state;
-	union {
-		struct amp_gaa_state gaa;
-		struct amp_cpl_state cpl;
-		struct amp_apl_state apl;
-	} d;
-	__u8 evt_type;
-	__u8 evt_code;
-	__u16 opcode;
-	__u8 id;
-	__u8 rsp_ident;
-
-	struct sock *sk;
-	struct amp_ctx *deferred;
-	struct timer_list timer;
-};
-
-/* AMP work */
-struct amp_work_pl_timeout {
-	struct work_struct work;
-	struct amp_ctrl *ctrl;
-};
-struct amp_work_ctx_timeout {
-	struct work_struct work;
-	struct amp_ctx *ctx;
-};
-struct amp_work_data_ready {
-	struct work_struct work;
-	struct sock *sk;
-	int bytes;
-};
-struct amp_work_state_change {
-	struct work_struct work;
-	struct sock *sk;
-};
-struct amp_work_conn_ind {
-	struct work_struct work;
-	struct hci_conn *hcon;
-	struct sk_buff *skb;
-};
-struct amp_work_create_physical {
-	struct work_struct work;
-	struct l2cap_conn *conn;
-	u8 id;
-	struct sock *sk;
-};
-struct amp_work_accept_physical {
-	struct work_struct work;
-	struct l2cap_conn *conn;
-	u8 id;
-	struct sock *sk;
-};
-struct amp_work_cmd_cmplt {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u16 opcode;
-	struct sk_buff *skb;
-};
-struct amp_work_cmd_status {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u16 opcode;
-	u8 status;
-};
-struct amp_work_event {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u8 event;
-	struct sk_buff *skb;
-};
-
-#endif /* __AMP_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/bluetooth.h flo-ElementalX-5.00-patched/include/net/bluetooth/bluetooth.h
--- flo-ElementalX-5.00/include/net/bluetooth/bluetooth.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/bluetooth.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
-/*
+/* 
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -12,20 +12,20 @@
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
    IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
    SOFTWARE IS DISCLAIMED.
 */
 
 #ifndef __BLUETOOTH_H
 #define __BLUETOOTH_H
 
-#include <linux/types.h>
+#include <asm/types.h>
 #include <asm/byteorder.h>
 #include <linux/list.h>
 #include <linux/poll.h>
@@ -36,9 +36,13 @@
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #endif
 
+/* Bluetooth versions */
+#define BLUETOOTH_VER_1_1	1
+#define BLUETOOTH_VER_1_2	2
+#define BLUETOOTH_VER_2_0	3
+
 /* Reserv for core and drivers use */
 #define BT_SKB_RESERVE	8
-#define BT_SKB_RESERVE_80211	32
 
 #define BTPROTO_L2CAP	0
 #define BTPROTO_HCI	1
@@ -63,68 +67,56 @@
 #define BT_SECURITY_LOW		1
 #define BT_SECURITY_MEDIUM	2
 #define BT_SECURITY_HIGH	3
-#define BT_SECURITY_VERY_HIGH	4
 
 #define BT_DEFER_SETUP	7
+
 #define BT_FLUSHABLE	8
 
+#define BT_FLUSHABLE_OFF	0
+#define BT_FLUSHABLE_ON		1
+
 #define BT_POWER	9
 struct bt_power {
 	__u8 force_active;
 };
+#define BT_POWER_FORCE_ACTIVE_OFF 0
+#define BT_POWER_FORCE_ACTIVE_ON  1
 
-#define BT_AMP_POLICY          10
+#define BT_CHANNEL_POLICY	10
 
-/* Require BR/EDR (default policy)
- *   AMP controllers cannot be used
- *   Channel move requests from the remote device are denied
- *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR
+/* BR/EDR only (default policy)
+ *   AMP controllers cannot be used.
+ *   Channel move requests from the remote device are denied.
+ *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR.
  */
-#define BT_AMP_POLICY_REQUIRE_BR_EDR   0
+#define BT_CHANNEL_POLICY_BREDR_ONLY		0
 
-/* Prefer BR/EDR
- *   Allow use of AMP controllers
- *   If the L2CAP channel is currently on AMP, move it to BR/EDR
- *   Channel move requests from the remote device are allowed
+/* BR/EDR Preferred
+ *   Allow use of AMP controllers.
+ *   If the L2CAP channel is currently on AMP, move it to BR/EDR.
+ *   Channel move requests from the remote device are allowed.
  */
-#define BT_AMP_POLICY_PREFER_BR_EDR    1
+#define BT_CHANNEL_POLICY_BREDR_PREFERRED	1
 
-/* Prefer AMP
+/* AMP Preferred
  *   Allow use of AMP controllers
  *   If the L2CAP channel is currently on BR/EDR and AMP controller
- *     resources are available, initiate a channel move to AMP
- *   Channel move requests from the remote device are allowed
+ *     resources are available, initiate a channel move to AMP.
+ *   Channel move requests from the remote device are allowed.
  *   If the L2CAP socket has not been connected yet, try to create
  *     and configure the channel directly on an AMP controller rather
- *     than BR/EDR
+ *     than BR/EDR.
  */
-#define BT_AMP_POLICY_PREFER_AMP       2
-
-#define BT_LE_PARAMS	100
-
-#define BT_LE_SCAN_WINDOW_MIN		0x0004
-#define BT_LE_SCAN_WINDOW_MAX		0x4000
-#define BT_LE_SCAN_WINDOW_DEF		0x0004
-
-#define BT_LE_SCAN_INTERVAL_MIN		0x0004
-#define BT_LE_SCAN_INTERVAL_MAX		0x4000
-#define BT_LE_SCAN_INTERVAL_DEF		0x0008
-
-#define BT_LE_CONN_INTERVAL_MIN		0x0006
-#define BT_LE_CONN_INTERVAL_MAX		0x0C80
-#define BT_LE_CONN_INTERVAL_MIN_DEF	0x0008
-#define BT_LE_CONN_INTERVAL_MAX_DEF	0x0100
-
-#define BT_LE_LATENCY_MAX		0x01F4
-#define BT_LE_LATENCY_DEF		0x0000
-
-#define BT_LE_SUP_TO_MIN		0x000A
-#define BT_LE_SUP_TO_MAX		0x0C80
-#define BT_LE_SUP_TO_DEFAULT		0X03E8
+#define BT_CHANNEL_POLICY_AMP_PREFERRED		2
 
-#define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
-#define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
-#define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
+__printf(1, 2)
+int bt_info(const char *fmt, ...);
+__printf(1, 2)
+int bt_err(const char *fmt, ...);
+
+#define BT_INFO(fmt, ...)	bt_info(fmt "\n", ##__VA_ARGS__)
+#define BT_ERR(fmt, ...)	bt_err(fmt "\n", ##__VA_ARGS__)
+#define BT_DBG(fmt, ...)	pr_debug(fmt "\n", ##__VA_ARGS__)
 
 /* Connection and socket states */
 enum {
@@ -139,13 +131,40 @@
 	BT_CLOSED
 };
 
+/* If unused will be removed by compiler */
+static inline const char *state_to_string(int state)
+{
+	switch (state) {
+	case BT_CONNECTED:
+		return "BT_CONNECTED";
+	case BT_OPEN:
+		return "BT_OPEN";
+	case BT_BOUND:
+		return "BT_BOUND";
+	case BT_LISTEN:
+		return "BT_LISTEN";
+	case BT_CONNECT:
+		return "BT_CONNECT";
+	case BT_CONNECT2:
+		return "BT_CONNECT2";
+	case BT_CONFIG:
+		return "BT_CONFIG";
+	case BT_DISCONN:
+		return "BT_DISCONN";
+	case BT_CLOSED:
+		return "BT_CLOSED";
+	}
+
+	return "invalid state";
+}
+
 /* BD Address */
 typedef struct {
 	__u8 b[6];
 } __packed bdaddr_t;
 
-#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0} })
-#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff} })
+#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})
+#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff}})
 
 /* Copy, swap, convert BD Address */
 static inline int bacmp(bdaddr_t *ba1, bdaddr_t *ba2)
@@ -165,20 +184,6 @@
 
 #define bt_sk(__sk) ((struct bt_sock *) __sk)
 
-struct bt_le_params {
-	__u8  prohibit_remote_chg;
-	__u8  filter_policy;
-	__u16 scan_interval;
-	__u16 scan_window;
-	__u16 interval_min;
-	__u16 interval_max;
-	__u16 latency;
-	__u16 supervision_timeout;
-	__u16 min_ce_len;
-	__u16 max_ce_len;
-	__u16 conn_timeout;
-};
-
 struct bt_sock {
 	struct sock sk;
 	bdaddr_t    src;
@@ -186,7 +191,7 @@
 	struct list_head accept_q;
 	struct sock *parent;
 	u32 defer_setup;
-	struct bt_le_params le_params;
+	bool suspended;
 };
 
 struct bt_sock_list {
@@ -202,7 +207,7 @@
 				struct msghdr *msg, size_t len, int flags);
 int  bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 			struct msghdr *msg, size_t len, int flags);
-uint bt_sock_poll(struct file *file, struct socket *sock, poll_table *wait);
+uint bt_sock_poll(struct file * file, struct socket *sock, poll_table *wait);
 int  bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
 
@@ -211,25 +216,14 @@
 struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
 
 /* Skb helpers */
-struct bt_l2cap_control {
-	__u8  frame_type;
-	__u8  final;
-	__u8  sar;
-	__u8  super;
-	__u16 reqseq;
-	__u16 txseq;
-	__u8  poll;
-	__u8  fcs;
-};
-
 struct bt_skb_cb {
 	__u8 pkt_type;
 	__u8 incoming;
 	__u16 expect;
+	__u16 tx_seq;
 	__u8 retries;
+	__u8 sar;
 	__u8 force_active;
-	unsigned short channel;
-	struct bt_l2cap_control control;
 };
 #define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
 
@@ -237,8 +231,7 @@
 {
 	struct sk_buff *skb;
 
-	skb = alloc_skb(len + BT_SKB_RESERVE, how);
-	if (skb) {
+	if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -251,8 +244,7 @@
 	struct sk_buff *skb;
 
 	release_sock(sk);
-	skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err);
-	if (skb) {
+	if ((skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err))) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -277,7 +269,7 @@
 	return NULL;
 }
 
-int bt_err(__u16 code);
+int bt_to_errno(__u16 code);
 
 extern int hci_sock_init(void);
 extern void hci_sock_cleanup(void);
@@ -293,4 +285,6 @@
 int sco_init(void);
 void sco_exit(void);
 
+void bt_sock_reclassify_lock(struct sock *sk, int proto);
+
 #endif /* __BLUETOOTH_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci.h	2014-12-03 11:07:31.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,7 +25,7 @@
 #ifndef __HCI_H
 #define __HCI_H
 
-#define HCI_MAX_ACL_SIZE	1500
+#define HCI_MAX_ACL_SIZE	1024
 #define HCI_MAX_SCO_SIZE	255
 #define HCI_MAX_EVENT_SIZE	260
 #define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
@@ -37,7 +37,7 @@
 #define HCI_DEV_DOWN			4
 #define HCI_DEV_SUSPEND			5
 #define HCI_DEV_RESUME			6
-#define HCI_DEV_WRITE			7
+#define HCI_SMD                7
 
 /* HCI notify events */
 #define HCI_NOTIFY_CONN_ADD		1
@@ -52,7 +52,6 @@
 #define HCI_RS232	4
 #define HCI_PCI		5
 #define HCI_SDIO	6
-#define HCI_SMD		7
 
 /* HCI controller types */
 #define HCI_BREDR	0x00
@@ -79,6 +78,14 @@
 
 	HCI_RAW,
 
+	HCI_RESET,
+};
+
+/*
+ * BR/EDR and/or LE controller flags: the flags defined here should represent
+ * states from the controller.
+ */
+enum {
 	HCI_SETUP,
 	HCI_AUTO_OFF,
 	HCI_MGMT,
@@ -86,8 +93,16 @@
 	HCI_SERVICE_CACHE,
 	HCI_LINK_KEYS,
 	HCI_DEBUG_KEYS,
+	HCI_UNREGISTER,
 
-	HCI_RESET,
+	HCI_LE_SCAN,
+	HCI_SSP_ENABLED,
+	HCI_HS_ENABLED,
+	HCI_LE_ENABLED,
+	HCI_CONNECTABLE,
+	HCI_DISCOVERABLE,
+	HCI_LINK_SECURITY,
+	HCI_PENDING_CLASS,
 };
 
 /* HCI ioctl defines */
@@ -101,7 +116,6 @@
 #define HCIGETCONNLIST	_IOR('H', 212, int)
 #define HCIGETCONNINFO	_IOR('H', 213, int)
 #define HCIGETAUTHINFO	_IOR('H', 215, int)
-#define HCISETAUTHINFO  _IOR('H', 216, int)
 
 #define HCISETRAW	_IOW('H', 220, int)
 #define HCISETSCAN	_IOW('H', 221, int)
@@ -124,7 +138,8 @@
 #define HCI_PAIRING_TIMEOUT	(60000)	/* 60 seconds */
 #define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
 #define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
-#define HCI_CMD_TIMEOUT		(5000)	/* 5 seconds */
+#define HCI_CMD_TIMEOUT		(1000)	/* 1 seconds */
+#define HCI_ACL_TX_TIMEOUT	(45000)	/* 45 seconds */
 
 /* HCI data types */
 #define HCI_COMMAND_PKT		0x01
@@ -160,35 +175,16 @@
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
-#define ESCO_WBS	(ESCO_EV3 | (EDR_ESCO_MASK ^ ESCO_2EV3))
-
-#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
-#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
-#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
-			EDR_ESCO_MASK)
-
-/* Air Coding Format */
-#define ACF_CVSD	0x0000;
-#define ACF_ULAW	0x0001;
-#define ACF_ALAW	0x0002;
-#define ACF_TRANS	0x0003;
-
-/* Retransmission Effort */
-#define RE_NO_RETRANS		0x00;
-#define RE_POWER_CONSUMP	0x01;
-#define RE_LINK_QUALITY		0x02;
-#define RE_DONT_CARE		0xFF;
+#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
 
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
 #define ACL_CONT		0x01
 #define ACL_START		0x02
-#define ACL_COMPLETE		0x03
 #define ACL_ACTIVE_BCAST	0x04
 #define ACL_PICO_BCAST		0x08
 
-#define ACL_PB_MASK	(ACL_CONT | ACL_START)
-
 /* Baseband links */
 #define SCO_LINK	0x00
 #define ACL_LINK	0x01
@@ -224,6 +220,7 @@
 
 #define LMP_EV4		0x01
 #define LMP_EV5		0x02
+#define LMP_NO_BREDR	0x20
 #define LMP_LE		0x40
 
 #define LMP_SNIFF_SUBR	0x02
@@ -233,11 +230,18 @@
 #define LMP_EDR_3S_ESCO	0x80
 
 #define LMP_EXT_INQ	0x01
+#define LMP_SIMUL_LE_BR	0x02
 #define LMP_SIMPLE_PAIR	0x08
 #define LMP_NO_FLUSH	0x40
 
 #define LMP_LSTO	0x01
 #define LMP_INQ_TX_PWR	0x02
+#define LMP_EXTFEATURES	0x80
+
+/* Extended LMP features */
+#define LMP_HOST_SSP		0x01
+#define LMP_HOST_LE		0x02
+#define LMP_HOST_LE_BREDR	0x04
 
 /* Connection modes */
 #define HCI_CM_ACTIVE	0x0000
@@ -268,9 +272,46 @@
 #define HCI_AT_GENERAL_BONDING		0x04
 #define HCI_AT_GENERAL_BONDING_MITM	0x05
 
+/* Link Key types */
+#define HCI_LK_COMBINATION		0x00
+#define HCI_LK_LOCAL_UNIT		0x01
+#define HCI_LK_REMOTE_UNIT		0x02
+#define HCI_LK_DEBUG_COMBINATION	0x03
+#define HCI_LK_UNAUTH_COMBINATION	0x04
+#define HCI_LK_AUTH_COMBINATION		0x05
+#define HCI_LK_CHANGED_COMBINATION	0x06
+/* The spec doesn't define types for SMP keys, the _MASTER suffix is implied */
+#define HCI_SMP_STK			0x80
+#define HCI_SMP_STK_SLAVE		0x81
+#define HCI_SMP_LTK			0x82
+#define HCI_SMP_LTK_SLAVE		0x83
+
+/* ---- HCI Error Codes ---- */
+#define HCI_ERROR_AUTH_FAILURE		0x05
+#define HCI_ERROR_REJ_BAD_ADDR		0x0f
+#define HCI_ERROR_REMOTE_USER_TERM	0x13
+#define HCI_ERROR_LOCAL_HOST_TERM	0x16
+#define HCI_ERROR_PAIRING_NOT_ALLOWED	0x18
+
 /* Flow control modes */
-#define HCI_PACKET_BASED_FLOW_CTL_MODE	0x00
-#define HCI_BLOCK_BASED_FLOW_CTL_MODE	0x01
+#define HCI_FLOW_CTL_MODE_PACKET_BASED	0x00
+#define HCI_FLOW_CTL_MODE_BLOCK_BASED	0x01
+
+/* Extended Inquiry Response field types */
+#define EIR_FLAGS		0x01 /* flags */
+#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
+#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
+#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
+#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
+#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
+#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
+#define EIR_NAME_SHORT		0x08 /* shortened local name */
+#define EIR_NAME_COMPLETE	0x09 /* complete local name */
+#define EIR_TX_POWER		0x0A /* transmit power level */
+#define EIR_CLASS_OF_DEV	0x0D /* Class of Device */
+#define EIR_SSP_HASH_C		0x0E /* Simple Pairing Hash C */
+#define EIR_SSP_RAND_R		0x0F /* Simple Pairing Randomizer R */
+#define EIR_DEVICE_ID		0x10 /* device ID */
 
 /* -----  HCI Commands ---- */
 #define HCI_OP_NOP			0x0000
@@ -331,11 +372,6 @@
 	__u8     link_key[16];
 } __packed;
 
-struct hci_rp_link_key_reply {
-	__u8     status;
-	bdaddr_t bdaddr;
-} __packed;
-
 #define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
 struct hci_cp_link_key_neg_reply {
 	bdaddr_t bdaddr;
@@ -412,11 +448,6 @@
 	__le16   handle;
 } __packed;
 
-#define HCI_OP_READ_CLOCK_OFFSET	0x041f
-struct hci_cp_read_clock_offset {
-	__le16   handle;
-} __packed;
-
 #define HCI_OP_SETUP_SYNC_CONN		0x0428
 struct hci_cp_setup_sync_conn {
 	__le16   handle;
@@ -464,6 +495,14 @@
 
 #define HCI_OP_USER_CONFIRM_NEG_REPLY	0x042d
 
+#define HCI_OP_USER_PASSKEY_REPLY		0x042e
+struct hci_cp_user_passkey_reply {
+	bdaddr_t bdaddr;
+	__le32	passkey;
+} __packed;
+
+#define HCI_OP_USER_PASSKEY_NEG_REPLY	0x042f
+
 #define HCI_OP_REMOTE_OOB_DATA_REPLY	0x0430
 struct hci_cp_remote_oob_data_reply {
 	bdaddr_t bdaddr;
@@ -482,69 +521,6 @@
 	__u8     reason;
 } __packed;
 
-#define HCI_OP_CREATE_PHYS_LINK		0x0435
-struct hci_cp_create_phys_link {
-	__u8     phy_handle;
-	__u8     key_len;
-	__u8     type;
-	__u8     data[32];
-} __packed;
-
-#define HCI_OP_ACCEPT_PHYS_LINK		0x0436
-struct hci_cp_accept_phys_link {
-	__u8     phy_handle;
-	__u8     key_len;
-	__u8     type;
-	__u8     data[32];
-} __packed;
-
-#define HCI_OP_DISCONN_PHYS_LINK	0x0437
-struct hci_cp_disconn_phys_link {
-	__u8     phy_handle;
-	__u8     reason;
-} __packed;
-
-struct hci_ext_fs {
-	__u8       id;
-	__u8       type;
-	__le16     max_sdu;
-	__le32     sdu_arr_time;
-	__le32     acc_latency;
-	__le32     flush_to;
-} __packed;
-
-#define HCI_OP_CREATE_LOGICAL_LINK	0x0438
-#define HCI_OP_ACCEPT_LOGICAL_LINK	0x0439
-struct hci_cp_create_logical_link {
-	__u8               phy_handle;
-	struct hci_ext_fs  tx_fs;
-	struct hci_ext_fs  rx_fs;
-} __packed;
-
-#define HCI_OP_DISCONN_LOGICAL_LINK	0x043a
-struct hci_cp_disconn_logical_link {
-	__le16   log_handle;
-} __packed;
-
-#define HCI_OP_LOGICAL_LINK_CANCEL	0x043b
-struct hci_cp_logical_link_cancel {
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-struct hci_rp_logical_link_cancel {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-#define HCI_OP_FLOW_SPEC_MODIFY		0x043c
-struct hci_cp_flow_spec_modify {
-	__le16             log_handle;
-	struct hci_ext_fs  tx_fs;
-	struct hci_ext_fs  rx_fs;
-} __packed;
-
 #define HCI_OP_SNIFF_MODE		0x0803
 struct hci_cp_sniff_mode {
 	__le16   handle;
@@ -705,12 +681,6 @@
 	__le16   voice_setting;
 } __packed;
 
-#define HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0c28
-struct hci_cp_write_automatic_flush_timeout {
-	__le16   handle;
-	__le16   timeout;
-} __packed;
-
 #define HCI_OP_HOST_BUFFER_SIZE		0x0c33
 struct hci_cp_host_buffer_size {
 	__le16   acl_mtu;
@@ -719,20 +689,14 @@
 	__le16   sco_max_pkt;
 } __packed;
 
-#define HCI_OP_WRITE_CURRENT_IAC_LAP	0x0c3a
-struct hci_cp_write_current_iac_lap {
-	__u8     num_current_iac;
-	__u8     lap[6];
-} __packed;
-
 #define HCI_OP_WRITE_INQUIRY_MODE	0x0c45
 
 #define HCI_MAX_EIR_LENGTH		240
 
 #define HCI_OP_WRITE_EIR		0x0c52
 struct hci_cp_write_eir {
-	uint8_t		fec;
-	uint8_t		data[HCI_MAX_EIR_LENGTH];
+	__u8	fec;
+	__u8	data[HCI_MAX_EIR_LENGTH];
 } __packed;
 
 #define HCI_OP_READ_SSP_MODE		0x0c55
@@ -755,70 +719,16 @@
 
 #define HCI_OP_READ_INQ_RSP_TX_POWER	0x0c58
 
-#define HCI_OP_READ_LL_TIMEOUT		0x0c61
-struct hci_rp_read_ll_timeout {
-	__u8     status;
-	__le16   timeout;
-} __packed;
-
-#define HCI_OP_WRITE_LL_TIMEOUT		0x0c62
-struct hci_cp_write_ll_timeout {
-	__le16   timeout;
-} __packed;
-
-#define HCI_OP_SET_EVENT_MASK_PAGE2	0x0c63
-struct hci_cp_set_event_mask_page2 {
-	__u8     mask[8];
-} __packed;
-
-#define HCI_OP_READ_LOCATION_DATA	0x0c64
-struct hci_rp_read_location_data {
-	__u8     status;
-	__u8     loc_dom_aware;
-	__u8     loc_dom;
-	__u8     loc_dom_opts;
-	__u8     loc_opts;
-} __packed;
-
-#define HCI_OP_WRITE_LOCATION_DATA	0x0c65
-struct hci_cp_write_location_data {
-	__u8     loc_dom_aware;
-	__u8     loc_dom;
-	__u8     loc_dom_opts;
-	__u8     loc_opts;
-} __packed;
-
 #define HCI_OP_READ_FLOW_CONTROL_MODE	0x0c66
 struct hci_rp_read_flow_control_mode {
 	__u8     status;
 	__u8     mode;
 } __packed;
 
-#define HCI_OP_WRITE_FLOW_CONTROL_MODE	0x0c67
-struct hci_cp_write_flow_control_mode {
-	__u8     mode;
-} __packed;
-
-#define HCI_OP_READ_BE_FLUSH_TIMEOUT	0x0c69
-struct hci_cp_read_be_flush_timeout {
-	__le16   log_handle;
-} __packed;
-
-struct hci_rp_read_be_flush_timeout {
-	__u8     status;
-	__le32   timeout;
-} __packed;
-
-#define HCI_OP_WRITE_BE_FLUSH_TIMEOUT	0x0c6a
-struct hci_cp_write_be_flush_timeout {
-	__le16   log_handle;
-	__le32   timeout;
-} __packed;
-
-#define HCI_OP_SHORT_RANGE_MODE		0x0c6b
-struct hci_cp_short_range_mode {
-	__u8     phy_handle;
-	__u8     mode;
+#define HCI_OP_WRITE_LE_HOST_SUPPORTED	0x0c6d
+struct hci_cp_write_le_host_supported {
+	__u8	le;
+	__u8	simul;
 } __packed;
 
 #define HCI_OP_READ_LOCAL_VERSION	0x1001
@@ -844,6 +754,9 @@
 } __packed;
 
 #define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
+struct hci_cp_read_local_ext_features {
+	__u8     page;
+} __packed;
 struct hci_rp_read_local_ext_features {
 	__u8     status;
 	__u8     page;
@@ -870,20 +783,19 @@
 struct hci_rp_read_data_block_size {
 	__u8     status;
 	__le16   max_acl_len;
-	__le16   data_block_len;
+	__le16   block_len;
 	__le16   num_blocks;
 } __packed;
 
-#define HCI_OP_READ_RSSI	0x1405
-struct hci_cp_read_rssi {
-	__le16   handle;
+#define HCI_OP_WRITE_PAGE_SCAN_ACTIVITY	0x0c1c
+struct hci_cp_write_page_scan_activity {
+	__le16   interval;
+	__le16   window;
 } __packed;
 
-struct hci_rp_read_rssi {
-	__u8     status;
-	__le16   handle;
-	__s8     rssi;
-} __packed;
+#define HCI_OP_WRITE_PAGE_SCAN_TYPE	0x0c47
+	#define PAGE_SCAN_TYPE_STANDARD		0x00
+	#define PAGE_SCAN_TYPE_INTERLACED	0x01
 
 #define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
 struct hci_rp_read_local_amp_info {
@@ -900,33 +812,6 @@
 	__le32   be_flush_to;
 } __packed;
 
-#define HCI_OP_READ_LOCAL_AMP_ASSOC	0x140a
-struct hci_cp_read_local_amp_assoc {
-	__u8     phy_handle;
-	__le16   len_so_far;
-	__le16   max_len;
-} __packed;
-
-struct hci_rp_read_local_amp_assoc {
-	__u8     status;
-	__u8     phy_handle;
-	__le16   rem_len;
-	__u8     frag[248];
-} __packed;
-
-#define HCI_OP_WRITE_REMOTE_AMP_ASSOC	0x140b
-struct hci_cp_write_remote_amp_assoc {
-	__u8     phy_handle;
-	__le16   len_so_far;
-	__le16   rem_len;
-	__u8     frag[248];
-} __packed;
-
-struct hci_rp_write_remote_amp_assoc {
-	__u8     status;
-	__u8     phy_handle;
-} __packed;
-
 #define HCI_OP_LE_SET_EVENT_MASK	0x2001
 struct hci_cp_le_set_event_mask {
 	__u8     mask[8];
@@ -939,19 +824,22 @@
 	__u8     le_max_pkt;
 } __packed;
 
-#define HCI_OP_LE_SET_SCAN_PARAMETERS	0x200b
-struct hci_cp_le_set_scan_parameters {
-	__u8	type;
-	__le16	interval;
-	__le16	window;
-	__u8	own_bdaddr_type;
-	__u8	filter;
+#define HCI_OP_LE_SET_SCAN_PARAM	0x200b
+struct hci_cp_le_set_scan_param {
+	__u8    type;
+	__le16  interval;
+	__le16  window;
+	__u8    own_address_type;
+	__u8    filter_policy;
 } __packed;
 
+#define LE_SCANNING_DISABLED		0x00
+#define LE_SCANNING_ENABLED		0x01
+
 #define HCI_OP_LE_SET_SCAN_ENABLE	0x200c
 struct hci_cp_le_set_scan_enable {
-	__u8	enable;
-	__u8	filter_dup;
+	__u8     enable;
+	__u8     filter_dup;
 } __packed;
 
 #define HCI_OP_LE_CREATE_CONN		0x200d
@@ -972,26 +860,6 @@
 
 #define HCI_OP_LE_CREATE_CONN_CANCEL	0x200e
 
-#define HCI_OP_LE_READ_WHITE_LIST_SIZE	0x200F
-struct hci_rp_le_read_white_list_size {
-	__u8     status;
-	__u8     size;
-} __packed;
-
-#define HCI_OP_LE_CLEAR_WHITE_LIST	0x2010
-
-#define HCI_OP_LE_ADD_DEV_WHITE_LIST	0x2011
-struct hci_cp_le_add_dev_white_list {
-	__u8     addr_type;
-	bdaddr_t addr;
-} __packed;
-
-#define HCI_OP_LE_REMOVE_DEV_WHITE_LIST 0x2012
-struct hci_cp_le_remove_dev_white_list {
-	__u8     addr_type;
-	bdaddr_t addr;
-} __packed;
-
 #define HCI_OP_LE_CONN_UPDATE		0x2013
 struct hci_cp_le_conn_update {
 	__le16   handle;
@@ -1003,16 +871,6 @@
 	__le16   max_ce_len;
 } __packed;
 
-#define HCI_OP_LE_ENCRYPT		0x2017
-struct hci_cp_le_encrypt {
-	__u8	key[16];
-	__u8	data[16];
-} __packed;
-struct hci_cp_le_encrypt_reply {
-	__u8     status;
-	__u8     encrypted[16];
-} __packed;
-
 #define HCI_OP_LE_START_ENC		0x2019
 struct hci_cp_le_start_enc {
 	__le16	handle;
@@ -1153,9 +1011,14 @@
 } __packed;
 
 #define HCI_EV_NUM_COMP_PKTS		0x13
+struct hci_comp_pkts_info {
+	__le16   handle;
+	__le16   count;
+} __packed;
+
 struct hci_ev_num_comp_pkts {
 	__u8     num_hndl;
-	/* variable length part */
+	struct hci_comp_pkts_info handles[0];
 } __packed;
 
 #define HCI_EV_MODE_CHANGE		0x14
@@ -1295,8 +1158,8 @@
 } __packed;
 
 #define HCI_EV_USER_PASSKEY_REQUEST	0x34
-struct hci_ev_user_passkey_request {
-	bdaddr_t bdaddr;
+struct hci_ev_user_passkey_req {
+	bdaddr_t	bdaddr;
 } __packed;
 
 #define HCI_EV_REMOTE_OOB_DATA_REQUEST	0x35
@@ -1310,12 +1173,6 @@
 	bdaddr_t bdaddr;
 } __packed;
 
-#define HCI_EV_USER_PASSKEY_NOTIFICATION	0x3b
-struct hci_ev_user_passkey_notification {
-	bdaddr_t	bdaddr;
-	__le32		passkey;
-} __packed;
-
 #define HCI_EV_REMOTE_HOST_FEATURES	0x3d
 struct hci_ev_remote_host_features {
 	bdaddr_t bdaddr;
@@ -1327,6 +1184,19 @@
 	__u8     subevent;
 } __packed;
 
+#define HCI_EV_NUM_COMP_BLOCKS		0x48
+struct hci_comp_blocks_info {
+	__le16   handle;
+	__le16   pkts;
+	__le16   blocks;
+} __packed;
+
+struct hci_ev_num_comp_blocks {
+	__le16   num_blocks;
+	__u8     num_hndl;
+	struct hci_comp_blocks_info handles[0];
+} __packed;
+
 /* Low energy meta events */
 #define HCI_EV_LE_CONN_COMPLETE		0x01
 struct hci_ev_le_conn_complete {
@@ -1341,6 +1211,14 @@
 	__u8     clk_accurancy;
 } __packed;
 
+#define HCI_EV_LE_LTK_REQ		0x05
+struct hci_ev_le_ltk_req {
+	__le16	handle;
+	__u8	random[8];
+	__le16	ediv;
+} __packed;
+
+/* Advertising report event types */
 #define ADV_IND		0x00
 #define ADV_DIRECT_IND	0x01
 #define ADV_SCAN_IND	0x02
@@ -1359,81 +1237,6 @@
 	__u8	 data[0];
 } __packed;
 
-#define HCI_EV_LE_CONN_UPDATE_COMPLETE	0x03
-struct hci_ev_le_conn_update_complete {
-	__u8     status;
-	__le16   handle;
-	__le16   interval;
-	__le16   latency;
-	__le16   supervision_timeout;
-} __packed;
-
-#define HCI_EV_LE_LTK_REQ		0x05
-struct hci_ev_le_ltk_req {
-	__le16	handle;
-	__u8	random[8];
-	__le16	ediv;
-} __packed;
-
-#define HCI_EV_PHYS_LINK_COMPLETE	0x40
-struct hci_ev_phys_link_complete {
-	__u8     status;
-	__u8     phy_handle;
-} __packed;
-
-#define HCI_EV_CHANNEL_SELECTED		0x41
-struct hci_ev_channel_selected {
-	__u8     phy_handle;
-} __packed;
-
-#define HCI_EV_DISCONN_PHYS_LINK_COMPLETE	0x42
-struct hci_ev_disconn_phys_link_complete {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     reason;
-} __packed;
-
-#define HCI_EV_LOG_LINK_COMPLETE	0x45
-struct hci_ev_log_link_complete {
-	__u8     status;
-	__le16   log_handle;
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-#define HCI_EV_DISCONN_LOG_LINK_COMPLETE	0x46
-struct hci_ev_disconn_log_link_complete {
-	__u8     status;
-	__le16   log_handle;
-	__u8     reason;
-} __packed;
-
-#define HCI_EV_FLOW_SPEC_MODIFY_COMPLETE	0x47
-struct hci_ev_flow_spec_modify_complete {
-	__u8     status;
-	__le16   log_handle;
-} __packed;
-
-#define HCI_EV_NUM_COMP_BLOCKS		0x48
-struct hci_ev_num_comp_blocks {
-	__le16   total_num_blocks;
-	__u8     num_hndl;
-	/* variable length part */
-} __packed;
-
-#define HCI_EV_SHORT_RANGE_MODE_COMPLETE	0x4c
-struct hci_ev_short_range_mode_complete {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     mode;
-} __packed;
-
-#define HCI_EV_AMP_STATUS_CHANGE	0x4d
-struct hci_ev_amp_status_change {
-	__u8     status;
-	__u8     amp_status;
-} __packed;
-
 /* Internal events generated by Bluetooth stack */
 #define HCI_EV_STACK_INTERNAL	0xfd
 struct hci_ev_stack_internal {
@@ -1481,7 +1284,6 @@
 	__u8	dlen;
 } __packed;
 
-#ifdef __KERNEL__
 #include <linux/skbuff.h>
 static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
 {
@@ -1497,7 +1299,6 @@
 {
 	return (struct hci_sco_hdr *) skb->data;
 }
-#endif
 
 /* Command opcode pack/unpack */
 #define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
@@ -1528,7 +1329,8 @@
 #define HCI_DEV_NONE	0xffff
 
 #define HCI_CHANNEL_RAW		0
-#define HCI_CHANNEL_CONTROL	1
+#define HCI_CHANNEL_MONITOR	2
+#define HCI_CHANNEL_CONTROL	3
 
 struct hci_filter {
 	unsigned long type_mask;
@@ -1591,11 +1393,6 @@
 	__u8     out;
 	__u16    state;
 	__u32    link_mode;
-	__u32    mtu;
-	__u32    cnt;
-	__u32    pkts;
-	__u8     pending_sec_level;
-	__u8     ssp_mode;
 };
 
 struct hci_dev_req {
@@ -1634,4 +1431,7 @@
 };
 #define IREQ_CACHE_FLUSH 0x0001
 
+extern bool enable_hs;
+extern bool enable_le;
+
 #endif /* __HCI_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci_core.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci_core.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci_core.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci_core.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012, The Linux Foundation. All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,11 +25,11 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
+#include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
-#include <linux/wakelock.h>
-/* HCI upper protocols */
-#define HCI_PROTO_L2CAP	0
-#define HCI_PROTO_SCO	1
+
+/* HCI priority */
+#define HCI_PRIO_MAX	7
 
 /* HCI Core structures */
 struct inquiry_data {
@@ -44,30 +44,40 @@
 };
 
 struct inquiry_entry {
-	struct inquiry_entry	*next;
+	struct list_head	all;		/* inq_cache.all */
+	struct list_head	list;		/* unknown or resolve */
+	enum {
+		NAME_NOT_KNOWN,
+		NAME_NEEDED,
+		NAME_PENDING,
+		NAME_KNOWN,
+	} name_state;
 	__u32			timestamp;
 	struct inquiry_data	data;
 };
 
-struct inquiry_cache {
-	spinlock_t		lock;
+struct discovery_state {
+	int			type;
+	enum {
+		DISCOVERY_STOPPED,
+		DISCOVERY_STARTING,
+		DISCOVERY_FINDING,
+		DISCOVERY_RESOLVING,
+		DISCOVERY_STOPPING,
+	} state;
+	struct list_head	all;		/* All devices found during inquiry */
+	struct list_head	unknown;	/* Name state not known */
+	struct list_head	resolve;	/* Name needs to be resolved */
 	__u32			timestamp;
-	struct inquiry_entry	*list;
 };
 
 struct hci_conn_hash {
 	struct list_head list;
-	spinlock_t       lock;
 	unsigned int     acl_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;
 };
 
-struct hci_chan_list {
-	struct list_head list;
-	spinlock_t       lock;
-};
-
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -79,37 +89,24 @@
 	u8 svc_hint;
 };
 
-struct key_master_id {
+struct smp_ltk {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+	u8 authenticated;
+	u8 type;
+	u8 enc_size;
 	__le16 ediv;
 	u8 rand[8];
-} __packed;
-
-#define KEY_TYPE_LE_BASE	0x11
-#define KEY_TYPE_LTK		0x11
-#define KEY_TYPE_IRK		0x12
-#define KEY_TYPE_CSRK		0x13
-
-struct link_key_data {
-	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
 	u8 val[16];
-	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[0];
 } __packed;
 
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
+	u8 type;
 	u8 val[16];
 	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[0];
 };
 
 struct oob_data {
@@ -123,14 +120,21 @@
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
-	u8 flags;
 };
 
+struct le_scan_params {
+	u8 type;
+	u16 interval;
+	u16 window;
+	int timeout;
+};
+
+#define HCI_MAX_SHORT_NAME_LENGTH	10
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
-	spinlock_t	lock;
-	atomic_t	refcnt;
+	struct mutex	lock;
 
 	char		name[8];
 	unsigned long	flags;
@@ -139,13 +143,14 @@
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
+	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
+	__u8		host_features[8];
 	__u8		commands[64];
-	__u8		ssp_mode;
 	__u8		hci_ver;
 	__u16		hci_rev;
 	__u8		lmp_ver;
@@ -174,7 +179,9 @@
 	__u32		amp_max_flush_to;
 	__u32		amp_be_flush_to;
 
-	__s8		is_wbs;
+	__u8		flow_ctl_mode;
+
+	unsigned int	auto_accept_delay;
 
 	unsigned long	quirks;
 
@@ -183,17 +190,17 @@
 	unsigned int	sco_cnt;
 	unsigned int	le_cnt;
 
-	__u8	flow_ctl_mode;
-
 	unsigned int	acl_mtu;
 	unsigned int	sco_mtu;
 	unsigned int	le_mtu;
 	unsigned int	acl_pkts;
 	unsigned int	sco_pkts;
 	unsigned int	le_pkts;
-	unsigned int	le_white_list_size;
 
-	unsigned int	data_block_len;
+	__u16		block_len;
+	__u16		block_mtu;
+	__u16		num_blocks;
+	__u16		block_cnt;
 
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
@@ -202,13 +209,18 @@
 	struct workqueue_struct	*workqueue;
 
 	struct work_struct	power_on;
-	struct work_struct	power_off;
-	struct timer_list	off_timer;
+	struct delayed_work	power_off;
+
+	__u16			discov_timeout;
+	struct delayed_work	discov_off;
+
+	struct delayed_work	service_cache;
 
 	struct timer_list	cmd_timer;
-	struct tasklet_struct	cmd_task;
-	struct tasklet_struct	rx_task;
-	struct tasklet_struct	tx_task;
+
+	struct work_struct	rx_work;
+	struct work_struct	cmd_work;
+	struct work_struct	tx_work;
 
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;
@@ -224,34 +236,27 @@
 
 	__u16			init_last_cmd;
 
-	struct crypto_blkcipher	*tfm;
+	struct list_head	mgmt_pending;
 
-	struct inquiry_cache	inq_cache;
+	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;
-	struct hci_chan_list	chan_list;
 	struct list_head	blacklist;
 
 	struct list_head	uuids;
 
 	struct list_head	link_keys;
 
+	struct list_head	long_term_keys;
+
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
-	rwlock_t		adv_entries_lock;
-	struct timer_list	adv_timer;
-
-	struct timer_list	disco_timer;
-	struct timer_list	disco_le_timer;
-	__u8			disco_state;
-	int			disco_int_phase;
-	int			disco_int_count;
+	struct delayed_work	adv_work;
 
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
 
-	void			*driver_data;
 	void			*core_data;
 
 	atomic_t		promisc;
@@ -263,13 +268,17 @@
 
 	struct rfkill		*rfkill;
 
-	struct module		*owner;
+	unsigned long		dev_flags;
+
+	struct delayed_work	le_scan_disable;
+
+	struct work_struct	le_scan;
+	struct le_scan_params	le_scan_params;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
 	int (*send)(struct sk_buff *skb);
-	void (*destruct)(struct hci_dev *hdev);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
 };
@@ -278,85 +287,53 @@
 	struct list_head list;
 
 	atomic_t	refcnt;
-	spinlock_t	lock;
 
 	bdaddr_t	dst;
-	__u8		 dst_id;
-	__u8            dst_type;
+	__u8		dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;
 	__u8		type;
-	__u8		out;
+	bool		out;
 	__u8		attempt;
 	__u8		dev_class[3];
 	__u8		features[8];
-	__u8		ssp_mode;
 	__u16		interval;
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;
+	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
 	__u8		pending_sec_level;
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
-	__u8		auth_initiator;
-	__u8		power_save;
 	__u16		disc_timeout;
-	__u16		conn_timeout;
-	unsigned long	pend;
+	unsigned long	flags;
 
 	__u8		remote_cap;
-	__u8		remote_oob;
 	__u8		remote_auth;
-
-	__s8	rssi_threshold;
-	__u16	rssi_update_interval;
-	__u8	rssi_update_thresh_exceed;
+	bool		flush_key;
 
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
+	struct list_head chan_list;
 
-	struct timer_list disc_timer;
+	struct delayed_work disc_work;
 	struct timer_list idle_timer;
-	struct delayed_work	rssi_update_work;
-	struct timer_list encrypt_pause_timer;
+	struct timer_list auto_accept_timer;
 
-	struct work_struct work_add;
-	struct work_struct work_del;
-	struct wake_lock idle_lock;
 	struct device	dev;
 	atomic_t	devref;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
-	void		*priv;
-
-	__u8             link_key[16];
-	__u8             key_type;
-
-	struct hci_conn	*link;
-
-	/* Low Energy SMP pairing data */
-	__u8		oob; /* OOB pairing supported */
-	__u8		tk_valid; /* TK value is valid */
-	__u8		cfm_pending; /* CONFIRM cmd may be sent */
-	__u8		preq[7]; /* Pairing Request */
-	__u8		prsp[7]; /* Pairing Response */
-	__u8		prnd[16]; /* Pairing Random */
-	__u8		pcnf[16]; /* Pairing Confirm */
-	__u8		tk[16]; /* Temporary Key */
-	__u8		smp_key_size;
-	__u8		sec_req;
-	__u8		auth;
 	void		*smp_conn;
-	struct timer_list smp_timer;
-	__u8		conn_valid;
 
+	struct hci_conn	*link;
 
 	void (*connect_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*security_cfm_cb)	(struct hci_conn *conn, u8 status);
@@ -365,47 +342,54 @@
 
 struct hci_chan {
 	struct list_head list;
-	struct hci_dev	*hdev;
-	__u16		state;
-	atomic_t	refcnt;
-	__u16		ll_handle;
-	struct hci_ext_fs	tx_fs;
-	struct hci_ext_fs	rx_fs;
-	struct hci_conn	*conn;
-	void		*l2cap_sk;
+
+	struct hci_conn *conn;
+	struct sk_buff_head data_q;
+	unsigned int	sent;
 };
 
-extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
+/* ----- HCI interface to upper protocols ----- */
+extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
+extern int l2cap_disconn_ind(struct hci_conn *hcon);
+extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
+extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
+extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+
+extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
+extern int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
+extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
-#define INQUIRY_ENTRY_AGE_MAX   (HZ*60*60)   /* 1 Hour */
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
-#define inquiry_cache_lock(c)		spin_lock(&c->lock)
-#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
-#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
-#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
-
-static inline void inquiry_cache_init(struct hci_dev *hdev)
-{
-	struct inquiry_cache *c = &hdev->inq_cache;
-	spin_lock_init(&c->lock);
-	c->list = NULL;
+static inline void discovery_init(struct hci_dev *hdev)
+{
+	hdev->discovery.state = DISCOVERY_STOPPED;
+	INIT_LIST_HEAD(&hdev->discovery.all);
+	INIT_LIST_HEAD(&hdev->discovery.unknown);
+	INIT_LIST_HEAD(&hdev->discovery.resolve);
 }
 
+bool hci_discovery_active(struct hci_dev *hdev);
+
+void hci_discovery_set_state(struct hci_dev *hdev, int state);
+
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
-	return c->list == NULL;
+	return list_empty(&hdev->discovery.all);
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
+	struct discovery_state *c = &hdev->discovery;
 	return jiffies - c->timestamp;
 }
 
@@ -414,31 +398,53 @@
 	return jiffies - e->timestamp;
 }
 
-struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
+					       bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr,
+						       int state);
+void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
+				      struct inquiry_entry *ie);
+bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+			      bool name_known, bool *ssp);
 
 /* ----- HCI Connections ----- */
 enum {
 	HCI_CONN_AUTH_PEND,
+	HCI_CONN_REAUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
+	HCI_CONN_LE_SMP_PEND,
+	HCI_CONN_MGMT_CONNECTED,
+	HCI_CONN_SSP_ENABLED,
+	HCI_CONN_POWER_SAVE,
+	HCI_CONN_REMOTE_OOB,
 };
 
+static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	return (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
+				test_bit(HCI_CONN_SSP_ENABLED, &conn->flags));
+}
+
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
 	h->acl_num = 0;
 	h->sco_num = 0;
+	h->le_num = 0;
 }
 
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_add(&c->list, &h->list);
+	list_add_rcu(&c->list, &h->list);
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num++;
@@ -456,7 +462,10 @@
 static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_del(&c->list);
+
+	list_del_rcu(&c->list);
+	synchronize_rcu();
+
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num--;
@@ -471,55 +480,58 @@
 	}
 }
 
+static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	switch (type) {
+	case ACL_LINK:
+		return h->acl_num;
+	case LE_LINK:
+		return h->le_num;
+	case SCO_LINK:
+	case ESCO_LINK:
+		return h->sco_num;
+	default:
+		return 0;
+	}
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->handle == handle)
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->handle == handle) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
+	rcu_read_unlock();
 
-static inline void hci_chan_list_init(struct hci_dev *hdev)
-{
-	struct hci_chan_list *h = &hdev->chan_list;
-	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
+	return NULL;
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 							__u8 type, bdaddr_t *ba)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && !bacmp(&c->dst, ba))
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && !bacmp(&c->dst, ba)) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
 
-static inline struct hci_conn *hci_conn_hash_lookup_id(struct hci_dev *hdev,
-					bdaddr_t *ba, __u8 id)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
-	struct hci_conn  *c;
+	rcu_read_unlock();
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (!bacmp(&c->dst, ba) && (c->dst_id == id))
-			return c;
-	}
 	return NULL;
 }
 
@@ -527,44 +539,19 @@
 							__u8 type, __u16 state)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && c->state == state)
-			return c;
-	}
-	return NULL;
-}
-
-static inline struct hci_chan *hci_chan_list_lookup_handle(struct hci_dev *hdev,
-					__u16 handle)
-{
-	struct hci_chan_list *l = &hdev->chan_list;
-	struct list_head *p;
-	struct hci_chan  *c;
+	rcu_read_lock();
 
-	list_for_each(p, &l->list) {
-		c = list_entry(p, struct hci_chan, list);
-		if (c->ll_handle == handle)
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && c->state == state) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
 
-static inline struct hci_chan *hci_chan_list_lookup_id(struct hci_dev *hdev,
-					__u8 handle)
-{
-	struct hci_chan_list *l = &hdev->chan_list;
-	struct list_head *p;
-	struct hci_chan  *c;
+	rcu_read_unlock();
 
-	list_for_each(p, &l->list) {
-		c = list_entry(p, struct hci_chan, list);
-		if (c->conn->handle == handle)
-			return c;
-	}
 	return NULL;
 }
 
@@ -574,60 +561,32 @@
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst);
-struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
-							__u8 addr_type);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
-void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process);
+void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_chan *hci_chan_add(struct hci_dev *hdev);
+struct hci_chan *hci_chan_create(struct hci_conn *conn);
 int hci_chan_del(struct hci_chan *chan);
-static inline void hci_chan_hold(struct hci_chan *chan)
-{
-	atomic_inc(&chan->refcnt);
-}
-int hci_chan_put(struct hci_chan *chan);
+void hci_chan_list_flush(struct hci_conn *conn);
 
-struct hci_chan *hci_chan_create(struct hci_chan *chan,
-				struct hci_ext_fs *tx_fs,
-				struct hci_ext_fs *rx_fs);
-void hci_chan_modify(struct hci_chan *chan,
-				struct hci_ext_fs *tx_fs,
-				struct hci_ext_fs *rx_fs);
-
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst,
-					__u8 sec_level, __u8 auth_type);
-struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
-					bdaddr_t *dst, __u8 sec_level,
-					__u8 auth_type,
-					struct bt_le_params *le_params);
-void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
-void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
-void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+						__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
-void hci_disconnect(struct hci_conn *conn, __u8 reason);
-void hci_disconnect_amp(struct hci_conn *conn, __u8 reason);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
-void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 void hci_conn_hold_device(struct hci_conn *conn);
 void hci_conn_put_device(struct hci_conn *conn);
 
-void hci_conn_set_rssi_reporter(struct hci_conn *conn,
-		s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed);
-void hci_conn_unset_rssi_reporter(struct hci_conn *conn);
-
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	del_timer(&conn->disc_timer);
+	cancel_delayed_work(&conn->disc_work);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
@@ -639,54 +598,54 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 4;
-			} else
+					timeo *= 2;
+			} else {
 				timeo = msecs_to_jiffies(10);
-		} else
+			}
+		} else {
 			timeo = msecs_to_jiffies(10);
-		mod_timer(&conn->disc_timer, jiffies + timeo);
+		}
+		cancel_delayed_work(&conn->disc_work);
+		queue_delayed_work(conn->hdev->workqueue,
+					&conn->disc_work, timeo);
 	}
 }
 
 /* ----- HCI Devices ----- */
-static inline void __hci_dev_put(struct hci_dev *d)
-{
-	if (atomic_dec_and_test(&d->refcnt))
-		d->destruct(d);
-}
-
 static inline void hci_dev_put(struct hci_dev *d)
 {
-	__hci_dev_put(d);
-	module_put(d->owner);
+	put_device(&d->dev);
 }
 
-static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
+static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 {
-	atomic_inc(&d->refcnt);
+	get_device(&d->dev);
 	return d;
 }
 
-static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
+#define hci_dev_lock(d)		mutex_lock(&d->lock)
+#define hci_dev_unlock(d)	mutex_unlock(&d->lock)
+
+#define to_hci_dev(d) container_of(d, struct hci_dev, dev)
+#define to_hci_conn(c) container_of(c, struct hci_conn, dev)
+
+static inline void *hci_get_drvdata(struct hci_dev *hdev)
 {
-	if (try_module_get(d->owner))
-		return __hci_dev_hold(d);
-	return NULL;
+	return dev_get_drvdata(&hdev->dev);
 }
 
-#define hci_dev_lock(d)		spin_lock(&d->lock)
-#define hci_dev_unlock(d)	spin_unlock(&d->lock)
-#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
-#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
+{
+	dev_set_drvdata(&hdev->dev, data);
+}
 
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
-struct hci_dev *hci_dev_get_type(__u8 amp_type);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);
 int hci_register_dev(struct hci_dev *hdev);
-int hci_unregister_dev(struct hci_dev *hdev);
+void hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);
@@ -699,23 +658,27 @@
 int hci_get_conn_list(void __user *arg);
 int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
-int hci_set_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-						u8 *key, u8 type, u8 pin_len);
-struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
-struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
-					bdaddr_t *bdaddr, u8 type);
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr, u8 type,
-		u8 auth, u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
+int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
+		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
+int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16 ediv,
+		u8 rand[8]);
+struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 addr_type);
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
@@ -739,8 +702,9 @@
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
-int hci_register_sysfs(struct hci_dev *hdev);
-void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_init_sysfs(struct hci_dev *hdev);
+int hci_add_sysfs(struct hci_dev *hdev);
+void hci_del_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
@@ -756,55 +720,46 @@
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
+#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
 
-/* ----- HCI protocols ----- */
-struct hci_proto {
-	char		*name;
-	unsigned int	id;
-	unsigned long	flags;
-
-	void		*priv;
+/* ----- Extended LMP capabilities ----- */
+#define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
 
-	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
-	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
-	int (*disconn_ind)	(struct hci_conn *conn);
-	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason,
-							__u8 is_process);
-	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
-	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
-	int (*create_cfm)	(struct hci_chan *chan, __u8 status);
-	int (*modify_cfm)	(struct hci_chan *chan, __u8 status);
-	int (*destroy_cfm)	(struct hci_chan *chan, __u8 status);
-};
-
-static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+/* ----- HCI protocols ----- */
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								__u8 type)
 {
-	register struct hci_proto *hp;
-	int mask = 0;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	switch (type) {
+	case ACL_LINK:
+		return l2cap_connect_ind(hdev, bdaddr);
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	case SCO_LINK:
+	case ESCO_LINK:
+		return sco_connect_ind(hdev, bdaddr);
 
-	return mask;
+	default:
+		BT_ERR("unknown link type %d", type);
+		return -EINVAL;
+	}
 }
 
 static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_connect_cfm(conn, status);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_connect_cfm(conn, status);
+		break;
+
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->connect_cfm_cb)
 		conn->connect_cfm_cb(conn, status);
@@ -812,32 +767,29 @@
 
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
-	register struct hci_proto *hp;
-	int reason = 0x13;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return HCI_ERROR_REMOTE_USER_TERM;
 
-	return reason;
+	return l2cap_disconn_ind(conn);
 }
 
-static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason,
-							__u8 is_process)
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason, is_process);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason, is_process);
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->disconn_cfm_cb)
 		conn->disconn_cfm_cb(conn, reason);
@@ -845,79 +797,41 @@
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
 	__u8 encrypt;
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
 		return;
 
-	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
+		return;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_create_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->create_cfm)
-		hp->create_cfm(chan, status);
-}
-
-static inline void hci_proto_modify_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->modify_cfm)
-		hp->modify_cfm(chan, status);
-}
-
-static inline void hci_proto_destroy_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->destroy_cfm)
-		hp->destroy_cfm(chan, status);
-}
-
-int hci_register_proto(struct hci_proto *hproto);
-int hci_unregister_proto(struct hci_proto *hproto);
-
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;
 
 	char *name;
 
-	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
+								__u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -929,150 +843,196 @@
 
 	hci_proto_auth_cfm(conn, status);
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
 	struct list_head *p;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
 
-	if (!status && encrypt && conn->pending_sec_level > conn->sec_level)
+	if (conn->pending_sec_level > conn->sec_level)
 		conn->sec_level = conn->pending_sec_level;
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
+								__u8 role)
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-int hci_register_cb(struct hci_cb *hcb);
-int hci_unregister_cb(struct hci_cb *hcb);
+static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
+{
+	size_t parsed = 0;
 
-int hci_register_notifier(struct notifier_block *nb);
-int hci_unregister_notifier(struct notifier_block *nb);
+	if (data_len < 2)
+		return false;
 
-/* AMP Manager event callbacks */
-struct amp_mgr_cb {
-	struct list_head list;
-	void (*amp_cmd_complete_event) (struct hci_dev *hdev, __u16 opcode,
-					struct sk_buff *skb);
-	void (*amp_cmd_status_event) (struct hci_dev *hdev, __u16 opcode,
-					__u8 status);
-	void (*amp_event) (struct hci_dev *hdev, __u8 ev_code,
-					struct sk_buff *skb);
-};
+	while (parsed < data_len - 1) {
+		u8 field_len = data[0];
+
+		if (field_len == 0)
+			break;
+
+		parsed += field_len + 1;
 
-void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
-			struct sk_buff *skb);
-void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status);
-void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
-			struct sk_buff *skb);
+		if (parsed > data_len)
+			break;
 
-int hci_register_amp(struct amp_mgr_cb *acb);
-int hci_unregister_amp(struct amp_mgr_cb *acb);
+		if (data[1] == type)
+			return true;
+
+		data += field_len + 1;
+	}
+
+	return false;
+}
+
+static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
+				  u8 data_len)
+{
+	eir[eir_len++] = sizeof(type) + data_len;
+	eir[eir_len++] = type;
+	memcpy(&eir[eir_len], data, data_len);
+	eir_len += data_len;
+
+	return eir_len;
+}
+
+int hci_register_cb(struct hci_cb *hcb);
+int hci_unregister_cb(struct hci_cb *hcb);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
-		struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
-void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
-
 /* ----- HCI Sockets ----- */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
-							struct sock *skip_sk);
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
+void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
+
+void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
 /* Management interface */
+#define MGMT_ADDR_BREDR			0x00
+#define MGMT_ADDR_LE_PUBLIC		0x01
+#define MGMT_ADDR_LE_RANDOM		0x02
+#define MGMT_ADDR_INVALID		0xff
+
+#define DISCOV_TYPE_BREDR		(BIT(MGMT_ADDR_BREDR))
+#define DISCOV_TYPE_LE			(BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+#define DISCOV_TYPE_INTERLEAVED		(BIT(MGMT_ADDR_BREDR) | \
+						BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
-int mgmt_index_added(u16 index);
-int mgmt_index_removed(u16 index);
-int mgmt_powered(u16 index, u8 powered);
-int mgmt_discoverable(u16 index, u8 discoverable);
-int mgmt_connectable(u16 index, u8 connectable);
-int mgmt_new_key(u16 index, struct link_key *key, u8 bonded);
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le);
-int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
-						u16 latency, u16 timeout);
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason);
-int mgmt_disconnect_failed(u16 index);
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
-int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_request(u16 index, u8 event, bdaddr_t *bdaddr,
-							__le32 value);
-int mgmt_user_oob_request(u16 index, bdaddr_t *bdaddr);
-int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
-int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
-								u8 status);
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
-				u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir);
-void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
-				u16 handle, u8 status);
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name);
-void mgmt_inquiry_started(u16 index);
-void mgmt_inquiry_complete_evt(u16 index, u8 status);
-void mgmt_disco_timeout(unsigned long data);
-void mgmt_disco_le_timeout(unsigned long data);
-int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status);
-
-/* LE SMP Management interface */
-int le_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, void *cp);
-int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3]);
-int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
-							u16 sub_ver);
-int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8]);
+int mgmt_index_added(struct hci_dev *hdev);
+int mgmt_index_removed(struct hci_dev *hdev);
+int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
+int mgmt_powered(struct hci_dev *hdev, u8 powered);
+int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
+int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
+int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
+int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
+		      bool persistent);
+int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			  u8 *dev_class);
+int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 link_type, u8 addr_type);
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 link_type, u8 addr_type, u8 status);
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			u8 addr_type, u8 status);
+int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
+int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				 u8 status);
+int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 status);
+int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 confirm_hint);
+int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type);
+int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, u8 status);
+int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+				   u8 status);
+int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
+int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+					    u8 *randomizer, u8 status);
+int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
+		      u8 ssp, u8 *eir, u16 eir_len);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
+int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
+int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
+int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+int mgmt_interleaved_discovery(struct hci_dev *hdev);
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+
+int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
@@ -1111,6 +1071,9 @@
 void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
-void hci_read_rssi(struct hci_conn *conn);
+int hci_do_inquiry(struct hci_dev *hdev, u8 length);
+int hci_cancel_inquiry(struct hci_dev *hdev);
+int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
+		int timeout);
 
 #endif /* __HCI_CORE_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci_mon.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci_mon.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci_mon.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci_mon.h	2016-06-02 00:28:55.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+
+   Copyright (C) 2011-2012  Intel Corporation
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_MON_H
+#define __HCI_MON_H
+
+struct hci_mon_hdr {
+	__le16	opcode;
+	__le16	index;
+	__le16	len;
+} __packed;
+#define HCI_MON_HDR_SIZE 6
+
+#define HCI_MON_NEW_INDEX	0
+#define HCI_MON_DEL_INDEX	1
+#define HCI_MON_COMMAND_PKT	2
+#define HCI_MON_EVENT_PKT	3
+#define HCI_MON_ACL_TX_PKT	4
+#define HCI_MON_ACL_RX_PKT	5
+#define HCI_MON_SCO_TX_PKT	6
+#define HCI_MON_SCO_RX_PKT	7
+
+struct hci_mon_new_index {
+	__u8		type;
+	__u8		bus;
+	bdaddr_t	bdaddr;
+	char		name[8];
+} __packed;
+#define HCI_MON_NEW_INDEX_SIZE 16
+
+#endif /* __HCI_MON_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/l2cap.h flo-ElementalX-5.00-patched/include/net/bluetooth/l2cap.h
--- flo-ElementalX-5.00/include/net/bluetooth/l2cap.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/l2cap.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
 
@@ -27,32 +27,29 @@
 #ifndef __L2CAP_H
 #define __L2CAP_H
 
+#include <asm/unaligned.h>
+
 /* L2CAP defaults */
 #define L2CAP_DEFAULT_MTU		672
 #define L2CAP_DEFAULT_MIN_MTU		48
-#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xffff
 #define L2CAP_DEFAULT_FLUSH_TO		0xffff
-#define L2CAP_MAX_FLUSH_TO		0x7ff
 #define L2CAP_DEFAULT_TX_WINDOW		63
+#define L2CAP_DEFAULT_EXT_WINDOW	0x3FFF
 #define L2CAP_DEFAULT_MAX_TX		3
 #define L2CAP_DEFAULT_RETRANS_TO	2000    /* 2 seconds */
 #define L2CAP_DEFAULT_MONITOR_TO	12000   /* 12 seconds */
-#define L2CAP_DEFAULT_MAX_PDU_SIZE	1482    /* Sized for AMP or BR/EDR */
+#define L2CAP_DEFAULT_MAX_PDU_SIZE	1009    /* Sized for 3-DH5 packet */
 #define L2CAP_DEFAULT_ACK_TO		200
-#define L2CAP_BREDR_MAX_PAYLOAD		1019    /* 3-DH5 packet */
-#define L2CAP_MAX_ERTM_QUEUED		5
-#define L2CAP_MIN_ERTM_QUEUED		2
-
-#define L2CAP_A2MP_DEFAULT_MTU		670
-
-#define L2CAP_TX_WIN_MAX_ENHANCED	0x3f
-#define L2CAP_TX_WIN_MAX_EXTENDED	0x3fff
 #define L2CAP_LE_DEFAULT_MTU		23
-
-#define L2CAP_CONN_TIMEOUT	(40000) /* 40 seconds */
-#define L2CAP_INFO_TIMEOUT	(4000)  /*  4 seconds */
-#define L2CAP_MOVE_TIMEOUT		(4*HZ)  /*  4 seconds */
-#define L2CAP_MOVE_ERTX_TIMEOUT		(60*HZ) /* 60 seconds */
+#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xFFFF
+#define L2CAP_DEFAULT_SDU_ITIME		0xFFFFFFFF
+#define L2CAP_DEFAULT_ACC_LAT		0xFFFFFFFF
+
+#define L2CAP_DISC_TIMEOUT		msecs_to_jiffies(100)
+#define L2CAP_DISC_REJ_TIMEOUT		msecs_to_jiffies(5000)
+#define L2CAP_ENC_TIMEOUT		msecs_to_jiffies(5000)
+#define L2CAP_CONN_TIMEOUT		msecs_to_jiffies(40000)
+#define L2CAP_INFO_TIMEOUT		msecs_to_jiffies(4000)
 
 /* L2CAP socket address */
 struct sockaddr_l2 {
@@ -87,35 +84,36 @@
 #define L2CAP_LM_TRUSTED	0x0008
 #define L2CAP_LM_RELIABLE	0x0010
 #define L2CAP_LM_SECURE		0x0020
-#define L2CAP_LM_FLUSHABLE	0x0040
 
 /* L2CAP command codes */
-#define L2CAP_COMMAND_REJ		0x01
-#define L2CAP_CONN_REQ			0x02
-#define L2CAP_CONN_RSP			0x03
-#define L2CAP_CONF_REQ			0x04
-#define L2CAP_CONF_RSP			0x05
-#define L2CAP_DISCONN_REQ		0x06
-#define L2CAP_DISCONN_RSP		0x07
-#define L2CAP_ECHO_REQ			0x08
-#define L2CAP_ECHO_RSP			0x09
-#define L2CAP_INFO_REQ			0x0a
-#define L2CAP_INFO_RSP			0x0b
+#define L2CAP_COMMAND_REJ	0x01
+#define L2CAP_CONN_REQ		0x02
+#define L2CAP_CONN_RSP		0x03
+#define L2CAP_CONF_REQ		0x04
+#define L2CAP_CONF_RSP		0x05
+#define L2CAP_DISCONN_REQ	0x06
+#define L2CAP_DISCONN_RSP	0x07
+#define L2CAP_ECHO_REQ		0x08
+#define L2CAP_ECHO_RSP		0x09
+#define L2CAP_INFO_REQ		0x0a
+#define L2CAP_INFO_RSP		0x0b
 #define L2CAP_CREATE_CHAN_REQ	0x0c
 #define L2CAP_CREATE_CHAN_RSP	0x0d
-#define L2CAP_MOVE_CHAN_REQ		0x0e
-#define L2CAP_MOVE_CHAN_RSP		0x0f
-#define L2CAP_MOVE_CHAN_CFM		0x10
+#define L2CAP_MOVE_CHAN_REQ	0x0e
+#define L2CAP_MOVE_CHAN_RSP	0x0f
+#define L2CAP_MOVE_CHAN_CFM	0x10
 #define L2CAP_MOVE_CHAN_CFM_RSP	0x11
 #define L2CAP_CONN_PARAM_UPDATE_REQ	0x12
 #define L2CAP_CONN_PARAM_UPDATE_RSP	0x13
 
-/* L2CAP feature mask */
+/* L2CAP extended feature mask */
 #define L2CAP_FEAT_FLOWCTL	0x00000001
 #define L2CAP_FEAT_RETRANS	0x00000002
+#define L2CAP_FEAT_BIDIR_QOS	0x00000004
 #define L2CAP_FEAT_ERTM		0x00000008
 #define L2CAP_FEAT_STREAMING	0x00000010
 #define L2CAP_FEAT_FCS		0x00000020
+#define L2CAP_FEAT_EXT_FLOW	0x00000040
 #define L2CAP_FEAT_FIXED_CHAN	0x00000080
 #define L2CAP_FEAT_EXT_WINDOW	0x00000100
 #define L2CAP_FEAT_UCD		0x00000200
@@ -128,52 +126,53 @@
 #define L2CAP_FC_L2CAP		0x02
 #define L2CAP_FC_A2MP		0x08
 
-/* L2CAP Control Field */
-#define L2CAP_CTRL_SAR               0xC000
-#define L2CAP_CTRL_REQSEQ            0x3F00
-#define L2CAP_CTRL_TXSEQ             0x007E
-#define L2CAP_CTRL_FINAL             0x0080
-#define L2CAP_CTRL_POLL              0x0010
-#define L2CAP_CTRL_SUPERVISE         0x000C
-#define L2CAP_CTRL_FRAME_TYPE        0x0001 /* I- or S-Frame */
-
-#define L2CAP_CTRL_TXSEQ_SHIFT      1
-#define L2CAP_CTRL_SUPERVISE_SHIFT  2
-#define L2CAP_CTRL_POLL_SHIFT       4
-#define L2CAP_CTRL_FINAL_SHIFT      7
-#define L2CAP_CTRL_REQSEQ_SHIFT     8
-#define L2CAP_CTRL_SAR_SHIFT       14
-
-#define L2CAP_EXT_CTRL_SAR           0x00030000
-#define L2CAP_EXT_CTRL_REQSEQ        0x0000FFFC
-#define L2CAP_EXT_CTRL_TXSEQ         0xFFFC0000
-#define L2CAP_EXT_CTRL_FINAL         0x00000002
-#define L2CAP_EXT_CTRL_POLL          0x00040000
-#define L2CAP_EXT_CTRL_SUPERVISE     0x00030000
-#define L2CAP_EXT_CTRL_FRAME_TYPE    0x00000001 /* I- or S-Frame */
-
-#define L2CAP_EXT_CTRL_FINAL_SHIFT      1
-#define L2CAP_EXT_CTRL_REQSEQ_SHIFT     2
-#define L2CAP_EXT_CTRL_SAR_SHIFT       16
-#define L2CAP_EXT_CTRL_SUPERVISE_SHIFT 16
-#define L2CAP_EXT_CTRL_POLL_SHIFT      18
-#define L2CAP_EXT_CTRL_TXSEQ_SHIFT     18
-
-/* L2CAP Supervisory Frame Types */
-#define L2CAP_SFRAME_RR            0x00
-#define L2CAP_SFRAME_REJ           0x01
-#define L2CAP_SFRAME_RNR           0x02
-#define L2CAP_SFRAME_SREJ          0x03
+/* L2CAP Control Field bit masks */
+#define L2CAP_CTRL_SAR			0xC000
+#define L2CAP_CTRL_REQSEQ		0x3F00
+#define L2CAP_CTRL_TXSEQ		0x007E
+#define L2CAP_CTRL_SUPERVISE		0x000C
+
+#define L2CAP_CTRL_RETRANS		0x0080
+#define L2CAP_CTRL_FINAL		0x0080
+#define L2CAP_CTRL_POLL			0x0010
+#define L2CAP_CTRL_FRAME_TYPE		0x0001 /* I- or S-Frame */
+
+#define L2CAP_CTRL_TXSEQ_SHIFT		1
+#define L2CAP_CTRL_SUPER_SHIFT		2
+#define L2CAP_CTRL_REQSEQ_SHIFT		8
+#define L2CAP_CTRL_SAR_SHIFT		14
+
+/* L2CAP Extended Control Field bit mask */
+#define L2CAP_EXT_CTRL_TXSEQ		0xFFFC0000
+#define L2CAP_EXT_CTRL_SAR		0x00030000
+#define L2CAP_EXT_CTRL_SUPERVISE	0x00030000
+#define L2CAP_EXT_CTRL_REQSEQ		0x0000FFFC
+
+#define L2CAP_EXT_CTRL_POLL		0x00040000
+#define L2CAP_EXT_CTRL_FINAL		0x00000002
+#define L2CAP_EXT_CTRL_FRAME_TYPE	0x00000001 /* I- or S-Frame */
+
+#define L2CAP_EXT_CTRL_REQSEQ_SHIFT	2
+#define L2CAP_EXT_CTRL_SAR_SHIFT	16
+#define L2CAP_EXT_CTRL_SUPER_SHIFT	16
+#define L2CAP_EXT_CTRL_TXSEQ_SHIFT	18
+
+/* L2CAP Supervisory Function */
+#define L2CAP_SUPER_RR		0x00
+#define L2CAP_SUPER_REJ		0x01
+#define L2CAP_SUPER_RNR		0x02
+#define L2CAP_SUPER_SREJ	0x03
 
 /* L2CAP Segmentation and Reassembly */
-#define L2CAP_SAR_UNSEGMENTED      0x00
-#define L2CAP_SAR_START            0x01
-#define L2CAP_SAR_END              0x02
-#define L2CAP_SAR_CONTINUE         0x03
-
-/* L2CAP ERTM / Streaming extra field lengths */
-#define L2CAP_SDULEN_SIZE       2
-#define L2CAP_FCS_SIZE          2
+#define L2CAP_SAR_UNSEGMENTED	0x00
+#define L2CAP_SAR_START		0x01
+#define L2CAP_SAR_END		0x02
+#define L2CAP_SAR_CONTINUE	0x03
+
+/* L2CAP Command rej. reasons */
+#define L2CAP_REJ_NOT_UNDERSTOOD	0x0000
+#define L2CAP_REJ_MTU_EXCEEDED		0x0001
+#define L2CAP_REJ_INVALID_CID		0x0002
 
 /* L2CAP structures */
 struct l2cap_hdr {
@@ -181,8 +180,12 @@
 	__le16     cid;
 } __packed;
 #define L2CAP_HDR_SIZE		4
-#define L2CAP_ENHANCED_HDR_SIZE	6
-#define L2CAP_EXTENDED_HDR_SIZE	8
+#define L2CAP_ENH_HDR_SIZE	6
+#define L2CAP_EXT_HDR_SIZE	8
+
+#define L2CAP_FCS_SIZE		2
+#define L2CAP_SDULEN_SIZE	2
+#define L2CAP_PSMLEN_SIZE	2
 
 struct l2cap_cmd_hdr {
 	__u8       code;
@@ -191,8 +194,19 @@
 } __packed;
 #define L2CAP_CMD_HDR_SIZE	4
 
-struct l2cap_cmd_rej {
+struct l2cap_cmd_rej_unk {
+	__le16     reason;
+} __packed;
+
+struct l2cap_cmd_rej_mtu {
 	__le16     reason;
+	__le16     max_mtu;
+} __packed;
+
+struct l2cap_cmd_rej_cid {
+	__le16     reason;
+	__le16     scid;
+	__le16     dcid;
 } __packed;
 
 struct l2cap_conn_req {
@@ -210,21 +224,21 @@
 /* channel indentifier */
 #define L2CAP_CID_SIGNALING	0x0001
 #define L2CAP_CID_CONN_LESS	0x0002
-#define L2CAP_CID_A2MP		0x0003
 #define L2CAP_CID_LE_DATA	0x0004
 #define L2CAP_CID_LE_SIGNALING	0x0005
 #define L2CAP_CID_SMP		0x0006
 #define L2CAP_CID_DYN_START	0x0040
 #define L2CAP_CID_DYN_END	0xffff
 
-/* connect result */
+/* connect/create channel results */
 #define L2CAP_CR_SUCCESS	0x0000
 #define L2CAP_CR_PEND		0x0001
 #define L2CAP_CR_BAD_PSM	0x0002
 #define L2CAP_CR_SEC_BLOCK	0x0003
 #define L2CAP_CR_NO_MEM		0x0004
+#define L2CAP_CR_BAD_AMP	0x0005
 
-/* connect status */
+/* connect/create channel status */
 #define L2CAP_CS_NO_INFO	0x0000
 #define L2CAP_CS_AUTHEN_PEND	0x0001
 #define L2CAP_CS_AUTHOR_PEND	0x0002
@@ -247,7 +261,7 @@
 #define L2CAP_CONF_REJECT	0x0002
 #define L2CAP_CONF_UNKNOWN	0x0003
 #define L2CAP_CONF_PENDING	0x0004
-#define L2CAP_CONF_FLOW_SPEC_REJECT	0x0005
+#define L2CAP_CONF_EFS_REJECT	0x0005
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -264,13 +278,8 @@
 #define L2CAP_CONF_QOS		0x03
 #define L2CAP_CONF_RFC		0x04
 #define L2CAP_CONF_FCS		0x05
-#define L2CAP_CONF_EXT_FS	0x06
-#define L2CAP_CONF_EXT_WINDOW	0x07
-
-/* QOS Service type */
-#define L2CAP_SERVICE_NO_TRAFFIC		0x00
-#define L2CAP_SERVICE_BEST_EFFORT		0x01
-#define L2CAP_SERVICE_GUARANTEED		0x02
+#define L2CAP_CONF_EFS		0x06
+#define L2CAP_CONF_EWS		0x07
 
 #define L2CAP_CONF_MAX_SIZE	22
 
@@ -283,26 +292,27 @@
 	__le16     max_pdu_size;
 } __packed;
 
-struct l2cap_conf_ext_fs {
-	__u8       id;
-	__u8       type;
-	__le16     max_sdu;
-	__le32     sdu_arr_time;
-	__le32     acc_latency;
-	__le32     flush_to;
-} __packed;
-
-struct l2cap_conf_prm {
-	__u8       fcs;
-	__le32     flush_to;
-};
-
 #define L2CAP_MODE_BASIC	0x00
 #define L2CAP_MODE_RETRANS	0x01
 #define L2CAP_MODE_FLOWCTL	0x02
 #define L2CAP_MODE_ERTM		0x03
 #define L2CAP_MODE_STREAMING	0x04
 
+struct l2cap_conf_efs {
+	__u8	id;
+	__u8	stype;
+	__le16	msdu;
+	__le32	sdu_itime;
+	__le32	acc_lat;
+	__le32	flush_to;
+} __packed;
+
+#define L2CAP_SERV_NOTRAFIC	0x00
+#define L2CAP_SERV_BESTEFFORT	0x01
+#define L2CAP_SERV_GUARANTEED	0x02
+
+#define L2CAP_BESTEFFORT_ID	0x01
+
 struct l2cap_disconn_req {
 	__le16     dcid;
 	__le16     scid;
@@ -327,83 +337,53 @@
 	__le16      psm;
 	__le16      scid;
 	__u8        amp_id;
-} __attribute__ ((packed));
+} __packed;
 
 struct l2cap_create_chan_rsp {
 	__le16      dcid;
 	__le16      scid;
 	__le16      result;
 	__le16      status;
-} __attribute__ ((packed));
-
-#define L2CAP_CREATE_CHAN_SUCCESS				(0x0000)
-#define L2CAP_CREATE_CHAN_PENDING				(0x0001)
-#define L2CAP_CREATE_CHAN_REFUSED_PSM			(0x0002)
-#define L2CAP_CREATE_CHAN_REFUSED_SECURITY		(0x0003)
-#define L2CAP_CREATE_CHAN_REFUSED_RESOURCES		(0x0004)
-#define L2CAP_CREATE_CHAN_REFUSED_CONTROLLER	(0x0005)
-
-#define L2CAP_CREATE_CHAN_STATUS_NONE			(0x0000)
-#define L2CAP_CREATE_CHAN_STATUS_AUTHENTICATION	(0x0001)
-#define L2CAP_CREATE_CHAN_STATUS_AUTHORIZATION	(0x0002)
+} __packed;
 
 struct l2cap_move_chan_req {
 	__le16      icid;
 	__u8        dest_amp_id;
-} __attribute__ ((packed));
+} __packed;
 
 struct l2cap_move_chan_rsp {
 	__le16      icid;
 	__le16      result;
-} __attribute__ ((packed));
+} __packed;
 
-#define L2CAP_MOVE_CHAN_SUCCESS				(0x0000)
-#define L2CAP_MOVE_CHAN_PENDING				(0x0001)
-#define L2CAP_MOVE_CHAN_REFUSED_CONTROLLER	(0x0002)
-#define L2CAP_MOVE_CHAN_REFUSED_SAME_ID		(0x0003)
-#define L2CAP_MOVE_CHAN_REFUSED_CONFIG		(0x0004)
-#define L2CAP_MOVE_CHAN_REFUSED_COLLISION	(0x0005)
-#define L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED	(0x0006)
+#define L2CAP_MR_SUCCESS	0x0000
+#define L2CAP_MR_PEND		0x0001
+#define L2CAP_MR_BAD_ID		0x0002
+#define L2CAP_MR_SAME_ID	0x0003
+#define L2CAP_MR_NOT_SUPP	0x0004
+#define L2CAP_MR_COLLISION	0x0005
+#define L2CAP_MR_NOT_ALLOWED	0x0006
 
 struct l2cap_move_chan_cfm {
 	__le16      icid;
 	__le16      result;
-} __attribute__ ((packed));
+} __packed;
 
-#define L2CAP_MOVE_CHAN_CONFIRMED	(0x0000)
-#define L2CAP_MOVE_CHAN_UNCONFIRMED	(0x0001)
+#define L2CAP_MC_CONFIRMED	0x0000
+#define L2CAP_MC_UNCONFIRMED	0x0001
 
 struct l2cap_move_chan_cfm_rsp {
 	__le16      icid;
-} __attribute__ ((packed));
-
-struct l2cap_amp_signal_work {
-	struct work_struct work;
-	struct l2cap_cmd_hdr cmd;
-	struct l2cap_conn *conn;
-	struct sk_buff *skb;
-	u8 *data;
-};
-
-struct l2cap_resegment_work {
-	struct work_struct work;
-	struct sock *sk;
-};
-
-struct l2cap_logical_link_work {
-	struct work_struct work;
-	struct hci_chan *chan;
-	u8 status;
-};
+} __packed;
 
 /* info type */
-#define L2CAP_IT_CL_MTU     0x0001
-#define L2CAP_IT_FEAT_MASK  0x0002
-#define L2CAP_IT_FIXED_CHAN 0x0003
+#define L2CAP_IT_CL_MTU		0x0001
+#define L2CAP_IT_FEAT_MASK	0x0002
+#define L2CAP_IT_FIXED_CHAN	0x0003
 
 /* info result */
-#define L2CAP_IR_SUCCESS    0x0000
-#define L2CAP_IR_NOTSUPP    0x0001
+#define L2CAP_IR_SUCCESS	0x0000
+#define L2CAP_IR_NOTSUPP	0x0001
 
 struct l2cap_conn_param_update_req {
 	__le16      min;
@@ -420,64 +400,21 @@
 #define L2CAP_CONN_PARAM_ACCEPTED	0x0000
 #define L2CAP_CONN_PARAM_REJECTED	0x0001
 
-/* ----- L2CAP connections ----- */
-struct l2cap_chan_list {
-	struct sock	*head;
-	rwlock_t	lock;
-};
-
-struct l2cap_conn {
-	struct hci_conn	*hcon;
-
-	bdaddr_t	*dst;
-	bdaddr_t	*src;
-
-	unsigned int	mtu;
-
-	__u32		feat_mask;
-	__u8		fc_mask;
-	struct amp_mgr *mgr;
-
-	__u8		info_state;
-	__u8		info_ident;
-
-	struct timer_list info_timer;
-
-	spinlock_t	lock;
-
-	struct sk_buff *rx_skb;
-	__u32		rx_len;
-	__u8		tx_ident;
-
-	__u8		disc_reason;
-
-	struct l2cap_chan_list chan_list;
+/* ----- L2CAP channels and connections ----- */
+struct srej_list {
+	__u16	tx_seq;
+	struct list_head list;
 };
 
-struct sock_del_list {
+struct l2cap_chan {
 	struct sock *sk;
-	struct list_head list;
-};
 
-#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
-#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
-#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
+	struct l2cap_conn	*conn;
 
-/* ----- L2CAP channel and socket info ----- */
-#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
-#define TX_QUEUE(sk) (&l2cap_pi(sk)->tx_queue)
-#define SREJ_QUEUE(sk) (&l2cap_pi(sk)->srej_queue)
+	__u8		state;
 
-struct l2cap_seq_list {
-	__u16 head;
-	__u16 tail;
-	__u16 size;
-	__u16 mask;
-	__u16 *list;
-};
+	atomic_t	refcnt;
 
-struct l2cap_pinfo {
-	struct bt_sock	bt;
 	__le16		psm;
 	__u16		dcid;
 	__u16		scid;
@@ -486,236 +423,443 @@
 	__u16		omtu;
 	__u16		flush_to;
 	__u8		mode;
-	__u8		fixed_channel;
-	__u8		num_conf_req;
-	__u8		num_conf_rsp;
-	__u8		incoming;
+	__u8		chan_type;
+	__u8		chan_policy;
+
+	__le16		sport;
 
-	__u8		fcs;
 	__u8		sec_level;
-	__u8		role_switch;
-	__u8		force_reliable;
-	__u8		flushable;
-	__u8		force_active;
+
+	__u8		ident;
 
 	__u8		conf_req[64];
 	__u8		conf_len;
-	__u8		conf_ident;
-	__u16		conf_state;
-	__u8		conn_state;
-	__u8		tx_state;
-	__u8		rx_state;
-	__u8		reconf_state;
-
-	__u8		amp_id;
-	__u8		amp_move_id;
-	__u8		amp_move_state;
-	__u8		amp_move_role;
-	__u8		amp_move_cmd_ident;
-	__u16		amp_move_reqseq;
-	__u16		amp_move_event;
+	__u8		num_conf_req;
+	__u8		num_conf_rsp;
+
+	__u8		fcs;
+
+	__u16		tx_win;
+	__u16		tx_win_max;
+	__u8		max_tx;
+	__u16		retrans_timeout;
+	__u16		monitor_timeout;
+	__u16		mps;
+
+	unsigned long	conf_state;
+	unsigned long	conn_state;
+	unsigned long	flags;
 
 	__u16		next_tx_seq;
 	__u16		expected_ack_seq;
 	__u16		expected_tx_seq;
 	__u16		buffer_seq;
+	__u16		buffer_seq_srej;
 	__u16		srej_save_reqseq;
-	__u16		last_acked_seq;
-	__u32		frames_sent;
+	__u16		frames_sent;
 	__u16		unacked_frames;
 	__u8		retry_count;
-	__u16		srej_queue_next;
+	__u8		num_acked;
 	__u16		sdu_len;
 	struct sk_buff	*sdu;
 	struct sk_buff	*sdu_last_frag;
-	atomic_t	ertm_queued;
-
-	__u8		ident;
 
-	__u16		tx_win;
-	__u16		tx_win_max;
-	__u16		ack_win;
-	__u8		max_tx;
-	__u8		amp_pref;
 	__u16		remote_tx_win;
 	__u8		remote_max_tx;
-	__u8		extended_control;
-	__u16		retrans_timeout;
-	__u16		monitor_timeout;
 	__u16		remote_mps;
-	__u16		mps;
 
-	__le16		sport;
+	__u8		local_id;
+	__u8		local_stype;
+	__u16		local_msdu;
+	__u32		local_sdu_itime;
+	__u32		local_acc_lat;
+	__u32		local_flush_to;
+
+	__u8		remote_id;
+	__u8		remote_stype;
+	__u16		remote_msdu;
+	__u32		remote_sdu_itime;
+	__u32		remote_acc_lat;
+	__u32		remote_flush_to;
+
+	struct delayed_work	chan_timer;
+	struct delayed_work	retrans_timer;
+	struct delayed_work	monitor_timer;
+	struct delayed_work	ack_timer;
+
+	struct sk_buff		*tx_send_head;
+	struct sk_buff_head	tx_q;
+	struct sk_buff_head	srej_q;
+	struct list_head	srej_l;
+
+	struct list_head	list;
+	struct list_head	global_l;
+
+	void			*data;
+	struct l2cap_ops	*ops;
+	struct mutex		lock;
+};
+
+struct l2cap_ops {
+	char			*name;
+
+	struct l2cap_chan	*(*new_connection) (void *data);
+	int			(*recv) (void *data, struct sk_buff *skb);
+	void			(*close) (void *data);
+	void			(*state_change) (void *data, int state);
+	struct sk_buff		*(*alloc_skb) (struct l2cap_chan *chan,
+					unsigned long len, int nb, int *err);
 
-	struct delayed_work	retrans_work;
-	struct delayed_work	monitor_work;
-	struct delayed_work	ack_work;
-	struct work_struct	tx_work;
-	struct sk_buff_head	tx_queue;
-	struct sk_buff_head	srej_queue;
-	struct l2cap_seq_list srej_list;
-	struct l2cap_seq_list retrans_list;
-	struct hci_conn	*ampcon;
-	struct hci_chan	*ampchan;
-	struct l2cap_conn	*conn;
-	struct l2cap_conf_prm local_conf;
-	struct l2cap_conf_prm remote_conf;
-	struct l2cap_conf_ext_fs local_fs;
-	struct l2cap_conf_ext_fs remote_fs;
-	struct sock		*next_c;
-	struct sock		*prev_c;
-};
-
-#define L2CAP_CONF_REQ_SENT       0x0001
-#define L2CAP_CONF_INPUT_DONE     0x0002
-#define L2CAP_CONF_OUTPUT_DONE    0x0004
-#define L2CAP_CONF_MTU_DONE       0x0008
-#define L2CAP_CONF_MODE_DONE      0x0010
-#define L2CAP_CONF_CONNECT_PEND   0x0020
-#define L2CAP_CONF_NO_FCS_RECV    0x0040
-#define L2CAP_CONF_STATE2_DEVICE  0x0080
-#define L2CAP_CONF_EXT_WIN_RECV   0x0100
-#define L2CAP_CONF_LOCKSTEP       0x0200
-#define L2CAP_CONF_LOCKSTEP_PEND  0x0400
-#define L2CAP_CONF_PEND_SENT      0x0800
-#define L2CAP_CONF_EFS_RECV       0x1000
+};
+
+struct l2cap_conn {
+	struct hci_conn		*hcon;
+	struct hci_chan		*hchan;
+
+	bdaddr_t		*dst;
+	bdaddr_t		*src;
+
+	unsigned int		mtu;
+
+	__u32			feat_mask;
+	__u8			fixed_chan_mask;
+
+	__u8			info_state;
+	__u8			info_ident;
+
+	struct delayed_work	info_timer;
+
+	spinlock_t		lock;
+
+	struct sk_buff		*rx_skb;
+	__u32			rx_len;
+	__u8			tx_ident;
+
+	__u8			disc_reason;
+
+	struct delayed_work	security_timer;
+	struct smp_chan		*smp_chan;
+
+	struct list_head	chan_l;
+	struct mutex		chan_lock;
+};
+
+#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
+#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
+#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
+
+#define L2CAP_CHAN_RAW			1
+#define L2CAP_CHAN_CONN_LESS		2
+#define L2CAP_CHAN_CONN_ORIENTED	3
+
+/* ----- L2CAP socket info ----- */
+#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
+
+struct l2cap_pinfo {
+	struct bt_sock		bt;
+	struct l2cap_chan	*chan;
+	struct sk_buff		*rx_busy_skb;
+};
+
+enum {
+	CONF_REQ_SENT,
+	CONF_INPUT_DONE,
+	CONF_OUTPUT_DONE,
+	CONF_MTU_DONE,
+	CONF_MODE_DONE,
+	CONF_CONNECT_PEND,
+	CONF_NO_FCS_RECV,
+	CONF_STATE2_DEVICE,
+	CONF_EWS_RECV,
+	CONF_LOC_CONF_PEND,
+	CONF_REM_CONF_PEND,
+};
 
 #define L2CAP_CONF_MAX_CONF_REQ 2
 #define L2CAP_CONF_MAX_CONF_RSP 2
 
-#define L2CAP_RECONF_NONE          0x00
-#define L2CAP_RECONF_INT           0x01
-#define L2CAP_RECONF_ACC           0x02
-
-#define L2CAP_CONN_SREJ_ACT        0x01
-#define L2CAP_CONN_REJ_ACT         0x02
-#define L2CAP_CONN_REMOTE_BUSY     0x04
-#define L2CAP_CONN_LOCAL_BUSY      0x08
-#define L2CAP_CONN_SEND_FBIT       0x10
-#define L2CAP_CONN_SENT_RNR        0x20
-
-#define L2CAP_SEQ_LIST_CLEAR       0xFFFF
-#define L2CAP_SEQ_LIST_TAIL        0x8000
-
-#define L2CAP_ERTM_TX_STATE_XMIT          0x01
-#define L2CAP_ERTM_TX_STATE_WAIT_F        0x02
-
-#define L2CAP_ERTM_RX_STATE_RECV                    0x01
-#define L2CAP_ERTM_RX_STATE_SREJ_SENT               0x02
-#define L2CAP_ERTM_RX_STATE_AMP_MOVE                0x03
-#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG             0x04
-#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE 0x05
-#define L2CAP_ERTM_RX_STATE_WAIT_F_FLAG             0x06
-
-#define L2CAP_ERTM_TXSEQ_EXPECTED        0x00
-#define L2CAP_ERTM_TXSEQ_EXPECTED_SREJ   0x01
-#define L2CAP_ERTM_TXSEQ_UNEXPECTED      0x02
-#define L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ 0x03
-#define L2CAP_ERTM_TXSEQ_DUPLICATE       0x04
-#define L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ  0x05
-#define L2CAP_ERTM_TXSEQ_INVALID         0x06
-#define L2CAP_ERTM_TXSEQ_INVALID_IGNORE  0x07
-
-#define L2CAP_ERTM_EVENT_DATA_REQUEST          0x01
-#define L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED   0x02
-#define L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR      0x03
-#define L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT  0x04
-#define L2CAP_ERTM_EVENT_RECV_FBIT             0x05
-#define L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES 0x06
-#define L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES 0x07
-#define L2CAP_ERTM_EVENT_EXPLICIT_POLL         0x08
-#define L2CAP_ERTM_EVENT_RECV_IFRAME           0x09
-#define L2CAP_ERTM_EVENT_RECV_RR               0x0a
-#define L2CAP_ERTM_EVENT_RECV_REJ              0x0b
-#define L2CAP_ERTM_EVENT_RECV_RNR              0x0c
-#define L2CAP_ERTM_EVENT_RECV_SREJ             0x0d
-#define L2CAP_ERTM_EVENT_RECV_FRAME            0x0e
-
-#define L2CAP_AMP_MOVE_NONE      0
-#define L2CAP_AMP_MOVE_INITIATOR 1
-#define L2CAP_AMP_MOVE_RESPONDER 2
-
-#define L2CAP_AMP_STATE_STABLE			0
-#define L2CAP_AMP_STATE_WAIT_CREATE		1
-#define L2CAP_AMP_STATE_WAIT_CREATE_RSP		2
-#define L2CAP_AMP_STATE_WAIT_MOVE		3
-#define L2CAP_AMP_STATE_WAIT_MOVE_RSP		4
-#define L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS	5
-#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM	6
-#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP	7
-#define L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE	8
-#define L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM	9
-#define L2CAP_AMP_STATE_WAIT_LOCAL_BUSY		10
-#define L2CAP_AMP_STATE_WAIT_PREPARE		11
-#define L2CAP_AMP_STATE_RESEGMENT		12
-
-#define L2CAP_ATT_ERROR				0x01
-#define L2CAP_ATT_MTU_REQ			0x02
-#define L2CAP_ATT_MTU_RSP			0x03
-#define L2CAP_ATT_RESPONSE_BIT			0x01
-#define L2CAP_ATT_INDICATE			0x1D
-#define L2CAP_ATT_CONFIRM			0x1E
-#define L2CAP_ATT_NOT_SUPPORTED			0x06
-
-#define __delta_seq(x, y, pi) ((x) >= (y) ? (x) - (y) : \
-				(pi)->tx_win_max + 1 - (y) + (x))
-#define __next_seq(x, pi) ((x + 1) & ((pi)->tx_win_max))
+enum {
+	CONN_SREJ_SENT,
+	CONN_WAIT_F,
+	CONN_SREJ_ACT,
+	CONN_SEND_PBIT,
+	CONN_REMOTE_BUSY,
+	CONN_LOCAL_BUSY,
+	CONN_REJ_ACT,
+	CONN_SEND_FBIT,
+	CONN_RNR_SENT,
+};
+
+/* Definitions for flags in l2cap_chan */
+enum {
+	FLAG_ROLE_SWITCH,
+	FLAG_FORCE_ACTIVE,
+	FLAG_FORCE_RELIABLE,
+	FLAG_FLUSHABLE,
+	FLAG_EXT_CTRL,
+	FLAG_EFS_ENABLE,
+};
+
+static inline void l2cap_chan_hold(struct l2cap_chan *c)
+{
+	atomic_inc(&c->refcnt);
+}
+
+static inline void l2cap_chan_put(struct l2cap_chan *c)
+{
+	if (atomic_dec_and_test(&c->refcnt))
+		kfree(c);
+}
+
+static inline void l2cap_chan_lock(struct l2cap_chan *chan)
+{
+	mutex_lock(&chan->lock);
+}
+
+static inline void l2cap_chan_unlock(struct l2cap_chan *chan)
+{
+	mutex_unlock(&chan->lock);
+}
+
+static inline void l2cap_set_timer(struct l2cap_chan *chan,
+					struct delayed_work *work, long timeout)
+{
+	BT_DBG("chan %p state %s timeout %ld", chan,
+					state_to_string(chan->state), timeout);
+
+	if (!cancel_delayed_work(work))
+		l2cap_chan_hold(chan);
+	schedule_delayed_work(work, timeout);
+}
+
+static inline bool l2cap_clear_timer(struct l2cap_chan *chan,
+					struct delayed_work *work)
+{
+	bool ret;
+
+	ret = cancel_delayed_work(work);
+	if (ret)
+		l2cap_chan_put(chan);
+
+	return ret;
+}
+
+#define __set_chan_timer(c, t) l2cap_set_timer(c, &c->chan_timer, (t))
+#define __clear_chan_timer(c) l2cap_clear_timer(c, &c->chan_timer)
+#define __set_retrans_timer(c) l2cap_set_timer(c, &c->retrans_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_RETRANS_TO));
+#define __clear_retrans_timer(c) l2cap_clear_timer(c, &c->retrans_timer)
+#define __set_monitor_timer(c) l2cap_set_timer(c, &c->monitor_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_MONITOR_TO));
+#define __clear_monitor_timer(c) l2cap_clear_timer(c, &c->monitor_timer)
+#define __set_ack_timer(c) l2cap_set_timer(c, &chan->ack_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
+#define __clear_ack_timer(c) l2cap_clear_timer(c, &c->ack_timer)
+
+static inline int __seq_offset(struct l2cap_chan *chan, __u16 seq1, __u16 seq2)
+{
+	int offset;
+
+	offset = (seq1 - seq2) % (chan->tx_win_max + 1);
+	if (offset < 0)
+		offset += (chan->tx_win_max + 1);
+
+	return offset;
+}
+
+static inline __u16 __next_seq(struct l2cap_chan *chan, __u16 seq)
+{
+	return (seq + 1) % (chan->tx_win_max + 1);
+}
+
+static inline int l2cap_tx_window_full(struct l2cap_chan *ch)
+{
+	int sub;
+
+	sub = (ch->next_tx_seq - ch->expected_ack_seq) % 64;
+
+	if (sub < 0)
+		sub += 64;
+
+	return sub == ch->remote_tx_win;
+}
+
+static inline __u16 __get_reqseq(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_REQSEQ) >>
+						L2CAP_EXT_CTRL_REQSEQ_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;
+}
+
+static inline __u32 __set_reqseq(struct l2cap_chan *chan, __u32 reqseq)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
+							L2CAP_EXT_CTRL_REQSEQ;
+	else
+		return (reqseq << L2CAP_CTRL_REQSEQ_SHIFT) & L2CAP_CTRL_REQSEQ;
+}
+
+static inline __u16 __get_txseq(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_TXSEQ) >>
+						L2CAP_EXT_CTRL_TXSEQ_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;
+}
+
+static inline __u32 __set_txseq(struct l2cap_chan *chan, __u32 txseq)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
+							L2CAP_EXT_CTRL_TXSEQ;
+	else
+		return (txseq << L2CAP_CTRL_TXSEQ_SHIFT) & L2CAP_CTRL_TXSEQ;
+}
+
+static inline bool __is_sframe(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_FRAME_TYPE;
+	else
+		return ctrl & L2CAP_CTRL_FRAME_TYPE;
+}
+
+static inline __u32 __set_sframe(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_FRAME_TYPE;
+	else
+		return L2CAP_CTRL_FRAME_TYPE;
+}
+
+static inline __u8 __get_ctrl_sar(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;
+}
+
+static inline __u32 __set_ctrl_sar(struct l2cap_chan *chan, __u32 sar)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (sar << L2CAP_EXT_CTRL_SAR_SHIFT) & L2CAP_EXT_CTRL_SAR;
+	else
+		return (sar << L2CAP_CTRL_SAR_SHIFT) & L2CAP_CTRL_SAR;
+}
+
+static inline bool __is_sar_start(struct l2cap_chan *chan, __u32 ctrl)
+{
+	return __get_ctrl_sar(chan, ctrl) == L2CAP_SAR_START;
+}
+
+static inline __u32 __get_sar_mask(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_SAR;
+	else
+		return L2CAP_CTRL_SAR;
+}
+
+static inline __u8 __get_ctrl_super(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_SUPERVISE) >>
+						L2CAP_EXT_CTRL_SUPER_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;
+}
+
+static inline __u32 __set_ctrl_super(struct l2cap_chan *chan, __u32 super)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (super << L2CAP_EXT_CTRL_SUPER_SHIFT) &
+						L2CAP_EXT_CTRL_SUPERVISE;
+	else
+		return (super << L2CAP_CTRL_SUPER_SHIFT) &
+							L2CAP_CTRL_SUPERVISE;
+}
+
+static inline __u32 __set_ctrl_final(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_FINAL;
+	else
+		return L2CAP_CTRL_FINAL;
+}
+
+static inline bool __is_ctrl_final(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_FINAL;
+	else
+		return ctrl & L2CAP_CTRL_FINAL;
+}
+
+static inline __u32 __set_ctrl_poll(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_POLL;
+	else
+		return L2CAP_CTRL_POLL;
+}
+
+static inline bool __is_ctrl_poll(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_POLL;
+	else
+		return ctrl & L2CAP_CTRL_POLL;
+}
+
+static inline __u32 __get_control(struct l2cap_chan *chan, void *p)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return get_unaligned_le32(p);
+	else
+		return get_unaligned_le16(p);
+}
+
+static inline void __put_control(struct l2cap_chan *chan, __u32 control,
+								void *p)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return put_unaligned_le32(control, p);
+	else
+		return put_unaligned_le16(control, p);
+}
+
+static inline __u8 __ctrl_size(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_HDR_SIZE - L2CAP_HDR_SIZE;
+	else
+		return L2CAP_ENH_HDR_SIZE - L2CAP_HDR_SIZE;
+}
 
 extern bool disable_ertm;
-extern const struct proto_ops l2cap_sock_ops;
-extern struct bt_sock_list l2cap_sk_list;
 
 int l2cap_init_sockets(void);
 void l2cap_cleanup_sockets(void);
 
-u8 l2cap_get_ident(struct l2cap_conn *conn);
-void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data);
-int l2cap_build_conf_req(struct sock *sk, void *data);
+void __l2cap_connect_rsp_defer(struct l2cap_chan *chan);
 int __l2cap_wait_ack(struct sock *sk);
 
-struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len);
-struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len);
-struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg,
-				size_t len, u16 sdulen, int reseg);
-int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
-			struct msghdr *msg, size_t len, int reseg);
-int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue);
-void l2cap_do_send(struct sock *sk, struct sk_buff *skb);
-void l2cap_streaming_send(struct sock *sk);
-int l2cap_ertm_send(struct sock *sk);
-int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs);
-int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff_head *skbs, u8 event);
-
-int l2cap_sock_le_params_valid(struct bt_le_params *le_params);
-void l2cap_sock_set_timer(struct sock *sk, long timeout);
-void l2cap_sock_clear_timer(struct sock *sk);
-void __l2cap_sock_close(struct sock *sk, int reason);
-void l2cap_sock_kill(struct sock *sk);
-void l2cap_sock_init(struct sock *sk, struct sock *parent);
-struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
-							int proto, gfp_t prio);
-struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
-						bdaddr_t *dst, int server);
-void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err);
-void l2cap_chan_del(struct sock *sk, int err);
-int l2cap_do_connect(struct sock *sk);
-int l2cap_data_channel(struct sock *sk, struct sk_buff *skb);
-void l2cap_amp_move_init(struct sock *sk);
-void l2cap_ertm_destruct(struct sock *sk);
-void l2cap_ertm_shutdown(struct sock *sk);
-void l2cap_ertm_recv_done(struct sock *sk);
-
-void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt);
-
-void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb);
-
-void l2cap_amp_physical_complete(int result, u8 remote_id, u8 local_id,
-				struct sock *sk);
-
-void l2cap_amp_logical_complete(int result, struct hci_conn *ampcon,
-				struct hci_chan *ampchan, struct sock *sk);
+int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm);
+int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid);
 
-void l2cap_amp_logical_destroyed(struct hci_conn *ampcon);
+struct l2cap_chan *l2cap_chan_create(struct sock *sk);
+void l2cap_chan_close(struct l2cap_chan *chan, int reason);
+void l2cap_chan_destroy(struct l2cap_chan *chan);
+int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
+								bdaddr_t *dst);
+int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
+								u32 priority);
+void l2cap_chan_busy(struct l2cap_chan *chan, int busy);
+int l2cap_chan_check_security(struct l2cap_chan *chan);
 
 #endif /* __L2CAP_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/mgmt.h flo-ElementalX-5.00-patched/include/net/bluetooth/mgmt.h
--- flo-ElementalX-5.00/include/net/bluetooth/mgmt.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/mgmt.h	2016-06-02 00:28:55.000000000 +0000
@@ -2,6 +2,7 @@
    BlueZ - Bluetooth protocol stack for Linux
 
    Copyright (C) 2010  Nokia Corporation
+   Copyright (C) 2011-2012  Intel Corporation
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -23,399 +24,440 @@
 
 #define MGMT_INDEX_NONE			0xFFFF
 
+#define MGMT_STATUS_SUCCESS		0x00
+#define MGMT_STATUS_UNKNOWN_COMMAND	0x01
+#define MGMT_STATUS_NOT_CONNECTED	0x02
+#define MGMT_STATUS_FAILED		0x03
+#define MGMT_STATUS_CONNECT_FAILED	0x04
+#define MGMT_STATUS_AUTH_FAILED		0x05
+#define MGMT_STATUS_NOT_PAIRED		0x06
+#define MGMT_STATUS_NO_RESOURCES	0x07
+#define MGMT_STATUS_TIMEOUT		0x08
+#define MGMT_STATUS_ALREADY_CONNECTED	0x09
+#define MGMT_STATUS_BUSY		0x0a
+#define MGMT_STATUS_REJECTED		0x0b
+#define MGMT_STATUS_NOT_SUPPORTED	0x0c
+#define MGMT_STATUS_INVALID_PARAMS	0x0d
+#define MGMT_STATUS_DISCONNECTED	0x0e
+#define MGMT_STATUS_NOT_POWERED		0x0f
+#define MGMT_STATUS_CANCELLED		0x10
+#define MGMT_STATUS_INVALID_INDEX	0x11
+#define MGMT_STATUS_RFKILLED		0x12
+
 struct mgmt_hdr {
-	__le16 opcode;
-	__le16 index;
-	__le16 len;
+	__le16	opcode;
+	__le16	index;
+	__le16	len;
 } __packed;
 
+struct mgmt_addr_info {
+	bdaddr_t	bdaddr;
+	__u8		type;
+} __packed;
+#define MGMT_ADDR_INFO_SIZE		7
+
 #define MGMT_OP_READ_VERSION		0x0001
+#define MGMT_READ_VERSION_SIZE		0
 struct mgmt_rp_read_version {
-	__u8 version;
-	__le16 revision;
+	__u8	version;
+	__le16	revision;
+} __packed;
+
+#define MGMT_OP_READ_COMMANDS		0x0002
+#define MGMT_READ_COMMANDS_SIZE		0
+struct mgmt_rp_read_commands {
+	__le16	num_commands;
+	__le16	num_events;
+	__le16	opcodes[0];
 } __packed;
 
 #define MGMT_OP_READ_INDEX_LIST		0x0003
+#define MGMT_READ_INDEX_LIST_SIZE	0
 struct mgmt_rp_read_index_list {
-	__le16 num_controllers;
-	__le16 index[0];
+	__le16	num_controllers;
+	__le16	index[0];
 } __packed;
 
 /* Reserve one extra byte for names in management messages so that they
  * are always guaranteed to be nul-terminated */
 #define MGMT_MAX_NAME_LENGTH		(HCI_MAX_NAME_LENGTH + 1)
+#define MGMT_MAX_SHORT_NAME_LENGTH	(HCI_MAX_SHORT_NAME_LENGTH + 1)
+
+#define MGMT_SETTING_POWERED		0x00000001
+#define MGMT_SETTING_CONNECTABLE	0x00000002
+#define MGMT_SETTING_FAST_CONNECTABLE	0x00000004
+#define MGMT_SETTING_DISCOVERABLE	0x00000008
+#define MGMT_SETTING_PAIRABLE		0x00000010
+#define MGMT_SETTING_LINK_SECURITY	0x00000020
+#define MGMT_SETTING_SSP		0x00000040
+#define MGMT_SETTING_BREDR		0x00000080
+#define MGMT_SETTING_HS			0x00000100
+#define MGMT_SETTING_LE			0x00000200
 
 #define MGMT_OP_READ_INFO		0x0004
+#define MGMT_READ_INFO_SIZE		0
 struct mgmt_rp_read_info {
-	__u8 type;
-	__u8 powered;
-	__u8 connectable;
-	__u8 discoverable;
-	__u8 pairable;
-	__u8 sec_mode;
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
-	__u8 features[8];
-	__u16 manufacturer;
-	__u8 hci_ver;
-	__u16 hci_rev;
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-	__u8 le_white_list_size;
+	bdaddr_t	bdaddr;
+	__u8		version;
+	__le16		manufacturer;
+	__le32		supported_settings;
+	__le32		current_settings;
+	__u8		dev_class[3];
+	__u8		name[MGMT_MAX_NAME_LENGTH];
+	__u8		short_name[MGMT_MAX_SHORT_NAME_LENGTH];
 } __packed;
 
 struct mgmt_mode {
 	__u8 val;
 } __packed;
 
+#define MGMT_SETTING_SIZE		1
+
 #define MGMT_OP_SET_POWERED		0x0005
 
 #define MGMT_OP_SET_DISCOVERABLE	0x0006
+struct mgmt_cp_set_discoverable {
+	__u8	val;
+	__le16	timeout;
+} __packed;
+#define MGMT_SET_DISCOVERABLE_SIZE	3
 
 #define MGMT_OP_SET_CONNECTABLE		0x0007
 
-#define MGMT_OP_SET_PAIRABLE		0x0008
+#define MGMT_OP_SET_FAST_CONNECTABLE	0x0008
+
+#define MGMT_OP_SET_PAIRABLE		0x0009
+
+#define MGMT_OP_SET_LINK_SECURITY	0x000A
+
+#define MGMT_OP_SET_SSP			0x000B
+
+#define MGMT_OP_SET_HS			0x000C
+
+#define MGMT_OP_SET_LE			0x000D
+#define MGMT_OP_SET_DEV_CLASS		0x000E
+struct mgmt_cp_set_dev_class {
+	__u8	major;
+	__u8	minor;
+} __packed;
+#define MGMT_SET_DEV_CLASS_SIZE		2
+
+#define MGMT_OP_SET_LOCAL_NAME		0x000F
+struct mgmt_cp_set_local_name {
+	__u8	name[MGMT_MAX_NAME_LENGTH];
+	__u8	short_name[MGMT_MAX_SHORT_NAME_LENGTH];
+} __packed;
+#define MGMT_SET_LOCAL_NAME_SIZE	260
 
-#define MGMT_OP_ADD_UUID		0x0009
+#define MGMT_OP_ADD_UUID		0x0010
 struct mgmt_cp_add_uuid {
-	__u8 uuid[16];
-	__u8 svc_hint;
+	__u8	uuid[16];
+	__u8	svc_hint;
 } __packed;
+#define MGMT_ADD_UUID_SIZE		17
 
-#define MGMT_OP_REMOVE_UUID		0x000A
+#define MGMT_OP_REMOVE_UUID		0x0011
 struct mgmt_cp_remove_uuid {
-	__u8 uuid[16];
+	__u8	uuid[16];
 } __packed;
+#define MGMT_REMOVE_UUID_SIZE		16
 
-#define MGMT_OP_SET_DEV_CLASS		0x000B
-struct mgmt_cp_set_dev_class {
-	__u8 major;
-	__u8 minor;
+struct mgmt_link_key_info {
+	struct mgmt_addr_info addr;
+	__u8	type;
+	__u8	val[16];
+	__u8	pin_len;
 } __packed;
-#define MGMT_MAJOR_CLASS_MASK		0x1F
-#define MGMT_MAJOR_CLASS_LIMITED	0x20
 
-#define MGMT_OP_SET_SERVICE_CACHE	0x000C
-struct mgmt_cp_set_service_cache {
-	__u8 enable;
-} __packed;
-
-struct mgmt_key_info {
-	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
-	u8 val[16];
-	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[10];
-} __packed;
-
-#define MGMT_OP_LOAD_KEYS		0x000D
-struct mgmt_cp_load_keys {
-	__u8 debug_keys;
-	__le16 key_count;
-	struct mgmt_key_info keys[0];
-} __packed;
-
-#define MGMT_OP_REMOVE_KEY		0x000E
-struct mgmt_cp_remove_key {
-	bdaddr_t bdaddr;
-	__u8 disconnect;
+#define MGMT_OP_LOAD_LINK_KEYS		0x0012
+struct mgmt_cp_load_link_keys {
+	__u8	debug_keys;
+	__le16	key_count;
+	struct	mgmt_link_key_info keys[0];
+} __packed;
+#define MGMT_LOAD_LINK_KEYS_SIZE	3
+
+struct mgmt_ltk_info {
+	struct mgmt_addr_info addr;
+	__u8	authenticated;
+	__u8	master;
+	__u8	enc_size;
+	__le16	ediv;
+	__u8	rand[8];
+	__u8	val[16];
 } __packed;
 
-#define MGMT_OP_DISCONNECT		0x000F
+#define MGMT_OP_LOAD_LONG_TERM_KEYS	0x0013
+struct mgmt_cp_load_long_term_keys {
+	__le16	key_count;
+	struct	mgmt_ltk_info keys[0];
+} __packed;
+#define MGMT_LOAD_LONG_TERM_KEYS_SIZE	2
+
+#define MGMT_OP_DISCONNECT		0x0014
 struct mgmt_cp_disconnect {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_DISCONNECT_SIZE		MGMT_ADDR_INFO_SIZE
 struct mgmt_rp_disconnect {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_GET_CONNECTIONS		0x0010
+#define MGMT_OP_GET_CONNECTIONS		0x0015
+#define MGMT_GET_CONNECTIONS_SIZE	0
 struct mgmt_rp_get_connections {
 	__le16 conn_count;
-	bdaddr_t conn[0];
+	struct mgmt_addr_info addr[0];
 } __packed;
 
-#define MGMT_OP_PIN_CODE_REPLY		0x0011
+#define MGMT_OP_PIN_CODE_REPLY		0x0016
 struct mgmt_cp_pin_code_reply {
-	bdaddr_t bdaddr;
-	__u8 pin_len;
-	__u8 pin_code[16];
+	struct mgmt_addr_info addr;
+	__u8	pin_len;
+	__u8	pin_code[16];
 } __packed;
+#define MGMT_PIN_CODE_REPLY_SIZE	(MGMT_ADDR_INFO_SIZE + 17)
 struct mgmt_rp_pin_code_reply {
-	bdaddr_t bdaddr;
-	uint8_t status;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0012
+#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0017
 struct mgmt_cp_pin_code_neg_reply {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_PIN_CODE_NEG_REPLY_SIZE	MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_SET_IO_CAPABILITY	0x0013
+#define MGMT_OP_SET_IO_CAPABILITY	0x0018
 struct mgmt_cp_set_io_capability {
-	__u8 io_capability;
+	__u8	io_capability;
 } __packed;
+#define MGMT_SET_IO_CAPABILITY_SIZE	1
 
-#define MGMT_OP_PAIR_DEVICE		0x0014
+#define MGMT_OP_PAIR_DEVICE		0x0019
 struct mgmt_cp_pair_device {
-	bdaddr_t bdaddr;
-	__u8 io_cap;
+	struct mgmt_addr_info addr;
+	__u8	io_cap;
 } __packed;
+#define MGMT_PAIR_DEVICE_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
 struct mgmt_rp_pair_device {
-	bdaddr_t bdaddr;
-	__u8 status;
-} __packed;
-
-#define MGMT_OP_USER_CONFIRM_REPLY	0x0015
-struct mgmt_cp_user_confirm_reply {
-	bdaddr_t bdaddr;
-} __packed;
-struct mgmt_rp_user_confirm_reply {
-	bdaddr_t bdaddr;
-	__u8 status;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x0016
+#define MGMT_OP_CANCEL_PAIR_DEVICE	0x001A
+#define MGMT_CANCEL_PAIR_DEVICE_SIZE	MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_SET_LOCAL_NAME		0x0017
-struct mgmt_cp_set_local_name {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
+#define MGMT_OP_UNPAIR_DEVICE		0x001B
+struct mgmt_cp_unpair_device {
+	struct mgmt_addr_info addr;
+	__u8 disconnect;
 } __packed;
+#define MGMT_UNPAIR_DEVICE_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
+struct mgmt_rp_unpair_device {
+	struct mgmt_addr_info addr;
+};
 
-#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0018
-struct mgmt_rp_read_local_oob_data {
-	__u8 hash[16];
-	__u8 randomizer[16];
+#define MGMT_OP_USER_CONFIRM_REPLY	0x001C
+struct mgmt_cp_user_confirm_reply {
+	struct mgmt_addr_info addr;
 } __packed;
-
-#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0019
-struct mgmt_cp_add_remote_oob_data {
-	bdaddr_t bdaddr;
-	__u8 hash[16];
-	__u8 randomizer[16];
+#define MGMT_USER_CONFIRM_REPLY_SIZE	MGMT_ADDR_INFO_SIZE
+struct mgmt_rp_user_confirm_reply {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x001A
-struct mgmt_cp_remove_remote_oob_data {
-	bdaddr_t bdaddr;
+#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x001D
+struct mgmt_cp_user_confirm_neg_reply {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_USER_CONFIRM_NEG_REPLY_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_START_DISCOVERY		0x001B
-
-#define MGMT_OP_STOP_DISCOVERY		0x001C
-
-#define MGMT_OP_USER_PASSKEY_REPLY	0x001D
+#define MGMT_OP_USER_PASSKEY_REPLY	0x001E
 struct mgmt_cp_user_passkey_reply {
-	bdaddr_t bdaddr;
-	__le32 passkey;
+	struct mgmt_addr_info addr;
+	__le32	passkey;
 } __packed;
-
-#define MGMT_OP_RESOLVE_NAME		0x001E
-struct mgmt_cp_resolve_name {
-	bdaddr_t bdaddr;
+#define MGMT_USER_PASSKEY_REPLY_SIZE	(MGMT_ADDR_INFO_SIZE + 4)
+struct mgmt_rp_user_passkey_reply {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_SET_LIMIT_DISCOVERABLE	0x001F
-
-#define MGMT_OP_SET_CONNECTION_PARAMS	0x0020
-struct mgmt_cp_set_connection_params {
-	bdaddr_t bdaddr;
-	__le16 interval_min;
-	__le16 interval_max;
-	__le16 slave_latency;
-	__le16 timeout_multiplier;
+#define MGMT_OP_USER_PASSKEY_NEG_REPLY	0x001F
+struct mgmt_cp_user_passkey_neg_reply {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_USER_PASSKEY_NEG_REPLY_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_ENCRYPT_LINK		0x0021
-struct mgmt_cp_encrypt_link {
-	bdaddr_t bdaddr;
-	__u8 enable;
+#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0020
+#define MGMT_READ_LOCAL_OOB_DATA_SIZE	0
+struct mgmt_rp_read_local_oob_data {
+	__u8	hash[16];
+	__u8	randomizer[16];
 } __packed;
 
-#define MGMT_OP_SET_RSSI_REPORTER		0x0022
-struct mgmt_cp_set_rssi_reporter {
-	bdaddr_t	bdaddr;
-	__s8		rssi_threshold;
-	__le16	interval;
-	__u8		updateOnThreshExceed;
+#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0021
+struct mgmt_cp_add_remote_oob_data {
+	struct mgmt_addr_info addr;
+	__u8	hash[16];
+	__u8	randomizer[16];
 } __packed;
+#define MGMT_ADD_REMOTE_OOB_DATA_SIZE	(MGMT_ADDR_INFO_SIZE + 32)
 
-#define MGMT_OP_UNSET_RSSI_REPORTER		0x0023
-struct mgmt_cp_unset_rssi_reporter {
-	bdaddr_t	bdaddr;
+#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x0022
+struct mgmt_cp_remove_remote_oob_data {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_REMOVE_REMOTE_OOB_DATA_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_CANCEL_RESOLVE_NAME	0x0024
-struct mgmt_cp_cancel_resolve_name {
-	bdaddr_t bdaddr;
+#define MGMT_OP_START_DISCOVERY		0x0023
+struct mgmt_cp_start_discovery {
+	__u8 type;
 } __packed;
+#define MGMT_START_DISCOVERY_SIZE	1
 
-#define MGMT_OP_LE_READ_WHITE_LIST_SIZE	0xE000
-
-#define MGMT_OP_LE_CLEAR_WHITE_LIST	0xE001
-
-#define MGMT_OP_LE_ADD_DEV_WHITE_LIST	0xE002
-struct mgmt_cp_le_add_dev_white_list {
-	__u8 addr_type;
-	bdaddr_t bdaddr;
+#define MGMT_OP_STOP_DISCOVERY		0x0024
+struct mgmt_cp_stop_discovery {
+	__u8 type;
 } __packed;
+#define MGMT_STOP_DISCOVERY_SIZE	1
 
-#define MGMT_OP_LE_REMOVE_DEV_WHITE_LIST	0xE003
-struct mgmt_cp_le_remove_dev_white_list {
-	__u8 addr_type;
-	bdaddr_t bdaddr;
+#define MGMT_OP_CONFIRM_NAME		0x0025
+struct mgmt_cp_confirm_name {
+	struct mgmt_addr_info addr;
+	__u8	name_known;
+} __packed;
+#define MGMT_CONFIRM_NAME_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
+struct mgmt_rp_confirm_name {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_LE_CREATE_CONN_WHITE_LIST	0xE004
-
-#define MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST	0xE005
+#define MGMT_OP_BLOCK_DEVICE		0x0026
+struct mgmt_cp_block_device {
+	struct mgmt_addr_info addr;
+} __packed;
+#define MGMT_BLOCK_DEVICE_SIZE		MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_LE_CANCEL_CREATE_CONN	0xE006
-struct mgmt_cp_le_cancel_create_conn {
-	bdaddr_t	bdaddr;
+#define MGMT_OP_UNBLOCK_DEVICE		0x0027
+struct mgmt_cp_unblock_device {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_UNBLOCK_DEVICE_SIZE	MGMT_ADDR_INFO_SIZE
 
 #define MGMT_EV_CMD_COMPLETE		0x0001
 struct mgmt_ev_cmd_complete {
-	__le16 opcode;
-	__u8 data[0];
+	__le16	opcode;
+	__u8	status;
+	__u8	data[0];
 } __packed;
 
 #define MGMT_EV_CMD_STATUS		0x0002
 struct mgmt_ev_cmd_status {
-	__u8 status;
-	__le16 opcode;
+	__le16	opcode;
+	__u8	status;
 } __packed;
 
 #define MGMT_EV_CONTROLLER_ERROR	0x0003
 struct mgmt_ev_controller_error {
-	__u8 error_code;
+	__u8	error_code;
 } __packed;
 
 #define MGMT_EV_INDEX_ADDED		0x0004
 
 #define MGMT_EV_INDEX_REMOVED		0x0005
 
-#define MGMT_EV_POWERED			0x0006
-
-#define MGMT_EV_DISCOVERABLE		0x0007
+#define MGMT_EV_NEW_SETTINGS		0x0006
 
-#define MGMT_EV_CONNECTABLE		0x0008
+#define MGMT_EV_CLASS_OF_DEV_CHANGED	0x0007
+struct mgmt_ev_class_of_dev_changed {
+	__u8	dev_class[3];
+};
 
-#define MGMT_EV_PAIRABLE		0x0009
+#define MGMT_EV_LOCAL_NAME_CHANGED	0x0008
+struct mgmt_ev_local_name_changed {
+	__u8	name[MGMT_MAX_NAME_LENGTH];
+	__u8	short_name[MGMT_MAX_SHORT_NAME_LENGTH];
+} __packed;
 
-#define MGMT_EV_NEW_KEY			0x000A
-struct mgmt_ev_new_key {
-	__u8 store_hint;
-	struct mgmt_key_info key;
+#define MGMT_EV_NEW_LINK_KEY		0x0009
+struct mgmt_ev_new_link_key {
+	__u8	store_hint;
+	struct mgmt_link_key_info key;
 } __packed;
 
-#define MGMT_EV_CONNECTED		0x000B
-struct mgmt_ev_connected {
-	bdaddr_t bdaddr;
-	__u8 le;
+#define MGMT_EV_NEW_LONG_TERM_KEY	0x000A
+struct mgmt_ev_new_long_term_key {
+	__u8	store_hint;
+	struct mgmt_ltk_info key;
 } __packed;
 
-#define MGMT_EV_DISCONNECTED		0x000C
-struct mgmt_ev_disconnected {
-	bdaddr_t bdaddr;
-	__u8     reason;
+#define MGMT_EV_DEVICE_CONNECTED	0x000B
+struct mgmt_ev_device_connected {
+	struct mgmt_addr_info addr;
+	__le32	flags;
+	__le16	eir_len;
+	__u8	eir[0];
 } __packed;
 
+#define MGMT_EV_DEVICE_DISCONNECTED	0x000C
+
 #define MGMT_EV_CONNECT_FAILED		0x000D
 struct mgmt_ev_connect_failed {
-	bdaddr_t bdaddr;
-	__u8 status;
+	struct mgmt_addr_info addr;
+	__u8	status;
 } __packed;
 
 #define MGMT_EV_PIN_CODE_REQUEST	0x000E
 struct mgmt_ev_pin_code_request {
-	bdaddr_t bdaddr;
-	__u8 secure;
+	struct mgmt_addr_info addr;
+	__u8	secure;
 } __packed;
 
 #define MGMT_EV_USER_CONFIRM_REQUEST	0x000F
 struct mgmt_ev_user_confirm_request {
-	bdaddr_t bdaddr;
-	__u8 auto_confirm;
-	__u8 event;
-	__le32 value;
-} __packed;
-
-#define MGMT_EV_AUTH_FAILED		0x0010
-struct mgmt_ev_auth_failed {
-	bdaddr_t bdaddr;
-	__u8 status;
-} __packed;
-
-#define MGMT_EV_LOCAL_NAME_CHANGED	0x0011
-struct mgmt_ev_local_name_changed {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
+	struct mgmt_addr_info addr;
+	__u8	confirm_hint;
+	__le32	value;
 } __packed;
 
-#define MGMT_EV_DEVICE_FOUND		0x0012
-struct mgmt_ev_device_found {
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
-	__s8 rssi;
-	__u8 le;
-	__u8 type;
-	__u8 eir[HCI_MAX_EIR_LENGTH];
-} __packed;
-
-#define MGMT_EV_REMOTE_NAME		0x0013
-struct mgmt_ev_remote_name {
-	bdaddr_t bdaddr;
-	__u8 status;
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-} __packed;
-
-#define MGMT_EV_DISCOVERING		0x0014
-
-#define MGMT_EV_USER_PASSKEY_REQUEST	0x0015
+#define MGMT_EV_USER_PASSKEY_REQUEST	0x0010
 struct mgmt_ev_user_passkey_request {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_ENCRYPT_CHANGE		0x0016
-struct mgmt_ev_encrypt_change {
-	bdaddr_t bdaddr;
-	__u8 status;
+#define MGMT_EV_AUTH_FAILED		0x0011
+struct mgmt_ev_auth_failed {
+	struct mgmt_addr_info addr;
+	__u8	status;
 } __packed;
 
+#define MGMT_DEV_FOUND_CONFIRM_NAME    0x01
+#define MGMT_DEV_FOUND_LEGACY_PAIRING  0x02
 
-#define MGMT_EV_REMOTE_CLASS		0x0017
-struct mgmt_ev_remote_class {
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
+#define MGMT_EV_DEVICE_FOUND		0x0012
+struct mgmt_ev_device_found {
+	struct mgmt_addr_info addr;
+	__s8	rssi;
+	__u8	flags[4];
+	__le16	eir_len;
+	__u8	eir[0];
 } __packed;
 
-#define MGMT_EV_REMOTE_VERSION		0x0018
-struct mgmt_ev_remote_version {
-	bdaddr_t bdaddr;
-	__u8	lmp_ver;
-	__u16	manufacturer;
-	__u16	lmp_subver;
+#define MGMT_EV_DISCOVERING		0x0013
+struct mgmt_ev_discovering {
+	__u8	type;
+	__u8	discovering;
 } __packed;
 
-#define MGMT_EV_REMOTE_FEATURES		0x0019
-struct mgmt_ev_remote_features {
-	bdaddr_t bdaddr;
-	uint8_t features[8];
+#define MGMT_EV_DEVICE_BLOCKED		0x0014
+struct mgmt_ev_device_blocked {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_RSSI_UPDATE		0x0020
-struct mgmt_ev_rssi_update {
-	bdaddr_t	bdaddr;
-	__s8			rssi;
+#define MGMT_EV_DEVICE_UNBLOCKED	0x0015
+struct mgmt_ev_device_unblocked {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_LE_CONN_PARAMS		0xF000
-struct mgmt_ev_le_conn_params {
-	bdaddr_t bdaddr;
-	__u16 interval;
-	__u16 latency;
-	__u16 timeout;
+#define MGMT_EV_DEVICE_UNPAIRED		0x0016
+struct mgmt_ev_device_unpaired {
+	struct mgmt_addr_info addr;
 } __packed;
diff -urN flo-ElementalX-5.00/include/net/bluetooth/rfcomm.h flo-ElementalX-5.00-patched/include/net/bluetooth/rfcomm.h
--- flo-ElementalX-5.00/include/net/bluetooth/rfcomm.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/rfcomm.h	2016-06-02 00:28:55.000000000 +0000
@@ -211,6 +211,7 @@
 #define RFCOMM_AUTH_ACCEPT  6
 #define RFCOMM_AUTH_REJECT  7
 #define RFCOMM_DEFER_SETUP  8
+#define RFCOMM_ENC_DROP     9
 
 /* Scheduling flags and events */
 #define RFCOMM_SCHED_WAKEUP 31
@@ -234,7 +235,8 @@
 /* ---- RFCOMM DLCs (channels) ---- */
 struct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio);
 void rfcomm_dlc_free(struct rfcomm_dlc *d);
-int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel);
+int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
+								u8 channel);
 int  rfcomm_dlc_close(struct rfcomm_dlc *d, int reason);
 int  rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb);
 int  rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig);
@@ -271,7 +273,8 @@
 }
 
 /* ---- RFCOMM sessions ---- */
-void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst);
+void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src,
+								bdaddr_t *dst);
 
 static inline void rfcomm_session_hold(struct rfcomm_session *s)
 {
@@ -312,7 +315,8 @@
 int  rfcomm_init_sockets(void);
 void rfcomm_cleanup_sockets(void);
 
-int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d);
+int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel,
+							struct rfcomm_dlc **d);
 
 /* ---- RFCOMM TTY ---- */
 #define RFCOMM_MAX_DEV  256
diff -urN flo-ElementalX-5.00/include/net/bluetooth/sco.h flo-ElementalX-5.00-patched/include/net/bluetooth/sco.h
--- flo-ElementalX-5.00/include/net/bluetooth/sco.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/sco.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -31,15 +30,13 @@
 #define SCO_DEFAULT_FLUSH_TO	0xFFFF
 
 #define SCO_CONN_TIMEOUT	(HZ * 40)
-#define SCO_DISCONN_TIMEOUT	(HZ * 20)
+#define SCO_DISCONN_TIMEOUT	(HZ * 2)
 #define SCO_CONN_IDLE_TIMEOUT	(HZ * 60)
 
 /* SCO socket address */
 struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
-	__u16		sco_pkt_type;
-	__s8		is_wbs;
 };
 
 /* SCO socket options */
@@ -75,8 +72,7 @@
 
 struct sco_pinfo {
 	struct bt_sock	bt;
-	__u16		pkt_type;
-
+	__u32		flags;
 	struct sco_conn	*conn;
 };
 
diff -urN flo-ElementalX-5.00/include/net/bluetooth/smp.h flo-ElementalX-5.00-patched/include/net/bluetooth/smp.h
--- flo-ElementalX-5.00/include/net/bluetooth/smp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/smp.h	2016-06-02 00:28:55.000000000 +0000
@@ -55,13 +55,6 @@
 #define SMP_AUTH_BONDING	0x01
 #define SMP_AUTH_MITM		0x04
 
-#define SMP_JUST_WORKS		0x00
-#define SMP_JUST_CFM		0x01
-#define SMP_REQ_PASSKEY		0x02
-#define SMP_CFM_PASSKEY		0x03
-#define SMP_REQ_OOB		0x04
-#define SMP_OVERLAP		0xFF
-
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {
 	__u8	confirm_val[16];
@@ -122,10 +115,32 @@
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16
 
+#define SMP_FLAG_TK_VALID	1
+#define SMP_FLAG_CFM_PENDING	2
+#define SMP_FLAG_MITM_AUTH	3
+
+struct smp_chan {
+	struct l2cap_conn *conn;
+	u8		preq[7]; /* SMP Pairing Request */
+	u8		prsp[7]; /* SMP Pairing Response */
+	u8              prnd[16]; /* SMP Pairing Random (local) */
+	u8              rrnd[16]; /* SMP Pairing Random (remote) */
+	u8		pcnf[16]; /* SMP Pairing Confirm */
+	u8		tk[16]; /* SMP Temporary Key */
+	u8		enc_key_size;
+	unsigned long	smp_flags;
+	struct crypto_blkcipher	*tfm;
+	struct work_struct confirm;
+	struct work_struct random;
+
+};
+
 /* SMP Commands */
-int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level);
+int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
-int smp_link_encrypt_cmplt(struct l2cap_conn *conn, __u8 status, __u8 encrypt);
-void smp_timeout(unsigned long l2cap_conn);
+int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
+
+void smp_chan_destroy(struct l2cap_conn *conn);
 
 #endif /* __SMP_H */
diff -urN flo-ElementalX-5.00/include/net/mip6.h flo-ElementalX-5.00-patched/include/net/mip6.h
--- flo-ElementalX-5.00/include/net/mip6.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/mip6.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,54 +0,0 @@
-/*
- * Copyright (C)2003-2006 Helsinki University of Technology
- * Copyright (C)2003-2006 USAGI/WIDE Project
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/*
- * Authors:
- *	Noriaki TAKAMIYA @USAGI
- *	Masahide NAKAMURA @USAGI
- *	YOSHIFUJI Hideaki @USAGI
- */
-#ifndef _NET_MIP6_H
-#define _NET_MIP6_H
-
-#include <linux/skbuff.h>
-#include <net/sock.h>
-
-/*
- * Mobility Header
- */
-struct ip6_mh {
-	__u8	ip6mh_proto;
-	__u8	ip6mh_hdrlen;
-	__u8	ip6mh_type;
-	__u8	ip6mh_reserved;
-	__u16	ip6mh_cksum;
-	/* Followed by type specific messages */
-	__u8	data[0];
-} __packed;
-
-#define IP6_MH_TYPE_BRR		0   /* Binding Refresh Request */
-#define IP6_MH_TYPE_HOTI	1   /* HOTI Message   */
-#define IP6_MH_TYPE_COTI	2   /* COTI Message  */
-#define IP6_MH_TYPE_HOT		3   /* HOT Message   */
-#define IP6_MH_TYPE_COT		4   /* COT Message  */
-#define IP6_MH_TYPE_BU		5   /* Binding Update */
-#define IP6_MH_TYPE_BACK	6   /* Binding ACK */
-#define IP6_MH_TYPE_BERROR	7   /* Binding Error */
-#define IP6_MH_TYPE_MAX		IP6_MH_TYPE_BERROR
-
-#endif
diff -urN flo-ElementalX-5.00/include/sound/tpa6130a2-plat.h flo-ElementalX-5.00-patched/include/sound/tpa6130a2-plat.h
--- flo-ElementalX-5.00/include/sound/tpa6130a2-plat.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/sound/tpa6130a2-plat.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,30 +0,0 @@
-/*
- * TPA6130A2 driver platform header
- *
- * Copyright (C) Nokia Corporation
- *
- * Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#ifndef TPA6130A2_PLAT_H
-#define TPA6130A2_PLAT_H
-
-struct tpa6130a2_platform_data {
-	int power_gpio;
-};
-
-#endif
diff -urN flo-ElementalX-5.00/include/trace/events/ext4.h flo-ElementalX-5.00-patched/include/trace/events/ext4.h
--- flo-ElementalX-5.00/include/trace/events/ext4.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/trace/events/ext4.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,2061 +0,0 @@
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM ext4
-
-#if !defined(_TRACE_EXT4_H) || defined(TRACE_HEADER_MULTI_READ)
-#define _TRACE_EXT4_H
-
-#include <linux/writeback.h>
-#include <linux/tracepoint.h>
-
-struct ext4_allocation_context;
-struct ext4_allocation_request;
-struct ext4_extent;
-struct ext4_prealloc_space;
-struct ext4_inode_info;
-struct mpage_da_data;
-struct ext4_map_blocks;
-struct ext4_extent;
-
-#define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))
-
-TRACE_EVENT(ext4_free_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16, mode			)
-		__field(	uid_t,	uid			)
-		__field(	gid_t,	gid			)
-		__field(	__u64, blocks			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->uid	= inode->i_uid;
-		__entry->gid	= inode->i_gid;
-		__entry->blocks	= inode->i_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o uid %u gid %u blocks %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->mode,
-		  __entry->uid, __entry->gid, __entry->blocks)
-);
-
-TRACE_EVENT(ext4_request_inode,
-	TP_PROTO(struct inode *dir, int mode),
-
-	TP_ARGS(dir, mode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	dir			)
-		__field(	__u16, mode			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= dir->i_sb->s_dev;
-		__entry->dir	= dir->i_ino;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d dir %lu mode 0%o",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->dir, __entry->mode)
-);
-
-TRACE_EVENT(ext4_allocate_inode,
-	TP_PROTO(struct inode *inode, struct inode *dir, int mode),
-
-	TP_ARGS(inode, dir, mode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	ino_t,	dir			)
-		__field(	__u16,	mode			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->dir	= dir->i_ino;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu dir %lu mode 0%o",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->dir, __entry->mode)
-);
-
-TRACE_EVENT(ext4_evict_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	nlink			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->nlink	= inode->i_nlink;
-	),
-
-	TP_printk("dev %d,%d ino %lu nlink %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->nlink)
-);
-
-TRACE_EVENT(ext4_drop_inode,
-	TP_PROTO(struct inode *inode, int drop),
-
-	TP_ARGS(inode, drop),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	drop			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->drop	= drop;
-	),
-
-	TP_printk("dev %d,%d ino %lu drop %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->drop)
-);
-
-TRACE_EVENT(ext4_mark_inode_dirty,
-	TP_PROTO(struct inode *inode, unsigned long IP),
-
-	TP_ARGS(inode, IP),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(unsigned long,	ip			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->ip	= IP;
-	),
-
-	TP_printk("dev %d,%d ino %lu caller %pF",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, (void *)__entry->ip)
-);
-
-TRACE_EVENT(ext4_begin_ordered_truncate,
-	TP_PROTO(struct inode *inode, loff_t new_size),
-
-	TP_ARGS(inode, new_size),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	new_size		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->new_size	= new_size;
-	),
-
-	TP_printk("dev %d,%d ino %lu new_size %lld",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->new_size)
-);
-
-DECLARE_EVENT_CLASS(ext4__write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int, len		)
-		__field(	unsigned int, flags		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->pos	= pos;
-		__entry->len	= len;
-		__entry->flags	= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %u flags %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->flags)
-);
-
-DEFINE_EVENT(ext4__write_begin, ext4_write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags)
-);
-
-DEFINE_EVENT(ext4__write_begin, ext4_da_write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags)
-);
-
-DECLARE_EVENT_CLASS(ext4__write_end,
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-			unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int, len		)
-		__field(	unsigned int, copied		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->pos	= pos;
-		__entry->len	= len;
-		__entry->copied	= copied;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %u copied %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_ordered_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_writeback_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_journalled_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_da_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-TRACE_EVENT(ext4_da_writepages,
-	TP_PROTO(struct inode *inode, struct writeback_control *wbc),
-
-	TP_ARGS(inode, wbc),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	long,	nr_to_write		)
-		__field(	long,	pages_skipped		)
-		__field(	loff_t,	range_start		)
-		__field(	loff_t,	range_end		)
-		__field(	int,	sync_mode		)
-		__field(	char,	for_kupdate		)
-		__field(	char,	range_cyclic		)
-		__field(       pgoff_t,	writeback_index		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->nr_to_write	= wbc->nr_to_write;
-		__entry->pages_skipped	= wbc->pages_skipped;
-		__entry->range_start	= wbc->range_start;
-		__entry->range_end	= wbc->range_end;
-		__entry->sync_mode	= wbc->sync_mode;
-		__entry->for_kupdate	= wbc->for_kupdate;
-		__entry->range_cyclic	= wbc->range_cyclic;
-		__entry->writeback_index = inode->i_mapping->writeback_index;
-	),
-
-	TP_printk("dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld "
-		  "range_start %lld range_end %lld sync_mode %d"
-		  "for_kupdate %d range_cyclic %d writeback_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->nr_to_write,
-		  __entry->pages_skipped, __entry->range_start,
-		  __entry->range_end, __entry->sync_mode,
-		  __entry->for_kupdate, __entry->range_cyclic,
-		  (unsigned long) __entry->writeback_index)
-);
-
-TRACE_EVENT(ext4_da_write_pages,
-	TP_PROTO(struct inode *inode, struct mpage_da_data *mpd),
-
-	TP_ARGS(inode, mpd),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	b_blocknr		)
-		__field(	__u32,	b_size			)
-		__field(	__u32,	b_state			)
-		__field(	unsigned long,	first_page	)
-		__field(	int,	io_done			)
-		__field(	int,	pages_written		)
-		__field(	int,	sync_mode		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->b_blocknr	= mpd->b_blocknr;
-		__entry->b_size		= mpd->b_size;
-		__entry->b_state	= mpd->b_state;
-		__entry->first_page	= mpd->first_page;
-		__entry->io_done	= mpd->io_done;
-		__entry->pages_written	= mpd->pages_written;
-		__entry->sync_mode	= mpd->wbc->sync_mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu b_blocknr %llu b_size %u b_state 0x%04x "
-		  "first_page %lu io_done %d pages_written %d sync_mode %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->b_blocknr, __entry->b_size,
-		  __entry->b_state, __entry->first_page,
-		  __entry->io_done, __entry->pages_written,
-		  __entry->sync_mode
-                  )
-);
-
-TRACE_EVENT(ext4_da_writepages_result,
-	TP_PROTO(struct inode *inode, struct writeback_control *wbc,
-			int ret, int pages_written),
-
-	TP_ARGS(inode, wbc, ret, pages_written),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	ret			)
-		__field(	int,	pages_written		)
-		__field(	long,	pages_skipped		)
-		__field(	int,	sync_mode		)
-		__field(       pgoff_t,	writeback_index		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->ret		= ret;
-		__entry->pages_written	= pages_written;
-		__entry->pages_skipped	= wbc->pages_skipped;
-		__entry->sync_mode	= wbc->sync_mode;
-		__entry->writeback_index = inode->i_mapping->writeback_index;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d pages_written %d pages_skipped %ld "
-		  "sync_mode %d writeback_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->ret,
-		  __entry->pages_written, __entry->pages_skipped,
-		  __entry->sync_mode,
-		  (unsigned long) __entry->writeback_index)
-);
-
-DECLARE_EVENT_CLASS(ext4__page_op,
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page),
-
-	TP_STRUCT__entry(
-		__field(	pgoff_t, index			)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-
-	),
-
-	TP_fast_assign(
-		__entry->index	= page->index;
-		__entry->ino	= page->mapping->host->i_ino;
-		__entry->dev	= page->mapping->host->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu page_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->index)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_writepage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_readpage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_releasepage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-TRACE_EVENT(ext4_invalidatepage,
-	TP_PROTO(struct page *page, unsigned long offset),
-
-	TP_ARGS(page, offset),
-
-	TP_STRUCT__entry(
-		__field(	pgoff_t, index			)
-		__field(	unsigned long, offset		)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-
-	),
-
-	TP_fast_assign(
-		__entry->index	= page->index;
-		__entry->offset	= offset;
-		__entry->ino	= page->mapping->host->i_ino;
-		__entry->dev	= page->mapping->host->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu page_index %lu offset %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->index, __entry->offset)
-);
-
-TRACE_EVENT(ext4_discard_blocks,
-	TP_PROTO(struct super_block *sb, unsigned long long blk,
-			unsigned long long count),
-
-	TP_ARGS(sb, blk, count),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u64,	blk			)
-		__field(	__u64,	count			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->blk	= blk;
-		__entry->count	= count;
-	),
-
-	TP_printk("dev %d,%d blk %llu count %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->blk, __entry->count)
-);
-
-DECLARE_EVENT_CLASS(ext4__mb_new_pa,
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	pa_pstart		)
-		__field(	__u32,	pa_len			)
-		__field(	__u64,	pa_lstart		)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->pa_pstart	= pa->pa_pstart;
-		__entry->pa_len		= pa->pa_len;
-		__entry->pa_lstart	= pa->pa_lstart;
-	),
-
-	TP_printk("dev %d,%d ino %lu pstart %llu len %u lstart %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pa_pstart, __entry->pa_len, __entry->pa_lstart)
-);
-
-DEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_inode_pa,
-
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa)
-);
-
-DEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_group_pa,
-
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa)
-);
-
-TRACE_EVENT(ext4_mb_release_inode_pa,
-	TP_PROTO(struct ext4_prealloc_space *pa,
-		 unsigned long long block, unsigned int count),
-
-	TP_ARGS(pa, block, count),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	block			)
-		__field(	__u32,	count			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= pa->pa_inode->i_sb->s_dev;
-		__entry->ino		= pa->pa_inode->i_ino;
-		__entry->block		= block;
-		__entry->count		= count;
-	),
-
-	TP_printk("dev %d,%d ino %lu block %llu count %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->block, __entry->count)
-);
-
-TRACE_EVENT(ext4_mb_release_group_pa,
-	TP_PROTO(struct super_block *sb, struct ext4_prealloc_space *pa),
-
-	TP_ARGS(sb, pa),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u64,	pa_pstart		)
-		__field(	__u32,	pa_len			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= sb->s_dev;
-		__entry->pa_pstart	= pa->pa_pstart;
-		__entry->pa_len		= pa->pa_len;
-	),
-
-	TP_printk("dev %d,%d pstart %llu len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->pa_pstart, __entry->pa_len)
-);
-
-TRACE_EVENT(ext4_discard_preallocations,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-	),
-
-	TP_printk("dev %d,%d ino %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino)
-);
-
-TRACE_EVENT(ext4_mb_discard_preallocations,
-	TP_PROTO(struct super_block *sb, int needed),
-
-	TP_ARGS(sb, needed),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	int,	needed			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->needed	= needed;
-	),
-
-	TP_printk("dev %d,%d needed %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->needed)
-);
-
-TRACE_EVENT(ext4_request_blocks,
-	TP_PROTO(struct ext4_allocation_request *ar),
-
-	TP_ARGS(ar),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	unsigned int, flags		)
-		__field(	unsigned int, len		)
-		__field(	__u32,  logical			)
-		__field(	__u32,	lleft			)
-		__field(	__u32,	lright			)
-		__field(	__u64,	goal			)
-		__field(	__u64,	pleft			)
-		__field(	__u64,	pright			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= ar->inode->i_sb->s_dev;
-		__entry->ino	= ar->inode->i_ino;
-		__entry->flags	= ar->flags;
-		__entry->len	= ar->len;
-		__entry->logical = ar->logical;
-		__entry->goal	= ar->goal;
-		__entry->lleft	= ar->lleft;
-		__entry->lright	= ar->lright;
-		__entry->pleft	= ar->pleft;
-		__entry->pright	= ar->pright;
-	),
-
-	TP_printk("dev %d,%d ino %lu flags %u len %u lblk %u goal %llu "
-		  "lleft %u lright %u pleft %llu pright %llu ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->flags,
-		  __entry->len, __entry->logical, __entry->goal,
-		  __entry->lleft, __entry->lright, __entry->pleft,
-		  __entry->pright)
-);
-
-TRACE_EVENT(ext4_allocate_blocks,
-	TP_PROTO(struct ext4_allocation_request *ar, unsigned long long block),
-
-	TP_ARGS(ar, block),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	block			)
-		__field(	unsigned int, flags		)
-		__field(	unsigned int, len		)
-		__field(	__u32,  logical			)
-		__field(	__u32,	lleft			)
-		__field(	__u32,	lright			)
-		__field(	__u64,	goal			)
-		__field(	__u64,	pleft			)
-		__field(	__u64,	pright			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= ar->inode->i_sb->s_dev;
-		__entry->ino	= ar->inode->i_ino;
-		__entry->block	= block;
-		__entry->flags	= ar->flags;
-		__entry->len	= ar->len;
-		__entry->logical = ar->logical;
-		__entry->goal	= ar->goal;
-		__entry->lleft	= ar->lleft;
-		__entry->lright	= ar->lright;
-		__entry->pleft	= ar->pleft;
-		__entry->pright	= ar->pright;
-	),
-
-	TP_printk("dev %d,%d ino %lu flags %u len %u block %llu lblk %u "
-		  "goal %llu lleft %u lright %u pleft %llu pright %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->flags,
-		  __entry->len, __entry->block, __entry->logical,
-		  __entry->goal,  __entry->lleft, __entry->lright,
-		  __entry->pleft, __entry->pright)
-);
-
-TRACE_EVENT(ext4_free_blocks,
-	TP_PROTO(struct inode *inode, __u64 block, unsigned long count,
-		 int flags),
-
-	TP_ARGS(inode, block, count, flags),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	__u64,	block			)
-		__field(	unsigned long,	count		)
-		__field(	int,	flags			)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->mode		= inode->i_mode;
-		__entry->block		= block;
-		__entry->count		= count;
-		__entry->flags		= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o block %llu count %lu flags %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->block, __entry->count,
-		  __entry->flags)
-);
-
-TRACE_EVENT(ext4_sync_file_enter,
-	TP_PROTO(struct file *file, int datasync),
-
-	TP_ARGS(file, datasync),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	ino_t,	parent			)
-		__field(	int,	datasync		)
-	),
-
-	TP_fast_assign(
-		struct dentry *dentry = file->f_path.dentry;
-
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->datasync	= datasync;
-		__entry->parent		= dentry->d_parent->d_inode->i_ino;
-	),
-
-	TP_printk("dev %d,%d ino %lu parent %lu datasync %d ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->parent, __entry->datasync)
-);
-
-TRACE_EVENT(ext4_sync_file_exit,
-	TP_PROTO(struct inode *inode, int ret),
-
-	TP_ARGS(inode, ret),
-
-	TP_STRUCT__entry(
-		__field(	int,	ret			)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-	),
-
-	TP_fast_assign(
-		__entry->ret		= ret;
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->ret)
-);
-
-TRACE_EVENT(ext4_sync_fs,
-	TP_PROTO(struct super_block *sb, int wait),
-
-	TP_ARGS(sb, wait),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	int,	wait			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->wait	= wait;
-	),
-
-	TP_printk("dev %d,%d wait %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->wait)
-);
-
-TRACE_EVENT(ext4_alloc_da_blocks,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field( unsigned int,	data_blocks	)
-		__field( unsigned int,	meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu data_blocks %u meta_blocks %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->data_blocks, __entry->meta_blocks)
-);
-
-TRACE_EVENT(ext4_mballoc_alloc,
-	TP_PROTO(struct ext4_allocation_context *ac),
-
-	TP_ARGS(ac),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	found			)
-		__field(	__u16,	groups			)
-		__field(	__u16,	buddy			)
-		__field(	__u16,	flags			)
-		__field(	__u16,	tail			)
-		__field(	__u8,	cr			)
-		__field(	__u32, 	orig_logical		)
-		__field(	  int,	orig_start		)
-		__field(	__u32, 	orig_group		)
-		__field(	  int,	orig_len		)
-		__field(	__u32, 	goal_logical		)
-		__field(	  int,	goal_start		)
-		__field(	__u32, 	goal_group		)
-		__field(	  int,	goal_len		)
-		__field(	__u32, 	result_logical		)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_inode->i_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->found		= ac->ac_found;
-		__entry->flags		= ac->ac_flags;
-		__entry->groups		= ac->ac_groups_scanned;
-		__entry->buddy		= ac->ac_buddy;
-		__entry->tail		= ac->ac_tail;
-		__entry->cr		= ac->ac_criteria;
-		__entry->orig_logical	= ac->ac_o_ex.fe_logical;
-		__entry->orig_start	= ac->ac_o_ex.fe_start;
-		__entry->orig_group	= ac->ac_o_ex.fe_group;
-		__entry->orig_len	= ac->ac_o_ex.fe_len;
-		__entry->goal_logical	= ac->ac_g_ex.fe_logical;
-		__entry->goal_start	= ac->ac_g_ex.fe_start;
-		__entry->goal_group	= ac->ac_g_ex.fe_group;
-		__entry->goal_len	= ac->ac_g_ex.fe_len;
-		__entry->result_logical	= ac->ac_f_ex.fe_logical;
-		__entry->result_start	= ac->ac_f_ex.fe_start;
-		__entry->result_group	= ac->ac_f_ex.fe_group;
-		__entry->result_len	= ac->ac_f_ex.fe_len;
-	),
-
-	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u "
-		  "result %u/%d/%u@%u blks %u grps %u cr %u flags 0x%04x "
-		  "tail %u broken %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->orig_group, __entry->orig_start,
-		  __entry->orig_len, __entry->orig_logical,
-		  __entry->goal_group, __entry->goal_start,
-		  __entry->goal_len, __entry->goal_logical,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len, __entry->result_logical,
-		  __entry->found, __entry->groups, __entry->cr,
-		  __entry->flags, __entry->tail,
-		  __entry->buddy ? 1 << __entry->buddy : 0)
-);
-
-TRACE_EVENT(ext4_mballoc_prealloc,
-	TP_PROTO(struct ext4_allocation_context *ac),
-
-	TP_ARGS(ac),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u32, 	orig_logical		)
-		__field(	  int,	orig_start		)
-		__field(	__u32, 	orig_group		)
-		__field(	  int,	orig_len		)
-		__field(	__u32, 	result_logical		)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_inode->i_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->orig_logical	= ac->ac_o_ex.fe_logical;
-		__entry->orig_start	= ac->ac_o_ex.fe_start;
-		__entry->orig_group	= ac->ac_o_ex.fe_group;
-		__entry->orig_len	= ac->ac_o_ex.fe_len;
-		__entry->result_logical	= ac->ac_b_ex.fe_logical;
-		__entry->result_start	= ac->ac_b_ex.fe_start;
-		__entry->result_group	= ac->ac_b_ex.fe_group;
-		__entry->result_len	= ac->ac_b_ex.fe_len;
-	),
-
-	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->orig_group, __entry->orig_start,
-		  __entry->orig_len, __entry->orig_logical,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len, __entry->result_logical)
-);
-
-DECLARE_EVENT_CLASS(ext4__mballoc,
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= sb->s_dev;
-		__entry->ino		= inode ? inode->i_ino : 0;
-		__entry->result_start	= start;
-		__entry->result_group	= group;
-		__entry->result_len	= len;
-	),
-
-	TP_printk("dev %d,%d inode %lu extent %u/%d/%d ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len)
-);
-
-DEFINE_EVENT(ext4__mballoc, ext4_mballoc_discard,
-
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len)
-);
-
-DEFINE_EVENT(ext4__mballoc, ext4_mballoc_free,
-
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len)
-);
-
-TRACE_EVENT(ext4_forget,
-	TP_PROTO(struct inode *inode, int is_metadata, __u64 block),
-
-	TP_ARGS(inode, is_metadata, block),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	int,	is_metadata		)
-		__field(	__u64,	block			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->is_metadata = is_metadata;
-		__entry->block	= block;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o is_metadata %d block %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->is_metadata, __entry->block)
-);
-
-TRACE_EVENT(ext4_da_update_reserve_space,
-	TP_PROTO(struct inode *inode, int used_blocks, int quota_claim),
-
-	TP_ARGS(inode, used_blocks, quota_claim),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	used_blocks		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-		__field(	int,	allocated_meta_blocks	)
-		__field(	int,	quota_claim		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->used_blocks = used_blocks;
-		__entry->reserved_data_blocks =
-				EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks =
-				EXT4_I(inode)->i_reserved_meta_blocks;
-		__entry->allocated_meta_blocks =
-				EXT4_I(inode)->i_allocated_meta_blocks;
-		__entry->quota_claim = quota_claim;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu used_blocks %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d "
-		  "allocated_meta_blocks %d quota_claim %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->used_blocks, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks, __entry->allocated_meta_blocks,
-		  __entry->quota_claim)
-);
-
-TRACE_EVENT(ext4_da_reserve_space,
-	TP_PROTO(struct inode *inode, int md_needed),
-
-	TP_ARGS(inode, md_needed),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,  mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	md_needed		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->md_needed = md_needed;
-		__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu md_needed %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->md_needed, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks)
-);
-
-TRACE_EVENT(ext4_da_release_space,
-	TP_PROTO(struct inode *inode, int freed_blocks),
-
-	TP_ARGS(inode, freed_blocks),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,  mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	freed_blocks		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-		__field(	int,	allocated_meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->freed_blocks = freed_blocks;
-		__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-		__entry->allocated_meta_blocks = EXT4_I(inode)->i_allocated_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu freed_blocks %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d "
-		  "allocated_meta_blocks %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->freed_blocks, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks, __entry->allocated_meta_blocks)
-);
-
-DECLARE_EVENT_CLASS(ext4__bitmap_load,
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u32,	group			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->group	= group;
-	),
-
-	TP_printk("dev %d,%d group %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_mb_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_mb_buddy_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_read_block_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_load_inode_bitmap,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-TRACE_EVENT(ext4_direct_IO_enter,
-	TP_PROTO(struct inode *inode, loff_t offset, unsigned long len, int rw),
-
-	TP_ARGS(inode, offset, len, rw),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned long,	len		)
-		__field(	int,	rw			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->rw	= rw;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lu rw %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->rw)
-);
-
-TRACE_EVENT(ext4_direct_IO_exit,
-	TP_PROTO(struct inode *inode, loff_t offset, unsigned long len,
-		 int rw, int ret),
-
-	TP_ARGS(inode, offset, len, rw, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned long,	len		)
-		__field(	int,	rw			)
-		__field(	int,	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->rw	= rw;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lu rw %d ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len,
-		  __entry->rw, __entry->ret)
-);
-
-TRACE_EVENT(ext4_fallocate_enter,
-	TP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),
-
-	TP_ARGS(inode, offset, len, mode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	loff_t,	len			)
-		__field(	int,	mode			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lld mode %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->pos,
-		  __entry->len, __entry->mode)
-);
-
-TRACE_EVENT(ext4_fallocate_exit,
-	TP_PROTO(struct inode *inode, loff_t offset,
-		 unsigned int max_blocks, int ret),
-
-	TP_ARGS(inode, offset, max_blocks, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int,	blocks		)
-		__field(	int, 	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->blocks	= max_blocks;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld blocks %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->blocks,
-		  __entry->ret)
-);
-
-TRACE_EVENT(ext4_unlink_enter,
-	TP_PROTO(struct inode *parent, struct dentry *dentry),
-
-	TP_ARGS(parent, dentry),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	parent			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	size			)
-		__field(	dev_t,	dev			)
-	),
-
-	TP_fast_assign(
-		__entry->parent		= parent->i_ino;
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->size		= dentry->d_inode->i_size;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu size %lld parent %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->size,
-		  (unsigned long) __entry->parent)
-);
-
-TRACE_EVENT(ext4_unlink_exit,
-	TP_PROTO(struct dentry *dentry, int ret),
-
-	TP_ARGS(dentry, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	int,	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ret		= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->ret)
-);
-
-DECLARE_EVENT_CLASS(ext4__truncate,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,  	ino		)
-		__field(	dev_t,  	dev		)
-		__field(	__u64,		blocks		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->blocks	= inode->i_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu blocks %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->blocks)
-);
-
-DEFINE_EVENT(ext4__truncate, ext4_truncate_enter,
-
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode)
-);
-
-DEFINE_EVENT(ext4__truncate, ext4_truncate_exit,
-
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode)
-);
-
-/* 'ux' is the uninitialized extent. */
-TRACE_EVENT(ext4_ext_convert_to_initialized_enter,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 struct ext4_extent *ux),
-
-	TP_ARGS(inode, map, ux),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	m_lblk	)
-		__field(	unsigned,	m_len	)
-		__field(	ext4_lblk_t,	u_lblk	)
-		__field(	unsigned,	u_len	)
-		__field(	ext4_fsblk_t,	u_pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->m_lblk		= map->m_lblk;
-		__entry->m_len		= map->m_len;
-		__entry->u_lblk		= le32_to_cpu(ux->ee_block);
-		__entry->u_len		= ext4_ext_get_actual_len(ux);
-		__entry->u_pblk		= ext4_ext_pblock(ux);
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_len %u u_lblk %u u_len %u "
-		  "u_pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->m_lblk, __entry->m_len,
-		  __entry->u_lblk, __entry->u_len, __entry->u_pblk)
-);
-
-/*
- * 'ux' is the uninitialized extent.
- * 'ix' is the initialized extent to which blocks are transferred.
- */
-TRACE_EVENT(ext4_ext_convert_to_initialized_fastpath,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 struct ext4_extent *ux, struct ext4_extent *ix),
-
-	TP_ARGS(inode, map, ux, ix),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	m_lblk	)
-		__field(	unsigned,	m_len	)
-		__field(	ext4_lblk_t,	u_lblk	)
-		__field(	unsigned,	u_len	)
-		__field(	ext4_fsblk_t,	u_pblk	)
-		__field(	ext4_lblk_t,	i_lblk	)
-		__field(	unsigned,	i_len	)
-		__field(	ext4_fsblk_t,	i_pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->m_lblk		= map->m_lblk;
-		__entry->m_len		= map->m_len;
-		__entry->u_lblk		= le32_to_cpu(ux->ee_block);
-		__entry->u_len		= ext4_ext_get_actual_len(ux);
-		__entry->u_pblk		= ext4_ext_pblock(ux);
-		__entry->i_lblk		= le32_to_cpu(ix->ee_block);
-		__entry->i_len		= ext4_ext_get_actual_len(ix);
-		__entry->i_pblk		= ext4_ext_pblock(ix);
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_len %u "
-		  "u_lblk %u u_len %u u_pblk %llu "
-		  "i_lblk %u i_len %u i_pblk %llu ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->m_lblk, __entry->m_len,
-		  __entry->u_lblk, __entry->u_len, __entry->u_pblk,
-		  __entry->i_lblk, __entry->i_len, __entry->i_pblk)
-);
-
-DECLARE_EVENT_CLASS(ext4__map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned int len, unsigned int flags),
-
-	TP_ARGS(inode, lblk, len, flags),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,  	ino		)
-		__field(	dev_t,  	dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	unsigned int,	len		)
-		__field(	unsigned int,	flags		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-		__entry->flags	= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u flags %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->len, __entry->flags)
-);
-
-DEFINE_EVENT(ext4__map_blocks_enter, ext4_ext_map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned len, unsigned flags),
-
-	TP_ARGS(inode, lblk, len, flags)
-);
-
-DEFINE_EVENT(ext4__map_blocks_enter, ext4_ind_map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned len, unsigned flags),
-
-	TP_ARGS(inode, lblk, len, flags)
-);
-
-DECLARE_EVENT_CLASS(ext4__map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned int len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-		__field(	unsigned int,	len		)
-		__field(	int,		ret		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-		__entry->len	= len;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu len %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->pblk,
-		  __entry->len, __entry->ret)
-);
-
-DEFINE_EVENT(ext4__map_blocks_exit, ext4_ext_map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret)
-);
-
-DEFINE_EVENT(ext4__map_blocks_exit, ext4_ind_map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret)
-);
-
-TRACE_EVENT(ext4_ext_load_extent,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk),
-
-	TP_ARGS(inode, lblk, pblk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->pblk)
-);
-
-TRACE_EVENT(ext4_load_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino		)
-		__field(	dev_t,	dev		)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %ld",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino)
-);
-
-TRACE_EVENT(ext4_journal_start,
-	TP_PROTO(struct super_block *sb, int nblocks, unsigned long IP),
-
-	TP_ARGS(sb, nblocks, IP),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	  int, 	nblocks			)
-		__field(unsigned long,	ip			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	 = sb->s_dev;
-		__entry->nblocks = nblocks;
-		__entry->ip	 = IP;
-	),
-
-	TP_printk("dev %d,%d nblocks %d caller %pF",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->nblocks, (void *)__entry->ip)
-);
-
-DECLARE_EVENT_CLASS(ext4__trim,
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len),
-
-	TP_STRUCT__entry(
-		__field(	int,	dev_major		)
-		__field(	int,	dev_minor		)
-		__field(	__u32, 	group			)
-		__field(	int,	start			)
-		__field(	int,	len			)
-	),
-
-	TP_fast_assign(
-		__entry->dev_major	= MAJOR(sb->s_dev);
-		__entry->dev_minor	= MINOR(sb->s_dev);
-		__entry->group		= group;
-		__entry->start		= start;
-		__entry->len		= len;
-	),
-
-	TP_printk("dev %d,%d group %u, start %d, len %d",
-		  __entry->dev_major, __entry->dev_minor,
-		  __entry->group, __entry->start, __entry->len)
-);
-
-DEFINE_EVENT(ext4__trim, ext4_trim_extent,
-
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len)
-);
-
-DEFINE_EVENT(ext4__trim, ext4_trim_all_free,
-
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len)
-);
-
-TRACE_EVENT(ext4_ext_handle_uninitialized_extents,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 unsigned int allocated, ext4_fsblk_t newblock),
-
-	TP_ARGS(inode, map, allocated, newblock),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-		__field(	unsigned int,	len		)
-		__field(	int,		flags		)
-		__field(	unsigned int,	allocated	)
-		__field(	ext4_fsblk_t,	newblk		)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->lblk		= map->m_lblk;
-		__entry->pblk		= map->m_pblk;
-		__entry->len		= map->m_len;
-		__entry->flags		= map->m_flags;
-		__entry->allocated	= allocated;
-		__entry->newblk		= newblock;
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_pblk %llu m_len %u flags %d"
-		  "allocated %d newblock %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk, (unsigned long long) __entry->pblk,
-		  __entry->len, __entry->flags,
-		  (unsigned int) __entry->allocated,
-		  (unsigned long long) __entry->newblk)
-);
-
-TRACE_EVENT(ext4_get_implied_cluster_alloc_exit,
-	TP_PROTO(struct super_block *sb, struct ext4_map_blocks *map, int ret),
-
-	TP_ARGS(sb, map, ret),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	ext4_fsblk_t,	pblk	)
-		__field(	unsigned int,	len	)
-		__field(	unsigned int,	flags	)
-		__field(	int,		ret	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->lblk	= map->m_lblk;
-		__entry->pblk	= map->m_pblk;
-		__entry->len	= map->m_len;
-		__entry->flags	= map->m_flags;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d m_lblk %u m_pblk %llu m_len %u m_flags %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->lblk, (unsigned long long) __entry->pblk,
-		  __entry->len, __entry->flags, __entry->ret)
-);
-
-TRACE_EVENT(ext4_ext_put_in_cache,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len,
-		 ext4_fsblk_t start),
-
-	TP_ARGS(inode, lblk, len, start),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	unsigned int,	len	)
-		__field(	ext4_fsblk_t,	start	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-		__entry->start	= start;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u start %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->len,
-		  (unsigned long long) __entry->start)
-);
-
-TRACE_EVENT(ext4_ext_in_cache,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, int ret),
-
-	TP_ARGS(inode, lblk, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	int,		ret	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->ret)
-
-);
-
-TRACE_EVENT(ext4_find_delalloc_range,
-	TP_PROTO(struct inode *inode, ext4_lblk_t from, ext4_lblk_t to,
-		int reverse, int found, ext4_lblk_t found_blk),
-
-	TP_ARGS(inode, from, to, reverse, found, found_blk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	from		)
-		__field(	ext4_lblk_t,	to		)
-		__field(	int,		reverse		)
-		__field(	int,		found		)
-		__field(	ext4_lblk_t,	found_blk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->from		= from;
-		__entry->to		= to;
-		__entry->reverse	= reverse;
-		__entry->found		= found;
-		__entry->found_blk	= found_blk;
-	),
-
-	TP_printk("dev %d,%d ino %lu from %u to %u reverse %d found %d "
-		  "(blk = %u)",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->from, (unsigned) __entry->to,
-		  __entry->reverse, __entry->found,
-		  (unsigned) __entry->found_blk)
-);
-
-TRACE_EVENT(ext4_get_reserved_cluster_alloc,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len),
-
-	TP_ARGS(inode, lblk, len),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	unsigned int,	len	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->len)
-);
-
-TRACE_EVENT(ext4_ext_show_extent,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,
-		 unsigned short len),
-
-	TP_ARGS(inode, lblk, pblk, len),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	ext4_fsblk_t,	pblk	)
-		__field(	unsigned short,	len	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-		__entry->len	= len;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  (unsigned long long) __entry->pblk,
-		  (unsigned short) __entry->len)
-);
-
-TRACE_EVENT(ext4_remove_blocks,
-	    TP_PROTO(struct inode *inode, struct ext4_extent *ex,
-		ext4_lblk_t from, ext4_fsblk_t to,
-		ext4_fsblk_t partial_cluster),
-
-	TP_ARGS(inode, ex, from, to, partial_cluster),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	ee_lblk	)
-		__field(	ext4_fsblk_t,	ee_pblk	)
-		__field(	unsigned short,	ee_len	)
-		__field(	ext4_lblk_t,	from	)
-		__field(	ext4_lblk_t,	to	)
-		__field(	ext4_fsblk_t,	partial	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ee_lblk	= cpu_to_le32(ex->ee_block);
-		__entry->ee_pblk	= ext4_ext_pblock(ex);
-		__entry->ee_len		= ext4_ext_get_actual_len(ex);
-		__entry->from		= from;
-		__entry->to		= to;
-		__entry->partial	= partial_cluster;
-	),
-
-	TP_printk("dev %d,%d ino %lu extent [%u(%llu), %u]"
-		  "from %u to %u partial_cluster %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->ee_lblk,
-		  (unsigned long long) __entry->ee_pblk,
-		  (unsigned short) __entry->ee_len,
-		  (unsigned) __entry->from,
-		  (unsigned) __entry->to,
-		  (unsigned) __entry->partial)
-);
-
-TRACE_EVENT(ext4_ext_rm_leaf,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start,
-		 struct ext4_extent *ex, ext4_fsblk_t partial_cluster),
-
-	TP_ARGS(inode, start, ex, partial_cluster),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	start	)
-		__field(	ext4_lblk_t,	ee_lblk	)
-		__field(	ext4_fsblk_t,	ee_pblk	)
-		__field(	short,		ee_len	)
-		__field(	ext4_fsblk_t,	partial	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->start		= start;
-		__entry->ee_lblk	= le32_to_cpu(ex->ee_block);
-		__entry->ee_pblk	= ext4_ext_pblock(ex);
-		__entry->ee_len		= ext4_ext_get_actual_len(ex);
-		__entry->partial	= partial_cluster;
-	),
-
-	TP_printk("dev %d,%d ino %lu start_lblk %u last_extent [%u(%llu), %u]"
-		  "partial_cluster %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  (unsigned) __entry->ee_lblk,
-		  (unsigned long long) __entry->ee_pblk,
-		  (unsigned short) __entry->ee_len,
-		  (unsigned) __entry->partial)
-);
-
-TRACE_EVENT(ext4_ext_rm_idx,
-	TP_PROTO(struct inode *inode, ext4_fsblk_t pblk),
-
-	TP_ARGS(inode, pblk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_fsblk_t,	pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pblk	= pblk;
-	),
-
-	TP_printk("dev %d,%d ino %lu index_pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long long) __entry->pblk)
-);
-
-TRACE_EVENT(ext4_ext_remove_space,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start, int depth),
-
-	TP_ARGS(inode, start, depth),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	start	)
-		__field(	int,		depth	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->start	= start;
-		__entry->depth	= depth;
-	),
-
-	TP_printk("dev %d,%d ino %lu since %u depth %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  __entry->depth)
-);
-
-TRACE_EVENT(ext4_ext_remove_space_done,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start, int depth,
-		ext4_lblk_t partial, unsigned short eh_entries),
-
-	TP_ARGS(inode, start, depth, partial, eh_entries),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	start		)
-		__field(	int,		depth		)
-		__field(	ext4_lblk_t,	partial		)
-		__field(	unsigned short,	eh_entries	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->start		= start;
-		__entry->depth		= depth;
-		__entry->partial	= partial;
-		__entry->eh_entries	= eh_entries;
-	),
-
-	TP_printk("dev %d,%d ino %lu since %u depth %d partial %u "
-		  "remaining_entries %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  __entry->depth,
-		  (unsigned) __entry->partial,
-		  (unsigned short) __entry->eh_entries)
-);
-
-#endif /* _TRACE_EXT4_H */
-
-/* This part must be outside protection */
-#include <trace/define_trace.h>
diff -urN flo-ElementalX-5.00/kernel/sysctl_binary.c flo-ElementalX-5.00-patched/kernel/sysctl_binary.c
--- flo-ElementalX-5.00/kernel/sysctl_binary.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/kernel/sysctl_binary.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,1520 +0,0 @@
-#include <linux/stat.h>
-#include <linux/sysctl.h>
-#include "../fs/xfs/xfs_sysctl.h"
-#include <linux/sunrpc/debug.h>
-#include <linux/string.h>
-#include <net/ip_vs.h>
-#include <linux/syscalls.h>
-#include <linux/namei.h>
-#include <linux/mount.h>
-#include <linux/fs.h>
-#include <linux/nsproxy.h>
-#include <linux/pid_namespace.h>
-#include <linux/file.h>
-#include <linux/ctype.h>
-#include <linux/netdevice.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-
-#ifdef CONFIG_SYSCTL_SYSCALL
-
-struct bin_table;
-typedef ssize_t bin_convert_t(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen);
-
-static bin_convert_t bin_dir;
-static bin_convert_t bin_string;
-static bin_convert_t bin_intvec;
-static bin_convert_t bin_ulongvec;
-static bin_convert_t bin_uuid;
-static bin_convert_t bin_dn_node_address;
-
-#define CTL_DIR   bin_dir
-#define CTL_STR   bin_string
-#define CTL_INT   bin_intvec
-#define CTL_ULONG bin_ulongvec
-#define CTL_UUID  bin_uuid
-#define CTL_DNADR bin_dn_node_address
-
-#define BUFSZ 256
-
-struct bin_table {
-	bin_convert_t		*convert;
-	int			ctl_name;
-	const char		*procname;
-	const struct bin_table	*child;
-};
-
-static const struct bin_table bin_random_table[] = {
-	{ CTL_INT,	RANDOM_POOLSIZE,	"poolsize" },
-	{ CTL_INT,	RANDOM_ENTROPY_COUNT,	"entropy_avail" },
-	{ CTL_INT,	RANDOM_READ_THRESH,	"read_wakeup_threshold" },
-	{ CTL_INT,	RANDOM_WRITE_THRESH,	"write_wakeup_threshold" },
-	{ CTL_UUID,	RANDOM_BOOT_ID,		"boot_id" },
-	{ CTL_UUID,	RANDOM_UUID,		"uuid" },
-	{}
-};
-
-static const struct bin_table bin_pty_table[] = {
-	{ CTL_INT,	PTY_MAX,	"max" },
-	{ CTL_INT,	PTY_NR,		"nr" },
-	{}
-};
-
-static const struct bin_table bin_kern_table[] = {
-	{ CTL_STR,	KERN_OSTYPE,			"ostype" },
-	{ CTL_STR,	KERN_OSRELEASE,			"osrelease" },
-	/* KERN_OSREV not used */
-	{ CTL_STR,	KERN_VERSION,			"version" },
-	/* KERN_SECUREMASK not used */
-	/* KERN_PROF not used */
-	{ CTL_STR,	KERN_NODENAME,			"hostname" },
-	{ CTL_STR,	KERN_DOMAINNAME,		"domainname" },
-
-	{ CTL_INT,	KERN_PANIC,			"panic" },
-	{ CTL_INT,	KERN_REALROOTDEV,		"real-root-dev" },
-
-	{ CTL_STR,	KERN_SPARC_REBOOT,		"reboot-cmd" },
-	{ CTL_INT,	KERN_CTLALTDEL,			"ctrl-alt-del" },
-	{ CTL_INT,	KERN_PRINTK,			"printk" },
-
-	/* KERN_NAMETRANS not used */
-	/* KERN_PPC_HTABRECLAIM not used */
-	/* KERN_PPC_ZEROPAGED not used */
-	{ CTL_INT,	KERN_PPC_POWERSAVE_NAP,		"powersave-nap" },
-
-	{ CTL_STR,	KERN_MODPROBE,			"modprobe" },
-	{ CTL_INT,	KERN_SG_BIG_BUFF,		"sg-big-buff" },
-	{ CTL_INT,	KERN_ACCT,			"acct" },
-	/* KERN_PPC_L2CR "l2cr" no longer used */
-
-	/* KERN_RTSIGNR not used */
-	/* KERN_RTSIGMAX not used */
-
-	{ CTL_ULONG,	KERN_SHMMAX,			"shmmax" },
-	{ CTL_INT,	KERN_MSGMAX,			"msgmax" },
-	{ CTL_INT,	KERN_MSGMNB,			"msgmnb" },
-	/* KERN_MSGPOOL not used*/
-	{ CTL_INT,	KERN_SYSRQ,			"sysrq" },
-	{ CTL_INT,	KERN_MAX_THREADS,		"threads-max" },
-	{ CTL_DIR,	KERN_RANDOM,			"random",	bin_random_table },
-	{ CTL_ULONG,	KERN_SHMALL,			"shmall" },
-	{ CTL_INT,	KERN_MSGMNI,			"msgmni" },
-	{ CTL_INT,	KERN_SEM,			"sem" },
-	{ CTL_INT,	KERN_SPARC_STOP_A,		"stop-a" },
-	{ CTL_INT,	KERN_SHMMNI,			"shmmni" },
-
-	{ CTL_INT,	KERN_OVERFLOWUID,		"overflowuid" },
-	{ CTL_INT,	KERN_OVERFLOWGID,		"overflowgid" },
-
-	{ CTL_STR,	KERN_HOTPLUG,			"hotplug", },
-	{ CTL_INT,	KERN_IEEE_EMULATION_WARNINGS,	"ieee_emulation_warnings" },
-
-	{ CTL_INT,	KERN_S390_USER_DEBUG_LOGGING,	"userprocess_debug" },
-	{ CTL_INT,	KERN_CORE_USES_PID,		"core_uses_pid" },
-	/* KERN_TAINTED "tainted" no longer used */
-	{ CTL_INT,	KERN_CADPID,			"cad_pid" },
-	{ CTL_INT,	KERN_PIDMAX,			"pid_max" },
-	{ CTL_STR,	KERN_CORE_PATTERN,		"core_pattern" },
-	{ CTL_INT,	KERN_PANIC_ON_OOPS,		"panic_on_oops" },
-	{ CTL_INT,	KERN_HPPA_PWRSW,		"soft-power" },
-	{ CTL_INT,	KERN_HPPA_UNALIGNED,		"unaligned-trap" },
-
-	{ CTL_INT,	KERN_PRINTK_RATELIMIT,		"printk_ratelimit" },
-	{ CTL_INT,	KERN_PRINTK_RATELIMIT_BURST,	"printk_ratelimit_burst" },
-
-	{ CTL_DIR,	KERN_PTY,			"pty",		bin_pty_table },
-	{ CTL_INT,	KERN_NGROUPS_MAX,		"ngroups_max" },
-	{ CTL_INT,	KERN_SPARC_SCONS_PWROFF,	"scons-poweroff" },
-	/* KERN_HZ_TIMER "hz_timer" no longer used */
-	{ CTL_INT,	KERN_UNKNOWN_NMI_PANIC,		"unknown_nmi_panic" },
-	{ CTL_INT,	KERN_BOOTLOADER_TYPE,		"bootloader_type" },
-	{ CTL_INT,	KERN_RANDOMIZE,			"randomize_va_space" },
-
-	{ CTL_INT,	KERN_SPIN_RETRY,		"spin_retry" },
-	/* KERN_ACPI_VIDEO_FLAGS "acpi_video_flags" no longer used */
-	{ CTL_INT,	KERN_IA64_UNALIGNED,		"ignore-unaligned-usertrap" },
-	{ CTL_INT,	KERN_COMPAT_LOG,		"compat-log" },
-	{ CTL_INT,	KERN_MAX_LOCK_DEPTH,		"max_lock_depth" },
-	{ CTL_INT,	KERN_PANIC_ON_NMI,		"panic_on_unrecovered_nmi" },
-	{ CTL_INT,	KERN_BOOT_REASON,		"boot_reason" },
-	{}
-};
-
-static const struct bin_table bin_vm_table[] = {
-	{ CTL_INT,	VM_OVERCOMMIT_MEMORY,		"overcommit_memory" },
-	{ CTL_INT,	VM_PAGE_CLUSTER,		"page-cluster" },
-	{ CTL_INT,	VM_DIRTY_BACKGROUND,		"dirty_background_ratio" },
-	{ CTL_INT,	VM_DIRTY_RATIO,			"dirty_ratio" },
-	/* VM_DIRTY_WB_CS "dirty_writeback_centisecs" no longer used */
-	/* VM_DIRTY_EXPIRE_CS "dirty_expire_centisecs" no longer used */
-	{ CTL_INT,	VM_NR_PDFLUSH_THREADS,		"nr_pdflush_threads" },
-	{ CTL_INT,	VM_OVERCOMMIT_RATIO,		"overcommit_ratio" },
-	/* VM_PAGEBUF unused */
-	/* VM_HUGETLB_PAGES "nr_hugepages" no longer used */
-	{ CTL_INT,	VM_SWAPPINESS,			"swappiness" },
-	{ CTL_INT,	VM_LOWMEM_RESERVE_RATIO,	"lowmem_reserve_ratio" },
-	{ CTL_INT,	VM_MIN_FREE_KBYTES,		"min_free_kbytes" },
-	{ CTL_INT,	VM_MAX_MAP_COUNT,		"max_map_count" },
-	{ CTL_INT,	VM_LAPTOP_MODE,			"laptop_mode" },
-	{ CTL_INT,	VM_BLOCK_DUMP,			"block_dump" },
-	{ CTL_INT,	VM_HUGETLB_GROUP,		"hugetlb_shm_group" },
-	{ CTL_INT,	VM_VFS_CACHE_PRESSURE,	"vfs_cache_pressure" },
-	{ CTL_INT,	VM_LEGACY_VA_LAYOUT,		"legacy_va_layout" },
-	/* VM_SWAP_TOKEN_TIMEOUT unused */
-	{ CTL_INT,	VM_DROP_PAGECACHE,		"drop_caches" },
-	{ CTL_INT,	VM_PERCPU_PAGELIST_FRACTION,	"percpu_pagelist_fraction" },
-	{ CTL_INT,	VM_ZONE_RECLAIM_MODE,		"zone_reclaim_mode" },
-	{ CTL_INT,	VM_MIN_UNMAPPED,		"min_unmapped_ratio" },
-	{ CTL_INT,	VM_PANIC_ON_OOM,		"panic_on_oom" },
-	{ CTL_INT,	VM_VDSO_ENABLED,		"vdso_enabled" },
-	{ CTL_INT,	VM_MIN_SLAB,			"min_slab_ratio" },
-
-	{}
-};
-
-static const struct bin_table bin_net_core_table[] = {
-	{ CTL_INT,	NET_CORE_WMEM_MAX,	"wmem_max" },
-	{ CTL_INT,	NET_CORE_RMEM_MAX,	"rmem_max" },
-	{ CTL_INT,	NET_CORE_WMEM_DEFAULT,	"wmem_default" },
-	{ CTL_INT,	NET_CORE_RMEM_DEFAULT,	"rmem_default" },
-	/* NET_CORE_DESTROY_DELAY unused */
-	{ CTL_INT,	NET_CORE_MAX_BACKLOG,	"netdev_max_backlog" },
-	/* NET_CORE_FASTROUTE unused */
-	{ CTL_INT,	NET_CORE_MSG_COST,	"message_cost" },
-	{ CTL_INT,	NET_CORE_MSG_BURST,	"message_burst" },
-	{ CTL_INT,	NET_CORE_OPTMEM_MAX,	"optmem_max" },
-	/* NET_CORE_HOT_LIST_LENGTH unused */
-	/* NET_CORE_DIVERT_VERSION unused */
-	/* NET_CORE_NO_CONG_THRESH unused */
-	/* NET_CORE_NO_CONG unused */
-	/* NET_CORE_LO_CONG unused */
-	/* NET_CORE_MOD_CONG unused */
-	{ CTL_INT,	NET_CORE_DEV_WEIGHT,	"dev_weight" },
-	{ CTL_INT,	NET_CORE_SOMAXCONN,	"somaxconn" },
-	{ CTL_INT,	NET_CORE_BUDGET,	"netdev_budget" },
-	{ CTL_INT,	NET_CORE_AEVENT_ETIME,	"xfrm_aevent_etime" },
-	{ CTL_INT,	NET_CORE_AEVENT_RSEQTH,	"xfrm_aevent_rseqth" },
-	{ CTL_INT,	NET_CORE_WARNINGS,	"warnings" },
-	{},
-};
-
-static const struct bin_table bin_net_unix_table[] = {
-	/* NET_UNIX_DESTROY_DELAY unused */
-	/* NET_UNIX_DELETE_DELAY unused */
-	{ CTL_INT,	NET_UNIX_MAX_DGRAM_QLEN,	"max_dgram_qlen" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_route_table[] = {
-	{ CTL_INT,	NET_IPV4_ROUTE_FLUSH,			"flush" },
-	/* NET_IPV4_ROUTE_MIN_DELAY "min_delay" no longer used */
-	/* NET_IPV4_ROUTE_MAX_DELAY "max_delay" no longer used */
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_THRESH,		"gc_thresh" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MAX_SIZE,		"max_size" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_MIN_INTERVAL,		"gc_min_interval" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS,	"gc_min_interval_ms" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_TIMEOUT,		"gc_timeout" },
-	/* NET_IPV4_ROUTE_GC_INTERVAL "gc_interval" no longer used */
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_LOAD,		"redirect_load" },
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_NUMBER,		"redirect_number" },
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_SILENCE,	"redirect_silence" },
-	{ CTL_INT,	NET_IPV4_ROUTE_ERROR_COST,		"error_cost" },
-	{ CTL_INT,	NET_IPV4_ROUTE_ERROR_BURST,		"error_burst" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_ELASTICITY,		"gc_elasticity" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MTU_EXPIRES,		"mtu_expires" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MIN_PMTU,		"min_pmtu" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MIN_ADVMSS,		"min_adv_mss" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_conf_vars_table[] = {
-	{ CTL_INT,	NET_IPV4_CONF_FORWARDING,		"forwarding" },
-	{ CTL_INT,	NET_IPV4_CONF_MC_FORWARDING,		"mc_forwarding" },
-
-	{ CTL_INT,	NET_IPV4_CONF_ACCEPT_REDIRECTS,		"accept_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SECURE_REDIRECTS,		"secure_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SEND_REDIRECTS,		"send_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SHARED_MEDIA,		"shared_media" },
-	{ CTL_INT,	NET_IPV4_CONF_RP_FILTER,		"rp_filter" },
-	{ CTL_INT,	NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE,	"accept_source_route" },
-	{ CTL_INT,	NET_IPV4_CONF_PROXY_ARP,		"proxy_arp" },
-	{ CTL_INT,	NET_IPV4_CONF_MEDIUM_ID,		"medium_id" },
-	{ CTL_INT,	NET_IPV4_CONF_BOOTP_RELAY,		"bootp_relay" },
-	{ CTL_INT,	NET_IPV4_CONF_LOG_MARTIANS,		"log_martians" },
-	{ CTL_INT,	NET_IPV4_CONF_TAG,			"tag" },
-	{ CTL_INT,	NET_IPV4_CONF_ARPFILTER,		"arp_filter" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_ANNOUNCE,		"arp_announce" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_IGNORE,		"arp_ignore" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_ACCEPT,		"arp_accept" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_NOTIFY,		"arp_notify" },
-
-	{ CTL_INT,	NET_IPV4_CONF_NOXFRM,			"disable_xfrm" },
-	{ CTL_INT,	NET_IPV4_CONF_NOPOLICY,			"disable_policy" },
-	{ CTL_INT,	NET_IPV4_CONF_FORCE_IGMP_VERSION,	"force_igmp_version" },
-	{ CTL_INT,	NET_IPV4_CONF_PROMOTE_SECONDARIES,	"promote_secondaries" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_conf_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_ALL,	"all",		bin_net_ipv4_conf_vars_table },
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT,	"default",	bin_net_ipv4_conf_vars_table },
-	{ CTL_DIR,	0, NULL, bin_net_ipv4_conf_vars_table },
-	{}
-};
-
-static const struct bin_table bin_net_neigh_vars_table[] = {
-	{ CTL_INT,	NET_NEIGH_MCAST_SOLICIT,	"mcast_solicit" },
-	{ CTL_INT,	NET_NEIGH_UCAST_SOLICIT,	"ucast_solicit" },
-	{ CTL_INT,	NET_NEIGH_APP_SOLICIT,		"app_solicit" },
-	/* NET_NEIGH_RETRANS_TIME "retrans_time" no longer used */
-	{ CTL_INT,	NET_NEIGH_REACHABLE_TIME,	"base_reachable_time" },
-	{ CTL_INT,	NET_NEIGH_DELAY_PROBE_TIME,	"delay_first_probe_time" },
-	{ CTL_INT,	NET_NEIGH_GC_STALE_TIME,	"gc_stale_time" },
-	{ CTL_INT,	NET_NEIGH_UNRES_QLEN,		"unres_qlen" },
-	{ CTL_INT,	NET_NEIGH_PROXY_QLEN,		"proxy_qlen" },
-	/* NET_NEIGH_ANYCAST_DELAY "anycast_delay" no longer used */
-	/* NET_NEIGH_PROXY_DELAY "proxy_delay" no longer used */
-	/* NET_NEIGH_LOCKTIME "locktime" no longer used */
-	{ CTL_INT,	NET_NEIGH_GC_INTERVAL,		"gc_interval" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH1,		"gc_thresh1" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH2,		"gc_thresh2" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH3,		"gc_thresh3" },
-	{ CTL_INT,	NET_NEIGH_RETRANS_TIME_MS,	"retrans_time_ms" },
-	{ CTL_INT,	NET_NEIGH_REACHABLE_TIME_MS,	"base_reachable_time_ms" },
-	{}
-};
-
-static const struct bin_table bin_net_neigh_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT, "default", bin_net_neigh_vars_table },
-	{ CTL_DIR,	0, NULL, bin_net_neigh_vars_table },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_netfilter_table[] = {
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_MAX,		"ip_conntrack_max" },
-
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT "ip_conntrack_tcp_timeout_syn_sent" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV "ip_conntrack_tcp_timeout_syn_recv" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED "ip_conntrack_tcp_timeout_established" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT "ip_conntrack_tcp_timeout_fin_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT	"ip_conntrack_tcp_timeout_close_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK "ip_conntrack_tcp_timeout_last_ack" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT "ip_conntrack_tcp_timeout_time_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE "ip_conntrack_tcp_timeout_close" no longer used */
-
-	/* NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT "ip_conntrack_udp_timeout" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM "ip_conntrack_udp_timeout_stream" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT "ip_conntrack_icmp_timeout" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT "ip_conntrack_generic_timeout" no longer used */
-
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_BUCKETS,		"ip_conntrack_buckets" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_LOG_INVALID,	"ip_conntrack_log_invalid" },
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS "ip_conntrack_tcp_timeout_max_retrans" no longer used */
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_LOOSE,	"ip_conntrack_tcp_loose" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL,	"ip_conntrack_tcp_be_liberal" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS,	"ip_conntrack_tcp_max_retrans" },
-
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED "ip_conntrack_sctp_timeout_closed" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT "ip_conntrack_sctp_timeout_cookie_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED "ip_conntrack_sctp_timeout_cookie_echoed" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED "ip_conntrack_sctp_timeout_established" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT "ip_conntrack_sctp_timeout_shutdown_sent" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD "ip_conntrack_sctp_timeout_shutdown_recd" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT "ip_conntrack_sctp_timeout_shutdown_ack_sent" no longer used */
-
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_COUNT,		"ip_conntrack_count" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_CHECKSUM,		"ip_conntrack_checksum" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_table[] = {
-	{CTL_INT,	NET_IPV4_FORWARD,			"ip_forward" },
-
-	{ CTL_DIR,	NET_IPV4_CONF,		"conf",		bin_net_ipv4_conf_table },
-	{ CTL_DIR,	NET_IPV4_NEIGH,		"neigh",	bin_net_neigh_table },
-	{ CTL_DIR,	NET_IPV4_ROUTE,		"route",	bin_net_ipv4_route_table },
-	/* NET_IPV4_FIB_HASH unused */
-	{ CTL_DIR,	NET_IPV4_NETFILTER,	"netfilter",	bin_net_ipv4_netfilter_table },
-
-	{ CTL_INT,	NET_IPV4_TCP_TIMESTAMPS,		"tcp_timestamps" },
-	{ CTL_INT,	NET_IPV4_TCP_WINDOW_SCALING,		"tcp_window_scaling" },
-	{ CTL_INT,	NET_IPV4_TCP_SACK,			"tcp_sack" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRANS_COLLAPSE,		"tcp_retrans_collapse" },
-	{ CTL_INT,	NET_IPV4_DEFAULT_TTL,			"ip_default_ttl" },
-	/* NET_IPV4_AUTOCONFIG unused */
-	{ CTL_INT,	NET_IPV4_NO_PMTU_DISC,			"ip_no_pmtu_disc" },
-	{ CTL_INT,	NET_IPV4_NONLOCAL_BIND,			"ip_nonlocal_bind" },
-	{ CTL_INT,	NET_IPV4_TCP_SYN_RETRIES,		"tcp_syn_retries" },
-	{ CTL_INT,	NET_TCP_SYNACK_RETRIES,			"tcp_synack_retries" },
-	{ CTL_INT,	NET_TCP_MAX_ORPHANS,			"tcp_max_orphans" },
-	{ CTL_INT,	NET_TCP_MAX_TW_BUCKETS,			"tcp_max_tw_buckets" },
-	{ CTL_INT,	NET_IPV4_DYNADDR,			"ip_dynaddr" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_TIME,		"tcp_keepalive_time" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_PROBES,		"tcp_keepalive_probes" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_INTVL,		"tcp_keepalive_intvl" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRIES1,			"tcp_retries1" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRIES2,			"tcp_retries2" },
-	{ CTL_INT,	NET_IPV4_TCP_FIN_TIMEOUT,		"tcp_fin_timeout" },
-	{ CTL_INT,	NET_TCP_SYNCOOKIES,			"tcp_syncookies" },
-	{ CTL_INT,	NET_TCP_TW_RECYCLE,			"tcp_tw_recycle" },
-	{ CTL_INT,	NET_TCP_ABORT_ON_OVERFLOW,		"tcp_abort_on_overflow" },
-	{ CTL_INT,	NET_TCP_STDURG,				"tcp_stdurg" },
-	{ CTL_INT,	NET_TCP_RFC1337,			"tcp_rfc1337" },
-	{ CTL_INT,	NET_TCP_MAX_SYN_BACKLOG,		"tcp_max_syn_backlog" },
-	{ CTL_INT,	NET_IPV4_LOCAL_PORT_RANGE,		"ip_local_port_range" },
-	{ CTL_INT,	NET_IPV4_IGMP_MAX_MEMBERSHIPS,		"igmp_max_memberships" },
-	{ CTL_INT,	NET_IPV4_IGMP_MAX_MSF,			"igmp_max_msf" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_THRESHOLD,		"inet_peer_threshold" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_MINTTL,		"inet_peer_minttl" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_MAXTTL,		"inet_peer_maxttl" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_GC_MINTIME,		"inet_peer_gc_mintime" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_GC_MAXTIME,		"inet_peer_gc_maxtime" },
-	{ CTL_INT,	NET_TCP_ORPHAN_RETRIES,			"tcp_orphan_retries" },
-	{ CTL_INT,	NET_TCP_FACK,				"tcp_fack" },
-	{ CTL_INT,	NET_TCP_REORDERING,			"tcp_reordering" },
-	{ CTL_INT,	NET_TCP_ECN,				"tcp_ecn" },
-	{ CTL_INT,	NET_TCP_DSACK,				"tcp_dsack" },
-	{ CTL_INT,	NET_TCP_MEM,				"tcp_mem" },
-	{ CTL_INT,	NET_TCP_WMEM,				"tcp_wmem" },
-	{ CTL_INT,	NET_TCP_RMEM,				"tcp_rmem" },
-	{ CTL_INT,	NET_TCP_APP_WIN,			"tcp_app_win" },
-	{ CTL_INT,	NET_TCP_ADV_WIN_SCALE,			"tcp_adv_win_scale" },
-	{ CTL_INT,	NET_TCP_TW_REUSE,			"tcp_tw_reuse" },
-	{ CTL_INT,	NET_TCP_FRTO,				"tcp_frto" },
-	{ CTL_INT,	NET_TCP_FRTO_RESPONSE,			"tcp_frto_response" },
-	{ CTL_INT,	NET_TCP_LOW_LATENCY,			"tcp_low_latency" },
-	{ CTL_INT,	NET_TCP_NO_METRICS_SAVE,		"tcp_no_metrics_save" },
-	{ CTL_INT,	NET_TCP_MODERATE_RCVBUF,		"tcp_moderate_rcvbuf" },
-	{ CTL_INT,	NET_TCP_TSO_WIN_DIVISOR,		"tcp_tso_win_divisor" },
-	{ CTL_STR,	NET_TCP_CONG_CONTROL,			"tcp_congestion_control" },
-	{ CTL_INT,	NET_TCP_ABC,				"tcp_abc" },
-	{ CTL_INT,	NET_TCP_MTU_PROBING,			"tcp_mtu_probing" },
-	{ CTL_INT,	NET_TCP_BASE_MSS,			"tcp_base_mss" },
-	{ CTL_INT,	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS,	"tcp_workaround_signed_windows" },
-	{ CTL_INT,	NET_TCP_DMA_COPYBREAK,			"tcp_dma_copybreak" },
-	{ CTL_INT,	NET_TCP_SLOW_START_AFTER_IDLE,		"tcp_slow_start_after_idle" },
-	{ CTL_INT,	NET_CIPSOV4_CACHE_ENABLE,		"cipso_cache_enable" },
-	{ CTL_INT,	NET_CIPSOV4_CACHE_BUCKET_SIZE,		"cipso_cache_bucket_size" },
-	{ CTL_INT,	NET_CIPSOV4_RBM_OPTFMT,			"cipso_rbm_optfmt" },
-	{ CTL_INT,	NET_CIPSOV4_RBM_STRICTVALID,		"cipso_rbm_strictvalid" },
-	/* NET_TCP_AVAIL_CONG_CONTROL "tcp_available_congestion_control" no longer used */
-	{ CTL_STR,	NET_TCP_ALLOWED_CONG_CONTROL,		"tcp_allowed_congestion_control" },
-	{ CTL_INT,	NET_TCP_MAX_SSTHRESH,			"tcp_max_ssthresh" },
-
-	{ CTL_INT,	NET_IPV4_ICMP_ECHO_IGNORE_ALL,		"icmp_echo_ignore_all" },
-	{ CTL_INT,	NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS,	"icmp_echo_ignore_broadcasts" },
-	{ CTL_INT,	NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES,	"icmp_ignore_bogus_error_responses" },
-	{ CTL_INT,	NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR,	"icmp_errors_use_inbound_ifaddr" },
-	{ CTL_INT,	NET_IPV4_ICMP_RATELIMIT,		"icmp_ratelimit" },
-	{ CTL_INT,	NET_IPV4_ICMP_RATEMASK,			"icmp_ratemask" },
-
-	{ CTL_INT,	NET_IPV4_IPFRAG_HIGH_THRESH,		"ipfrag_high_thresh" },
-	{ CTL_INT,	NET_IPV4_IPFRAG_LOW_THRESH,		"ipfrag_low_thresh" },
-	{ CTL_INT,	NET_IPV4_IPFRAG_TIME,			"ipfrag_time" },
-
-	{ CTL_INT,	NET_IPV4_IPFRAG_SECRET_INTERVAL,	"ipfrag_secret_interval" },
-	/* NET_IPV4_IPFRAG_MAX_DIST "ipfrag_max_dist" no longer used */
-
-	{ CTL_INT,	2088 /* NET_IPQ_QMAX */,		"ip_queue_maxlen" },
-
-	/* NET_TCP_DEFAULT_WIN_SCALE unused */
-	/* NET_TCP_BIC_BETA unused */
-	/* NET_IPV4_TCP_MAX_KA_PROBES unused */
-	/* NET_IPV4_IP_MASQ_DEBUG unused */
-	/* NET_TCP_SYN_TAILDROP unused */
-	/* NET_IPV4_ICMP_SOURCEQUENCH_RATE unused */
-	/* NET_IPV4_ICMP_DESTUNREACH_RATE unused */
-	/* NET_IPV4_ICMP_TIMEEXCEED_RATE unused */
-	/* NET_IPV4_ICMP_PARAMPROB_RATE unused */
-	/* NET_IPV4_ICMP_ECHOREPLY_RATE unused */
-	/* NET_IPV4_ALWAYS_DEFRAG unused */
-	{}
-};
-
-static const struct bin_table bin_net_ipx_table[] = {
-	{ CTL_INT,	NET_IPX_PPROP_BROADCASTING,	"ipx_pprop_broadcasting" },
-	/* NET_IPX_FORWARDING unused */
-	{}
-};
-
-static const struct bin_table bin_net_atalk_table[] = {
-	{ CTL_INT,	NET_ATALK_AARP_EXPIRY_TIME,		"aarp-expiry-time" },
-	{ CTL_INT,	NET_ATALK_AARP_TICK_TIME,		"aarp-tick-time" },
-	{ CTL_INT,	NET_ATALK_AARP_RETRANSMIT_LIMIT,	"aarp-retransmit-limit" },
-	{ CTL_INT,	NET_ATALK_AARP_RESOLVE_TIME,		"aarp-resolve-time" },
-	{},
-};
-
-static const struct bin_table bin_net_netrom_table[] = {
-	{ CTL_INT,	NET_NETROM_DEFAULT_PATH_QUALITY,		"default_path_quality" },
-	{ CTL_INT,	NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER,	"obsolescence_count_initialiser" },
-	{ CTL_INT,	NET_NETROM_NETWORK_TTL_INITIALISER,		"network_ttl_initialiser" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_TIMEOUT,			"transport_timeout" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_MAXIMUM_TRIES,		"transport_maximum_tries" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY,		"transport_acknowledge_delay" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_BUSY_DELAY,		"transport_busy_delay" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE,	"transport_requested_window_size" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT,	"transport_no_activity_timeout" },
-	{ CTL_INT,	NET_NETROM_ROUTING_CONTROL,			"routing_control" },
-	{ CTL_INT,	NET_NETROM_LINK_FAILS_COUNT,			"link_fails_count" },
-	{ CTL_INT,	NET_NETROM_RESET,				"reset" },
-	{}
-};
-
-static const struct bin_table bin_net_ax25_param_table[] = {
-	{ CTL_INT,	NET_AX25_IP_DEFAULT_MODE,	"ip_default_mode" },
-	{ CTL_INT,	NET_AX25_DEFAULT_MODE,		"ax25_default_mode" },
-	{ CTL_INT,	NET_AX25_BACKOFF_TYPE,		"backoff_type" },
-	{ CTL_INT,	NET_AX25_CONNECT_MODE,		"connect_mode" },
-	{ CTL_INT,	NET_AX25_STANDARD_WINDOW,	"standard_window_size" },
-	{ CTL_INT,	NET_AX25_EXTENDED_WINDOW,	"extended_window_size" },
-	{ CTL_INT,	NET_AX25_T1_TIMEOUT,		"t1_timeout" },
-	{ CTL_INT,	NET_AX25_T2_TIMEOUT,		"t2_timeout" },
-	{ CTL_INT,	NET_AX25_T3_TIMEOUT,		"t3_timeout" },
-	{ CTL_INT,	NET_AX25_IDLE_TIMEOUT,		"idle_timeout" },
-	{ CTL_INT,	NET_AX25_N2,			"maximum_retry_count" },
-	{ CTL_INT,	NET_AX25_PACLEN,		"maximum_packet_length" },
-	{ CTL_INT,	NET_AX25_PROTOCOL,		"protocol" },
-	{ CTL_INT,	NET_AX25_DAMA_SLAVE_TIMEOUT,	"dama_slave_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_ax25_table[] = {
-	{ CTL_DIR,	0, NULL, bin_net_ax25_param_table },
-	{}
-};
-
-static const struct bin_table bin_net_rose_table[] = {
-	{ CTL_INT,	NET_ROSE_RESTART_REQUEST_TIMEOUT,	"restart_request_timeout" },
-	{ CTL_INT,	NET_ROSE_CALL_REQUEST_TIMEOUT,		"call_request_timeout" },
-	{ CTL_INT,	NET_ROSE_RESET_REQUEST_TIMEOUT,		"reset_request_timeout" },
-	{ CTL_INT,	NET_ROSE_CLEAR_REQUEST_TIMEOUT,		"clear_request_timeout" },
-	{ CTL_INT,	NET_ROSE_ACK_HOLD_BACK_TIMEOUT,		"acknowledge_hold_back_timeout" },
-	{ CTL_INT,	NET_ROSE_ROUTING_CONTROL,		"routing_control" },
-	{ CTL_INT,	NET_ROSE_LINK_FAIL_TIMEOUT,		"link_fail_timeout" },
-	{ CTL_INT,	NET_ROSE_MAX_VCS,			"maximum_virtual_circuits" },
-	{ CTL_INT,	NET_ROSE_WINDOW_SIZE,			"window_size" },
-	{ CTL_INT,	NET_ROSE_NO_ACTIVITY_TIMEOUT,		"no_activity_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_conf_var_table[] = {
-	{ CTL_INT,	NET_IPV6_FORWARDING,			"forwarding" },
-	{ CTL_INT,	NET_IPV6_HOP_LIMIT,			"hop_limit" },
-	{ CTL_INT,	NET_IPV6_MTU,				"mtu" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA,			"accept_ra" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_REDIRECTS,		"accept_redirects" },
-	{ CTL_INT,	NET_IPV6_AUTOCONF,			"autoconf" },
-	{ CTL_INT,	NET_IPV6_DAD_TRANSMITS,			"dad_transmits" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICITS,			"router_solicitations" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICIT_INTERVAL,		"router_solicitation_interval" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICIT_DELAY,		"router_solicitation_delay" },
-	{ CTL_INT,	NET_IPV6_USE_TEMPADDR,			"use_tempaddr" },
-	{ CTL_INT,	NET_IPV6_TEMP_VALID_LFT,		"temp_valid_lft" },
-	{ CTL_INT,	NET_IPV6_TEMP_PREFERED_LFT,		"temp_prefered_lft" },
-	{ CTL_INT,	NET_IPV6_REGEN_MAX_RETRY,		"regen_max_retry" },
-	{ CTL_INT,	NET_IPV6_MAX_DESYNC_FACTOR,		"max_desync_factor" },
-	{ CTL_INT,	NET_IPV6_MAX_ADDRESSES,			"max_addresses" },
-	{ CTL_INT,	NET_IPV6_FORCE_MLD_VERSION,		"force_mld_version" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_DEFRTR,		"accept_ra_defrtr" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_PINFO,		"accept_ra_pinfo" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_RTR_PREF,		"accept_ra_rtr_pref" },
-	{ CTL_INT,	NET_IPV6_RTR_PROBE_INTERVAL,		"router_probe_interval" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN,	"accept_ra_rt_info_max_plen" },
-	{ CTL_INT,	NET_IPV6_PROXY_NDP,			"proxy_ndp" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_SOURCE_ROUTE,		"accept_source_route" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_conf_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_ALL,		"all",	bin_net_ipv6_conf_var_table },
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT, 	"default", bin_net_ipv6_conf_var_table },
-	{ CTL_DIR,	0, NULL, bin_net_ipv6_conf_var_table },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_route_table[] = {
-	/* NET_IPV6_ROUTE_FLUSH	"flush"  no longer used */
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_THRESH,		"gc_thresh" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MAX_SIZE,		"max_size" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_MIN_INTERVAL,		"gc_min_interval" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_TIMEOUT,		"gc_timeout" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_INTERVAL,		"gc_interval" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_ELASTICITY,		"gc_elasticity" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MTU_EXPIRES,		"mtu_expires" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MIN_ADVMSS,		"min_adv_mss" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS,	"gc_min_interval_ms" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_icmp_table[] = {
-	{ CTL_INT,	NET_IPV6_ICMP_RATELIMIT,	"ratelimit" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_table[] = {
-	{ CTL_DIR,	NET_IPV6_CONF,		"conf",		bin_net_ipv6_conf_table },
-	{ CTL_DIR,	NET_IPV6_NEIGH,		"neigh",	bin_net_neigh_table },
-	{ CTL_DIR,	NET_IPV6_ROUTE,		"route",	bin_net_ipv6_route_table },
-	{ CTL_DIR,	NET_IPV6_ICMP,		"icmp",		bin_net_ipv6_icmp_table },
-	{ CTL_INT,	NET_IPV6_BINDV6ONLY,		"bindv6only" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_HIGH_THRESH,	"ip6frag_high_thresh" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_LOW_THRESH,	"ip6frag_low_thresh" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_TIME,		"ip6frag_time" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_SECRET_INTERVAL,	"ip6frag_secret_interval" },
-	{ CTL_INT,	NET_IPV6_MLD_MAX_MSF,		"mld_max_msf" },
-	{ CTL_INT,	2088 /* IPQ_QMAX */,		"ip6_queue_maxlen" },
-	{}
-};
-
-static const struct bin_table bin_net_x25_table[] = {
-	{ CTL_INT,	NET_X25_RESTART_REQUEST_TIMEOUT,	"restart_request_timeout" },
-	{ CTL_INT,	NET_X25_CALL_REQUEST_TIMEOUT,		"call_request_timeout" },
-	{ CTL_INT,	NET_X25_RESET_REQUEST_TIMEOUT,	"reset_request_timeout" },
-	{ CTL_INT,	NET_X25_CLEAR_REQUEST_TIMEOUT,	"clear_request_timeout" },
-	{ CTL_INT,	NET_X25_ACK_HOLD_BACK_TIMEOUT,	"acknowledgement_hold_back_timeout" },
-	{ CTL_INT,	NET_X25_FORWARD,			"x25_forward" },
-	{}
-};
-
-static const struct bin_table bin_net_tr_table[] = {
-	{ CTL_INT,	NET_TR_RIF_TIMEOUT,	"rif_timeout" },
-	{}
-};
-
-
-static const struct bin_table bin_net_decnet_conf_vars[] = {
-	{ CTL_INT,	NET_DECNET_CONF_DEV_FORWARDING,	"forwarding" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_PRIORITY,	"priority" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_T2,		"t2" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_T3,		"t3" },
-	{}
-};
-
-static const struct bin_table bin_net_decnet_conf[] = {
-	{ CTL_DIR, NET_DECNET_CONF_ETHER,    "ethernet", bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_GRE,	     "ipgre",    bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_X25,	     "x25",      bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_PPP,	     "ppp",      bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_DDCMP,    "ddcmp",    bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_LOOPBACK, "loopback", bin_net_decnet_conf_vars },
-	{ CTL_DIR, 0,			     NULL,	 bin_net_decnet_conf_vars },
-	{}
-};
-
-static const struct bin_table bin_net_decnet_table[] = {
-	{ CTL_DIR,	NET_DECNET_CONF,		"conf",	bin_net_decnet_conf },
-	{ CTL_DNADR,	NET_DECNET_NODE_ADDRESS,	"node_address" },
-	{ CTL_STR,	NET_DECNET_NODE_NAME,		"node_name" },
-	{ CTL_STR,	NET_DECNET_DEFAULT_DEVICE,	"default_device" },
-	{ CTL_INT,	NET_DECNET_TIME_WAIT,		"time_wait" },
-	{ CTL_INT,	NET_DECNET_DN_COUNT,		"dn_count" },
-	{ CTL_INT,	NET_DECNET_DI_COUNT,		"di_count" },
-	{ CTL_INT,	NET_DECNET_DR_COUNT,		"dr_count" },
-	{ CTL_INT,	NET_DECNET_DST_GC_INTERVAL,	"dst_gc_interval" },
-	{ CTL_INT,	NET_DECNET_NO_FC_MAX_CWND,	"no_fc_max_cwnd" },
-	{ CTL_INT,	NET_DECNET_MEM,		"decnet_mem" },
-	{ CTL_INT,	NET_DECNET_RMEM,		"decnet_rmem" },
-	{ CTL_INT,	NET_DECNET_WMEM,		"decnet_wmem" },
-	{ CTL_INT,	NET_DECNET_DEBUG_LEVEL,	"debug" },
-	{}
-};
-
-static const struct bin_table bin_net_sctp_table[] = {
-	{ CTL_INT,	NET_SCTP_RTO_INITIAL,		"rto_initial" },
-	{ CTL_INT,	NET_SCTP_RTO_MIN,		"rto_min" },
-	{ CTL_INT,	NET_SCTP_RTO_MAX,		"rto_max" },
-	{ CTL_INT,	NET_SCTP_RTO_ALPHA,		"rto_alpha_exp_divisor" },
-	{ CTL_INT,	NET_SCTP_RTO_BETA,		"rto_beta_exp_divisor" },
-	{ CTL_INT,	NET_SCTP_VALID_COOKIE_LIFE,	"valid_cookie_life" },
-	{ CTL_INT,	NET_SCTP_ASSOCIATION_MAX_RETRANS,	"association_max_retrans" },
-	{ CTL_INT,	NET_SCTP_PATH_MAX_RETRANS,	"path_max_retrans" },
-	{ CTL_INT,	NET_SCTP_MAX_INIT_RETRANSMITS,	"max_init_retransmits" },
-	{ CTL_INT,	NET_SCTP_HB_INTERVAL,		"hb_interval" },
-	{ CTL_INT,	NET_SCTP_PRESERVE_ENABLE,	"cookie_preserve_enable" },
-	{ CTL_INT,	NET_SCTP_MAX_BURST,		"max_burst" },
-	{ CTL_INT,	NET_SCTP_ADDIP_ENABLE,		"addip_enable" },
-	{ CTL_INT,	NET_SCTP_PRSCTP_ENABLE,		"prsctp_enable" },
-	{ CTL_INT,	NET_SCTP_SNDBUF_POLICY,		"sndbuf_policy" },
-	{ CTL_INT,	NET_SCTP_SACK_TIMEOUT,		"sack_timeout" },
-	{ CTL_INT,	NET_SCTP_RCVBUF_POLICY,		"rcvbuf_policy" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_llc2_timeout_table[] = {
-	{ CTL_INT,	NET_LLC2_ACK_TIMEOUT,	"ack" },
-	{ CTL_INT,	NET_LLC2_P_TIMEOUT,	"p" },
-	{ CTL_INT,	NET_LLC2_REJ_TIMEOUT,	"rej" },
-	{ CTL_INT,	NET_LLC2_BUSY_TIMEOUT,	"busy" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_station_table[] = {
-	{ CTL_INT,	NET_LLC_STATION_ACK_TIMEOUT,	"ack_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_llc2_table[] = {
-	{ CTL_DIR,	NET_LLC2,		"timeout",	bin_net_llc_llc2_timeout_table },
-	{}
-};
-
-static const struct bin_table bin_net_llc_table[] = {
-	{ CTL_DIR,	NET_LLC2,		"llc2",		bin_net_llc_llc2_table },
-	{ CTL_DIR,	NET_LLC_STATION,	"station",	bin_net_llc_station_table },
-	{}
-};
-
-static const struct bin_table bin_net_netfilter_table[] = {
-	{ CTL_INT,	NET_NF_CONNTRACK_MAX,			"nf_conntrack_max" },
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT "nf_conntrack_tcp_timeout_syn_sent" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV "nf_conntrack_tcp_timeout_syn_recv" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED "nf_conntrack_tcp_timeout_established" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT "nf_conntrack_tcp_timeout_fin_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT "nf_conntrack_tcp_timeout_close_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK "nf_conntrack_tcp_timeout_last_ack" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT "nf_conntrack_tcp_timeout_time_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE "nf_conntrack_tcp_timeout_close" no longer used */
-	/* NET_NF_CONNTRACK_UDP_TIMEOUT	"nf_conntrack_udp_timeout" no longer used */
-	/* NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM "nf_conntrack_udp_timeout_stream" no longer used */
-	/* NET_NF_CONNTRACK_ICMP_TIMEOUT "nf_conntrack_icmp_timeout" no longer used */
-	/* NET_NF_CONNTRACK_GENERIC_TIMEOUT "nf_conntrack_generic_timeout" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_BUCKETS,		"nf_conntrack_buckets" },
-	{ CTL_INT,	NET_NF_CONNTRACK_LOG_INVALID,		"nf_conntrack_log_invalid" },
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS "nf_conntrack_tcp_timeout_max_retrans" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_LOOSE,		"nf_conntrack_tcp_loose" },
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_BE_LIBERAL,	"nf_conntrack_tcp_be_liberal" },
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_MAX_RETRANS,	"nf_conntrack_tcp_max_retrans" },
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED "nf_conntrack_sctp_timeout_closed" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT "nf_conntrack_sctp_timeout_cookie_wait" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED "nf_conntrack_sctp_timeout_cookie_echoed" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED "nf_conntrack_sctp_timeout_established" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT "nf_conntrack_sctp_timeout_shutdown_sent" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD "nf_conntrack_sctp_timeout_shutdown_recd" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT "nf_conntrack_sctp_timeout_shutdown_ack_sent" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_COUNT,			"nf_conntrack_count" },
-	/* NET_NF_CONNTRACK_ICMPV6_TIMEOUT "nf_conntrack_icmpv6_timeout" no longer used */
-	/* NET_NF_CONNTRACK_FRAG6_TIMEOUT "nf_conntrack_frag6_timeout" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_FRAG6_LOW_THRESH,	"nf_conntrack_frag6_low_thresh" },
-	{ CTL_INT,	NET_NF_CONNTRACK_FRAG6_HIGH_THRESH,	"nf_conntrack_frag6_high_thresh" },
-	{ CTL_INT,	NET_NF_CONNTRACK_CHECKSUM,		"nf_conntrack_checksum" },
-
-	{}
-};
-
-static const struct bin_table bin_net_irda_table[] = {
-	{ CTL_INT,	NET_IRDA_DISCOVERY,		"discovery" },
-	{ CTL_STR,	NET_IRDA_DEVNAME,		"devname" },
-	{ CTL_INT,	NET_IRDA_DEBUG,			"debug" },
-	{ CTL_INT,	NET_IRDA_FAST_POLL,		"fast_poll_increase" },
-	{ CTL_INT,	NET_IRDA_DISCOVERY_SLOTS,	"discovery_slots" },
-	{ CTL_INT,	NET_IRDA_DISCOVERY_TIMEOUT,	"discovery_timeout" },
-	{ CTL_INT,	NET_IRDA_SLOT_TIMEOUT,		"slot_timeout" },
-	{ CTL_INT,	NET_IRDA_MAX_BAUD_RATE,		"max_baud_rate" },
-	{ CTL_INT,	NET_IRDA_MIN_TX_TURN_TIME,	"min_tx_turn_time" },
-	{ CTL_INT,	NET_IRDA_MAX_TX_DATA_SIZE,	"max_tx_data_size" },
-	{ CTL_INT,	NET_IRDA_MAX_TX_WINDOW,		"max_tx_window" },
-	{ CTL_INT,	NET_IRDA_MAX_NOREPLY_TIME,	"max_noreply_time" },
-	{ CTL_INT,	NET_IRDA_WARN_NOREPLY_TIME,	"warn_noreply_time" },
-	{ CTL_INT,	NET_IRDA_LAP_KEEPALIVE_TIME,	"lap_keepalive_time" },
-	{}
-};
-
-static const struct bin_table bin_net_table[] = {
-	{ CTL_DIR,	NET_CORE,		"core",		bin_net_core_table },
-	/* NET_ETHER not used */
-	/* NET_802 not used */
-	{ CTL_DIR,	NET_UNIX,		"unix",		bin_net_unix_table },
-	{ CTL_DIR,	NET_IPV4,		"ipv4",		bin_net_ipv4_table },
-	{ CTL_DIR,	NET_IPX,		"ipx",		bin_net_ipx_table },
-	{ CTL_DIR,	NET_ATALK,		"appletalk",	bin_net_atalk_table },
-	{ CTL_DIR,	NET_NETROM,		"netrom",	bin_net_netrom_table },
-	{ CTL_DIR,	NET_AX25,		"ax25",		bin_net_ax25_table },
-	/*  NET_BRIDGE "bridge" no longer used */
-	{ CTL_DIR,	NET_ROSE,		"rose",		bin_net_rose_table },
-	{ CTL_DIR,	NET_IPV6,		"ipv6",		bin_net_ipv6_table },
-	{ CTL_DIR,	NET_X25,		"x25",		bin_net_x25_table },
-	{ CTL_DIR,	NET_TR,			"token-ring",	bin_net_tr_table },
-	{ CTL_DIR,	NET_DECNET,		"decnet",	bin_net_decnet_table },
-	/*  NET_ECONET not used */
-	{ CTL_DIR,	NET_SCTP,		"sctp",		bin_net_sctp_table },
-	{ CTL_DIR,	NET_LLC,		"llc",		bin_net_llc_table },
-	{ CTL_DIR,	NET_NETFILTER,		"netfilter",	bin_net_netfilter_table },
-	/* NET_DCCP "dccp" no longer used */
-	{ CTL_DIR,	NET_IRDA,		"irda",		bin_net_irda_table },
-	{ CTL_INT,	2089,			"nf_conntrack_max" },
-	{}
-};
-
-static const struct bin_table bin_fs_quota_table[] = {
-	{ CTL_INT,	FS_DQ_LOOKUPS,		"lookups" },
-	{ CTL_INT,	FS_DQ_DROPS,		"drops" },
-	{ CTL_INT,	FS_DQ_READS,		"reads" },
-	{ CTL_INT,	FS_DQ_WRITES,		"writes" },
-	{ CTL_INT,	FS_DQ_CACHE_HITS,	"cache_hits" },
-	{ CTL_INT,	FS_DQ_ALLOCATED,	"allocated_dquots" },
-	{ CTL_INT,	FS_DQ_FREE,		"free_dquots" },
-	{ CTL_INT,	FS_DQ_SYNCS,		"syncs" },
-	{ CTL_INT,	FS_DQ_WARNINGS,		"warnings" },
-	{}
-};
-
-static const struct bin_table bin_fs_xfs_table[] = {
-	{ CTL_INT,	XFS_SGID_INHERIT,	"irix_sgid_inherit" },
-	{ CTL_INT,	XFS_SYMLINK_MODE,	"irix_symlink_mode" },
-	{ CTL_INT,	XFS_PANIC_MASK,		"panic_mask" },
-
-	{ CTL_INT,	XFS_ERRLEVEL,		"error_level" },
-	{ CTL_INT,	XFS_SYNCD_TIMER,	"xfssyncd_centisecs" },
-	{ CTL_INT,	XFS_INHERIT_SYNC,	"inherit_sync" },
-	{ CTL_INT,	XFS_INHERIT_NODUMP,	"inherit_nodump" },
-	{ CTL_INT,	XFS_INHERIT_NOATIME,	"inherit_noatime" },
-	{ CTL_INT,	XFS_BUF_TIMER,		"xfsbufd_centisecs" },
-	{ CTL_INT,	XFS_BUF_AGE,		"age_buffer_centisecs" },
-	{ CTL_INT,	XFS_INHERIT_NOSYM,	"inherit_nosymlinks" },
-	{ CTL_INT,	XFS_ROTORSTEP,	"rotorstep" },
-	{ CTL_INT,	XFS_INHERIT_NODFRG,	"inherit_nodefrag" },
-	{ CTL_INT,	XFS_FILESTREAM_TIMER,	"filestream_centisecs" },
-	{ CTL_INT,	XFS_STATS_CLEAR,	"stats_clear" },
-	{}
-};
-
-static const struct bin_table bin_fs_ocfs2_nm_table[] = {
-	{ CTL_STR,	1, "hb_ctl_path" },
-	{}
-};
-
-static const struct bin_table bin_fs_ocfs2_table[] = {
-	{ CTL_DIR,	1,	"nm",	bin_fs_ocfs2_nm_table },
-	{}
-};
-
-static const struct bin_table bin_inotify_table[] = {
-	{ CTL_INT,	INOTIFY_MAX_USER_INSTANCES,	"max_user_instances" },
-	{ CTL_INT,	INOTIFY_MAX_USER_WATCHES,	"max_user_watches" },
-	{ CTL_INT,	INOTIFY_MAX_QUEUED_EVENTS,	"max_queued_events" },
-	{}
-};
-
-static const struct bin_table bin_fs_table[] = {
-	{ CTL_INT,	FS_NRINODE,		"inode-nr" },
-	{ CTL_INT,	FS_STATINODE,		"inode-state" },
-	/* FS_MAXINODE unused */
-	/* FS_NRDQUOT unused */
-	/* FS_MAXDQUOT unused */
-	/* FS_NRFILE "file-nr" no longer used */
-	{ CTL_INT,	FS_MAXFILE,		"file-max" },
-	{ CTL_INT,	FS_DENTRY,		"dentry-state" },
-	/* FS_NRSUPER unused */
-	/* FS_MAXUPSER unused */
-	{ CTL_INT,	FS_OVERFLOWUID,		"overflowuid" },
-	{ CTL_INT,	FS_OVERFLOWGID,		"overflowgid" },
-	{ CTL_INT,	FS_LEASES,		"leases-enable" },
-	{ CTL_INT,	FS_DIR_NOTIFY,		"dir-notify-enable" },
-	{ CTL_INT,	FS_LEASE_TIME,		"lease-break-time" },
-	{ CTL_DIR,	FS_DQSTATS,		"quota",	bin_fs_quota_table },
-	{ CTL_DIR,	FS_XFS,			"xfs",		bin_fs_xfs_table },
-	{ CTL_ULONG,	FS_AIO_NR,		"aio-nr" },
-	{ CTL_ULONG,	FS_AIO_MAX_NR,		"aio-max-nr" },
-	{ CTL_DIR,	FS_INOTIFY,		"inotify",	bin_inotify_table },
-	{ CTL_DIR,	FS_OCFS2,		"ocfs2",	bin_fs_ocfs2_table },
-	{ CTL_INT,	KERN_SETUID_DUMPABLE,	"suid_dumpable" },
-	{}
-};
-
-static const struct bin_table bin_ipmi_table[] = {
-	{ CTL_INT,	DEV_IPMI_POWEROFF_POWERCYCLE,	"poweroff_powercycle" },
-	{}
-};
-
-static const struct bin_table bin_mac_hid_files[] = {
-	/* DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES unused */
-	/* DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES unused */
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON_EMULATION,	"mouse_button_emulation" },
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE,	"mouse_button2_keycode" },
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE,	"mouse_button3_keycode" },
-	/* DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES unused */
-	{}
-};
-
-static const struct bin_table bin_raid_table[] = {
-	{ CTL_INT,	DEV_RAID_SPEED_LIMIT_MIN,	"speed_limit_min" },
-	{ CTL_INT,	DEV_RAID_SPEED_LIMIT_MAX,	"speed_limit_max" },
-	{}
-};
-
-static const struct bin_table bin_scsi_table[] = {
-	{ CTL_INT, DEV_SCSI_LOGGING_LEVEL, "logging_level" },
-	{}
-};
-
-static const struct bin_table bin_dev_table[] = {
-	/* DEV_CDROM	"cdrom" no longer used */
-	/* DEV_HWMON unused */
-	/* DEV_PARPORT	"parport" no longer used */
-	{ CTL_DIR,	DEV_RAID,	"raid",		bin_raid_table },
-	{ CTL_DIR,	DEV_MAC_HID,	"mac_hid",	bin_mac_hid_files },
-	{ CTL_DIR,	DEV_SCSI,	"scsi",		bin_scsi_table },
-	{ CTL_DIR,	DEV_IPMI,	"ipmi",		bin_ipmi_table },
-	{}
-};
-
-static const struct bin_table bin_bus_isa_table[] = {
-	{ CTL_INT,	BUS_ISA_MEM_BASE,	"membase" },
-	{ CTL_INT,	BUS_ISA_PORT_BASE,	"portbase" },
-	{ CTL_INT,	BUS_ISA_PORT_SHIFT,	"portshift" },
-	{}
-};
-
-static const struct bin_table bin_bus_table[] = {
-	{ CTL_DIR,	CTL_BUS_ISA,	"isa",	bin_bus_isa_table },
-	{}
-};
-
-
-static const struct bin_table bin_s390dbf_table[] = {
-	{ CTL_INT,	5678 /* CTL_S390DBF_STOPPABLE */, "debug_stoppable" },
-	{ CTL_INT,	5679 /* CTL_S390DBF_ACTIVE */,	  "debug_active" },
-	{}
-};
-
-static const struct bin_table bin_sunrpc_table[] = {
-	/* CTL_RPCDEBUG	"rpc_debug"  no longer used */
-	/* CTL_NFSDEBUG "nfs_debug"  no longer used */
-	/* CTL_NFSDDEBUG "nfsd_debug" no longer used  */
-	/* CTL_NLMDEBUG "nlm_debug" no longer used */
-
-	{ CTL_INT,	CTL_SLOTTABLE_UDP,	"udp_slot_table_entries" },
-	{ CTL_INT,	CTL_SLOTTABLE_TCP,	"tcp_slot_table_entries" },
-	{ CTL_INT,	CTL_MIN_RESVPORT,	"min_resvport" },
-	{ CTL_INT,	CTL_MAX_RESVPORT,	"max_resvport" },
-	{}
-};
-
-static const struct bin_table bin_pm_table[] = {
-	/* frv specific */
-	/* 1 == CTL_PM_SUSPEND	"suspend"  no longer used" */
-	{ CTL_INT,	2 /* CTL_PM_CMODE */,		"cmode" },
-	{ CTL_INT,	3 /* CTL_PM_P0 */,		"p0" },
-	{ CTL_INT,	4 /* CTL_PM_CM */,		"cm" },
-	{}
-};
-
-static const struct bin_table bin_root_table[] = {
-	{ CTL_DIR,	CTL_KERN,	"kernel",	bin_kern_table },
-	{ CTL_DIR,	CTL_VM,		"vm",		bin_vm_table },
-	{ CTL_DIR,	CTL_NET,	"net",		bin_net_table },
-	/* CTL_PROC not used */
-	{ CTL_DIR,	CTL_FS,		"fs",		bin_fs_table },
-	/* CTL_DEBUG "debug" no longer used */
-	{ CTL_DIR,	CTL_DEV,	"dev",		bin_dev_table },
-	{ CTL_DIR,	CTL_BUS,	"bus",		bin_bus_table },
-	{ CTL_DIR,	CTL_ABI,	"abi" },
-	/* CTL_CPU not used */
-	/* CTL_ARLAN "arlan" no longer used */
-	{ CTL_DIR,	CTL_S390DBF,	"s390dbf",	bin_s390dbf_table },
-	{ CTL_DIR,	CTL_SUNRPC,	"sunrpc",	bin_sunrpc_table },
-	{ CTL_DIR,	CTL_PM,		"pm",		bin_pm_table },
-	{}
-};
-
-static ssize_t bin_dir(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	return -ENOTDIR;
-}
-
-
-static ssize_t bin_string(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	ssize_t result, copied = 0;
-
-	if (oldval && oldlen) {
-		char __user *lastp;
-		loff_t pos = 0;
-		int ch;
-
-		result = vfs_read(file, oldval, oldlen, &pos);
-		if (result < 0)
-			goto out;
-
-		copied = result;
-		lastp = oldval + copied - 1;
-
-		result = -EFAULT;
-		if (get_user(ch, lastp))
-			goto out;
-
-		/* Trim off the trailing newline */
-		if (ch == '\n') {
-			result = -EFAULT;
-			if (put_user('\0', lastp))
-				goto out;
-			copied -= 1;
-		}
-	}
-
-	if (newval && newlen) {
-		loff_t pos = 0;
-
-		result = vfs_write(file, newval, newlen, &pos);
-		if (result < 0)
-			goto out;
-	}
-
-	result = copied;
-out:
-	return result;
-}
-
-static ssize_t bin_intvec(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t copied = 0;
-	char *buffer;
-	ssize_t result;
-
-	result = -ENOMEM;
-	buffer = kmalloc(BUFSZ, GFP_KERNEL);
-	if (!buffer)
-		goto out;
-
-	if (oldval && oldlen) {
-		unsigned __user *vec = oldval;
-		size_t length = oldlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-
-		str = buffer;
-		end = str + result;
-		*end++ = '\0';
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			value = simple_strtoul(str, &str, 10);
-			while (isspace(*str))
-				str++;
-			
-			result = -EFAULT;
-			if (put_user(value, vec + i))
-				goto out_kfree;
-
-			copied += sizeof(*vec);
-			if (!isdigit(*str))
-				break;
-		}
-	}
-
-	if (newval && newlen) {
-		unsigned __user *vec = newval;
-		size_t length = newlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		str = buffer;
-		end = str + BUFSZ;
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			result = -EFAULT;
-			if (get_user(value, vec + i))
-				goto out_kfree;
-
-			str += snprintf(str, end - str, "%lu\t", value);
-		}
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buffer, str - buffer, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-	}
-	result = copied;
-out_kfree:
-	kfree(buffer);
-out:
-	return result;
-}
-
-static ssize_t bin_ulongvec(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t copied = 0;
-	char *buffer;
-	ssize_t result;
-
-	result = -ENOMEM;
-	buffer = kmalloc(BUFSZ, GFP_KERNEL);
-	if (!buffer)
-		goto out;
-
-	if (oldval && oldlen) {
-		unsigned long __user *vec = oldval;
-		size_t length = oldlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-
-		str = buffer;
-		end = str + result;
-		*end++ = '\0';
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			value = simple_strtoul(str, &str, 10);
-			while (isspace(*str))
-				str++;
-			
-			result = -EFAULT;
-			if (put_user(value, vec + i))
-				goto out_kfree;
-
-			copied += sizeof(*vec);
-			if (!isdigit(*str))
-				break;
-		}
-	}
-
-	if (newval && newlen) {
-		unsigned long __user *vec = newval;
-		size_t length = newlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		str = buffer;
-		end = str + BUFSZ;
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			result = -EFAULT;
-			if (get_user(value, vec + i))
-				goto out_kfree;
-
-			str += snprintf(str, end - str, "%lu\t", value);
-		}
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buffer, str - buffer, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-	}
-	result = copied;
-out_kfree:
-	kfree(buffer);
-out:
-	return result;
-}
-
-static ssize_t bin_uuid(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t result, copied = 0;
-
-	/* Only supports reads */
-	if (oldval && oldlen) {
-		loff_t pos = 0;
-		char buf[40], *str = buf;
-		unsigned char uuid[16];
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-
-		buf[result] = '\0';
-
-		/* Convert the uuid to from a string to binary */
-		for (i = 0; i < 16; i++) {
-			result = -EIO;
-			if (!isxdigit(str[0]) || !isxdigit(str[1]))
-				goto out;
-
-			uuid[i] = (hex_to_bin(str[0]) << 4) |
-					hex_to_bin(str[1]);
-			str += 2;
-			if (*str == '-')
-				str++;
-		}
-
-		if (oldlen > 16)
-			oldlen = 16;
-
-		result = -EFAULT;
-		if (copy_to_user(oldval, uuid, oldlen))
-			goto out;
-
-		copied = oldlen;
-	}
-	result = copied;
-out:
-	return result;
-}
-
-static ssize_t bin_dn_node_address(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t result, copied = 0;
-
-	if (oldval && oldlen) {
-		loff_t pos = 0;
-		char buf[15], *nodep;
-		unsigned long area, node;
-		__le16 dnaddr;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-
-		buf[result] = '\0';
-
-		/* Convert the decnet address to binary */
-		result = -EIO;
-		nodep = strchr(buf, '.') + 1;
-		if (!nodep)
-			goto out;
-
-		area = simple_strtoul(buf, NULL, 10);
-		node = simple_strtoul(nodep, NULL, 10);
-
-		result = -EIO;
-		if ((area > 63)||(node > 1023))
-			goto out;
-
-		dnaddr = cpu_to_le16((area << 10) | node);
-
-		result = -EFAULT;
-		if (put_user(dnaddr, (__le16 __user *)oldval))
-			goto out;
-
-		copied = sizeof(dnaddr);
-	}
-
-	if (newval && newlen) {
-		loff_t pos = 0;
-		__le16 dnaddr;
-		char buf[15];
-		int len;
-
-		result = -EINVAL;
-		if (newlen != sizeof(dnaddr))
-			goto out;
-
-		result = -EFAULT;
-		if (get_user(dnaddr, (__le16 __user *)newval))
-			goto out;
-
-		len = snprintf(buf, sizeof(buf), "%hu.%hu",
-				le16_to_cpu(dnaddr) >> 10,
-				le16_to_cpu(dnaddr) & 0x3ff);
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buf, len, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-	}
-
-	result = copied;
-out:
-	return result;
-}
-
-static const struct bin_table *get_sysctl(const int *name, int nlen, char *path)
-{
-	const struct bin_table *table = &bin_root_table[0];
-	int ctl_name;
-
-	/* The binary sysctl tables have a small maximum depth so
-	 * there is no danger of overflowing our path as it PATH_MAX
-	 * bytes long.
-	 */
-	memcpy(path, "sys/", 4);
-	path += 4;
-
-repeat:
-	if (!nlen)
-		return ERR_PTR(-ENOTDIR);
-	ctl_name = *name;
-	name++;
-	nlen--;
-	for ( ; table->convert; table++) {
-		int len = 0;
-
-		/*
-		 * For a wild card entry map from ifindex to network
-		 * device name.
-		 */
-		if (!table->ctl_name) {
-#ifdef CONFIG_NET
-			struct net *net = current->nsproxy->net_ns;
-			struct net_device *dev;
-			dev = dev_get_by_index(net, ctl_name);
-			if (dev) {
-				len = strlen(dev->name);
-				memcpy(path, dev->name, len);
-				dev_put(dev);
-			}
-#endif
-		/* Use the well known sysctl number to proc name mapping */
-		} else if (ctl_name == table->ctl_name) {
-			len = strlen(table->procname);
-			memcpy(path, table->procname, len);
-		}
-		if (len) {
-			path += len;
-			if (table->child) {
-				*path++ = '/';
-				table = table->child;
-				goto repeat;
-			}
-			*path = '\0';
-			return table;
-		}
-	}
-	return ERR_PTR(-ENOTDIR);
-}
-
-static char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)
-{
-	char *tmp, *result;
-
-	result = ERR_PTR(-ENOMEM);
-	tmp = __getname();
-	if (tmp) {
-		const struct bin_table *table = get_sysctl(name, nlen, tmp);
-		result = tmp;
-		*tablep = table;
-		if (IS_ERR(table)) {
-			__putname(tmp);
-			result = ERR_CAST(table);
-		}
-	}
-	return result;
-}
-
-static ssize_t binary_sysctl(const int *name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	const struct bin_table *table = NULL;
-	struct vfsmount *mnt;
-	struct file *file;
-	ssize_t result;
-	char *pathname;
-	int flags;
-
-	pathname = sysctl_getname(name, nlen, &table);
-	result = PTR_ERR(pathname);
-	if (IS_ERR(pathname))
-		goto out;
-
-	/* How should the sysctl be accessed? */
-	if (oldval && oldlen && newval && newlen) {
-		flags = O_RDWR;
-	} else if (newval && newlen) {
-		flags = O_WRONLY;
-	} else if (oldval && oldlen) {
-		flags = O_RDONLY;
-	} else {
-		result = 0;
-		goto out_putname;
-	}
-
-	mnt = current->nsproxy->pid_ns->proc_mnt;
-	file = file_open_root(mnt->mnt_root, mnt, pathname, flags);
-	result = PTR_ERR(file);
-	if (IS_ERR(file))
-		goto out_putname;
-
-	result = table->convert(file, oldval, oldlen, newval, newlen);
-
-	fput(file);
-out_putname:
-	__putname(pathname);
-out:
-	return result;
-}
-
-
-#else /* CONFIG_SYSCTL_SYSCALL */
-
-static ssize_t binary_sysctl(const int *name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	return -ENOSYS;
-}
-
-#endif /* CONFIG_SYSCTL_SYSCALL */
-
-
-static void deprecated_sysctl_warning(const int *name, int nlen)
-{
-	int i;
-
-	/*
-	 * CTL_KERN/KERN_VERSION is used by older glibc and cannot
-	 * ever go away.
-	 */
-	if (name[0] == CTL_KERN && name[1] == KERN_VERSION)
-		return;
-
-	if (printk_ratelimit()) {
-		printk(KERN_INFO
-			"warning: process `%s' used the deprecated sysctl "
-			"system call with ", current->comm);
-		for (i = 0; i < nlen; i++)
-			printk("%d.", name[i]);
-		printk("\n");
-	}
-	return;
-}
-
-#define WARN_ONCE_HASH_BITS 8
-#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)
-
-static DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);
-
-#define FNV32_OFFSET 2166136261U
-#define FNV32_PRIME 0x01000193
-
-/*
- * Print each legacy sysctl (approximately) only once.
- * To avoid making the tables non-const use a external
- * hash-table instead.
- * Worst case hash collision: 6, but very rarely.
- * NOTE! We don't use the SMP-safe bit tests. We simply
- * don't care enough.
- */
-static void warn_on_bintable(const int *name, int nlen)
-{
-	int i;
-	u32 hash = FNV32_OFFSET;
-
-	for (i = 0; i < nlen; i++)
-		hash = (hash ^ name[i]) * FNV32_PRIME;
-	hash %= WARN_ONCE_HASH_SIZE;
-	if (__test_and_set_bit(hash, warn_once_bitmap))
-		return;
-	deprecated_sysctl_warning(name, nlen);
-}
-
-static ssize_t do_sysctl(int __user *args_name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	int name[CTL_MAXNAME];
-	int i;
-
-	/* Check args->nlen. */
-	if (nlen < 0 || nlen > CTL_MAXNAME)
-		return -ENOTDIR;
-	/* Read in the sysctl name for simplicity */
-	for (i = 0; i < nlen; i++)
-		if (get_user(name[i], args_name + i))
-			return -EFAULT;
-
-	warn_on_bintable(name, nlen);
-
-	return binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);
-}
-
-SYSCALL_DEFINE1(sysctl, struct __sysctl_args __user *, args)
-{
-	struct __sysctl_args tmp;
-	size_t oldlen = 0;
-	ssize_t result;
-
-	if (copy_from_user(&tmp, args, sizeof(tmp)))
-		return -EFAULT;
-
-	if (tmp.oldval && !tmp.oldlenp)
-		return -EFAULT;
-
-	if (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))
-		return -EFAULT;
-
-	result = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,
-			   tmp.newval, tmp.newlen);
-
-	if (result >= 0) {
-		oldlen = result;
-		result = 0;
-	}
-
-	if (tmp.oldlenp && put_user(oldlen, tmp.oldlenp))
-		return -EFAULT;
-
-	return result;
-}
-
-
-#ifdef CONFIG_COMPAT
-#include <asm/compat.h>
-
-struct compat_sysctl_args {
-	compat_uptr_t	name;
-	int		nlen;
-	compat_uptr_t	oldval;
-	compat_uptr_t	oldlenp;
-	compat_uptr_t	newval;
-	compat_size_t	newlen;
-	compat_ulong_t	__unused[4];
-};
-
-asmlinkage long compat_sys_sysctl(struct compat_sysctl_args __user *args)
-{
-	struct compat_sysctl_args tmp;
-	compat_size_t __user *compat_oldlenp;
-	size_t oldlen = 0;
-	ssize_t result;
-
-	if (copy_from_user(&tmp, args, sizeof(tmp)))
-		return -EFAULT;
-
-	if (tmp.oldval && !tmp.oldlenp)
-		return -EFAULT;
-
-	compat_oldlenp = compat_ptr(tmp.oldlenp);
-	if (compat_oldlenp && get_user(oldlen, compat_oldlenp))
-		return -EFAULT;
-
-	result = do_sysctl(compat_ptr(tmp.name), tmp.nlen,
-			   compat_ptr(tmp.oldval), oldlen,
-			   compat_ptr(tmp.newval), tmp.newlen);
-
-	if (result >= 0) {
-		oldlen = result;
-		result = 0;
-	}
-
-	if (compat_oldlenp && put_user(oldlen, compat_oldlenp))
-		return -EFAULT;
-
-	return result;
-}
-
-#endif /* CONFIG_COMPAT */
diff -urN flo-ElementalX-5.00/mm/mmzone.c flo-ElementalX-5.00-patched/mm/mmzone.c
--- flo-ElementalX-5.00/mm/mmzone.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/mm/mmzone.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,88 +0,0 @@
-/*
- * linux/mm/mmzone.c
- *
- * management codes for pgdats and zones.
- */
-
-
-#include <linux/stddef.h>
-#include <linux/mm.h>
-#include <linux/mmzone.h>
-
-struct pglist_data *first_online_pgdat(void)
-{
-	return NODE_DATA(first_online_node);
-}
-
-struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)
-{
-	int nid = next_online_node(pgdat->node_id);
-
-	if (nid == MAX_NUMNODES)
-		return NULL;
-	return NODE_DATA(nid);
-}
-
-/*
- * next_zone - helper magic for for_each_zone()
- */
-struct zone *next_zone(struct zone *zone)
-{
-	pg_data_t *pgdat = zone->zone_pgdat;
-
-	if (zone < pgdat->node_zones + MAX_NR_ZONES - 1)
-		zone++;
-	else {
-		pgdat = next_online_pgdat(pgdat);
-		if (pgdat)
-			zone = pgdat->node_zones;
-		else
-			zone = NULL;
-	}
-	return zone;
-}
-
-static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)
-{
-#ifdef CONFIG_NUMA
-	return node_isset(zonelist_node_idx(zref), *nodes);
-#else
-	return 1;
-#endif /* CONFIG_NUMA */
-}
-
-/* Returns the next zone at or below highest_zoneidx in a zonelist */
-struct zoneref *next_zones_zonelist(struct zoneref *z,
-					enum zone_type highest_zoneidx,
-					nodemask_t *nodes,
-					struct zone **zone)
-{
-	/*
-	 * Find the next suitable zone to use for the allocation.
-	 * Only filter based on nodemask if it's set
-	 */
-	if (likely(nodes == NULL))
-		while (zonelist_zone_idx(z) > highest_zoneidx)
-			z++;
-	else
-		while (zonelist_zone_idx(z) > highest_zoneidx ||
-				(z->zone && !zref_in_nodemask(z, nodes)))
-			z++;
-
-	*zone = zonelist_zone(z);
-	return z;
-}
-
-#ifdef CONFIG_ARCH_HAS_HOLES_MEMORYMODEL
-int memmap_valid_within(unsigned long pfn,
-					struct page *page, struct zone *zone)
-{
-	if (page_to_pfn(page) != pfn)
-		return 0;
-
-	if (page_zone(page) != zone)
-		return 0;
-
-	return 1;
-}
-#endif /* CONFIG_ARCH_HAS_HOLES_MEMORYMODEL */
diff -urN flo-ElementalX-5.00/net/bluetooth/Kconfig flo-ElementalX-5.00-patched/net/bluetooth/Kconfig
--- flo-ElementalX-5.00/net/bluetooth/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/Kconfig	2016-06-02 00:28:55.000000000 +0000
@@ -11,8 +11,6 @@
 	select CRYPTO_BLKCIPHER
 	select CRYPTO_AES
 	select CRYPTO_ECB
-	select CRYPTO_HMAC
-	select CRYPTO_SHA256
 	help
 	  Bluetooth is low-cost, low-power, short-range wireless technology.
 	  It was designed as a replacement for cables and other short-range
diff -urN flo-ElementalX-5.00/net/bluetooth/Makefile flo-ElementalX-5.00-patched/net/bluetooth/Makefile
--- flo-ElementalX-5.00/net/bluetooth/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/Makefile	2016-06-02 00:28:55.000000000 +0000
@@ -9,5 +9,4 @@
 obj-$(CONFIG_BT_HIDP)	+= hidp/
 
 bluetooth-y := af_bluetooth.o hci_core.o hci_conn.o hci_event.o mgmt.o \
-	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o \
-	amp.o
+	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o
diff -urN flo-ElementalX-5.00/net/bluetooth/af_bluetooth.c flo-ElementalX-5.00-patched/net/bluetooth/af_bluetooth.c
--- flo-ElementalX-5.00/net/bluetooth/af_bluetooth.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/af_bluetooth.c	2016-06-02 00:28:55.000000000 +0000
@@ -40,15 +40,6 @@
 
 #include <net/bluetooth/bluetooth.h>
 
-#ifdef CONFIG_ANDROID_PARANOID_NETWORK
-#include <linux/android_aid.h>
-#endif
-
-#ifndef CONFIG_BT_SOCK_DEBUG
-#undef  BT_DBG
-#define BT_DBG(D...)
-#endif
-
 #define VERSION "2.16"
 
 /* Bluetooth sockets */
@@ -80,19 +71,16 @@
 	"slock-AF_BLUETOOTH-BTPROTO_AVDTP",
 };
 
-static inline void bt_sock_reclassify_lock(struct socket *sock, int proto)
+void bt_sock_reclassify_lock(struct sock *sk, int proto)
 {
-	struct sock *sk = sock->sk;
-
-	if (!sk)
-		return;
-
+	BUG_ON(!sk);
 	BUG_ON(sock_owned_by_user(sk));
 
 	sock_lock_init_class_and_name(sk,
 			bt_slock_key_strings[proto], &bt_slock_key[proto],
 				bt_key_strings[proto], &bt_lock_key[proto]);
 }
+EXPORT_SYMBOL(bt_sock_reclassify_lock);
 
 int bt_sock_register(int proto, const struct net_proto_family *ops)
 {
@@ -134,40 +122,11 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
-#ifdef CONFIG_ANDROID_PARANOID_NETWORK
-static inline int current_has_bt_admin(void)
-{
-	return (!current_euid() || in_egroup_p(AID_NET_BT_ADMIN));
-}
-
-static inline int current_has_bt(void)
-{
-	return (current_has_bt_admin() || in_egroup_p(AID_NET_BT));
-}
-# else
-static inline int current_has_bt_admin(void)
-{
-	return 1;
-}
-
-static inline int current_has_bt(void)
-{
-	return 1;
-}
-#endif
-
 static int bt_sock_create(struct net *net, struct socket *sock, int proto,
 			  int kern)
 {
 	int err;
 
-	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
-			proto == BTPROTO_L2CAP) {
-		if (!current_has_bt())
-			return -EPERM;
-	} else if (!current_has_bt_admin())
-		return -EPERM;
-
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
@@ -183,7 +142,8 @@
 
 	if (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {
 		err = bt_proto[proto]->create(net, sock, proto, kern);
-		bt_sock_reclassify_lock(sock, proto);
+		if (!err)
+			bt_sock_reclassify_lock(sock->sk, proto);
 		module_put(bt_proto[proto]->owner);
 	}
 
@@ -194,17 +154,17 @@
 
 void bt_sock_link(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock_bh(&l->lock);
+	write_lock(&l->lock);
 	sk_add_node(sk, &l->head);
-	write_unlock_bh(&l->lock);
+	write_unlock(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_link);
 
 void bt_sock_unlink(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock_bh(&l->lock);
+	write_lock(&l->lock);
 	sk_del_node_init(sk);
-	write_unlock_bh(&l->lock);
+	write_unlock(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_unlink);
 
@@ -237,15 +197,14 @@
 
 	BT_DBG("parent %p", parent);
 
-	local_bh_disable();
 	list_for_each_safe(p, n, &bt_sk(parent)->accept_q) {
 		sk = (struct sock *) list_entry(p, struct bt_sock, accept_q);
 
-		bh_lock_sock(sk);
+		lock_sock(sk);
 
 		/* FIXME: Is this check still needed */
 		if (sk->sk_state == BT_CLOSED) {
-			bh_unlock_sock(sk);
+			release_sock(sk);
 			bt_accept_unlink(sk);
 			continue;
 		}
@@ -256,14 +215,12 @@
 			if (newsock)
 				sock_graft(sk, newsock);
 
-			bh_unlock_sock(sk);
-			local_bh_enable();
+			release_sock(sk);
 			return sk;
 		}
 
-		bh_unlock_sock(sk);
+		release_sock(sk);
 	}
-	local_bh_enable();
 
 	return NULL;
 }
@@ -290,8 +247,6 @@
 		return err;
 	}
 
-	msg->msg_namelen = 0;
-
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
@@ -349,8 +304,6 @@
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
-	msg->msg_namelen = 0;
-
 	BT_DBG("sk %p size %zu", sk, size);
 
 	lock_sock(sk);
@@ -493,7 +446,7 @@
 			sk->sk_state == BT_CONFIG)
 		return mask;
 
-	if (sock_writeable(sk))
+	if (!bt_sk(sk)->suspended && sock_writeable(sk))
 		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
 	else
 		set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
@@ -558,9 +511,8 @@
 	BT_DBG("sk %p", sk);
 
 	add_wait_queue(sk_sleep(sk), &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
 	while (sk->sk_state != state) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
 		if (!timeo) {
 			err = -EINPROGRESS;
 			break;
@@ -574,12 +526,13 @@
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
 			break;
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 	return err;
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/amp.c flo-ElementalX-5.00-patched/net/bluetooth/amp.c
--- flo-ElementalX-5.00/net/bluetooth/amp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/amp.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,2041 +0,0 @@
-/*
-   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 and
-   only version 2 as published by the Free Software Foundation.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-*/
-
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-
-#include <linux/skbuff.h>
-#include <linux/list.h>
-#include <linux/workqueue.h>
-#include <linux/timer.h>
-
-#include <linux/crypto.h>
-#include <linux/scatterlist.h>
-#include <linux/err.h>
-#include <crypto/hash.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
-#include <net/bluetooth/amp.h>
-
-static struct workqueue_struct *amp_workqueue;
-
-LIST_HEAD(amp_mgr_list);
-DEFINE_RWLOCK(amp_mgr_list_lock);
-
-static int send_a2mp(struct socket *sock, u8 *data, int len);
-
-static void ctx_timeout(unsigned long data);
-
-static void launch_ctx(struct amp_mgr *mgr);
-static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data);
-static int kill_ctx(struct amp_ctx *ctx);
-static int cancel_ctx(struct amp_ctx *ctx);
-
-static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst);
-
-static void remove_amp_mgr(struct amp_mgr *mgr)
-{
-	BT_DBG("mgr %p", mgr);
-
-	write_lock(&amp_mgr_list_lock);
-	list_del(&mgr->list);
-	write_unlock(&amp_mgr_list_lock);
-
-	read_lock(&mgr->ctx_list_lock);
-	while (!list_empty(&mgr->ctx_list)) {
-		struct amp_ctx *ctx;
-		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
-		read_unlock(&mgr->ctx_list_lock);
-		BT_DBG("kill ctx %p", ctx);
-		kill_ctx(ctx);
-		read_lock(&mgr->ctx_list_lock);
-	}
-	read_unlock(&mgr->ctx_list_lock);
-
-	kfree(mgr->ctrls);
-
-	kfree(mgr);
-}
-
-static struct amp_mgr *get_amp_mgr_sk(struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct amp_mgr *found = NULL;
-
-	read_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if ((mgr->a2mp_sock) && (mgr->a2mp_sock->sk == sk)) {
-			found = mgr;
-			break;
-		}
-	}
-	read_unlock(&amp_mgr_list_lock);
-	return found;
-}
-
-static struct amp_mgr *get_create_amp_mgr(struct hci_conn *hcon,
-						struct sk_buff *skb)
-{
-	struct amp_mgr *mgr;
-
-	write_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if (mgr->l2cap_conn == hcon->l2cap_data) {
-			BT_DBG("found %p", mgr);
-			write_unlock(&amp_mgr_list_lock);
-			goto gc_finished;
-		}
-	}
-	write_unlock(&amp_mgr_list_lock);
-
-	mgr = kzalloc(sizeof(*mgr), GFP_ATOMIC);
-	if (!mgr)
-		return NULL;
-
-	mgr->l2cap_conn = hcon->l2cap_data;
-	mgr->next_ident = 1;
-	INIT_LIST_HEAD(&mgr->ctx_list);
-	rwlock_init(&mgr->ctx_list_lock);
-	mgr->skb = skb;
-	BT_DBG("hcon %p mgr %p", hcon, mgr);
-	mgr->a2mp_sock = open_fixed_channel(&hcon->hdev->bdaddr, &hcon->dst);
-	if (!mgr->a2mp_sock) {
-		kfree(mgr);
-		return NULL;
-	}
-	write_lock(&amp_mgr_list_lock);
-	list_add(&(mgr->list), &amp_mgr_list);
-	write_unlock(&amp_mgr_list_lock);
-
-gc_finished:
-	return mgr;
-}
-
-static struct amp_ctrl *get_ctrl(struct amp_mgr *mgr, u8 remote_id)
-{
-	if ((mgr->ctrls) && (mgr->ctrls->id == remote_id))
-		return mgr->ctrls;
-	else
-		return NULL;
-}
-
-static struct amp_ctrl *get_create_ctrl(struct amp_mgr *mgr, u8 id)
-{
-	struct amp_ctrl *ctrl;
-
-	BT_DBG("mgr %p, id %d", mgr, id);
-	if ((mgr->ctrls) && (mgr->ctrls->id == id))
-		ctrl = mgr->ctrls;
-	else {
-		kfree(mgr->ctrls);
-		ctrl = kzalloc(sizeof(struct amp_ctrl), GFP_ATOMIC);
-		if (ctrl) {
-			ctrl->mgr = mgr;
-			ctrl->id = id;
-		}
-		mgr->ctrls = ctrl;
-	}
-
-	return ctrl;
-}
-
-static struct amp_ctx *create_ctx(u8 type, u8 state)
-{
-	struct amp_ctx *ctx = NULL;
-
-	ctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);
-	if (ctx) {
-		ctx->type = type;
-		ctx->state = state;
-		init_timer(&(ctx->timer));
-		ctx->timer.function = ctx_timeout;
-		ctx->timer.data = (unsigned long) ctx;
-	}
-	BT_DBG("ctx %p, type %d", ctx, type);
-	return ctx;
-}
-
-static inline void start_ctx(struct amp_mgr *mgr, struct amp_ctx *ctx)
-{
-	BT_DBG("ctx %p", ctx);
-	write_lock(&mgr->ctx_list_lock);
-	list_add(&ctx->list, &mgr->ctx_list);
-	write_unlock(&mgr->ctx_list_lock);
-	ctx->mgr = mgr;
-	execute_ctx(ctx, AMP_INIT, 0);
-}
-
-static void destroy_ctx(struct amp_ctx *ctx)
-{
-	struct amp_mgr *mgr = ctx->mgr;
-
-	BT_DBG("ctx %p deferred %p", ctx, ctx->deferred);
-	del_timer(&ctx->timer);
-	write_lock(&mgr->ctx_list_lock);
-	list_del(&ctx->list);
-	write_unlock(&mgr->ctx_list_lock);
-	if (ctx->deferred)
-		execute_ctx(ctx->deferred, AMP_INIT, 0);
-	kfree(ctx);
-}
-
-static struct amp_ctx *get_ctx_mgr(struct amp_mgr *mgr, u8 type)
-{
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if (ctx->type == type) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_type(struct amp_ctx *cur, u8 type)
-{
-	struct amp_mgr *mgr = cur->mgr;
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if ((ctx->type == type) && (ctx != cur)) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_a2mp(struct amp_mgr *mgr, u8 ident)
-{
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if ((ctx->evt_type & AMP_A2MP_RSP) &&
-				(ctx->rsp_ident == ident)) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_hdev(struct hci_dev *hdev, u8 evt_type,
-					u16 evt_value)
-{
-	struct amp_mgr *mgr;
-	struct amp_ctx *fnd = NULL;
-
-	read_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		struct amp_ctx *ctx;
-		read_lock(&mgr->ctx_list_lock);
-		list_for_each_entry(ctx, &mgr->ctx_list, list) {
-			struct hci_dev *ctx_hdev;
-			ctx_hdev = hci_dev_get(ctx->id);
-			if ((ctx_hdev == hdev) && (ctx->evt_type & evt_type)) {
-				switch (evt_type) {
-				case AMP_HCI_CMD_STATUS:
-				case AMP_HCI_CMD_CMPLT:
-					if (ctx->opcode == evt_value)
-						fnd = ctx;
-					break;
-				case AMP_HCI_EVENT:
-					if (ctx->evt_code == (u8) evt_value)
-						fnd = ctx;
-					break;
-				}
-			}
-			if (ctx_hdev)
-				hci_dev_put(ctx_hdev);
-
-			if (fnd)
-				break;
-		}
-		read_unlock(&mgr->ctx_list_lock);
-	}
-	read_unlock(&amp_mgr_list_lock);
-	return fnd;
-}
-
-static inline u8 next_ident(struct amp_mgr *mgr)
-{
-	if (++mgr->next_ident == 0)
-		mgr->next_ident = 1;
-	return mgr->next_ident;
-}
-
-static inline void send_a2mp_cmd2(struct amp_mgr *mgr, u8 ident, u8 code,
-				u16 len, void *data, u16 len2, void *data2)
-{
-	struct a2mp_cmd_hdr *hdr;
-	int plen;
-	u8 *p, *cmd;
-
-	BT_DBG("ident %d code 0x%02x", ident, code);
-	if (!mgr->a2mp_sock)
-		return;
-	plen = sizeof(*hdr) + len + len2;
-	cmd = kzalloc(plen, GFP_ATOMIC);
-	if (!cmd)
-		return;
-	hdr = (struct a2mp_cmd_hdr *) cmd;
-	hdr->code  = code;
-	hdr->ident = ident;
-	hdr->len   = cpu_to_le16(len+len2);
-	p = cmd + sizeof(*hdr);
-	memcpy(p, data, len);
-	p += len;
-	memcpy(p, data2, len2);
-	send_a2mp(mgr->a2mp_sock, cmd, plen);
-	kfree(cmd);
-}
-
-static inline void send_a2mp_cmd(struct amp_mgr *mgr, u8 ident,
-				u8 code, u16 len, void *data)
-{
-	send_a2mp_cmd2(mgr, ident, code, len, data, 0, NULL);
-}
-
-static inline int command_rej(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_cmd_rej *rej;
-	struct amp_ctx *ctx;
-
-	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
-	rej = (struct a2mp_cmd_rej *) skb_pull(skb, sizeof(*hdr));
-	if (skb->len < sizeof(*rej))
-		return -EINVAL;
-	BT_DBG("reason %d", le16_to_cpu(rej->reason));
-	ctx = get_ctx_a2mp(mgr, hdr->ident);
-	if (ctx)
-		kill_ctx(ctx);
-	skb_pull(skb, sizeof(*rej));
-	return 0;
-}
-
-static int send_a2mp_cl(struct amp_mgr *mgr, u8 ident, u8 code, u16 len,
-			void *msg)
-{
-	struct a2mp_cl clist[16];
-	struct a2mp_cl *cl;
-	struct hci_dev *hdev;
-	int num_ctrls = 1, id;
-
-	cl = clist;
-	cl->id  = 0;
-	cl->type = 0;
-	cl->status = 1;
-
-	for (id = 0; id < 16; ++id) {
-		hdev = hci_dev_get(id);
-		if (hdev) {
-			if ((hdev->amp_type != HCI_BREDR) &&
-			test_bit(HCI_UP, &hdev->flags)) {
-				(cl + num_ctrls)->id  = hdev->id;
-				(cl + num_ctrls)->type = hdev->amp_type;
-				(cl + num_ctrls)->status = hdev->amp_status;
-				++num_ctrls;
-			}
-			hci_dev_put(hdev);
-		}
-	}
-	send_a2mp_cmd2(mgr, ident, code, len, msg,
-						num_ctrls*sizeof(*cl), clist);
-
-	return 0;
-}
-
-static void send_a2mp_change_notify(void)
-{
-	struct amp_mgr *mgr;
-
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if (mgr->discovered)
-			send_a2mp_cl(mgr, next_ident(mgr),
-					A2MP_CHANGE_NOTIFY, 0, NULL);
-	}
-}
-
-static inline int discover_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_discover_req *req;
-	u16 *efm;
-	struct a2mp_discover_rsp rsp;
-
-	req = (struct a2mp_discover_req *) skb_pull(skb, sizeof(*hdr));
-	if (skb->len < sizeof(*req))
-		return -EINVAL;
-	efm = (u16 *) skb_pull(skb, sizeof(*req));
-
-	BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(req->mtu),
-		le16_to_cpu(req->ext_feat));
-
-	while (le16_to_cpu(req->ext_feat) & 0x8000) {
-		if (skb->len < sizeof(*efm))
-			return -EINVAL;
-		req->ext_feat = *efm;
-		BT_DBG("efm 0x%4.4x", le16_to_cpu(req->ext_feat));
-		efm = (u16 *) skb_pull(skb, sizeof(*efm));
-	}
-
-	rsp.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
-	rsp.ext_feat = 0;
-
-	mgr->discovered = 1;
-
-	return send_a2mp_cl(mgr, hdr->ident, A2MP_DISCOVER_RSP,
-				sizeof(rsp), &rsp);
-}
-
-static inline int change_notify(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_cl *cl;
-
-	cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*hdr));
-	while (skb->len >= sizeof(*cl)) {
-		struct amp_ctrl *ctrl;
-		if (cl->id != 0) {
-			ctrl = get_create_ctrl(mgr, cl->id);
-			if (ctrl != NULL) {
-				ctrl->type = cl->type;
-				ctrl->status = cl->status;
-			}
-		}
-		cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
-	}
-
-	/* TODO find controllers in manager that were not on received */
-	/*      controller list and destroy them */
-	send_a2mp_cmd(mgr, hdr->ident, A2MP_CHANGE_RSP, 0, NULL);
-
-	return 0;
-}
-
-static inline int getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	u8 *data;
-	int id;
-	struct hci_dev *hdev;
-	struct a2mp_getinfo_rsp rsp;
-
-	data = (u8 *) skb_pull(skb, sizeof(*hdr));
-	if (le16_to_cpu(hdr->len) < sizeof(*data))
-		return -EINVAL;
-	if (skb->len < sizeof(*data))
-		return -EINVAL;
-	id = *data;
-	skb_pull(skb, sizeof(*data));
-	rsp.id = id;
-	rsp.status = 1;
-
-	BT_DBG("id %d", id);
-	hdev = hci_dev_get(id);
-
-	if (hdev && hdev->amp_type != HCI_BREDR) {
-		rsp.status = 0;
-		rsp.total_bw = cpu_to_le32(hdev->amp_total_bw);
-		rsp.max_bw = cpu_to_le32(hdev->amp_max_bw);
-		rsp.min_latency = cpu_to_le32(hdev->amp_min_latency);
-		rsp.pal_cap = cpu_to_le16(hdev->amp_pal_cap);
-		rsp.assoc_size = cpu_to_le16(hdev->amp_assoc_size);
-	}
-
-	send_a2mp_cmd(mgr, hdr->ident, A2MP_GETINFO_RSP, sizeof(rsp), &rsp);
-
-	if (hdev)
-		hci_dev_put(hdev);
-
-	return 0;
-}
-
-static void create_physical(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct amp_ctx *ctx = NULL;
-
-	BT_DBG("conn %p", conn);
-	mgr = get_create_amp_mgr(conn->hcon, NULL);
-	if (!mgr)
-		goto cp_finished;
-	BT_DBG("mgr %p", mgr);
-	ctx = create_ctx(AMP_CREATEPHYSLINK, AMP_CPL_INIT);
-	if (!ctx)
-		goto cp_finished;
-	ctx->sk = sk;
-	sock_hold(sk);
-	start_ctx(mgr, ctx);
-	return;
-
-cp_finished:
-	l2cap_amp_physical_complete(-ENOMEM, 0, 0, sk);
-}
-
-static void accept_physical(struct l2cap_conn *lcon, u8 id, struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	struct amp_ctx *aplctx = NULL;
-	u8 remote_id = 0;
-	int result = -EINVAL;
-
-	BT_DBG("lcon %p", lcon);
-	hdev = hci_dev_get(id);
-	if (!hdev)
-		goto ap_finished;
-	BT_DBG("hdev %p", hdev);
-	mgr = get_create_amp_mgr(lcon->hcon, NULL);
-	if (!mgr)
-		goto ap_finished;
-	BT_DBG("mgr %p", mgr);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
-					&mgr->l2cap_conn->hcon->dst);
-	if (conn) {
-		BT_DBG("conn %p", hdev);
-		result = 0;
-		remote_id = conn->dst_id;
-		goto ap_finished;
-	}
-	aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
-	if (!aplctx)
-		goto ap_finished;
-	aplctx->sk = sk;
-	sock_hold(sk);
-	return;
-
-ap_finished:
-	if (hdev)
-		hci_dev_put(hdev);
-	l2cap_amp_physical_complete(result, id, remote_id, sk);
-}
-
-static int getampassoc_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct amp_ctx *ctx;
-	struct a2mp_getampassoc_req *req;
-
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (struct a2mp_getampassoc_req *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-
-	ctx = create_ctx(AMP_GETAMPASSOC, AMP_GAA_INIT);
-	if (!ctx)
-		return -ENOMEM;
-	ctx->id = req->id;
-	ctx->d.gaa.req_ident = hdr->ident;
-	ctx->hdev = hci_dev_get(ctx->id);
-	if (ctx->hdev)
-		ctx->d.gaa.assoc = kmalloc(ctx->hdev->amp_assoc_size,
-						GFP_ATOMIC);
-	start_ctx(mgr, ctx);
-	return 0;
-}
-
-static u8 getampassoc_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct sk_buff *skb = (struct sk_buff *) data;
-	struct hci_cp_read_local_amp_assoc cp;
-	struct hci_rp_read_local_amp_assoc *rp;
-	struct a2mp_getampassoc_rsp rsp;
-	u16 rem_len;
-	u16 frag_len;
-
-	rsp.status = 1;
-	if ((evt_type == AMP_KILLED) || (!ctx->hdev) || (!ctx->d.gaa.assoc))
-		goto gaa_finished;
-
-	switch (ctx->state) {
-	case AMP_GAA_INIT:
-		ctx->state = AMP_GAA_RLAA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
-		ctx->d.gaa.len_so_far = 0;
-		cp.phy_handle = 0;
-		cp.len_so_far = 0;
-		cp.max_len = ctx->hdev->amp_assoc_size;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		break;
-
-	case AMP_GAA_RLAA_COMPLETE:
-		if (skb->len < 4)
-			goto gaa_finished;
-		rp = (struct hci_rp_read_local_amp_assoc *) skb->data;
-		if (rp->status)
-			goto gaa_finished;
-		rem_len = le16_to_cpu(rp->rem_len);
-		skb_pull(skb, 4);
-		frag_len = skb->len;
-
-		if (ctx->d.gaa.len_so_far + rem_len <=
-				ctx->hdev->amp_assoc_size) {
-			struct hci_cp_read_local_amp_assoc cp;
-			u8 *assoc = ctx->d.gaa.assoc + ctx->d.gaa.len_so_far;
-			memcpy(assoc, rp->frag, frag_len);
-			ctx->d.gaa.len_so_far += rem_len;
-			rem_len -= frag_len;
-			if (rem_len == 0) {
-				rsp.status = 0;
-				goto gaa_finished;
-			}
-			/* more assoc data to read */
-			cp.phy_handle = 0;
-			cp.len_so_far = ctx->d.gaa.len_so_far;
-			cp.max_len = ctx->hdev->amp_assoc_size;
-			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		}
-		break;
-
-	default:
-		goto gaa_finished;
-		break;
-	}
-	return 0;
-
-gaa_finished:
-	rsp.id = ctx->id;
-	send_a2mp_cmd2(ctx->mgr, ctx->d.gaa.req_ident, A2MP_GETAMPASSOC_RSP,
-			sizeof(rsp), &rsp,
-			ctx->d.gaa.len_so_far, ctx->d.gaa.assoc);
-	kfree(ctx->d.gaa.assoc);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	return 1;
-}
-
-struct hmac_sha256_result {
-	struct completion completion;
-	int err;
-};
-
-static void hmac_sha256_final(struct crypto_async_request *req, int err)
-{
-	struct hmac_sha256_result *r = req->data;
-	if (err == -EINPROGRESS)
-		return;
-	r->err = err;
-	complete(&r->completion);
-}
-
-int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize,
-		u8 *output, u8 outlen)
-{
-	int ret = 0;
-	struct crypto_ahash *tfm;
-	struct scatterlist sg;
-	struct ahash_request *req;
-	struct hmac_sha256_result tresult;
-	void *hash_buff = NULL;
-
-	unsigned char hash_result[64];
-	int i;
-
-	memset(output, 0, outlen);
-
-	init_completion(&tresult.completion);
-
-	tfm = crypto_alloc_ahash("hmac(sha256)", CRYPTO_ALG_TYPE_AHASH,
-				CRYPTO_ALG_TYPE_AHASH_MASK);
-	if (IS_ERR(tfm)) {
-		BT_DBG("crypto_alloc_ahash failed");
-		ret = PTR_ERR(tfm);
-		goto err_tfm;
-	}
-
-	req = ahash_request_alloc(tfm, GFP_KERNEL);
-	if (!req) {
-		BT_DBG("failed to allocate request for hmac(sha256)");
-		ret = -ENOMEM;
-		goto err_req;
-	}
-
-	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
-					hmac_sha256_final, &tresult);
-
-	hash_buff = kzalloc(psize, GFP_KERNEL);
-	if (!hash_buff) {
-		BT_DBG("failed to kzalloc hash_buff");
-		ret = -ENOMEM;
-		goto err_hash_buf;
-	}
-
-	memset(hash_result, 0, 64);
-	memcpy(hash_buff, plaintext, psize);
-	sg_init_one(&sg, hash_buff, psize);
-
-	if (ksize) {
-		crypto_ahash_clear_flags(tfm, ~0);
-		ret = crypto_ahash_setkey(tfm, key, ksize);
-
-		if (ret) {
-			BT_DBG("crypto_ahash_setkey failed");
-			goto err_setkey;
-		}
-	}
-
-	ahash_request_set_crypt(req, &sg, hash_result, psize);
-	ret = crypto_ahash_digest(req);
-
-	BT_DBG("ret 0x%x", ret);
-
-	switch (ret) {
-	case 0:
-		for (i = 0; i < outlen; i++)
-			output[i] = hash_result[i];
-		break;
-	case -EINPROGRESS:
-	case -EBUSY:
-		ret = wait_for_completion_interruptible(&tresult.completion);
-		if (!ret && !tresult.err) {
-			INIT_COMPLETION(tresult.completion);
-			break;
-		} else {
-			BT_DBG("wait_for_completion_interruptible failed");
-			if (!ret)
-				ret = tresult.err;
-			goto out;
-		}
-	default:
-		goto out;
-	}
-
-out:
-err_setkey:
-	kfree(hash_buff);
-err_hash_buf:
-	ahash_request_free(req);
-err_req:
-	crypto_free_ahash(tfm);
-err_tfm:
-	return ret;
-}
-
-static void show_key(u8 *k)
-{
-	int i = 0;
-	for (i = 0; i < 32; i += 8)
-		BT_DBG("    %02x %02x %02x %02x %02x %02x %02x %02x",
-				*(k+i+0), *(k+i+1), *(k+i+2), *(k+i+3),
-				*(k+i+4), *(k+i+5), *(k+i+6), *(k+i+7));
-}
-
-static int physlink_security(struct hci_conn *conn, u8 *data, u8 *len, u8 *type)
-{
-	u8 bt2_key[32];
-	u8 gamp_key[32];
-	u8 b802_key[32];
-	int result;
-
-	if (!hci_conn_check_link_mode(conn))
-		return -EACCES;
-
-	BT_DBG("key_type %d", conn->key_type);
-	if (conn->key_type < 3)
-		return -EACCES;
-
-	*type = conn->key_type;
-	*len = 32;
-	memcpy(&bt2_key[0], conn->link_key, 16);
-	memcpy(&bt2_key[16], conn->link_key, 16);
-	result = hmac_sha256(bt2_key, 32, "gamp", 4, gamp_key, 32);
-	if (result)
-		goto ps_finished;
-
-	if (conn->key_type == 3) {
-		BT_DBG("gamp_key");
-		show_key(gamp_key);
-		memcpy(data, gamp_key, 32);
-		goto ps_finished;
-	}
-
-	result = hmac_sha256(gamp_key, 32, "802b", 4, b802_key, 32);
-	if (result)
-		goto ps_finished;
-
-	BT_DBG("802b_key");
-	show_key(b802_key);
-	memcpy(data, b802_key, 32);
-
-ps_finished:
-	return result;
-}
-
-static u8 amp_next_handle;
-static inline u8 physlink_handle(struct hci_dev *hdev)
-{
-	/* TODO amp_next_handle should be part of hci_dev */
-	if (amp_next_handle == 0)
-		amp_next_handle = 1;
-	return amp_next_handle++;
-}
-
-/* Start an Accept Physical Link sequence */
-static int createphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct amp_ctx *ctx = NULL;
-	struct a2mp_createphyslink_req *req;
-
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (struct a2mp_createphyslink_req *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-	BT_DBG("local_id %d, remote_id %d", req->local_id, req->remote_id);
-
-	/* initialize the context */
-	ctx = create_ctx(AMP_ACCEPTPHYSLINK, AMP_APL_INIT);
-	if (!ctx)
-		return -ENOMEM;
-	ctx->d.apl.req_ident = hdr->ident;
-	ctx->d.apl.remote_id = req->local_id;
-	ctx->id = req->remote_id;
-
-	/* add the supplied remote assoc to the context */
-	ctx->d.apl.remote_assoc = kmalloc(skb->len, GFP_ATOMIC);
-	if (ctx->d.apl.remote_assoc)
-		memcpy(ctx->d.apl.remote_assoc, skb->data, skb->len);
-	ctx->d.apl.len_so_far = 0;
-	ctx->d.apl.rem_len = skb->len;
-	skb_pull(skb, skb->len);
-	ctx->hdev = hci_dev_get(ctx->id);
-	start_ctx(mgr, ctx);
-	return 0;
-}
-
-static u8 acceptphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct sk_buff *skb = data;
-	struct hci_cp_accept_phys_link acp;
-	struct hci_cp_write_remote_amp_assoc wcp;
-	struct hci_rp_write_remote_amp_assoc *wrp;
-	struct hci_ev_cmd_status *cs = data;
-	struct hci_ev_phys_link_complete *ev;
-	struct a2mp_createphyslink_rsp rsp;
-	struct amp_ctx *cplctx;
-	struct amp_ctx *aplctx;
-	u16 frag_len;
-	struct hci_conn *conn;
-	int result;
-
-	BT_DBG("state %d", ctx->state);
-	result = -EINVAL;
-	rsp.status = 1;        /* Invalid Controller ID */
-	if (!ctx->hdev || !test_bit(HCI_UP, &ctx->hdev->flags))
-		goto apl_finished;
-	if (evt_type == AMP_KILLED) {
-		result = -EAGAIN;
-		rsp.status = 4;        /* Disconnect request received */
-		goto apl_finished;
-	}
-	if (!ctx->d.apl.remote_assoc) {
-		result = -ENOMEM;
-		rsp.status = 2;        /* Unable to Start */
-		goto apl_finished;
-	}
-
-	switch (ctx->state) {
-	case AMP_APL_INIT:
-		BT_DBG("local_id %d, remote_id %d",
-			ctx->id, ctx->d.apl.remote_id);
-		conn = hci_conn_hash_lookup_id(ctx->hdev,
-					&ctx->mgr->l2cap_conn->hcon->dst,
-					ctx->d.apl.remote_id);
-		if (conn) {
-			result = -EEXIST;
-			rsp.status = 5;   /* Already Exists */
-			goto apl_finished;
-		}
-
-		aplctx = get_ctx_type(ctx, AMP_ACCEPTPHYSLINK);
-		if ((aplctx) &&
-			(aplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
-			BT_DBG("deferred to %p", aplctx);
-			aplctx->deferred = ctx;
-			break;
-		}
-
-		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
-		if ((cplctx) &&
-			(cplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
-			struct hci_conn *bcon = ctx->mgr->l2cap_conn->hcon;
-			BT_DBG("local %s remote %s",
-				batostr(&bcon->hdev->bdaddr),
-				batostr(&bcon->dst));
-			if ((cplctx->state < AMP_CPL_PL_COMPLETE) ||
-				(bacmp(&bcon->hdev->bdaddr, &bcon->dst) < 0)) {
-				BT_DBG("COLLISION LOSER");
-				cplctx->deferred = ctx;
-				cancel_ctx(cplctx);
-				break;
-			} else {
-				BT_DBG("COLLISION WINNER");
-				result = -EISCONN;
-				rsp.status = 3;    /* Collision */
-				goto apl_finished;
-			}
-		}
-
-		result = physlink_security(ctx->mgr->l2cap_conn->hcon, acp.data,
-						&acp.key_len, &acp.type);
-		if (result) {
-			BT_DBG("SECURITY");
-			rsp.status = 6;    /* Security Violation */
-			goto apl_finished;
-		}
-
-		ctx->d.apl.phy_handle = physlink_handle(ctx->hdev);
-		ctx->state = AMP_APL_APL_STATUS;
-		ctx->evt_type = AMP_HCI_CMD_STATUS;
-		ctx->opcode = HCI_OP_ACCEPT_PHYS_LINK;
-		acp.phy_handle = ctx->d.apl.phy_handle;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(acp), &acp);
-		break;
-
-	case AMP_APL_APL_STATUS:
-		if (cs->status != 0)
-			goto apl_finished;
-		/* PAL will accept link, send a2mp response */
-		rsp.local_id = ctx->id;
-		rsp.remote_id = ctx->d.apl.remote_id;
-		rsp.status = 0;
-		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
-				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
-
-		/* send the first assoc fragment */
-		wcp.phy_handle = ctx->d.apl.phy_handle;
-		wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
-		wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
-		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-		memcpy(wcp.frag, ctx->d.apl.remote_assoc, frag_len);
-		ctx->state = AMP_APL_WRA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-		break;
-
-	case AMP_APL_WRA_COMPLETE:
-		/* received write remote amp assoc command complete event */
-		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
-		if (wrp->status != 0)
-			goto apl_finished;
-		if (wrp->phy_handle != ctx->d.apl.phy_handle)
-			goto apl_finished;
-		/* update progress */
-		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-		ctx->d.apl.len_so_far += frag_len;
-		ctx->d.apl.rem_len -= frag_len;
-		if (ctx->d.apl.rem_len > 0) {
-			u8 *assoc;
-			/* another assoc fragment to send */
-			wcp.phy_handle = ctx->d.apl.phy_handle;
-			wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
-			wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
-			frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-			assoc = ctx->d.apl.remote_assoc + ctx->d.apl.len_so_far;
-			memcpy(wcp.frag, assoc, frag_len);
-			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-			break;
-		}
-		/* wait for physical link complete event */
-		ctx->state = AMP_APL_PL_COMPLETE;
-		ctx->evt_type = AMP_HCI_EVENT;
-		ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
-		break;
-
-	case AMP_APL_PL_COMPLETE:
-		/* physical link complete event received */
-		if (skb->len < sizeof(*ev))
-			goto apl_finished;
-		ev = (struct hci_ev_phys_link_complete *) skb->data;
-		if (ev->phy_handle != ctx->d.apl.phy_handle)
-			break;
-		if (ev->status != 0)
-			goto apl_finished;
-		conn = hci_conn_hash_lookup_handle(ctx->hdev, ev->phy_handle);
-		if (!conn)
-			goto apl_finished;
-		result = 0;
-		BT_DBG("PL_COMPLETE phy_handle %x", ev->phy_handle);
-		conn->dst_id = ctx->d.apl.remote_id;
-		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
-		goto apl_finished;
-		break;
-
-	default:
-		goto apl_finished;
-		break;
-	}
-	return 0;
-
-apl_finished:
-	if (ctx->sk)
-		l2cap_amp_physical_complete(result, ctx->id,
-					ctx->d.apl.remote_id, ctx->sk);
-	if ((result) && (ctx->state < AMP_APL_PL_COMPLETE)) {
-		rsp.local_id = ctx->id;
-		rsp.remote_id = ctx->d.apl.remote_id;
-		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
-				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
-	}
-	kfree(ctx->d.apl.remote_assoc);
-	if (ctx->sk)
-		sock_put(ctx->sk);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	return 1;
-}
-
-static void cancel_cpl_ctx(struct amp_ctx *ctx, u8 reason)
-{
-	struct hci_cp_disconn_phys_link dcp;
-
-	ctx->state = AMP_CPL_PL_CANCEL;
-	ctx->evt_type = AMP_HCI_EVENT;
-	ctx->evt_code = HCI_EV_DISCONN_PHYS_LINK_COMPLETE;
-	dcp.phy_handle = ctx->d.cpl.phy_handle;
-	dcp.reason = reason;
-	hci_send_cmd(ctx->hdev, HCI_OP_DISCONN_PHYS_LINK, sizeof(dcp), &dcp);
-}
-
-static u8 createphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct amp_ctrl *ctrl;
-	struct sk_buff *skb = data;
-	struct a2mp_cmd_hdr *hdr;
-	struct hci_ev_cmd_status *cs = data;
-	struct amp_ctx *cplctx;
-	struct a2mp_discover_req dreq;
-	struct a2mp_discover_rsp *drsp;
-	u16 *efm;
-	struct a2mp_getinfo_req greq;
-	struct a2mp_getinfo_rsp *grsp;
-	struct a2mp_cl *cl;
-	struct a2mp_getampassoc_req areq;
-	struct a2mp_getampassoc_rsp *arsp;
-	struct hci_cp_create_phys_link cp;
-	struct hci_cp_write_remote_amp_assoc wcp;
-	struct hci_rp_write_remote_amp_assoc *wrp;
-	struct hci_ev_channel_selected *cev;
-	struct hci_cp_read_local_amp_assoc rcp;
-	struct hci_rp_read_local_amp_assoc *rrp;
-	struct a2mp_createphyslink_req creq;
-	struct a2mp_createphyslink_rsp *crsp;
-	struct hci_ev_phys_link_complete *pev;
-	struct hci_ev_disconn_phys_link_complete *dev;
-	u8 *assoc, *rassoc, *lassoc;
-	u16 frag_len;
-	u16 rem_len;
-	int result = -EAGAIN;
-	struct hci_conn *conn;
-
-	BT_DBG("state %d", ctx->state);
-	if (evt_type == AMP_KILLED)
-		goto cpl_finished;
-
-	if (evt_type == AMP_CANCEL) {
-		if ((ctx->state < AMP_CPL_CPL_STATUS) ||
-			((ctx->state == AMP_CPL_PL_COMPLETE) &&
-			!(ctx->evt_type & AMP_HCI_EVENT)))
-			goto cpl_finished;
-
-		cancel_cpl_ctx(ctx, 0x16);
-		return 0;
-	}
-
-	switch (ctx->state) {
-	case AMP_CPL_INIT:
-		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
-		if (cplctx) {
-			BT_DBG("deferred to %p", cplctx);
-			cplctx->deferred = ctx;
-			break;
-		}
-		ctx->state = AMP_CPL_DISC_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		dreq.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
-		dreq.ext_feat = 0;
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_DISCOVER_REQ,
-							sizeof(dreq), &dreq);
-		break;
-
-	case AMP_CPL_DISC_RSP:
-		drsp = (struct a2mp_discover_rsp *) skb_pull(skb, sizeof(*hdr));
-		if (skb->len < (sizeof(*drsp))) {
-			result = -EINVAL;
-			goto cpl_finished;
-		}
-
-		efm = (u16 *) skb_pull(skb, sizeof(*drsp));
-		BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(drsp->mtu),
-						le16_to_cpu(drsp->ext_feat));
-
-		while (le16_to_cpu(drsp->ext_feat) & 0x8000) {
-			if (skb->len < sizeof(*efm)) {
-				result = -EINVAL;
-				goto cpl_finished;
-			}
-			drsp->ext_feat = *efm;
-			BT_DBG("efm 0x%4.4x", le16_to_cpu(drsp->ext_feat));
-			efm = (u16 *) skb_pull(skb, sizeof(*efm));
-		}
-		cl = (struct a2mp_cl *) efm;
-
-		/* find the first remote and local controller with the
-		 * same type
-		 */
-		greq.id = 0;
-		result = -ENODEV;
-		while (skb->len >= sizeof(*cl)) {
-			if ((cl->id != 0) && (greq.id == 0)) {
-				struct hci_dev *hdev;
-				hdev = hci_dev_get_type(cl->type);
-				if (hdev) {
-					struct hci_conn *conn;
-					ctx->hdev = hdev;
-					ctx->id = hdev->id;
-					ctx->d.cpl.remote_id = cl->id;
-					conn = hci_conn_hash_lookup_ba(hdev,
-					    ACL_LINK,
-					    &ctx->mgr->l2cap_conn->hcon->dst);
-					if (conn) {
-						BT_DBG("PL_COMPLETE exists %x",
-							(int) conn->handle);
-						result = 0;
-					}
-					ctrl = get_create_ctrl(ctx->mgr,
-								cl->id);
-					if (ctrl) {
-						ctrl->type = cl->type;
-						ctrl->status = cl->status;
-					}
-					greq.id = cl->id;
-				}
-			}
-			cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
-		}
-		if ((!greq.id) || (!result))
-			goto cpl_finished;
-		ctx->state = AMP_CPL_GETINFO_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETINFO_REQ,
-							sizeof(greq), &greq);
-		break;
-
-	case AMP_CPL_GETINFO_RSP:
-		if (skb->len < sizeof(*grsp))
-			goto cpl_finished;
-		grsp = (struct a2mp_getinfo_rsp *) skb_pull(skb, sizeof(*hdr));
-		skb_pull(skb, sizeof(*grsp));
-		if (grsp->status)
-			goto cpl_finished;
-		if (grsp->id != ctx->d.cpl.remote_id)
-			goto cpl_finished;
-		ctrl = get_ctrl(ctx->mgr, grsp->id);
-		if (!ctrl)
-			goto cpl_finished;
-		ctrl->status = grsp->status;
-		ctrl->total_bw = le32_to_cpu(grsp->total_bw);
-		ctrl->max_bw = le32_to_cpu(grsp->max_bw);
-		ctrl->min_latency = le32_to_cpu(grsp->min_latency);
-		ctrl->pal_cap = le16_to_cpu(grsp->pal_cap);
-		ctrl->max_assoc_size = le16_to_cpu(grsp->assoc_size);
-
-		ctx->d.cpl.max_len = ctrl->max_assoc_size;
-
-		/* setup up GAA request */
-		areq.id = ctx->d.cpl.remote_id;
-
-		/* advance context state */
-		ctx->state = AMP_CPL_GAA_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETAMPASSOC_REQ,
-							sizeof(areq), &areq);
-		break;
-
-	case AMP_CPL_GAA_RSP:
-		if (skb->len < sizeof(*arsp))
-			goto cpl_finished;
-		hdr = (void *) skb->data;
-		arsp = (void *) skb_pull(skb, sizeof(*hdr));
-		if (arsp->status != 0)
-			goto cpl_finished;
-
-		/* store away remote assoc */
-		assoc = (u8 *) skb_pull(skb, sizeof(*arsp));
-		ctx->d.cpl.len_so_far = 0;
-		ctx->d.cpl.rem_len = hdr->len - sizeof(*arsp);
-		skb_pull(skb, ctx->d.cpl.rem_len);
-		rassoc = kmalloc(ctx->d.cpl.rem_len, GFP_ATOMIC);
-		if (!rassoc)
-			goto cpl_finished;
-		memcpy(rassoc, assoc, ctx->d.cpl.rem_len);
-		ctx->d.cpl.remote_assoc = rassoc;
-
-		/* set up CPL command */
-		ctx->d.cpl.phy_handle = physlink_handle(ctx->hdev);
-		cp.phy_handle = ctx->d.cpl.phy_handle;
-		if (physlink_security(ctx->mgr->l2cap_conn->hcon, cp.data,
-					&cp.key_len, &cp.type)) {
-			result = -EPERM;
-			goto cpl_finished;
-		}
-
-		/* advance context state */
-		ctx->state = AMP_CPL_CPL_STATUS;
-		ctx->evt_type = AMP_HCI_CMD_STATUS;
-		ctx->opcode = HCI_OP_CREATE_PHYS_LINK;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		break;
-
-	case AMP_CPL_CPL_STATUS:
-		/* received create physical link command status */
-		if (cs->status != 0)
-			goto cpl_finished;
-		/* send the first assoc fragment */
-		wcp.phy_handle = ctx->d.cpl.phy_handle;
-		wcp.len_so_far = ctx->d.cpl.len_so_far;
-		wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
-		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-		memcpy(wcp.frag, ctx->d.cpl.remote_assoc, frag_len);
-		ctx->state = AMP_CPL_WRA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-		break;
-
-	case AMP_CPL_WRA_COMPLETE:
-		/* received write remote amp assoc command complete event */
-		if (skb->len < sizeof(*wrp))
-			goto cpl_finished;
-		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
-		if (wrp->status != 0)
-			goto cpl_finished;
-		if (wrp->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-
-		/* update progress */
-		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-		ctx->d.cpl.len_so_far += frag_len;
-		ctx->d.cpl.rem_len -= frag_len;
-		if (ctx->d.cpl.rem_len > 0) {
-			/* another assoc fragment to send */
-			wcp.phy_handle = ctx->d.cpl.phy_handle;
-			wcp.len_so_far = cpu_to_le16(ctx->d.cpl.len_so_far);
-			wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
-			frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-			memcpy(wcp.frag,
-				ctx->d.cpl.remote_assoc + ctx->d.cpl.len_so_far,
-				frag_len);
-			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-			break;
-		}
-		/* now wait for channel selected event */
-		ctx->state = AMP_CPL_CHANNEL_SELECT;
-		ctx->evt_type = AMP_HCI_EVENT;
-		ctx->evt_code = HCI_EV_CHANNEL_SELECTED;
-		break;
-
-	case AMP_CPL_CHANNEL_SELECT:
-		/* received channel selection event */
-		if (skb->len < sizeof(*cev))
-			goto cpl_finished;
-		cev = (void *) skb->data;
-/* TODO - PK This check is valid but Libra PAL returns 0 for handle during
-			Create Physical Link collision scenario
-		if (cev->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-*/
-
-		/* request the first local assoc fragment */
-		rcp.phy_handle = ctx->d.cpl.phy_handle;
-		rcp.len_so_far = 0;
-		rcp.max_len = ctx->d.cpl.max_len;
-		lassoc = kmalloc(ctx->d.cpl.max_len, GFP_ATOMIC);
-		if (!lassoc)
-			goto cpl_finished;
-		ctx->d.cpl.local_assoc = lassoc;
-		ctx->d.cpl.len_so_far = 0;
-		ctx->state = AMP_CPL_RLA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
-		break;
-
-	case AMP_CPL_RLA_COMPLETE:
-		/* received read local amp assoc command complete event */
-		if (skb->len < 4)
-			goto cpl_finished;
-		rrp = (struct hci_rp_read_local_amp_assoc *) skb->data;
-		if (rrp->status)
-			goto cpl_finished;
-		if (rrp->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-		rem_len = le16_to_cpu(rrp->rem_len);
-		skb_pull(skb, 4);
-		frag_len = skb->len;
-
-		if (ctx->d.cpl.len_so_far + rem_len > ctx->d.cpl.max_len)
-			goto cpl_finished;
-
-		/* save this fragment in context */
-		lassoc = ctx->d.cpl.local_assoc + ctx->d.cpl.len_so_far;
-		memcpy(lassoc, rrp->frag, frag_len);
-		ctx->d.cpl.len_so_far += frag_len;
-		rem_len -= frag_len;
-		if (rem_len > 0) {
-			/* request another local assoc fragment */
-			rcp.phy_handle = ctx->d.cpl.phy_handle;
-			rcp.len_so_far = ctx->d.cpl.len_so_far;
-			rcp.max_len = ctx->d.cpl.max_len;
-			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
-		} else {
-			creq.local_id = ctx->id;
-			creq.remote_id = ctx->d.cpl.remote_id;
-			/* wait for A2MP rsp AND phys link complete event */
-			ctx->state = AMP_CPL_PL_COMPLETE;
-			ctx->evt_type = AMP_A2MP_RSP | AMP_HCI_EVENT;
-			ctx->rsp_ident = next_ident(ctx->mgr);
-			ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
-			send_a2mp_cmd2(ctx->mgr, ctx->rsp_ident,
-				A2MP_CREATEPHYSLINK_REQ, sizeof(creq), &creq,
-				ctx->d.cpl.len_so_far, ctx->d.cpl.local_assoc);
-		}
-		break;
-
-	case AMP_CPL_PL_COMPLETE:
-		if (evt_type == AMP_A2MP_RSP) {
-			/* create physical link response received */
-			ctx->evt_type &= ~AMP_A2MP_RSP;
-			if (skb->len < sizeof(*crsp))
-				goto cpl_finished;
-			crsp = (void *) skb_pull(skb, sizeof(*hdr));
-			if ((crsp->local_id != ctx->d.cpl.remote_id) ||
-				(crsp->remote_id != ctx->id) ||
-				(crsp->status != 0)) {
-				cancel_cpl_ctx(ctx, 0x13);
-				break;
-			}
-
-			/* notify Qualcomm PAL */
-			if (ctx->hdev->manufacturer == 0x001d)
-				hci_send_cmd(ctx->hdev,
-					hci_opcode_pack(0x3f, 0x00), 0, NULL);
-		}
-		if (evt_type == AMP_HCI_EVENT) {
-			ctx->evt_type &= ~AMP_HCI_EVENT;
-			/* physical link complete event received */
-			if (skb->len < sizeof(*pev))
-				goto cpl_finished;
-			pev = (void *) skb->data;
-			if (pev->phy_handle != ctx->d.cpl.phy_handle)
-				break;
-			if (pev->status != 0)
-				goto cpl_finished;
-		}
-		if (ctx->evt_type)
-			break;
-		conn = hci_conn_hash_lookup_handle(ctx->hdev,
-							ctx->d.cpl.phy_handle);
-		if (!conn)
-			goto cpl_finished;
-		result = 0;
-		BT_DBG("PL_COMPLETE phy_handle %x", ctx->d.cpl.phy_handle);
-		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
-		conn->dst_id = ctx->d.cpl.remote_id;
-		conn->out = 1;
-		goto cpl_finished;
-		break;
-
-	case AMP_CPL_PL_CANCEL:
-		dev = (void *) skb->data;
-		BT_DBG("PL_COMPLETE cancelled %x", dev->phy_handle);
-		result = -EISCONN;
-		goto cpl_finished;
-		break;
-
-	default:
-		goto cpl_finished;
-		break;
-	}
-	return 0;
-
-cpl_finished:
-	l2cap_amp_physical_complete(result, ctx->id, ctx->d.cpl.remote_id,
-					ctx->sk);
-	if (ctx->sk)
-		sock_put(ctx->sk);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	kfree(ctx->d.cpl.remote_assoc);
-	kfree(ctx->d.cpl.local_assoc);
-	return 1;
-}
-
-static int disconnphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (void *) skb->data;
-	struct a2mp_disconnphyslink_req *req;
-	struct a2mp_disconnphyslink_rsp rsp;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	struct amp_ctx *aplctx;
-
-	BT_DBG("mgr %p skb %p", mgr, skb);
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (void *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-
-	rsp.local_id = req->remote_id;
-	rsp.remote_id = req->local_id;
-	rsp.status = 0;
-	BT_DBG("local_id %d remote_id %d",
-		(int) rsp.local_id, (int) rsp.remote_id);
-	hdev = hci_dev_get(rsp.local_id);
-	if (!hdev) {
-		rsp.status = 1; /* Invalid Controller ID */
-		goto dpl_finished;
-	}
-	BT_DBG("hdev %p", hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
-					&mgr->l2cap_conn->hcon->dst);
-	if (!conn) {
-		aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
-		if (aplctx) {
-			kill_ctx(aplctx);
-			rsp.status = 0;
-			goto dpl_finished;
-		}
-		rsp.status = 2;  /* No Physical Link exists */
-		goto dpl_finished;
-	}
-	BT_DBG("conn %p", conn);
-	hci_disconnect(conn, 0x13);
-
-dpl_finished:
-	send_a2mp_cmd(mgr, hdr->ident,
-				A2MP_DISCONNPHYSLINK_RSP, sizeof(rsp), &rsp);
-	if (hdev)
-		hci_dev_put(hdev);
-	return 0;
-}
-
-static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct amp_mgr *mgr = ctx->mgr;
-	u8 finished = 0;
-
-	if (!mgr->connected)
-		return 0;
-
-	switch (ctx->type) {
-	case AMP_GETAMPASSOC:
-		finished = getampassoc_handler(ctx, evt_type, data);
-		break;
-	case AMP_CREATEPHYSLINK:
-		finished = createphyslink_handler(ctx, evt_type, data);
-		break;
-	case AMP_ACCEPTPHYSLINK:
-		finished = acceptphyslink_handler(ctx, evt_type, data);
-		break;
-	}
-
-	if (!finished)
-		mod_timer(&(ctx->timer), jiffies +
-			msecs_to_jiffies(A2MP_RSP_TIMEOUT));
-	else
-		destroy_ctx(ctx);
-	return finished;
-}
-
-static int cancel_ctx(struct amp_ctx *ctx)
-{
-	return execute_ctx(ctx, AMP_CANCEL, 0);
-}
-
-static int kill_ctx(struct amp_ctx *ctx)
-{
-	return execute_ctx(ctx, AMP_KILLED, 0);
-}
-
-static void ctx_timeout_worker(struct work_struct *w)
-{
-	struct amp_work_ctx_timeout *work = (struct amp_work_ctx_timeout *) w;
-	struct amp_ctx *ctx = work->ctx;
-	kill_ctx(ctx);
-	kfree(work);
-}
-
-static void ctx_timeout(unsigned long data)
-{
-	struct amp_ctx *ctx = (struct amp_ctx *) data;
-	struct amp_work_ctx_timeout *work;
-
-	BT_DBG("ctx %p", ctx);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, ctx_timeout_worker);
-		work->ctx = ctx;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void launch_ctx(struct amp_mgr *mgr)
-{
-	struct amp_ctx *ctx = NULL;
-
-	BT_DBG("mgr %p", mgr);
-	read_lock(&mgr->ctx_list_lock);
-	if (!list_empty(&mgr->ctx_list))
-		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
-	read_unlock(&mgr->ctx_list_lock);
-	BT_DBG("ctx %p", ctx);
-	if (ctx)
-		execute_ctx(ctx, AMP_INIT, NULL);
-}
-
-static inline int a2mp_rsp(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct amp_ctx *ctx;
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	u16 hdr_len = le16_to_cpu(hdr->len);
-
-	/* find context waiting for A2MP rsp with this rsp's identifier */
-	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
-	ctx = get_ctx_a2mp(mgr, hdr->ident);
-	if (ctx) {
-		execute_ctx(ctx, AMP_A2MP_RSP, skb);
-	} else {
-		BT_DBG("context not found");
-		skb_pull(skb, sizeof(*hdr));
-		if (hdr_len > skb->len)
-			hdr_len = skb->len;
-		skb_pull(skb, hdr_len);
-	}
-	return 0;
-}
-
-/* L2CAP-A2MP interface */
-
-static void a2mp_receive(struct sock *sk, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	int len;
-	int err = 0;
-	struct amp_mgr *mgr;
-
-	mgr = get_amp_mgr_sk(sk);
-	if (!mgr)
-		goto a2mp_finished;
-
-	len = skb->len;
-	while (len >= sizeof(*hdr)) {
-		struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-		u16 clen = le16_to_cpu(hdr->len);
-
-		BT_DBG("code 0x%02x id %d len %d", hdr->code, hdr->ident, clen);
-		if (clen > len || !hdr->ident) {
-			err = -EINVAL;
-			break;
-		}
-		switch (hdr->code) {
-		case A2MP_COMMAND_REJ:
-			command_rej(mgr, skb);
-			break;
-		case A2MP_DISCOVER_REQ:
-			err = discover_req(mgr, skb);
-			break;
-		case A2MP_CHANGE_NOTIFY:
-			err = change_notify(mgr, skb);
-			break;
-		case A2MP_GETINFO_REQ:
-			err = getinfo_req(mgr, skb);
-			break;
-		case A2MP_GETAMPASSOC_REQ:
-			err = getampassoc_req(mgr, skb);
-			break;
-		case A2MP_CREATEPHYSLINK_REQ:
-			err = createphyslink_req(mgr, skb);
-			break;
-		case A2MP_DISCONNPHYSLINK_REQ:
-			err = disconnphyslink_req(mgr, skb);
-			break;
-		case A2MP_CHANGE_RSP:
-		case A2MP_DISCOVER_RSP:
-		case A2MP_GETINFO_RSP:
-		case A2MP_GETAMPASSOC_RSP:
-		case A2MP_CREATEPHYSLINK_RSP:
-		case A2MP_DISCONNPHYSLINK_RSP:
-			err = a2mp_rsp(mgr, skb);
-			break;
-		default:
-			BT_ERR("Unknown A2MP signaling command 0x%2.2x",
-				hdr->code);
-			skb_pull(skb, sizeof(*hdr));
-			err = -EINVAL;
-			break;
-		}
-		len = skb->len;
-	}
-
-a2mp_finished:
-	if (err && mgr) {
-		struct a2mp_cmd_rej rej;
-		rej.reason = cpu_to_le16(0);
-		send_a2mp_cmd(mgr, hdr->ident, A2MP_COMMAND_REJ,
-							sizeof(rej), &rej);
-	}
-}
-
-/* L2CAP-A2MP interface */
-
-static int send_a2mp(struct socket *sock, u8 *data, int len)
-{
-	struct kvec iv = { data, len };
-	struct msghdr msg;
-
-	memset(&msg, 0, sizeof(msg));
-
-	return kernel_sendmsg(sock, &msg, &iv, 1, len);
-}
-
-static void data_ready_worker(struct work_struct *w)
-{
-	struct amp_work_data_ready *work = (struct amp_work_data_ready *) w;
-	struct sock *sk = work->sk;
-	struct sk_buff *skb;
-
-	/* skb_dequeue() is thread-safe */
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		a2mp_receive(sk, skb);
-		kfree_skb(skb);
-	}
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void data_ready(struct sock *sk, int bytes)
-{
-	struct amp_work_data_ready *work;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, data_ready_worker);
-		sock_hold(sk);
-		work->sk = sk;
-		work->bytes = bytes;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			kfree(work);
-			sock_put(sk);
-		}
-	}
-}
-
-static void state_change_worker(struct work_struct *w)
-{
-	struct amp_work_state_change *work = (struct amp_work_state_change *) w;
-	struct amp_mgr *mgr;
-	switch (work->sk->sk_state) {
-	case BT_CONNECTED:
-		/* socket is up */
-		BT_DBG("CONNECTED");
-		mgr = get_amp_mgr_sk(work->sk);
-		if (mgr) {
-			mgr->connected = 1;
-			if (mgr->skb) {
-				l2cap_recv_deferred_frame(work->sk, mgr->skb);
-				mgr->skb = NULL;
-			}
-			launch_ctx(mgr);
-		}
-		break;
-
-	case BT_CLOSED:
-		/* connection is gone */
-		BT_DBG("CLOSED");
-		mgr = get_amp_mgr_sk(work->sk);
-		if (mgr) {
-			if (!sock_flag(work->sk, SOCK_DEAD))
-				sock_release(mgr->a2mp_sock);
-			mgr->a2mp_sock = NULL;
-			remove_amp_mgr(mgr);
-		}
-		break;
-
-	default:
-		/* something else happened */
-		break;
-	}
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void state_change(struct sock *sk)
-{
-	struct amp_work_state_change *work;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, state_change_worker);
-		sock_hold(sk);
-		work->sk = sk;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			kfree(work);
-			sock_put(sk);
-		}
-	}
-}
-
-static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst)
-{
-	int err;
-	struct socket *sock;
-	struct sockaddr_l2 addr;
-	struct sock *sk;
-	struct l2cap_options opts = {L2CAP_A2MP_DEFAULT_MTU,
-			L2CAP_A2MP_DEFAULT_MTU, L2CAP_DEFAULT_FLUSH_TO,
-			L2CAP_MODE_ERTM, 1, 0xFF, 1};
-
-
-	err = sock_create_kern(PF_BLUETOOTH, SOCK_SEQPACKET,
-					BTPROTO_L2CAP, &sock);
-
-	if (err) {
-		BT_ERR("sock_create_kern failed %d", err);
-		return NULL;
-	}
-
-	sk = sock->sk;
-	sk->sk_data_ready = data_ready;
-	sk->sk_state_change = state_change;
-
-	memset(&addr, 0, sizeof(addr));
-	bacpy(&addr.l2_bdaddr, src);
-	addr.l2_family = AF_BLUETOOTH;
-	addr.l2_cid = L2CAP_CID_A2MP;
-	err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
-	if (err) {
-		BT_ERR("kernel_bind failed %d", err);
-		sock_release(sock);
-		return NULL;
-	}
-
-	l2cap_fixed_channel_config(sk, &opts);
-
-	memset(&addr, 0, sizeof(addr));
-	bacpy(&addr.l2_bdaddr, dst);
-	addr.l2_family = AF_BLUETOOTH;
-	addr.l2_cid = L2CAP_CID_A2MP;
-	err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr),
-							O_NONBLOCK);
-	if ((err == 0) || (err == -EINPROGRESS))
-		return sock;
-	else {
-		BT_ERR("kernel_connect failed %d", err);
-		sock_release(sock);
-		return NULL;
-	}
-}
-
-static void conn_ind_worker(struct work_struct *w)
-{
-	struct amp_work_conn_ind *work = (struct amp_work_conn_ind *) w;
-	struct hci_conn *hcon = work->hcon;
-	struct sk_buff *skb = work->skb;
-	struct amp_mgr *mgr;
-
-	mgr = get_create_amp_mgr(hcon, skb);
-	BT_DBG("mgr %p", mgr);
-	hci_conn_put(hcon);
-	kfree(work);
-}
-
-static void create_physical_worker(struct work_struct *w)
-{
-	struct amp_work_create_physical *work =
-		(struct amp_work_create_physical *) w;
-
-	create_physical(work->conn, work->sk);
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void accept_physical_worker(struct work_struct *w)
-{
-	struct amp_work_accept_physical *work =
-		(struct amp_work_accept_physical *) w;
-
-	accept_physical(work->conn, work->id, work->sk);
-	sock_put(work->sk);
-	kfree(work);
-}
-
-/* L2CAP Fixed Channel interface */
-
-void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb)
-{
-	struct amp_work_conn_ind *work;
-	BT_DBG("hcon %p, skb %p", hcon, skb);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, conn_ind_worker);
-		hci_conn_hold(hcon);
-		work->hcon = hcon;
-		work->skb = skb;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			hci_conn_put(hcon);
-			kfree(work);
-		}
-	}
-}
-
-/* L2CAP Physical Link interface */
-
-void amp_create_physical(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct amp_work_create_physical *work;
-	BT_DBG("conn %p", conn);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, create_physical_worker);
-		work->conn = conn;
-		work->sk = sk;
-		sock_hold(sk);
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			sock_put(sk);
-			kfree(work);
-		}
-	}
-}
-
-void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk)
-{
-	struct amp_work_accept_physical *work;
-	BT_DBG("conn %p", conn);
-
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, accept_physical_worker);
-		work->conn = conn;
-		work->sk = sk;
-		work->id = id;
-		sock_hold(sk);
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			sock_put(sk);
-			kfree(work);
-		}
-	}
-}
-
-/* HCI interface */
-
-static void amp_cmd_cmplt_worker(struct work_struct *w)
-{
-	struct amp_work_cmd_cmplt *work = (struct amp_work_cmd_cmplt *) w;
-	struct hci_dev *hdev = work->hdev;
-	u16 opcode = work->opcode;
-	struct sk_buff *skb = work->skb;
-	struct amp_ctx *ctx;
-
-	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_CMPLT, opcode);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_CMD_CMPLT, skb);
-	kfree_skb(skb);
-	kfree(w);
-}
-
-static void amp_cmd_cmplt_evt(struct hci_dev *hdev, u16 opcode,
-				struct sk_buff *skb)
-{
-	struct amp_work_cmd_cmplt *work;
-	struct sk_buff *skbc;
-	BT_DBG("hdev %p opcode 0x%x skb %p len %d",
-		hdev, opcode, skb, skb->len);
-	skbc = skb_clone(skb, GFP_ATOMIC);
-	if (!skbc)
-		return;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_cmd_cmplt_worker);
-		work->hdev = hdev;
-		work->opcode = opcode;
-		work->skb = skbc;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_cmd_status_worker(struct work_struct *w)
-{
-	struct amp_work_cmd_status *work = (struct amp_work_cmd_status *) w;
-	struct hci_dev *hdev = work->hdev;
-	u16 opcode = work->opcode;
-	u8 status = work->status;
-	struct amp_ctx *ctx;
-
-	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_STATUS, opcode);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_CMD_STATUS, &status);
-	kfree(w);
-}
-
-static void amp_cmd_status_evt(struct hci_dev *hdev, u16 opcode, u8 status)
-{
-	struct amp_work_cmd_status *work;
-	BT_DBG("hdev %p opcode 0x%x status %d", hdev, opcode, status);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_cmd_status_worker);
-		work->hdev = hdev;
-		work->opcode = opcode;
-		work->status = status;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_event_worker(struct work_struct *w)
-{
-	struct amp_work_event *work = (struct amp_work_event *) w;
-	struct hci_dev *hdev = work->hdev;
-	u8 event = work->event;
-	struct sk_buff *skb = work->skb;
-	struct amp_ctx *ctx;
-
-	if (event == HCI_EV_AMP_STATUS_CHANGE) {
-		struct hci_ev_amp_status_change *ev;
-		if (skb->len < sizeof(*ev))
-			goto amp_event_finished;
-		ev = (void *) skb->data;
-		if (ev->status != 0)
-			goto amp_event_finished;
-		if (ev->amp_status == hdev->amp_status)
-			goto amp_event_finished;
-		hdev->amp_status = ev->amp_status;
-		send_a2mp_change_notify();
-		goto amp_event_finished;
-	}
-	ctx = get_ctx_hdev(hdev, AMP_HCI_EVENT, (u16) event);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_EVENT, skb);
-
-amp_event_finished:
-	kfree_skb(skb);
-	kfree(w);
-}
-
-static void amp_evt(struct hci_dev *hdev, u8 event, struct sk_buff *skb)
-{
-	struct amp_work_event *work;
-	struct sk_buff *skbc;
-	BT_DBG("hdev %p event 0x%x skb %p", hdev, event, skb);
-	skbc = skb_clone(skb, GFP_ATOMIC);
-	if (!skbc)
-		return;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_event_worker);
-		work->hdev = hdev;
-		work->event = event;
-		work->skb = skbc;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_dev_event_worker(struct work_struct *w)
-{
-	send_a2mp_change_notify();
-	kfree(w);
-}
-
-static int amp_dev_event(struct notifier_block *this, unsigned long event,
-			void *ptr)
-{
-	struct hci_dev *hdev = (struct hci_dev *) ptr;
-	struct amp_work_event *work;
-
-	if (hdev->amp_type == HCI_BREDR)
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case HCI_DEV_UNREG:
-	case HCI_DEV_REG:
-	case HCI_DEV_UP:
-	case HCI_DEV_DOWN:
-		BT_DBG("hdev %p event %ld", hdev, event);
-		work = kmalloc(sizeof(*work), GFP_ATOMIC);
-		if (work) {
-			INIT_WORK((struct work_struct *) work,
-				amp_dev_event_worker);
-			if (queue_work(amp_workqueue,
-				(struct work_struct *) work) == 0)
-				kfree(work);
-		}
-	}
-	return NOTIFY_DONE;
-}
-
-
-/* L2CAP module init continued */
-
-static struct notifier_block amp_notifier = {
-	.notifier_call = amp_dev_event
-};
-
-static struct amp_mgr_cb hci_amp = {
-	.amp_cmd_complete_event = amp_cmd_cmplt_evt,
-	.amp_cmd_status_event = amp_cmd_status_evt,
-	.amp_event = amp_evt
-};
-
-int amp_init(void)
-{
-	hci_register_amp(&hci_amp);
-	hci_register_notifier(&amp_notifier);
-	amp_next_handle = 1;
-	amp_workqueue = create_singlethread_workqueue("a2mp");
-	if (!amp_workqueue)
-		return -EPERM;
-	return 0;
-}
-
-void amp_exit(void)
-{
-	hci_unregister_amp(&hci_amp);
-	hci_unregister_notifier(&amp_notifier);
-	flush_workqueue(amp_workqueue);
-	destroy_workqueue(amp_workqueue);
-}
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/core.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/core.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -57,8 +56,8 @@
 
 #define VERSION "1.3"
 
-static bool compress_src = 1;
-static bool compress_dst = 1;
+static bool compress_src = true;
+static bool compress_dst = true;
 
 static LIST_HEAD(bnep_session_list);
 static DECLARE_RWSEM(bnep_session_sem);
@@ -66,31 +65,24 @@
 static struct bnep_session *__bnep_get_session(u8 *dst)
 {
 	struct bnep_session *s;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &bnep_session_list) {
-		s = list_entry(p, struct bnep_session, list);
+	list_for_each_entry(s, &bnep_session_list, list)
 		if (!compare_ether_addr(dst, s->eh.h_source))
 			return s;
-	}
+
 	return NULL;
 }
 
 static void __bnep_link_session(struct bnep_session *s)
 {
-	/* It's safe to call __module_get() here because sessions are added
-	   by the socket layer which has to hold the reference to this module.
-	 */
-	__module_get(THIS_MODULE);
 	list_add(&s->list, &bnep_session_list);
 }
 
 static void __bnep_unlink_session(struct bnep_session *s)
 {
 	list_del(&s->list);
-	module_put(THIS_MODULE);
 }
 
 static int bnep_send(struct bnep_session *s, void *data, size_t len)
@@ -510,7 +502,7 @@
 
 		schedule();
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	/* Cleanup session */
@@ -531,6 +523,7 @@
 
 	up_write(&bnep_session_sem);
 	free_netdev(dev);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -617,9 +610,11 @@
 
 	__bnep_link_session(s);
 
+	__module_get(THIS_MODULE);
 	s->task = kthread_run(bnep_session, s, "kbnepd %s", dev->name);
 	if (IS_ERR(s->task)) {
 		/* Session thread start failed, gotta cleanup. */
+		module_put(THIS_MODULE);
 		unregister_netdev(dev);
 		__bnep_unlink_session(s);
 		err = PTR_ERR(s->task);
@@ -668,17 +663,14 @@
 
 int bnep_get_connlist(struct bnep_connlist_req *req)
 {
-	struct list_head *p;
+	struct bnep_session *s;
 	int err = 0, n = 0;
 
 	down_read(&bnep_session_sem);
 
-	list_for_each(p, &bnep_session_list) {
-		struct bnep_session *s;
+	list_for_each_entry(s, &bnep_session_list, list) {
 		struct bnep_conninfo ci;
 
-		s = list_entry(p, struct bnep_session, list);
-
 		__bnep_copy_ci(&ci, s);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/netdev.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/netdev.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/netdev.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/netdev.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 #include <linux/slab.h>
 
 #include <linux/socket.h>
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/sock.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/sock.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -42,7 +42,6 @@
 #include <linux/uaccess.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 
 #include "bnep.h"
 
@@ -143,10 +142,10 @@
 {
 	if (cmd == BNEPGETCONNLIST) {
 		struct bnep_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -157,7 +156,7 @@
 
 		err = bnep_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/capi.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/capi.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/capi.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/capi.c	2016-06-02 00:28:55.000000000 +0000
@@ -326,7 +326,7 @@
 {
 	struct capi_ctr *ctrl = &session->ctrl;
 	struct cmtp_application *application;
-	__u16 cmd, appl;
+	__u16 appl;
 	__u32 contr;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
@@ -344,7 +344,6 @@
 		return;
 	}
 
-	cmd = CAPICMD(CAPIMSG_COMMAND(skb->data), CAPIMSG_SUBCOMMAND(skb->data));
 	appl = CAPIMSG_APPID(skb->data);
 	contr = CAPIMSG_CONTROL(skb->data);
 
@@ -387,7 +386,8 @@
 
 	capi_ctr_down(ctrl);
 
-	kthread_stop(session->task);
+	atomic_inc(&session->terminate);
+	wake_up_process(session->task);
 }
 
 static void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_params *rp)
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/cmtp.h flo-ElementalX-5.00-patched/net/bluetooth/cmtp/cmtp.h
--- flo-ElementalX-5.00/net/bluetooth/cmtp/cmtp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/cmtp.h	2016-06-02 00:28:55.000000000 +0000
@@ -81,6 +81,7 @@
 
 	char name[BTNAMSIZ];
 
+	atomic_t terminate;
 	struct task_struct *task;
 
 	wait_queue_head_t wait;
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/core.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/core.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -53,28 +53,24 @@
 static struct cmtp_session *__cmtp_get_session(bdaddr_t *bdaddr)
 {
 	struct cmtp_session *session;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &cmtp_session_list) {
-		session = list_entry(p, struct cmtp_session, list);
+	list_for_each_entry(session, &cmtp_session_list, list)
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
-	}
+
 	return NULL;
 }
 
 static void __cmtp_link_session(struct cmtp_session *session)
 {
-	__module_get(THIS_MODULE);
 	list_add(&session->list, &cmtp_session_list);
 }
 
 static void __cmtp_unlink_session(struct cmtp_session *session)
 {
 	list_del(&session->list);
-	module_put(THIS_MODULE);
 }
 
 static void __cmtp_copy_session(struct cmtp_session *session, struct cmtp_conninfo *ci)
@@ -292,9 +288,11 @@
 
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (!kthread_should_stop()) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
+		if (atomic_read(&session->terminate))
+			break;
 		if (sk->sk_state != BT_CONNECTED)
 			break;
 
@@ -310,7 +308,7 @@
 
 		schedule();
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	down_write(&cmtp_session_sem);
@@ -325,6 +323,7 @@
 	up_write(&cmtp_session_sem);
 
 	kfree(session);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -349,7 +348,8 @@
 
 	bacpy(&session->bdaddr, &bt_sk(sock->sk)->dst);
 
-	session->mtu = min_t(uint, l2cap_pi(sock->sk)->omtu, l2cap_pi(sock->sk)->imtu);
+	session->mtu = min_t(uint, l2cap_pi(sock->sk)->chan->omtu,
+					l2cap_pi(sock->sk)->chan->imtu);
 
 	BT_DBG("mtu %d", session->mtu);
 
@@ -373,25 +373,28 @@
 
 	__cmtp_link_session(session);
 
+	__module_get(THIS_MODULE);
 	session->task = kthread_run(cmtp_session, session, "kcmtpd_ctr_%d",
 								session->num);
 	if (IS_ERR(session->task)) {
+		module_put(THIS_MODULE);
 		err = PTR_ERR(session->task);
 		goto unlink;
 	}
 
 	if (!(session->flags & (1 << CMTP_LOOPBACK))) {
 		err = cmtp_attach_device(session);
-		if (err < 0)
-			goto detach;
+		if (err < 0) {
+			atomic_inc(&session->terminate);
+			wake_up_process(session->task);
+			up_write(&cmtp_session_sem);
+			return err;
+		}
 	}
 
 	up_write(&cmtp_session_sem);
 	return 0;
 
-detach:
-	cmtp_detach_device(session);
-
 unlink:
 	__cmtp_unlink_session(session);
 
@@ -416,7 +419,8 @@
 		skb_queue_purge(&session->transmit);
 
 		/* Stop session thread */
-		kthread_stop(session->task);
+		atomic_inc(&session->terminate);
+		wake_up_process(session->task);
 	} else
 		err = -ENOENT;
 
@@ -426,19 +430,16 @@
 
 int cmtp_get_connlist(struct cmtp_connlist_req *req)
 {
-	struct list_head *p;
+	struct cmtp_session *session;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&cmtp_session_sem);
 
-	list_for_each(p, &cmtp_session_list) {
-		struct cmtp_session *session;
+	list_for_each_entry(session, &cmtp_session_list, list) {
 		struct cmtp_conninfo ci;
 
-		session = list_entry(p, struct cmtp_session, list);
-
 		__cmtp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/sock.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/sock.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -39,7 +39,6 @@
 
 #include <linux/isdn/capilli.h>
 
-#include <asm/system.h>
 
 #include "cmtp.h"
 
@@ -137,10 +136,10 @@
 {
 	if (cmd == CMTPGETCONNLIST) {
 		struct cmtp_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -151,7 +150,7 @@
 
 		err = cmtp_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_conn.c flo-ElementalX-5.00-patched/net/bluetooth/hci_conn.c
--- flo-ElementalX-5.00/net/bluetooth/hci_conn.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_conn.c	2014-12-03 11:07:31.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -35,194 +35,54 @@
 #include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
+#include <net/bluetooth/smp.h>
 
-struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
-				bdaddr_t *dst, __u8 sec_level, __u8 auth_type,
-				struct bt_le_params *le_params)
+static void hci_le_connect(struct hci_conn *conn)
 {
-	struct hci_conn *le, *le_wlist_conn;
+	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_create_conn cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (le) {
-		le_wlist_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK,
-								BDADDR_ANY);
-		if (!le_wlist_conn) {
-			hci_conn_hold(le);
-			return le;
-		} else {
-			BT_DBG("remove wlist conn");
-			le->out = 1;
-			le->link_mode |= HCI_LM_MASTER;
-			le->sec_level = BT_SECURITY_LOW;
-			le->type = LE_LINK;
-			hci_proto_connect_cfm(le, 0);
-			hci_conn_del(le_wlist_conn);
-			return le;
-		}
-	}
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			le = hci_le_conn_add(hdev, dst,
-					entry->bdaddr_type);
-		else
-			le = hci_le_conn_add(hdev, dst, 0);
-	} else {
-		le = hci_le_conn_add(hdev, dst, key->addr_type);
-	}
-
-	if (!le)
-		return ERR_PTR(-ENOMEM);
-
-	hci_conn_hold(le);
 
-	le->state = BT_CONNECT;
-	le->out = 1;
-	le->link_mode |= HCI_LM_MASTER;
-	le->sec_level = BT_SECURITY_LOW;
-	le->type = LE_LINK;
+	conn->state = BT_CONNECT;
+	conn->out = true;
+	conn->link_mode |= HCI_LM_MASTER;
+	conn->sec_level = BT_SECURITY_LOW;
 
 	memset(&cp, 0, sizeof(cp));
-	if (l2cap_sock_le_params_valid(le_params)) {
-		cp.supervision_timeout =
-				cpu_to_le16(le_params->supervision_timeout);
-		cp.scan_interval = cpu_to_le16(le_params->scan_interval);
-		cp.scan_window = cpu_to_le16(le_params->scan_window);
-		cp.conn_interval_min = cpu_to_le16(le_params->interval_min);
-		cp.conn_interval_max = cpu_to_le16(le_params->interval_max);
-		cp.conn_latency = cpu_to_le16(le_params->latency);
-		cp.min_ce_len = cpu_to_le16(le_params->min_ce_len);
-		cp.max_ce_len = cpu_to_le16(le_params->max_ce_len);
-		le->conn_timeout = le_params->conn_timeout;
-	} else {
-		cp.supervision_timeout = cpu_to_le16(BT_LE_SUP_TO_DEFAULT);
-		cp.scan_interval = cpu_to_le16(BT_LE_SCAN_INTERVAL_DEF);
-		cp.scan_window = cpu_to_le16(BT_LE_SCAN_WINDOW_DEF);
-		cp.conn_interval_min = cpu_to_le16(BT_LE_CONN_INTERVAL_MIN_DEF);
-		cp.conn_interval_max = cpu_to_le16(BT_LE_CONN_INTERVAL_MAX_DEF);
-		cp.conn_latency = cpu_to_le16(BT_LE_LATENCY_DEF);
-		le->conn_timeout = 5;
-	}
-	if (!bacmp(&le->dst, BDADDR_ANY)) {
-		cp.filter_policy = 0x01;
-		le->conn_timeout = 0;
-	} else {
-		bacpy(&cp.peer_addr, &le->dst);
-		cp.peer_addr_type = le->dst_type;
-	}
+	cp.scan_interval = cpu_to_le16(0x0060);
+	cp.scan_window = cpu_to_le16(0x0030);
+	bacpy(&cp.peer_addr, &conn->dst);
+	cp.peer_addr_type = conn->dst_type;
+	cp.conn_interval_min = cpu_to_le16(0x0028);
+	cp.conn_interval_max = cpu_to_le16(0x0038);
+	cp.supervision_timeout = cpu_to_le16(0x002a);
+	cp.min_ce_len = cpu_to_le16(0x0000);
+	cp.max_ce_len = cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
-
-	return le;
 }
-EXPORT_SYMBOL(hci_le_connect);
 
 static void hci_le_connect_cancel(struct hci_conn *conn)
 {
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
-void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_conn *le;
-
-	BT_DBG("%p", hdev);
-
-	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (le) {
-		BT_DBG("send hci connect cancel");
-		hci_le_connect_cancel(le);
-		hci_conn_del(le);
-	}
-}
-EXPORT_SYMBOL(hci_le_cancel_create_connect);
-
-void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_cp_le_add_dev_white_list cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	bacpy(&cp.addr, dst);
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			cp.addr_type = entry->bdaddr_type;
-		else
-			cp.addr_type = 0x00;
-	} else {
-		cp.addr_type = key->addr_type;
-	}
-
-	hci_send_cmd(hdev, HCI_OP_LE_ADD_DEV_WHITE_LIST, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_le_add_dev_white_list);
-
-void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_cp_le_remove_dev_white_list cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	bacpy(&cp.addr, dst);
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			cp.addr_type = entry->bdaddr_type;
-		else
-			cp.addr_type = 0x00;
-	} else {
-		cp.addr_type = key->addr_type;
-	}
-
-	hci_send_cmd(hdev, HCI_OP_LE_REMOVE_DEV_WHITE_LIST, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_le_remove_dev_white_list);
-
-static inline bool is_role_switch_possible(struct hci_dev *hdev)
-{
-	if (hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECTED))
-		return false;
-	return true;
-}
-
 void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct inquiry_entry *ie;
 	struct hci_cp_create_conn cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->link_mode = HCI_LM_MASTER;
 
@@ -244,12 +104,12 @@
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
-		conn->ssp_mode = ie->data.ssp_mode;
+		if (ie->data.ssp_mode > 0)
+			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
-	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER)
-		&& is_role_switch_possible(hdev))
+	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch = 0x01;
 	else
 		cp.role_switch = 0x00;
@@ -263,7 +123,7 @@
 
 	BT_DBG("%p", conn);
 
-	if (conn->hdev->hci_ver < 2)
+	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
 		return;
 
 	bacpy(&cp.bdaddr, &conn->dst);
@@ -272,22 +132,15 @@
 
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 {
+	struct hci_cp_disconnect cp;
+
 	BT_DBG("%p", conn);
 
 	conn->state = BT_DISCONN;
 
-	if (conn->hdev->dev_type == HCI_BREDR) {
-		struct hci_cp_disconnect cp;
-		cp.handle = cpu_to_le16(conn->handle);
-		cp.reason = reason;
-		hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
-	} else {
-		struct hci_cp_disconn_phys_link cp;
-		cp.phy_handle = (u8) conn->handle;
-		cp.reason = reason;
-		hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHYS_LINK,
-				sizeof(cp), &cp);
-	}
+	cp.handle = cpu_to_le16(conn->handle);
+	cp.reason = reason;
+	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
 void hci_add_sco(struct hci_conn *conn, __u16 handle)
@@ -298,7 +151,7 @@
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 
@@ -316,28 +169,18 @@
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 
 	cp.handle   = cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	if (conn->hdev->is_wbs) {
-		/* Transparent Data */
-		uint16_t voice_setting = hdev->voice_setting | ACF_TRANS;
-		cp.max_latency    = cpu_to_le16(0x000D);
-		cp.pkt_type = cpu_to_le16(ESCO_WBS);
-		cp.voice_setting  = cpu_to_le16(voice_setting);
-		/* Retransmission Effort */
-		cp.retrans_effort = RE_LINK_QUALITY;
-	} else {
-		cp.max_latency    = cpu_to_le16(0x000A);
-		cp.pkt_type = cpu_to_le16(conn->pkt_type);
-		cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
-		cp.retrans_effort = RE_POWER_CONSUMP;
-	}
+	cp.max_latency    = cpu_to_le16(0xffff);
+	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
+	cp.retrans_effort = 0xff;
 
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
@@ -362,18 +205,6 @@
 }
 EXPORT_SYMBOL(hci_le_conn_update);
 
-void hci_read_rssi(struct hci_conn *conn)
-{
-	struct hci_cp_read_rssi cp;
-	struct hci_dev *hdev = conn->hdev;
-
-	memset(&cp, 0, sizeof(cp));
-	cp.handle   = cpu_to_le16(conn->handle);
-
-	hci_send_cmd(hdev, HCI_OP_READ_RSSI, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_read_rssi);
-
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16])
 {
@@ -393,7 +224,7 @@
 }
 EXPORT_SYMBOL(hci_le_start_enc);
 
-void hci_le_ltk_reply(struct hci_conn *conn, __u8 ltk[16])
+void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_ltk_reply cp;
@@ -403,7 +234,7 @@
 	memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
-	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
+	memcpy(cp.ltk, ltk, sizeof(ltk));
 
 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
 }
@@ -444,15 +275,16 @@
 	}
 }
 
-static void hci_conn_timeout(unsigned long arg)
+static void hci_conn_timeout(struct work_struct *work)
 {
-	struct hci_conn *conn = (void *) arg;
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+							disc_work.work);
 	__u8 reason;
 
-	BT_DBG("conn %p state %d", conn, conn->state);
+	BT_DBG("conn %p state %s", conn, state_to_string(conn->state));
 
-	hci_dev_lock(hdev);
+	if (atomic_read(&conn->refcnt))
+		return;
 
 	switch (conn->state) {
 	case BT_CONNECT:
@@ -466,67 +298,76 @@
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		if (!atomic_read(&conn->refcnt)) {
-			reason = hci_proto_disconn_ind(conn);
-			hci_acl_disconn(conn, reason);
-		}
+		reason = hci_proto_disconn_ind(conn);
+		hci_acl_disconn(conn, reason);
 		break;
 	default:
-		if (!atomic_read(&conn->refcnt))
-			conn->state = BT_CLOSED;
+		conn->state = BT_CLOSED;
 		break;
 	}
-
-	hci_dev_unlock(hdev);
 }
 
-static void hci_conn_idle(unsigned long arg)
+/* Enter sniff mode */
+static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 {
-	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	hci_conn_enter_sniff_mode(conn);
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
+		return;
+
+	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
+		return;
+
+	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
+		struct hci_cp_sniff_subrate cp;
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
+	}
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
+		struct hci_cp_sniff_mode cp;
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
+	}
 }
 
-static void hci_conn_rssi_update(struct work_struct *work)
+static void hci_conn_idle(unsigned long arg)
 {
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct hci_conn *conn =
-		container_of(delayed, struct hci_conn, rssi_update_work);
+	struct hci_conn *conn = (void *) arg;
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	hci_read_rssi(conn);
+	hci_conn_enter_sniff_mode(conn);
 }
 
-static void encryption_disabled_timeout(unsigned long userdata)
+static void hci_conn_auto_accept(unsigned long arg)
 {
-	struct hci_conn *conn = (struct hci_conn *)userdata;
-	BT_INFO("conn %p Grace Prd Exp ", conn);
-
-	hci_encrypt_cfm(conn, 0, 0);
-
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		struct hci_cp_set_conn_encrypt cp;
-		BT_INFO("HCI_CONN_ENCRYPT_PEND is set");
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
-						sizeof(cp), &cp);
-	}
+	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
 
+	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
+								&conn->dst);
 }
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst)
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	conn = kzalloc(sizeof(struct hci_conn), GFP_ATOMIC);
+	conn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);
 	if (!conn)
 		return NULL;
 
@@ -538,52 +379,40 @@
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
+	conn->key_type = 0xff;
 
-	conn->power_save = 1;
+	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-	conn->conn_valid = true;
-	spin_lock_init(&conn->lock);
-	wake_lock_init(&conn->idle_lock, WAKE_LOCK_SUSPEND, "bt_idle");
 
 	switch (type) {
 	case ACL_LINK:
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
-		conn->link_policy = hdev->link_policy;
 		break;
 	case SCO_LINK:
-		if (!pkt_type)
-			pkt_type = SCO_ESCO_MASK;
+		if (lmp_esco_capable(hdev))
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
+		else
+			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
+		break;
 	case ESCO_LINK:
-		if (!pkt_type)
-			pkt_type = ALL_ESCO_MASK;
-		if (lmp_esco_capable(hdev)) {
-			/* HCI Setup Synchronous Connection Command uses
-			   reverse logic on the EDR_ESCO_MASK bits */
-			conn->pkt_type = (pkt_type ^ EDR_ESCO_MASK) &
-					hdev->esco_type;
-		} else {
-			/* Legacy HCI Add Sco Connection Command uses a
-			   shifted bitmask */
-			conn->pkt_type = (pkt_type << 5) & hdev->pkt_type &
-					SCO_PTYPE_MASK;
-		}
+		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
 		break;
 	}
 
 	skb_queue_head_init(&conn->data_q);
 
-	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
+	INIT_LIST_HEAD(&conn->chan_list);
+
+	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
-	INIT_DELAYED_WORK(&conn->rssi_update_work, hci_conn_rssi_update);
-	setup_timer(&conn->encrypt_pause_timer, encryption_disabled_timeout,
-			(unsigned long)conn);
+	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
+							(unsigned long) conn);
 
 	atomic_set(&conn->refcnt, 0);
 
 	hci_dev_hold(hdev);
 
-	tasklet_disable(&hdev->tx_task);
-
 	hci_conn_hash_add(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
@@ -592,20 +421,6 @@
 
 	hci_conn_init_sysfs(conn);
 
-	tasklet_enable(&hdev->tx_task);
-
-	return conn;
-}
-
-struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
-							__u8 addr_type)
-{
-	struct hci_conn *conn = hci_conn_add(hdev, LE_LINK, 0, dst);
-	if (!conn)
-		return NULL;
-
-	conn->dst_type = addr_type;
-
 	return conn;
 }
 
@@ -615,17 +430,11 @@
 
 	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
 
-	spin_lock_bh(&conn->lock);
-	conn->conn_valid = false; /* conn data is being released */
-	spin_unlock_bh(&conn->lock);
-
-	/* Make sure no timers are running */
 	del_timer(&conn->idle_timer);
-	wake_lock_destroy(&conn->idle_lock);
-	del_timer(&conn->disc_timer);
-	del_timer(&conn->smp_timer);
-	__cancel_delayed_work(&conn->rssi_update_work);
-	del_timer(&conn->encrypt_pause_timer);
+
+	cancel_delayed_work_sync(&conn->disc_work);
+
+	del_timer(&conn->auto_accept_timer);
 
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
@@ -647,102 +456,35 @@
 		}
 	}
 
-	tasklet_disable(&hdev->tx_task);
+
+	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
-
 	skb_queue_purge(&conn->data_q);
 
 	hci_conn_put_device(conn);
 
 	hci_dev_put(hdev);
 
-	return 0;
-}
-
-struct hci_chan *hci_chan_add(struct hci_dev *hdev)
-{
-	struct hci_chan *chan;
-
-	BT_DBG("%s", hdev->name);
-
-	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
-	if (!chan)
-		return NULL;
-
-	atomic_set(&chan->refcnt, 0);
-
-	hci_dev_hold(hdev);
-
-	chan->hdev = hdev;
-
-	list_add(&chan->list, &hdev->chan_list.list);
-
-	return chan;
-}
-EXPORT_SYMBOL(hci_chan_add);
-
-int hci_chan_del(struct hci_chan *chan)
-{
-	BT_DBG("%s chan %p", chan->hdev->name, chan);
-
-	list_del(&chan->list);
-
-	hci_conn_put(chan->conn);
-	hci_dev_put(chan->hdev);
-
-	kfree(chan);
+	if (conn->handle == 0)
+		kfree(conn);
 
 	return 0;
 }
 
-int hci_chan_put(struct hci_chan *chan)
-{
-	struct hci_cp_disconn_logical_link cp;
-	struct hci_conn *hcon;
-	u16 ll_handle;
-
-	BT_DBG("chan %p refcnt %d", chan, atomic_read(&chan->refcnt));
-	if (!atomic_dec_and_test(&chan->refcnt))
-		return 0;
-
-	hcon = chan->conn;
-	ll_handle = chan->ll_handle;
-
-	hci_chan_del(chan);
-
-	BT_DBG("chan->conn->state %d", hcon->state);
-	if (hcon->state == BT_CONNECTED) {
-		cp.log_handle = cpu_to_le16(ll_handle);
-		hci_send_cmd(hcon->hdev, HCI_OP_DISCONN_LOGICAL_LINK,
-				sizeof(cp), &cp);
-	}
-
-	return 1;
-}
-EXPORT_SYMBOL(hci_chan_put);
-
 struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 {
 	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL;
-	struct list_head *p;
+	struct hci_dev *hdev = NULL, *d;
 
 	BT_DBG("%s -> %s", batostr(src), batostr(dst));
 
-	read_lock_bh(&hci_dev_list_lock);
+	read_lock(&hci_dev_list_lock);
 
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-
-		if (d->dev_type != HCI_BREDR)
-			continue;
+	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
 			continue;
 
@@ -765,83 +507,50 @@
 	if (hdev)
 		hdev = hci_dev_hold(hdev);
 
-	read_unlock_bh(&hci_dev_list_lock);
+	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
 EXPORT_SYMBOL(hci_get_route);
 
-struct hci_dev *hci_dev_get_type(u8 amp_type)
+/* Create SCO, ACL or LE connection.
+ * Device _must_ be locked */
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
 {
-	struct hci_dev *hdev = NULL;
-	struct hci_dev *d;
+	struct hci_conn *acl;
+	struct hci_conn *sco;
+	struct hci_conn *le;
 
-	BT_DBG("amp_type %d", amp_type);
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	read_lock_bh(&hci_dev_list_lock);
+	if (type == LE_LINK) {
+		struct adv_entry *entry;
 
-	list_for_each_entry(d, &hci_dev_list, list) {
-		if ((d->amp_type == amp_type) && test_bit(HCI_UP, &d->flags)) {
-			hdev = d;
-			break;
-		}
-	}
+		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+		if (le)
+			return ERR_PTR(-EBUSY);
 
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
+		entry = hci_find_adv_entry(hdev, dst);
+		if (!entry)
+			return ERR_PTR(-EHOSTUNREACH);
 
-	read_unlock_bh(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_dev_get_type);
+		le = hci_conn_add(hdev, LE_LINK, dst);
+		if (!le)
+			return ERR_PTR(-ENOMEM);
 
-struct hci_dev *hci_dev_get_amp(bdaddr_t *dst)
-{
-	struct hci_dev *d;
-	struct hci_dev *hdev = NULL;
+		le->dst_type = entry->bdaddr_type;
 
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+		hci_le_connect(le);
 
-	read_lock_bh(&hci_dev_list_lock);
+		hci_conn_hold(le);
 
-	list_for_each_entry(d, &hci_dev_list, list) {
-		struct hci_conn *conn;
-		if (d->dev_type == HCI_BREDR)
-			continue;
-		conn = hci_conn_hash_lookup_ba(d, ACL_LINK, dst);
-		if (conn) {
-			hdev = d;
-			break;
-		}
+		return le;
 	}
 
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
-
-	read_unlock_bh(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_dev_get_amp);
-
-/* Create SCO, ACL or LE connection.
- * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst,
-					__u8 sec_level, __u8 auth_type)
-{
-	struct hci_conn *acl;
-	struct hci_conn *sco;
-
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
-
-	if (type == LE_LINK)
-		return hci_le_connect(hdev, pkt_type, dst, sec_level,
-							auth_type, NULL);
-
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
-		acl = hci_conn_add(hdev, ACL_LINK, 0, dst);
+		acl = hci_conn_add(hdev, ACL_LINK, dst);
 		if (!acl)
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 	}
 
 	hci_conn_hold(acl);
@@ -856,23 +565,12 @@
 	if (type == ACL_LINK)
 		return acl;
 
-	/* type of connection already existing can be ESCO or SCO
-	 * so check for both types before creating new */
-
 	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
-
-	if (!sco && type == ESCO_LINK) {
-		sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst);
-	} else if (!sco && type == SCO_LINK) {
-		/* this case can be practically not possible */
-		sco = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, dst);
-	}
-
 	if (!sco) {
-		sco = hci_conn_add(hdev, type, pkt_type, dst);
+		sco = hci_conn_add(hdev, type, dst);
 		if (!sco) {
 			hci_conn_put(acl);
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 		}
 	}
 
@@ -883,12 +581,12 @@
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
-		acl->power_save = 1;
-		hci_conn_enter_active_mode(acl, 1);
+		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
+		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
-		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
+		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
 			/* defer SCO setup until mode change completed */
-			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->pend);
+			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);
 			return sco;
 		}
 
@@ -899,43 +597,12 @@
 }
 EXPORT_SYMBOL(hci_connect);
 
-void hci_disconnect(struct hci_conn *conn, __u8 reason)
-{
-	BT_DBG("conn %p", conn);
-
-	hci_proto_disconn_cfm(conn, reason, 0);
-}
-EXPORT_SYMBOL(hci_disconnect);
-
-void hci_disconnect_amp(struct hci_conn *conn, __u8 reason)
-{
-	struct hci_dev *hdev = NULL;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock_bh(&hci_dev_list_lock);
-
-	list_for_each_entry(hdev, &hci_dev_list, list) {
-		struct hci_conn *c;
-		if (hdev == conn->hdev)
-			continue;
-		if (hdev->amp_type == HCI_BREDR)
-			continue;
-		c = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &conn->dst);
-		if (c)
-			hci_disconnect(c, reason);
-	}
-
-	read_unlock_bh(&hci_dev_list_lock);
-}
-
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0 &&
-					!(conn->link_mode & HCI_LM_ENCRYPT))
+	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 
 	return 1;
@@ -957,71 +624,118 @@
 
 	/* Make sure we preserve an existing MITM requirement*/
 	auth_type |= (conn->auth_type & 0x01);
+
 	conn->auth_type = auth_type;
-	conn->auth_initiator = 1;
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 
 		/* encrypt must be pending if auth is also pending */
-		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
 
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
+		if (conn->key_type != 0xff)
+			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 	}
 
 	return 0;
 }
 
+/* Encrypt the the link */
+static void hci_conn_encrypt(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
+		struct hci_cp_set_conn_encrypt cp;
+		cp.handle  = cpu_to_le16(conn->handle);
+		cp.encrypt = 0x01;
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
+	}
+}
+
 /* Enable security */
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("conn %p %d %d", conn, sec_level, auth_type);
+	BT_DBG("conn %p", conn);
 
+	if (conn->type == LE_LINK)
+		return smp_conn_security(conn, sec_level);
+
+	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
-	if (sec_level == BT_SECURITY_LOW &&
-				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+	/* For non 2.1 devices and low security level we don't need the link
+	   key. */
+	if (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))
 		return 1;
 
-	if (conn->type == LE_LINK) {
-		if (conn->pending_sec_level > sec_level)
-			sec_level = conn->pending_sec_level;
-
-		if (sec_level > conn->sec_level)
-			conn->pending_sec_level = sec_level;
-		hci_proto_connect_cfm(conn, 0);
+	/* For other security levels we need the link key. */
+	if (!(conn->link_mode & HCI_LM_AUTH))
+		goto auth;
+
+	/* An authenticated combination key has sufficient security for any
+	   security level. */
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION)
+		goto encrypt;
+
+	/* An unauthenticated combination key has sufficient security for
+	   security level 1 and 2. */
+	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
+			(sec_level == BT_SECURITY_MEDIUM ||
+			sec_level == BT_SECURITY_LOW))
+		goto encrypt;
+
+	/* A combination key has always sufficient security for the security
+	   levels 1 or 2. High security level requires the combination key
+	   is generated using maximum PIN code length (16).
+	   For pre 2.1 units. */
+	if (conn->key_type == HCI_LK_COMBINATION &&
+			(sec_level != BT_SECURITY_HIGH ||
+			conn->pin_length == 16))
+		goto encrypt;
+
+auth:
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return 0;
-	} else if (conn->link_mode & HCI_LM_ENCRYPT) {
-		return hci_conn_auth(conn, sec_level, auth_type);
-	} else if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+
+	if (!hci_conn_auth(conn, sec_level, auth_type))
 		return 0;
-	}
 
-	if (hci_conn_auth(conn, sec_level, auth_type)) {
-		struct hci_cp_set_conn_encrypt cp;
-		if (timer_pending(&conn->encrypt_pause_timer)) {
-			BT_INFO("encrypt_pause_timer is pending");
-			return 0;
-		}
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
-							sizeof(cp), &cp);
-	}
+encrypt:
+	if (conn->link_mode & HCI_LM_ENCRYPT)
+		return 1;
 
+	hci_conn_encrypt(conn);
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_security);
 
+/* Check secure link requirement */
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
+{
+	BT_DBG("conn %p", conn);
+
+	if (sec_level != BT_SECURITY_HIGH)
+		return 1; /* Accept if non-secure is required */
+
+	if (conn->sec_level == BT_SECURITY_HIGH)
+		return 1;
+
+	return 0; /* Reject not secure link */
+}
+EXPORT_SYMBOL(hci_conn_check_secure);
+
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
@@ -1040,7 +754,7 @@
 	if (!role && conn->link_mode & HCI_LM_MASTER)
 		return 1;
 
-	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
 		struct hci_cp_switch_role cp;
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.role = role;
@@ -1061,187 +775,36 @@
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->type == LE_LINK)
-		return;
-
 	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 
-	if (!conn->power_save && !force_active)
+	if (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)
 		goto timer;
 
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 		struct hci_cp_exit_sniff_mode cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);
 	}
 
 timer:
-	if (hdev->idle_timeout > 0) {
-		spin_lock_bh(&conn->lock);
-		if (conn->conn_valid) {
-			mod_timer(&conn->idle_timer,
-				jiffies + msecs_to_jiffies(hdev->idle_timeout));
-			wake_lock(&conn->idle_lock);
-		}
-		spin_unlock_bh(&conn->lock);
-	}
+	if (hdev->idle_timeout > 0)
+		mod_timer(&conn->idle_timer,
+			jiffies + msecs_to_jiffies(hdev->idle_timeout));
 }
 
-static inline void hci_conn_stop_rssi_timer(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-	cancel_delayed_work(&conn->rssi_update_work);
-}
-
-static inline void hci_conn_start_rssi_timer(struct hci_conn *conn,
-	u16 interval)
-{
-	struct hci_dev *hdev = conn->hdev;
-	BT_DBG("conn %p, pending %d", conn,
-			delayed_work_pending(&conn->rssi_update_work));
-	if (!delayed_work_pending(&conn->rssi_update_work)) {
-		queue_delayed_work(hdev->workqueue, &conn->rssi_update_work,
-				msecs_to_jiffies(interval));
-	}
-}
-
-void hci_conn_set_rssi_reporter(struct hci_conn *conn,
-	s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed)
-{
-	if (conn) {
-		conn->rssi_threshold = rssi_threshold;
-		conn->rssi_update_interval = interval;
-		conn->rssi_update_thresh_exceed = updateOnThreshExceed;
-		hci_conn_start_rssi_timer(conn, interval);
-	}
-}
-
-void hci_conn_unset_rssi_reporter(struct hci_conn *conn)
-{
-	if (conn) {
-		BT_DBG("Deleting the rssi_update_timer");
-		hci_conn_stop_rssi_timer(conn);
-	}
-}
-
-/* Enter sniff mode */
-void hci_conn_enter_sniff_mode(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p mode %d", conn, conn->mode);
-
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
-	if (conn->type == LE_LINK)
-		return;
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE ||
-		!(conn->link_policy & HCI_LP_SNIFF) ||
-		(hci_find_link_key(hdev, &conn->dst) == NULL))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
-}
-
-struct hci_chan *hci_chan_create(struct hci_chan *chan,
-			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
-{
-	struct hci_cp_create_logical_link cp;
-
-	chan->state = BT_CONNECT;
-	chan->tx_fs = *tx_fs;
-	chan->rx_fs = *rx_fs;
-	cp.phy_handle = chan->conn->handle;
-	cp.tx_fs.id = chan->tx_fs.id;
-	cp.tx_fs.type = chan->tx_fs.type;
-	cp.tx_fs.max_sdu = cpu_to_le16(chan->tx_fs.max_sdu);
-	cp.tx_fs.sdu_arr_time = cpu_to_le32(chan->tx_fs.sdu_arr_time);
-	cp.tx_fs.acc_latency = cpu_to_le32(chan->tx_fs.acc_latency);
-	cp.tx_fs.flush_to = cpu_to_le32(chan->tx_fs.flush_to);
-	cp.rx_fs.id = chan->rx_fs.id;
-	cp.rx_fs.type = chan->rx_fs.type;
-	cp.rx_fs.max_sdu = cpu_to_le16(chan->rx_fs.max_sdu);
-	cp.rx_fs.sdu_arr_time = cpu_to_le32(chan->rx_fs.sdu_arr_time);
-	cp.rx_fs.acc_latency = cpu_to_le32(chan->rx_fs.acc_latency);
-	cp.rx_fs.flush_to = cpu_to_le32(chan->rx_fs.flush_to);
-	hci_conn_hold(chan->conn);
-	if (chan->conn->out)
-		hci_send_cmd(chan->conn->hdev, HCI_OP_CREATE_LOGICAL_LINK,
-							sizeof(cp), &cp);
-	else
-		hci_send_cmd(chan->conn->hdev, HCI_OP_ACCEPT_LOGICAL_LINK,
-							sizeof(cp), &cp);
-	return chan;
-}
-EXPORT_SYMBOL(hci_chan_create);
-
-void hci_chan_modify(struct hci_chan *chan,
-			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
-{
-	struct hci_cp_flow_spec_modify cp;
-
-	chan->tx_fs = *tx_fs;
-	chan->rx_fs = *rx_fs;
-	cp.log_handle = cpu_to_le16(chan->ll_handle);
-	cp.tx_fs.id = tx_fs->id;
-	cp.tx_fs.type = tx_fs->type;
-	cp.tx_fs.max_sdu = cpu_to_le16(tx_fs->max_sdu);
-	cp.tx_fs.sdu_arr_time = cpu_to_le32(tx_fs->sdu_arr_time);
-	cp.tx_fs.acc_latency = cpu_to_le32(tx_fs->acc_latency);
-	cp.tx_fs.flush_to = cpu_to_le32(tx_fs->flush_to);
-	cp.rx_fs.id = rx_fs->id;
-	cp.rx_fs.type = rx_fs->type;
-	cp.rx_fs.max_sdu = cpu_to_le16(rx_fs->max_sdu);
-	cp.rx_fs.sdu_arr_time = cpu_to_le32(rx_fs->sdu_arr_time);
-	cp.rx_fs.acc_latency = cpu_to_le32(rx_fs->acc_latency);
-	cp.rx_fs.flush_to = cpu_to_le32(rx_fs->flush_to);
-	hci_conn_hold(chan->conn);
-	hci_send_cmd(chan->conn->hdev, HCI_OP_FLOW_SPEC_MODIFY, sizeof(cp),
-									&cp);
-}
-EXPORT_SYMBOL(hci_chan_modify);
-
 /* Drop all connection on the device */
-void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process)
+void hci_conn_hash_flush(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
+	struct hci_conn *c, *n;
 
 	BT_DBG("hdev %s", hdev->name);
 
-	p = h->list.next;
-	while (p != &h->list) {
-		struct hci_conn *c;
-
-		c = list_entry(p, struct hci_conn, list);
-		p = p->next;
-
+	list_for_each_entry_safe(c, n, &h->list, list) {
 		c->state = BT_CLOSED;
 
-		hci_proto_disconn_cfm(c, 0x16, is_process);
+		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
 		hci_conn_del(c);
 	}
 }
@@ -1277,10 +840,10 @@
 
 int hci_get_conn_list(void __user *arg)
 {
+	register struct hci_conn *c;
 	struct hci_conn_list_req req, *cl;
 	struct hci_conn_info *ci;
 	struct hci_dev *hdev;
-	struct list_head *p;
 	int n = 0, size, err;
 
 	if (copy_from_user(&req, arg, sizeof(req)))
@@ -1303,30 +866,18 @@
 
 	ci = cl->conn_info;
 
-	hci_dev_lock_bh(hdev);
-	list_for_each(p, &hdev->conn_hash.list) {
-		register struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
-
+	hci_dev_lock(hdev);
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
 		bacpy(&(ci + n)->bdaddr, &c->dst);
 		(ci + n)->handle = c->handle;
 		(ci + n)->type  = c->type;
 		(ci + n)->out   = c->out;
 		(ci + n)->state = c->state;
 		(ci + n)->link_mode = c->link_mode;
-		if (c->type == SCO_LINK) {
-			(ci + n)->mtu = hdev->sco_mtu;
-			(ci + n)->cnt = hdev->sco_cnt;
-			(ci + n)->pkts = hdev->sco_pkts;
-		} else {
-			(ci + n)->mtu = hdev->acl_mtu;
-			(ci + n)->cnt = hdev->acl_cnt;
-			(ci + n)->pkts = hdev->acl_pkts;
-		}
 		if (++n >= req.conn_num)
 			break;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	cl->dev_id = hdev->id;
 	cl->conn_num = n;
@@ -1350,7 +901,7 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
 	if (conn) {
 		bacpy(&ci.bdaddr, &conn->dst);
@@ -1359,19 +910,8 @@
 		ci.out   = conn->out;
 		ci.state = conn->state;
 		ci.link_mode = conn->link_mode;
-		if (req.type == SCO_LINK) {
-			ci.mtu = hdev->sco_mtu;
-			ci.cnt = hdev->sco_cnt;
-			ci.pkts = hdev->sco_pkts;
-		} else {
-			ci.mtu = hdev->acl_mtu;
-			ci.cnt = hdev->acl_cnt;
-			ci.pkts = hdev->acl_pkts;
-		}
-		ci.pending_sec_level = conn->pending_sec_level;
-		ci.ssp_mode = conn->ssp_mode;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -1387,11 +927,11 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
 	if (conn)
 		req.type = conn->auth_type;
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -1399,38 +939,48 @@
 	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
 
-int hci_set_auth_info(struct hci_dev *hdev, void __user *arg)
+struct hci_chan *hci_chan_create(struct hci_conn *conn)
 {
-	struct hci_auth_info_req req;
-	struct hci_conn *conn;
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_chan *chan;
 
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
+	BT_DBG("%s conn %p", hdev->name, conn);
 
-	hci_dev_lock_bh(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
-	if (conn) {
-		conn->auth_type = req.type;
-		switch (conn->auth_type) {
-		case HCI_AT_NO_BONDING:
-			conn->pending_sec_level = BT_SECURITY_LOW;
-			break;
-		case HCI_AT_DEDICATED_BONDING:
-		case HCI_AT_GENERAL_BONDING:
-			conn->pending_sec_level = BT_SECURITY_MEDIUM;
-			break;
-		case HCI_AT_DEDICATED_BONDING_MITM:
-		case HCI_AT_GENERAL_BONDING_MITM:
-			conn->pending_sec_level = BT_SECURITY_HIGH;
-			break;
-		default:
-			break;
-		}
-	}
-	hci_dev_unlock_bh(hdev);
+	chan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);
+	if (!chan)
+		return NULL;
 
-	if (!conn)
-		return -ENOENT;
+	chan->conn = conn;
+	skb_queue_head_init(&chan->data_q);
 
-	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
+	list_add_rcu(&chan->list, &conn->chan_list);
+
+	return chan;
+}
+
+int hci_chan_del(struct hci_chan *chan)
+{
+	struct hci_conn *conn = chan->conn;
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
+
+	list_del_rcu(&chan->list);
+
+	synchronize_rcu();
+
+	skb_queue_purge(&chan->data_q);
+	kfree(chan);
+
+	return 0;
+}
+
+void hci_chan_list_flush(struct hci_conn *conn)
+{
+	struct hci_chan *chan, *n;
+
+	BT_DBG("conn %p", conn);
+
+	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
+		hci_chan_del(chan);
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_core.c flo-ElementalX-5.00-patched/net/bluetooth/hci_core.c
--- flo-ElementalX-5.00/net/bluetooth/hci_core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -39,13 +40,11 @@
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <linux/rfkill.h>
 #include <linux/timer.h>
 #include <linux/crypto.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -54,13 +53,9 @@
 
 #define AUTO_OFF_TIMEOUT 2000
 
-static void hci_cmd_task(unsigned long arg);
-static void hci_rx_task(unsigned long arg);
-static void hci_tx_task(unsigned long arg);
-
-static DEFINE_RWLOCK(hci_task_lock);
-
-static bool enable_smp = 1;
+static void hci_rx_work(struct work_struct *work);
+static void hci_cmd_work(struct work_struct *work);
+static void hci_tx_work(struct work_struct *work);
 
 /* HCI device list */
 LIST_HEAD(hci_dev_list);
@@ -70,32 +65,11 @@
 LIST_HEAD(hci_cb_list);
 DEFINE_RWLOCK(hci_cb_list_lock);
 
-/* AMP Manager event callbacks */
-LIST_HEAD(amp_mgr_cb_list);
-DEFINE_RWLOCK(amp_mgr_cb_list_lock);
-
-/* HCI protocols */
-#define HCI_MAX_PROTO	2
-struct hci_proto *hci_proto[HCI_MAX_PROTO];
-
-/* HCI notifiers list */
-static ATOMIC_NOTIFIER_HEAD(hci_notifier);
-
 /* ---- HCI notifications ---- */
 
-int hci_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&hci_notifier, nb);
-}
-
-int hci_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&hci_notifier, nb);
-}
-
 static void hci_notify(struct hci_dev *hdev, int event)
 {
-	atomic_notifier_call_chain(&hci_notifier, event, hdev);
+	hci_sock_dev_event(hdev, event);
 }
 
 /* ---- HCI requests ---- */
@@ -107,8 +81,28 @@
 	/* If this is the init phase check if the completed command matches
 	 * the last init command, and if not just return.
 	 */
-	if (test_bit(HCI_INIT, &hdev->flags) && hdev->init_last_cmd != cmd)
+	if (test_bit(HCI_INIT, &hdev->flags) && hdev->init_last_cmd != cmd) {
+		struct hci_command_hdr *sent = (void *) hdev->sent_cmd->data;
+		struct sk_buff *skb;
+
+		/* Some CSR based controllers generate a spontaneous
+		 * reset complete event during init and any pending
+		 * command will never be completed. In such a case we
+		 * need to resend whatever was the last sent
+		 * command.
+		 */
+
+		if (cmd != HCI_OP_RESET || sent->opcode == HCI_OP_RESET)
+			return;
+
+		skb = skb_clone(hdev->sent_cmd, GFP_ATOMIC);
+		if (skb) {
+			skb_queue_head(&hdev->cmd_q, skb);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
+		}
+
 		return;
+	}
 
 	if (hdev->req_status == HCI_REQ_PEND) {
 		hdev->req_result = result;
@@ -152,7 +146,7 @@
 
 	switch (hdev->req_status) {
 	case HCI_REQ_DONE:
-		err = -bt_err(hdev->req_result);
+		err = -bt_to_errno(hdev->req_result);
 		break;
 
 	case HCI_REQ_CANCELED:
@@ -193,110 +187,104 @@
 
 	/* Reset device */
 	set_bit(HCI_RESET, &hdev->flags);
-	memset(&hdev->features, 0, sizeof(hdev->features));
 	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 }
 
-static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
+static void bredr_init(struct hci_dev *hdev)
 {
 	struct hci_cp_delete_stored_link_key cp;
-	struct sk_buff *skb;
 	__le16 param;
 	__u8 flt_type;
 
-	BT_DBG("%s %ld", hdev->name, opt);
-
-	/* Driver initialization */
-
-	/* Special commands */
-	while ((skb = skb_dequeue(&hdev->driver_init))) {
-		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
-		skb->dev = (void *) hdev;
-
-		skb_queue_tail(&hdev->cmd_q, skb);
-		tasklet_schedule(&hdev->cmd_task);
-	}
-	skb_queue_purge(&hdev->driver_init);
+	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_PACKET_BASED;
 
 	/* Mandatory initialization */
 
 	/* Reset */
 	if (!test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
-			set_bit(HCI_RESET, &hdev->flags);
-			hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+		set_bit(HCI_RESET, &hdev->flags);
+		hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 	}
 
+	/* Read Local Supported Features */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
+
 	/* Read Local Version */
 	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
 
+	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
+	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
 
-	/* Set default HCI Flow Control Mode */
-	if (hdev->dev_type == HCI_BREDR)
-		hdev->flow_ctl_mode = HCI_PACKET_BASED_FLOW_CTL_MODE;
-	else
-		hdev->flow_ctl_mode = HCI_BLOCK_BASED_FLOW_CTL_MODE;
+	/* Read BD Address */
+	hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
 
-	/* Read HCI Flow Control Mode */
-	hci_send_cmd(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, 0, NULL);
+	/* Read Class of Device */
+	hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
 
-	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
+	/* Read Local Name */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
 
-	/* Read Data Block Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, 0, NULL);
+	/* Read Voice Setting */
+	hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
 
-#if 0
-	/* Host buffer size */
-	{
-		struct hci_cp_host_buffer_size cp;
-		cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
-		cp.sco_mtu = HCI_MAX_SCO_SIZE;
-		cp.acl_max_pkt = cpu_to_le16(0xffff);
-		cp.sco_max_pkt = cpu_to_le16(0xffff);
-		hci_send_cmd(hdev, HCI_OP_HOST_BUFFER_SIZE, sizeof(cp), &cp);
-	}
-#endif
-
-	if (hdev->dev_type == HCI_BREDR) {
-		/* BR-EDR initialization */
-
-		/* Read Local Supported Features */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
-
-		/* Read BD Address */
-		hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
-
-		/* Read Class of Device */
-		hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
-
-		/* Read Local Name */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
-
-		/* Read Voice Setting */
-		hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
-
-		/* Optional initialization */
-		/* Clear Event Filters */
-		flt_type = HCI_FLT_CLEAR_ALL;
-		hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
-
-		/* Connection accept timeout ~20 secs */
-		param = cpu_to_le16(0x7d00);
-		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
-
-		bacpy(&cp.bdaddr, BDADDR_ANY);
-		cp.delete_all = 1;
-		hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY,
-				sizeof(cp), &cp);
-	} else {
-		/* AMP initialization */
-		/* Connection accept timeout ~5 secs */
-		param = cpu_to_le16(0x1f40);
-		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
+	/* Optional initialization */
+
+	/* Clear Event Filters */
+	flt_type = HCI_FLT_CLEAR_ALL;
+	hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
+
+	/* Connection accept timeout ~20 secs */
+	param = cpu_to_le16(0x7d00);
+	hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
+
+	bacpy(&cp.bdaddr, BDADDR_ANY);
+	cp.delete_all = 1;
+	hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY, sizeof(cp), &cp);
+}
+
+static void amp_init(struct hci_dev *hdev)
+{
+	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_BLOCK_BASED;
+
+	/* Reset */
+	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+
+	/* Read Local Version */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
+}
+
+static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct sk_buff *skb;
+
+	BT_DBG("%s %ld", hdev->name, opt);
+
+	/* Driver initialization */
+
+	/* Special commands */
+	while ((skb = skb_dequeue(&hdev->driver_init))) {
+		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+		skb->dev = (void *) hdev;
 
-		/* Read AMP Info */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);
+		skb_queue_tail(&hdev->cmd_q, skb);
+		queue_work(hdev->workqueue, &hdev->cmd_work);
+	}
+	skb_queue_purge(&hdev->driver_init);
+
+	switch (hdev->dev_type) {
+	case HCI_BREDR:
+		bredr_init(hdev);
+		break;
+
+	case HCI_AMP:
+		amp_init(hdev);
+		break;
+
+	default:
+		BT_ERR("Unknown device type %d", hdev->dev_type);
+		break;
 	}
+
 }
 
 static void hci_le_init_req(struct hci_dev *hdev, unsigned long opt)
@@ -305,12 +293,6 @@
 
 	/* Read LE buffer size */
 	hci_send_cmd(hdev, HCI_OP_LE_READ_BUFFER_SIZE, 0, NULL);
-
-	/* Read LE clear white list */
-	hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
-
-	/* Read LE white list size */
-	hci_send_cmd(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, 0, NULL);
 }
 
 static void hci_scan_req(struct hci_dev *hdev, unsigned long opt)
@@ -357,8 +339,7 @@
  * Device is held on return. */
 struct hci_dev *hci_dev_get(int index)
 {
-	struct hci_dev *hdev = NULL;
-	struct list_head *p;
+	struct hci_dev *hdev = NULL, *d;
 
 	BT_DBG("%d", index);
 
@@ -366,8 +347,7 @@
 		return NULL;
 
 	read_lock(&hci_dev_list_lock);
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+	list_for_each_entry(d, &hci_dev_list, list) {
 		if (d->id == index) {
 			hdev = hci_dev_hold(d);
 			break;
@@ -376,75 +356,211 @@
 	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
-EXPORT_SYMBOL(hci_dev_get);
 
 /* ---- Inquiry support ---- */
-static void inquiry_cache_flush(struct hci_dev *hdev)
+
+bool hci_discovery_active(struct hci_dev *hdev)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
-	struct inquiry_entry *next  = cache->list, *e;
+	struct discovery_state *discov = &hdev->discovery;
+
+	switch (discov->state) {
+	case DISCOVERY_FINDING:
+	case DISCOVERY_RESOLVING:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+void hci_discovery_set_state(struct hci_dev *hdev, int state)
+{
+	BT_DBG("%s state %u -> %u", hdev->name, hdev->discovery.state, state);
+
+	if (hdev->discovery.state == state)
+		return;
+
+	switch (state) {
+	case DISCOVERY_STOPPED:
+		if (hdev->discovery.state != DISCOVERY_STARTING)
+			mgmt_discovering(hdev, 0);
+		hdev->discovery.type = 0;
+		break;
+	case DISCOVERY_STARTING:
+		break;
+	case DISCOVERY_FINDING:
+		mgmt_discovering(hdev, 1);
+		break;
+	case DISCOVERY_RESOLVING:
+		break;
+	case DISCOVERY_STOPPING:
+		break;
+	}
 
-	BT_DBG("cache %p", cache);
+	hdev->discovery.state = state;
+}
+
+static void inquiry_cache_flush(struct hci_dev *hdev)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *p, *n;
 
-	cache->list = NULL;
-	while ((e = next)) {
-		next = e->next;
-		kfree(e);
+	list_for_each_entry_safe(p, n, &cache->all, all) {
+		list_del(&p->all);
+		kfree(p);
 	}
+
+	INIT_LIST_HEAD(&cache->unknown);
+	INIT_LIST_HEAD(&cache->resolve);
 }
 
 struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	BT_DBG("cache %p, %s", cache, batostr(bdaddr));
+
+	list_for_each_entry(e, &cache->all, all) {
+		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr)
+{
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *e;
 
 	BT_DBG("cache %p, %s", cache, batostr(bdaddr));
 
-	for (e = cache->list; e; e = e->next)
+	list_for_each_entry(e, &cache->unknown, list) {
 		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr,
+						       int state)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	BT_DBG("cache %p bdaddr %s state %d", cache, batostr(bdaddr), state);
+
+	list_for_each_entry(e, &cache->resolve, list) {
+		if (!bacmp(bdaddr, BDADDR_ANY) && e->name_state == state)
+			return e;
+		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
+				      struct inquiry_entry *ie)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct list_head *pos = &cache->resolve;
+	struct inquiry_entry *p;
+
+	list_del(&ie->list);
+
+	list_for_each_entry(p, &cache->resolve, list) {
+		if (p->name_state != NAME_PENDING &&
+				abs(p->data.rssi) >= abs(ie->data.rssi))
 			break;
-	return e;
+		pos = &p->list;
+	}
+
+	list_add(&ie->list, pos);
 }
 
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data)
+bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+			      bool name_known, bool *ssp)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *ie;
 
 	BT_DBG("cache %p, %s", cache, batostr(&data->bdaddr));
 
+	if (ssp)
+		*ssp = data->ssp_mode;
+
 	ie = hci_inquiry_cache_lookup(hdev, &data->bdaddr);
-	if (!ie) {
-		/* Entry not in the cache. Add new one. */
-		ie = kzalloc(sizeof(struct inquiry_entry), GFP_ATOMIC);
-		if (!ie)
-			return;
+	if (ie) {
+		if (ie->data.ssp_mode && ssp)
+			*ssp = true;
+
+		if (ie->name_state == NAME_NEEDED &&
+						data->rssi != ie->data.rssi) {
+			ie->data.rssi = data->rssi;
+			hci_inquiry_cache_update_resolve(hdev, ie);
+		}
+
+		goto update;
+	}
 
-		ie->next = cache->list;
-		cache->list = ie;
+	/* Entry not in the cache. Add new one. */
+	ie = kzalloc(sizeof(struct inquiry_entry), GFP_ATOMIC);
+	if (!ie)
+		return false;
+
+	list_add(&ie->all, &cache->all);
+
+	if (name_known) {
+		ie->name_state = NAME_KNOWN;
+	} else {
+		ie->name_state = NAME_NOT_KNOWN;
+		list_add(&ie->list, &cache->unknown);
+	}
+
+update:
+	if (name_known && ie->name_state != NAME_KNOWN &&
+					ie->name_state != NAME_PENDING) {
+		ie->name_state = NAME_KNOWN;
+		list_del(&ie->list);
 	}
 
 	memcpy(&ie->data, data, sizeof(*data));
 	ie->timestamp = jiffies;
 	cache->timestamp = jiffies;
+
+	if (ie->name_state == NAME_NOT_KNOWN)
+		return false;
+
+	return true;
 }
 
 static int inquiry_cache_dump(struct hci_dev *hdev, int num, __u8 *buf)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_info *info = (struct inquiry_info *) buf;
 	struct inquiry_entry *e;
 	int copied = 0;
 
-	for (e = cache->list; e && copied < num; e = e->next, copied++) {
+	list_for_each_entry(e, &cache->all, all) {
 		struct inquiry_data *data = &e->data;
+
+		if (copied >= num)
+			break;
+
 		bacpy(&info->bdaddr, &data->bdaddr);
 		info->pscan_rep_mode	= data->pscan_rep_mode;
 		info->pscan_period_mode	= data->pscan_period_mode;
 		info->pscan_mode	= data->pscan_mode;
 		memcpy(info->dev_class, data->dev_class, 3);
 		info->clock_offset	= data->clock_offset;
+
 		info++;
+		copied++;
 	}
 
 	BT_DBG("cache %p, copied %d", cache, copied);
@@ -484,14 +600,14 @@
 	if (!hdev)
 		return -ENODEV;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	if (inquiry_cache_age(hdev) > INQUIRY_CACHE_AGE_MAX ||
 				inquiry_cache_empty(hdev) ||
 				ir.flags & IREQ_CACHE_FLUSH) {
 		inquiry_cache_flush(hdev);
 		do_inquiry = 1;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	timeo = ir.length * msecs_to_jiffies(2000);
 
@@ -513,9 +629,9 @@
 		goto done;
 	}
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	ir.num_rsp = inquiry_cache_dump(hdev, max_rsp, buf);
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	BT_DBG("num_rsp %d", ir.num_rsp);
 
@@ -549,6 +665,11 @@
 
 	hci_req_lock(hdev);
 
+	if (test_bit(HCI_UNREGISTER, &hdev->dev_flags)) {
+		ret = -ENODEV;
+		goto done;
+	}
+
 	if (hdev->rfkill && rfkill_blocked(hdev->rfkill)) {
 		ret = -ERFKILL;
 		goto done;
@@ -562,24 +683,16 @@
 	if (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))
 		set_bit(HCI_RAW, &hdev->flags);
 
+	/* Treat all non BR/EDR controllers as raw devices if
+	   enable_hs is not set */
+	if (hdev->dev_type != HCI_BREDR && !enable_hs)
+		set_bit(HCI_RAW, &hdev->flags);
+
 	if (hdev->open(hdev)) {
 		ret = -EIO;
 		goto done;
 	}
 
-	if (!skb_queue_empty(&hdev->cmd_q)) {
-		BT_ERR("command queue is not empty, purging");
-		skb_queue_purge(&hdev->cmd_q);
-	}
-	if (!skb_queue_empty(&hdev->rx_q)) {
-		BT_ERR("rx queue is not empty, purging");
-		skb_queue_purge(&hdev->rx_q);
-	}
-	if (!skb_queue_empty(&hdev->raw_q)) {
-		BT_ERR("raw queue is not empty, purging");
-		skb_queue_purge(&hdev->raw_q);
-	}
-
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		set_bit(HCI_INIT, &hdev->flags);
@@ -588,7 +701,7 @@
 		ret = __hci_request(hdev, hci_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
-		if (lmp_le_capable(hdev))
+		if (lmp_host_le_capable(hdev))
 			ret = __hci_request(hdev, hci_le_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
@@ -599,17 +712,16 @@
 		hci_dev_hold(hdev);
 		set_bit(HCI_UP, &hdev->flags);
 		hci_notify(hdev, HCI_DEV_UP);
-		if (!test_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR) {
-			hci_dev_lock_bh(hdev);
-			mgmt_powered(hdev->id, 1);
-			hci_dev_unlock_bh(hdev);
+		if (!test_bit(HCI_SETUP, &hdev->dev_flags)) {
+			hci_dev_lock(hdev);
+			mgmt_powered(hdev, 1);
+			hci_dev_unlock(hdev);
 		}
 	} else {
 		/* Init failed, cleanup */
-		tasklet_kill(&hdev->rx_task);
-		tasklet_kill(&hdev->tx_task);
-		tasklet_kill(&hdev->cmd_task);
+		flush_work(&hdev->tx_work);
+		flush_work(&hdev->cmd_work);
+		flush_work(&hdev->rx_work);
 
 		skb_queue_purge(&hdev->cmd_q);
 		skb_queue_purge(&hdev->rx_q);
@@ -632,12 +744,14 @@
 	return ret;
 }
 
-static int hci_dev_do_close(struct hci_dev *hdev, u8 is_process)
+static int hci_dev_do_close(struct hci_dev *hdev)
 {
-	unsigned long keepflags = 0;
-
 	BT_DBG("%s %p", hdev->name, hdev);
 
+	cancel_work_sync(&hdev->le_scan);
+
+	cancel_delayed_work(&hdev->power_off);
+
 	hci_req_cancel(hdev, ENODEV);
 	hci_req_lock(hdev);
 
@@ -647,38 +761,44 @@
 		return 0;
 	}
 
-	/* Kill RX and TX tasks */
-	tasklet_kill(&hdev->rx_task);
-	tasklet_kill(&hdev->tx_task);
+	/* Flush RX and TX works */
+	flush_work(&hdev->tx_work);
+	flush_work(&hdev->rx_work);
+
+	if (hdev->discov_timeout > 0) {
+		cancel_delayed_work(&hdev->discov_off);
+		hdev->discov_timeout = 0;
+		clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+	}
+
+	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		cancel_delayed_work(&hdev->service_cache);
 
-	hci_dev_lock_bh(hdev);
+	cancel_delayed_work_sync(&hdev->le_scan_disable);
+
+	hci_dev_lock(hdev);
 	inquiry_cache_flush(hdev);
-	hci_conn_hash_flush(hdev, is_process);
-	hci_dev_unlock_bh(hdev);
+	hci_conn_hash_flush(hdev);
+	hci_dev_unlock(hdev);
 
 	hci_notify(hdev, HCI_DEV_DOWN);
 
-	if (hdev->dev_type == HCI_BREDR) {
-		hci_dev_lock_bh(hdev);
-		mgmt_powered(hdev->id, 0);
-		hci_dev_unlock_bh(hdev);
-	}
-
 	if (hdev->flush)
 		hdev->flush(hdev);
 
 	/* Reset device */
 	skb_queue_purge(&hdev->cmd_q);
 	atomic_set(&hdev->cmd_cnt, 1);
-	if (!test_bit(HCI_RAW, &hdev->flags)) {
+	if (!test_bit(HCI_RAW, &hdev->flags) &&
+				test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
 		set_bit(HCI_INIT, &hdev->flags);
 		__hci_request(hdev, hci_reset_req, 0,
 					msecs_to_jiffies(250));
 		clear_bit(HCI_INIT, &hdev->flags);
 	}
 
-	/* Kill cmd task */
-	tasklet_kill(&hdev->cmd_task);
+	/* flush cmd  work */
+	flush_work(&hdev->cmd_work);
 
 	/* Drop queues */
 	skb_queue_purge(&hdev->rx_q);
@@ -696,15 +816,17 @@
 	 * and no tasks are scheduled. */
 	hdev->close(hdev);
 
-	/* Clear only non-persistent flags */
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		set_bit(HCI_MGMT, &keepflags);
-	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
-		set_bit(HCI_LINK_KEYS, &keepflags);
-	if (test_bit(HCI_DEBUG_KEYS, &hdev->flags))
-		set_bit(HCI_DEBUG_KEYS, &keepflags);
+	if (!test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags)) {
+		hci_dev_lock(hdev);
+		mgmt_powered(hdev, 0);
+		hci_dev_unlock(hdev);
+	}
+
+	/* Clear flags */
+	hdev->flags = 0;
 
-	hdev->flags = keepflags;
+	memset(hdev->eir, 0, sizeof(hdev->eir));
+	memset(hdev->dev_class, 0, sizeof(hdev->dev_class));
 
 	hci_req_unlock(hdev);
 
@@ -720,7 +842,12 @@
 	hdev = hci_dev_get(dev);
 	if (!hdev)
 		return -ENODEV;
-	err = hci_dev_do_close(hdev, 1);
+
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		cancel_delayed_work(&hdev->power_off);
+
+	err = hci_dev_do_close(hdev);
+
 	hci_dev_put(hdev);
 	return err;
 }
@@ -735,7 +862,6 @@
 		return -ENODEV;
 
 	hci_req_lock(hdev);
-	tasklet_disable(&hdev->tx_task);
 
 	if (!test_bit(HCI_UP, &hdev->flags))
 		goto done;
@@ -744,10 +870,10 @@
 	skb_queue_purge(&hdev->rx_q);
 	skb_queue_purge(&hdev->cmd_q);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	inquiry_cache_flush(hdev);
-	hci_conn_hash_flush(hdev, 0);
-	hci_dev_unlock_bh(hdev);
+	hci_conn_hash_flush(hdev);
+	hci_dev_unlock(hdev);
 
 	if (hdev->flush)
 		hdev->flush(hdev);
@@ -760,7 +886,6 @@
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
 done:
-	tasklet_enable(&hdev->tx_task);
 	hci_req_unlock(hdev);
 	hci_dev_put(hdev);
 	return ret;
@@ -859,9 +984,9 @@
 
 int hci_get_dev_list(void __user *arg)
 {
+	struct hci_dev *hdev;
 	struct hci_dev_list_req *dl;
 	struct hci_dev_req *dr;
-	struct list_head *p;
 	int n = 0, size, err;
 	__u16 dev_num;
 
@@ -879,16 +1004,13 @@
 
 	dr = dl->dev_req;
 
-	read_lock_bh(&hci_dev_list_lock);
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *hdev;
-
-		hdev = list_entry(p, struct hci_dev, list);
-
-		hci_del_off_timer(hdev);
+	read_lock(&hci_dev_list_lock);
+	list_for_each_entry(hdev, &hci_dev_list, list) {
+		if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+			cancel_delayed_work(&hdev->power_off);
 
-		if (!test_bit(HCI_MGMT, &hdev->flags))
-			set_bit(HCI_PAIRABLE, &hdev->flags);
+		if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+			set_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
 		(dr + n)->dev_id  = hdev->id;
 		(dr + n)->dev_opt = hdev->flags;
@@ -896,7 +1018,7 @@
 		if (++n >= dev_num)
 			break;
 	}
-	read_unlock_bh(&hci_dev_list_lock);
+	read_unlock(&hci_dev_list_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*dr);
@@ -920,10 +1042,11 @@
 	if (!hdev)
 		return -ENODEV;
 
-	hci_del_off_timer(hdev);
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		cancel_delayed_work_sync(&hdev->power_off);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
-		set_bit(HCI_PAIRABLE, &hdev->flags);
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		set_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
 	strcpy(di.name, hdev->name);
 	di.bdaddr   = hdev->bdaddr;
@@ -959,7 +1082,7 @@
 	if (!blocked)
 		return 0;
 
-	hci_dev_do_close(hdev, 0);
+	hci_dev_do_close(hdev);
 
 	return 0;
 }
@@ -977,6 +1100,7 @@
 	if (!hdev)
 		return NULL;
 
+	hci_init_sysfs(hdev);
 	skb_queue_head_init(&hdev->driver_init);
 
 	return hdev;
@@ -1001,45 +1125,45 @@
 	BT_DBG("%s", hdev->name);
 
 	err = hci_dev_open(hdev->id);
-	if (err && err != -EALREADY)
+	if (err < 0) {
+		mgmt_set_powered_failed(hdev, err);
 		return;
+	}
+
+	if (test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		schedule_delayed_work(&hdev->power_off,
+					msecs_to_jiffies(AUTO_OFF_TIMEOUT));
 
-	if (test_bit(HCI_AUTO_OFF, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR)
-		mod_timer(&hdev->off_timer,
-				jiffies + msecs_to_jiffies(AUTO_OFF_TIMEOUT));
-
-	if (test_and_clear_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR)
-		mgmt_index_added(hdev->id);
+	if (test_and_clear_bit(HCI_SETUP, &hdev->dev_flags))
+		mgmt_index_added(hdev);
 }
 
 static void hci_power_off(struct work_struct *work)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, power_off);
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+							power_off.work);
 
 	BT_DBG("%s", hdev->name);
 
-	hci_dev_close(hdev->id);
+	hci_dev_do_close(hdev);
 }
 
-static void hci_auto_off(unsigned long data)
+static void hci_discov_off(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) data;
+	struct hci_dev *hdev;
+	u8 scan = SCAN_PAGE;
+
+	hdev = container_of(work, struct hci_dev, discov_off.work);
 
 	BT_DBG("%s", hdev->name);
 
-	clear_bit(HCI_AUTO_OFF, &hdev->flags);
+	hci_dev_lock(hdev);
 
-	queue_work(hdev->workqueue, &hdev->power_off);
-}
+	hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, sizeof(scan), &scan);
 
-void hci_del_off_timer(struct hci_dev *hdev)
-{
-	BT_DBG("%s", hdev->name);
+	hdev->discov_timeout = 0;
 
-	clear_bit(HCI_AUTO_OFF, &hdev->flags);
-	del_timer(&hdev->off_timer);
+	hci_dev_unlock(hdev);
 }
 
 int hci_uuids_clear(struct hci_dev *hdev)
@@ -1074,80 +1198,108 @@
 	return 0;
 }
 
-struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
+int hci_smp_ltks_clear(struct hci_dev *hdev)
 {
-	struct list_head *p;
+	struct smp_ltk *k, *tmp;
+
+	list_for_each_entry_safe(k, tmp, &hdev->long_term_keys, list) {
+		list_del(&k->list);
+		kfree(k);
+	}
 
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
+	return 0;
+}
 
-		k = list_entry(p, struct link_key, list);
+struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	struct link_key *k;
 
+	list_for_each_entry(k, &hdev->link_keys, list)
 		if (bacmp(bdaddr, &k->bdaddr) == 0)
 			return k;
-	}
 
 	return NULL;
 }
 
-struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
+static bool hci_persistent_key(struct hci_dev *hdev, struct hci_conn *conn,
+						u8 key_type, u8 old_key_type)
 {
-	struct list_head *p;
+	/* Legacy key */
+	if (key_type < 0x03)
+		return true;
 
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
-		struct key_master_id *id;
+	/* Debug keys are insecure so don't store them persistently */
+	if (key_type == HCI_LK_DEBUG_COMBINATION)
+		return false;
 
-		k = list_entry(p, struct link_key, list);
+	/* Changed combination key and there's no previous one */
+	if (key_type == HCI_LK_CHANGED_COMBINATION && old_key_type == 0xff)
+		return false;
 
-		if (k->key_type != KEY_TYPE_LTK)
-			continue;
+	/* Security mode 3 case */
+	if (!conn)
+		return true;
+
+	/* Neither local nor remote side had no-bonding as requirement */
+	if (conn->auth_type > 0x01 && conn->remote_auth > 0x01)
+		return true;
+
+	/* Local side had dedicated bonding as requirement */
+	if (conn->auth_type == 0x02 || conn->auth_type == 0x03)
+		return true;
 
-		if (k->dlen != sizeof(*id))
+	/* Remote side had dedicated bonding as requirement */
+	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03)
+		return true;
+
+	/* If none of the above criteria match, then don't store the key
+	 * persistently */
+	return false;
+}
+
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
+{
+	struct smp_ltk *k;
+
+	list_for_each_entry(k, &hdev->long_term_keys, list) {
+		if (k->ediv != ediv ||
+				memcmp(rand, k->rand, sizeof(k->rand)))
 			continue;
 
-		id = (void *) &k->data;
-		if (id->ediv == ediv &&
-				(memcmp(rand, id->rand, sizeof(id->rand)) == 0))
-			return k;
+		return k;
 	}
 
 	return NULL;
 }
 EXPORT_SYMBOL(hci_find_ltk);
 
-struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
-					bdaddr_t *bdaddr, u8 type)
+struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 addr_type)
 {
-	struct list_head *p;
-
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
-
-		k = list_entry(p, struct link_key, list);
+	struct smp_ltk *k;
 
-		if ((k->key_type == type) && (bacmp(bdaddr, &k->bdaddr) == 0))
+	list_for_each_entry(k, &hdev->long_term_keys, list)
+		if (addr_type == k->bdaddr_type &&
+					bacmp(bdaddr, &k->bdaddr) == 0)
 			return k;
-	}
 
 	return NULL;
 }
-EXPORT_SYMBOL(hci_find_link_key_type);
+EXPORT_SYMBOL(hci_find_ltk_by_addr);
 
-int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-						u8 *val, u8 type, u8 pin_len)
+int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
+		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len)
 {
 	struct link_key *key, *old_key;
-	struct hci_conn *conn;
 	u8 old_key_type;
-	u8 bonded = 0;
+	bool persistent;
 
 	old_key = hci_find_link_key(hdev, bdaddr);
 	if (old_key) {
-		old_key_type = old_key->key_type;
+		old_key_type = old_key->type;
 		key = old_key;
 	} else {
-		old_key_type = 0xff;
+		old_key_type = conn ? conn->key_type : 0xff;
 		key = kzalloc(sizeof(*key), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
@@ -1156,76 +1308,72 @@
 
 	BT_DBG("%s key for %s type %u", hdev->name, batostr(bdaddr), type);
 
+	/* Some buggy controller combinations generate a changed
+	 * combination key for legacy pairing even when there's no
+	 * previous key */
+	if (type == HCI_LK_CHANGED_COMBINATION &&
+					(!conn || conn->remote_auth == 0xff) &&
+					old_key_type == 0xff) {
+		type = HCI_LK_COMBINATION;
+		if (conn)
+			conn->key_type = type;
+	}
+
 	bacpy(&key->bdaddr, bdaddr);
 	memcpy(key->val, val, 16);
-	key->auth = 0x01;
-	key->key_type = type;
 	key->pin_len = pin_len;
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
-	/* Store the link key persistently if one of the following is true:
-	 * 1. the remote side is using dedicated bonding since in that case
-	 *    also the local requirements are set to dedicated bonding
-	 * 2. the local side had dedicated bonding as a requirement
-	 * 3. this is a legacy link key
-	 * 4. this is a changed combination key and there was a previously
-	 *    stored one
-	 * If none of the above match only keep the link key around for
-	 * this connection and set the temporary flag for the device.
-	*/
+	if (type == HCI_LK_CHANGED_COMBINATION)
+		key->type = old_key_type;
+	else
+		key->type = type;
 
-	if (conn) {
-		if ((conn->remote_auth > 0x01) ||
-			(conn->auth_initiator && conn->auth_type > 0x01) ||
-			(key->key_type < 0x03) ||
-			(key->key_type == 0x06 && old_key_type != 0xff))
-			bonded = 1;
-	}
+	if (!new_key)
+		return 0;
 
-	if (new_key)
-		mgmt_new_key(hdev->id, key, bonded);
+	persistent = hci_persistent_key(hdev, conn, type, old_key_type);
 
-	if (type == 0x06)
-		key->key_type = old_key_type;
+	mgmt_new_link_key(hdev, key, persistent);
+
+	if (conn)
+		conn->flush_key = !persistent;
 
 	return 0;
 }
 
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 addr_type, u8 key_size, u8 auth,
-			__le16 ediv, u8 rand[8], u8 ltk[16])
+int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16
+		ediv, u8 rand[8])
 {
-	struct link_key *key, *old_key;
-	struct key_master_id *id;
+	struct smp_ltk *key, *old_key;
 
-	BT_DBG("%s Auth: %2.2X addr %s type: %d", hdev->name, auth,
-						batostr(bdaddr), addr_type);
+	if (!(type & HCI_SMP_STK) && !(type & HCI_SMP_LTK))
+		return 0;
 
-	old_key = hci_find_link_key_type(hdev, bdaddr, KEY_TYPE_LTK);
-	if (old_key) {
+	old_key = hci_find_ltk_by_addr(hdev, bdaddr, addr_type);
+	if (old_key)
 		key = old_key;
-	} else {
-		key = kzalloc(sizeof(*key) + sizeof(*id), GFP_ATOMIC);
+	else {
+		key = kzalloc(sizeof(*key), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
-		list_add(&key->list, &hdev->link_keys);
+		list_add(&key->list, &hdev->long_term_keys);
 	}
 
-	key->dlen = sizeof(*id);
-
 	bacpy(&key->bdaddr, bdaddr);
-	key->addr_type = addr_type;
-	memcpy(key->val, ltk, sizeof(key->val));
-	key->key_type = KEY_TYPE_LTK;
-	key->pin_len = key_size;
-	key->auth = auth;
-
-	id = (void *) &key->data;
-	id->ediv = ediv;
-	memcpy(id->rand, rand, sizeof(id->rand));
+	key->bdaddr_type = addr_type;
+	memcpy(key->val, tk, sizeof(key->val));
+	key->authenticated = authenticated;
+	key->ediv = ediv;
+	key->enc_size = enc_size;
+	key->type = type;
+	memcpy(key->rand, rand, sizeof(key->rand));
 
-	if (new_key)
-		mgmt_new_key(hdev->id, key, auth & 0x01);
+	if (!new_key)
+		return 0;
+
+	if (type & HCI_SMP_LTK)
+		mgmt_new_ltk(hdev, key, 1);
 
 	return 0;
 }
@@ -1246,6 +1394,23 @@
 	return 0;
 }
 
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	struct smp_ltk *k, *tmp;
+
+	list_for_each_entry_safe(k, tmp, &hdev->long_term_keys, list) {
+		if (bacmp(bdaddr, &k->bdaddr))
+			continue;
+
+		BT_DBG("%s removing %s", hdev->name, batostr(bdaddr));
+
+		list_del(&k->list);
+		kfree(k);
+	}
+
+	return 0;
+}
+
 /* HCI command timer function */
 static void hci_cmd_timer(unsigned long arg)
 {
@@ -1253,12 +1418,11 @@
 
 	BT_ERR("%s command tx timeout", hdev->name);
 	atomic_set(&hdev->cmd_cnt, 1);
-	clear_bit(HCI_RESET, &hdev->flags);
-	tasklet_schedule(&hdev->cmd_task);
+	queue_work(hdev->workqueue, &hdev->cmd_work);
 }
 
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
-							bdaddr_t *bdaddr)
+					  bdaddr_t *bdaddr)
 {
 	struct oob_data *data;
 
@@ -1297,158 +1461,282 @@
 	return 0;
 }
 
-static void hci_adv_clear(unsigned long arg)
-{
-	struct hci_dev *hdev = (void *) arg;
-
-	hci_adv_entries_clear(hdev);
-}
-
-int hci_adv_entries_clear(struct hci_dev *hdev)
+int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
+			    u8 *randomizer)
 {
-	struct list_head *p, *n;
-
-	BT_DBG("");
-	write_lock_bh(&hdev->adv_entries_lock);
+	struct oob_data *data;
 
-	list_for_each_safe(p, n, &hdev->adv_entries) {
-		struct adv_entry *entry;
+	data = hci_find_remote_oob_data(hdev, bdaddr);
 
-		entry = list_entry(p, struct adv_entry, list);
+	if (!data) {
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
 
-		list_del(p);
-		kfree(entry);
+		bacpy(&data->bdaddr, bdaddr);
+		list_add(&data->list, &hdev->remote_oob_data);
 	}
 
-	write_unlock_bh(&hdev->adv_entries_lock);
+	memcpy(data->hash, hash, sizeof(data->hash));
+	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
+
+	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
 
 	return 0;
 }
 
-struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
+struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct list_head *p;
-	struct adv_entry *res = NULL;
+	struct bdaddr_list *b;
 
-	BT_DBG("");
-	read_lock_bh(&hdev->adv_entries_lock);
+	list_for_each_entry(b, &hdev->blacklist, list)
+		if (bacmp(bdaddr, &b->bdaddr) == 0)
+			return b;
 
-	list_for_each(p, &hdev->adv_entries) {
-		struct adv_entry *entry;
+	return NULL;
+}
 
-		entry = list_entry(p, struct adv_entry, list);
+int hci_blacklist_clear(struct hci_dev *hdev)
+{
+	struct list_head *p, *n;
 
-		if (bacmp(bdaddr, &entry->bdaddr) == 0) {
-			res = entry;
-			goto out;
-		}
+	list_for_each_safe(p, n, &hdev->blacklist) {
+		struct bdaddr_list *b;
+
+		b = list_entry(p, struct bdaddr_list, list);
+
+		list_del(p);
+		kfree(b);
 	}
-out:
-	read_unlock_bh(&hdev->adv_entries_lock);
-	return res;
+
+	return 0;
 }
 
-static inline int is_connectable_adv(u8 evt_type)
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
-		return 1;
+	struct bdaddr_list *entry;
 
-	return 0;
+	if (bacmp(bdaddr, BDADDR_ANY) == 0)
+		return -EBADF;
+
+	if (hci_blacklist_lookup(hdev, bdaddr))
+		return -EEXIST;
+
+	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	bacpy(&entry->bdaddr, bdaddr);
+
+	list_add(&entry->list, &hdev->blacklist);
+
+	return mgmt_device_blocked(hdev, bdaddr, type);
 }
 
-int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
-								u8 *randomizer)
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct oob_data *data;
+	struct bdaddr_list *entry;
 
-	data = hci_find_remote_oob_data(hdev, bdaddr);
+	if (bacmp(bdaddr, BDADDR_ANY) == 0)
+		return hci_blacklist_clear(hdev);
 
-	if (!data) {
-		data = kmalloc(sizeof(*data), GFP_ATOMIC);
-		if (!data)
-			return -ENOMEM;
+	entry = hci_blacklist_lookup(hdev, bdaddr);
+	if (!entry)
+		return -ENOENT;
 
-		bacpy(&data->bdaddr, bdaddr);
-		list_add(&data->list, &hdev->remote_oob_data);
-	}
+	list_del(&entry->list);
+	kfree(entry);
 
-	memcpy(data->hash, hash, sizeof(data->hash));
-	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
+	return mgmt_device_unblocked(hdev, bdaddr, type);
+}
 
-	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
+static void hci_clear_adv_cache(struct work_struct *work)
+{
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    adv_work.work);
+
+	hci_dev_lock(hdev);
+
+	hci_adv_entries_clear(hdev);
+
+	hci_dev_unlock(hdev);
+}
+
+int hci_adv_entries_clear(struct hci_dev *hdev)
+{
+	struct adv_entry *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &hdev->adv_entries, list) {
+		list_del(&entry->list);
+		kfree(entry);
+	}
+
+	BT_DBG("%s adv cache cleared", hdev->name);
 
 	return 0;
 }
 
-int hci_add_adv_entry(struct hci_dev *hdev,
-					struct hci_ev_le_advertising_info *ev)
+struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	struct adv_entry *entry;
-	u8 flags = 0;
-	int i;
 
-	BT_DBG("");
+	list_for_each_entry(entry, &hdev->adv_entries, list)
+		if (bacmp(bdaddr, &entry->bdaddr) == 0)
+			return entry;
 
-	if (!is_connectable_adv(ev->evt_type))
-		return -EINVAL;
+	return NULL;
+}
 
-	if (ev->data && ev->length) {
-		for (i = 0; (i + 2) < ev->length; i++)
-			if (ev->data[i+1] == 0x01) {
-				flags = ev->data[i+2];
-				BT_DBG("flags: %2.2x", flags);
-				break;
-			} else {
-				i += ev->data[i];
-			}
-	}
+static inline int is_connectable_adv(u8 evt_type)
+{
+	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
+		return 1;
+
+	return 0;
+}
+
+int hci_add_adv_entry(struct hci_dev *hdev,
+					struct hci_ev_le_advertising_info *ev) { struct adv_entry *entry; if (!is_connectable_adv(ev->evt_type))
+		return -EINVAL;
 
-	entry = hci_find_adv_entry(hdev, &ev->bdaddr);
 	/* Only new entries should be added to adv_entries. So, if
 	 * bdaddr was found, don't add it. */
-	if (entry) {
-		entry->flags = flags;
+	if (hci_find_adv_entry(hdev, &ev->bdaddr))
 		return 0;
-	}
 
-	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
 
 	bacpy(&entry->bdaddr, &ev->bdaddr);
 	entry->bdaddr_type = ev->bdaddr_type;
-	entry->flags = flags;
 
-	write_lock(&hdev->adv_entries_lock);
 	list_add(&entry->list, &hdev->adv_entries);
-	write_unlock(&hdev->adv_entries_lock);
+
+	BT_DBG("%s adv entry added: address %s type %u", hdev->name,
+				batostr(&entry->bdaddr), entry->bdaddr_type);
+
+	return 0;
+}
+
+static void le_scan_param_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct le_scan_params *param =  (struct le_scan_params *) opt;
+	struct hci_cp_le_set_scan_param cp;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.type = param->type;
+	cp.interval = cpu_to_le16(param->interval);
+	cp.window = cpu_to_le16(param->window);
+
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_PARAM, sizeof(cp), &cp);
+}
+
+static void le_scan_enable_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct hci_cp_le_set_scan_enable cp;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.enable = 1;
+
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
+}
+
+static int hci_do_le_scan(struct hci_dev *hdev, u8 type, u16 interval,
+			  u16 window, int timeout)
+{
+	long timeo = msecs_to_jiffies(3000);
+	struct le_scan_params param;
+	int err;
+
+	BT_DBG("%s", hdev->name);
+
+	if (test_bit(HCI_LE_SCAN, &hdev->dev_flags))
+		return -EINPROGRESS;
+
+	param.type = type;
+	param.interval = interval;
+	param.window = window;
+
+	hci_req_lock(hdev);
+
+	err = __hci_request(hdev, le_scan_param_req, (unsigned long) &param,
+			    timeo);
+	if (!err)
+		err = __hci_request(hdev, le_scan_enable_req, 0, timeo);
+
+	hci_req_unlock(hdev);
+
+	if (err < 0)
+		return err;
+
+	schedule_delayed_work(&hdev->le_scan_disable,
+			      msecs_to_jiffies(timeout));
 
 	return 0;
 }
 
-static struct crypto_blkcipher *alloc_cypher(void)
+static void le_scan_disable_work(struct work_struct *work)
 {
-	if (enable_smp)
-		return crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    le_scan_disable.work);
+	struct hci_cp_le_set_scan_enable cp;
+
+	BT_DBG("%s", hdev->name);
+
+	memset(&cp, 0, sizeof(cp));
 
-	return ERR_PTR(-ENOTSUPP);
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
+}
+
+static void le_scan_work(struct work_struct *work)
+{
+	struct hci_dev *hdev = container_of(work, struct hci_dev, le_scan);
+	struct le_scan_params *param = &hdev->le_scan_params;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_do_le_scan(hdev, param->type, param->interval, param->window,
+		       param->timeout);
+}
+
+int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
+		int timeout)
+{
+	struct le_scan_params *param = &hdev->le_scan_params;
+
+	BT_DBG("%s", hdev->name);
+
+	if (work_busy(&hdev->le_scan))
+		return -EINPROGRESS;
+
+	param->type = type;
+	param->interval = interval;
+	param->window = window;
+	param->timeout = timeout;
+
+	queue_work(system_long_wq, &hdev->le_scan);
+
+	return 0;
 }
 
 /* Register HCI device */
 int hci_register_dev(struct hci_dev *hdev)
 {
 	struct list_head *head = &hci_dev_list, *p;
-	int i, id;
+	int i, id, error;
 
-	BT_DBG("%p name %s bus %d owner %p", hdev, hdev->name,
-						hdev->bus, hdev->owner);
+	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	if (!hdev->open || !hdev->close || !hdev->destruct)
+	if (!hdev->open || !hdev->close)
 		return -EINVAL;
 
+	/* Do not allow HCI_AMP devices to register at index 0,
+	 * so the index can be used as the AMP controller ID.
+	 */
 	id = (hdev->dev_type == HCI_BREDR) ? 0 : 1;
 
-	write_lock_bh(&hci_dev_list_lock);
+	write_lock(&hci_dev_list_lock);
 
 	/* Find first available device id */
 	list_for_each(p, &hci_dev_list) {
@@ -1459,12 +1747,12 @@
 
 	sprintf(hdev->name, "hci%d", id);
 	hdev->id = id;
-	list_add(&hdev->list, head);
+	list_add_tail(&hdev->list, head);
 
-	atomic_set(&hdev->refcnt, 1);
-	spin_lock_init(&hdev->lock);
+	mutex_init(&hdev->lock);
 
 	hdev->flags = 0;
+	hdev->dev_flags = 0;
 	hdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);
 	hdev->esco_type = (ESCO_HV1);
 	hdev->link_mode = (HCI_LM_ACCEPT);
@@ -1474,19 +1762,16 @@
 	hdev->sniff_max_interval = 800;
 	hdev->sniff_min_interval = 80;
 
-	tasklet_init(&hdev->cmd_task, hci_cmd_task, (unsigned long) hdev);
-	tasklet_init(&hdev->rx_task, hci_rx_task, (unsigned long) hdev);
-	tasklet_init(&hdev->tx_task, hci_tx_task, (unsigned long) hdev);
+	INIT_WORK(&hdev->rx_work, hci_rx_work);
+	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
+	INIT_WORK(&hdev->tx_work, hci_tx_work);
+
 
 	skb_queue_head_init(&hdev->rx_q);
 	skb_queue_head_init(&hdev->cmd_q);
 	skb_queue_head_init(&hdev->raw_q);
 
 	setup_timer(&hdev->cmd_timer, hci_cmd_timer, (unsigned long) hdev);
-	setup_timer(&hdev->disco_timer, mgmt_disco_timeout,
-						(unsigned long) hdev);
-	setup_timer(&hdev->disco_le_timer, mgmt_disco_le_timeout,
-						(unsigned long) hdev);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		hdev->reassembly[i] = NULL;
@@ -1494,43 +1779,49 @@
 	init_waitqueue_head(&hdev->req_wait_q);
 	mutex_init(&hdev->req_lock);
 
-	inquiry_cache_init(hdev);
+	discovery_init(hdev);
 
 	hci_conn_hash_init(hdev);
-	hci_chan_list_init(hdev);
+
+	INIT_LIST_HEAD(&hdev->mgmt_pending);
 
 	INIT_LIST_HEAD(&hdev->blacklist);
 
 	INIT_LIST_HEAD(&hdev->uuids);
 
 	INIT_LIST_HEAD(&hdev->link_keys);
+	INIT_LIST_HEAD(&hdev->long_term_keys);
 
 	INIT_LIST_HEAD(&hdev->remote_oob_data);
 
 	INIT_LIST_HEAD(&hdev->adv_entries);
-	rwlock_init(&hdev->adv_entries_lock);
-	setup_timer(&hdev->adv_timer, hci_adv_clear, (unsigned long) hdev);
 
+	INIT_DELAYED_WORK(&hdev->adv_work, hci_clear_adv_cache);
 	INIT_WORK(&hdev->power_on, hci_power_on);
-	INIT_WORK(&hdev->power_off, hci_power_off);
-	setup_timer(&hdev->off_timer, hci_auto_off, (unsigned long) hdev);
+	INIT_DELAYED_WORK(&hdev->power_off, hci_power_off);
+
+	INIT_DELAYED_WORK(&hdev->discov_off, hci_discov_off);
 
 	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	atomic_set(&hdev->promisc, 0);
 
-	write_unlock_bh(&hci_dev_list_lock);
+	INIT_WORK(&hdev->le_scan, le_scan_work);
+
+	INIT_DELAYED_WORK(&hdev->le_scan_disable, le_scan_disable_work);
 
-	hdev->workqueue = create_singlethread_workqueue(hdev->name);
-	if (!hdev->workqueue)
-		goto nomem;
-
-	hdev->tfm = alloc_cypher();
-	if (IS_ERR(hdev->tfm))
-		BT_INFO("Failed to load transform for ecb(aes): %ld",
-							PTR_ERR(hdev->tfm));
+	write_unlock(&hci_dev_list_lock);
 
-	hci_register_sysfs(hdev);
+	hdev->workqueue = alloc_workqueue(hdev->name, WQ_HIGHPRI | WQ_UNBOUND |
+							WQ_MEM_RECLAIM, 1);
+	if (!hdev->workqueue) {
+		error = -ENOMEM;
+		goto err;
+	}
+
+	error = hci_add_sysfs(hdev);
+	if (error < 0)
+		goto err_wqueue;
 
 	hdev->rfkill = rfkill_alloc(hdev->name, &hdev->dev,
 				RFKILL_TYPE_BLUETOOTH, &hci_rfkill_ops, hdev);
@@ -1541,49 +1832,56 @@
 		}
 	}
 
-	set_bit(HCI_AUTO_OFF, &hdev->flags);
-	set_bit(HCI_SETUP, &hdev->flags);
-	queue_work(hdev->workqueue, &hdev->power_on);
+	set_bit(HCI_AUTO_OFF, &hdev->dev_flags);
+	set_bit(HCI_SETUP, &hdev->dev_flags);
+	schedule_work(&hdev->power_on);
 
 	hci_notify(hdev, HCI_DEV_REG);
+	hci_dev_hold(hdev);
 
 	return id;
 
-nomem:
-	write_lock_bh(&hci_dev_list_lock);
+err_wqueue:
+	destroy_workqueue(hdev->workqueue);
+err:
+	write_lock(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock_bh(&hci_dev_list_lock);
+	write_unlock(&hci_dev_list_lock);
 
-	return -ENOMEM;
+	return error;
 }
 EXPORT_SYMBOL(hci_register_dev);
 
 /* Unregister HCI device */
-int hci_unregister_dev(struct hci_dev *hdev)
+void hci_unregister_dev(struct hci_dev *hdev)
 {
 	int i;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	write_lock_bh(&hci_dev_list_lock);
+	set_bit(HCI_UNREGISTER, &hdev->dev_flags);
+
+	write_lock(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock_bh(&hci_dev_list_lock);
+	write_unlock(&hci_dev_list_lock);
 
-	hci_dev_do_close(hdev, hdev->bus == HCI_SMD);
+	hci_dev_do_close(hdev);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		kfree_skb(hdev->reassembly[i]);
 
+	cancel_work_sync(&hdev->power_on);
+
 	if (!test_bit(HCI_INIT, &hdev->flags) &&
-				!test_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR) {
-		hci_dev_lock_bh(hdev);
-		mgmt_index_removed(hdev->id);
-		hci_dev_unlock_bh(hdev);
+				!test_bit(HCI_SETUP, &hdev->dev_flags)) {
+		hci_dev_lock(hdev);
+		mgmt_index_removed(hdev);
+		hci_dev_unlock(hdev);
 	}
 
-	if (!IS_ERR(hdev->tfm))
-		crypto_free_blkcipher(hdev->tfm);
+	/* mgmt_index_removed should take care of emptying the
+	 * pending list */
+	BUG_ON(!list_empty(&hdev->mgmt_pending));
 
 	hci_notify(hdev, HCI_DEV_UNREG);
 
@@ -1592,28 +1890,22 @@
 		rfkill_destroy(hdev->rfkill);
 	}
 
-	hci_unregister_sysfs(hdev);
+	hci_del_sysfs(hdev);
 
-	/* Disable all timers */
-	hci_del_off_timer(hdev);
-	del_timer(&hdev->adv_timer);
-	del_timer(&hdev->cmd_timer);
-	del_timer(&hdev->disco_timer);
-	del_timer(&hdev->disco_le_timer);
+	cancel_delayed_work_sync(&hdev->adv_work);
 
 	destroy_workqueue(hdev->workqueue);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	hci_blacklist_clear(hdev);
 	hci_uuids_clear(hdev);
 	hci_link_keys_clear(hdev);
+	hci_smp_ltks_clear(hdev);
 	hci_remote_oob_data_clear(hdev);
 	hci_adv_entries_clear(hdev);
-	hci_dev_unlock_bh(hdev);
-
-	__hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
-	return 0;
+	hci_dev_put(hdev);
 }
 EXPORT_SYMBOL(hci_unregister_dev);
 
@@ -1649,9 +1941,8 @@
 	/* Time stamp */
 	__net_timestamp(skb);
 
-	/* Queue frame for rx task */
 	skb_queue_tail(&hdev->rx_q, skb);
-	tasklet_schedule(&hdev->rx_task);
+	queue_work(hdev->workqueue, &hdev->rx_work);
 
 	return 0;
 }
@@ -1702,7 +1993,7 @@
 
 	while (count) {
 		scb = (void *) skb->cb;
-		len = min(scb->expect, (__u16)count);
+		len = min_t(uint, scb->expect, count);
 
 		memcpy(skb_put(skb, len), data, len);
 
@@ -1780,7 +2071,7 @@
 
 		data += (count - rem);
 		count = rem;
-	};
+	}
 
 	return rem;
 }
@@ -1815,7 +2106,7 @@
 
 		data += (count - rem);
 		count = rem;
-	};
+	}
 
 	return rem;
 }
@@ -1823,59 +2114,13 @@
 
 /* ---- Interface to upper protocols ---- */
 
-/* Register/Unregister protocols.
- * hci_task_lock is used to ensure that no tasks are running. */
-int hci_register_proto(struct hci_proto *hp)
-{
-	int err = 0;
-
-	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
-
-	if (hp->id >= HCI_MAX_PROTO)
-		return -EINVAL;
-
-	write_lock_bh(&hci_task_lock);
-
-	if (!hci_proto[hp->id])
-		hci_proto[hp->id] = hp;
-	else
-		err = -EEXIST;
-
-	write_unlock_bh(&hci_task_lock);
-
-	return err;
-}
-EXPORT_SYMBOL(hci_register_proto);
-
-int hci_unregister_proto(struct hci_proto *hp)
-{
-	int err = 0;
-
-	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
-
-	if (hp->id >= HCI_MAX_PROTO)
-		return -EINVAL;
-
-	write_lock_bh(&hci_task_lock);
-
-	if (hci_proto[hp->id])
-		hci_proto[hp->id] = NULL;
-	else
-		err = -ENOENT;
-
-	write_unlock_bh(&hci_task_lock);
-
-	return err;
-}
-EXPORT_SYMBOL(hci_unregister_proto);
-
 int hci_register_cb(struct hci_cb *cb)
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock_bh(&hci_cb_list_lock);
+	write_lock(&hci_cb_list_lock);
 	list_add(&cb->list, &hci_cb_list);
-	write_unlock_bh(&hci_cb_list_lock);
+	write_unlock(&hci_cb_list_lock);
 
 	return 0;
 }
@@ -1885,82 +2130,14 @@
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock_bh(&hci_cb_list_lock);
+	write_lock(&hci_cb_list_lock);
 	list_del(&cb->list);
-	write_unlock_bh(&hci_cb_list_lock);
+	write_unlock(&hci_cb_list_lock);
 
 	return 0;
 }
 EXPORT_SYMBOL(hci_unregister_cb);
 
-int hci_register_amp(struct amp_mgr_cb *cb)
-{
-	BT_DBG("%p", cb);
-
-	write_lock_bh(&amp_mgr_cb_list_lock);
-	list_add(&cb->list, &amp_mgr_cb_list);
-	write_unlock_bh(&amp_mgr_cb_list_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_register_amp);
-
-int hci_unregister_amp(struct amp_mgr_cb *cb)
-{
-	BT_DBG("%p", cb);
-
-	write_lock_bh(&amp_mgr_cb_list_lock);
-	list_del(&cb->list);
-	write_unlock_bh(&amp_mgr_cb_list_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_unregister_amp);
-
-void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
-			struct sk_buff *skb)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("opcode 0x%x", opcode);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_cmd_complete_event)
-			cb->amp_cmd_complete_event(hdev, opcode, skb);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
-void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("opcode 0x%x, status %d", opcode, status);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_cmd_status_event)
-			cb->amp_cmd_status_event(hdev, opcode, status);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
-void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
-			struct sk_buff *skb)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("ev_code 0x%x", ev_code);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_event)
-			cb->amp_event(hdev, ev_code, skb);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
 static int hci_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
@@ -1972,17 +2149,20 @@
 
 	BT_DBG("%s type %d len %d", hdev->name, bt_cb(skb)->pkt_type, skb->len);
 
-	if (atomic_read(&hdev->promisc)) {
-		/* Time stamp */
-		__net_timestamp(skb);
+	/* Time stamp */
+	__net_timestamp(skb);
 
-		hci_send_to_sock(hdev, skb, NULL);
+	/* Send copy to monitor */
+	hci_send_to_monitor(hdev, skb);
+
+	if (atomic_read(&hdev->promisc)) {
+		/* Send copy to the sockets */
+		hci_send_to_sock(hdev, skb);
 	}
 
 	/* Get rid of skb owner, prior to sending to the driver. */
 	skb_orphan(skb);
 
-	hci_notify(hdev, HCI_DEV_WRITE);
 	return hdev->send(skb);
 }
 
@@ -2017,11 +2197,10 @@
 		hdev->init_last_cmd = opcode;
 
 	skb_queue_tail(&hdev->cmd_q, skb);
-	tasklet_schedule(&hdev->cmd_task);
+	queue_work(hdev->workqueue, &hdev->cmd_work);
 
 	return 0;
 }
-EXPORT_SYMBOL(hci_send_cmd);
 
 /* Get data from the previously sent command */
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)
@@ -2054,27 +2233,18 @@
 	hdr->dlen   = cpu_to_le16(len);
 }
 
-void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
-		struct sk_buff *skb, __u16 flags)
+static void hci_queue_acl(struct hci_conn *conn, struct sk_buff_head *queue,
+				struct sk_buff *skb, __u16 flags)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct sk_buff *list;
 
-	BT_DBG("%s conn %p chan %p flags 0x%x", hdev->name, conn, chan, flags);
-
-	skb->dev = (void *) hdev;
-	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-	if (hdev->dev_type == HCI_BREDR)
-		hci_add_acl_hdr(skb, conn->handle, flags);
-	else
-		hci_add_acl_hdr(skb, chan->ll_handle, flags);
-
 	list = skb_shinfo(skb)->frag_list;
 	if (!list) {
 		/* Non fragmented */
 		BT_DBG("%s nonfrag skb %p len %d", hdev->name, skb, skb->len);
 
-		skb_queue_tail(&conn->data_q, skb);
+		skb_queue_tail(queue, skb);
 	} else {
 		/* Fragmented */
 		BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
@@ -2082,10 +2252,11 @@
 		skb_shinfo(skb)->frag_list = NULL;
 
 		/* Queue all fragments atomically */
-		spin_lock_bh(&conn->data_q.lock);
+		spin_lock(&queue->lock);
 
-		__skb_queue_tail(&conn->data_q, skb);
-		flags &= ~ACL_PB_MASK;
+		__skb_queue_tail(queue, skb);
+
+		flags &= ~ACL_START;
 		flags |= ACL_CONT;
 		do {
 			skb = list; list = list->next;
@@ -2096,13 +2267,27 @@
 
 			BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
 
-			__skb_queue_tail(&conn->data_q, skb);
+			__skb_queue_tail(queue, skb);
 		} while (list);
 
-		spin_unlock_bh(&conn->data_q.lock);
+		spin_unlock(&queue->lock);
 	}
+}
 
-	tasklet_schedule(&hdev->tx_task);
+void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags)
+{
+	struct hci_conn *conn = chan->conn;
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s chan %p flags 0x%x", hdev->name, chan, flags);
+
+	skb->dev = (void *) hdev;
+	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
+	hci_add_acl_hdr(skb, conn->handle, flags);
+
+	hci_queue_acl(conn, &chan->data_q, skb, flags);
+
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 EXPORT_SYMBOL(hci_send_acl);
 
@@ -2125,75 +2310,25 @@
 	bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
 
 	skb_queue_tail(&conn->data_q, skb);
-	tasklet_schedule(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 EXPORT_SYMBOL(hci_send_sco);
 
 /* ---- HCI TX task (outgoing data) ---- */
-/* HCI ACL Connection scheduler */
-static inline struct hci_conn *hci_low_sent_acl(struct hci_dev *hdev,
-								int *quote)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn = NULL;
-	int num = 0, min = ~0, conn_num = 0;
-	struct list_head *p;
-
-	/* We don't have to lock device here. Connections are always
-	 * added and removed with TX task disabled. */
-	list_for_each(p, &h->list) {
-		struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == ACL_LINK)
-			conn_num++;
-
-		if (skb_queue_empty(&c->data_q))
-			continue;
-
-		if (c->state != BT_CONNECTED && c->state != BT_CONFIG)
-			continue;
-
-		num++;
-
-		if (c->sent < min) {
-			min  = c->sent;
-			conn = c;
-		}
-	}
-
-	if (conn) {
-		int cnt, q;
-		cnt = hdev->acl_cnt;
-		q = cnt / num;
-		*quote = q ? q : 1;
-	} else
-		*quote = 0;
-
-	if ((*quote == hdev->acl_cnt) &&
-		(conn->sent == (hdev->acl_pkts - 1)) &&
-		(conn_num > 1)) {
-			*quote = 0;
-			conn = NULL;
-	}
-
-	BT_DBG("conn %p quote %d", conn, *quote);
-	return conn;
-}
 
 /* HCI Connection scheduler */
 static inline struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type, int *quote)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn = NULL;
+	struct hci_conn *conn = NULL, *c;
 	int num = 0, min = ~0;
-	struct list_head *p;
 
 	/* We don't have to lock device here. Connections are always
 	 * added and removed with TX task disabled. */
-	list_for_each(p, &h->list) {
-		struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
 
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
 		if (c->type != type || skb_queue_empty(&c->data_q))
 			continue;
 
@@ -2206,8 +2341,13 @@
 			min  = c->sent;
 			conn = c;
 		}
+
+		if (hci_conn_num(hdev, type) == num)
+			break;
 	}
 
+	rcu_read_unlock();
+
 	if (conn) {
 		int cnt, q;
 
@@ -2239,69 +2379,270 @@
 static inline void hci_link_tx_to(struct hci_dev *hdev, __u8 type)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
-	struct hci_conn  *c;
+	struct hci_conn *c;
 
 	BT_ERR("%s link tx timeout", hdev->name);
 
+	rcu_read_lock();
+
 	/* Kill stalled connections */
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
+	list_for_each_entry_rcu(c, &h->list, list) {
 		if (c->type == type && c->sent) {
 			BT_ERR("%s killing stalled connection %s",
 				hdev->name, batostr(&c->dst));
 			hci_acl_disconn(c, 0x13);
 		}
 	}
+
+	rcu_read_unlock();
 }
 
-static inline void hci_sched_acl(struct hci_dev *hdev)
+static inline struct hci_chan *hci_chan_sent(struct hci_dev *hdev, __u8 type,
+						int *quote)
 {
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_chan *chan = NULL;
+	int num = 0, min = ~0, cur_prio = 0;
 	struct hci_conn *conn;
-	struct sk_buff *skb;
-	int quote;
+	int cnt, q, conn_num = 0;
+
+	BT_DBG("%s", hdev->name);
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(conn, &h->list, list) {
+		struct hci_chan *tmp;
+
+		if (conn->type != type)
+			continue;
+
+		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
+			continue;
+
+		conn_num++;
+
+		list_for_each_entry_rcu(tmp, &conn->chan_list, list) {
+			struct sk_buff *skb;
+
+			if (skb_queue_empty(&tmp->data_q))
+				continue;
+
+			skb = skb_peek(&tmp->data_q);
+			if (skb->priority < cur_prio)
+				continue;
+
+			if (skb->priority > cur_prio) {
+				num = 0;
+				min = ~0;
+				cur_prio = skb->priority;
+			}
+
+			num++;
+
+			if (conn->sent < min) {
+				min  = conn->sent;
+				chan = tmp;
+			}
+		}
+
+		if (hci_conn_num(hdev, type) == conn_num)
+			break;
+	}
+
+	rcu_read_unlock();
+
+	if (!chan)
+		return NULL;
+
+	switch (chan->conn->type) {
+	case ACL_LINK:
+		cnt = hdev->acl_cnt;
+		break;
+	case SCO_LINK:
+	case ESCO_LINK:
+		cnt = hdev->sco_cnt;
+		break;
+	case LE_LINK:
+		cnt = hdev->le_mtu ? hdev->le_cnt : hdev->acl_cnt;
+		break;
+	default:
+		cnt = 0;
+		BT_ERR("Unknown link type");
+	}
+
+	q = cnt / num;
+	*quote = q ? q : 1;
+	BT_DBG("chan %p quote %d", chan, *quote);
+	return chan;
+}
+
+static void hci_prio_recalculate(struct hci_dev *hdev, __u8 type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn *conn;
+	int num = 0;
 
 	BT_DBG("%s", hdev->name);
 
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(conn, &h->list, list) {
+		struct hci_chan *chan;
+
+		if (conn->type != type)
+			continue;
+
+		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
+			continue;
+
+		num++;
+
+		list_for_each_entry_rcu(chan, &conn->chan_list, list) {
+			struct sk_buff *skb;
+
+			if (chan->sent) {
+				chan->sent = 0;
+				continue;
+			}
+
+			if (skb_queue_empty(&chan->data_q))
+				continue;
+
+			skb = skb_peek(&chan->data_q);
+			if (skb->priority >= HCI_PRIO_MAX - 1)
+				continue;
+
+			skb->priority = HCI_PRIO_MAX - 1;
+
+			BT_DBG("chan %p skb %p promoted to %d", chan, skb,
+								skb->priority);
+		}
+
+		if (hci_conn_num(hdev, type) == num)
+			break;
+	}
+
+	rcu_read_unlock();
+
+}
+
+static inline int __get_blocks(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	/* Calculate count of blocks used by this packet */
+	return DIV_ROUND_UP(skb->len - HCI_ACL_HDR_SIZE, hdev->block_len);
+}
+
+static inline void __check_timeout(struct hci_dev *hdev, unsigned int cnt)
+{
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* ACL tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
-		if (hdev->acl_cnt <= 0 &&
-			time_after(jiffies, hdev->acl_last_tx + HZ * 45))
+		if (!cnt && time_after(jiffies, hdev->acl_last_tx +
+					msecs_to_jiffies(HCI_ACL_TX_TIMEOUT)))
 			hci_link_tx_to(hdev, ACL_LINK);
 	}
+}
 
-	while (hdev->acl_cnt > 0 &&
-		((conn = hci_low_sent_acl(hdev, &quote)) != NULL)) {
+static inline void hci_sched_acl_pkt(struct hci_dev *hdev)
+{
+	unsigned int cnt = hdev->acl_cnt;
+	struct hci_chan *chan;
+	struct sk_buff *skb;
+	int quote;
 
-		while (quote > 0 &&
-			  (skb = skb_dequeue(&conn->data_q))) {
-			int count = 1;
+	__check_timeout(hdev, cnt);
 
-			BT_DBG("skb %p len %d", skb, skb->len);
+	while (hdev->acl_cnt &&
+			(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote-- && (skb = skb_peek(&chan->data_q))) {
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+					skb->len, skb->priority);
 
-			if (hdev->flow_ctl_mode ==
-				HCI_BLOCK_BASED_FLOW_CTL_MODE)
-				/* Calculate count of blocks used by
-				 * this packet
-				 */
-				count = ((skb->len - HCI_ACL_HDR_SIZE - 1) /
-					hdev->data_block_len) + 1;
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
+
+			skb = skb_dequeue(&chan->data_q);
+
+			hci_conn_enter_active_mode(chan->conn,
+						   bt_cb(skb)->force_active);
+
+			hci_send_frame(skb);
+			hdev->acl_last_tx = jiffies;
+
+			hdev->acl_cnt--;
+			chan->sent++;
+			chan->conn->sent++;
+		}
+	}
+
+	if (cnt != hdev->acl_cnt)
+		hci_prio_recalculate(hdev, ACL_LINK);
+}
+
+static inline void hci_sched_acl_blk(struct hci_dev *hdev)
+{
+	unsigned int cnt = hdev->block_cnt;
+	struct hci_chan *chan;
+	struct sk_buff *skb;
+	int quote;
+
+	__check_timeout(hdev, cnt);
+
+	while (hdev->block_cnt > 0 &&
+			(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote > 0 && (skb = skb_peek(&chan->data_q))) {
+			int blocks;
+
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+						skb->len, skb->priority);
+
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
 
-			if (count > hdev->acl_cnt)
+			skb = skb_dequeue(&chan->data_q);
+
+			blocks = __get_blocks(hdev, skb);
+			if (blocks > hdev->block_cnt)
 				return;
 
-			hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
+			hci_conn_enter_active_mode(chan->conn,
+						bt_cb(skb)->force_active);
 
 			hci_send_frame(skb);
 			hdev->acl_last_tx = jiffies;
 
-			hdev->acl_cnt -= count;
-			quote -= count;
+			hdev->block_cnt -= blocks;
+			quote -= blocks;
 
-			conn->sent += count;
+			chan->sent += blocks;
+			chan->conn->sent += blocks;
 		}
 	}
+
+	if (cnt != hdev->block_cnt)
+		hci_prio_recalculate(hdev, ACL_LINK);
+}
+
+static inline void hci_sched_acl(struct hci_dev *hdev)
+{
+	BT_DBG("%s", hdev->name);
+
+	if (!hci_conn_num(hdev, ACL_LINK))
+		return;
+
+	switch (hdev->flow_ctl_mode) {
+	case HCI_FLOW_CTL_MODE_PACKET_BASED:
+		hci_sched_acl_pkt(hdev);
+		break;
+
+	case HCI_FLOW_CTL_MODE_BLOCK_BASED:
+		hci_sched_acl_blk(hdev);
+		break;
+	}
 }
 
 /* Schedule SCO */
@@ -2313,6 +2654,9 @@
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, SCO_LINK))
+		return;
+
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, SCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2333,6 +2677,9 @@
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, ESCO_LINK))
+		return;
+
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, ESCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2347,12 +2694,15 @@
 
 static inline void hci_sched_le(struct hci_dev *hdev)
 {
-	struct hci_conn *conn;
+	struct hci_chan *chan;
 	struct sk_buff *skb;
-	int quote, cnt;
+	int quote, cnt, tmp;
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, LE_LINK))
+		return;
+
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* LE tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
@@ -2362,30 +2712,42 @@
 	}
 
 	cnt = hdev->le_pkts ? hdev->le_cnt : hdev->acl_cnt;
-	while (cnt && (conn = hci_low_sent(hdev, LE_LINK, &quote))) {
-		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
-			BT_DBG("skb %p len %d", skb, skb->len);
+	tmp = cnt;
+	while (cnt && (chan = hci_chan_sent(hdev, LE_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote-- && (skb = skb_peek(&chan->data_q))) {
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+					skb->len, skb->priority);
+
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
+
+			skb = skb_dequeue(&chan->data_q);
 
 			hci_send_frame(skb);
 			hdev->le_last_tx = jiffies;
 
 			cnt--;
-			conn->sent++;
+			chan->sent++;
+			chan->conn->sent++;
 		}
 	}
+
 	if (hdev->le_pkts)
 		hdev->le_cnt = cnt;
 	else
 		hdev->acl_cnt = cnt;
+
+	if (cnt != tmp)
+		hci_prio_recalculate(hdev, LE_LINK);
 }
 
-static void hci_tx_task(unsigned long arg)
+static void hci_tx_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, tx_work);
 	struct sk_buff *skb;
 
-	read_lock(&hci_task_lock);
-
 	BT_DBG("%s acl %d sco %d le %d", hdev->name, hdev->acl_cnt,
 		hdev->sco_cnt, hdev->le_cnt);
 
@@ -2402,11 +2764,9 @@
 	/* Send next queued raw (unknown type) packet */
 	while ((skb = skb_dequeue(&hdev->raw_q)))
 		hci_send_frame(skb);
-
-	read_unlock(&hci_task_lock);
 }
 
-/* ----- HCI RX task (incoming data proccessing) ----- */
+/* ----- HCI RX task (incoming data processing) ----- */
 
 /* ACL data packet */
 static inline void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2430,16 +2790,19 @@
 	hci_dev_unlock(hdev);
 
 	if (conn) {
-		register struct hci_proto *hp;
+		hci_conn_enter_active_mode(conn, BT_POWER_FORCE_ACTIVE_OFF);
 
-		hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
+		hci_dev_lock(hdev);
+		if (test_bit(HCI_MGMT, &hdev->dev_flags) &&
+		    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+			mgmt_device_connected(hdev, &conn->dst, conn->type,
+					      conn->dst_type, 0, NULL, 0,
+					      conn->dev_class);
+		hci_dev_unlock(hdev);
 
 		/* Send to upper protocol */
-		hp = hci_proto[HCI_PROTO_L2CAP];
-		if (hp && hp->recv_acldata) {
-			hp->recv_acldata(conn, skb, flags);
-			return;
-		}
+		l2cap_recv_acldata(conn, skb, flags);
+		return;
 	} else {
 		BT_ERR("%s ACL packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2468,14 +2831,9 @@
 	hci_dev_unlock(hdev);
 
 	if (conn) {
-		register struct hci_proto *hp;
-
 		/* Send to upper protocol */
-		hp = hci_proto[HCI_PROTO_SCO];
-		if (hp && hp->recv_scodata) {
-			hp->recv_scodata(conn, skb);
-			return;
-		}
+		sco_recv_scodata(conn, skb);
+		return;
 	} else {
 		BT_ERR("%s SCO packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2484,19 +2842,20 @@
 	kfree_skb(skb);
 }
 
-static void hci_rx_task(unsigned long arg)
+static void hci_rx_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, rx_work);
 	struct sk_buff *skb;
 
 	BT_DBG("%s", hdev->name);
 
-	read_lock(&hci_task_lock);
-
 	while ((skb = skb_dequeue(&hdev->rx_q))) {
+		/* Send copy to monitor */
+		hci_send_to_monitor(hdev, skb);
+
 		if (atomic_read(&hdev->promisc)) {
 			/* Send copy to the sockets */
-			hci_send_to_sock(hdev, skb, NULL);
+			hci_send_to_sock(hdev, skb);
 		}
 
 		if (test_bit(HCI_RAW, &hdev->flags)) {
@@ -2517,6 +2876,7 @@
 		/* Process frame */
 		switch (bt_cb(skb)->pkt_type) {
 		case HCI_EVENT_PKT:
+			BT_DBG("%s Event packet", hdev->name);
 			hci_event_packet(hdev, skb);
 			break;
 
@@ -2535,13 +2895,11 @@
 			break;
 		}
 	}
-
-	read_unlock(&hci_task_lock);
 }
 
-static void hci_cmd_task(unsigned long arg)
+static void hci_cmd_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, cmd_work);
 	struct sk_buff *skb;
 
 	BT_DBG("%s cmd %d", hdev->name, atomic_read(&hdev->cmd_cnt));
@@ -2558,14 +2916,44 @@
 		if (hdev->sent_cmd) {
 			atomic_dec(&hdev->cmd_cnt);
 			hci_send_frame(skb);
-			mod_timer(&hdev->cmd_timer,
+			if (test_bit(HCI_RESET, &hdev->flags))
+				del_timer(&hdev->cmd_timer);
+			else
+				mod_timer(&hdev->cmd_timer,
 				  jiffies + msecs_to_jiffies(HCI_CMD_TIMEOUT));
 		} else {
 			skb_queue_head(&hdev->cmd_q, skb);
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 		}
 	}
 }
 
-module_param(enable_smp, bool, 0644);
-MODULE_PARM_DESC(enable_smp, "Enable SMP support (LE only)");
+int hci_do_inquiry(struct hci_dev *hdev, u8 length)
+{
+	/* General inquiry access code (GIAC) */
+	u8 lap[3] = { 0x33, 0x8b, 0x9e };
+	struct hci_cp_inquiry cp;
+
+	BT_DBG("%s", hdev->name);
+
+	if (test_bit(HCI_INQUIRY, &hdev->flags))
+		return -EINPROGRESS;
+
+	inquiry_cache_flush(hdev);
+
+	memset(&cp, 0, sizeof(cp));
+	memcpy(&cp.lap, lap, sizeof(cp.lap));
+	cp.length  = length;
+
+	return hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+}
+
+int hci_cancel_inquiry(struct hci_dev *hdev)
+{
+	BT_DBG("%s", hdev->name);
+
+	if (!test_bit(HCI_INQUIRY, &hdev->flags))
+		return -EPERM;
+
+	return hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
+}
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_event.c flo-ElementalX-5.00-patched/net/bluetooth/hci_event.c
--- flo-ElementalX-5.00/net/bluetooth/hci_event.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_event.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -35,10 +35,8 @@
 #include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -53,11 +51,19 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
+	if (status) {
+		hci_dev_lock(hdev);
+		mgmt_stop_discovery_failed(hdev, status);
+		hci_dev_unlock(hdev);
 		return;
+	}
 
 	clear_bit(HCI_INQUIRY, &hdev->flags);
 
+	hci_dev_lock(hdev);
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+	hci_dev_unlock(hdev);
+
 	hci_req_complete(hdev, HCI_OP_INQUIRY_CANCEL, status);
 
 	hci_conn_check_pending(hdev);
@@ -72,36 +78,9 @@
 	if (status)
 		return;
 
-	clear_bit(HCI_INQUIRY, &hdev->flags);
-
 	hci_conn_check_pending(hdev);
 }
 
-static void hci_cc_link_key_reply(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	struct hci_rp_link_key_reply *rp = (void *) skb->data;
-	struct hci_conn *conn;
-	struct hci_cp_link_key_reply *cp;
-
-	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-	if (rp->status)
-		return;
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_LINK_KEY_REPLY);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn) {
-		hci_conn_hold(conn);
-		memcpy(conn->link_key, cp->link_key, sizeof(conn->link_key));
-		conn->key_type = 5;
-		hci_conn_put(conn);
-	}
-	hci_dev_unlock(hdev);
-}
-
 static void hci_cc_remote_name_req_cancel(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	BT_DBG("%s", hdev->name);
@@ -211,6 +190,11 @@
 	clear_bit(HCI_RESET, &hdev->flags);
 
 	hci_req_complete(hdev, HCI_OP_RESET, status);
+
+	/* Reset all non-persistent flags */
+	hdev->dev_flags &= ~(BIT(HCI_LE_SCAN) | BIT(HCI_PENDING_CLASS));
+
+	hdev->discovery.state = DISCOVERY_STOPPED;
 }
 
 static void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -223,13 +207,17 @@
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LOCAL_NAME);
 	if (!sent)
 		return;
+
 	hci_dev_lock(hdev);
-	if (!status)
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_set_local_name_complete(hdev, sent, status);
+	else if (!status)
 		memcpy(hdev->dev_name, sent, HCI_MAX_NAME_LENGTH);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_set_local_name_complete(hdev->id, sent, status);
 	hci_dev_unlock(hdev);
+
+	hci_req_complete(hdev, HCI_OP_WRITE_LOCAL_NAME, status);
 }
 
 static void hci_cc_read_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -241,7 +229,8 @@
 	if (rp->status)
 		return;
 
-	memcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);
+	if (test_bit(HCI_SETUP, &hdev->dev_flags))
+		memcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);
 }
 
 static void hci_cc_write_auth_enable(struct hci_dev *hdev, struct sk_buff *skb)
@@ -264,6 +253,9 @@
 			clear_bit(HCI_AUTH, &hdev->flags);
 	}
 
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_auth_enable_complete(hdev, status);
+
 	hci_req_complete(hdev, HCI_OP_WRITE_AUTH_ENABLE, status);
 }
 
@@ -292,7 +284,8 @@
 
 static void hci_cc_write_scan_enable(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	__u8 status = *((__u8 *) skb->data);
+	__u8 param, status = *((__u8 *) skb->data);
+	int old_pscan, old_iscan;
 	void *sent;
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
@@ -301,30 +294,40 @@
 	if (!sent)
 		return;
 
-	if (!status) {
-		__u8 param = *((__u8 *) sent);
-		int old_pscan, old_iscan;
-		hci_dev_lock(hdev);
+	param = *((__u8 *) sent);
 
-		old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
-		old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
+	hci_dev_lock(hdev);
 
-		if (param & SCAN_INQUIRY) {
-			set_bit(HCI_ISCAN, &hdev->flags);
-			if (!old_iscan)
-				mgmt_discoverable(hdev->id, 1);
-		} else if (old_iscan)
-			mgmt_discoverable(hdev->id, 0);
-
-		if (param & SCAN_PAGE) {
-			set_bit(HCI_PSCAN, &hdev->flags);
-			if (!old_pscan)
-				mgmt_connectable(hdev->id, 1);
-		} else if (old_pscan)
-			mgmt_connectable(hdev->id, 0);
-		hci_dev_unlock(hdev);
+	if (status != 0) {
+		mgmt_write_scan_failed(hdev, param, status);
+		hdev->discov_timeout = 0;
+		goto done;
 	}
 
+	old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
+	old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
+
+	if (param & SCAN_INQUIRY) {
+		set_bit(HCI_ISCAN, &hdev->flags);
+		if (!old_iscan)
+			mgmt_discoverable(hdev, 1);
+		if (hdev->discov_timeout > 0) {
+			int to = msecs_to_jiffies(hdev->discov_timeout * 1000);
+			queue_delayed_work(hdev->workqueue, &hdev->discov_off,
+									to);
+		}
+	} else if (old_iscan)
+		mgmt_discoverable(hdev, 0);
+
+	if (param & SCAN_PAGE) {
+		set_bit(HCI_PSCAN, &hdev->flags);
+		if (!old_pscan)
+			mgmt_connectable(hdev, 1);
+	} else if (old_pscan)
+		mgmt_connectable(hdev, 0);
+
+done:
+	hci_dev_unlock(hdev);
 	hci_req_complete(hdev, HCI_OP_WRITE_SCAN_ENABLE, status);
 }
 
@@ -350,14 +353,19 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
-		return;
-
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_CLASS_OF_DEV);
 	if (!sent)
 		return;
 
-	memcpy(hdev->dev_class, sent, 3);
+	hci_dev_lock(hdev);
+
+	if (status == 0)
+		memcpy(hdev->dev_class, sent, 3);
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_set_class_of_dev_complete(hdev, sent, status);
+
+	hci_dev_unlock(hdev);
 }
 
 static void hci_cc_read_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
@@ -379,11 +387,8 @@
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
-		tasklet_enable(&hdev->tx_task);
-	}
 }
 
 static void hci_cc_write_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
@@ -410,11 +415,8 @@
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
-		tasklet_enable(&hdev->tx_task);
-	}
 }
 
 static void hci_cc_host_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -426,28 +428,6 @@
 	hci_req_complete(hdev, HCI_OP_HOST_BUFFER_SIZE, status);
 }
 
-static void hci_cc_le_clear_white_list(struct hci_dev *hdev,
-							struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	hci_req_complete(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, status);
-}
-
-static void hci_cc_read_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	struct hci_rp_read_ssp_mode *rp = (void *) skb->data;
-
-	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
-	if (rp->status)
-		return;
-
-	hdev->ssp_mode = rp->mode;
-}
-
 static void hci_cc_write_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	__u8 status = *((__u8 *) skb->data);
@@ -455,14 +435,18 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
-		return;
-
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_MODE);
 	if (!sent)
 		return;
 
-	hdev->ssp_mode = *((__u8 *) sent);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_ssp_enable_complete(hdev, *((u8 *) sent), status);
+	else if (!status) {
+		if (*((u8 *) sent))
+			set_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+		else
+			clear_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+	}
 }
 
 static u8 hci_get_inquiry_mode(struct hci_dev *hdev)
@@ -509,16 +493,16 @@
 	 * command otherwise */
 	u8 events[8] = { 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00 };
 
-	BT_DBG("");
+	/* CSR 1.1 dongles does not accept any bitfield so don't try to set
+	 * any event mask for pre 1.2 devices */
+	if (hdev->hci_ver < BLUETOOTH_VER_1_2)
+		return;
 
-	/* Events for 1.2 and newer controllers */
-	if (hdev->lmp_ver > 1) {
-		events[4] |= 0x01; /* Flow Specification Complete */
-		events[4] |= 0x02; /* Inquiry Result with RSSI */
-		events[4] |= 0x04; /* Read Remote Extended Features Complete */
-		events[5] |= 0x08; /* Synchronous Connection Complete */
-		events[5] |= 0x10; /* Synchronous Connection Changed */
-	}
+	events[4] |= 0x01; /* Flow Specification Complete */
+	events[4] |= 0x02; /* Inquiry Result with RSSI */
+	events[4] |= 0x04; /* Read Remote Extended Features Complete */
+	events[5] |= 0x08; /* Synchronous Connection Complete */
+	events[5] |= 0x10; /* Synchronous Connection Changed */
 
 	if (hdev->features[3] & LMP_RSSI_INQ)
 		events[4] |= 0x04; /* Inquiry Result with RSSI */
@@ -559,12 +543,27 @@
 
 static void hci_setup(struct hci_dev *hdev)
 {
-	if (hdev->lmp_ver > 1)
+	if (hdev->dev_type != HCI_BREDR)
+		return;
+
+	hci_setup_event_mask(hdev);
+
+	if (hdev->hci_ver > BLUETOOTH_VER_1_1)
 		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_COMMANDS, 0, NULL);
 
 	if (hdev->features[6] & LMP_SIMPLE_PAIR) {
-		u8 mode = 0x01;
-		hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, sizeof(mode), &mode);
+		if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			u8 mode = 0x01;
+			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE,
+				     sizeof(mode), &mode);
+		} else {
+			struct hci_cp_write_eir cp;
+
+			memset(hdev->eir, 0, sizeof(hdev->eir));
+			memset(&cp, 0, sizeof(cp));
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+		}
 	}
 
 	if (hdev->features[3] & LMP_RSSI_INQ)
@@ -572,6 +571,20 @@
 
 	if (hdev->features[7] & LMP_INQ_TX_PWR)
 		hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER, 0, NULL);
+
+	if (hdev->features[7] & LMP_EXTFEATURES) {
+		struct hci_cp_read_local_ext_features cp;
+
+		cp.page = 0x01;
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, sizeof(cp),
+			     &cp);
+	}
+
+	if (test_bit(HCI_LINK_SECURITY, &hdev->dev_flags)) {
+		u8 enable = 1;
+		hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(enable),
+			     &enable);
+	}
 }
 
 static void hci_cc_read_local_version(struct hci_dev *hdev, struct sk_buff *skb)
@@ -581,7 +594,7 @@
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
 	if (rp->status)
-		return;
+		goto done;
 
 	hdev->hci_ver = rp->hci_ver;
 	hdev->hci_rev = __le16_to_cpu(rp->hci_rev);
@@ -593,8 +606,11 @@
 					hdev->manufacturer,
 					hdev->hci_ver, hdev->hci_rev);
 
-	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags))
+	if (test_bit(HCI_INIT, &hdev->flags))
 		hci_setup(hdev);
+
+done:
+	hci_req_complete(hdev, HCI_OP_READ_LOCAL_VERSION, rp->status);
 }
 
 static void hci_setup_link_policy(struct hci_dev *hdev)
@@ -611,8 +627,8 @@
 		link_policy |= HCI_LP_PARK;
 
 	link_policy = cpu_to_le16(link_policy);
-	hci_send_cmd(hdev, HCI_OP_WRITE_DEF_LINK_POLICY,
-					sizeof(link_policy), &link_policy);
+	hci_send_cmd(hdev, HCI_OP_WRITE_DEF_LINK_POLICY, sizeof(link_policy),
+		     &link_policy);
 }
 
 static void hci_cc_read_local_commands(struct hci_dev *hdev, struct sk_buff *skb)
@@ -644,23 +660,6 @@
 
 	memcpy(hdev->features, rp->features, 8);
 
-	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags)) {
-		if (hdev->features[6] & LMP_SIMPLE_PAIR) {
-			u8 mode = 0x01;
-			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE,
-					sizeof(mode), &mode);
-		}
-
-		if (hdev->features[3] & LMP_RSSI_INQ)
-			hci_setup_inquiry_mode(hdev);
-
-		if (hdev->features[7] & LMP_INQ_TX_PWR)
-			hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER,
-								0, NULL);
-
-		hci_setup_event_mask(hdev);
-	}
-
 	/* Adjust default settings according to features
 	 * supported by device. */
 
@@ -705,8 +704,50 @@
 					hdev->features[6], hdev->features[7]);
 }
 
+static void hci_set_le_support(struct hci_dev *hdev)
+{
+	struct hci_cp_write_le_host_supported cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	if (enable_le && test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+		cp.le = 1;
+		cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+	}
+
+	if (cp.le != !!(hdev->host_features[0] & LMP_HOST_LE))
+		hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(cp),
+			     &cp);
+}
+
+static void hci_cc_read_local_ext_features(struct hci_dev *hdev,
+							struct sk_buff *skb)
+{
+	struct hci_rp_read_local_ext_features *rp = (void *) skb->data;
+
+	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
+	if (rp->status)
+		goto done;
+
+	switch (rp->page) {
+	case 0:
+		memcpy(hdev->features, rp->features, 8);
+		break;
+	case 1:
+		memcpy(hdev->host_features, rp->features, 8);
+		break;
+	}
+
+	if (test_bit(HCI_INIT, &hdev->flags) && hdev->features[4] & LMP_LE)
+		hci_set_le_support(hdev);
+
+done:
+	hci_req_complete(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, rp->status);
+}
+
 static void hci_cc_read_flow_control_mode(struct hci_dev *hdev,
-					struct sk_buff *skb)
+						struct sk_buff *skb)
 {
 	struct hci_rp_read_flow_control_mode *rp = (void *) skb->data;
 
@@ -716,6 +757,8 @@
 		return;
 
 	hdev->flow_ctl_mode = rp->mode;
+
+	hci_req_complete(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, rp->status);
 }
 
 static void hci_cc_read_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -727,20 +770,18 @@
 	if (rp->status)
 		return;
 
-	if (hdev->flow_ctl_mode == HCI_PACKET_BASED_FLOW_CTL_MODE) {
-		hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
-		hdev->sco_mtu  = rp->sco_mtu;
-		hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
-		hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
-		hdev->acl_cnt = hdev->acl_pkts;
-		hdev->sco_cnt = hdev->sco_pkts;
-	}
+	hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
+	hdev->sco_mtu  = rp->sco_mtu;
+	hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
+	hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
 
 	if (test_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks)) {
 		hdev->sco_mtu  = 64;
 		hdev->sco_pkts = 8;
 	}
 
+	hdev->acl_cnt = hdev->acl_pkts;
+	hdev->sco_cnt = hdev->sco_pkts;
 
 	BT_DBG("%s acl mtu %d:%d sco mtu %d:%d", hdev->name,
 					hdev->acl_mtu, hdev->acl_pkts,
@@ -759,17 +800,8 @@
 	hci_req_complete(hdev, HCI_OP_READ_BD_ADDR, rp->status);
 }
 
-static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
-}
-
 static void hci_cc_read_data_block_size(struct hci_dev *hdev,
-					struct sk_buff *skb)
+							struct sk_buff *skb)
 {
 	struct hci_rp_read_data_block_size *rp = (void *) skb->data;
 
@@ -778,23 +810,29 @@
 	if (rp->status)
 		return;
 
-	if (hdev->flow_ctl_mode == HCI_BLOCK_BASED_FLOW_CTL_MODE) {
-		hdev->acl_mtu  = __le16_to_cpu(rp->max_acl_len);
-		hdev->sco_mtu = 0;
-		hdev->data_block_len = __le16_to_cpu(rp->data_block_len);
-		/* acl_pkts indicates the number of blocks */
-		hdev->acl_pkts = __le16_to_cpu(rp->num_blocks);
-		hdev->sco_pkts = 0;
-		hdev->acl_cnt = hdev->acl_pkts;
-		hdev->sco_cnt = 0;
-	}
+	hdev->block_mtu = __le16_to_cpu(rp->max_acl_len);
+	hdev->block_len = __le16_to_cpu(rp->block_len);
+	hdev->num_blocks = __le16_to_cpu(rp->num_blocks);
+
+	hdev->block_cnt = hdev->num_blocks;
+
+	BT_DBG("%s blk mtu %d cnt %d len %d", hdev->name, hdev->block_mtu,
+					hdev->block_cnt, hdev->block_len);
+
+	hci_req_complete(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, rp->status);
+}
+
+static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	BT_DBG("%s acl mtu %d:%d, data block len %d", hdev->name,
-			hdev->acl_mtu, hdev->acl_cnt, hdev->data_block_len);
+	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
 }
 
 static void hci_cc_read_local_amp_info(struct hci_dev *hdev,
-				struct sk_buff *skb)
+		struct sk_buff *skb)
 {
 	struct hci_rp_read_local_amp_info *rp = (void *) skb->data;
 
@@ -872,10 +910,11 @@
 	struct hci_conn *conn;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_reply_complete(hdev->id, &rp->bdaddr, rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_pin_code_reply_complete(hdev, &rp->bdaddr, rp->status);
 
 	if (rp->status != 0)
 		goto unlock;
@@ -887,6 +926,7 @@
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
 	if (conn)
 		conn->pin_length = cp->pin_len;
+
 unlock:
 	hci_dev_unlock(hdev);
 }
@@ -896,13 +936,16 @@
 	struct hci_rp_pin_code_neg_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_neg_reply_complete(hdev->id, &rp->bdaddr,
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_pin_code_neg_reply_complete(hdev, &rp->bdaddr,
 								rp->status);
+
 	hci_dev_unlock(hdev);
 }
+
 static void hci_cc_le_read_buffer_size(struct hci_dev *hdev,
 				       struct sk_buff *skb)
 {
@@ -923,63 +966,66 @@
 	hci_req_complete(hdev, HCI_OP_LE_READ_BUFFER_SIZE, rp->status);
 }
 
-static void hci_cc_le_read_white_list_size(struct hci_dev *hdev,
-				       struct sk_buff *skb)
+static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_rp_le_read_white_list_size *rp = (void *) skb->data;
+	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	if (rp->status)
-		return;
-
-	hdev->le_white_list_size = rp->size;
+	hci_dev_lock(hdev);
 
-	BT_DBG("%s le white list %d", hdev->name, hdev->le_white_list_size);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_confirm_reply_complete(hdev, &rp->bdaddr, ACL_LINK, 0,
+						 rp->status);
 
-	hci_req_complete(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, rp->status);
+	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_reply_complete(hdev->id, &rp->bdaddr,
-								rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_confirm_neg_reply_complete(hdev, &rp->bdaddr,
+						     ACL_LINK, 0, rp->status);
+
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static void hci_cc_user_passkey_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_neg_reply_complete(hdev->id, &rp->bdaddr,
-								rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_reply_complete(hdev, &rp->bdaddr, ACL_LINK,
+						 0, rp->status);
+
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_read_rssi(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_user_passkey_neg_reply(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
-	struct hci_conn *conn;
-	struct hci_rp_read_rssi *rp = (void *) skb->data;
+	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	BT_DBG("%s rssi : %d handle : %d", hdev->name, rp->rssi, rp->handle);
+	hci_dev_lock(hdev);
 
-	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));
-	if (conn)
-		mgmt_read_rssi_complete(hdev->id, rp->rssi, &conn->dst,
-			__le16_to_cpu(rp->handle), rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_neg_reply_complete(hdev, &rp->bdaddr,
+						     ACL_LINK, 0, rp->status);
+
+	hci_dev_unlock(hdev);
 }
 
 static void hci_cc_read_local_oob_data_reply(struct hci_dev *hdev,
@@ -988,13 +1034,86 @@
 	struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-	hci_dev_lock(hdev);
 
-	mgmt_read_local_oob_data_reply_complete(hdev->id, rp->hash,
+	hci_dev_lock(hdev);
+	mgmt_read_local_oob_data_reply_complete(hdev, rp->hash,
 						rp->randomizer, rp->status);
 	hci_dev_unlock(hdev);
 }
 
+static void hci_cc_le_set_scan_param(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	hci_req_complete(hdev, HCI_OP_LE_SET_SCAN_PARAM, status);
+
+	if (status) {
+		hci_dev_lock(hdev);
+		mgmt_start_discovery_failed(hdev, status);
+		hci_dev_unlock(hdev);
+		return;
+	}
+}
+
+static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_cp_le_set_scan_enable *cp;
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
+	if (!cp)
+		return;
+
+	switch (cp->enable) {
+	case LE_SCANNING_ENABLED:
+		hci_req_complete(hdev, HCI_OP_LE_SET_SCAN_ENABLE, status);
+
+		if (status) {
+			hci_dev_lock(hdev);
+			mgmt_start_discovery_failed(hdev, status);
+			hci_dev_unlock(hdev);
+			return;
+		}
+
+		set_bit(HCI_LE_SCAN, &hdev->dev_flags);
+
+		cancel_delayed_work_sync(&hdev->adv_work);
+
+		hci_dev_lock(hdev);
+		hci_adv_entries_clear(hdev);
+		hci_discovery_set_state(hdev, DISCOVERY_FINDING);
+		hci_dev_unlock(hdev);
+		break;
+
+	case LE_SCANNING_DISABLED:
+		if (status)
+			return;
+
+		clear_bit(HCI_LE_SCAN, &hdev->dev_flags);
+
+		schedule_delayed_work(&hdev->adv_work, ADV_CLEAR_TIMEOUT);
+
+		if (hdev->discovery.type == DISCOV_TYPE_INTERLEAVED) {
+			mgmt_interleaved_discovery(hdev);
+		} else {
+			hci_dev_lock(hdev);
+			hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+			hci_dev_unlock(hdev);
+		}
+
+		break;
+
+	default:
+		BT_ERR("Used reserved LE_Scan_Enable param %d", cp->enable);
+		break;
+	}
+}
+
 static void hci_cc_le_ltk_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_le_ltk_reply *rp = (void *) skb->data;
@@ -1019,26 +1138,30 @@
 	hci_req_complete(hdev, HCI_OP_LE_LTK_NEG_REPLY, rp->status);
 }
 
-static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
-					struct sk_buff *skb)
+static inline void hci_cc_write_le_host_supported(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
-	void *sent;
-	__u8 param_scan_enable;
+	struct hci_cp_write_le_host_supported *sent;
 	__u8 status = *((__u8 *) skb->data);
 
-	if (status)
-		return;
+	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
+	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED);
 	if (!sent)
 		return;
 
-	param_scan_enable = *((__u8 *) sent);
-	if (param_scan_enable == 0x01) {
-		del_timer(&hdev->adv_timer);
-	} else if (param_scan_enable == 0x00) {
-		mod_timer(&hdev->adv_timer, jiffies + ADV_CLEAR_TIMEOUT);
+	if (!status) {
+		if (sent->le)
+			hdev->host_features[0] |= LMP_HOST_LE;
+		else
+			hdev->host_features[0] &= ~LMP_HOST_LE;
 	}
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags) &&
+					!test_bit(HCI_INIT, &hdev->flags))
+		mgmt_le_enable_complete(hdev, sent->le, status);
+
+	hci_req_complete(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, status);
 }
 
 static inline void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)
@@ -1047,15 +1170,19 @@
 
 	if (status) {
 		hci_req_complete(hdev, HCI_OP_INQUIRY, status);
-
 		hci_conn_check_pending(hdev);
-	} else {
-		set_bit(HCI_INQUIRY, &hdev->flags);
 		hci_dev_lock(hdev);
-		if (test_bit(HCI_MGMT, &hdev->flags))
-			mgmt_inquiry_started(hdev->id);
+		if (test_bit(HCI_MGMT, &hdev->dev_flags))
+			mgmt_start_discovery_failed(hdev, status);
 		hci_dev_unlock(hdev);
+		return;
 	}
+
+	set_bit(HCI_INQUIRY, &hdev->flags);
+
+	hci_dev_lock(hdev);
+	hci_discovery_set_state(hdev, DISCOVERY_FINDING);
+	hci_dev_unlock(hdev);
 }
 
 static inline void hci_cs_create_conn(struct hci_dev *hdev, __u8 status)
@@ -1086,9 +1213,9 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_conn_add(hdev, ACL_LINK, 0, &cp->bdaddr);
+			conn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr);
 			if (conn) {
-				conn->out = 1;
+				conn->out = true;
 				conn->link_mode |= HCI_LM_MASTER;
 			} else
 				BT_ERR("No memory for new connection");
@@ -1140,6 +1267,9 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
+	if (!status)
+		return;
+
 	cp = hci_sent_cmd_data(hdev, HCI_OP_AUTH_REQUESTED);
 	if (!cp)
 		return;
@@ -1148,27 +1278,10 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		if (status) {
-			mgmt_auth_failed(hdev->id, &conn->dst, status);
-			clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
-
-			if (conn->state == BT_CONFIG) {
-				conn->state = BT_CONNECTED;
-				hci_proto_connect_cfm(conn, status);
-				hci_conn_put(conn);
-			} else {
-				hci_auth_cfm(conn, status);
-				hci_conn_hold(conn);
-				conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-				hci_conn_put(conn);
-			}
-
-			if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
-				hci_encrypt_cfm(conn, status, 0x00);
-			}
+		if (conn->state == BT_CONFIG) {
+			hci_proto_connect_cfm(conn, status);
+			hci_conn_put(conn);
 		}
-		conn->auth_initiator = 1;
 	}
 
 	hci_dev_unlock(hdev);
@@ -1211,15 +1324,93 @@
 		return 0;
 
 	/* Only request authentication for SSP connections or non-SSP
-	 * devices with sec_level >= BT_SECURITY_MEDIUM*/
-	 BT_DBG("Pending sec level is %d", conn->pending_sec_level);
-	if (!(hdev->ssp_mode > 0 && conn->ssp_mode > 0) &&
-				conn->pending_sec_level < BT_SECURITY_MEDIUM)
+	 * devices with sec_level HIGH or if MITM protection is requested */
+	if (!hci_conn_ssp_enabled(conn) &&
+				conn->pending_sec_level != BT_SECURITY_HIGH &&
+				!(conn->auth_type & 0x01))
 		return 0;
 
 	return 1;
 }
 
+static inline int hci_resolve_name(struct hci_dev *hdev,
+				   struct inquiry_entry *e)
+{
+	struct hci_cp_remote_name_req cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	bacpy(&cp.bdaddr, &e->data.bdaddr);
+	cp.pscan_rep_mode = e->data.pscan_rep_mode;
+	cp.pscan_mode = e->data.pscan_mode;
+	cp.clock_offset = e->data.clock_offset;
+
+	return hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
+}
+
+static bool hci_resolve_next_name(struct hci_dev *hdev)
+{
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	if (list_empty(&discov->resolve))
+		return false;
+
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);
+	if (!e)
+		return false;
+
+	if (hci_resolve_name(hdev, e) == 0) {
+		e->name_state = NAME_PENDING;
+		return true;
+	}
+
+	return false;
+}
+
+static void hci_check_pending_name(struct hci_dev *hdev, struct hci_conn *conn,
+				   bdaddr_t *bdaddr, u8 *name, u8 name_len)
+{
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	if (conn && !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, bdaddr, ACL_LINK, 0x00, 0, name,
+				      name_len, conn->dev_class);
+
+	if (discov->state == DISCOVERY_STOPPED)
+		return;
+
+	if (discov->state == DISCOVERY_STOPPING)
+		goto discov_complete;
+
+	if (discov->state != DISCOVERY_RESOLVING)
+		return;
+
+	e = hci_inquiry_cache_lookup_resolve(hdev, bdaddr, NAME_PENDING);
+	/* If the device was not found in a list of found devices names of which
+	 * are pending. there is no need to continue resolving a next name as it
+	 * will be done upon receiving another Remote Name Request Complete
+	 * Event */
+	if (!e)
+		return;
+
+	list_del(&e->list);
+	if (name) {
+		e->name_state = NAME_KNOWN;
+		mgmt_remote_name(hdev, bdaddr, ACL_LINK, 0x00,
+				 e->data.rssi, name, name_len);
+	} else {
+		e->name_state = NAME_NOT_KNOWN;
+	}
+
+	if (hci_resolve_next_name(hdev))
+		return;
+
+discov_complete:
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+}
+
 static void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)
 {
 	struct hci_cp_remote_name_req *cp;
@@ -1239,12 +1430,23 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		hci_check_pending_name(hdev, conn, &cp->bdaddr, NULL, 0);
+
+	if (!conn)
+		goto unlock;
+
+	if (!hci_outgoing_auth_needed(hdev, conn))
+		goto unlock;
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1355,9 +1557,9 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend);
+		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, status);
 	}
 
@@ -1382,20 +1584,41 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend);
+		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, status);
 	}
 
 	hci_dev_unlock(hdev);
 }
 
+static void hci_cs_disconnect(struct hci_dev *hdev, u8 status)
+{
+	struct hci_cp_disconnect *cp;
+	struct hci_conn *conn;
+
+	if (!status)
+		return;
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONNECT);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
+	if (conn)
+		mgmt_disconnect_failed(hdev, &conn->dst, conn->type,
+				       conn->dst_type, status);
+
+	hci_dev_unlock(hdev);
+}
+
 static void hci_cs_le_create_conn(struct hci_dev *hdev, __u8 status)
 {
 	struct hci_cp_le_create_conn *cp;
 	struct hci_conn *conn;
-	unsigned long exp = msecs_to_jiffies(5000);
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
@@ -1418,176 +1641,62 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_le_conn_add(hdev, &cp->peer_addr,
-						cp->peer_addr_type);
-			if (conn)
-				conn->out = 1;
-			else
+			conn = hci_conn_add(hdev, LE_LINK, &cp->peer_addr);
+			if (conn) {
+				conn->dst_type = cp->peer_addr_type;
+				conn->out = true;
+			} else {
 				BT_ERR("No memory for new connection");
-		} else
-			exp = msecs_to_jiffies(conn->conn_timeout * 1000);
-
-		if (conn && exp)
-			mod_timer(&conn->disc_timer, jiffies + exp);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_accept_logical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_create_logical_link *ap;
-	struct hci_chan *chan;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	ap = hci_sent_cmd_data(hdev, HCI_OP_ACCEPT_LOGICAL_LINK);
-	if (!ap)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, ap->phy_handle);
-
-	BT_DBG("%s chan %p", hdev->name, chan);
-
-	if (status) {
-		if (chan && chan->state == BT_CONNECT) {
-			chan->state = BT_CLOSED;
-			hci_proto_create_cfm(chan, status);
+			}
 		}
-	} else if (chan) {
-		chan->state = BT_CONNECT2;
 	}
 
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cs_create_logical_link(struct hci_dev *hdev, __u8 status)
+static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
 {
-	struct hci_cp_create_logical_link *cp;
-	struct hci_chan *chan;
-
 	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_LOGICAL_LINK);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, cp->phy_handle);
-
-	BT_DBG("%s chan %p", hdev->name, chan);
-
-	if (status) {
-		if (chan && chan->state == BT_CONNECT) {
-			chan->state = BT_CLOSED;
-			hci_proto_create_cfm(chan, status);
-		}
-	} else if (chan)
-			chan->state = BT_CONNECT2;
-
-	hci_dev_unlock(hdev);
 }
 
-static void hci_cs_flow_spec_modify(struct hci_dev *hdev, __u8 status)
+static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_cp_flow_spec_modify *cp;
-	struct hci_chan *chan;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_FLOW_SPEC_MODIFY);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
+	__u8 status = *((__u8 *) skb->data);
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
 
-	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
-	if (chan) {
-		if (status)
-			hci_proto_modify_cfm(chan, status);
-		else {
-			chan->tx_fs = cp->tx_fs;
-			chan->rx_fs = cp->rx_fs;
-		}
-	}
+	BT_DBG("%s status %d", hdev->name, status);
 
-	hci_dev_unlock(hdev);
-}
+	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
 
-static void hci_cs_disconn_logical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_disconn_logical_link *cp;
-	struct hci_chan *chan;
+	hci_conn_check_pending(hdev);
 
-	if (!status)
+	if (!test_and_clear_bit(HCI_INQUIRY, &hdev->flags))
 		return;
 
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_LOGICAL_LINK);
-	if (!cp)
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		return;
 
 	hci_dev_lock(hdev);
 
-	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
-	if (chan)
-		hci_chan_del(chan);
-
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_disconn_physical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_disconn_phys_link *cp;
-	struct hci_conn *conn;
-
-	if (!status)
-		return;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_PHYS_LINK);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
+	if (discov->state != DISCOVERY_FINDING)
+		goto unlock;
 
-	conn = hci_conn_hash_lookup_handle(hdev, cp->phy_handle);
-	if (conn) {
-		conn->state = BT_CLOSED;
-		hci_conn_del(conn);
+	if (list_empty(&discov->resolve)) {
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+		goto unlock;
 	}
 
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
-{
-	BT_DBG("%s status 0x%x", hdev->name, status);
-}
-
-static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status %d", hdev->name, status);
-
-	if (!hdev->disco_state)
-		clear_bit(HCI_INQUIRY, &hdev->flags);
-
-	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
-	hci_dev_lock(hdev);
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);
+	if (e && hci_resolve_name(hdev, e) == 0) {
+		e->name_state = NAME_PENDING;
+		hci_discovery_set_state(hdev, DISCOVERY_RESOLVING);
+	} else {
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+	}
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_inquiry_complete_evt(hdev->id, status);
+unlock:
 	hci_dev_unlock(hdev);
-
-	if (!lmp_le_capable(hdev))
-		hci_conn_check_pending(hdev);
 }
 
 static inline void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -1604,6 +1713,8 @@
 	hci_dev_lock(hdev);
 
 	for (; num_rsp; num_rsp--, info++) {
+		bool name_known, ssp;
+
 		bacpy(&data.bdaddr, &info->bdaddr);
 		data.pscan_rep_mode	= info->pscan_rep_mode;
 		data.pscan_period_mode	= info->pscan_period_mode;
@@ -1612,9 +1723,11 @@
 		data.clock_offset	= info->clock_offset;
 		data.rssi		= 0x00;
 		data.ssp_mode		= 0x00;
-		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-					info->dev_class, 0, 0, NULL);
+
+		name_known = hci_inquiry_cache_update(hdev, &data, false, &ssp);
+		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+				  info->dev_class, 0, !name_known, ssp, NULL,
+				  0);
 	}
 
 	hci_dev_unlock(hdev);
@@ -1647,12 +1760,12 @@
 		if (conn->type == ACL_LINK) {
 			conn->state = BT_CONFIG;
 			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-			mgmt_connected(hdev->id, &ev->bdaddr, 0);
-		} else if (conn->type == LE_LINK) {
-			conn->state = BT_CONNECTED;
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-			mgmt_connected(hdev->id, &ev->bdaddr, 1);
+
+			if (!conn->out && !hci_conn_ssp_enabled(conn) &&
+			    !hci_find_link_key(hdev, &ev->bdaddr))
+				conn->disc_timeout = HCI_PAIRING_TIMEOUT;
+			else
+				conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 		} else
 			conn->state = BT_CONNECTED;
 
@@ -1665,28 +1778,27 @@
 		if (test_bit(HCI_ENCRYPT, &hdev->flags))
 			conn->link_mode |= HCI_LM_ENCRYPT;
 
-		/* Get remote version */
+		/* Get remote features */
 		if (conn->type == ACL_LINK) {
-			struct hci_cp_read_remote_version cp;
+			struct hci_cp_read_remote_features cp;
 			cp.handle = ev->handle;
-			hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET,
-				sizeof(cp), &cp);
-			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_VERSION,
-				sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
+				     sizeof(cp), &cp);
 		}
 
 		/* Set packet type for incoming connection */
-		if (!conn->out && hdev->hci_ver < 3) {
+		if (!conn->out && hdev->hci_ver < BLUETOOTH_VER_2_0) {
 			struct hci_cp_change_conn_ptype cp;
 			cp.handle = ev->handle;
 			cp.pkt_type = cpu_to_le16(conn->pkt_type);
-			hci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE,
-							sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE, sizeof(cp),
+				     &cp);
 		}
 	} else {
 		conn->state = BT_CLOSED;
-		if (conn->type == ACL_LINK || conn->type == LE_LINK)
-			mgmt_connect_failed(hdev->id, &ev->bdaddr, ev->status);
+		if (conn->type == ACL_LINK)
+			mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
+					    conn->dst_type, ev->status);
 	}
 
 	if (conn->type == ACL_LINK)
@@ -1704,15 +1816,6 @@
 	hci_conn_check_pending(hdev);
 }
 
-static inline bool is_sco_active(struct hci_dev *hdev)
-{
-	if (hci_conn_hash_lookup_state(hdev, SCO_LINK, BT_CONNECTED) ||
-			(hci_conn_hash_lookup_state(hdev, ESCO_LINK,
-						    BT_CONNECTED)))
-		return true;
-	return false;
-}
-
 static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_conn_request *ev = (void *) skb->data;
@@ -1737,8 +1840,7 @@
 
 		conn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);
 		if (!conn) {
-			/* pkt_type not yet used for incoming connections */
-			conn = hci_conn_add(hdev, ev->link_type, 0, &ev->bdaddr);
+			conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr);
 			if (!conn) {
 				BT_ERR("No memory for new connection");
 				hci_dev_unlock(hdev);
@@ -1747,8 +1849,6 @@
 		}
 
 		memcpy(conn->dev_class, ev->dev_class, 3);
-		/* For incoming connection update remote class to userspace */
-		mgmt_remote_class(hdev->id, &ev->bdaddr, ev->dev_class);
 		conn->state = BT_CONNECT;
 
 		hci_dev_unlock(hdev);
@@ -1758,14 +1858,13 @@
 
 			bacpy(&cp.bdaddr, &ev->bdaddr);
 
-			if (lmp_rswitch_capable(hdev) && ((mask & HCI_LM_MASTER)
-						|| is_sco_active(hdev)))
+			if (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))
 				cp.role = 0x00; /* Become master */
 			else
 				cp.role = 0x01; /* Remain slave */
 
-			hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ,
-							sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp),
+				     &cp);
 		} else {
 			struct hci_cp_accept_sync_conn_req cp;
 
@@ -1774,19 +1873,19 @@
 
 			cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 			cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-			cp.max_latency    = cpu_to_le16(0x000A);
+			cp.max_latency    = cpu_to_le16(0xffff);
 			cp.content_format = cpu_to_le16(hdev->voice_setting);
-			cp.retrans_effort = 0x01;
+			cp.retrans_effort = 0xff;
 
 			hci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,
-							sizeof(cp), &cp);
+				     sizeof(cp), &cp);
 		}
 	} else {
 		/* Connection rejected */
 		struct hci_cp_reject_conn_req cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = 0x0f;
+		cp.reason = HCI_ERROR_REJ_BAD_ADDR;
 		hci_send_cmd(hdev, HCI_OP_REJECT_CONN_REQ, sizeof(cp), &cp);
 	}
 }
@@ -1796,14 +1895,7 @@
 	struct hci_ev_disconn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
 
-	BT_DBG("%s status %d reason %d", hdev->name, ev->status, ev->reason);
-
-	if (ev->status) {
-		hci_dev_lock(hdev);
-		mgmt_disconnect_failed(hdev->id);
-		hci_dev_unlock(hdev);
-		return;
-	}
+	BT_DBG("%s status %d", hdev->name, ev->status);
 
 	hci_dev_lock(hdev);
 
@@ -1811,16 +1903,25 @@
 	if (!conn)
 		goto unlock;
 
-	conn->state = BT_CLOSED;
-
-	if (conn->type == ACL_LINK || conn->type == LE_LINK)
-		mgmt_disconnected(hdev->id, &conn->dst, ev->reason);
+	if (ev->status == 0)
+		conn->state = BT_CLOSED;
 
-	if (conn->type == LE_LINK)
-		del_timer(&conn->smp_timer);
+	if (test_and_clear_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags) &&
+			(conn->type == ACL_LINK || conn->type == LE_LINK)) {
+		if (ev->status != 0)
+			mgmt_disconnect_failed(hdev, &conn->dst, conn->type,
+						conn->dst_type, ev->status);
+		else
+			mgmt_device_disconnected(hdev, &conn->dst, conn->type,
+						 conn->dst_type);
+	}
 
-	hci_proto_disconn_cfm(conn, ev->reason, 0);
-	hci_conn_del(conn);
+	if (ev->status == 0) {
+		if (conn->type == ACL_LINK && conn->flush_key)
+			hci_remove_link_key(hdev, &conn->dst);
+		hci_proto_disconn_cfm(conn, ev->reason);
+		hci_conn_del(conn);
+	}
 
 unlock:
 	hci_dev_unlock(hdev);
@@ -1836,82 +1937,59 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
-	if (conn) {
-		if (ev->status == 0x06 && hdev->ssp_mode > 0 &&
-							conn->ssp_mode > 0) {
-			struct hci_cp_auth_requested cp;
-			hci_remove_link_key(hdev, &conn->dst);
-			cp.handle = cpu_to_le16(conn->handle);
-			hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
-							sizeof(cp), &cp);
-			hci_dev_unlock(hdev);
-			BT_INFO("Pin or key missing");
-			return;
-		}
+	if (!conn)
+		goto unlock;
 
-		if (!ev->status) {
+	if (!ev->status) {
+		if (!hci_conn_ssp_enabled(conn) &&
+				test_bit(HCI_CONN_REAUTH_PEND, &conn->flags)) {
+			BT_INFO("re-auth of legacy device is not possible.");
+		} else {
 			conn->link_mode |= HCI_LM_AUTH;
 			conn->sec_level = conn->pending_sec_level;
-		} else {
-			mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
-			conn->sec_level = BT_SECURITY_LOW;
 		}
+	} else {
+		mgmt_auth_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+				 ev->status);
+	}
 
-		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
+	clear_bit(HCI_CONN_AUTH_PEND, &conn->flags);
+	clear_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 
-		if (conn->state == BT_CONFIG) {
-			if (!ev->status && hdev->ssp_mode > 0 &&
-							conn->ssp_mode > 0) {
-				struct hci_cp_set_conn_encrypt cp;
-				cp.handle  = ev->handle;
-				cp.encrypt = 0x01;
-				hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT,
-							sizeof(cp), &cp);
-			} else {
-				conn->state = BT_CONNECTED;
-				hci_proto_connect_cfm(conn, ev->status);
-				hci_conn_put(conn);
-			}
+	if (conn->state == BT_CONFIG) {
+		if (!ev->status && hci_conn_ssp_enabled(conn)) {
+			struct hci_cp_set_conn_encrypt cp;
+			cp.handle  = ev->handle;
+			cp.encrypt = 0x01;
+			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
 		} else {
-			hci_auth_cfm(conn, ev->status);
-
-			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+			conn->state = BT_CONNECTED;
+			hci_proto_connect_cfm(conn, ev->status);
 			hci_conn_put(conn);
 		}
+	} else {
+		hci_auth_cfm(conn, ev->status);
 
-		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-			if (!ev->status) {
-				if (conn->link_mode & HCI_LM_ENCRYPT) {
-					/* Encryption implies authentication */
-					conn->link_mode |= HCI_LM_AUTH;
-					conn->link_mode |= HCI_LM_ENCRYPT;
-					conn->sec_level =
-						conn->pending_sec_level;
-					clear_bit(HCI_CONN_ENCRYPT_PEND,
-							&conn->pend);
-					hci_encrypt_cfm(conn, ev->status, 1);
-
-					if (test_bit(HCI_MGMT, &hdev->flags))
-						mgmt_encrypt_change(hdev->id,
-							&conn->dst,
-							ev->status);
-
-				} else {
-					struct hci_cp_set_conn_encrypt cp;
-					cp.handle  = ev->handle;
-					cp.encrypt = 0x01;
-					hci_send_cmd(hdev,
-						HCI_OP_SET_CONN_ENCRYPT,
-						sizeof(cp), &cp);
-				}
-			} else {
-				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
-				hci_encrypt_cfm(conn, ev->status, 0x00);
-			}
+		hci_conn_hold(conn);
+		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+		hci_conn_put(conn);
+	}
+
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
+		if (!ev->status) {
+			struct hci_cp_set_conn_encrypt cp;
+			cp.handle  = ev->handle;
+			cp.encrypt = 0x01;
+			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
+		} else {
+			clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
+			hci_encrypt_cfm(conn, ev->status, 0x00);
 		}
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1926,16 +2004,31 @@
 
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_remote_name(hdev->id, &ev->bdaddr, ev->status, ev->name);
-
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
+
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		goto check_auth;
+
+	if (ev->status == 0)
+		hci_check_pending_name(hdev, conn, &ev->bdaddr, ev->name,
+				       strnlen(ev->name, HCI_MAX_NAME_LENGTH));
+	else
+		hci_check_pending_name(hdev, conn, &ev->bdaddr, NULL, 0);
+
+check_auth:
+	if (!conn)
+		goto unlock;
+
+	if (!hci_outgoing_auth_needed(hdev, conn))
+		goto unlock;
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1960,7 +2053,13 @@
 				conn->link_mode &= ~HCI_LM_ENCRYPT;
 		}
 
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
+
+		if (ev->status && conn->state == BT_CONNECTED) {
+			hci_acl_disconn(conn, 0x13);
+			hci_conn_put(conn);
+			goto unlock;
+		}
 
 		if (conn->state == BT_CONFIG) {
 			if (!ev->status)
@@ -1968,30 +2067,11 @@
 
 			hci_proto_connect_cfm(conn, ev->status);
 			hci_conn_put(conn);
-		} else {
-			/*
-			* If the remote device does not support
-			* Pause Encryption, usually during the
-			* roleSwitch we see Encryption disable
-			* for short duration. Allow remote device
-			* to disable encryption
-			* for short duration in this case.
-			*/
-			if ((ev->encrypt == 0) && (ev->status == 0) &&
-				((conn->features[5] & LMP_PAUSE_ENC) == 0)) {
-				mod_timer(&conn->encrypt_pause_timer,
-					jiffies + msecs_to_jiffies(500));
-				BT_INFO("enc pause timer, enc_pend_flag set");
-			} else {
-				del_timer(&conn->encrypt_pause_timer);
-				hci_encrypt_cfm(conn, ev->status, ev->encrypt);
-			}
-		}
-
-		if (test_bit(HCI_MGMT, &hdev->flags))
-			mgmt_encrypt_change(hdev->id, &conn->dst, ev->status);
+		} else
+			hci_encrypt_cfm(conn, ev->status, ev->encrypt);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -2009,7 +2089,7 @@
 		if (!ev->status)
 			conn->link_mode |= HCI_LM_SECURE;
 
-		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
+		clear_bit(HCI_CONN_AUTH_PEND, &conn->flags);
 
 		hci_key_change_cfm(conn, ev->status);
 	}
@@ -2030,10 +2110,8 @@
 	if (!conn)
 		goto unlock;
 
-	if (!ev->status) {
+	if (!ev->status)
 		memcpy(conn->features, ev->features, 8);
-		mgmt_remote_features(hdev->id, &conn->dst, ev->features);
-	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
@@ -2045,18 +2123,18 @@
 		hci_send_cmd(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES,
 							sizeof(cp), &cp);
 		goto unlock;
-	} else  if (!(lmp_ssp_capable(conn)) && conn->auth_initiator &&
-		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH)) {
-		conn->pending_sec_level = BT_SECURITY_MEDIUM;
 	}
 
-	if (!ev->status) {
+	if (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {
 		struct hci_cp_remote_name_req cp;
 		memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
-	}
+	} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &conn->dst, conn->type,
+				      conn->dst_type, 0, NULL, 0,
+				      conn->dev_class);
 
 	if (!hci_outgoing_auth_needed(hdev, conn)) {
 		conn->state = BT_CONNECTED;
@@ -2070,24 +2148,7 @@
 
 static inline void hci_remote_version_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_ev_remote_version *ev = (void *) skb->data;
-	struct hci_cp_read_remote_features cp;
-	struct hci_conn *conn;
-	BT_DBG("%s status %d", hdev->name, ev->status);
-
-	hci_dev_lock(hdev);
-	cp.handle = ev->handle;
-	hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
-				sizeof(cp), &cp);
-
-	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
-	if (!conn)
-		goto unlock;
-	if (!ev->status)
-		mgmt_remote_version(hdev->id, &conn->dst, ev->lmp_ver,
-				ev->manufacturer, ev->lmp_subver);
-unlock:
-	hci_dev_unlock(hdev);
+	BT_DBG("%s", hdev->name);
 }
 
 static inline void hci_qos_setup_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2104,9 +2165,6 @@
 
 	opcode = __le16_to_cpu(ev->opcode);
 
-	if (test_bit(HCI_RESET, &hdev->flags) && (opcode != HCI_OP_RESET))
-		return;
-
 	switch (opcode) {
 	case HCI_OP_INQUIRY_CANCEL:
 		hci_cc_inquiry_cancel(hdev, skb);
@@ -2116,10 +2174,6 @@
 		hci_cc_exit_periodic_inq(hdev, skb);
 		break;
 
-	case HCI_OP_LINK_KEY_REPLY:
-		hci_cc_link_key_reply(hdev, skb);
-		break;
-
 	case HCI_OP_REMOTE_NAME_REQ_CANCEL:
 		hci_cc_remote_name_req_cancel(hdev, skb);
 		break;
@@ -2188,10 +2242,6 @@
 		hci_cc_host_buffer_size(hdev, skb);
 		break;
 
-	case HCI_OP_READ_SSP_MODE:
-		hci_cc_read_ssp_mode(hdev, skb);
-		break;
-
 	case HCI_OP_WRITE_SSP_MODE:
 		hci_cc_write_ssp_mode(hdev, skb);
 		break;
@@ -2208,6 +2258,10 @@
 		hci_cc_read_local_features(hdev, skb);
 		break;
 
+	case HCI_OP_READ_LOCAL_EXT_FEATURES:
+		hci_cc_read_local_ext_features(hdev, skb);
+		break;
+
 	case HCI_OP_READ_BUFFER_SIZE:
 		hci_cc_read_buffer_size(hdev, skb);
 		break;
@@ -2216,6 +2270,10 @@
 		hci_cc_read_bd_addr(hdev, skb);
 		break;
 
+	case HCI_OP_READ_DATA_BLOCK_SIZE:
+		hci_cc_read_data_block_size(hdev, skb);
+		break;
+
 	case HCI_OP_WRITE_CA_TIMEOUT:
 		hci_cc_write_ca_timeout(hdev, skb);
 		break;
@@ -2224,19 +2282,10 @@
 		hci_cc_read_flow_control_mode(hdev, skb);
 		break;
 
-	case HCI_OP_READ_DATA_BLOCK_SIZE:
-		hci_cc_read_data_block_size(hdev, skb);
-		break;
-
 	case HCI_OP_READ_LOCAL_AMP_INFO:
 		hci_cc_read_local_amp_info(hdev, skb);
 		break;
 
-	case HCI_OP_READ_LOCAL_AMP_ASSOC:
-	case HCI_OP_WRITE_REMOTE_AMP_ASSOC:
-		hci_amp_cmd_complete(hdev, opcode, skb);
-		break;
-
 	case HCI_OP_DELETE_STORED_LINK_KEY:
 		hci_cc_delete_stored_link_key(hdev, skb);
 		break;
@@ -2273,24 +2322,28 @@
 		hci_cc_le_read_buffer_size(hdev, skb);
 		break;
 
-	case HCI_OP_LE_READ_WHITE_LIST_SIZE:
-		hci_cc_le_read_white_list_size(hdev, skb);
+	case HCI_OP_USER_CONFIRM_REPLY:
+		hci_cc_user_confirm_reply(hdev, skb);
 		break;
 
-	case HCI_OP_LE_CLEAR_WHITE_LIST:
-		hci_cc_le_clear_white_list(hdev, skb);
+	case HCI_OP_USER_CONFIRM_NEG_REPLY:
+		hci_cc_user_confirm_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_READ_RSSI:
-		hci_cc_read_rssi(hdev, skb);
+	case HCI_OP_USER_PASSKEY_REPLY:
+		hci_cc_user_passkey_reply(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_REPLY:
-		hci_cc_user_confirm_reply(hdev, skb);
+	case HCI_OP_USER_PASSKEY_NEG_REPLY:
+		hci_cc_user_passkey_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_NEG_REPLY:
-		hci_cc_user_confirm_neg_reply(hdev, skb);
+	case HCI_OP_LE_SET_SCAN_PARAM:
+		hci_cc_le_set_scan_param(hdev, skb);
+		break;
+
+	case HCI_OP_LE_SET_SCAN_ENABLE:
+		hci_cc_le_set_scan_enable(hdev, skb);
 		break;
 
 	case HCI_OP_LE_LTK_REPLY:
@@ -2301,8 +2354,8 @@
 		hci_cc_le_ltk_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_LE_SET_SCAN_ENABLE:
-		hci_cc_le_set_scan_enable(hdev, skb);
+	case HCI_OP_WRITE_LE_HOST_SUPPORTED:
+		hci_cc_write_le_host_supported(hdev, skb);
 		break;
 
 	default:
@@ -2313,10 +2366,10 @@
 	if (ev->opcode != HCI_OP_NOP)
 		del_timer(&hdev->cmd_timer);
 
-	if (ev->ncmd) {
+	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 	}
 }
 
@@ -2367,40 +2420,15 @@
 		break;
 
 	case HCI_OP_SNIFF_MODE:
-		hci_cs_sniff_mode(hdev, ev->status);
-		break;
-
-	case HCI_OP_EXIT_SNIFF_MODE:
-		hci_cs_exit_sniff_mode(hdev, ev->status);
-		break;
-
-	case HCI_OP_CREATE_LOGICAL_LINK:
-		hci_cs_create_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_ACCEPT_LOGICAL_LINK:
-		hci_cs_accept_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_DISCONN_LOGICAL_LINK:
-		hci_cs_disconn_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_FLOW_SPEC_MODIFY:
-		hci_cs_flow_spec_modify(hdev, ev->status);
+		hci_cs_sniff_mode(hdev, ev->status);
 		break;
 
-	case HCI_OP_CREATE_PHYS_LINK:
-	case HCI_OP_ACCEPT_PHYS_LINK:
-		hci_amp_cmd_status(hdev, opcode, ev->status);
+	case HCI_OP_EXIT_SNIFF_MODE:
+		hci_cs_exit_sniff_mode(hdev, ev->status);
 		break;
 
-	case HCI_OP_DISCONN_PHYS_LINK:
-		hci_cs_disconn_physical_link(hdev, ev->status);
-
 	case HCI_OP_DISCONNECT:
-		if (ev->status != 0)
-			mgmt_disconnect_failed(hdev->id);
+		hci_cs_disconnect(hdev, ev->status);
 		break;
 
 	case HCI_OP_LE_CREATE_CONN:
@@ -2422,7 +2450,7 @@
 	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 	}
 }
 
@@ -2444,7 +2472,7 @@
 				conn->link_mode |= HCI_LM_MASTER;
 		}
 
-		clear_bit(HCI_CONN_RSWITCH_PEND, &conn->pend);
+		clear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);
 
 		hci_role_switch_cfm(conn, ev->status, ev->role);
 	}
@@ -2455,125 +2483,117 @@
 static inline void hci_num_comp_pkts_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_num_comp_pkts *ev = (void *) skb->data;
-	__le16 *ptr;
 	int i;
 
-	skb_pull(skb, sizeof(*ev));
-
-	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
+	if (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_PACKET_BASED) {
+		BT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);
+		return;
+	}
 
-	if (skb->len < ev->num_hndl * 4) {
+	if (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +
+			ev->num_hndl * sizeof(struct hci_comp_pkts_info)) {
 		BT_DBG("%s bad parameters", hdev->name);
 		return;
 	}
 
-	tasklet_disable(&hdev->tx_task);
+	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
 
-	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
-		struct hci_conn *conn = NULL;
-		struct hci_chan *chan;
+	for (i = 0; i < ev->num_hndl; i++) {
+		struct hci_comp_pkts_info *info = &ev->handles[i];
+		struct hci_conn *conn;
 		__u16  handle, count;
 
-		handle = get_unaligned_le16(ptr++);
-		count  = get_unaligned_le16(ptr++);
+		handle = __le16_to_cpu(info->handle);
+		count  = __le16_to_cpu(info->count);
 
-		if (hdev->dev_type == HCI_BREDR)
-			conn = hci_conn_hash_lookup_handle(hdev, handle);
-		else {
-			chan = hci_chan_list_lookup_handle(hdev, handle);
-			if (chan)
-				conn = chan->conn;
-		}
-		if (conn) {
-			conn->sent -= count;
+		conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (!conn)
+			continue;
 
-			if (conn->type == ACL_LINK) {
+		conn->sent -= count;
+
+		switch (conn->type) {
+		case ACL_LINK:
+			hdev->acl_cnt += count;
+			if (hdev->acl_cnt > hdev->acl_pkts)
+				hdev->acl_cnt = hdev->acl_pkts;
+			break;
+
+		case LE_LINK:
+			if (hdev->le_pkts) {
+				hdev->le_cnt += count;
+				if (hdev->le_cnt > hdev->le_pkts)
+					hdev->le_cnt = hdev->le_pkts;
+			} else {
 				hdev->acl_cnt += count;
 				if (hdev->acl_cnt > hdev->acl_pkts)
 					hdev->acl_cnt = hdev->acl_pkts;
-			} else if (conn->type == LE_LINK) {
-				if (hdev->le_pkts) {
-					hdev->le_cnt += count;
-					if (hdev->le_cnt > hdev->le_pkts)
-						hdev->le_cnt = hdev->le_pkts;
-				} else {
-					hdev->acl_cnt += count;
-					if (hdev->acl_cnt > hdev->acl_pkts)
-						hdev->acl_cnt = hdev->acl_pkts;
-				}
-			} else {
-				hdev->sco_cnt += count;
-				if (hdev->sco_cnt > hdev->sco_pkts)
-					hdev->sco_cnt = hdev->sco_pkts;
 			}
+			break;
+
+		case SCO_LINK:
+			hdev->sco_cnt += count;
+			if (hdev->sco_cnt > hdev->sco_pkts)
+				hdev->sco_cnt = hdev->sco_pkts;
+			break;
+
+		default:
+			BT_ERR("Unknown type %d conn %p", conn->type, conn);
+			break;
 		}
 	}
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 
 static inline void hci_num_comp_blocks_evt(struct hci_dev *hdev,
-					struct sk_buff *skb)
+					   struct sk_buff *skb)
 {
 	struct hci_ev_num_comp_blocks *ev = (void *) skb->data;
-	__le16 *ptr;
 	int i;
 
-	skb_pull(skb, sizeof(*ev));
-
-	BT_DBG("%s total_num_blocks %d num_hndl %d",
-		hdev->name, ev->total_num_blocks, ev->num_hndl);
+	if (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_BLOCK_BASED) {
+		BT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);
+		return;
+	}
 
-	if (skb->len < ev->num_hndl * 6) {
+	if (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +
+			ev->num_hndl * sizeof(struct hci_comp_blocks_info)) {
 		BT_DBG("%s bad parameters", hdev->name);
 		return;
 	}
 
-	tasklet_disable(&hdev->tx_task);
+	BT_DBG("%s num_blocks %d num_hndl %d", hdev->name, ev->num_blocks,
+								ev->num_hndl);
 
-	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
-		struct hci_conn *conn = NULL;
-		struct hci_chan *chan;
+	for (i = 0; i < ev->num_hndl; i++) {
+		struct hci_comp_blocks_info *info = &ev->handles[i];
+		struct hci_conn *conn;
 		__u16  handle, block_count;
 
-		handle = get_unaligned_le16(ptr++);
+		handle = __le16_to_cpu(info->handle);
+		block_count = __le16_to_cpu(info->blocks);
 
-		/* Skip packet count */
-		ptr++;
-		block_count  = get_unaligned_le16(ptr++);
-
-		BT_DBG("%s handle %d count %d", hdev->name, handle,
-			block_count);
-
-		if (hdev->dev_type == HCI_BREDR)
-			conn = hci_conn_hash_lookup_handle(hdev, handle);
-		else {
-			chan = hci_chan_list_lookup_handle(hdev, handle);
-			if (chan)
-				conn = chan->conn;
-		}
-		if (conn) {
-			BT_DBG("%s conn %p sent %d", hdev->name,
-				conn, conn->sent);
+		conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (!conn)
+			continue;
 
-			conn->sent -= block_count;
+		conn->sent -= block_count;
 
-			if (conn->type == ACL_LINK) {
-				hdev->acl_cnt += block_count;
-				if (hdev->acl_cnt > hdev->acl_pkts)
-					hdev->acl_cnt = hdev->acl_pkts;
-			} else {
-				/* We should not find ourselves here */
-				BT_DBG("Unexpected event for SCO connection");
-			}
+		switch (conn->type) {
+		case ACL_LINK:
+			hdev->block_cnt += block_count;
+			if (hdev->block_cnt > hdev->num_blocks)
+				hdev->block_cnt = hdev->num_blocks;
+			break;
+
+		default:
+			BT_ERR("Unknown type %d conn %p", conn->type, conn);
+			break;
 		}
 	}
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 
 static inline void hci_mode_change_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2590,17 +2610,14 @@
 		conn->mode = ev->mode;
 		conn->interval = __le16_to_cpu(ev->interval);
 
-		if (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		if (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 			if (conn->mode == HCI_CM_ACTIVE)
-				conn->power_save = 1;
+				set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 			else
-				conn->power_save = 0;
+				clear_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 		}
-		if (conn->mode == HCI_CM_SNIFF)
-			if (wake_lock_active(&conn->idle_lock))
-				wake_unlock(&conn->idle_lock);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, ev->status);
 	}
 
@@ -2617,20 +2634,30 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (conn && conn->state == BT_CONNECTED) {
+	if (!conn)
+		goto unlock;
+
+	if (conn->state == BT_CONNECTED) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_PAIRING_TIMEOUT;
 		hci_conn_put(conn);
-		hci_conn_enter_active_mode(conn, 0);
 	}
 
-	if (!test_bit(HCI_PAIRABLE, &hdev->flags))
+	if (!test_bit(HCI_PAIRABLE, &hdev->dev_flags))
 		hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,
 					sizeof(ev->bdaddr), &ev->bdaddr);
+	else if (test_bit(HCI_MGMT, &hdev->dev_flags)) {
+		u8 secure;
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_request(hdev->id, &ev->bdaddr);
+		if (conn->pending_sec_level == BT_SECURITY_HIGH)
+			secure = 1;
+		else
+			secure = 0;
+
+		mgmt_pin_code_request(hdev, &ev->bdaddr, secure);
+	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -2643,7 +2670,7 @@
 
 	BT_DBG("%s", hdev->name);
 
-	if (!test_bit(HCI_LINK_KEYS, &hdev->flags))
+	if (!test_bit(HCI_LINK_KEYS, &hdev->dev_flags))
 		return;
 
 	hci_dev_lock(hdev);
@@ -2655,31 +2682,33 @@
 		goto not_found;
 	}
 
-	BT_DBG("%s found key type %u for %s", hdev->name, key->key_type,
+	BT_DBG("%s found key type %u for %s", hdev->name, key->type,
 							batostr(&ev->bdaddr));
 
-	if (!test_bit(HCI_DEBUG_KEYS, &hdev->flags) && key->key_type == 0x03) {
+	if (!test_bit(HCI_DEBUG_KEYS, &hdev->dev_flags) &&
+				key->type == HCI_LK_DEBUG_COMBINATION) {
 		BT_DBG("%s ignoring debug key", hdev->name);
 		goto not_found;
 	}
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-
 	if (conn) {
-		BT_DBG("Conn pending sec level is %d, ssp is %d, key len is %d",
-			conn->pending_sec_level, conn->ssp_mode, key->pin_len);
-	}
-	if (conn && (conn->ssp_mode == 0) &&
-		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH) &&
-		(key->pin_len != 16)) {
-		BT_DBG("Security is high ignoring this key");
-		goto not_found;
-	}
+		if (key->type == HCI_LK_UNAUTH_COMBINATION &&
+				conn->auth_type != 0xff &&
+				(conn->auth_type & 0x01)) {
+			BT_DBG("%s ignoring unauthenticated key", hdev->name);
+			goto not_found;
+		}
+
+		if (key->type == HCI_LK_COMBINATION && key->pin_len < 16 &&
+				conn->pending_sec_level == BT_SECURITY_HIGH) {
+			BT_DBG("%s ignoring key unauthenticated for high \
+							security", hdev->name);
+			goto not_found;
+		}
 
-	if (key->key_type == 0x04 && conn && conn->auth_type != 0xff &&
-						(conn->auth_type & 0x01)) {
-		BT_DBG("%s ignoring unauthenticated key", hdev->name);
-		goto not_found;
+		conn->key_type = key->type;
+		conn->pin_length = key->pin_len;
 	}
 
 	bacpy(&cp.bdaddr, &ev->bdaddr);
@@ -2702,7 +2731,7 @@
 	struct hci_conn *conn;
 	u8 pin_len = 0;
 
-	BT_DBG("%s type %d", hdev->name, ev->key_type);
+	BT_DBG("%s", hdev->name);
 
 	hci_dev_lock(hdev);
 
@@ -2710,19 +2739,16 @@
 	if (conn) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+		pin_len = conn->pin_length;
 
-		memcpy(conn->link_key, ev->link_key, 16);
-		conn->key_type = ev->key_type;
-		hci_disconnect_amp(conn, 0x06);
+		if (ev->key_type != HCI_LK_CHANGED_COMBINATION)
+			conn->key_type = ev->key_type;
 
-		conn->link_mode &= ~HCI_LM_ENCRYPT;
-		pin_len = conn->pin_length;
 		hci_conn_put(conn);
-		hci_conn_enter_active_mode(conn, 0);
 	}
 
-	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
-		hci_add_link_key(hdev, 1, &ev->bdaddr, ev->link_key,
+	if (test_bit(HCI_LINK_KEYS, &hdev->dev_flags))
+		hci_add_link_key(hdev, conn, 1, &ev->bdaddr, ev->link_key,
 							ev->key_type, pin_len);
 
 	hci_dev_unlock(hdev);
@@ -2789,6 +2815,7 @@
 {
 	struct inquiry_data data;
 	int num_rsp = *((__u8 *) skb->data);
+	bool name_known, ssp;
 
 	BT_DBG("%s num_rsp %d", hdev->name, num_rsp);
 
@@ -2810,10 +2837,12 @@
 			data.clock_offset	= info->clock_offset;
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
-			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-						info->dev_class, info->rssi,
-						0, NULL);
+
+			name_known = hci_inquiry_cache_update(hdev, &data,
+							      false, &ssp);
+			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+					  info->dev_class, info->rssi,
+					  !name_known, ssp, NULL, 0);
 		}
 	} else {
 		struct inquiry_info_with_rssi *info = (void *) (skb->data + 1);
@@ -2827,10 +2856,11 @@
 			data.clock_offset	= info->clock_offset;
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
-			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-						info->dev_class, info->rssi,
-						0, NULL);
+			name_known = hci_inquiry_cache_update(hdev, &data,
+							      false, &ssp);
+			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+					  info->dev_class, info->rssi,
+					  !name_known, ssp, NULL, 0);
 		}
 	}
 
@@ -2855,32 +2885,25 @@
 
 		ie = hci_inquiry_cache_lookup(hdev, &conn->dst);
 		if (ie)
-			ie->data.ssp_mode = (ev->features[0] & 0x01);
+			ie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);
 
-		conn->ssp_mode = (ev->features[0] & 0x01);
-		/*In case if remote device ssp supported/2.0 device
-		reduce the security level to MEDIUM if it is VERY HIGH*/
-		if (!conn->ssp_mode && conn->auth_initiator &&
-			(conn->pending_sec_level == BT_SECURITY_VERY_HIGH))
-			conn->pending_sec_level = BT_SECURITY_MEDIUM;
-
-		if (conn->ssp_mode && conn->auth_initiator &&
-			conn->io_capability != 0x03) {
-			conn->pending_sec_level = BT_SECURITY_VERY_HIGH;
-			conn->auth_type = HCI_AT_DEDICATED_BONDING_MITM;
-		}
+		if (ev->features[0] & LMP_HOST_SSP)
+			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
 
-	if (!ev->status) {
+	if (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {
 		struct hci_cp_remote_name_req cp;
 		memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
-	}
+	} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &conn->dst, conn->type,
+				      conn->dst_type, 0, NULL, 0,
+				      conn->dev_class);
 
 	if (!hci_outgoing_auth_needed(hdev, conn)) {
 		conn->state = BT_CONNECTED;
@@ -2927,9 +2950,7 @@
 	case 0x1a:	/* Unsupported Remote Feature */
 	case 0x1f:	/* Unspecified error */
 		if (conn->out && conn->attempt < 2) {
-			if (!conn->hdev->is_wbs)
-				conn->pkt_type =
-					(hdev->esco_type & SCO_ESCO_MASK) |
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
 					(hdev->esco_type & EDR_ESCO_MASK);
 			hci_setup_sync(conn, conn->link->handle);
 			goto unlock;
@@ -2957,16 +2978,8 @@
 static inline void hci_sniff_subrate_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_sniff_subrate *ev = (void *) skb->data;
-	struct hci_conn *conn =
-		hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
-	if (conn && (ev->max_rx_latency > hdev->sniff_max_interval)) {
-		BT_ERR("value of rx_latency:%d", ev->max_rx_latency);
-		hci_dev_lock(hdev);
-		hci_conn_enter_active_mode(conn, 1);
-		hci_dev_unlock(hdev);
-	}
 }
 
 static inline void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2983,6 +2996,8 @@
 	hci_dev_lock(hdev);
 
 	for (; num_rsp; num_rsp--, info++) {
+		bool name_known, ssp;
+
 		bacpy(&data.bdaddr, &info->bdaddr);
 		data.pscan_rep_mode	= info->pscan_rep_mode;
 		data.pscan_period_mode	= info->pscan_period_mode;
@@ -2991,10 +3006,19 @@
 		data.clock_offset	= info->clock_offset;
 		data.rssi		= info->rssi;
 		data.ssp_mode		= 0x01;
-		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-				info->dev_class, info->rssi,
-				HCI_MAX_EIR_LENGTH, info->data);
+
+		if (test_bit(HCI_MGMT, &hdev->dev_flags))
+			name_known = eir_has_data_type(info->data,
+						       sizeof(info->data),
+						       EIR_NAME_COMPLETE);
+		else
+			name_known = true;
+
+		name_known = hci_inquiry_cache_update(hdev, &data, name_known,
+						      &ssp);
+		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+				  info->dev_class, info->rssi, !name_known,
+				  ssp, info->data, sizeof(info->data));
 	}
 
 	hci_dev_unlock(hdev);
@@ -3002,23 +3026,19 @@
 
 static inline u8 hci_get_auth_req(struct hci_conn *conn)
 {
-	BT_DBG("%p", conn);
-
 	/* If remote requests dedicated bonding follow that lead */
 	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03) {
 		/* If both remote and local IO capabilities allow MITM
 		 * protection then require it, otherwise don't */
-		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03) {
+		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03)
 			return 0x02;
-		} else {
-			conn->auth_type |= 0x01;
+		else
 			return 0x03;
-		}
 	}
 
 	/* If remote requests no-bonding follow that lead */
-	if (conn->remote_auth <= 0x01)
-		return 0x00;
+	if (conn->remote_auth == 0x00 || conn->remote_auth == 0x01)
+		return conn->remote_auth | (conn->auth_type & 0x01);
 
 	return conn->auth_type;
 }
@@ -3038,23 +3058,22 @@
 
 	hci_conn_hold(conn);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		goto unlock;
 
-	if (test_bit(HCI_PAIRABLE, &hdev->flags) ||
+	if (test_bit(HCI_PAIRABLE, &hdev->dev_flags) ||
 			(conn->remote_auth & ~0x01) == HCI_AT_NO_BONDING) {
 		struct hci_cp_io_capability_reply cp;
-		u8 io_cap = conn->io_capability;
 
-		/* ACL-SSP does not support IO CAP 0x04 */
-		cp.capability = (io_cap == 0x04) ? 0x01 : io_cap;
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		if (conn->auth_initiator)
-			cp.authentication = conn->auth_type;
-		else
-			cp.authentication = hci_get_auth_req(conn);
+		/* Change the IO capability from KeyboardDisplay
+		 * to DisplayYesNo as it is not supported by BT spec. */
+		cp.capability = (conn->io_capability == 0x04) ?
+						0x01 : conn->io_capability;
+		conn->auth_type = hci_get_auth_req(conn);
+		cp.authentication = conn->auth_type;
 
-		if ((conn->out == 0x01 || conn->remote_oob == 0x01) &&
+		if ((conn->out || test_bit(HCI_CONN_REMOTE_OOB, &conn->flags)) &&
 				hci_find_remote_oob_data(hdev, &conn->dst))
 			cp.oob_data = 0x01;
 		else
@@ -3066,7 +3085,7 @@
 		struct hci_cp_io_capability_neg_reply cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = 0x16; /* Pairing not allowed */
+		cp.reason = HCI_ERROR_PAIRING_NOT_ALLOWED;
 
 		hci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_NEG_REPLY,
 							sizeof(cp), &cp);
@@ -3090,31 +3109,94 @@
 		goto unlock;
 
 	conn->remote_cap = ev->capability;
-	conn->remote_oob = ev->oob_data;
 	conn->remote_auth = ev->authentication;
+	if (ev->oob_data)
+		set_bit(HCI_CONN_REMOTE_OOB, &conn->flags);
 
 unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_user_ssp_confirmation_evt(struct hci_dev *hdev,
-						u8 event, struct sk_buff *skb)
+static inline void hci_user_confirm_request_evt(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
 	struct hci_ev_user_confirm_req *ev = (void *) skb->data;
+	int loc_mitm, rem_mitm, confirm_hint = 0;
+	struct hci_conn *conn;
 
 	BT_DBG("%s", hdev->name);
 
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags)) {
-		if (event == HCI_EV_USER_PASSKEY_REQUEST)
-			mgmt_user_confirm_request(hdev->id, event,
-							&ev->bdaddr, 0);
-		else
-			mgmt_user_confirm_request(hdev->id, event,
-						&ev->bdaddr, ev->passkey);
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		goto unlock;
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
+	if (!conn)
+		goto unlock;
+
+	loc_mitm = (conn->auth_type & 0x01);
+	rem_mitm = (conn->remote_auth & 0x01);
+
+	/* If we require MITM but the remote device can't provide that
+	 * (it has NoInputNoOutput) then reject the confirmation
+	 * request. The only exception is when we're dedicated bonding
+	 * initiators (connect_cfm_cb set) since then we always have the MITM
+	 * bit set. */
+	if (!conn->connect_cfm_cb && loc_mitm && conn->remote_cap == 0x03) {
+		BT_DBG("Rejecting request: remote device can't provide MITM");
+		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_NEG_REPLY,
+					sizeof(ev->bdaddr), &ev->bdaddr);
+		goto unlock;
+	}
+
+	/* If no side requires MITM protection; auto-accept */
+	if ((!loc_mitm || conn->remote_cap == 0x03) &&
+				(!rem_mitm || conn->io_capability == 0x03)) {
+
+		/* If we're not the initiators request authorization to
+		 * proceed from user space (mgmt_user_confirm with
+		 * confirm_hint set to 1). */
+		if (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
+			BT_DBG("Confirming auto-accept as acceptor");
+			confirm_hint = 1;
+			goto confirm;
+		}
+
+		BT_DBG("Auto-accept of user confirmation with %ums delay",
+						hdev->auto_accept_delay);
+
+		if (hdev->auto_accept_delay > 0) {
+			int delay = msecs_to_jiffies(hdev->auto_accept_delay);
+			mod_timer(&conn->auto_accept_timer, jiffies + delay);
+			goto unlock;
+		}
+
+		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY,
+						sizeof(ev->bdaddr), &ev->bdaddr);
+		goto unlock;
 	}
 
+confirm:
+	mgmt_user_confirm_request(hdev, &ev->bdaddr, ACL_LINK, 0, ev->passkey,
+				  confirm_hint);
+
+unlock:
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_user_passkey_request_evt(struct hci_dev *hdev,
+							struct sk_buff *skb)
+{
+	struct hci_ev_user_passkey_req *ev = (void *) skb->data;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_request(hdev, &ev->bdaddr, ACL_LINK, 0);
+
 	hci_dev_unlock(hdev);
 }
 
@@ -3136,8 +3218,9 @@
 	 * initiated the authentication. A traditional auth_complete
 	 * event gets always produced as initiator and is also mapped to
 	 * the mgmt_auth_failed event */
-	if (!test_bit(HCI_CONN_AUTH_PEND, &conn->pend) && ev->status != 0)
-		mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
+	if (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) && ev->status != 0)
+		mgmt_auth_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+				 ev->status);
 
 	hci_conn_put(conn);
 
@@ -3156,13 +3239,13 @@
 
 	ie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);
 	if (ie)
-		ie->data.ssp_mode = (ev->features[0] & 0x01);
+		ie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);
 
 	hci_dev_unlock(hdev);
 }
 
 static inline void hci_remote_oob_data_request_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
+						   struct sk_buff *skb)
 {
 	struct hci_ev_remote_oob_data_request *ev = (void *) skb->data;
 	struct oob_data *data;
@@ -3171,7 +3254,7 @@
 
 	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		goto unlock;
 
 	data = hci_find_remote_oob_data(hdev, &ev->bdaddr);
@@ -3200,89 +3283,70 @@
 {
 	struct hci_ev_le_conn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
-	u8 white_list;
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
 
 	hci_dev_lock(hdev);
 
-	/* Ignore event for LE cancel create conn whitelist */
-	if (ev->status && !bacmp(&ev->bdaddr, BDADDR_ANY))
-		goto unlock;
-
-	if (hci_conn_hash_lookup_ba(hdev, LE_LINK, BDADDR_ANY))
-		white_list = 1;
-	else
-		white_list = 0;
-
-	BT_DBG("w_list %d", white_list);
-
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &ev->bdaddr);
 	if (!conn) {
-		conn = hci_le_conn_add(hdev, &ev->bdaddr, ev->bdaddr_type);
+		conn = hci_conn_add(hdev, LE_LINK, &ev->bdaddr);
 		if (!conn) {
 			BT_ERR("No memory for new connection");
 			hci_dev_unlock(hdev);
 			return;
 		}
+
+		conn->dst_type = ev->bdaddr_type;
 	}
 
 	if (ev->status) {
+		mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
+						conn->dst_type, ev->status);
 		hci_proto_connect_cfm(conn, ev->status);
 		conn->state = BT_CLOSED;
 		hci_conn_del(conn);
 		goto unlock;
 	}
 
+	if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &ev->bdaddr, conn->type,
+				      conn->dst_type, 0, NULL, 0, NULL);
+
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->handle = __le16_to_cpu(ev->handle);
 	conn->state = BT_CONNECTED;
-	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-	mgmt_connected(hdev->id, &ev->bdaddr, 1);
-	mgmt_le_conn_params(hdev->id, &ev->bdaddr,
-			__le16_to_cpu(ev->interval),
-			__le16_to_cpu(ev->latency),
-			__le16_to_cpu(ev->supervision_timeout));
 
-	hci_conn_hold(conn);
 	hci_conn_hold_device(conn);
 	hci_conn_add_sysfs(conn);
 
-	if (!white_list)
-		hci_proto_connect_cfm(conn, ev->status);
+	hci_proto_connect_cfm(conn, ev->status);
 
 unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_le_conn_update_complete_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
+						struct sk_buff *skb)
 {
-	struct hci_ev_le_conn_update_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s status %d", hdev->name, ev->status);
+	u8 num_reports = skb->data[0];
+	void *ptr = &skb->data[1];
+	s8 rssi;
 
 	hci_dev_lock(hdev);
 
-	conn = hci_conn_hash_lookup_handle(hdev,
-				__le16_to_cpu(ev->handle));
-	if (conn == NULL) {
-		BT_ERR("Unknown connection update");
-		goto unlock;
-	}
+	while (num_reports--) {
+		struct hci_ev_le_advertising_info *ev = ptr;
 
-	if (ev->status) {
-		BT_ERR("Connection update unsuccessful");
-		goto unlock;
-	}
+		hci_add_adv_entry(hdev, ev);
 
-	mgmt_le_conn_params(hdev->id, &conn->dst,
-			__le16_to_cpu(ev->interval),
-			__le16_to_cpu(ev->latency),
-			__le16_to_cpu(ev->supervision_timeout));
+		rssi = ev->data[ev->length];
+		mgmt_device_found(hdev, &ev->bdaddr, LE_LINK, ev->bdaddr_type,
+				  NULL, rssi, 0, 1, ev->data, ev->length);
+
+		ptr += sizeof(*ev) + ev->length + 1;
+	}
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -3293,7 +3357,7 @@
 	struct hci_cp_le_ltk_reply cp;
 	struct hci_cp_le_ltk_neg_reply neg;
 	struct hci_conn *conn;
-	struct link_key *ltk;
+	struct smp_ltk *ltk;
 
 	BT_DBG("%s handle %d", hdev->name, cpu_to_le16(ev->handle));
 
@@ -3309,10 +3373,21 @@
 
 	memcpy(cp.ltk, ltk->val, sizeof(ltk->val));
 	cp.handle = cpu_to_le16(conn->handle);
-	conn->pin_length = ltk->pin_len;
+
+	if (ltk->authenticated)
+		conn->pending_sec_level = BT_SECURITY_HIGH;
+	else
+		conn->pending_sec_level = BT_SECURITY_MEDIUM;
+
+	conn->enc_key_size = ltk->enc_size;
 
 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
 
+	if (ltk->type & HCI_SMP_STK) {
+		list_del(&ltk->list);
+		kfree(ltk);
+	}
+
 	hci_dev_unlock(hdev);
 
 	return;
@@ -3323,27 +3398,6 @@
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_le_advertising_info *ev;
-	u8 num_reports;
-
-	num_reports = skb->data[0];
-	ev = (void *) &skb->data[1];
-
-	hci_dev_lock(hdev);
-
-	while (num_reports--) {
-		mgmt_device_found(hdev->id, &ev->bdaddr, ev->bdaddr_type,
-				1, NULL, 0, ev->length, ev->data);
-		hci_add_adv_entry(hdev, ev);
-		ev = (void *) (ev->data + ev->length + 1);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
 static inline void hci_le_meta_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_le_meta *le_ev = (void *) skb->data;
@@ -3355,150 +3409,24 @@
 		hci_le_conn_complete_evt(hdev, skb);
 		break;
 
-	case HCI_EV_LE_CONN_UPDATE_COMPLETE:
-		hci_le_conn_update_complete_evt(hdev, skb);
+	case HCI_EV_LE_ADVERTISING_REPORT:
+		hci_le_adv_report_evt(hdev, skb);
 		break;
 
 	case HCI_EV_LE_LTK_REQ:
 		hci_le_ltk_request_evt(hdev, skb);
 		break;
 
-	case HCI_EV_LE_ADVERTISING_REPORT:
-		hci_le_adv_report_evt(hdev, skb);
-		break;
-
 	default:
 		break;
 	}
 }
 
-static inline void hci_phy_link_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_phys_link_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s handle %d status %d", hdev->name, ev->phy_handle,
-		ev->status);
-
-	hci_dev_lock(hdev);
-
-	if (ev->status == 0) {
-		conn = hci_conn_add(hdev, ACL_LINK, 0, BDADDR_ANY);
-		if (conn) {
-			conn->handle = ev->phy_handle;
-			conn->state = BT_CONNECTED;
-
-			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT/2;
-			hci_conn_put(conn);
-
-			hci_conn_hold_device(conn);
-			hci_conn_add_sysfs(conn);
-		} else
-			BT_ERR("No memory for new connection");
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_log_link_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_log_link_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, ev->phy_handle);
-
-	if (chan) {
-		if (ev->status == 0) {
-			chan->ll_handle = __le16_to_cpu(ev->log_handle);
-			chan->state = BT_CONNECTED;
-		} else {
-			chan->state = BT_CLOSED;
-		}
-
-		hci_proto_create_cfm(chan, ev->status);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_flow_spec_modify_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_flow_spec_modify_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_handle(hdev, ev->log_handle);
-	if (chan)
-		hci_proto_modify_cfm(chan, ev->status);
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_disconn_log_link_complete_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_disconn_log_link_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	if (ev->status)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_handle(hdev, __le16_to_cpu(ev->log_handle));
-	if (chan)
-		hci_proto_destroy_cfm(chan, ev->reason);
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_disconn_phy_link_complete_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_disconn_phys_link_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s status %d", hdev->name, ev->status);
-
-	if (ev->status)
-		return;
-
-	hci_dev_lock(hdev);
-
-	conn = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);
-	if (conn) {
-		conn->state = BT_CLOSED;
-
-		hci_proto_disconn_cfm(conn, ev->reason, 0);
-		hci_conn_del(conn);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_event_hdr *hdr = (void *) skb->data;
 	__u8 event = hdr->evt;
 
-	BT_DBG("");
-
 	skb_pull(skb, HCI_EVENT_HDR_SIZE);
 
 	switch (event) {
@@ -3626,10 +3554,12 @@
 		hci_io_capa_reply_evt(hdev, skb);
 		break;
 
-	case HCI_EV_USER_PASSKEY_REQUEST:
-	case HCI_EV_USER_PASSKEY_NOTIFICATION:
 	case HCI_EV_USER_CONFIRM_REQUEST:
-		hci_user_ssp_confirmation_evt(hdev, event, skb);
+		hci_user_confirm_request_evt(hdev, skb);
+		break;
+
+	case HCI_EV_USER_PASSKEY_REQUEST:
+		hci_user_passkey_request_evt(hdev, skb);
 		break;
 
 	case HCI_EV_SIMPLE_PAIR_COMPLETE:
@@ -3648,40 +3578,10 @@
 		hci_remote_oob_data_request_evt(hdev, skb);
 		break;
 
-	case HCI_EV_PHYS_LINK_COMPLETE:
-		hci_phy_link_complete(hdev, skb);
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
-	case HCI_EV_LOG_LINK_COMPLETE:
-		hci_log_link_complete(hdev, skb);
-		break;
-
-	case HCI_EV_FLOW_SPEC_MODIFY_COMPLETE:
-		hci_flow_spec_modify_complete(hdev, skb);
-		break;
-
-	case HCI_EV_DISCONN_LOG_LINK_COMPLETE:
-		hci_disconn_log_link_complete_evt(hdev, skb);
-		break;
-
-	case HCI_EV_DISCONN_PHYS_LINK_COMPLETE:
-		hci_disconn_phy_link_complete_evt(hdev, skb);
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
 	case HCI_EV_NUM_COMP_BLOCKS:
 		hci_num_comp_blocks_evt(hdev, skb);
 		break;
 
-	case HCI_EV_CHANNEL_SELECTED:
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
-	case HCI_EV_AMP_STATUS_CHANGE:
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
 	default:
 		BT_DBG("%s event 0x%x", hdev->name, event);
 		break;
@@ -3690,31 +3590,3 @@
 	kfree_skb(skb);
 	hdev->stat.evt_rx++;
 }
-
-/* Generate internal stack event */
-void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)
-{
-	struct hci_event_hdr *hdr;
-	struct hci_ev_stack_internal *ev;
-	struct sk_buff *skb;
-
-	skb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);
-	if (!skb)
-		return;
-
-	hdr = (void *) skb_put(skb, HCI_EVENT_HDR_SIZE);
-	hdr->evt  = HCI_EV_STACK_INTERNAL;
-	hdr->plen = sizeof(*ev) + dlen;
-
-	ev  = (void *) skb_put(skb, sizeof(*ev) + dlen);
-	ev->type = type;
-	memcpy(ev->data, data, dlen);
-
-	bt_cb(skb)->incoming = 1;
-	__net_timestamp(skb);
-
-	bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
-	skb->dev = (void *) hdev;
-	hci_send_to_sock(hdev, skb, NULL);
-	kfree_skb(skb);
-}
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_sock.c flo-ElementalX-5.00-patched/net/bluetooth/hci_sock.c
--- flo-ElementalX-5.00/net/bluetooth/hci_sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2011, The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -42,14 +42,14 @@
 #include <linux/ioctl.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/hci_mon.h>
 
-static bool enable_mgmt = 1;
+static atomic_t monitor_promisc = ATOMIC_INIT(0);
 
 /* ----- HCI socket interface ----- */
 
@@ -85,22 +85,20 @@
 };
 
 /* Send frame to RAW socket */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
-							struct sock *skip_sk)
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct sock *sk;
 	struct hlist_node *node;
+	struct sk_buff *skb_copy = NULL;
 
 	BT_DBG("hdev %p len %d", hdev, skb->len);
 
 	read_lock(&hci_sk_list.lock);
+
 	sk_for_each(sk, node, &hci_sk_list.head) {
 		struct hci_filter *flt;
 		struct sk_buff *nskb;
 
-		if (sk == skip_sk)
-			continue;
-
 		if (sk->sk_state != BT_BOUND || hci_pi(sk)->hdev != hdev)
 			continue;
 
@@ -108,12 +106,9 @@
 		if (skb->sk == sk)
 			continue;
 
-		if (bt_cb(skb)->channel != hci_pi(sk)->channel)
+		if (hci_pi(sk)->channel != HCI_CHANNEL_RAW)
 			continue;
 
-		if (bt_cb(skb)->channel == HCI_CHANNEL_CONTROL)
-			goto clone;
-
 		/* Apply filter */
 		flt = &hci_pi(sk)->filter;
 
@@ -137,125 +132,366 @@
 				continue;
 		}
 
-clone:
+		if (!skb_copy) {
+			/* Create a private copy with headroom */
+			skb_copy = __pskb_copy(skb, 1, GFP_ATOMIC);
+			if (!skb_copy)
+				continue;
+
+			/* Put type byte before the data */
+			memcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);
+		}
+
+		nskb = skb_clone(skb_copy, GFP_ATOMIC);
+		if (!nskb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
+	}
+
+	read_unlock(&hci_sk_list.lock);
+
+	kfree_skb(skb_copy);
+}
+
+/* Send frame to control socket */
+void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk)
+{
+	struct sock *sk;
+	struct hlist_node *node;
+
+	BT_DBG("len %d", skb->len);
+
+	read_lock(&hci_sk_list.lock);
+
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
+
+		/* Skip the original socket */
+		if (sk == skip_sk)
+			continue;
+
+		if (sk->sk_state != BT_BOUND)
+			continue;
+
+		if (hci_pi(sk)->channel != HCI_CHANNEL_CONTROL)
+			continue;
+
 		nskb = skb_clone(skb, GFP_ATOMIC);
 		if (!nskb)
 			continue;
 
-		/* Put type byte before the data */
-		if (bt_cb(skb)->channel == HCI_CHANNEL_RAW)
-			memcpy(skb_push(nskb, 1), &bt_cb(nskb)->pkt_type, 1);
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
+	}
+
+	read_unlock(&hci_sk_list.lock);
+}
+
+/* Send frame to monitor socket */
+void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	struct sock *sk;
+	struct hlist_node *node;
+	struct sk_buff *skb_copy = NULL;
+	__le16 opcode;
+
+	if (!atomic_read(&monitor_promisc))
+		return;
+
+	BT_DBG("hdev %p len %d", hdev, skb->len);
+
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_COMMAND_PKT:
+		opcode = __constant_cpu_to_le16(HCI_MON_COMMAND_PKT);
+		break;
+	case HCI_EVENT_PKT:
+		opcode = __constant_cpu_to_le16(HCI_MON_EVENT_PKT);
+		break;
+	case HCI_ACLDATA_PKT:
+		if (bt_cb(skb)->incoming)
+			opcode = __constant_cpu_to_le16(HCI_MON_ACL_RX_PKT);
+		else
+			opcode = __constant_cpu_to_le16(HCI_MON_ACL_TX_PKT);
+		break;
+	case HCI_SCODATA_PKT:
+		if (bt_cb(skb)->incoming)
+			opcode = __constant_cpu_to_le16(HCI_MON_SCO_RX_PKT);
+		else
+			opcode = __constant_cpu_to_le16(HCI_MON_SCO_TX_PKT);
+		break;
+	default:
+		return;
+	}
+
+	read_lock(&hci_sk_list.lock);
+
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
+
+		if (sk->sk_state != BT_BOUND)
+			continue;
+
+		if (hci_pi(sk)->channel != HCI_CHANNEL_MONITOR)
+			continue;
+
+		if (!skb_copy) {
+			struct hci_mon_hdr *hdr;
+
+			/* Create a private copy with headroom */
+			skb_copy = __pskb_copy(skb, HCI_MON_HDR_SIZE, GFP_ATOMIC);
+			if (!skb_copy)
+				continue;
+
+			/* Put header before the data */
+			hdr = (void *) skb_push(skb_copy, HCI_MON_HDR_SIZE);
+			hdr->opcode = opcode;
+			hdr->index = cpu_to_le16(hdev->id);
+			hdr->len = cpu_to_le16(skb->len);
+		}
+
+		nskb = skb_clone(skb_copy, GFP_ATOMIC);
+		if (!nskb)
+			continue;
 
 		if (sock_queue_rcv_skb(sk, nskb))
 			kfree_skb(nskb);
 	}
+
 	read_unlock(&hci_sk_list.lock);
+
+	kfree_skb(skb_copy);
 }
 
-static int hci_sock_release(struct socket *sock)
+static void send_monitor_event(struct sk_buff *skb)
 {
-	struct sock *sk = sock->sk;
-	struct hci_dev *hdev;
+	struct sock *sk;
+	struct hlist_node *node;
 
-	BT_DBG("sock %p sk %p", sock, sk);
+	BT_DBG("len %d", skb->len);
 
-	if (!sk)
-		return 0;
+	read_lock(&hci_sk_list.lock);
 
-	hdev = hci_pi(sk)->hdev;
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
 
-	bt_sock_unlink(&hci_sk_list, sk);
+		if (sk->sk_state != BT_BOUND)
+			continue;
 
-	if (hdev) {
-		atomic_dec(&hdev->promisc);
-		hci_dev_put(hdev);
+		if (hci_pi(sk)->channel != HCI_CHANNEL_MONITOR)
+			continue;
+
+		nskb = skb_clone(skb, GFP_ATOMIC);
+		if (!nskb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
 	}
 
-	sock_orphan(sk);
+	read_unlock(&hci_sk_list.lock);
+}
 
-	skb_queue_purge(&sk->sk_receive_queue);
-	skb_queue_purge(&sk->sk_write_queue);
+static struct sk_buff *create_monitor_event(struct hci_dev *hdev, int event)
+{
+	struct hci_mon_hdr *hdr;
+	struct hci_mon_new_index *ni;
+	struct sk_buff *skb;
+	__le16 opcode;
 
-	sock_put(sk);
-	return 0;
+	switch (event) {
+	case HCI_DEV_REG:
+		skb = bt_skb_alloc(HCI_MON_NEW_INDEX_SIZE, GFP_ATOMIC);
+		if (!skb)
+			return NULL;
+
+		ni = (void *) skb_put(skb, HCI_MON_NEW_INDEX_SIZE);
+		ni->type = hdev->dev_type;
+		ni->bus = hdev->bus;
+		bacpy(&ni->bdaddr, &hdev->bdaddr);
+		memcpy(ni->name, hdev->name, 8);
+
+		opcode = __constant_cpu_to_le16(HCI_MON_NEW_INDEX);
+		break;
+
+	case HCI_DEV_UNREG:
+		skb = bt_skb_alloc(0, GFP_ATOMIC);
+		if (!skb)
+			return NULL;
+
+		opcode = __constant_cpu_to_le16(HCI_MON_DEL_INDEX);
+		break;
+
+	default:
+		return NULL;
+	}
+
+	__net_timestamp(skb);
+
+	hdr = (void *) skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr->opcode = opcode;
+	hdr->index = cpu_to_le16(hdev->id);
+	hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
+
+	return skb;
 }
 
-struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
+static void send_monitor_replay(struct sock *sk)
 {
-	struct list_head *p;
+	struct hci_dev *hdev;
 
-	list_for_each(p, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	read_lock(&hci_dev_list_lock);
 
-		b = list_entry(p, struct bdaddr_list, list);
+	list_for_each_entry(hdev, &hci_dev_list, list) {
+		struct sk_buff *skb;
 
-		if (bacmp(bdaddr, &b->bdaddr) == 0)
-			return b;
+		skb = create_monitor_event(hdev, HCI_DEV_REG);
+		if (!skb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, skb))
+			kfree_skb(skb);
 	}
 
-	return NULL;
+	read_unlock(&hci_dev_list_lock);
 }
 
-static int hci_blacklist_add(struct hci_dev *hdev, void __user *arg)
+/* Generate internal stack event */
+static void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)
 {
-	bdaddr_t bdaddr;
-	struct bdaddr_list *entry;
+	struct hci_event_hdr *hdr;
+	struct hci_ev_stack_internal *ev;
+	struct sk_buff *skb;
 
-	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
-		return -EFAULT;
+	skb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);
+	if (!skb)
+		return;
 
-	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
-		return -EBADF;
+	hdr = (void *) skb_put(skb, HCI_EVENT_HDR_SIZE);
+	hdr->evt  = HCI_EV_STACK_INTERNAL;
+	hdr->plen = sizeof(*ev) + dlen;
 
-	if (hci_blacklist_lookup(hdev, &bdaddr))
-		return -EEXIST;
+	ev  = (void *) skb_put(skb, sizeof(*ev) + dlen);
+	ev->type = type;
+	memcpy(ev->data, data, dlen);
 
-	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
-	if (!entry)
-		return -ENOMEM;
+	bt_cb(skb)->incoming = 1;
+	__net_timestamp(skb);
+
+	bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
+	skb->dev = (void *) hdev;
+	hci_send_to_sock(hdev, skb);
+	kfree_skb(skb);
+}
 
-	bacpy(&entry->bdaddr, &bdaddr);
+void hci_sock_dev_event(struct hci_dev *hdev, int event)
+{
+	struct hci_ev_si_device ev;
 
-	list_add(&entry->list, &hdev->blacklist);
+	BT_DBG("hdev %s event %d", hdev->name, event);
 
-	return 0;
+	/* Send event to monitor */
+	if (atomic_read(&monitor_promisc)) {
+		struct sk_buff *skb;
+
+		skb = create_monitor_event(hdev, event);
+		if (skb) {
+			send_monitor_event(skb);
+			kfree_skb(skb);
+		}
+	}
+
+	/* Send event to sockets */
+	ev.event  = event;
+	ev.dev_id = hdev->id;
+	hci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);
+
+	if (event == HCI_DEV_UNREG) {
+		struct sock *sk;
+		struct hlist_node *node;
+
+		/* Detach sockets from device */
+		read_lock(&hci_sk_list.lock);
+		sk_for_each(sk, node, &hci_sk_list.head) {
+			bh_lock_sock_nested(sk);
+			if (hci_pi(sk)->hdev == hdev) {
+				hci_pi(sk)->hdev = NULL;
+				sk->sk_err = EPIPE;
+				sk->sk_state = BT_OPEN;
+				sk->sk_state_change(sk);
+
+				hci_dev_put(hdev);
+			}
+			bh_unlock_sock(sk);
+		}
+		read_unlock(&hci_sk_list.lock);
+	}
 }
 
-int hci_blacklist_clear(struct hci_dev *hdev)
+static int hci_sock_release(struct socket *sock)
 {
-	struct list_head *p, *n;
+	struct sock *sk = sock->sk;
+	struct hci_dev *hdev;
 
-	list_for_each_safe(p, n, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	BT_DBG("sock %p sk %p", sock, sk);
 
-		b = list_entry(p, struct bdaddr_list, list);
+	if (!sk)
+		return 0;
+
+	hdev = hci_pi(sk)->hdev;
 
-		list_del(p);
-		kfree(b);
+	if (hci_pi(sk)->channel == HCI_CHANNEL_MONITOR)
+		atomic_dec(&monitor_promisc);
+
+	bt_sock_unlink(&hci_sk_list, sk);
+
+	if (hdev) {
+		atomic_dec(&hdev->promisc);
+		hci_dev_put(hdev);
 	}
 
+	sock_orphan(sk);
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	skb_queue_purge(&sk->sk_write_queue);
+
+	sock_put(sk);
 	return 0;
 }
 
-static int hci_blacklist_del(struct hci_dev *hdev, void __user *arg)
+static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
-	struct bdaddr_list *entry;
+	int err;
 
 	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
 		return -EFAULT;
 
-	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
-		return hci_blacklist_clear(hdev);
+	hci_dev_lock(hdev);
 
-	entry = hci_blacklist_lookup(hdev, &bdaddr);
-	if (!entry)
-		return -ENOENT;
+	err = hci_blacklist_add(hdev, &bdaddr, 0);
 
-	list_del(&entry->list);
-	kfree(entry);
+	hci_dev_unlock(hdev);
 
-	return 0;
+	return err;
+}
+
+static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
+{
+	bdaddr_t bdaddr;
+	int err;
+
+	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
+		return -EFAULT;
+
+	hci_dev_lock(hdev);
+
+	err = hci_blacklist_del(hdev, &bdaddr, 0);
+
+	hci_dev_unlock(hdev);
+
+	return err;
 }
 
 /* Ioctls that require bound socket */
@@ -290,15 +526,12 @@
 	case HCIBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_blacklist_add(hdev, (void __user *) arg);
+		return hci_sock_blacklist_add(hdev, (void __user *) arg);
 
 	case HCIUNBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_blacklist_del(hdev, (void __user *) arg);
-
-	case HCISETAUTHINFO:
-		return hci_set_auth_info(hdev, (void __user *) arg);
+		return hci_sock_blacklist_del(hdev, (void __user *) arg);
 
 	default:
 		if (hdev->ioctl)
@@ -328,12 +561,7 @@
 	case HCIDEVUP:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-
-		err =  hci_dev_open(arg);
-		if (!err || err == -EALREADY)
-			return 0;
-		else
-			return err;
+		return hci_dev_open(arg);
 
 	case HCIDEVDOWN:
 		if (!capable(CAP_NET_ADMIN))
@@ -392,31 +620,69 @@
 	if (haddr.hci_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	if (haddr.hci_channel > HCI_CHANNEL_CONTROL)
-		return -EINVAL;
-
-	if (haddr.hci_channel == HCI_CHANNEL_CONTROL && !enable_mgmt)
-		return -EINVAL;
-
 	lock_sock(sk);
 
-	if (sk->sk_state == BT_BOUND || hci_pi(sk)->hdev) {
+	if (sk->sk_state == BT_BOUND) {
 		err = -EALREADY;
 		goto done;
 	}
 
-	if (haddr.hci_dev != HCI_DEV_NONE) {
-		hdev = hci_dev_get(haddr.hci_dev);
-		if (!hdev) {
-			err = -ENODEV;
+	switch (haddr.hci_channel) {
+	case HCI_CHANNEL_RAW:
+		if (hci_pi(sk)->hdev) {
+			err = -EALREADY;
 			goto done;
 		}
 
-		atomic_inc(&hdev->promisc);
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			hdev = hci_dev_get(haddr.hci_dev);
+			if (!hdev) {
+				err = -ENODEV;
+				goto done;
+			}
+
+			atomic_inc(&hdev->promisc);
+		}
+
+		hci_pi(sk)->hdev = hdev;
+		break;
+
+	case HCI_CHANNEL_CONTROL:
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			err = -EINVAL;
+			goto done;
+		}
+
+		if (!capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			goto done;
+		}
+
+		break;
+
+	case HCI_CHANNEL_MONITOR:
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			err = -EINVAL;
+			goto done;
+		}
+
+		if (!capable(CAP_NET_RAW)) {
+			err = -EPERM;
+			goto done;
+		}
+
+		send_monitor_replay(sk);
+
+		atomic_inc(&monitor_promisc);
+		break;
+
+	default:
+		err = -EINVAL;
+		goto done;
 	}
 
+
 	hci_pi(sk)->channel = haddr.hci_channel;
-	hci_pi(sk)->hdev = hdev;
 	sk->sk_state = BT_BOUND;
 
 done:
@@ -440,6 +706,7 @@
 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
+	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;
@@ -467,7 +734,8 @@
 		data = &tv;
 		len = sizeof(tv);
 #ifdef CONFIG_COMPAT
-		if (msg->msg_flags & MSG_CMSG_COMPAT) {
+		if (!COMPAT_USE_64BIT_TIME &&
+		    (msg->msg_flags & MSG_CMSG_COMPAT)) {
 			ctv.tv_sec = tv.tv_sec;
 			ctv.tv_usec = tv.tv_usec;
 			data = &ctv;
@@ -499,8 +767,6 @@
 	if (!skb)
 		return err;
 
-	msg->msg_namelen = 0;
-
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
@@ -510,7 +776,15 @@
 	skb_reset_transport_header(skb);
 	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 
-	hci_sock_cmsg(sk, msg, skb);
+	switch (hci_pi(sk)->channel) {
+	case HCI_CHANNEL_RAW:
+		hci_sock_cmsg(sk, msg, skb);
+		break;
+	case HCI_CHANNEL_CONTROL:
+	case HCI_CHANNEL_MONITOR:
+		sock_recv_timestamp(msg, sk, skb);
+		break;
+	}
 
 	skb_free_datagram(sk, skb);
 
@@ -523,7 +797,6 @@
 	struct sock *sk = sock->sk;
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
-	int reserve = 0;
 	int err;
 
 	BT_DBG("sock %p sk %p", sock, sk);
@@ -545,6 +818,9 @@
 	case HCI_CHANNEL_CONTROL:
 		err = mgmt_control(sk, msg, len);
 		goto done;
+	case HCI_CHANNEL_MONITOR:
+		err = -EOPNOTSUPP;
+		goto done;
 	default:
 		err = -EINVAL;
 		goto done;
@@ -561,18 +837,10 @@
 		goto done;
 	}
 
-	/* Allocate extra headroom for Qualcomm PAL */
-	if (hdev->dev_type == HCI_AMP && hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
-
-	skb = bt_skb_send_alloc(sk, len + reserve,
-					msg->msg_flags & MSG_DONTWAIT, &err);
+	skb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		goto done;
 
-	if (reserve)
-		skb_reserve(skb, reserve);
-
 	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 		err = -EFAULT;
 		goto drop;
@@ -596,10 +864,10 @@
 
 		if (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {
 			skb_queue_tail(&hdev->raw_q, skb);
-			tasklet_schedule(&hdev->tx_task);
+			queue_work(hdev->workqueue, &hdev->tx_work);
 		} else {
 			skb_queue_tail(&hdev->cmd_q, skb);
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 		}
 	} else {
 		if (!capable(CAP_NET_RAW)) {
@@ -608,7 +876,7 @@
 		}
 
 		skb_queue_tail(&hdev->raw_q, skb);
-		tasklet_schedule(&hdev->tx_task);
+		queue_work(hdev->workqueue, &hdev->tx_work);
 	}
 
 	err = len;
@@ -632,6 +900,11 @@
 
 	lock_sock(sk);
 
+	if (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	switch (optname) {
 	case HCI_DATA_DIR:
 		if (get_user(opt, (int __user *)optval)) {
@@ -694,6 +967,7 @@
 		break;
 	}
 
+done:
 	release_sock(sk);
 	return err;
 }
@@ -702,11 +976,20 @@
 {
 	struct hci_ufilter uf;
 	struct sock *sk = sock->sk;
-	int len, opt;
+	int len, opt, err = 0;
+
+	BT_DBG("sk %p, opt %d", sk, optname);
 
 	if (get_user(len, optlen))
 		return -EFAULT;
 
+	lock_sock(sk);
+
+	if (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	switch (optname) {
 	case HCI_DATA_DIR:
 		if (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)
@@ -715,7 +998,7 @@
 			opt = 0;
 
 		if (put_user(opt, optval))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	case HCI_TIME_STAMP:
@@ -725,13 +1008,14 @@
 			opt = 0;
 
 		if (put_user(opt, optval))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	case HCI_FILTER:
 		{
 			struct hci_filter *f = &hci_pi(sk)->filter;
 
+			memset(&uf, 0, sizeof(uf));
 			uf.type_mask = f->type_mask;
 			uf.opcode    = f->opcode;
 			uf.event_mask[0] = *((u32 *) f->event_mask + 0);
@@ -740,15 +1024,17 @@
 
 		len = min_t(unsigned int, len, sizeof(uf));
 		if (copy_to_user(optval, &uf, len))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	default:
-		return -ENOPROTOOPT;
+		err = -ENOPROTOOPT;
 		break;
 	}
 
-	return 0;
+done:
+	release_sock(sk);
+	return err;
 }
 
 static const struct proto_ops hci_sock_ops = {
@@ -806,54 +1092,12 @@
 	return 0;
 }
 
-static int hci_sock_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
-{
-	struct hci_dev *hdev = (struct hci_dev *) ptr;
-	struct hci_ev_si_device ev;
-
-	BT_DBG("hdev %s event %ld", hdev->name, event);
-
-	/* Send event to sockets */
-	ev.event  = event;
-	ev.dev_id = hdev->id;
-	hci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);
-
-	if (event == HCI_DEV_UNREG) {
-		struct sock *sk;
-		struct hlist_node *node;
-
-		/* Detach sockets from device */
-		read_lock(&hci_sk_list.lock);
-		sk_for_each(sk, node, &hci_sk_list.head) {
-			local_bh_disable();
-			bh_lock_sock_nested(sk);
-			if (hci_pi(sk)->hdev == hdev) {
-				hci_pi(sk)->hdev = NULL;
-				sk->sk_err = EPIPE;
-				sk->sk_state = BT_OPEN;
-				sk->sk_state_change(sk);
-
-				hci_dev_put(hdev);
-			}
-			bh_unlock_sock(sk);
-			local_bh_enable();
-		}
-		read_unlock(&hci_sk_list.lock);
-	}
-
-	return NOTIFY_DONE;
-}
-
 static const struct net_proto_family hci_sock_family_ops = {
 	.family	= PF_BLUETOOTH,
 	.owner	= THIS_MODULE,
 	.create	= hci_sock_create,
 };
 
-static struct notifier_block hci_sock_nblock = {
-	.notifier_call = hci_sock_dev_event
-};
-
 int __init hci_sock_init(void)
 {
 	int err;
@@ -866,8 +1110,6 @@
 	if (err < 0)
 		goto error;
 
-	hci_register_notifier(&hci_sock_nblock);
-
 	BT_INFO("HCI socket layer initialized");
 
 	return 0;
@@ -883,10 +1125,5 @@
 	if (bt_sock_unregister(BTPROTO_HCI) < 0)
 		BT_ERR("HCI socket unregistration failed");
 
-	hci_unregister_notifier(&hci_sock_nblock);
-
 	proto_unregister(&hci_sk_proto);
 }
-
-module_param(enable_mgmt, bool, 0644);
-MODULE_PARM_DESC(enable_mgmt, "Enable Management interface");
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_sysfs.c flo-ElementalX-5.00-patched/net/bluetooth/hci_sysfs.c
--- flo-ElementalX-5.00/net/bluetooth/hci_sysfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_sysfs.c	2016-06-02 00:28:55.000000000 +0000
@@ -5,7 +5,6 @@
 #include <linux/init.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -25,6 +24,8 @@
 		return "SCO";
 	case ESCO_LINK:
 		return "eSCO";
+	case LE_LINK:
+		return "LE";
 	default:
 		return "UNKNOWN";
 	}
@@ -32,19 +33,19 @@
 
 static ssize_t show_link_type(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 	return sprintf(buf, "%s\n", link_typetostr(conn->type));
 }
 
 static ssize_t show_link_address(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 	return sprintf(buf, "%s\n", batostr(&conn->dst));
 }
 
 static ssize_t show_link_features(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 
 	return sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 				conn->features[0], conn->features[1],
@@ -78,8 +79,8 @@
 
 static void bt_link_release(struct device *dev)
 {
-	void *data = dev_get_drvdata(dev);
-	kfree(data);
+	struct hci_conn *conn = to_hci_conn(dev);
+	kfree(conn);
 }
 
 static struct device_type bt_link = {
@@ -88,14 +89,36 @@
 	.release = bt_link_release,
 };
 
-static void add_conn(struct work_struct *work)
+/*
+ * The rfcomm tty device will possibly retain even when conn
+ * is down, and sysfs doesn't support move zombie device,
+ * so we should move the device before conn device is destroyed.
+ */
+static int __match_tty(struct device *dev, void *data)
+{
+	return !strncmp(dev_name(dev), "rfcomm", 6);
+}
+
+void hci_conn_init_sysfs(struct hci_conn *conn)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work_add);
 	struct hci_dev *hdev = conn->hdev;
 
-	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
+	BT_DBG("conn %p", conn);
+
+	conn->dev.type = &bt_link;
+	conn->dev.class = bt_class;
+	conn->dev.parent = &hdev->dev;
+
+	device_initialize(&conn->dev);
+}
+
+void hci_conn_add_sysfs(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p", conn);
 
-	dev_set_drvdata(&conn->dev, conn);
+	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
 
 	if (device_add(&conn->dev) < 0) {
 		BT_ERR("Failed to register connection device");
@@ -105,19 +128,8 @@
 	hci_dev_hold(hdev);
 }
 
-/*
- * The rfcomm tty device will possibly retain even when conn
- * is down, and sysfs doesn't support move zombie device,
- * so we should move the device before conn device is destroyed.
- */
-static int __match_tty(struct device *dev, void *data)
-{
-	return !strncmp(dev_name(dev), "rfcomm", 6);
-}
-
-static void del_conn(struct work_struct *work)
+void hci_conn_del_sysfs(struct hci_conn *conn)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work_del);
 	struct hci_dev *hdev = conn->hdev;
 
 	if (!device_is_registered(&conn->dev))
@@ -139,37 +151,6 @@
 	hci_dev_put(hdev);
 }
 
-void hci_conn_init_sysfs(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p", conn);
-
-	conn->dev.type = &bt_link;
-	conn->dev.class = bt_class;
-	conn->dev.parent = &hdev->dev;
-
-	device_initialize(&conn->dev);
-
-	INIT_WORK(&conn->work_add, add_conn);
-	INIT_WORK(&conn->work_del, del_conn);
-}
-
-void hci_conn_add_sysfs(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-
-	queue_work(conn->hdev->workqueue, &conn->work_add);
-}
-
-void hci_conn_del_sysfs(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-
-	if (conn->hdev)
-		queue_work(conn->hdev->workqueue, &conn->work_del);
-}
-
 static inline char *host_bustostr(int bus)
 {
 	switch (bus) {
@@ -206,19 +187,19 @@
 
 static ssize_t show_bus(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", host_bustostr(hdev->bus));
 }
 
 static ssize_t show_type(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", host_typetostr(hdev->dev_type));
 }
 
 static ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	char name[HCI_MAX_NAME_LENGTH + 1];
 	int i;
 
@@ -231,20 +212,20 @@
 
 static ssize_t show_class(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "0x%.2x%.2x%.2x\n",
 			hdev->dev_class[2], hdev->dev_class[1], hdev->dev_class[0]);
 }
 
 static ssize_t show_address(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", batostr(&hdev->bdaddr));
 }
 
 static ssize_t show_features(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 
 	return sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 				hdev->features[0], hdev->features[1],
@@ -255,31 +236,31 @@
 
 static ssize_t show_manufacturer(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->manufacturer);
 }
 
 static ssize_t show_hci_version(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->hci_ver);
 }
 
 static ssize_t show_hci_revision(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->hci_rev);
 }
 
 static ssize_t show_idle_timeout(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->idle_timeout);
 }
 
 static ssize_t store_idle_timeout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	unsigned int val;
 	int rv;
 
@@ -297,13 +278,13 @@
 
 static ssize_t show_sniff_max_interval(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->sniff_max_interval);
 }
 
 static ssize_t store_sniff_max_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	u16 val;
 	int rv;
 
@@ -321,13 +302,13 @@
 
 static ssize_t show_sniff_min_interval(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->sniff_min_interval);
 }
 
 static ssize_t store_sniff_min_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	u16 val;
 	int rv;
 
@@ -387,8 +368,9 @@
 
 static void bt_host_release(struct device *dev)
 {
-	void *data = dev_get_drvdata(dev);
-	kfree(data);
+	struct hci_dev *hdev = to_hci_dev(dev);
+	kfree(hdev);
+	module_put(THIS_MODULE);
 }
 
 static struct device_type bt_host = {
@@ -400,12 +382,12 @@
 static int inquiry_cache_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *e;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	for (e = cache->list; e; e = e->next) {
+	list_for_each_entry(e, &cache->all, all) {
 		struct inquiry_data *data = &e->data;
 		seq_printf(f, "%s %d %d %d 0x%.2x%.2x%.2x 0x%.4x %d %d %u\n",
 			   batostr(&data->bdaddr),
@@ -416,7 +398,7 @@
 			   data->rssi, data->ssp_mode, e->timestamp);
 	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -436,19 +418,14 @@
 static int blacklist_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct list_head *l;
-
-	hci_dev_lock_bh(hdev);
-
-	list_for_each(l, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	struct bdaddr_list *b;
 
-		b = list_entry(l, struct bdaddr_list, list);
+	hci_dev_lock(hdev);
 
+	list_for_each_entry(b, &hdev->blacklist, list)
 		seq_printf(f, "%s\n", batostr(&b->bdaddr));
-	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -485,19 +462,14 @@
 static int uuids_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct list_head *l;
-
-	hci_dev_lock_bh(hdev);
-
-	list_for_each(l, &hdev->uuids) {
-		struct bt_uuid *uuid;
+	struct bt_uuid *uuid;
 
-		uuid = list_entry(l, struct bt_uuid, list);
+	hci_dev_lock(hdev);
 
+	list_for_each_entry(uuid, &hdev->uuids, list)
 		print_bt_uuid(f, uuid->uuid);
-	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -514,22 +486,57 @@
 	.release	= single_release,
 };
 
-int hci_register_sysfs(struct hci_dev *hdev)
+static int auto_accept_delay_set(void *data, u64 val)
+{
+	struct hci_dev *hdev = data;
+
+	hci_dev_lock(hdev);
+
+	hdev->auto_accept_delay = val;
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+static int auto_accept_delay_get(void *data, u64 *val)
+{
+	struct hci_dev *hdev = data;
+
+	hci_dev_lock(hdev);
+
+	*val = hdev->auto_accept_delay;
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(auto_accept_delay_fops, auto_accept_delay_get,
+					auto_accept_delay_set, "%llu\n");
+
+void hci_init_sysfs(struct hci_dev *hdev)
+{
+	struct device *dev = &hdev->dev;
+
+	dev->type = &bt_host;
+	dev->class = bt_class;
+
+	__module_get(THIS_MODULE);
+	device_initialize(dev);
+}
+
+int hci_add_sysfs(struct hci_dev *hdev)
 {
 	struct device *dev = &hdev->dev;
 	int err;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	dev->type = &bt_host;
-	dev->class = bt_class;
 	dev->parent = hdev->parent;
-
 	dev_set_name(dev, "%s", hdev->name);
 
-	dev_set_drvdata(dev, hdev);
-
-	err = device_register(dev);
+	err = device_add(dev);
 	if (err < 0)
 		return err;
 
@@ -548,10 +555,12 @@
 
 	debugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);
 
+	debugfs_create_file("auto_accept_delay", 0444, hdev->debugfs, hdev,
+						&auto_accept_delay_fops);
 	return 0;
 }
 
-void hci_unregister_sysfs(struct hci_dev *hdev)
+void hci_del_sysfs(struct hci_dev *hdev)
 {
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/core.c flo-ElementalX-5.00-patched/net/bluetooth/hidp/core.c
--- flo-ElementalX-5.00/net/bluetooth/hidp/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    HIDP implementation for Linux Bluetooth stack (BlueZ).
    Copyright (C) 2003-2004 Marcel Holtmann <marcel@holtmann.org>
-   Copyright (c) 2012 The Linux Foundation.  All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -22,7 +21,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -38,6 +36,8 @@
 #include <linux/file.h>
 #include <linux/init.h>
 #include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/kthread.h>
 #include <net/sock.h>
 
 #include <linux/input.h>
@@ -81,31 +81,27 @@
 static struct hidp_session *__hidp_get_session(bdaddr_t *bdaddr)
 {
 	struct hidp_session *session;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &hidp_session_list) {
-		session = list_entry(p, struct hidp_session, list);
+	list_for_each_entry(session, &hidp_session_list, list) {
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
 	}
+
 	return NULL;
 }
 
 static void __hidp_link_session(struct hidp_session *session)
 {
-	__module_get(THIS_MODULE);
 	list_add(&session->list, &hidp_session_list);
 }
 
 static void __hidp_unlink_session(struct hidp_session *session)
 {
-	if (session->conn)
-		hci_conn_put_device(session->conn);
+	hci_conn_put_device(session->conn);
 
 	list_del(&session->list);
-	module_put(THIS_MODULE);
 }
 
 static void __hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)
@@ -254,6 +250,9 @@
 
 	BT_DBG("session %p data %p size %d", session, data, size);
 
+	if (atomic_read(&session->terminate))
+		return -EIO;
+
 	skb = alloc_skb(size + 1, GFP_ATOMIC);
 	if (!skb) {
 		BT_ERR("Can't allocate memory for new frame");
@@ -319,24 +318,143 @@
 	return hidp_queue_report(session, buf, rsize);
 }
 
+static int hidp_get_raw_report(struct hid_device *hid,
+		unsigned char report_number,
+		unsigned char *data, size_t count,
+		unsigned char report_type)
+{
+	struct hidp_session *session = hid->driver_data;
+	struct sk_buff *skb;
+	size_t len;
+	int numbered_reports = hid->report_enum[report_type].numbered;
+	int ret;
+
+	switch (report_type) {
+	case HID_FEATURE_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_FEATURE;
+		break;
+	case HID_INPUT_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_INPUT;
+		break;
+	case HID_OUTPUT_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_OUPUT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (mutex_lock_interruptible(&session->report_mutex))
+		return -ERESTARTSYS;
+
+	/* Set up our wait, and send the report request to the device. */
+	session->waiting_report_type = report_type & HIDP_DATA_RTYPE_MASK;
+	session->waiting_report_number = numbered_reports ? report_number : -1;
+	set_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	data[0] = report_number;
+	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data, 1);
+	if (ret)
+		goto err;
+
+	/* Wait for the return of the report. The returned report
+	   gets put in session->report_return.  */
+	while (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags)) {
+		int res;
+
+		res = wait_event_interruptible_timeout(session->report_queue,
+			!test_bit(HIDP_WAITING_FOR_RETURN, &session->flags),
+			5*HZ);
+		if (res == 0) {
+			/* timeout */
+			ret = -EIO;
+			goto err;
+		}
+		if (res < 0) {
+			/* signal */
+			ret = -ERESTARTSYS;
+			goto err;
+		}
+	}
+
+	skb = session->report_return;
+	if (skb) {
+		len = skb->len < count ? skb->len : count;
+		memcpy(data, skb->data, len);
+
+		kfree_skb(skb);
+		session->report_return = NULL;
+	} else {
+		/* Device returned a HANDSHAKE, indicating  protocol error. */
+		len = -EIO;
+	}
+
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	mutex_unlock(&session->report_mutex);
+
+	return len;
+
+err:
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	mutex_unlock(&session->report_mutex);
+	return ret;
+}
+
 static int hidp_output_raw_report(struct hid_device *hid, unsigned char *data, size_t count,
 		unsigned char report_type)
 {
+	struct hidp_session *session = hid->driver_data;
+	int ret;
+
 	switch (report_type) {
 	case HID_FEATURE_REPORT:
 		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_FEATURE;
 		break;
 	case HID_OUTPUT_REPORT:
-		report_type = HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT;
+		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_OUPUT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (hidp_send_ctrl_message(hid->driver_data, report_type,
-			data, count))
-		return -ENOMEM;
-	return count;
+	if (mutex_lock_interruptible(&session->report_mutex))
+		return -ERESTARTSYS;
+
+	/* Set up our wait, and send the report request to the device. */
+	set_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data,
+									count);
+	if (ret)
+		goto err;
+
+	/* Wait for the ACK from the device. */
+	while (test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags)) {
+		int res;
+
+		res = wait_event_interruptible_timeout(session->report_queue,
+			!test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags),
+			10*HZ);
+		if (res == 0) {
+			/* timeout */
+			ret = -EIO;
+			goto err;
+		}
+		if (res < 0) {
+			/* signal */
+			ret = -ERESTARTSYS;
+			goto err;
+		}
+	}
+
+	if (!session->output_report_success) {
+		ret = -EIO;
+		goto err;
+	}
+
+	ret = count;
+
+err:
+	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	mutex_unlock(&session->report_mutex);
+	return ret;
 }
 
 static void hidp_idle_timeout(unsigned long arg)
@@ -344,7 +462,7 @@
 	struct hidp_session *session = (struct hidp_session *) arg;
 
 	atomic_inc(&session->terminate);
-	hidp_schedule(session);
+	wake_up_process(session->task);
 }
 
 static void hidp_set_timer(struct hidp_session *session)
@@ -363,16 +481,21 @@
 					unsigned char param)
 {
 	BT_DBG("session %p param 0x%02x", session, param);
+	session->output_report_success = 0; /* default condition */
 
 	switch (param) {
 	case HIDP_HSHK_SUCCESSFUL:
 		/* FIXME: Call into SET_ GET_ handlers here */
+		session->output_report_success = 1;
 		break;
 
 	case HIDP_HSHK_NOT_READY:
 	case HIDP_HSHK_ERR_INVALID_REPORT_ID:
 	case HIDP_HSHK_ERR_UNSUPPORTED_REQUEST:
 	case HIDP_HSHK_ERR_INVALID_PARAMETER:
+		if (test_and_clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags))
+			wake_up_interruptible(&session->report_queue);
+
 		/* FIXME: Call into SET_ GET_ handlers here */
 		break;
 
@@ -391,6 +514,10 @@
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 		break;
 	}
+
+	/* Wake up the waiting thread. */
+	if (test_and_clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags))
+		wake_up_interruptible(&session->report_queue);
 }
 
 static void hidp_process_hid_control(struct hidp_session *session,
@@ -403,15 +530,16 @@
 		skb_queue_purge(&session->ctrl_transmit);
 		skb_queue_purge(&session->intr_transmit);
 
-		/* Kill session thread */
 		atomic_inc(&session->terminate);
-		hidp_schedule(session);
+		wake_up_process(current);
 	}
 }
 
-static void hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
+/* Returns true if the passed-in skb should be freed by the caller. */
+static int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
 				unsigned char param)
 {
+	int done_with_skb = 1;
 	BT_DBG("session %p skb %p len %d param 0x%02x", session, skb, skb->len, param);
 
 	switch (param) {
@@ -423,7 +551,6 @@
 
 		if (session->hid)
 			hid_input_report(session->hid, HID_INPUT_REPORT, skb->data, skb->len, 0);
-
 		break;
 
 	case HIDP_DATA_RTYPE_OTHER:
@@ -435,12 +562,27 @@
 		__hidp_send_ctrl_message(session,
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 	}
+
+	if (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags) &&
+				param == session->waiting_report_type) {
+		if (session->waiting_report_number < 0 ||
+		    session->waiting_report_number == skb->data[0]) {
+			/* hidp_get_raw_report() is waiting on this report. */
+			session->report_return = skb;
+			done_with_skb = 0;
+			clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+			wake_up_interruptible(&session->report_queue);
+		}
+	}
+
+	return done_with_skb;
 }
 
 static void hidp_recv_ctrl_frame(struct hidp_session *session,
 					struct sk_buff *skb)
 {
 	unsigned char hdr, type, param;
+	int free_skb = 1;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
 
@@ -460,7 +602,7 @@
 		break;
 
 	case HIDP_TRANS_DATA:
-		hidp_process_data(session, skb, param);
+		free_skb = hidp_process_data(session, skb, param);
 		break;
 
 	default:
@@ -469,7 +611,8 @@
 		break;
 	}
 
-	kfree_skb(skb);
+	if (free_skb)
+		kfree_skb(skb);
 }
 
 static void hidp_recv_intr_frame(struct hidp_session *session,
@@ -514,25 +657,32 @@
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
 
-static void hidp_process_transmit(struct hidp_session *session)
+static void hidp_process_intr_transmit(struct hidp_session *session)
 {
 	struct sk_buff *skb;
 
 	BT_DBG("session %p", session);
 
-	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
-		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->ctrl_transmit, skb);
+	while ((skb = skb_dequeue(&session->intr_transmit))) {
+		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->intr_transmit, skb);
 			break;
 		}
 
 		hidp_set_timer(session);
 		kfree_skb(skb);
 	}
+}
 
-	while ((skb = skb_dequeue(&session->intr_transmit))) {
-		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->intr_transmit, skb);
+static void hidp_process_ctrl_transmit(struct hidp_session *session)
+{
+	struct sk_buff *skb;
+
+	BT_DBG("session %p", session);
+
+	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
+		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->ctrl_transmit, skb);
 			break;
 		}
 
@@ -547,59 +697,56 @@
 	struct sock *ctrl_sk = session->ctrl_sock->sk;
 	struct sock *intr_sk = session->intr_sock->sk;
 	struct sk_buff *skb;
-	int vendor = 0x0000, product = 0x0000;
 	wait_queue_t ctrl_wait, intr_wait;
 
 	BT_DBG("session %p", session);
 
-	if (session->input) {
-		vendor  = session->input->id.vendor;
-		product = session->input->id.product;
-	}
-
-	if (session->hid) {
-		vendor  = session->hid->vendor;
-		product = session->hid->product;
-	}
-
-	daemonize("khidpd_%04x%04x", vendor, product);
+	__module_get(THIS_MODULE);
 	set_user_nice(current, -15);
 
 	init_waitqueue_entry(&ctrl_wait, current);
 	init_waitqueue_entry(&intr_wait, current);
 	add_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 	add_wait_queue(sk_sleep(intr_sk), &intr_wait);
+	session->waiting_for_startup = 0;
+	wake_up_interruptible(&session->startup_queue);
+	set_current_state(TASK_INTERRUPTIBLE);
 	while (!atomic_read(&session->terminate)) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
 		if (ctrl_sk->sk_state != BT_CONNECTED ||
 				intr_sk->sk_state != BT_CONNECTED)
 			break;
 
-		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
+		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_ctrl_frame(session, skb);
+				hidp_recv_intr_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
+		hidp_process_intr_transmit(session);
+
+		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_intr_frame(session, skb);
+				hidp_recv_ctrl_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		hidp_process_transmit(session);
+		hidp_process_ctrl_transmit(session);
 
 		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(intr_sk), &intr_wait);
 	remove_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 
+	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	wake_up_interruptible(&session->report_queue);
+
 	down_write(&hidp_session_sem);
 
 	hidp_del_timer(session);
@@ -631,7 +778,9 @@
 
 	up_write(&hidp_session_sem);
 
+	kfree(session->rd_data);
 	kfree(session);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -646,11 +795,11 @@
 	if (!hdev)
 		return NULL;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (conn)
 		hci_conn_hold_device(conn);
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	hci_dev_put(hdev);
 
@@ -661,7 +810,7 @@
 				struct hidp_connadd_req *req)
 {
 	struct input_dev *input;
-	int err, i;
+	int i;
 
 	input = input_allocate_device();
 	if (!input)
@@ -708,12 +857,6 @@
 
 	input->event = hidp_input_event;
 
-	err = input_register_device(input);
-	if (err < 0) {
-		hci_conn_put_device(session->conn);
-		return err;
-	}
-
 	return 0;
 }
 
@@ -739,6 +882,9 @@
 	struct hidp_session *session = hid->driver_data;
 	struct hid_report *report;
 
+	if (hid->quirks & HID_QUIRK_NO_INIT_REPORTS)
+		return 0;
+
 	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].
 			report_list, list)
 		hidp_send_report(session, report);
@@ -769,6 +915,8 @@
 	.hidinput_input_event = hidp_hidinput_event,
 };
 
+/* This function sets up the hid device. It does not add it
+   to the HID system. That is done in hidp_add_connection(). */
 static int hidp_setup_hid(struct hidp_session *session,
 				struct hidp_connadd_req *req)
 {
@@ -801,25 +949,18 @@
 	hid->version = req->version;
 	hid->country = req->country;
 
-	strncpy(hid->name, req->name, 128);
+	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 	strncpy(hid->phys, batostr(&bt_sk(session->ctrl_sock->sk)->src), 64);
 	strncpy(hid->uniq, batostr(&bt_sk(session->ctrl_sock->sk)->dst), 64);
 
 	hid->dev.parent = &session->conn->dev;
 	hid->ll_driver = &hidp_hid_driver;
 
+	hid->hid_get_raw_report = hidp_get_raw_report;
 	hid->hid_output_raw_report = hidp_output_raw_report;
 
-	err = hid_add_device(hid);
-	if (err < 0)
-		goto failed;
-
 	return 0;
 
-failed:
-	hid_destroy_device(hid);
-	session->hid = NULL;
-
 fault:
 	kfree(session->rd_data);
 	session->rd_data = NULL;
@@ -830,6 +971,7 @@
 int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock, struct socket *intr_sock)
 {
 	struct hidp_session *session, *s;
+	int vendor, product;
 	int err;
 
 	BT_DBG("");
@@ -838,24 +980,28 @@
 			bacmp(&bt_sk(ctrl_sock->sk)->dst, &bt_sk(intr_sock->sk)->dst))
 		return -ENOTUNIQ;
 
-	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
-	if (!session)
-		return -ENOMEM;
-
 	BT_DBG("rd_data %p rd_size %d", req->rd_data, req->rd_size);
 
 	down_write(&hidp_session_sem);
 
 	s = __hidp_get_session(&bt_sk(ctrl_sock->sk)->dst);
 	if (s && s->state == BT_CONNECTED) {
-		err = -EEXIST;
-		goto failed;
+		up_write(&hidp_session_sem);
+		return -EEXIST;
+	}
+
+	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
+	if (!session) {
+		up_write(&hidp_session_sem);
+		return -ENOMEM;
 	}
 
 	bacpy(&session->bdaddr, &bt_sk(ctrl_sock->sk)->dst);
 
-	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->omtu, l2cap_pi(ctrl_sock->sk)->imtu);
-	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->omtu, l2cap_pi(intr_sock->sk)->imtu);
+	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->chan->omtu,
+					l2cap_pi(ctrl_sock->sk)->chan->imtu);
+	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->chan->omtu,
+					l2cap_pi(intr_sock->sk)->chan->imtu);
 
 	BT_DBG("ctrl mtu %d intr mtu %d", session->ctrl_mtu, session->intr_mtu);
 
@@ -874,6 +1020,10 @@
 	skb_queue_head_init(&session->ctrl_transmit);
 	skb_queue_head_init(&session->intr_transmit);
 
+	mutex_init(&session->report_mutex);
+	init_waitqueue_head(&session->report_queue);
+	init_waitqueue_head(&session->startup_queue);
+	session->waiting_for_startup = 1;
 	session->flags   = req->flags & (1 << HIDP_BLUETOOTH_VENDOR_ID);
 	session->idle_to = req->idle_to;
 
@@ -881,7 +1031,7 @@
 
 	if (req->rd_size > 0) {
 		err = hidp_setup_hid(session, req);
-		if (err && err != -ENODEV)
+		if (err)
 			goto purge;
 	}
 
@@ -893,9 +1043,40 @@
 
 	hidp_set_timer(session);
 
-	err = kernel_thread(hidp_session, session, CLONE_KERNEL);
-	if (err < 0)
+	if (session->hid) {
+		vendor  = session->hid->vendor;
+		product = session->hid->product;
+	} else if (session->input) {
+		vendor  = session->input->id.vendor;
+		product = session->input->id.product;
+	} else {
+		vendor = 0x0000;
+		product = 0x0000;
+	}
+
+	session->task = kthread_run(hidp_session, session, "khidpd_%04x%04x",
+							vendor, product);
+	if (IS_ERR(session->task)) {
+		err = PTR_ERR(session->task);
 		goto unlink;
+	}
+
+	while (session->waiting_for_startup) {
+		wait_event_interruptible(session->startup_queue,
+			!session->waiting_for_startup);
+	}
+
+	if (session->hid)
+		err = hid_add_device(session->hid);
+	else
+		err = input_register_device(session->input);
+
+	if (err < 0) {
+		atomic_inc(&session->terminate);
+		wake_up_process(session->task);
+		up_write(&hidp_session_sem);
+		return err;
+	}
 
 	if (session->input) {
 		hidp_send_ctrl_message(session,
@@ -934,7 +1115,6 @@
 failed:
 	up_write(&hidp_session_sem);
 
-	input_free_device(session->input);
 	kfree(session);
 	return err;
 }
@@ -958,13 +1138,8 @@
 			skb_queue_purge(&session->ctrl_transmit);
 			skb_queue_purge(&session->intr_transmit);
 
-			/* Wakeup user-space polling for socket errors */
-			session->intr_sock->sk->sk_err = EUNATCH;
-			session->ctrl_sock->sk->sk_err = EUNATCH;
-
-			/* Kill session thread */
 			atomic_inc(&session->terminate);
-			hidp_schedule(session);
+			wake_up_process(session->task);
 		}
 	} else
 		err = -ENOENT;
@@ -975,19 +1150,16 @@
 
 int hidp_get_connlist(struct hidp_connlist_req *req)
 {
-	struct list_head *p;
+	struct hidp_session *session;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&hidp_session_sem);
 
-	list_for_each(p, &hidp_session_list) {
-		struct hidp_session *session;
+	list_for_each_entry(session, &hidp_session_list, list) {
 		struct hidp_conninfo ci;
 
-		session = list_entry(p, struct hidp_session, list);
-
 		__hidp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/hidp.h flo-ElementalX-5.00-patched/net/bluetooth/hidp/hidp.h
--- flo-ElementalX-5.00/net/bluetooth/hidp/hidp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/hidp.h	2016-06-02 00:28:55.000000000 +0000
@@ -80,6 +80,8 @@
 #define HIDP_VIRTUAL_CABLE_UNPLUG	0
 #define HIDP_BOOT_PROTOCOL_MODE		1
 #define HIDP_BLUETOOTH_VENDOR_ID	9
+#define HIDP_WAITING_FOR_RETURN		10
+#define HIDP_WAITING_FOR_SEND_ACK	11
 
 struct hidp_connadd_req {
 	int   ctrl_sock;	/* Connected control socket */
@@ -141,6 +143,7 @@
 	uint intr_mtu;
 
 	atomic_t terminate;
+	struct task_struct *task;
 
 	unsigned char keys[8];
 	unsigned char leds;
@@ -154,9 +157,22 @@
 	struct sk_buff_head ctrl_transmit;
 	struct sk_buff_head intr_transmit;
 
+	/* Used in hidp_get_raw_report() */
+	int waiting_report_type; /* HIDP_DATA_RTYPE_* */
+	int waiting_report_number; /* -1 for not numbered */
+	struct mutex report_mutex;
+	struct sk_buff *report_return;
+	wait_queue_head_t report_queue;
+
+	/* Used in hidp_output_raw_report() */
+	int output_report_success; /* boolean */
+
 	/* Report descriptor */
 	__u8 *rd_data;
 	uint rd_size;
+
+	wait_queue_head_t startup_queue;
+	int waiting_for_startup;
 };
 
 static inline void hidp_schedule(struct hidp_session *session)
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/sock.c flo-ElementalX-5.00-patched/net/bluetooth/hidp/sock.c
--- flo-ElementalX-5.00/net/bluetooth/hidp/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -160,10 +160,10 @@
 {
 	if (cmd == HIDPGETCONNLIST) {
 		struct hidp_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -174,7 +174,7 @@
 
 		err = hidp_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/l2cap_core.c flo-ElementalX-5.00-patched/net/bluetooth/l2cap_core.c
--- flo-ElementalX-5.00/net/bluetooth/l2cap_core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/l2cap_core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,8 +1,9 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -46,544 +47,340 @@
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/crc16.h>
-#include <linux/math64.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
-#include <net/bluetooth/amp.h>
 
 bool disable_ertm;
-bool enable_hs;
-bool enable_reconfig;
 
 static u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;
-static u8 l2cap_fc_mask = L2CAP_FC_L2CAP;
+static u8 l2cap_fixed_chan[8] = { L2CAP_FC_L2CAP, };
 
-struct workqueue_struct *_l2cap_wq;
-
-struct bt_sock_list l2cap_sk_list = {
-	.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)
-};
-
-static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id);
-static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u16 result);
-static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
-			u16 icid, u16 result);
-
-static void l2cap_amp_move_setup(struct sock *sk);
-static void l2cap_amp_move_success(struct sock *sk);
-static void l2cap_amp_move_revert(struct sock *sk);
-
-static int l2cap_ertm_rx_queued_iframes(struct sock *sk);
+static LIST_HEAD(chan_list);
+static DEFINE_RWLOCK(chan_list_lock);
 
 static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
 				u8 code, u8 ident, u16 dlen, void *data);
-static int l2cap_answer_move_poll(struct sock *sk);
-static int l2cap_create_cfm(struct hci_chan *chan, u8 status);
-static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi);
-static void l2cap_chan_ready(struct sock *sk);
-static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process);
-static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l);
-static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to);
-static void l2cap_queue_acl_data(struct work_struct *worker);
-static struct att_channel_parameters{
-	struct sk_buff *skb;
-	struct l2cap_conn *conn;
-	__le16 cid;
-	int dir;
-} att_chn_params;
+static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
+								void *data);
+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);
+static void l2cap_send_disconn_req(struct l2cap_conn *conn,
+				struct l2cap_chan *chan, int err);
 
 /* ---- L2CAP channels ---- */
-static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)
+
+static struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->dcid == cid)
-			break;
+	struct l2cap_chan *c;
+
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->dcid == cid)
+			return c;
 	}
-	return s;
+	return NULL;
 }
 
-/* Find channel with given DCID.
- * Returns locked socket */
-static inline struct sock *l2cap_get_chan_by_dcid(struct l2cap_chan_list *l,
-						u16 cid)
+static struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_dcid(l, cid);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
+	struct l2cap_chan *c;
 
-static struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->scid == cid)
-			break;
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->scid == cid)
+			return c;
 	}
-	return s;
+	return NULL;
 }
 
 /* Find channel with given SCID.
  * Returns locked socket */
-static inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
+static struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_scid(l, cid);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
+	struct l2cap_chan *c;
 
-static struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->ident == ident)
-			break;
-	}
-	return s;
-}
+	mutex_lock(&conn->chan_lock);
+	c = __l2cap_get_chan_by_scid(conn, cid);
+	mutex_unlock(&conn->chan_lock);
 
-static inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_ident(l, ident);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
+	return c;
 }
 
-static inline struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,
-						u16 seq)
+static struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
 {
-	struct sk_buff *skb;
+	struct l2cap_chan *c;
 
-	skb_queue_walk(head, skb) {
-		if (bt_cb(skb)->control.txseq == seq)
-			return skb;
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->ident == ident)
+			return c;
 	}
-
 	return NULL;
 }
 
-static int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)
+static inline struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
 {
-	u16 allocSize = 1;
-	int err = 0;
-	int i;
+	struct l2cap_chan *c;
 
-	/* Actual allocated size must be a power of 2 */
-	while (allocSize && allocSize <= size)
-		allocSize <<= 1;
-	if (!allocSize)
-		return -ENOMEM;
-
-	seq_list->list = kzalloc(sizeof(u16) * allocSize, GFP_ATOMIC);
-	if (!seq_list->list)
-		return -ENOMEM;
-
-	seq_list->size = allocSize;
-	seq_list->mask = allocSize - 1;
-	seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-	seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-	for (i = 0; i < allocSize; i++)
-		seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
+	mutex_lock(&conn->chan_lock);
+	c = __l2cap_get_chan_by_ident(conn, ident);
+	mutex_unlock(&conn->chan_lock);
 
-	return err;
+	return c;
 }
 
-static inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)
+static struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src)
 {
-	kfree(seq_list->list);
-}
+	struct l2cap_chan *c;
 
-static inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,
-					u16 seq)
-{
-	return seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;
+	list_for_each_entry(c, &chan_list, global_l) {
+		if (c->sport == psm && !bacmp(&bt_sk(c->sk)->src, src))
+			return c;
+	}
+	return NULL;
 }
 
-static u16 l2cap_seq_list_remove(struct l2cap_seq_list *seq_list, u16 seq)
+int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)
 {
-	u16 mask = seq_list->mask;
+	int err;
 
-	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
+	write_lock(&chan_list_lock);
 
-	if (seq_list->head == L2CAP_SEQ_LIST_CLEAR) {
-		/* In case someone tries to pop the head of an empty list */
-		BT_DBG("List empty");
-		return L2CAP_SEQ_LIST_CLEAR;
-	} else if (seq_list->head == seq) {
-		/* Head can be removed quickly */
-		BT_DBG("Remove head");
-		seq_list->head = seq_list->list[seq & mask];
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
+	if (psm && __l2cap_global_chan_by_addr(psm, src)) {
+		err = -EADDRINUSE;
+		goto done;
+	}
 
-		if (seq_list->head == L2CAP_SEQ_LIST_TAIL) {
-			seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-			seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-		}
+	if (psm) {
+		chan->psm = psm;
+		chan->sport = psm;
+		err = 0;
 	} else {
-		/* Non-head item must be found first */
-		u16 prev = seq_list->head;
-		BT_DBG("Find and remove");
-		while (seq_list->list[prev & mask] != seq) {
-			prev = seq_list->list[prev & mask];
-			if (prev == L2CAP_SEQ_LIST_TAIL) {
-				BT_DBG("seq %d not in list", (int) seq);
-				return L2CAP_SEQ_LIST_CLEAR;
-			}
-		}
+		u16 p;
 
-		seq_list->list[prev & mask] = seq_list->list[seq & mask];
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
-		if (seq_list->tail == seq)
-			seq_list->tail = prev;
+		err = -EINVAL;
+		for (p = 0x1001; p < 0x1100; p += 2)
+			if (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src)) {
+				chan->psm   = cpu_to_le16(p);
+				chan->sport = cpu_to_le16(p);
+				err = 0;
+				break;
+			}
 	}
-	return seq;
-}
-
-static inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)
-{
-	return l2cap_seq_list_remove(seq_list, seq_list->head);
-}
-
-static void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)
-{
-	if (seq_list->head != L2CAP_SEQ_LIST_CLEAR) {
-		u16 i;
-		for (i = 0; i < seq_list->size; i++)
-			seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
 
-		seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-		seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-	}
+done:
+	write_unlock(&chan_list_lock);
+	return err;
 }
 
-static void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)
+int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)
 {
-	u16 mask = seq_list->mask;
+	write_lock(&chan_list_lock);
 
-	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
+	chan->scid = scid;
 
-	if (seq_list->list[seq & mask] == L2CAP_SEQ_LIST_CLEAR) {
-		if (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)
-			seq_list->head = seq;
-		else
-			seq_list->list[seq_list->tail & mask] = seq;
+	write_unlock(&chan_list_lock);
 
-		seq_list->tail = seq;
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;
-	}
+	return 0;
 }
 
-static u16 __pack_enhanced_control(struct bt_l2cap_control *control)
+static u16 l2cap_alloc_cid(struct l2cap_conn *conn)
 {
-	u16 packed;
-
-	packed = (control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT) &
-		L2CAP_CTRL_REQSEQ;
-	packed |= (control->final << L2CAP_CTRL_FINAL_SHIFT) &
-		L2CAP_CTRL_FINAL;
+	u16 cid = L2CAP_CID_DYN_START;
 
-	if (control->frame_type == 's') {
-		packed |= (control->poll << L2CAP_CTRL_POLL_SHIFT) &
-			L2CAP_CTRL_POLL;
-		packed |= (control->super << L2CAP_CTRL_SUPERVISE_SHIFT) &
-			L2CAP_CTRL_SUPERVISE;
-		packed |= L2CAP_CTRL_FRAME_TYPE;
-	} else {
-		packed |= (control->sar << L2CAP_CTRL_SAR_SHIFT) &
-			L2CAP_CTRL_SAR;
-		packed |= (control->txseq << L2CAP_CTRL_TXSEQ_SHIFT) &
-			L2CAP_CTRL_TXSEQ;
+	for (; cid < L2CAP_CID_DYN_END; cid++) {
+		if (!__l2cap_get_chan_by_scid(conn, cid))
+			return cid;
 	}
 
-	return packed;
+	return 0;
 }
 
-static void __get_enhanced_control(u16 enhanced,
-					struct bt_l2cap_control *control)
+static void __l2cap_state_change(struct l2cap_chan *chan, int state)
 {
-	control->reqseq = (enhanced & L2CAP_CTRL_REQSEQ) >>
-		L2CAP_CTRL_REQSEQ_SHIFT;
-	control->final = (enhanced & L2CAP_CTRL_FINAL) >>
-		L2CAP_CTRL_FINAL_SHIFT;
+	BT_DBG("chan %p %s -> %s", chan, state_to_string(chan->state),
+						state_to_string(state));
 
-	if (enhanced & L2CAP_CTRL_FRAME_TYPE) {
-		control->frame_type = 's';
-		control->poll = (enhanced & L2CAP_CTRL_POLL) >>
-			L2CAP_CTRL_POLL_SHIFT;
-		control->super = (enhanced & L2CAP_CTRL_SUPERVISE) >>
-			L2CAP_CTRL_SUPERVISE_SHIFT;
-
-		control->sar = 0;
-		control->txseq = 0;
-	} else {
-		control->frame_type = 'i';
-		control->sar = (enhanced & L2CAP_CTRL_SAR) >>
-			L2CAP_CTRL_SAR_SHIFT;
-		control->txseq = (enhanced & L2CAP_CTRL_TXSEQ) >>
-			L2CAP_CTRL_TXSEQ_SHIFT;
-
-		control->poll = 0;
-		control->super = 0;
-	}
+	chan->state = state;
+	chan->ops->state_change(chan->data, state);
 }
 
-static u32 __pack_extended_control(struct bt_l2cap_control *control)
+static void l2cap_state_change(struct l2cap_chan *chan, int state)
 {
-	u32 packed;
+	struct sock *sk = chan->sk;
 
-	packed = (control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
-		L2CAP_EXT_CTRL_REQSEQ;
-	packed |= (control->final << L2CAP_EXT_CTRL_FINAL_SHIFT) &
-		L2CAP_EXT_CTRL_FINAL;
-
-	if (control->frame_type == 's') {
-		packed |= (control->poll << L2CAP_EXT_CTRL_POLL_SHIFT) &
-			L2CAP_EXT_CTRL_POLL;
-		packed |= (control->super << L2CAP_EXT_CTRL_SUPERVISE_SHIFT) &
-			L2CAP_EXT_CTRL_SUPERVISE;
-		packed |= L2CAP_EXT_CTRL_FRAME_TYPE;
-	} else {
-		packed |= (control->sar << L2CAP_EXT_CTRL_SAR_SHIFT) &
-			L2CAP_EXT_CTRL_SAR;
-		packed |= (control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
-			L2CAP_EXT_CTRL_TXSEQ;
-	}
-
-	return packed;
+	lock_sock(sk);
+	__l2cap_state_change(chan, state);
+	release_sock(sk);
 }
 
-static void __get_extended_control(u32 extended,
-				struct bt_l2cap_control *control)
+static inline void __l2cap_chan_set_err(struct l2cap_chan *chan, int err)
 {
-	control->reqseq = (extended & L2CAP_EXT_CTRL_REQSEQ) >>
-		L2CAP_EXT_CTRL_REQSEQ_SHIFT;
-	control->final = (extended & L2CAP_EXT_CTRL_FINAL) >>
-		L2CAP_EXT_CTRL_FINAL_SHIFT;
-
-	if (extended & L2CAP_EXT_CTRL_FRAME_TYPE) {
-		control->frame_type = 's';
-		control->poll = (extended & L2CAP_EXT_CTRL_POLL) >>
-			L2CAP_EXT_CTRL_POLL_SHIFT;
-		control->super = (extended & L2CAP_EXT_CTRL_SUPERVISE) >>
-			L2CAP_EXT_CTRL_SUPERVISE_SHIFT;
-
-		control->sar = 0;
-		control->txseq = 0;
-	} else {
-		control->frame_type = 'i';
-		control->sar = (extended & L2CAP_EXT_CTRL_SAR) >>
-			L2CAP_EXT_CTRL_SAR_SHIFT;
-		control->txseq = (extended & L2CAP_EXT_CTRL_TXSEQ) >>
-			L2CAP_EXT_CTRL_TXSEQ_SHIFT;
+	struct sock *sk = chan->sk;
 
-		control->poll = 0;
-		control->super = 0;
-	}
+	sk->sk_err = err;
 }
 
-static inline void l2cap_ertm_stop_ack_timer(struct l2cap_pinfo *pi)
+static inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)
 {
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->ack_work);
-}
+	struct sock *sk = chan->sk;
 
-static inline void l2cap_ertm_start_ack_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p, pending %d", pi, delayed_work_pending(&pi->ack_work));
-	if (!delayed_work_pending(&pi->ack_work)) {
-		queue_delayed_work(_l2cap_wq, &pi->ack_work,
-				msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
-	}
+	lock_sock(sk);
+	__l2cap_chan_set_err(chan, err);
+	release_sock(sk);
 }
 
-static inline void l2cap_ertm_stop_retrans_timer(struct l2cap_pinfo *pi)
+static void l2cap_chan_timeout(struct work_struct *work)
 {
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->retrans_work);
-}
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							chan_timer.work);
+	struct l2cap_conn *conn = chan->conn;
+	int reason;
+
+	BT_DBG("chan %p state %s", chan, state_to_string(chan->state));
+
+	mutex_lock(&conn->chan_lock);
+	l2cap_chan_lock(chan);
+
+	if (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)
+		reason = ECONNREFUSED;
+	else if (chan->state == BT_CONNECT &&
+					chan->sec_level != BT_SECURITY_SDP)
+		reason = ECONNREFUSED;
+	else
+		reason = ETIMEDOUT;
 
-static inline void l2cap_ertm_start_retrans_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	if (!delayed_work_pending(&pi->monitor_work) && pi->retrans_timeout) {
-		__cancel_delayed_work(&pi->retrans_work);
-		queue_delayed_work(_l2cap_wq, &pi->retrans_work,
-			msecs_to_jiffies(pi->retrans_timeout));
-	}
-}
+	l2cap_chan_close(chan, reason);
 
-static inline void l2cap_ertm_stop_monitor_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->monitor_work);
-}
+	l2cap_chan_unlock(chan);
 
-static inline void l2cap_ertm_start_monitor_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	__cancel_delayed_work(&pi->monitor_work);
-	if (pi->monitor_timeout) {
-		queue_delayed_work(_l2cap_wq, &pi->monitor_work,
-				msecs_to_jiffies(pi->monitor_timeout));
-	}
+	chan->ops->close(chan->data);
+	mutex_unlock(&conn->chan_lock);
+
+	l2cap_chan_put(chan);
 }
 
-static u16 l2cap_alloc_cid(struct l2cap_chan_list *l)
+struct l2cap_chan *l2cap_chan_create(struct sock *sk)
 {
-	u16 cid = L2CAP_CID_DYN_START;
+	struct l2cap_chan *chan;
 
-	for (; cid < L2CAP_CID_DYN_END; cid++) {
-		if (!__l2cap_get_chan_by_scid(l, cid))
-			return cid;
-	}
+	chan = kzalloc(sizeof(*chan), GFP_ATOMIC);
+	if (!chan)
+		return NULL;
 
-	return 0;
-}
+	mutex_init(&chan->lock);
 
-static inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)
-{
-	sock_hold(sk);
+	chan->sk = sk;
 
-	if (l->head)
-		l2cap_pi(l->head)->prev_c = sk;
+	write_lock(&chan_list_lock);
+	list_add(&chan->global_l, &chan_list);
+	write_unlock(&chan_list_lock);
 
-	l2cap_pi(sk)->next_c = l->head;
-	l2cap_pi(sk)->prev_c = NULL;
-	l->head = sk;
-}
+	INIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);
 
-static inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)
-{
-	struct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;
+	chan->state = BT_OPEN;
 
-	write_lock_bh(&l->lock);
-	if (sk == l->head)
-		l->head = next;
+	atomic_set(&chan->refcnt, 1);
 
-	if (next)
-		l2cap_pi(next)->prev_c = prev;
-	if (prev)
-		l2cap_pi(prev)->next_c = next;
-	write_unlock_bh(&l->lock);
+	BT_DBG("sk %p chan %p", sk, chan);
 
-	__sock_put(sk);
+	return chan;
 }
 
-static void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
+void l2cap_chan_destroy(struct l2cap_chan *chan)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
+	write_lock(&chan_list_lock);
+	list_del(&chan->global_l);
+	write_unlock(&chan_list_lock);
+
+	l2cap_chan_put(chan);
+}
 
+void __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)
+{
 	BT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn,
-			l2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);
+			chan->psm, chan->dcid);
 
-	conn->disc_reason = 0x13;
+	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
 
-	l2cap_pi(sk)->conn = conn;
+	chan->conn = conn;
 
-	if (!l2cap_pi(sk)->fixed_channel &&
-		(sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)) {
+	switch (chan->chan_type) {
+	case L2CAP_CHAN_CONN_ORIENTED:
 		if (conn->hcon->type == LE_LINK) {
 			/* LE connection */
-			if (l2cap_pi(sk)->imtu < L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->imtu = L2CAP_LE_DEFAULT_MTU;
-			if (l2cap_pi(sk)->omtu < L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->omtu = L2CAP_LE_DEFAULT_MTU;
-
-			l2cap_pi(sk)->scid = L2CAP_CID_LE_DATA;
-			l2cap_pi(sk)->dcid = L2CAP_CID_LE_DATA;
+			chan->omtu = L2CAP_LE_DEFAULT_MTU;
+			chan->scid = L2CAP_CID_LE_DATA;
+			chan->dcid = L2CAP_CID_LE_DATA;
 		} else {
 			/* Alloc CID for connection-oriented socket */
-			l2cap_pi(sk)->scid = l2cap_alloc_cid(l);
-			l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
+			chan->scid = l2cap_alloc_cid(conn);
+			chan->omtu = L2CAP_DEFAULT_MTU;
 		}
-	} else if (sk->sk_type == SOCK_DGRAM) {
+		break;
+
+	case L2CAP_CHAN_CONN_LESS:
 		/* Connectionless socket */
-		l2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
-	} else if (sk->sk_type == SOCK_RAW) {
+		chan->scid = L2CAP_CID_CONN_LESS;
+		chan->dcid = L2CAP_CID_CONN_LESS;
+		chan->omtu = L2CAP_DEFAULT_MTU;
+		break;
+
+	default:
 		/* Raw socket can send/recv signalling messages only */
-		l2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
+		chan->scid = L2CAP_CID_SIGNALING;
+		chan->dcid = L2CAP_CID_SIGNALING;
+		chan->omtu = L2CAP_DEFAULT_MTU;
 	}
 
-	if (l2cap_get_smallest_flushto(l) > l2cap_pi(sk)->flush_to) {
-		/*if flush timeout of the channel is lesser than existing */
-		l2cap_set_acl_flushto(conn->hcon, l2cap_pi(sk)->flush_to);
-	}
-	/* Otherwise, do not set scid/dcid/omtu.  These will be set up
-	 * by l2cap_fixed_channel_config()
-	 */
+	chan->local_id		= L2CAP_BESTEFFORT_ID;
+	chan->local_stype	= L2CAP_SERV_BESTEFFORT;
+	chan->local_msdu	= L2CAP_DEFAULT_MAX_SDU_SIZE;
+	chan->local_sdu_itime	= L2CAP_DEFAULT_SDU_ITIME;
+	chan->local_acc_lat	= L2CAP_DEFAULT_ACC_LAT;
+	chan->local_flush_to	= L2CAP_DEFAULT_FLUSH_TO;
 
-	__l2cap_chan_link(l, sk);
+	l2cap_chan_hold(chan);
+
+	list_add(&chan->list, &conn->chan_l);
+}
+
+void l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)
+{
+	mutex_lock(&conn->chan_lock);
+	__l2cap_chan_add(conn, chan);
+	mutex_unlock(&conn->chan_lock);
 }
 
-/* Delete channel.
- * Must be called on the locked socket. */
-void l2cap_chan_del(struct sock *sk, int err)
+static void l2cap_chan_del(struct l2cap_chan *chan, int err)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct sock *sk = chan->sk;
+	struct l2cap_conn *conn = chan->conn;
 	struct sock *parent = bt_sk(sk)->parent;
 
-	l2cap_sock_clear_timer(sk);
+	__clear_chan_timer(chan);
 
-	BT_DBG("sk %p, conn %p, err %d", sk, conn, err);
+	BT_DBG("chan %p, conn %p, err %d", chan, conn, err);
 
 	if (conn) {
-		struct l2cap_chan_list *l = &conn->chan_list;
-		/* Unlink from channel list */
-		l2cap_chan_unlink(l, sk);
-		l2cap_pi(sk)->conn = NULL;
-		if (!l2cap_pi(sk)->fixed_channel)
-			hci_conn_put(conn->hcon);
-
-		read_lock(&l->lock);
-		if (l2cap_pi(sk)->flush_to < l2cap_get_smallest_flushto(l))
-			l2cap_set_acl_flushto(conn->hcon,
-				l2cap_get_smallest_flushto(l));
-		read_unlock(&l->lock);
-	}
-
-	if (l2cap_pi(sk)->ampchan) {
-		struct hci_chan *ampchan = l2cap_pi(sk)->ampchan;
-		struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
-		l2cap_pi(sk)->ampchan = NULL;
-		l2cap_pi(sk)->ampcon = NULL;
-		l2cap_pi(sk)->amp_id = 0;
-		if (hci_chan_put(ampchan))
-			ampcon->l2cap_data = NULL;
-		else
-			l2cap_deaggregate(ampchan, l2cap_pi(sk));
+		/* Delete from channel list */
+		list_del(&chan->list);
+
+		l2cap_chan_put(chan);
+
+		chan->conn = NULL;
+		hci_conn_put(conn->hcon);
 	}
 
-	sk->sk_state = BT_CLOSED;
+	lock_sock(sk);
+
+	__l2cap_state_change(chan, BT_CLOSED);
 	sock_set_flag(sk, SOCK_ZAPPED);
 
 	if (err)
-		sk->sk_err = err;
+		__l2cap_chan_set_err(chan, err);
 
 	if (parent) {
 		bt_accept_unlink(sk);
@@ -591,26 +388,118 @@
 	} else
 		sk->sk_state_change(sk);
 
-	sk->sk_send_head = NULL;
-	skb_queue_purge(TX_QUEUE(sk));
+	release_sock(sk);
+
+	if (!(test_bit(CONF_OUTPUT_DONE, &chan->conf_state) &&
+			test_bit(CONF_INPUT_DONE, &chan->conf_state)))
+		return;
+
+	skb_queue_purge(&chan->tx_q);
+
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		struct srej_list *l, *tmp;
+
+		__clear_retrans_timer(chan);
+		__clear_monitor_timer(chan);
+		__clear_ack_timer(chan);
+
+		skb_queue_purge(&chan->srej_q);
 
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		if (l2cap_pi(sk)->sdu)
-			kfree_skb(l2cap_pi(sk)->sdu);
+		list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
+			list_del(&l->list);
+			kfree(l);
+		}
+	}
+}
+
+static void l2cap_chan_cleanup_listen(struct sock *parent)
+{
+	struct sock *sk;
+
+	BT_DBG("parent %p", parent);
+
+	/* Close not yet accepted channels */
+	while ((sk = bt_accept_dequeue(parent, NULL))) {
+		struct l2cap_chan *chan = l2cap_pi(sk)->chan;
+
+		l2cap_chan_lock(chan);
+		__clear_chan_timer(chan);
+		l2cap_chan_close(chan, ECONNRESET);
+		l2cap_chan_unlock(chan);
+
+		chan->ops->close(chan->data);
+	}
+}
+
+void l2cap_chan_close(struct l2cap_chan *chan, int reason)
+{
+	struct l2cap_conn *conn = chan->conn;
+	struct sock *sk = chan->sk;
+
+	BT_DBG("chan %p state %s sk %p", chan,
+					state_to_string(chan->state), sk);
+
+	switch (chan->state) {
+	case BT_LISTEN:
+		lock_sock(sk);
+		l2cap_chan_cleanup_listen(sk);
+
+		__l2cap_state_change(chan, BT_CLOSED);
+		sock_set_flag(sk, SOCK_ZAPPED);
+		release_sock(sk);
+		break;
+
+	case BT_CONNECTED:
+	case BT_CONFIG:
+		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
+					conn->hcon->type == ACL_LINK) {
+			__clear_chan_timer(chan);
+			__set_chan_timer(chan, sk->sk_sndtimeo);
+			l2cap_send_disconn_req(conn, chan, reason);
+		} else
+			l2cap_chan_del(chan, reason);
+		break;
+
+	case BT_CONNECT2:
+		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
+					conn->hcon->type == ACL_LINK) {
+			struct l2cap_conn_rsp rsp;
+			__u16 result;
+
+			if (bt_sk(sk)->defer_setup)
+				result = L2CAP_CR_SEC_BLOCK;
+			else
+				result = L2CAP_CR_BAD_PSM;
+			l2cap_state_change(chan, BT_DISCONN);
+
+			rsp.scid   = cpu_to_le16(chan->dcid);
+			rsp.dcid   = cpu_to_le16(chan->scid);
+			rsp.result = cpu_to_le16(result);
+			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
+		}
+
+		l2cap_chan_del(chan, reason);
+		break;
 
-		skb_queue_purge(SREJ_QUEUE(sk));
+	case BT_CONNECT:
+	case BT_DISCONN:
+		l2cap_chan_del(chan, reason);
+		break;
 
-		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
+	default:
+		lock_sock(sk);
+		sock_set_flag(sk, SOCK_ZAPPED);
+		release_sock(sk);
+		break;
 	}
 }
 
-static inline u8 l2cap_get_auth_type(struct sock *sk)
+static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
 {
-	if (sk->sk_type == SOCK_RAW) {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_VERY_HIGH:
+	if (chan->chan_type == L2CAP_CHAN_RAW) {
+		switch (chan->sec_level) {
 		case BT_SECURITY_HIGH:
 			return HCI_AT_DEDICATED_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -618,18 +507,16 @@
 		default:
 			return HCI_AT_NO_BONDING;
 		}
-	} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
+	} else if (chan->psm == cpu_to_le16(0x0001)) {
+		if (chan->sec_level == BT_SECURITY_LOW)
+			chan->sec_level = BT_SECURITY_SDP;
 
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
-			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
+		if (chan->sec_level == BT_SECURITY_HIGH)
 			return HCI_AT_NO_BONDING_MITM;
 		else
 			return HCI_AT_NO_BONDING;
 	} else {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_VERY_HIGH:
+		switch (chan->sec_level) {
 		case BT_SECURITY_HIGH:
 			return HCI_AT_GENERAL_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -641,18 +528,17 @@
 }
 
 /* Service level security */
-static inline int l2cap_check_security(struct sock *sk)
+int l2cap_chan_check_security(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	__u8 auth_type;
 
-	auth_type = l2cap_get_auth_type(sk);
+	auth_type = l2cap_get_auth_type(chan);
 
-	return hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,
-								auth_type);
+	return hci_conn_security(conn->hcon, chan->sec_level, auth_type);
 }
 
-u8 l2cap_get_ident(struct l2cap_conn *conn)
+static u8 l2cap_get_ident(struct l2cap_conn *conn)
 {
 	u8 id;
 
@@ -662,118 +548,150 @@
 	 *  200 - 254 are used by utilities like l2ping, etc.
 	 */
 
-	spin_lock_bh(&conn->lock);
+	spin_lock(&conn->lock);
 
 	if (++conn->tx_ident > 128)
 		conn->tx_ident = 1;
 
 	id = conn->tx_ident;
 
-	spin_unlock_bh(&conn->lock);
+	spin_unlock(&conn->lock);
 
 	return id;
 }
 
-static void apply_fcs(struct sk_buff *skb)
+static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
 {
-	size_t len;
-	u16 partial_crc;
-	struct sk_buff *iter;
-	struct sk_buff *final_frag = skb;
+	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
+	u8 flags;
+
+	BT_DBG("code 0x%2.2x", code);
+
+	if (!skb)
+		return;
 
-	if (skb_has_frag_list(skb))
-		len = skb_headlen(skb);
+	if (lmp_no_flush_capable(conn->hcon->hdev))
+		flags = ACL_START_NO_FLUSH;
 	else
-		len = skb->len - L2CAP_FCS_SIZE;
+		flags = ACL_START;
 
-	partial_crc = crc16(0, (u8 *) skb->data, len);
+	bt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;
+	skb->priority = HCI_PRIO_MAX;
 
-	skb_walk_frags(skb, iter) {
-		len = iter->len;
-		if (!iter->next)
-			len -= L2CAP_FCS_SIZE;
+	hci_send_acl(conn->hchan, skb, flags);
+}
 
-		partial_crc = crc16(partial_crc, iter->data, len);
-		final_frag = iter;
-	}
+static void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)
+{
+	struct hci_conn *hcon = chan->conn->hcon;
+	u16 flags;
+
+	BT_DBG("chan %p, skb %p len %d priority %u", chan, skb, skb->len,
+							skb->priority);
+
+	if (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&
+					lmp_no_flush_capable(hcon->hdev))
+		flags = ACL_START_NO_FLUSH;
+	else
+		flags = ACL_START;
 
-	put_unaligned_le16(partial_crc,
-		final_frag->data + final_frag->len - L2CAP_FCS_SIZE);
+	bt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+	hci_send_acl(chan->conn->hchan, skb, flags);
 }
 
-void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
+static inline void l2cap_send_sframe(struct l2cap_chan *chan, u32 control)
 {
-	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
-	u8 flags;
+	struct sk_buff *skb;
+	struct l2cap_hdr *lh;
+	struct l2cap_conn *conn = chan->conn;
+	int count, hlen;
 
-	BT_DBG("code 0x%2.2x", code);
+	if (chan->state != BT_CONNECTED)
+		return;
+
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hlen = L2CAP_EXT_HDR_SIZE;
+	else
+		hlen = L2CAP_ENH_HDR_SIZE;
+
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		hlen += L2CAP_FCS_SIZE;
 
+	BT_DBG("chan %p, control 0x%8.8x", chan, control);
+
+	count = min_t(unsigned int, conn->mtu, hlen);
+
+	control |= __set_sframe(chan);
+
+	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+		control |= __set_ctrl_final(chan);
+
+	if (test_and_clear_bit(CONN_SEND_PBIT, &chan->conn_state))
+		control |= __set_ctrl_poll(chan);
+
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
 	if (!skb)
 		return;
 
-	if (conn->hcon == NULL || conn->hcon->hdev == NULL)
-		return;
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);
+	lh->cid = cpu_to_le16(chan->dcid);
 
-	if (lmp_no_flush_capable(conn->hcon->hdev))
-		flags = ACL_START_NO_FLUSH;
-	else
-		flags = ACL_START;
+	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
 
-	bt_cb(skb)->force_active = 1;
+	if (chan->fcs == L2CAP_FCS_CRC16) {
+		u16 fcs = crc16(0, (u8 *)lh, count - L2CAP_FCS_SIZE);
+		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
+	}
 
-	hci_send_acl(conn->hcon, NULL, skb, flags);
+	skb->priority = HCI_PRIO_MAX;
+	l2cap_do_send(chan, skb);
 }
 
-static inline int __l2cap_no_conn_pending(struct sock *sk)
+static inline void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, u32 control)
 {
-	return !(l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND);
-}
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+	} else
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
 
-static void l2cap_send_conn_req(struct sock *sk)
-{
-	struct l2cap_conn_req req;
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-	req.psm  = l2cap_pi(sk)->psm;
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
+	l2cap_send_sframe(chan, control);
+}
 
-	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-			L2CAP_CONN_REQ, sizeof(req), &req);
+static inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)
+{
+	return !test_bit(CONF_CONNECT_PEND, &chan->conf_state);
 }
 
-static void l2cap_send_create_chan_req(struct sock *sk, u8 amp_id)
+static void l2cap_send_conn_req(struct l2cap_chan *chan)
 {
-	struct l2cap_create_chan_req req;
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-	req.psm  = l2cap_pi(sk)->psm;
-	req.amp_id = amp_id;
+	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn_req req;
+
+	req.scid = cpu_to_le16(chan->scid);
+	req.psm  = chan->psm;
 
-	l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
-	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
+	chan->ident = l2cap_get_ident(conn);
 
-	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-			L2CAP_CREATE_CHAN_REQ, sizeof(req), &req);
+	set_bit(CONF_CONNECT_PEND, &chan->conf_state);
+
+	l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);
 }
 
-static void l2cap_do_start(struct sock *sk)
+static void l2cap_do_start(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 
 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
 		if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
 			return;
 
-		if (l2cap_check_security(sk) && __l2cap_no_conn_pending(sk)) {
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-
-			if (l2cap_pi(sk)->amp_pref ==
-					BT_AMP_POLICY_PREFER_AMP &&
-					enable_hs &&
-					conn->fc_mask & L2CAP_FC_A2MP)
-				amp_create_physical(conn, sk);
-			else
-				l2cap_send_conn_req(sk);
-		}
+		if (l2cap_chan_check_security(chan) &&
+				__l2cap_no_conn_pending(chan))
+			l2cap_send_conn_req(chan);
 	} else {
 		struct l2cap_info_req req;
 		req.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
@@ -781,8 +699,7 @@
 		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
 		conn->info_ident = l2cap_get_ident(conn);
 
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
+		schedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);
 
 		l2cap_send_cmd(conn, conn->info_ident,
 					L2CAP_INFO_REQ, sizeof(req), &req);
@@ -805,91 +722,75 @@
 	}
 }
 
-void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err)
+static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err)
 {
+	struct sock *sk = chan->sk;
 	struct l2cap_disconn_req req;
 
 	if (!conn)
 		return;
 
-	sk->sk_send_head = NULL;
-	skb_queue_purge(TX_QUEUE(sk));
-
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		skb_queue_purge(SREJ_QUEUE(sk));
-
-		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		__clear_retrans_timer(chan);
+		__clear_monitor_timer(chan);
+		__clear_ack_timer(chan);
 	}
 
-	req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
+	req.dcid = cpu_to_le16(chan->dcid);
+	req.scid = cpu_to_le16(chan->scid);
 	l2cap_send_cmd(conn, l2cap_get_ident(conn),
 			L2CAP_DISCONN_REQ, sizeof(req), &req);
 
-	sk->sk_state = BT_DISCONN;
-	sk->sk_err = err;
+	lock_sock(sk);
+	__l2cap_state_change(chan, BT_DISCONN);
+	__l2cap_chan_set_err(chan, err);
+	release_sock(sk);
 }
 
 /* ---- L2CAP connections ---- */
 static void l2cap_conn_start(struct l2cap_conn *conn)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock_del_list del, *tmp1, *tmp2;
-	struct sock *sk;
+	struct l2cap_chan *chan, *tmp;
 
 	BT_DBG("conn %p", conn);
 
-	INIT_LIST_HEAD(&del.list);
+	mutex_lock(&conn->chan_lock);
 
-	read_lock(&l->lock);
+	list_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {
+		struct sock *sk = chan->sk;
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
+		l2cap_chan_lock(chan);
 
-		if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-			bh_unlock_sock(sk);
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (sk->sk_state == BT_CONNECT) {
-			if (!l2cap_check_security(sk) ||
-					!__l2cap_no_conn_pending(sk)) {
-				bh_unlock_sock(sk);
+		if (chan->state == BT_CONNECT) {
+			if (!l2cap_chan_check_security(chan) ||
+					!__l2cap_no_conn_pending(chan)) {
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			if (!l2cap_mode_supported(l2cap_pi(sk)->mode,
-					conn->feat_mask)
-					&& l2cap_pi(sk)->conf_state &
-					L2CAP_CONF_STATE2_DEVICE) {
-				tmp1 = kzalloc(sizeof(struct sock_del_list),
-						GFP_ATOMIC);
-				tmp1->sk = sk;
-				list_add_tail(&tmp1->list, &del.list);
-				bh_unlock_sock(sk);
+			if (!l2cap_mode_supported(chan->mode, conn->feat_mask)
+					&& test_bit(CONF_STATE2_DEVICE,
+					&chan->conf_state)) {
+				l2cap_chan_close(chan, ECONNRESET);
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
+			l2cap_send_conn_req(chan);
 
-			if (l2cap_pi(sk)->amp_pref ==
-					BT_AMP_POLICY_PREFER_AMP &&
-					enable_hs &&
-					conn->fc_mask & L2CAP_FC_A2MP)
-				amp_create_physical(conn, sk);
-			else
-				l2cap_send_conn_req(sk);
-
-		} else if (sk->sk_state == BT_CONNECT2) {
+		} else if (chan->state == BT_CONNECT2) {
 			struct l2cap_conn_rsp rsp;
 			char buf[128];
-			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+			rsp.scid = cpu_to_le16(chan->dcid);
+			rsp.dcid = cpu_to_le16(chan->scid);
 
-			if (l2cap_check_security(sk)) {
+			if (l2cap_chan_check_security(chan)) {
+				lock_sock(sk);
 				if (bt_sk(sk)->defer_setup) {
 					struct sock *parent = bt_sk(sk)->parent;
 					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
@@ -898,133 +799,86 @@
 						parent->sk_data_ready(parent, 0);
 
 				} else {
-					sk->sk_state = BT_CONFIG;
+					__l2cap_state_change(chan, BT_CONFIG);
 					rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
 					rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
 				}
+				release_sock(sk);
 			} else {
 				rsp.result = cpu_to_le16(L2CAP_CR_PEND);
 				rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);
 			}
 
-			if (rsp.result == cpu_to_le16(L2CAP_CR_SUCCESS) &&
-					l2cap_pi(sk)->amp_id) {
-				amp_accept_physical(conn,
-						l2cap_pi(sk)->amp_id, sk);
-				bh_unlock_sock(sk);
-				continue;
-			}
-
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
 
-			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT ||
+			if (test_bit(CONF_REQ_SENT, &chan->conf_state) ||
 					rsp.result != L2CAP_CR_SUCCESS) {
-				bh_unlock_sock(sk);
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+			set_bit(CONF_REQ_SENT, &chan->conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-						l2cap_build_conf_req(sk, buf), buf);
-			l2cap_pi(sk)->num_conf_req++;
+						l2cap_build_conf_req(chan, buf), buf);
+			chan->num_conf_req++;
 		}
 
-		bh_unlock_sock(sk);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	list_for_each_entry_safe(tmp1, tmp2, &del.list, list) {
-		bh_lock_sock(tmp1->sk);
-		__l2cap_sock_close(tmp1->sk, ECONNRESET);
-		bh_unlock_sock(tmp1->sk);
-		list_del(&tmp1->list);
-		kfree(tmp1);
-	}
+	mutex_unlock(&conn->chan_lock);
 }
 
-/* Find socket with fixed cid with given source and destination bdaddrs.
- * Direction of the req/rsp must match.
+/* Find socket with cid and source bdaddr.
+ * Returns closest match, locked.
  */
-struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
-						bdaddr_t *dst, int incoming)
+static struct l2cap_chan *l2cap_global_chan_by_scid(int state, __le16 cid, bdaddr_t *src)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
+	struct l2cap_chan *c, *c1 = NULL;
 
-	BT_DBG(" %d", incoming);
+	read_lock(&chan_list_lock);
 
-	read_lock(&l2cap_sk_list.lock);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-
-		if (incoming && !l2cap_pi(sk)->incoming)
-			continue;
-
-		if (!incoming && l2cap_pi(sk)->incoming)
+		if (state && c->state != state)
 			continue;
 
-		if (l2cap_pi(sk)->scid == cid && !bacmp(&bt_sk(sk)->dst, dst)) {
+		if (c->scid == cid) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
+			if (!bacmp(&bt_sk(sk)->src, src)) {
+				read_unlock(&chan_list_lock);
+				return c;
+			}
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
+				c1 = c;
 		}
 	}
 
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
-	return node ? sk : sk1;
+	return c1;
 }
 
-/* Find socket with cid and source bdaddr.
- * Returns closest match, locked.
- */
-static struct sock *l2cap_get_sock_by_scid(int state, __le16 cid, bdaddr_t *src)
+static void l2cap_le_conn_ready(struct l2cap_conn *conn)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
-
-	read_lock(&l2cap_sk_list.lock);
+	struct sock *parent, *sk;
+	struct l2cap_chan *chan, *pchan;
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (state && sk->sk_state != state)
-			continue;
-
-		if (l2cap_pi(sk)->scid == cid) {
-			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
-
-			/* Closest match */
-			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
-		}
-	}
-
-	read_unlock(&l2cap_sk_list.lock);
-
-	return node ? sk : sk1;
-}
-
-static void l2cap_le_conn_ready(struct l2cap_conn *conn)
-{
-	struct l2cap_chan_list *list = &conn->chan_list;
-	struct sock *parent, *uninitialized_var(sk);
-
-	BT_DBG("");
+	BT_DBG("");
 
 	/* Check if we have socket listening on cid */
-	parent = l2cap_get_sock_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
+	pchan = l2cap_global_chan_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
 							conn->src);
-	if (!parent)
+	if (!pchan)
 		return;
 
-	bh_lock_sock(parent);
+	parent = pchan->sk;
+
+	lock_sock(parent);
 
 	/* Check for backlog size */
 	if (sk_acceptq_is_full(parent)) {
@@ -1032,101 +886,115 @@
 		goto clean;
 	}
 
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
-	if (!sk)
+	chan = pchan->ops->new_connection(pchan->data);
+	if (!chan)
 		goto clean;
 
-	write_lock_bh(&list->lock);
+	sk = chan->sk;
 
 	hci_conn_hold(conn->hcon);
+	conn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;
 
-	l2cap_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, conn->src);
 	bacpy(&bt_sk(sk)->dst, conn->dst);
-	l2cap_pi(sk)->incoming = 1;
 
 	bt_accept_enqueue(parent, sk);
 
-	__l2cap_chan_add(conn, sk);
+	l2cap_chan_add(conn, chan);
 
-	sk->sk_state = BT_CONNECTED;
-	parent->sk_data_ready(parent, 0);
+	__set_chan_timer(chan, sk->sk_sndtimeo);
 
-	write_unlock_bh(&list->lock);
+	__l2cap_state_change(chan, BT_CONNECTED);
+	parent->sk_data_ready(parent, 0);
 
 clean:
-	bh_unlock_sock(parent);
+	release_sock(parent);
+}
+
+static void l2cap_chan_ready(struct l2cap_chan *chan)
+{
+	struct sock *sk = chan->sk;
+	struct sock *parent;
+
+	lock_sock(sk);
+
+	parent = bt_sk(sk)->parent;
+
+	BT_DBG("sk %p, parent %p", sk, parent);
+
+	chan->conf_state = 0;
+	__clear_chan_timer(chan);
+
+	__l2cap_state_change(chan, BT_CONNECTED);
+	sk->sk_state_change(sk);
+
+	if (parent)
+		parent->sk_data_ready(parent, 0);
+
+	release_sock(sk);
 }
 
 static void l2cap_conn_ready(struct l2cap_conn *conn)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
+	struct l2cap_chan *chan;
+	struct hci_conn *hcon = conn->hcon;
 
 	BT_DBG("conn %p", conn);
 
-	if (!conn->hcon->out && conn->hcon->type == LE_LINK)
+	if (!hcon->out && hcon->type == LE_LINK)
 		l2cap_le_conn_ready(conn);
 
-	read_lock(&l->lock);
+	if (hcon->out && hcon->type == LE_LINK)
+		smp_conn_security(hcon, hcon->pending_sec_level);
 
-	if (l->head) {
-		for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-			bh_lock_sock(sk);
+	mutex_lock(&conn->chan_lock);
 
-			if (conn->hcon->type == LE_LINK) {
-				u8 sec_level = l2cap_pi(sk)->sec_level;
-				u8 pending_sec = conn->hcon->pending_sec_level;
+	list_for_each_entry(chan, &conn->chan_l, list) {
 
-				if (pending_sec > sec_level)
-					sec_level = pending_sec;
+		l2cap_chan_lock(chan);
 
-				if (smp_conn_security(conn, sec_level))
-					l2cap_chan_ready(sk);
+		if (hcon->type == LE_LINK) {
+			if (smp_conn_security(hcon, chan->sec_level))
+				l2cap_chan_ready(chan);
 
-				hci_conn_put(conn->hcon);
+		} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			struct sock *sk = chan->sk;
+			__clear_chan_timer(chan);
+			lock_sock(sk);
+			__l2cap_state_change(chan, BT_CONNECTED);
+			sk->sk_state_change(sk);
+			release_sock(sk);
 
-			} else if (sk->sk_type != SOCK_SEQPACKET &&
-					sk->sk_type != SOCK_STREAM) {
-				l2cap_sock_clear_timer(sk);
-				sk->sk_state = BT_CONNECTED;
-				sk->sk_state_change(sk);
-			} else if (sk->sk_state == BT_CONNECT)
-				l2cap_do_start(sk);
+		} else if (chan->state == BT_CONNECT)
+			l2cap_do_start(chan);
 
-			bh_unlock_sock(sk);
-		}
-	} else if (conn->hcon->type == LE_LINK) {
-		smp_conn_security(conn, BT_SECURITY_HIGH);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	if (conn->hcon->out && conn->hcon->type == LE_LINK)
-		l2cap_le_conn_ready(conn);
+	mutex_unlock(&conn->chan_lock);
 }
 
 /* Notify sockets that we cannot guaranty reliability anymore */
 static void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
+	struct l2cap_chan *chan;
 
 	BT_DBG("conn %p", conn);
 
-	read_lock(&l->lock);
+	mutex_lock(&conn->chan_lock);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (l2cap_pi(sk)->force_reliable)
-			sk->sk_err = err;
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
+			__l2cap_chan_set_err(chan, err);
 	}
 
-	read_unlock(&l->lock);
+	mutex_unlock(&conn->chan_lock);
 }
 
-static void l2cap_info_timeout(unsigned long arg)
+static void l2cap_info_timeout(struct work_struct *work)
 {
-	struct l2cap_conn *conn = (void *) arg;
+	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
+							info_timer.work);
 
 	conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
 	conn->info_ident = 0;
@@ -1134,21 +1002,78 @@
 	l2cap_conn_start(conn);
 }
 
+static void l2cap_conn_del(struct hci_conn *hcon, int err)
+{
+	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct l2cap_chan *chan, *l;
+
+	if (!conn)
+		return;
+
+	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
+
+	kfree_skb(conn->rx_skb);
+
+	mutex_lock(&conn->chan_lock);
+
+	/* Kill channels */
+	list_for_each_entry_safe(chan, l, &conn->chan_l, list) {
+		l2cap_chan_lock(chan);
+
+		l2cap_chan_del(chan, err);
+
+		l2cap_chan_unlock(chan);
+
+		chan->ops->close(chan->data);
+	}
+
+	mutex_unlock(&conn->chan_lock);
+
+	hci_chan_del(conn->hchan);
+
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
+		cancel_delayed_work_sync(&conn->info_timer);
+
+	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags)) {
+		cancel_delayed_work_sync(&conn->security_timer);
+		smp_chan_destroy(conn);
+	}
+
+	hcon->l2cap_data = NULL;
+	kfree(conn);
+}
+
+static void security_timeout(struct work_struct *work)
+{
+	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
+						security_timer.work);
+
+	l2cap_conn_del(conn->hcon, ETIMEDOUT);
+}
+
 static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct hci_chan *hchan;
 
 	if (conn || status)
 		return conn;
 
+	hchan = hci_chan_create(hcon);
+	if (!hchan)
+		return NULL;
+
 	conn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);
-	if (!conn)
+	if (!conn) {
+		hci_chan_del(hchan);
 		return NULL;
+	}
 
 	hcon->l2cap_data = conn;
 	conn->hcon = hcon;
+	conn->hchan = hchan;
 
-	BT_DBG("hcon %p conn %p", hcon, conn);
+	BT_DBG("hcon %p conn %p hchan %p", hcon, conn, hchan);
 
 	if (hcon->hdev->le_mtu && hcon->type == LE_LINK)
 		conn->mtu = hcon->hdev->le_mtu;
@@ -1161,112 +1086,59 @@
 	conn->feat_mask = 0;
 
 	spin_lock_init(&conn->lock);
-	rwlock_init(&conn->chan_list.lock);
+	mutex_init(&conn->chan_lock);
+
+	INIT_LIST_HEAD(&conn->chan_l);
 
 	if (hcon->type == LE_LINK)
-		setup_timer(&hcon->smp_timer, smp_timeout,
-						(unsigned long) conn);
+		INIT_DELAYED_WORK(&conn->security_timer, security_timeout);
 	else
-		setup_timer(&conn->info_timer, l2cap_info_timeout,
-						(unsigned long) conn);
+		INIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);
 
-	conn->disc_reason = 0x13;
+	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
 
 	return conn;
 }
 
-static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-	struct sock *next;
-
-	if (!conn)
-		return;
-
-	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
-
-	if ((conn->hcon == hcon) && (conn->rx_skb))
-		kfree_skb(conn->rx_skb);
-
-	BT_DBG("conn->hcon %p", conn->hcon);
-
-	/* Kill channels */
-	for (sk = conn->chan_list.head; sk; ) {
-		BT_DBG("ampcon %p", l2cap_pi(sk)->ampcon);
-		if ((conn->hcon == hcon) || (l2cap_pi(sk)->ampcon == hcon)) {
-			next = l2cap_pi(sk)->next_c;
-			if (is_process)
-				lock_sock(sk);
-			else
-				bh_lock_sock(sk);
-			l2cap_chan_del(sk, err);
-			if (is_process)
-				release_sock(sk);
-			else
-				bh_unlock_sock(sk);
-			l2cap_sock_kill(sk);
-			sk = next;
-		} else
-			sk = l2cap_pi(sk)->next_c;
-	}
-
-	if (conn->hcon == hcon) {
-		if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
-			del_timer_sync(&conn->info_timer);
-
-		hcon->l2cap_data = NULL;
-
-		kfree(conn);
-	}
-	att_chn_params.conn = NULL;
-	BT_DBG("att_chn_params.conn set to NULL");
-}
-
-static inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	write_lock_bh(&l->lock);
-	__l2cap_chan_add(conn, sk);
-	write_unlock_bh(&l->lock);
-}
-
 /* ---- Socket interface ---- */
 
 /* Find socket with psm and source bdaddr.
  * Returns closest match.
  */
-static struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)
+static struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm, bdaddr_t *src)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
+	struct l2cap_chan *c, *c1 = NULL;
 
-	read_lock(&l2cap_sk_list.lock);
+	read_lock(&chan_list_lock);
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (state && sk->sk_state != state)
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
+
+		if (state && c->state != state)
 			continue;
 
-		if (l2cap_pi(sk)->psm == psm) {
+		if (c->psm == psm) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
+			if (!bacmp(&bt_sk(sk)->src, src)) {
+				read_unlock(&chan_list_lock);
+				return c;
+			}
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
+				c1 = c;
 		}
 	}
 
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
-	return node ? sk : sk1;
+	return c1;
 }
 
-int l2cap_do_connect(struct sock *sk)
+int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid, bdaddr_t *dst)
 {
+	struct sock *sk = chan->sk;
 	bdaddr_t *src = &bt_sk(sk)->src;
-	bdaddr_t *dst = &bt_sk(sk)->dst;
 	struct l2cap_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev *hdev;
@@ -1274,104 +1146,136 @@
 	int err;
 
 	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst),
-							l2cap_pi(sk)->psm);
+							chan->psm);
 
 	hdev = hci_get_route(dst, src);
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	auth_type = l2cap_get_auth_type(sk);
+	l2cap_chan_lock(chan);
 
-	if (l2cap_pi(sk)->fixed_channel) {
-		/* Fixed channels piggyback on existing ACL connections */
-		hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
-		if (!hcon || !hcon->l2cap_data) {
-			err = -ENOTCONN;
-			goto done;
-		}
+	/* PSM must be odd and lsb of upper byte must be 0 */
+	if ((__le16_to_cpu(psm) & 0x0101) != 0x0001 && !cid &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
 
-		conn = hcon->l2cap_data;
-	} else {
-		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA)
-			hcon = hci_le_connect(hdev, 0, dst,
-					l2cap_pi(sk)->sec_level, auth_type,
-					&bt_sk(sk)->le_params);
-		else
-			hcon = hci_connect(hdev, ACL_LINK, 0, dst,
-					l2cap_pi(sk)->sec_level, auth_type);
+	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !(psm || cid)) {
+		err = -EINVAL;
+		goto done;
+	}
 
-		if (IS_ERR(hcon)) {
-			err = PTR_ERR(hcon);
-			goto done;
-		}
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		break;
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+		if (!disable_ertm)
+			break;
+		/* fall through */
+	default:
+		err = -ENOTSUPP;
+		goto done;
+	}
 
-		conn = l2cap_conn_add(hcon, 0);
-		if (!conn) {
-			hci_conn_put(hcon);
-			err = -ENOMEM;
-			goto done;
-		}
+	lock_sock(sk);
+
+	switch (sk->sk_state) {
+	case BT_CONNECT:
+	case BT_CONNECT2:
+	case BT_CONFIG:
+		/* Already connecting */
+		err = 0;
+		release_sock(sk);
+		goto done;
+
+	case BT_CONNECTED:
+		/* Already connected */
+		err = -EISCONN;
+		release_sock(sk);
+		goto done;
+
+	case BT_OPEN:
+	case BT_BOUND:
+		/* Can connect */
+		break;
+
+	default:
+		err = -EBADFD;
+		release_sock(sk);
+		goto done;
 	}
 
-	/* Update source addr of the socket */
-	bacpy(src, conn->src);
+	/* Set destination address and psm */
+	bacpy(&bt_sk(sk)->dst, dst);
 
-	l2cap_chan_add(conn, sk);
+	release_sock(sk);
 
-	if ((l2cap_pi(sk)->fixed_channel) ||
-			(l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
-				hcon->state == BT_CONNECTED)) {
-		sk->sk_state = BT_CONNECTED;
-		sk->sk_state_change(sk);
-	} else {
-		sk->sk_state = BT_CONNECT;
-		/* If we have valid LE Params, let timeout override default */
-		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
-			l2cap_sock_le_params_valid(&bt_sk(sk)->le_params)) {
-			u16 timeout = bt_sk(sk)->le_params.conn_timeout;
-
-			if (timeout)
-				l2cap_sock_set_timer(sk,
-						msecs_to_jiffies(timeout*1000));
-		} else
-			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
+	chan->psm = psm;
+	chan->dcid = cid;
 
-		sk->sk_state_change(sk);
+	auth_type = l2cap_get_auth_type(chan);
 
-		if (hcon->state == BT_CONNECTED) {
-			if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-				l2cap_sock_clear_timer(sk);
-				if (l2cap_check_security(sk)) {
-					sk->sk_state = BT_CONNECTED;
-					sk->sk_state_change(sk);
-				}
-			} else
-				l2cap_do_start(sk);
-		}
+	if (chan->dcid == L2CAP_CID_LE_DATA)
+		hcon = hci_connect(hdev, LE_LINK, dst,
+					chan->sec_level, auth_type);
+	else
+		hcon = hci_connect(hdev, ACL_LINK, dst,
+					chan->sec_level, auth_type);
+
+	if (IS_ERR(hcon)) {
+		err = PTR_ERR(hcon);
+		goto done;
+	}
+
+	conn = l2cap_conn_add(hcon, 0);
+	if (!conn) {
+		hci_conn_put(hcon);
+		err = -ENOMEM;
+		goto done;
+	}
+
+	/* Update source addr of the socket */
+	bacpy(src, conn->src);
+
+	l2cap_chan_unlock(chan);
+	l2cap_chan_add(conn, chan);
+	l2cap_chan_lock(chan);
+
+	l2cap_state_change(chan, BT_CONNECT);
+	__set_chan_timer(chan, sk->sk_sndtimeo);
+
+	if (hcon->state == BT_CONNECTED) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			__clear_chan_timer(chan);
+			if (l2cap_chan_check_security(chan))
+				l2cap_state_change(chan, BT_CONNECTED);
+		} else
+			l2cap_do_start(chan);
 	}
 
 	err = 0;
 
 done:
-	hci_dev_unlock_bh(hdev);
+	l2cap_chan_unlock(chan);
+	hci_dev_unlock(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
 
 int __l2cap_wait_ack(struct sock *sk)
 {
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	DECLARE_WAITQUEUE(wait, current);
 	int err = 0;
 	int timeo = HZ/5;
 
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (l2cap_pi(sk)->unacked_frames > 0 && l2cap_pi(sk)->conn &&
-		atomic_read(&l2cap_pi(sk)->ertm_queued)) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (chan->unacked_frames > 0 && chan->conn) {
 		if (!timeo)
 			timeo = HZ/5;
 
@@ -1383,6 +1287,7 @@
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
@@ -1393,354 +1298,325 @@
 	return err;
 }
 
-static void l2cap_ertm_tx_worker(struct work_struct *work)
+static void l2cap_monitor_timeout(struct work_struct *work)
 {
-	struct l2cap_pinfo *pi =
-		container_of(work, struct l2cap_pinfo, tx_work);
-	struct sock *sk = (struct sock *)pi;
-	BT_DBG("%p", pi);
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							monitor_timer.work);
 
-	lock_sock(sk);
-	l2cap_ertm_send(sk);
-	release_sock(sk);
-	sock_put(sk);
-}
+	BT_DBG("chan %p", chan);
 
-static void l2cap_skb_destructor(struct sk_buff *skb)
-{
-	struct sock *sk = skb->sk;
-	int queued;
-	int keep_sk = 0;
+	l2cap_chan_lock(chan);
+
+	if (chan->retry_count >= chan->remote_max_tx) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+		l2cap_chan_unlock(chan);
+		l2cap_chan_put(chan);
+		return;
+	}
 
-	queued = atomic_sub_return(1, &l2cap_pi(sk)->ertm_queued);
-	if (queued < L2CAP_MIN_ERTM_QUEUED)
-		keep_sk = queue_work(_l2cap_wq, &l2cap_pi(sk)->tx_work);
+	chan->retry_count++;
+	__set_monitor_timer(chan);
 
-	if (!keep_sk)
-		sock_put(sk);
+	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
+	l2cap_chan_unlock(chan);
+	l2cap_chan_put(chan);
 }
 
-void l2cap_do_send(struct sock *sk, struct sk_buff *skb)
+static void l2cap_retrans_timeout(struct work_struct *work)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							retrans_timer.work);
 
-	BT_DBG("sk %p, skb %p len %d", sk, skb, skb->len);
+	BT_DBG("chan %p", chan);
 
-	if (pi->ampcon && (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
-			pi->amp_move_state == L2CAP_AMP_STATE_WAIT_PREPARE)) {
-		BT_DBG("Sending on AMP connection %p %p",
-			pi->ampcon, pi->ampchan);
-		if (pi->ampchan)
-			hci_send_acl(pi->ampcon, pi->ampchan, skb,
-					ACL_COMPLETE);
-		else
-			kfree_skb(skb);
-	} else {
-		u16 flags;
+	l2cap_chan_lock(chan);
 
-		if (!(pi->conn)) {
-			kfree_skb(skb);
-			return;
-		}
+	chan->retry_count = 1;
+	__set_monitor_timer(chan);
 
-		bt_cb(skb)->force_active = pi->force_active;
-		BT_DBG("Sending on BR/EDR connection %p", pi->conn->hcon);
+	set_bit(CONN_WAIT_F, &chan->conn_state);
 
-		if (lmp_no_flush_capable(pi->conn->hcon->hdev) &&
-			!l2cap_pi(sk)->flushable)
-			flags = ACL_START_NO_FLUSH;
-		else
-			flags = ACL_START;
+	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
 
-		hci_send_acl(pi->conn->hcon, NULL, skb, flags);
-	}
+	l2cap_chan_unlock(chan);
+	l2cap_chan_put(chan);
 }
 
-int l2cap_ertm_send(struct sock *sk)
+static void l2cap_drop_acked_frames(struct l2cap_chan *chan)
 {
-	struct sk_buff *skb, *tx_skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control *control;
-	int sent = 0;
+	struct sk_buff *skb;
 
-	BT_DBG("sk %p", sk);
+	while ((skb = skb_peek(&chan->tx_q)) &&
+			chan->unacked_frames) {
+		if (bt_cb(skb)->tx_seq == chan->expected_ack_seq)
+			break;
 
-	if (sk->sk_state != BT_CONNECTED)
-		return -ENOTCONN;
+		skb = skb_dequeue(&chan->tx_q);
+		kfree_skb(skb);
 
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return 0;
+		chan->unacked_frames--;
+	}
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return 0;
+	if (!chan->unacked_frames)
+		__clear_retrans_timer(chan);
+}
 
-	while (sk->sk_send_head && (pi->unacked_frames < pi->remote_tx_win) &&
-		atomic_read(&pi->ertm_queued) < L2CAP_MAX_ERTM_QUEUED &&
-		(pi->tx_state == L2CAP_ERTM_TX_STATE_XMIT)) {
-
-		skb = sk->sk_send_head;
-
-		bt_cb(skb)->retries = 1;
-		control = &bt_cb(skb)->control;
-
-		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-			control->final = 1;
-			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-		}
-		control->reqseq = pi->buffer_seq;
-		pi->last_acked_seq = pi->buffer_seq;
-		control->txseq = pi->next_tx_seq;
-
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		}
+static void l2cap_streaming_send(struct l2cap_chan *chan)
+{
+	struct sk_buff *skb;
+	u32 control;
+	u16 fcs;
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(skb);
+	while ((skb = skb_dequeue(&chan->tx_q))) {
+		control = __get_control(chan, skb->data + L2CAP_HDR_SIZE);
+		control |= __set_txseq(chan, chan->next_tx_seq);
+		__put_control(chan, control, skb->data + L2CAP_HDR_SIZE);
 
-		/* Clone after data has been modified. Data is assumed to be
-		   read-only (for locking purposes) on cloned sk_buffs.
-		 */
-		tx_skb = skb_clone(skb, GFP_ATOMIC);
+		if (chan->fcs == L2CAP_FCS_CRC16) {
+			fcs = crc16(0, (u8 *)skb->data,
+						skb->len - L2CAP_FCS_SIZE);
+			put_unaligned_le16(fcs,
+					skb->data + skb->len - L2CAP_FCS_SIZE);
+		}
 
-		if (!tx_skb)
-			break;
+		l2cap_do_send(chan, skb);
 
-		sock_hold(sk);
-		tx_skb->sk = sk;
-		tx_skb->destructor = l2cap_skb_destructor;
-		atomic_inc(&pi->ertm_queued);
+		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
+	}
+}
 
-		l2cap_ertm_start_retrans_timer(pi);
+static void l2cap_retransmit_one_frame(struct l2cap_chan *chan, u16 tx_seq)
+{
+	struct sk_buff *skb, *tx_skb;
+	u16 fcs;
+	u32 control;
 
-		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
-		pi->unacked_frames += 1;
-		pi->frames_sent += 1;
-		sent += 1;
+	skb = skb_peek(&chan->tx_q);
+	if (!skb)
+		return;
 
-		if (skb_queue_is_last(TX_QUEUE(sk), skb))
-			sk->sk_send_head = NULL;
-		else
-			sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);
+	while (bt_cb(skb)->tx_seq != tx_seq) {
+		if (skb_queue_is_last(&chan->tx_q, skb))
+			return;
 
-		l2cap_do_send(sk, tx_skb);
-		BT_DBG("Sent txseq %d", (int)control->txseq);
+		skb = skb_queue_next(&chan->tx_q, skb);
 	}
 
-	BT_DBG("Sent %d, %d unacked, %d in ERTM queue, %d in HCI queue", sent,
-		(int) pi->unacked_frames, skb_queue_len(TX_QUEUE(sk)),
-		atomic_read(&pi->ertm_queued));
+	if (chan->remote_max_tx &&
+			bt_cb(skb)->retries == chan->remote_max_tx) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+		return;
+	}
 
-	return sent;
+	tx_skb = skb_clone(skb, GFP_ATOMIC);
+	bt_cb(skb)->retries++;
+
+	control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
+	control &= __get_sar_mask(chan);
+
+	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+		control |= __set_ctrl_final(chan);
+
+	control |= __set_reqseq(chan, chan->buffer_seq);
+	control |= __set_txseq(chan, tx_seq);
+
+	__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
+
+	if (chan->fcs == L2CAP_FCS_CRC16) {
+		fcs = crc16(0, (u8 *)tx_skb->data,
+						tx_skb->len - L2CAP_FCS_SIZE);
+		put_unaligned_le16(fcs,
+				tx_skb->data + tx_skb->len - L2CAP_FCS_SIZE);
+	}
+
+	l2cap_do_send(chan, tx_skb);
 }
 
-int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs)
+static int l2cap_ertm_send(struct l2cap_chan *chan)
 {
-	struct sk_buff *skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control *control;
-	int sent = 0;
-
-	BT_DBG("sk %p, skbs %p", sk, skbs);
+	struct sk_buff *skb, *tx_skb;
+	u16 fcs;
+	u32 control;
+	int nsent = 0;
 
-	if (sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_CONNECTED)
 		return -ENOTCONN;
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return 0;
+	while ((skb = chan->tx_send_head) && (!l2cap_tx_window_full(chan))) {
 
-	skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
+		if (chan->remote_max_tx &&
+				bt_cb(skb)->retries == chan->remote_max_tx) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+			break;
+		}
 
-	BT_DBG("skb queue empty 0x%2.2x", skb_queue_empty(TX_QUEUE(sk)));
-	while (!skb_queue_empty(TX_QUEUE(sk))) {
+		tx_skb = skb_clone(skb, GFP_ATOMIC);
 
-		skb = skb_dequeue(TX_QUEUE(sk));
+		bt_cb(skb)->retries++;
 
-		BT_DBG("skb %p", skb);
+		control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
+		control &= __get_sar_mask(chan);
 
-		bt_cb(skb)->retries = 1;
-		control = &bt_cb(skb)->control;
+		if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+			control |= __set_ctrl_final(chan);
 
-		BT_DBG("control %p", control);
+		control |= __set_reqseq(chan, chan->buffer_seq);
+		control |= __set_txseq(chan, chan->next_tx_seq);
 
-		control->reqseq = 0;
-		control->txseq = pi->next_tx_seq;
+		__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
 
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(control),
-					skb->data + L2CAP_HDR_SIZE);
+		if (chan->fcs == L2CAP_FCS_CRC16) {
+			fcs = crc16(0, (u8 *)skb->data,
+						tx_skb->len - L2CAP_FCS_SIZE);
+			put_unaligned_le16(fcs, skb->data +
+						tx_skb->len - L2CAP_FCS_SIZE);
 		}
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(skb);
-
-		l2cap_do_send(sk, skb);
+		l2cap_do_send(chan, tx_skb);
 
-		BT_DBG("Sent txseq %d", (int)control->txseq);
+		__set_retrans_timer(chan);
 
-		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
-		pi->frames_sent += 1;
-		sent += 1;
-	}
+		bt_cb(skb)->tx_seq = chan->next_tx_seq;
 
-	BT_DBG("Sent %d", sent);
+		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
 
-	return 0;
-}
+		if (bt_cb(skb)->retries == 1) {
+			chan->unacked_frames++;
 
-static int memcpy_fromkvec(unsigned char *kdata, struct kvec *iv, int len)
-{
-	while (len > 0) {
-		if (iv->iov_len) {
-			int copy = min_t(unsigned int, len, iv->iov_len);
-			memcpy(kdata, iv->iov_base, copy);
-			len -= copy;
-			kdata += copy;
-			iv->iov_base += copy;
-			iv->iov_len -= copy;
+			if (!nsent++)
+				__clear_ack_timer(chan);
 		}
-		iv++;
+
+		chan->frames_sent++;
+
+		if (skb_queue_is_last(&chan->tx_q, skb))
+			chan->tx_send_head = NULL;
+		else
+			chan->tx_send_head = skb_queue_next(&chan->tx_q, skb);
 	}
 
-	return 0;
+	return nsent;
 }
 
-static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg,
-					int len, int count, struct sk_buff *skb,
-					int reseg)
+static int l2cap_retransmit_frames(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff **frag;
-	struct sk_buff *final;
-	int err, sent = 0;
+	int ret;
 
-	BT_DBG("sk %p, msg %p, len %d, count %d, skb %p", sk,
-		msg, (int)len, (int)count, skb);
+	if (!skb_queue_empty(&chan->tx_q))
+		chan->tx_send_head = chan->tx_q.next;
 
-	if (!conn)
-		return -ENOTCONN;
+	chan->next_tx_seq = chan->expected_ack_seq;
+	ret = l2cap_ertm_send(chan);
+	return ret;
+}
 
-	/* When resegmenting, data is copied from kernel space */
-	if (reseg) {
-		err = memcpy_fromkvec(skb_put(skb, count),
-				(struct kvec *) msg->msg_iov, count);
-	} else {
-		err = memcpy_fromiovec(skb_put(skb, count), msg->msg_iov,
-					count);
-	}
+static void __l2cap_send_ack(struct l2cap_chan *chan)
+{
+	u32 control = 0;
 
-	if (err)
-		return -EFAULT;
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-	sent += count;
-	len  -= count;
-	final = skb;
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+		l2cap_send_sframe(chan, control);
+		return;
+	}
 
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		int skblen;
-		count = min_t(unsigned int, conn->mtu, len);
+	if (l2cap_ertm_send(chan) > 0)
+		return;
 
-		/* Add room for the FCS if it fits */
-		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16 &&
-			len + L2CAP_FCS_SIZE <= conn->mtu)
-			skblen = count + L2CAP_FCS_SIZE;
-		else
-			skblen = count;
+	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+	l2cap_send_sframe(chan, control);
+}
 
-		/* Don't use bt_skb_send_alloc() while resegmenting, since
-		 * it is not ok to block.
-		 */
-		if (reseg) {
-			*frag = bt_skb_alloc(skblen, GFP_ATOMIC);
-			if (*frag)
-				skb_set_owner_w(*frag, sk);
-		} else {
-			*frag = bt_skb_send_alloc(sk, skblen,
-					msg->msg_flags & MSG_DONTWAIT, &err);
-		}
+static void l2cap_send_ack(struct l2cap_chan *chan)
+{
+	__clear_ack_timer(chan);
+	__l2cap_send_ack(chan);
+}
 
-		if (!*frag)
-			return -EFAULT;
+static void l2cap_send_srejtail(struct l2cap_chan *chan)
+{
+	struct srej_list *tail;
+	u32 control;
 
-		/* When resegmenting, data is copied from kernel space */
-		if (reseg) {
-			err = memcpy_fromkvec(skb_put(*frag, count),
-						(struct kvec *) msg->msg_iov,
-						count);
-		} else {
-			err = memcpy_fromiovec(skb_put(*frag, count),
-						msg->msg_iov, count);
-		}
+	control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+	control |= __set_ctrl_final(chan);
 
-		if (err)
-			return -EFAULT;
+	tail = list_entry((&chan->srej_l)->prev, struct srej_list, list);
+	control |= __set_reqseq(chan, tail->tx_seq);
 
-		sent += count;
-		len  -= count;
+	l2cap_send_sframe(chan, control);
+}
+
+static inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,
+					 struct msghdr *msg, int len,
+					 int count, struct sk_buff *skb)
+{
+	struct l2cap_conn *conn = chan->conn;
+	struct sk_buff **frag;
+	int err, sent = 0;
 
-		final = *frag;
+	if (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count))
+		return -EFAULT;
 
-		frag = &(*frag)->next;
-	}
+	sent += count;
+	len  -= count;
 
-	if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16) {
-		if (skb_tailroom(final) < L2CAP_FCS_SIZE) {
-			if (reseg) {
-				*frag = bt_skb_alloc(L2CAP_FCS_SIZE,
-						GFP_ATOMIC);
-				if (*frag)
-					skb_set_owner_w(*frag, sk);
-			} else {
-				*frag = bt_skb_send_alloc(sk, L2CAP_FCS_SIZE,
-						msg->msg_flags & MSG_DONTWAIT,
-						&err);
-			}
+	/* Continuation fragments (no L2CAP header) */
+	frag = &skb_shinfo(skb)->frag_list;
+	while (len) {
+		count = min_t(unsigned int, conn->mtu, len);
 
-			if (!*frag)
-				return -EFAULT;
+		*frag = chan->ops->alloc_skb(chan, count,
+					     msg->msg_flags & MSG_DONTWAIT,
+					     &err);
 
-			final = *frag;
-		}
+		if (!*frag)
+			return err;
+		if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count))
+			return -EFAULT;
+
+		(*frag)->priority = skb->priority;
 
-		skb_put(final, L2CAP_FCS_SIZE);
+		sent += count;
+		len  -= count;
+
+		frag = &(*frag)->next;
 	}
 
 	return sent;
 }
 
-struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len)
+static struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 priority)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE + 2;
+	int err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;
 	struct l2cap_hdr *lh;
 
-	BT_DBG("sk %p len %d", sk, (int)len);
+	BT_DBG("chan %p len %d priority %u", chan, (int)len, priority);
 
 	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
+
+	skb = chan->ops->alloc_skb(chan, count + hlen,
+				   msg->msg_flags & MSG_DONTWAIT, &err);
+
 	if (!skb)
 		return ERR_PTR(err);
 
+	skb->priority = priority;
+
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->cid = cpu_to_le16(chan->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-	put_unaligned_le16(l2cap_pi(sk)->psm, skb_put(skb, 2));
+	put_unaligned_le16(chan->psm, skb_put(skb, 2));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1748,27 +1624,33 @@
 	return skb;
 }
 
-struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len)
+static struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 priority)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
 	int err, count, hlen = L2CAP_HDR_SIZE;
 	struct l2cap_hdr *lh;
 
-	BT_DBG("sk %p len %d", sk, (int)len);
+	BT_DBG("chan %p len %d", chan, (int)len);
 
 	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
+
+	skb = chan->ops->alloc_skb(chan, count + hlen,
+				   msg->msg_flags & MSG_DONTWAIT, &err);
+
 	if (!skb)
 		return ERR_PTR(err);
 
+	skb->priority = priority;
+
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->cid = cpu_to_le16(chan->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1776,3919 +1658,1753 @@
 	return skb;
 }
 
-struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk,
-					struct msghdr *msg, size_t len,
-					u16 sdulen, int reseg)
+static struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 control, u16 sdulen)
 {
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
-	int err = 0, count = 0, hlen = 0;
-	int reserve = 0;
+	int err, count, hlen;
 	struct l2cap_hdr *lh;
-	u8 fcs = l2cap_pi(sk)->fcs;
 
-	if (l2cap_pi(sk)->extended_control)
-		hlen = L2CAP_EXTENDED_HDR_SIZE;
+	BT_DBG("chan %p len %d", chan, (int)len);
+
+	if (!conn)
+		return ERR_PTR(-ENOTCONN);
+
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hlen = L2CAP_EXT_HDR_SIZE;
 	else
-		hlen = L2CAP_ENHANCED_HDR_SIZE;
+		hlen = L2CAP_ENH_HDR_SIZE;
 
 	if (sdulen)
 		hlen += L2CAP_SDULEN_SIZE;
 
-	if (fcs == L2CAP_FCS_CRC16)
+	if (chan->fcs == L2CAP_FCS_CRC16)
 		hlen += L2CAP_FCS_SIZE;
 
-	BT_DBG("sk %p, msg %p, len %d, sdulen %d, hlen %d",
-		sk, msg, (int)len, (int)sdulen, hlen);
-
-	count = min_t(unsigned int, (l2cap_pi(sk)->conn->mtu - hlen), len);
-
-	/* Allocate extra headroom for Qualcomm PAL.  This is only
-	 * necessary in two places (here and when creating sframes)
-	 * because only unfragmented iframes and sframes are sent
-	 * using AMP controllers.
-	 */
-	if (l2cap_pi(sk)->ampcon &&
-			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
+	count = min_t(unsigned int, (conn->mtu - hlen), len);
 
-	/* Don't use bt_skb_send_alloc() while resegmenting, since
-	 * it is not ok to block.
-	 */
-	if (reseg) {
-		skb = bt_skb_alloc(count + hlen + reserve, GFP_ATOMIC);
-		if (skb)
-			skb_set_owner_w(skb, sk);
-	} else {
-		skb = bt_skb_send_alloc(sk, count + hlen + reserve,
+	skb = chan->ops->alloc_skb(chan, count + hlen,
 					msg->msg_flags & MSG_DONTWAIT, &err);
-	}
+
 	if (!skb)
 		return ERR_PTR(err);
 
-	if (reserve)
-		skb_reserve(skb, reserve);
-
-	bt_cb(skb)->control.fcs = fcs;
-
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len + hlen - L2CAP_HDR_SIZE);
+	lh->cid = cpu_to_le16(chan->dcid);
+	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
-	/* Control header is populated later */
-	if (l2cap_pi(sk)->extended_control)
-		put_unaligned_le32(0, skb_put(skb, 4));
-	else
-		put_unaligned_le16(0, skb_put(skb, 2));
+	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
 
 	if (sdulen)
 		put_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, reseg);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
-		BT_DBG("err %d", err);
 		kfree_skb(skb);
 		return ERR_PTR(err);
 	}
 
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		put_unaligned_le16(0, skb_put(skb, L2CAP_FCS_SIZE));
+
 	bt_cb(skb)->retries = 0;
 	return skb;
 }
 
-static void l2cap_ertm_process_reqseq(struct sock *sk, u16 reqseq)
+static int l2cap_sar_segment_sdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *acked_skb;
-	u16 ackseq;
-
-	BT_DBG("sk %p, reqseq %d", sk, (int) reqseq);
-
-	pi = l2cap_pi(sk);
-
-	if (pi->unacked_frames == 0 || reqseq == pi->expected_ack_seq)
-		return;
-
-	BT_DBG("expected_ack_seq %d, unacked_frames %d",
-		(int) pi->expected_ack_seq, (int) pi->unacked_frames);
+	struct sk_buff *skb;
+	struct sk_buff_head sar_queue;
+	u32 control;
+	size_t size = 0;
+
+	skb_queue_head_init(&sar_queue);
+	control = __set_ctrl_sar(chan, L2CAP_SAR_START);
+	skb = l2cap_create_iframe_pdu(chan, msg, chan->remote_mps, control, len);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	__skb_queue_tail(&sar_queue, skb);
+	len -= chan->remote_mps;
+	size += chan->remote_mps;
 
-	for (ackseq = pi->expected_ack_seq; ackseq != reqseq;
-		ackseq = __next_seq(ackseq, pi)) {
+	while (len > 0) {
+		size_t buflen;
 
-		acked_skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), ackseq);
-		if (acked_skb) {
-			skb_unlink(acked_skb, TX_QUEUE(sk));
-			kfree_skb(acked_skb);
-			pi->unacked_frames--;
+		if (len > chan->remote_mps) {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_CONTINUE);
+			buflen = chan->remote_mps;
+		} else {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_END);
+			buflen = len;
 		}
-	}
 
-	pi->expected_ack_seq = reqseq;
+		skb = l2cap_create_iframe_pdu(chan, msg, buflen, control, 0);
+		if (IS_ERR(skb)) {
+			skb_queue_purge(&sar_queue);
+			return PTR_ERR(skb);
+		}
 
-	if (pi->unacked_frames == 0)
-		l2cap_ertm_stop_retrans_timer(pi);
+		__skb_queue_tail(&sar_queue, skb);
+		len -= buflen;
+		size += buflen;
+	}
+	skb_queue_splice_tail(&sar_queue, &chan->tx_q);
+	if (chan->tx_send_head == NULL)
+		chan->tx_send_head = sar_queue.next;
 
-	BT_DBG("unacked_frames %d", (int) pi->unacked_frames);
+	return size;
 }
 
-static struct sk_buff *l2cap_create_sframe_pdu(struct sock *sk, u32 control)
+int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
+								u32 priority)
 {
 	struct sk_buff *skb;
-	int len;
-	int reserve = 0;
-	struct l2cap_hdr *lh;
+	u32 control;
+	int err;
 
-	if (l2cap_pi(sk)->extended_control)
-		len = L2CAP_EXTENDED_HDR_SIZE;
-	else
-		len = L2CAP_ENHANCED_HDR_SIZE;
+	/* Connectionless channel */
+	if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
+		skb = l2cap_create_connless_pdu(chan, msg, len, priority);
+		if (IS_ERR(skb))
+			return PTR_ERR(skb);
 
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16)
-		len += L2CAP_FCS_SIZE;
+		l2cap_do_send(chan, skb);
+		return len;
+	}
 
-	/* Allocate extra headroom for Qualcomm PAL */
-	if (l2cap_pi(sk)->ampcon &&
-			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		/* Check outgoing MTU */
+		if (len > chan->omtu)
+			return -EMSGSIZE;
+
+		/* Create a basic PDU */
+		skb = l2cap_create_basic_pdu(chan, msg, len, priority);
+		if (IS_ERR(skb))
+			return PTR_ERR(skb);
 
-	skb = bt_skb_alloc(len + reserve, GFP_ATOMIC);
+		l2cap_do_send(chan, skb);
+		err = len;
+		break;
 
-	if (!skb)
-		return ERR_PTR(-ENOMEM);
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+		/* Entire SDU fits into one PDU */
+		if (len <= chan->remote_mps) {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_UNSEGMENTED);
+			skb = l2cap_create_iframe_pdu(chan, msg, len, control,
+									0);
+			if (IS_ERR(skb))
+				return PTR_ERR(skb);
 
-	if (reserve)
-		skb_reserve(skb, reserve);
+			__skb_queue_tail(&chan->tx_q, skb);
 
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len - L2CAP_HDR_SIZE);
+			if (chan->tx_send_head == NULL)
+				chan->tx_send_head = skb;
 
-	if (l2cap_pi(sk)->extended_control)
-		put_unaligned_le32(control, skb_put(skb, 4));
-	else
-		put_unaligned_le16(control, skb_put(skb, 2));
+		} else {
+			/* Segment SDU into multiples PDUs */
+			err = l2cap_sar_segment_sdu(chan, msg, len);
+			if (err < 0)
+				return err;
+		}
 
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16) {
-		u16 fcs = crc16(0, (u8 *) skb->data, skb->len);
-		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
-	}
+		if (chan->mode == L2CAP_MODE_STREAMING) {
+			l2cap_streaming_send(chan);
+			err = len;
+			break;
+		}
 
-	return skb;
-}
+		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+				test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			err = len;
+			break;
+		}
 
-static void l2cap_ertm_send_sframe(struct sock *sk,
-				struct bt_l2cap_control *control)
-{
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-	u32 control_field;
+		err = l2cap_ertm_send(chan);
+		if (err >= 0)
+			err = len;
 
-	BT_DBG("sk %p, control %p", sk, control);
+		break;
 
-	if (control->frame_type != 's')
-		return;
+	default:
+		BT_DBG("bad state %1.1x", chan->mode);
+		err = -EBADFD;
+	}
 
-	pi = l2cap_pi(sk);
+	return err;
+}
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
-		BT_DBG("AMP error - attempted S-Frame send during AMP move");
-		return;
-	}
+/* Copy frame to all raw sockets on that connection */
+static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+	struct l2cap_chan *chan;
 
-	if ((pi->conn_state & L2CAP_CONN_SEND_FBIT) && !control->poll) {
-		control->final = 1;
-		pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-	}
+	BT_DBG("conn %p", conn);
 
-	if (control->super == L2CAP_SFRAME_RR)
-		pi->conn_state &= ~L2CAP_CONN_SENT_RNR;
-	else if (control->super == L2CAP_SFRAME_RNR)
-		pi->conn_state |= L2CAP_CONN_SENT_RNR;
+	mutex_lock(&conn->chan_lock);
 
-	if (control->super != L2CAP_SFRAME_SREJ) {
-		pi->last_acked_seq = control->reqseq;
-		l2cap_ertm_stop_ack_timer(pi);
-	}
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		struct sock *sk = chan->sk;
+		if (chan->chan_type != L2CAP_CHAN_RAW)
+			continue;
 
-	BT_DBG("reqseq %d, final %d, poll %d, super %d", (int) control->reqseq,
-		(int) control->final, (int) control->poll,
-		(int) control->super);
+		/* Don't send frame to the socket it came from */
+		if (skb->sk == sk)
+			continue;
+		nskb = skb_clone(skb, GFP_ATOMIC);
+		if (!nskb)
+			continue;
 
-	if (pi->extended_control)
-		control_field = __pack_extended_control(control);
-	else
-		control_field = __pack_enhanced_control(control);
+		if (chan->ops->recv(chan->data, nskb))
+			kfree_skb(nskb);
+	}
 
-	skb = l2cap_create_sframe_pdu(sk, control_field);
-	if (!IS_ERR(skb))
-		l2cap_do_send(sk, skb);
+	mutex_unlock(&conn->chan_lock);
 }
 
-static void l2cap_ertm_send_ack(struct sock *sk)
+/* ---- L2CAP signalling commands ---- */
+static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
+				u8 code, u8 ident, u16 dlen, void *data)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control control;
-	u16 frames_to_ack = __delta_seq(pi->buffer_seq, pi->last_acked_seq, pi);
-	int threshold;
+	struct sk_buff *skb, **frag;
+	struct l2cap_cmd_hdr *cmd;
+	struct l2cap_hdr *lh;
+	int len, count;
 
-	BT_DBG("sk %p", sk);
-	BT_DBG("last_acked_seq %d, buffer_seq %d", (int)pi->last_acked_seq,
-		(int)pi->buffer_seq);
+	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
+			conn, code, ident, dlen);
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
+	if (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)
+		return NULL;
 
-	if ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-		pi->rx_state == L2CAP_ERTM_RX_STATE_RECV) {
-		l2cap_ertm_stop_ack_timer(pi);
-		control.super = L2CAP_SFRAME_RNR;
-		control.reqseq = pi->buffer_seq;
-		l2cap_ertm_send_sframe(sk, &control);
-	} else {
-		if (!(pi->conn_state & L2CAP_CONN_REMOTE_BUSY)) {
-			l2cap_ertm_send(sk);
-			/* If any i-frames were sent, they included an ack */
-			if (pi->buffer_seq == pi->last_acked_seq)
-				frames_to_ack = 0;
-		}
+	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
+	count = min_t(unsigned int, conn->mtu, len);
 
-		/* Ack now if the window is 3/4ths full.
-		 * Calculate without mul or div
-		 */
-		threshold = pi->ack_win;
-		threshold += threshold << 1;
-		threshold >>= 2;
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
+	if (!skb)
+		return NULL;
 
-		BT_DBG("frames_to_ack %d, threshold %d", (int)frames_to_ack,
-			threshold);
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
 
-		if (frames_to_ack >= threshold) {
-			l2cap_ertm_stop_ack_timer(pi);
-			control.super = L2CAP_SFRAME_RR;
-			control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &control);
-			frames_to_ack = 0;
-		}
+	if (conn->hcon->type == LE_LINK)
+		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
+	else
+		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
+
+	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
+	cmd->code  = code;
+	cmd->ident = ident;
+	cmd->len   = cpu_to_le16(dlen);
 
-		if (frames_to_ack)
-			l2cap_ertm_start_ack_timer(pi);
+	if (dlen) {
+		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
+		memcpy(skb_put(skb, count), data, count);
+		data += count;
 	}
-}
 
-static void l2cap_ertm_send_rr_or_rnr(struct sock *sk, bool poll)
-{
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
+	len -= skb->len;
+
+	/* Continuation fragments (no L2CAP header) */
+	frag = &skb_shinfo(skb)->frag_list;
+	while (len) {
+		count = min_t(unsigned int, conn->mtu, len);
+
+		*frag = bt_skb_alloc(count, GFP_ATOMIC);
+		if (!*frag)
+			goto fail;
 
-	BT_DBG("sk %p, poll %d", sk, (int) poll);
+		memcpy(skb_put(*frag, count), data, count);
 
-	pi = l2cap_pi(sk);
+		len  -= count;
+		data += count;
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.poll = poll;
+		frag = &(*frag)->next;
+	}
 
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
-		control.super = L2CAP_SFRAME_RNR;
-	else
-		control.super = L2CAP_SFRAME_RR;
+	return skb;
 
-	control.reqseq = pi->buffer_seq;
-	l2cap_ertm_send_sframe(sk, &control);
+fail:
+	kfree_skb(skb);
+	return NULL;
 }
 
-static void l2cap_ertm_send_i_or_rr_or_rnr(struct sock *sk)
+static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
 {
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
+	struct l2cap_conf_opt *opt = *ptr;
+	int len;
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.final = 1;
-	control.reqseq = pi->buffer_seq;
-	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+	len = L2CAP_CONF_OPT_SIZE + opt->len;
+	*ptr += len;
 
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		control.super = L2CAP_SFRAME_RNR;
-		l2cap_ertm_send_sframe(sk, &control);
-	}
+	*type = opt->type;
+	*olen = opt->len;
 
-	if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-		(pi->unacked_frames > 0))
-		l2cap_ertm_start_retrans_timer(pi);
+	switch (opt->len) {
+	case 1:
+		*val = *((u8 *) opt->val);
+		break;
 
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	case 2:
+		*val = get_unaligned_le16(opt->val);
+		break;
 
-	/* Send pending iframes */
-	l2cap_ertm_send(sk);
+	case 4:
+		*val = get_unaligned_le32(opt->val);
+		break;
 
-	if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-		/* F-bit wasn't sent in an s-frame or i-frame yet, so
-		 * send it now.
-		 */
-		control.super = L2CAP_SFRAME_RR;
-		l2cap_ertm_send_sframe(sk, &control);
+	default:
+		*val = (unsigned long) opt->val;
+		break;
 	}
+
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
+	return len;
 }
 
-static void l2cap_ertm_send_srej(struct sock *sk, u16 txseq)
+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	u16 seq;
+	struct l2cap_conf_opt *opt = *ptr;
 
-	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
 
-	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
+	opt->type = type;
+	opt->len  = len;
 
-	for (seq = pi->expected_tx_seq; seq != txseq;
-		seq = __next_seq(seq, pi)) {
-		if (!l2cap_ertm_seq_in_queue(SREJ_QUEUE(pi), seq)) {
-			control.reqseq = seq;
-			l2cap_ertm_send_sframe(sk, &control);
-			l2cap_seq_list_append(&pi->srej_list, seq);
-		}
+	switch (len) {
+	case 1:
+		*((u8 *) opt->val)  = val;
+		break;
+
+	case 2:
+		put_unaligned_le16(val, opt->val);
+		break;
+
+	case 4:
+		put_unaligned_le32(val, opt->val);
+		break;
+
+	default:
+		memcpy(opt->val, (void *) val, len);
+		break;
 	}
 
-	pi->expected_tx_seq = __next_seq(txseq, pi);
+	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
-static void l2cap_ertm_send_srej_tail(struct sock *sk)
+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
+	struct l2cap_conf_efs efs;
 
-	BT_DBG("sk %p", sk);
+	switch (chan->mode) {
+	case L2CAP_MODE_ERTM:
+		efs.id		= chan->local_id;
+		efs.stype	= chan->local_stype;
+		efs.msdu	= cpu_to_le16(chan->local_msdu);
+		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
+		efs.acc_lat	= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);
+		efs.flush_to	= cpu_to_le32(L2CAP_DEFAULT_FLUSH_TO);
+		break;
 
-	pi = l2cap_pi(sk);
+	case L2CAP_MODE_STREAMING:
+		efs.id		= 1;
+		efs.stype	= L2CAP_SERV_BESTEFFORT;
+		efs.msdu	= cpu_to_le16(chan->local_msdu);
+		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
+		efs.acc_lat	= 0;
+		efs.flush_to	= 0;
+		break;
 
-	if (pi->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)
+	default:
 		return;
+	}
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
-	control.reqseq = pi->srej_list.tail;
-	l2cap_ertm_send_sframe(sk, &control);
+	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
+							(unsigned long) &efs);
 }
 
-static void l2cap_ertm_send_srej_list(struct sock *sk, u16 txseq)
+static void l2cap_ack_timeout(struct work_struct *work)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	u16 initial_head;
-	u16 seq;
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							ack_timer.work);
 
-	BT_DBG("sk %p, txseq %d", sk, (int) txseq);
+	BT_DBG("chan %p", chan);
 
-	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
+	l2cap_chan_lock(chan);
 
-	/* Capture initial list head to allow only one pass through the list. */
-	initial_head = pi->srej_list.head;
+	__l2cap_send_ack(chan);
 
-	do {
-		seq = l2cap_seq_list_pop(&pi->srej_list);
-		if ((seq == txseq) || (seq == L2CAP_SEQ_LIST_CLEAR))
-			break;
+	l2cap_chan_unlock(chan);
 
-		control.reqseq = seq;
-		l2cap_ertm_send_sframe(sk, &control);
-		l2cap_seq_list_append(&pi->srej_list, seq);
-	} while (pi->srej_list.head != initial_head);
+	l2cap_chan_put(chan);
 }
 
-static void l2cap_ertm_abort_rx_srej_sent(struct sock *sk)
+static inline void l2cap_ertm_init(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	BT_DBG("sk %p", sk);
+	chan->expected_ack_seq = 0;
+	chan->unacked_frames = 0;
+	chan->buffer_seq = 0;
+	chan->num_acked = 0;
+	chan->frames_sent = 0;
 
-	pi->expected_tx_seq = pi->buffer_seq;
-	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
-	skb_queue_purge(SREJ_QUEUE(sk));
-	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-}
+	INIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);
+	INIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);
+	INIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);
 
-static int l2cap_ertm_tx_state_xmit(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff_head *skbs, u8 event)
-{
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	skb_queue_head_init(&chan->srej_q);
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_DATA_REQUEST:
-		if (sk->sk_send_head == NULL)
-			sk->sk_send_head = skb_peek(skbs);
-
-		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
-		l2cap_ertm_send(sk);
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
-		BT_DBG("Enter LOCAL_BUSY");
-		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-			/* The SREJ_SENT state must be aborted if we are to
-			 * enter the LOCAL_BUSY state.
-			 */
-			l2cap_ertm_abort_rx_srej_sent(sk);
-		}
-
-		l2cap_ertm_send_ack(sk);
-
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
-		BT_DBG("Exit LOCAL_BUSY");
-		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_LOCAL_BUSY) {
-			if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(pi->conn, pi,
-						pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			} else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_RESPONDER) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-						pi->amp_move_cmd_ident,
-						pi->dcid,
-						L2CAP_MOVE_CHAN_SUCCESS);
-			}
-			break;
-		}
+	INIT_LIST_HEAD(&chan->srej_l);
+}
 
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_NONE &&
-			(pi->conn_state & L2CAP_CONN_SENT_RNR)) {
-			struct bt_l2cap_control local_control;
-
-			memset(&local_control, 0, sizeof(local_control));
-			local_control.frame_type = 's';
-			local_control.super = L2CAP_SFRAME_RR;
-			local_control.poll = 1;
-			local_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &local_control);
-
-			pi->retry_count = 1;
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-		break;
-	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
-		l2cap_ertm_send_rr_or_rnr(sk, 1);
-		pi->retry_count = 1;
-		l2cap_ertm_start_monitor_timer(pi);
-		l2cap_ertm_stop_ack_timer(pi);
-		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		break;
-	case L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES:
-		l2cap_ertm_send_rr_or_rnr(sk, 1);
-		pi->retry_count = 1;
-		l2cap_ertm_start_monitor_timer(pi);
-		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		break;
-	case L2CAP_ERTM_EVENT_RECV_FBIT:
-		/* Nothing to process */
-		break;
+static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
+{
+	switch (mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (l2cap_mode_supported(mode, remote_feat_mask))
+			return mode;
+		/* fall through */
 	default:
-		break;
+		return L2CAP_MODE_BASIC;
 	}
-
-	return err;
 }
 
-static int l2cap_ertm_tx_state_wait_f(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff_head *skbs, u8 event)
+static inline bool __l2cap_ews_supported(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW;
+}
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_DATA_REQUEST:
-		if (sk->sk_send_head == NULL)
-			sk->sk_send_head = skb_peek(skbs);
-		/* Queue data, but don't send. */
-		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
-		BT_DBG("Enter LOCAL_BUSY");
-		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-			/* The SREJ_SENT state must be aborted if we are to
-			 * enter the LOCAL_BUSY state.
-			 */
-			l2cap_ertm_abort_rx_srej_sent(sk);
-		}
-
-		l2cap_ertm_send_ack(sk);
-
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
-		BT_DBG("Exit LOCAL_BUSY");
-		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->conn_state & L2CAP_CONN_SENT_RNR) {
-			struct bt_l2cap_control local_control;
-			memset(&local_control, 0, sizeof(local_control));
-			local_control.frame_type = 's';
-			local_control.super = L2CAP_SFRAME_RR;
-			local_control.poll = 1;
-			local_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &local_control);
-
-			pi->retry_count = 1;
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-
-		/* Fall through */
-
-	case L2CAP_ERTM_EVENT_RECV_FBIT:
-		if (control && control->final) {
-			l2cap_ertm_stop_monitor_timer(pi);
-			if (pi->unacked_frames > 0)
-				l2cap_ertm_start_retrans_timer(pi);
-			pi->retry_count = 0;
-			pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-			BT_DBG("recv fbit tx_state 0x2.2%x", pi->tx_state);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
-		/* Ignore */
-		break;
-	case L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES:
-		if ((pi->max_tx == 0) || (pi->retry_count < pi->max_tx)) {
-			l2cap_ertm_send_rr_or_rnr(sk, 1);
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->retry_count += 1;
-		} else
-			l2cap_send_disconn_req(pi->conn, sk, ECONNABORTED);
-		break;
-	default:
-		break;
-	}
+static inline bool __l2cap_efs_supported(struct l2cap_chan *chan)
+{
+	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_FLOW;
+}
 
-	return err;
+static inline void l2cap_txwin_setup(struct l2cap_chan *chan)
+{
+	if (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&
+						__l2cap_ews_supported(chan)) {
+		/* use extended control field */
+		set_bit(FLAG_EXT_CTRL, &chan->flags);
+		chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
+	} else {
+		chan->tx_win = min_t(u16, chan->tx_win,
+						L2CAP_DEFAULT_TX_WINDOW);
+		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
+	}
 }
 
-int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff_head *skbs, u8 event)
+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	struct l2cap_conf_req *req = data;
+	struct l2cap_conf_rfc rfc = { .mode = chan->mode };
+	void *ptr = req->data;
+	u16 size;
+
+	BT_DBG("chan %p", chan);
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d, state %d",
-		sk, control, skbs, (int)event, l2cap_pi(sk)->tx_state);
+	if (chan->num_conf_req || chan->num_conf_rsp)
+		goto done;
+
+	switch (chan->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))
+			break;
 
-	pi = l2cap_pi(sk);
+		if (__l2cap_efs_supported(chan))
+			set_bit(FLAG_EFS_ENABLE, &chan->flags);
 
-	switch (pi->tx_state) {
-	case L2CAP_ERTM_TX_STATE_XMIT:
-		err = l2cap_ertm_tx_state_xmit(sk, control, skbs, event);
-		break;
-	case L2CAP_ERTM_TX_STATE_WAIT_F:
-		err = l2cap_ertm_tx_state_wait_f(sk, control, skbs, event);
-		break;
+		/* fall through */
 	default:
-		/* Ignore event */
+		chan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);
 		break;
 	}
 
-	return err;
-}
+done:
+	if (chan->imtu != L2CAP_DEFAULT_MTU)
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
 
-int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
-			struct msghdr *msg, size_t len, int reseg)
-{
-	struct sk_buff *skb;
-	u16 sdu_len;
-	size_t pdu_len;
-	int err = 0;
-	u8 sar;
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&
+				!(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))
+			break;
 
-	BT_DBG("sk %p, msg %p, len %d", sk, msg, (int)len);
+		rfc.mode            = L2CAP_MODE_BASIC;
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+		rfc.max_pdu_size    = 0;
 
-	/* It is critical that ERTM PDUs fit in a single HCI fragment,
-	 * so fragmented skbs are not used.  The HCI layer's handling
-	 * of fragmented skbs is not compatible with ERTM's queueing.
-	 */
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+		break;
 
-	/* PDU size is derived from the HCI MTU */
-	pdu_len = l2cap_pi(sk)->conn->mtu;
+	case L2CAP_MODE_ERTM:
+		rfc.mode            = L2CAP_MODE_ERTM;
+		rfc.max_transmit    = chan->max_tx;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
 
-	/* Constrain BR/EDR PDU size to fit within the largest radio packet */
-	if (!l2cap_pi(sk)->ampcon)
-		pdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);
-
-	/* Adjust for largest possible L2CAP overhead. */
-	pdu_len -= L2CAP_EXTENDED_HDR_SIZE + L2CAP_FCS_SIZE;
-
-	/* Remote device may have requested smaller PDUs */
-	pdu_len = min_t(size_t, pdu_len, l2cap_pi(sk)->remote_mps);
-
-	if (len <= pdu_len) {
-		sar = L2CAP_SAR_UNSEGMENTED;
-		sdu_len = 0;
-		pdu_len = len;
-	} else {
-		sar = L2CAP_SAR_START;
-		sdu_len = len;
-		pdu_len -= L2CAP_SDULEN_SIZE;
-	}
+		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+		rfc.max_pdu_size = cpu_to_le16(size);
 
-	while (len) {
-		skb = l2cap_create_iframe_pdu(sk, msg, pdu_len, sdu_len, reseg);
+		l2cap_txwin_setup(chan);
 
-		BT_DBG("iframe skb %p", skb);
+		rfc.txwin_size = min_t(u16, chan->tx_win,
+						L2CAP_DEFAULT_TX_WINDOW);
 
-		if (IS_ERR(skb)) {
-			__skb_queue_purge(seg_queue);
-			return PTR_ERR(skb);
-		}
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
+			l2cap_add_opt_efs(&ptr, chan);
 
-		bt_cb(skb)->control.sar = sar;
-		__skb_queue_tail(seg_queue, skb);
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
 
-		len -= pdu_len;
-		if (sdu_len) {
-			sdu_len = 0;
-			pdu_len += L2CAP_SDULEN_SIZE;
+		if (chan->fcs == L2CAP_FCS_NONE ||
+				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
+			chan->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
 		}
 
-		if (len <= pdu_len) {
-			sar = L2CAP_SAR_END;
-			pdu_len = len;
-		} else {
-			sar = L2CAP_SAR_CONTINUE;
+		if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
+								chan->tx_win);
+		break;
+
+	case L2CAP_MODE_STREAMING:
+		rfc.mode            = L2CAP_MODE_STREAMING;
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+
+		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+		rfc.max_pdu_size = cpu_to_le16(size);
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
+			l2cap_add_opt_efs(&ptr, chan);
+
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
+
+		if (chan->fcs == L2CAP_FCS_NONE ||
+				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
+			chan->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
 		}
+		break;
 	}
 
-	return err;
-}
+	req->dcid  = cpu_to_le16(chan->dcid);
+	req->flags = cpu_to_le16(0);
 
-static inline int is_initial_frame(u8 sar)
-{
-	return (sar == L2CAP_SAR_UNSEGMENTED ||
-		sar == L2CAP_SAR_START);
+	return ptr - data;
 }
 
-static inline int l2cap_skbuff_to_kvec(struct sk_buff *skb, struct kvec *iv,
-					size_t veclen)
+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)
 {
-	struct sk_buff *frag_iter;
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = chan->conf_req;
+	int len = chan->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_efs efs;
+	u8 remote_efs = 0;
+	u16 mtu = L2CAP_DEFAULT_MTU;
+	u16 result = L2CAP_CONF_SUCCESS;
+	u16 size;
 
-	BT_DBG("skb %p (len %d), iv %p", skb, (int)skb->len, iv);
+	BT_DBG("chan %p", chan);
 
-	if (iv->iov_len + skb->len > veclen)
-		return -ENOMEM;
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
 
-	memcpy(iv->iov_base + iv->iov_len, skb->data, skb->len);
-	iv->iov_len += skb->len;
+		hint  = type & L2CAP_CONF_HINT;
+		type &= L2CAP_CONF_MASK;
 
-	skb_walk_frags(skb, frag_iter) {
-		if (iv->iov_len + skb->len > veclen)
-			return -ENOMEM;
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			mtu = val;
+			break;
 
-		BT_DBG("Copying %d bytes", (int)frag_iter->len);
-		memcpy(iv->iov_base + iv->iov_len, frag_iter->data,
-			frag_iter->len);
-		iv->iov_len += frag_iter->len;
-	}
+		case L2CAP_CONF_FLUSH_TO:
+			chan->flush_to = val;
+			break;
 
-	return 0;
-}
+		case L2CAP_CONF_QOS:
+			break;
 
-int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue)
-{
-	void *buf;
-	int buflen;
-	int err = 0;
-	struct sk_buff *skb;
-	struct msghdr msg;
-	struct kvec iv;
-	struct sk_buff_head old_frames;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *) val, olen);
+			break;
 
-	BT_DBG("sk %p", sk);
+		case L2CAP_CONF_FCS:
+			if (val == L2CAP_FCS_NONE)
+				set_bit(CONF_NO_FCS_RECV, &chan->conf_state);
+			break;
 
-	if (skb_queue_empty(queue))
-		return 0;
+		case L2CAP_CONF_EFS:
+			remote_efs = 1;
+			if (olen == sizeof(efs))
+				memcpy(&efs, (void *) val, olen);
+			break;
+
+		case L2CAP_CONF_EWS:
+			if (!enable_hs)
+				return -ECONNREFUSED;
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = (struct iovec *) &iv;
+			set_bit(FLAG_EXT_CTRL, &chan->flags);
+			set_bit(CONF_EWS_RECV, &chan->conf_state);
+			chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
+			chan->remote_tx_win = val;
+			break;
 
-	buflen = pi->omtu + L2CAP_FCS_SIZE;
-	buf = kzalloc(buflen, GFP_TEMPORARY);
+		default:
+			if (hint)
+				break;
 
-	if (!buf) {
-		BT_DBG("Could not allocate resegmentation buffer");
-		return -ENOMEM;
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+		}
 	}
 
-	/* Move current frames off the original queue */
-	__skb_queue_head_init(&old_frames);
-	skb_queue_splice_tail_init(queue, &old_frames);
+	if (chan->num_conf_rsp || chan->num_conf_req > 1)
+		goto done;
 
-	while (!skb_queue_empty(&old_frames)) {
-		struct sk_buff_head current_sdu;
-		u8 original_sar;
+	switch (chan->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {
+			chan->mode = l2cap_select_mode(rfc.mode,
+					chan->conn->feat_mask);
+			break;
+		}
 
-		/* Reassemble each SDU from one or more PDUs */
+		if (remote_efs) {
+			if (__l2cap_efs_supported(chan))
+				set_bit(FLAG_EFS_ENABLE, &chan->flags);
+			else
+				return -ECONNREFUSED;
+		}
 
-		iv.iov_base = buf;
-		iv.iov_len = 0;
+		if (chan->mode != rfc.mode)
+			return -ECONNREFUSED;
 
-		skb = skb_peek(&old_frames);
-		original_sar = bt_cb(skb)->control.sar;
+		break;
+	}
 
-		__skb_unlink(skb, &old_frames);
+done:
+	if (chan->mode != rfc.mode) {
+		result = L2CAP_CONF_UNACCEPT;
+		rfc.mode = chan->mode;
 
-		/* Append data to SDU */
-		if (pi->extended_control)
-			skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
-		else
-			skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
+		if (chan->num_conf_rsp == 1)
+			return -ECONNREFUSED;
 
-		if (original_sar == L2CAP_SAR_START)
-			skb_pull(skb, L2CAP_SDULEN_SIZE);
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+	}
 
-		err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
 
-		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
-			iv.iov_len -= L2CAP_FCS_SIZE;
+		if (mtu < L2CAP_DEFAULT_MIN_MTU)
+			result = L2CAP_CONF_UNACCEPT;
+		else {
+			chan->omtu = mtu;
+			set_bit(CONF_MTU_DONE, &chan->conf_state);
+		}
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu);
 
-		/* Free skb */
-		kfree_skb(skb);
+		if (remote_efs) {
+			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != chan->local_stype) {
 
-		if (err)
-			break;
+				result = L2CAP_CONF_UNACCEPT;
 
-		while (!skb_queue_empty(&old_frames) && !err) {
-			/* Check next frame */
-			skb = skb_peek(&old_frames);
+				if (chan->num_conf_req >= 1)
+					return -ECONNREFUSED;
 
-			if (is_initial_frame(bt_cb(skb)->control.sar))
-				break;
+				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+							sizeof(efs),
+							(unsigned long) &efs);
+			} else {
+				/* Send PENDING Conf Rsp */
+				result = L2CAP_CONF_PENDING;
+				set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+			}
+		}
 
-			__skb_unlink(skb, &old_frames);
+		switch (rfc.mode) {
+		case L2CAP_MODE_BASIC:
+			chan->fcs = L2CAP_FCS_NONE;
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
+			break;
 
-			/* Append data to SDU */
-			if (pi->extended_control)
-				skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
+		case L2CAP_MODE_ERTM:
+			if (!test_bit(CONF_EWS_RECV, &chan->conf_state))
+				chan->remote_tx_win = rfc.txwin_size;
 			else
-				skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
+				rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;
 
-			if (bt_cb(skb)->control.sar == L2CAP_SAR_START)
-				skb_pull(skb, L2CAP_SDULEN_SIZE);
+			chan->remote_max_tx = rfc.max_transmit;
 
-			err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
+			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
+						chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+			rfc.max_pdu_size = cpu_to_le16(size);
+			chan->remote_mps = size;
+
+			rfc.retrans_timeout =
+				le16_to_cpu(L2CAP_DEFAULT_RETRANS_TO);
+			rfc.monitor_timeout =
+				le16_to_cpu(L2CAP_DEFAULT_MONITOR_TO);
 
-			if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
-				iv.iov_len -= L2CAP_FCS_SIZE;
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
 
-			/* Free skb */
-			kfree_skb(skb);
-		}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
 
-		if (err)
+			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
+				chan->remote_id = efs.id;
+				chan->remote_stype = efs.stype;
+				chan->remote_msdu = le16_to_cpu(efs.msdu);
+				chan->remote_flush_to =
+						le32_to_cpu(efs.flush_to);
+				chan->remote_acc_lat =
+						le32_to_cpu(efs.acc_lat);
+				chan->remote_sdu_itime =
+					le32_to_cpu(efs.sdu_itime);
+				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+					sizeof(efs), (unsigned long) &efs);
+			}
 			break;
 
-		/* Segment data */
+		case L2CAP_MODE_STREAMING:
+			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
+						chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+			rfc.max_pdu_size = cpu_to_le16(size);
+			chan->remote_mps = size;
 
-		__skb_queue_head_init(&current_sdu);
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
 
-		/* skbs for the SDU were just freed, but the
-		 * resegmenting process could produce more, smaller
-		 * skbs due to smaller PDUs and reduced HCI MTU.  The
-		 * overhead from the sk_buff structs could put us over
-		 * the sk_sndbuf limit.
-		 *
-		 * Since this code is running in response to a
-		 * received poll/final packet, it cannot block.
-		 * Therefore, memory allocation needs to be allowed by
-		 * falling back to bt_skb_alloc() (with
-		 * skb_set_owner_w() to maintain sk_wmem_alloc
-		 * correctly).
-		 */
-		msg.msg_iovlen = iv.iov_len;
-		err = l2cap_segment_sdu(sk, &current_sdu, &msg,
-					msg.msg_iovlen, 1);
-
-		if (err || skb_queue_empty(&current_sdu)) {
-			BT_DBG("Error %d resegmenting data for socket %p",
-				err, sk);
-			__skb_queue_purge(&current_sdu);
-			break;
-		}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
 
-		/* Fix up first PDU SAR bits */
-		if (!is_initial_frame(original_sar)) {
-			BT_DBG("Changing SAR bits, %d PDUs",
-				skb_queue_len(&current_sdu));
-			skb = skb_peek(&current_sdu);
-
-			if (skb_queue_len(&current_sdu) == 1) {
-				/* Change SAR from 'unsegmented' to 'end' */
-				bt_cb(skb)->control.sar = L2CAP_SAR_END;
-			} else {
-				struct l2cap_hdr *lh;
-				size_t hdrlen;
+			break;
 
-				/* Change SAR from 'start' to 'continue' */
-				bt_cb(skb)->control.sar = L2CAP_SAR_CONTINUE;
+		default:
+			result = L2CAP_CONF_UNACCEPT;
 
-				/* Start frames contain 2 bytes for
-				 * sdulen and continue frames don't.
-				 * Must rewrite header to eliminate
-				 * sdulen and then adjust l2cap frame
-				 * length.
-				 */
-				if (pi->extended_control)
-					hdrlen = L2CAP_EXTENDED_HDR_SIZE;
-				else
-					hdrlen = L2CAP_ENHANCED_HDR_SIZE;
-
-				memmove(skb->data + L2CAP_SDULEN_SIZE,
-					skb->data, hdrlen);
-				skb_pull(skb, L2CAP_SDULEN_SIZE);
-				lh = (struct l2cap_hdr *)skb->data;
-				lh->len = cpu_to_le16(le16_to_cpu(lh->len) -
-							L2CAP_SDULEN_SIZE);
-			}
+			memset(&rfc, 0, sizeof(rfc));
+			rfc.mode = chan->mode;
 		}
 
-		/* Add to queue */
-		skb_queue_splice_tail(&current_sdu, queue);
+		if (result == L2CAP_CONF_SUCCESS)
+			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
 	}
+	rsp->scid   = cpu_to_le16(chan->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
 
-	__skb_queue_purge(&old_frames);
-	if (err)
-		__skb_queue_purge(queue);
-
-	kfree(buf);
-
-	BT_DBG("Queue resegmented, err=%d", err);
-	return err;
+	return ptr - data;
 }
 
-static void l2cap_resegment_worker(struct work_struct *work)
+static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, u16 *result)
 {
-	int err = 0;
-	struct l2cap_resegment_work *seg_work =
-		container_of(work, struct l2cap_resegment_work, work);
-	struct sock *sk = seg_work->sk;
+	struct l2cap_conf_req *req = data;
+	void *ptr = req->data;
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_efs efs;
 
-	kfree(seg_work);
+	BT_DBG("chan %p, rsp %p, len %d, req %p", chan, rsp, len, data);
 
-	BT_DBG("sk %p", sk);
-	lock_sock(sk);
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
 
-	if (l2cap_pi(sk)->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
-		release_sock(sk);
-		sock_put(sk);
-		return;
-	}
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			if (val < L2CAP_DEFAULT_MIN_MTU) {
+				*result = L2CAP_CONF_UNACCEPT;
+				chan->imtu = L2CAP_DEFAULT_MIN_MTU;
+			} else
+				chan->imtu = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
+			break;
 
-	err = l2cap_resegment_queue(sk, TX_QUEUE(sk));
+		case L2CAP_CONF_FLUSH_TO:
+			chan->flush_to = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
+							2, chan->flush_to);
+			break;
 
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *)val, olen);
 
-	if (skb_queue_empty(TX_QUEUE(sk)))
-		sk->sk_send_head = NULL;
-	else
-		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
+			if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&
+							rfc.mode != chan->mode)
+				return -ECONNREFUSED;
 
-	if (err)
-		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
-	else
-		l2cap_ertm_send(sk);
+			chan->fcs = 0;
 
-	release_sock(sk);
-	sock_put(sk);
-}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+			break;
 
-static int l2cap_setup_resegment(struct sock *sk)
-{
-	struct l2cap_resegment_work *seg_work;
+		case L2CAP_CONF_EWS:
+			chan->tx_win = min_t(u16, val,
+						L2CAP_DEFAULT_EXT_WINDOW);
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
+							chan->tx_win);
+			break;
 
-	BT_DBG("sk %p", sk);
+		case L2CAP_CONF_EFS:
+			if (olen == sizeof(efs))
+				memcpy(&efs, (void *)val, olen);
+
+			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != chan->local_stype)
+				return -ECONNREFUSED;
 
-	if (skb_queue_empty(TX_QUEUE(sk)))
-		return 0;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+					sizeof(efs), (unsigned long) &efs);
+			break;
+		}
+	}
 
-	seg_work = kzalloc(sizeof(*seg_work), GFP_ATOMIC);
-	if (!seg_work)
-		return -ENOMEM;
+	if (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)
+		return -ECONNREFUSED;
+
+	chan->mode = rfc.mode;
 
-	INIT_WORK(&seg_work->work, l2cap_resegment_worker);
-	sock_hold(sk);
-	seg_work->sk = sk;
+	if (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {
+		switch (rfc.mode) {
+		case L2CAP_MODE_ERTM:
+			chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+			chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+
+			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
+				chan->local_msdu = le16_to_cpu(efs.msdu);
+				chan->local_sdu_itime =
+						le32_to_cpu(efs.sdu_itime);
+				chan->local_acc_lat = le32_to_cpu(efs.acc_lat);
+				chan->local_flush_to =
+						le32_to_cpu(efs.flush_to);
+			}
+			break;
 
-	if (!queue_work(_l2cap_wq, &seg_work->work)) {
-		kfree(seg_work);
-		sock_put(sk);
-		return -ENOMEM;
+		case L2CAP_MODE_STREAMING:
+			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+		}
 	}
 
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_RESEGMENT;
+	req->dcid   = cpu_to_le16(chan->dcid);
+	req->flags  = cpu_to_le16(0x0000);
 
-	return 0;
+	return ptr - data;
 }
 
-static inline int l2cap_rmem_available(struct sock *sk)
+static int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data, u16 result, u16 flags)
 {
-	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
-		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
-	return atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf / 3;
-}
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
 
-static inline int l2cap_rmem_full(struct sock *sk)
-{
-	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
-		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
-	return atomic_read(&sk->sk_rmem_alloc) > (2 * sk->sk_rcvbuf) / 3;
+	BT_DBG("chan %p", chan);
+
+	rsp->scid   = cpu_to_le16(chan->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(flags);
+
+	return ptr - data;
 }
 
-void l2cap_amp_move_init(struct sock *sk)
+void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)
 {
-	BT_DBG("sk %p", sk);
+	struct l2cap_conn_rsp rsp;
+	struct l2cap_conn *conn = chan->conn;
+	u8 buf[128];
 
-	if (!l2cap_pi(sk)->conn)
-		return;
+	rsp.scid   = cpu_to_le16(chan->dcid);
+	rsp.dcid   = cpu_to_le16(chan->scid);
+	rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+	rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+	l2cap_send_cmd(conn, chan->ident,
+				L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
-	if (!(l2cap_pi(sk)->conn->fc_mask & L2CAP_FC_A2MP) || !enable_hs)
+	if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
 		return;
 
-	if (l2cap_pi(sk)->amp_id == 0) {
-		if (l2cap_pi(sk)->amp_pref != BT_AMP_POLICY_PREFER_AMP)
-			return;
-		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
-		l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
-		amp_create_physical(l2cap_pi(sk)->conn, sk);
-	} else {
-		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
-		l2cap_pi(sk)->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-		l2cap_pi(sk)->amp_move_id = 0;
-		l2cap_amp_move_setup(sk);
-		l2cap_send_move_chan_req(l2cap_pi(sk)->conn,
-					l2cap_pi(sk), l2cap_pi(sk)->scid, 0);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-	}
+	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+			l2cap_build_conf_req(chan, buf), buf);
+	chan->num_conf_req++;
 }
 
-static void l2cap_chan_ready(struct sock *sk)
+static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)
 {
-	struct sock *parent = bt_sk(sk)->parent;
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc;
 
-	BT_DBG("sk %p, parent %p", sk, parent);
+	BT_DBG("chan %p, rsp %p, len %d", chan, rsp, len);
 
-	l2cap_pi(sk)->conf_state = 0;
-	l2cap_sock_clear_timer(sk);
+	if ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))
+		return;
 
-	if (!parent) {
-		/* Outgoing channel.
-		 * Wake up socket sleeping on connect.
-		 */
-		sk->sk_state = BT_CONNECTED;
-		sk->sk_state_change(sk);
-	} else {
-		/* Incoming channel.
-		 * Wake up socket sleeping on accept.
-		 */
-		parent->sk_data_ready(parent, 0);
-	}
-}
-
-/* Copy frame to all raw sockets on that connection */
-static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sk_buff *nskb;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (sk->sk_type != SOCK_RAW)
-			continue;
-
-		/* Don't send frame to the socket it came from */
-		if (skb->sk == sk)
-			continue;
-		nskb = skb_clone(skb, GFP_ATOMIC);
-		if (!nskb)
-			continue;
-
-		if (sock_queue_rcv_skb(sk, nskb))
-			kfree_skb(nskb);
-	}
-	read_unlock(&l->lock);
-}
-
-/* ---- L2CAP signalling commands ---- */
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data)
-{
-	struct sk_buff *skb, **frag;
-	struct l2cap_cmd_hdr *cmd;
-	struct l2cap_hdr *lh;
-	int len, count;
-	unsigned int mtu = conn->hcon->hdev->acl_mtu;
-
-	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
-			conn, code, ident, dlen);
-
-	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
-	count = min_t(unsigned int, mtu, len);
-
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return NULL;
-
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
-
-	if (conn->hcon->type == LE_LINK)
-		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
-	else
-		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
-
-	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
-	cmd->code  = code;
-	cmd->ident = ident;
-	cmd->len   = cpu_to_le16(dlen);
-
-	if (dlen) {
-		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
-		memcpy(skb_put(skb, count), data, count);
-		data += count;
-	}
-
-	len -= skb->len;
-
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		count = min_t(unsigned int, mtu, len);
-
-		*frag = bt_skb_alloc(count, GFP_ATOMIC);
-		if (!*frag)
-			goto fail;
-
-		memcpy(skb_put(*frag, count), data, count);
-
-		len  -= count;
-		data += count;
-
-		frag = &(*frag)->next;
-	}
-
-	return skb;
-
-fail:
-	kfree_skb(skb);
-	return NULL;
-}
-
-static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-	int len;
-
-	len = L2CAP_CONF_OPT_SIZE + opt->len;
-	*ptr += len;
-
-	*type = opt->type;
-	*olen = opt->len;
-
-	switch (opt->len) {
-	case 1:
-		*val = *((u8 *) opt->val);
-		break;
-
-	case 2:
-		*val = get_unaligned_le16(opt->val);
-		break;
-
-	case 4:
-		*val = get_unaligned_le32(opt->val);
-		break;
-
-	default:
-		*val = (unsigned long) opt->val;
-		break;
-	}
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
-	return len;
-}
-
-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
-
-	opt->type = type;
-	opt->len  = len;
-
-	switch (len) {
-	case 1:
-		*((u8 *) opt->val)  = val;
-		break;
-
-	case 2:
-		put_unaligned_le16(val, opt->val);
-		break;
-
-	case 4:
-		put_unaligned_le32(val, opt->val);
-		break;
-
-	default:
-		memcpy(opt->val, (void *) val, len);
-		break;
-	}
-
-	*ptr += L2CAP_CONF_OPT_SIZE + len;
-}
-
-static void l2cap_ertm_ack_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, ack_work);
-	struct sock *sk = (struct sock *)pi;
-	u16 frames_to_ack;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	frames_to_ack = __delta_seq(l2cap_pi(sk)->buffer_seq,
-				    l2cap_pi(sk)->last_acked_seq,
-				    l2cap_pi(sk));
-
-	if (frames_to_ack)
-		l2cap_ertm_send_rr_or_rnr(sk, 0);
-
-	release_sock(sk);
-}
-
-static void l2cap_ertm_retrans_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, retrans_work);
-	struct sock *sk = (struct sock *)pi;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES);
-	release_sock(sk);
-}
-
-static void l2cap_ertm_monitor_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, monitor_work);
-	struct sock *sk = (struct sock *)pi;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES);
-
-	release_sock(sk);
-}
-
-static inline void l2cap_ertm_init(struct sock *sk)
-{
-	l2cap_pi(sk)->next_tx_seq = 0;
-	l2cap_pi(sk)->expected_tx_seq = 0;
-	l2cap_pi(sk)->expected_ack_seq = 0;
-	l2cap_pi(sk)->unacked_frames = 0;
-	l2cap_pi(sk)->buffer_seq = 0;
-	l2cap_pi(sk)->frames_sent = 0;
-	l2cap_pi(sk)->last_acked_seq = 0;
-	l2cap_pi(sk)->sdu = NULL;
-	l2cap_pi(sk)->sdu_last_frag = NULL;
-	l2cap_pi(sk)->sdu_len = 0;
-	atomic_set(&l2cap_pi(sk)->ertm_queued, 0);
-
-	l2cap_pi(sk)->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-	l2cap_pi(sk)->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-
-	BT_DBG("tx_state 0x2.2%x rx_state 0x2.2%x", l2cap_pi(sk)->tx_state,
-		l2cap_pi(sk)->rx_state);
-
-	l2cap_pi(sk)->amp_id = 0;
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
-	l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	l2cap_pi(sk)->amp_move_reqseq = 0;
-	l2cap_pi(sk)->amp_move_event = 0;
-
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->ack_work, l2cap_ertm_ack_timeout);
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->retrans_work,
-			l2cap_ertm_retrans_timeout);
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->monitor_work,
-			l2cap_ertm_monitor_timeout);
-	INIT_WORK(&l2cap_pi(sk)->tx_work, l2cap_ertm_tx_worker);
-	skb_queue_head_init(SREJ_QUEUE(sk));
-	skb_queue_head_init(TX_QUEUE(sk));
-
-	l2cap_seq_list_init(&l2cap_pi(sk)->srej_list, l2cap_pi(sk)->tx_win);
-	l2cap_seq_list_init(&l2cap_pi(sk)->retrans_list,
-			l2cap_pi(sk)->remote_tx_win);
-}
-
-void l2cap_ertm_destruct(struct sock *sk)
-{
-	l2cap_seq_list_free(&l2cap_pi(sk)->srej_list);
-	l2cap_seq_list_free(&l2cap_pi(sk)->retrans_list);
-}
-
-void l2cap_ertm_shutdown(struct sock *sk)
-{
-	l2cap_ertm_stop_ack_timer(l2cap_pi(sk));
-	l2cap_ertm_stop_retrans_timer(l2cap_pi(sk));
-	l2cap_ertm_stop_monitor_timer(l2cap_pi(sk));
-}
-
-void l2cap_ertm_recv_done(struct sock *sk)
-{
-	lock_sock(sk);
-
-	if (l2cap_pi(sk)->mode != L2CAP_MODE_ERTM ||
-			sk->sk_state != BT_CONNECTED) {
-		release_sock(sk);
-		return;
-	}
-
-	/* Consume any queued incoming frames and update local busy status */
-	if (l2cap_pi(sk)->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT &&
-			l2cap_ertm_rx_queued_iframes(sk))
-		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
-	else if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-			l2cap_rmem_available(sk))
-		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
-
-	release_sock(sk);
-}
-
-static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
-{
-	switch (mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (l2cap_mode_supported(mode, remote_feat_mask))
-			return mode;
-		/* fall through */
-	default:
-		return L2CAP_MODE_BASIC;
-	}
-}
-
-static void l2cap_setup_txwin(struct l2cap_pinfo *pi)
-{
-	if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED &&
-		(pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW)) {
-		pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
-		pi->extended_control = 1;
-	} else {
-		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
-			pi->tx_win = L2CAP_TX_WIN_MAX_ENHANCED;
-
-		pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
-		pi->extended_control = 0;
-	}
-	pi->ack_win = pi->tx_win;
-}
-
-static void l2cap_aggregate_fs(struct hci_ext_fs *cur,
-		struct hci_ext_fs *new,
-		struct hci_ext_fs *agg)
-{
-	*agg = *cur;
-	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
-		/* current flow spec has known rate */
-		if ((new->max_sdu == 0xFFFF) ||
-				(new->sdu_arr_time == 0xFFFFFFFF)) {
-			/* new fs has unknown rate, so aggregate is unknown */
-			agg->max_sdu = 0xFFFF;
-			agg->sdu_arr_time = 0xFFFFFFFF;
-		} else {
-			/* new fs has known rate, so aggregate is known */
-			u64 cur_rate;
-			u64 new_rate;
-			cur_rate = cur->max_sdu * 1000000ULL;
-			if (cur->sdu_arr_time)
-				cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
-			new_rate = new->max_sdu * 1000000ULL;
-			if (new->sdu_arr_time)
-				new_rate = div_u64(new_rate, new->sdu_arr_time);
-			cur_rate = cur_rate + new_rate;
-			if (cur_rate)
-				agg->sdu_arr_time = div64_u64(
-					agg->max_sdu * 1000000ULL, cur_rate);
-		}
-	}
-}
-
-static int l2cap_aggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
-{
-	struct hci_ext_fs tx_fs;
-	struct hci_ext_fs rx_fs;
-
-	BT_DBG("chan %p", chan);
-
-	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
-			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
-			((chan->rx_fs.max_sdu == 0xFFFF) ||
-			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
-		return 0;
-
-	l2cap_aggregate_fs(&chan->tx_fs,
-				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
-	l2cap_aggregate_fs(&chan->rx_fs,
-				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
-	hci_chan_modify(chan, &tx_fs, &rx_fs);
-	return 1;
-}
-
-static void l2cap_deaggregate_fs(struct hci_ext_fs *cur,
-		struct hci_ext_fs *old,
-		struct hci_ext_fs *agg)
-{
-	*agg = *cur;
-	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
-		u64 cur_rate;
-		u64 old_rate;
-		cur_rate = cur->max_sdu * 1000000ULL;
-		if (cur->sdu_arr_time)
-			cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
-		old_rate = old->max_sdu * 1000000ULL;
-		if (old->sdu_arr_time)
-			old_rate = div_u64(old_rate, old->sdu_arr_time);
-		cur_rate = cur_rate - old_rate;
-		if (cur_rate)
-			agg->sdu_arr_time = div64_u64(
-				agg->max_sdu * 1000000ULL, cur_rate);
-	}
-}
-
-static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
-{
-	struct hci_ext_fs tx_fs;
-	struct hci_ext_fs rx_fs;
-
-	BT_DBG("chan %p", chan);
-
-	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
-			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
-			((chan->rx_fs.max_sdu == 0xFFFF) ||
-			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
-		return 0;
-
-	l2cap_deaggregate_fs(&chan->tx_fs,
-				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
-	l2cap_deaggregate_fs(&chan->rx_fs,
-				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
-	hci_chan_modify(chan, &tx_fs, &rx_fs);
-	return 1;
-}
-
-static struct hci_chan *l2cap_chan_admit(u8 amp_id, struct sock *sk)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct hci_dev *hdev;
-	struct hci_conn *hcon;
-	struct hci_chan *chan;
-
-	hdev = hci_dev_get(amp_id);
-	if (!hdev)
-		return NULL;
-
-	BT_DBG("hdev %s", hdev->name);
-
-	hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, pi->conn->dst);
-	if (!hcon) {
-		chan = NULL;
-		goto done;
-	}
-
-	chan = hci_chan_list_lookup_id(hdev, hcon->handle);
-	if (chan) {
-		l2cap_aggregate(chan, pi);
-		sock_hold(sk);
-		chan->l2cap_sk = sk;
-		hci_chan_hold(chan);
-		pi->ampchan = chan;
-		goto done;
-	}
-
-	chan = hci_chan_add(hdev);
-	if (chan) {
-		chan->conn = hcon;
-		sock_hold(sk);
-		chan->l2cap_sk = sk;
-		hci_chan_hold(chan);
-		pi->ampchan = chan;
-		hci_chan_create(chan,
-			(struct hci_ext_fs *) &pi->local_fs,
-			(struct hci_ext_fs *) &pi->remote_fs);
-	}
-done:
-	hci_dev_put(hdev);
-	return chan;
-}
-
-static void l2cap_get_ertm_timeouts(struct l2cap_conf_rfc *rfc,
-						struct l2cap_pinfo *pi)
-{
-	if (pi->amp_id && pi->ampcon) {
-		u64 ertm_to = pi->ampcon->hdev->amp_be_flush_to;
-
-		/* Class 1 devices have must have ERTM timeouts
-		 * exceeding the Link Supervision Timeout.  The
-		 * default Link Supervision Timeout for AMP
-		 * controllers is 10 seconds.
-		 *
-		 * Class 1 devices use 0xffffffff for their
-		 * best-effort flush timeout, so the clamping logic
-		 * will result in a timeout that meets the above
-		 * requirement.  ERTM timeouts are 16-bit values, so
-		 * the maximum timeout is 65.535 seconds.
-		 */
-
-		/* Convert timeout to milliseconds and round */
-		ertm_to = div_u64(ertm_to + 999, 1000);
-
-		/* This is the recommended formula for class 2 devices
-		 * that start ERTM timers when packets are sent to the
-		 * controller.
-		 */
-		ertm_to = 3 * ertm_to + 500;
-
-		if (ertm_to > 0xffff)
-			ertm_to = 0xffff;
-
-		rfc->retrans_timeout = cpu_to_le16((u16) ertm_to);
-		rfc->monitor_timeout = rfc->retrans_timeout;
-	} else {
-		rfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-		rfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	}
-}
-
-int l2cap_build_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
-	void *ptr = req->data;
-
-	BT_DBG("sk %p mode %d", sk, pi->mode);
-
-	if (pi->num_conf_req || pi->num_conf_rsp)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (pi->conf_state & L2CAP_CONF_STATE2_DEVICE)
-			break;
-
-		/* fall through */
-	default:
-		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
-		break;
-	}
-
-done:
-	if (pi->imtu != L2CAP_DEFAULT_MTU)
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_ERTM) &&
-				!(pi->conn->feat_mask & L2CAP_FEAT_STREAMING))
-			break;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = 0;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-		break;
-
-	case L2CAP_MODE_ERTM:
-		l2cap_setup_txwin(pi);
-		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
-			rfc.txwin_size = L2CAP_TX_WIN_MAX_ENHANCED;
-		else
-			rfc.txwin_size = pi->tx_win;
-		rfc.max_transmit = pi->max_tx;
-		rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		l2cap_get_ertm_timeouts(&rfc, pi);
-
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
-			pi->extended_control) {
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
-					pi->tx_win);
-		}
-
-		if (pi->amp_id) {
-			/* default best effort extended flow spec */
-			struct l2cap_conf_ext_fs fs = {1, 1, 0xFFFF,
-					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
-				sizeof(fs), (unsigned long) &fs);
-		}
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-
-	case L2CAP_MODE_STREAMING:
-		l2cap_setup_txwin(pi);
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
-			pi->extended_control) {
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2, 0);
-		}
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-	}
-
-	req->dcid  = cpu_to_le16(pi->dcid);
-	req->flags = cpu_to_le16(0);
-
-	return ptr - data;
-}
-
-
-static int l2cap_build_amp_reconf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
-	void *ptr = req->data;
-
-	BT_DBG("sk %p", sk);
-
-	switch (pi->mode) {
-	case L2CAP_MODE_ERTM:
-		rfc.mode            = L2CAP_MODE_ERTM;
-		rfc.txwin_size      = pi->tx_win;
-		rfc.max_transmit    = pi->max_tx;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		l2cap_get_ertm_timeouts(&rfc, pi);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		break;
-
-	default:
-		return -ECONNREFUSED;
-	}
-
-	l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-						(unsigned long) &rfc);
-
-	if (pi->conn->feat_mask & L2CAP_FEAT_FCS) {
-		/* TODO assign fcs for br/edr based on socket config option */
-		/* FCS is not used with AMP because it is redundant - lower
-		 * layers already include a checksum. */
-		if (pi->amp_id)
-			pi->local_conf.fcs = L2CAP_FCS_NONE;
-		else
-			pi->local_conf.fcs = L2CAP_FCS_CRC16;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->local_conf.fcs);
-		pi->fcs = pi->local_conf.fcs | pi->remote_conf.fcs;
-	}
-
-	req->dcid  = cpu_to_le16(pi->dcid);
-	req->flags = cpu_to_le16(0);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = pi->conf_req;
-	int len = pi->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_ext_fs fs;
-	u16 mtu = L2CAP_DEFAULT_MTU;
-	u16 result = L2CAP_CONF_SUCCESS;
-
-	BT_DBG("sk %p", sk);
-
-	if (pi->omtu > mtu)
-		mtu = pi->omtu;
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
-
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				result = L2CAP_CONF_UNACCEPT;
-			else
-				pi->remote_conf.flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				result = L2CAP_CONF_UNACCEPT;
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
-
-		case L2CAP_CONF_FCS:
-			if (val == L2CAP_FCS_NONE)
-				pi->conf_state |= L2CAP_CONF_NO_FCS_RECV;
-			pi->remote_conf.fcs = val;
-			break;
-
-		case L2CAP_CONF_EXT_FS:
-			if (olen == sizeof(fs)) {
-				pi->conf_state |= L2CAP_CONF_EFS_RECV;
-				if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
-					result = L2CAP_CONF_UNACCEPT;
-					break;
-				}
-				memcpy(&fs, (void *) val, olen);
-				if (fs.type != L2CAP_SERVICE_BEST_EFFORT) {
-					result = L2CAP_CONF_FLOW_SPEC_REJECT;
-					break;
-				}
-				pi->remote_conf.flush_to =
-						le32_to_cpu(fs.flush_to);
-				pi->remote_fs.id = fs.id;
-				pi->remote_fs.type = fs.type;
-				pi->remote_fs.max_sdu =
-						le16_to_cpu(fs.max_sdu);
-				pi->remote_fs.sdu_arr_time =
-						le32_to_cpu(fs.sdu_arr_time);
-				pi->remote_fs.acc_latency =
-						le32_to_cpu(fs.acc_latency);
-				pi->remote_fs.flush_to =
-						le32_to_cpu(fs.flush_to);
-			}
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			pi->extended_control = 1;
-			pi->remote_tx_win = val;
-			pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
-			pi->conf_state |= L2CAP_CONF_EXT_WIN_RECV;
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-		}
-	}
-
-	if (pi->num_conf_rsp || pi->num_conf_req > 1)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {
-			pi->mode = l2cap_select_mode(rfc.mode,
-					pi->conn->feat_mask);
-			break;
-		}
-
-		if (pi->mode != rfc.mode)
-			return -ECONNREFUSED;
-
-		break;
-	}
-
-done:
-	if (pi->mode != rfc.mode) {
-		result = L2CAP_CONF_UNACCEPT;
-		rfc.mode = pi->mode;
-		if (mtu > L2CAP_DEFAULT_MTU)
-			pi->omtu = mtu;
-
-		if (pi->num_conf_rsp == 1)
-			return -ECONNREFUSED;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
-
-
-	if ((pi->conf_state & L2CAP_CONF_LOCKSTEP) &&
-			!(pi->conf_state & L2CAP_CONF_EFS_RECV))
-		return -ECONNREFUSED;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
-
-		if (mtu < L2CAP_DEFAULT_MIN_MTU) {
-			result = L2CAP_CONF_UNACCEPT;
-			pi->omtu = L2CAP_DEFAULT_MIN_MTU;
-		} else {
-			pi->omtu = mtu;
-			pi->conf_state |= L2CAP_CONF_MTU_DONE;
-		}
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
-
-		switch (rfc.mode) {
-		case L2CAP_MODE_BASIC:
-			pi->fcs = L2CAP_FCS_NONE;
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-			break;
-
-		case L2CAP_MODE_ERTM:
-			if (!(pi->conf_state & L2CAP_CONF_EXT_WIN_RECV))
-				pi->remote_tx_win = rfc.txwin_size;
-			pi->remote_max_tx = rfc.max_transmit;
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-			l2cap_get_ertm_timeouts(&rfc, pi);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
-					sizeof(fs), (unsigned long) &fs);
-
-			break;
-
-		case L2CAP_MODE_STREAMING:
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			break;
-
-		default:
-			result = L2CAP_CONF_UNACCEPT;
-
-			memset(&rfc, 0, sizeof(rfc));
-			rfc.mode = pi->mode;
-		}
-
-		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
-				!(pi->conf_state & L2CAP_CONF_PEND_SENT)) {
-			pi->conf_state |= L2CAP_CONF_PEND_SENT;
-			result = L2CAP_CONF_PENDING;
-
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND &&
-					pi->amp_id) {
-				struct hci_chan *chan;
-				/* Trigger logical link creation only on AMP */
-
-				chan = l2cap_chan_admit(pi->amp_id, sk);
-				if (!chan)
-					return -ECONNREFUSED;
-
-				if (chan->state == BT_CONNECTED)
-					l2cap_create_cfm(chan, 0);
-			}
-		}
-
-		if (result == L2CAP_CONF_SUCCESS)
-			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
-	}
-	rsp->scid   = cpu_to_le16(pi->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_amp_move_reconf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = pi->conf_req;
-	int len = pi->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_ext_fs fs;
-	u16 mtu = pi->omtu;
-	u16 tx_win = pi->remote_tx_win;
-	u16 result = L2CAP_CONF_SUCCESS;
-
-	BT_DBG("sk %p", sk);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
-
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			if (pi->amp_move_id)
-				result = L2CAP_CONF_UNACCEPT;
-			else
-				pi->remote_conf.flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			if (pi->amp_move_id)
-				result = L2CAP_CONF_UNACCEPT;
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
-
-		case L2CAP_CONF_FCS:
-			pi->remote_conf.fcs = val;
-			break;
-
-		case L2CAP_CONF_EXT_FS:
-			if (olen == sizeof(fs)) {
-				memcpy(&fs, (void *) val, olen);
-				if (fs.type != L2CAP_SERVICE_BEST_EFFORT)
-					result = L2CAP_CONF_FLOW_SPEC_REJECT;
-				else {
-					pi->remote_conf.flush_to =
-						le32_to_cpu(fs.flush_to);
-				}
-			}
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			tx_win = val;
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-			}
-	}
-
-	BT_DBG("result 0x%2.2x cur mode 0x%2.2x req  mode 0x%2.2x",
-		result, pi->mode, rfc.mode);
-
-	if (pi->mode != rfc.mode || rfc.mode == L2CAP_MODE_BASIC)
-		result = L2CAP_CONF_UNACCEPT;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
-
-		/* Don't allow mtu to decrease. */
-		if (mtu < pi->omtu)
-			result = L2CAP_CONF_UNACCEPT;
-
-		BT_DBG("mtu %d omtu %d", mtu, pi->omtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
-
-		/* Don't allow extended transmit window to change. */
-		if (tx_win != pi->remote_tx_win) {
-			result = L2CAP_CONF_UNACCEPT;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
-					pi->remote_tx_win);
-		}
-
-		pi->remote_mps = rfc.max_pdu_size;
-
-		if (rfc.mode == L2CAP_MODE_ERTM) {
-			l2cap_get_ertm_timeouts(&rfc, pi);
-		} else {
-			rfc.retrans_timeout = 0;
-			rfc.monitor_timeout = 0;
-		}
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
-
-	if (result != L2CAP_CONF_SUCCESS)
-		goto done;
-
-	pi->fcs = pi->remote_conf.fcs | pi->local_conf.fcs;
-
-	if (pi->rx_state == L2CAP_ERTM_RX_STATE_WAIT_F_FLAG)
-		pi->flush_to = pi->remote_conf.flush_to;
-
-done:
-	rsp->scid   = cpu_to_le16(pi->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	void *ptr = req->data;
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-
-	BT_DBG("sk %p, rsp %p, len %d, req %p", sk, rsp, len, data);
-
-	/* Initialize rfc in case no rfc option is received */
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			if (val < L2CAP_DEFAULT_MIN_MTU) {
-				*result = L2CAP_CONF_UNACCEPT;
-				pi->imtu = L2CAP_DEFAULT_MIN_MTU;
-			} else
-				pi->imtu = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
-							2, pi->flush_to);
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-
-			if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
-							rfc.mode != pi->mode)
-				return -ECONNREFUSED;
-
-			pi->fcs = 0;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			pi->ack_win = min_t(u16, val, pi->ack_win);
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW,
-					2, pi->tx_win);
-			break;
-
-		default:
-			break;
-		}
-	}
-
-	if (pi->mode == L2CAP_MODE_BASIC && pi->mode != rfc.mode)
-		return -ECONNREFUSED;
-
-	pi->mode = rfc.mode;
-
-	if (*result == L2CAP_CONF_SUCCESS) {
-		switch (rfc.mode) {
-		case L2CAP_MODE_ERTM:
-			pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-			pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-			if (!pi->extended_control) {
-				pi->ack_win = min_t(u16, pi->ack_win,
-						    rfc.txwin_size);
-			}
-			break;
-		case L2CAP_MODE_STREAMING:
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		}
-	}
-
-	req->dcid   = cpu_to_le16(pi->dcid);
-	req->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
-{
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-
-	BT_DBG("sk %p", sk);
-
-	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(flags);
-
-	return ptr - data;
-}
-
-static void l2cap_conf_rfc_get(struct sock *sk, void *rsp, int len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-	u16 txwin_ext = pi->ack_win;
-
-	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
-
-	/* Initialize rfc in case no rfc option is received */
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-	rfc.txwin_size = min_t(u16, pi->ack_win, L2CAP_DEFAULT_TX_WINDOW);
-
-	if ((pi->mode != L2CAP_MODE_ERTM) && (pi->mode != L2CAP_MODE_STREAMING))
-		return;
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-			break;
-		case L2CAP_CONF_EXT_WINDOW:
-			txwin_ext = val;
-			break;
-		}
-	}
-
-	switch (rfc.mode) {
-	case L2CAP_MODE_ERTM:
-		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		if (pi->extended_control)
-			pi->ack_win = min_t(u16, pi->ack_win, txwin_ext);
-		else
-			pi->ack_win = min_t(u16, pi->ack_win, rfc.txwin_size);
-		break;
-	case L2CAP_MODE_STREAMING:
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-	}
-}
-
-static void l2cap_conf_ext_fs_get(struct sock *sk, void *rsp, int len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_ext_fs fs;
-
-	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-		if ((type == L2CAP_CONF_EXT_FS) &&
-				(olen == sizeof(struct l2cap_conf_ext_fs))) {
-			memcpy(&fs, (void *)val, olen);
-			pi->local_fs.id = fs.id;
-			pi->local_fs.type = fs.type;
-			pi->local_fs.max_sdu = le16_to_cpu(fs.max_sdu);
-			pi->local_fs.sdu_arr_time =
-						le32_to_cpu(fs.sdu_arr_time);
-			pi->local_fs.acc_latency = le32_to_cpu(fs.acc_latency);
-			pi->local_fs.flush_to = le32_to_cpu(fs.flush_to);
-			break;
-		}
-	}
-
-}
-
-static int l2cap_finish_amp_move(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	int err =0;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
-
-	pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-
-	if (pi->ampcon)
-		pi->conn->mtu = pi->ampcon->hdev->acl_mtu;
-	else
-		pi->conn->mtu = pi->conn->hcon->hdev->acl_mtu;
-
-	err = l2cap_setup_resegment(sk);
-
-	return err;
-}
-
-static int l2cap_amp_move_reconf_rsp(struct sock *sk, void *rsp, int len,
-					u16 result)
-{
-	int err = 0;
-	struct l2cap_conf_rfc rfc = {.mode = L2CAP_MODE_BASIC};
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-	BT_DBG("sk %p, rsp %p, len %d, res 0x%2.2x", sk, rsp, len, result);
-
-	if (pi->reconf_state == L2CAP_RECONF_NONE)
-		return -ECONNREFUSED;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		while (len >= L2CAP_CONF_OPT_SIZE) {
-			int type, olen;
-			unsigned long val;
-
-			len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-			if (type == L2CAP_CONF_RFC) {
-				if (olen == sizeof(rfc))
-					memcpy(&rfc, (void *)val, olen);
-
-				if (rfc.mode != pi->mode) {
-					l2cap_send_disconn_req(pi->conn, sk,
-								ECONNRESET);
-					return -ECONNRESET;
-				}
-
-				goto done;
-			}
-		}
-	}
-
-	BT_ERR("Expected RFC option was missing, using existing values");
-
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(pi->retrans_timeout);
-	rfc.monitor_timeout = cpu_to_le16(pi->monitor_timeout);
-
-done:
-	l2cap_ertm_stop_ack_timer(pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	l2cap_ertm_stop_monitor_timer(pi);
-
-	pi->mps = le16_to_cpu(rfc.max_pdu_size);
-	if (pi->mode == L2CAP_MODE_ERTM) {
-		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-	}
-
-	if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_ACC) {
-		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_NONE;
-
-		/* Respond to poll */
-		err = l2cap_answer_move_poll(sk);
-	} else if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_INT) {
-		if (pi->mode == L2CAP_MODE_ERTM) {
-			l2cap_ertm_tx(sk, NULL, NULL,
-					L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-			pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-		}
-	}
-
-	return err;
-}
-
-
-static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;
-
-	if (rej->reason != 0x0000)
-		return 0;
-
-	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
-					cmd->ident == conn->info_ident) {
-		del_timer(&conn->info_timer);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
-
-		l2cap_conn_start(conn);
-	}
-
-	return 0;
-}
-
-static struct sock *l2cap_create_connect(struct l2cap_conn *conn,
-						struct l2cap_cmd_hdr *cmd,
-						u8 *data, u8 rsp_code,
-						u8 amp_id)
-{
-	struct l2cap_chan_list *list = &conn->chan_list;
-	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
-	struct l2cap_conn_rsp rsp;
-	struct sock *parent, *sk = NULL;
-	int result, status = L2CAP_CS_NO_INFO;
-
-	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
-	__le16 psm = req->psm;
-
-	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
-
-	/* Check if we have socket listening on psm */
-	parent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);
-	if (!parent) {
-		result = L2CAP_CR_BAD_PSM;
-		goto sendresp;
-	}
-
-	bh_lock_sock(parent);
-
-	/* Check if the ACL is secure enough (if not SDP) */
-	if (psm != cpu_to_le16(0x0001) &&
-				!hci_conn_check_link_mode(conn->hcon)) {
-		conn->disc_reason = 0x05;
-		result = L2CAP_CR_SEC_BLOCK;
-		goto response;
-	}
-
-	result = L2CAP_CR_NO_MEM;
-
-	/* Check for backlog size */
-	if (sk_acceptq_is_full(parent)) {
-		BT_DBG("backlog full %d", parent->sk_ack_backlog);
-		goto response;
-	}
-
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
-	if (!sk)
-		goto response;
-
-	write_lock_bh(&list->lock);
-
-	/* Check if we already have channel with that dcid */
-	if (__l2cap_get_chan_by_dcid(list, scid)) {
-		write_unlock_bh(&list->lock);
-		sock_set_flag(sk, SOCK_ZAPPED);
-		l2cap_sock_kill(sk);
-		sk = NULL;
-		goto response;
-	}
-
-	hci_conn_hold(conn->hcon);
-
-	l2cap_sock_init(sk, parent);
-	bacpy(&bt_sk(sk)->src, conn->src);
-	bacpy(&bt_sk(sk)->dst, conn->dst);
-	l2cap_pi(sk)->psm  = psm;
-	l2cap_pi(sk)->dcid = scid;
-
-	bt_accept_enqueue(parent, sk);
-
-	__l2cap_chan_add(conn, sk);
-	dcid = l2cap_pi(sk)->scid;
-	l2cap_pi(sk)->amp_id = amp_id;
-
-	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-
-	l2cap_pi(sk)->ident = cmd->ident;
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
-		if (l2cap_check_security(sk)) {
-			if (bt_sk(sk)->defer_setup) {
-				sk->sk_state = BT_CONNECT2;
-				result = L2CAP_CR_PEND;
-				status = L2CAP_CS_AUTHOR_PEND;
-				parent->sk_data_ready(parent, 0);
-			} else {
-				/* Force pending result for AMP controllers.
-				 * The connection will succeed after the
-				 * physical link is up. */
-				if (amp_id) {
-					sk->sk_state = BT_CONNECT2;
-					result = L2CAP_CR_PEND;
-				} else {
-					sk->sk_state = BT_CONFIG;
-					result = L2CAP_CR_SUCCESS;
-				}
-				status = L2CAP_CS_NO_INFO;
-			}
-		} else {
-			sk->sk_state = BT_CONNECT2;
-			result = L2CAP_CR_PEND;
-			status = L2CAP_CS_AUTHEN_PEND;
-		}
-	} else {
-		sk->sk_state = BT_CONNECT2;
-		result = L2CAP_CR_PEND;
-		status = L2CAP_CS_NO_INFO;
-	}
-
-	write_unlock_bh(&list->lock);
-
-response:
-	bh_unlock_sock(parent);
-
-sendresp:
-	rsp.scid   = cpu_to_le16(scid);
-	rsp.dcid   = cpu_to_le16(dcid);
-	rsp.result = cpu_to_le16(result);
-	rsp.status = cpu_to_le16(status);
-	l2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);
-
-	if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)) {
-		struct l2cap_info_req info;
-		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
-		conn->info_ident = l2cap_get_ident(conn);
-
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
-
-		l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(info), &info);
-	}
-
-	if (sk && !(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
-				result == L2CAP_CR_SUCCESS) {
-		u8 buf[128];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-	return sk;
-}
-
-static inline int l2cap_connect_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	l2cap_create_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);
-	return 0;
-}
-
-static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
-	u16 scid, dcid, result, status;
-	struct sock *sk;
-	u8 req[128];
-
-	scid   = __le16_to_cpu(rsp->scid);
-	dcid   = __le16_to_cpu(rsp->dcid);
-	result = __le16_to_cpu(rsp->result);
-	status = __le16_to_cpu(rsp->status);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
-
-	if (scid) {
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-		if (!sk)
-			return -EFAULT;
-	} else {
-		sk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
-		if (!sk)
-			return -EFAULT;
-	}
-
-	switch (result) {
-	case L2CAP_CR_SUCCESS:
-		sk->sk_state = BT_CONFIG;
-		l2cap_pi(sk)->ident = 0;
-		l2cap_pi(sk)->dcid = dcid;
-		l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)
-			break;
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, req), req);
-		l2cap_pi(sk)->num_conf_req++;
-		break;
-
-	case L2CAP_CR_PEND:
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-		break;
-
-	default:
-		/* don't delete l2cap channel if sk is owned by user */
-		if (sock_owned_by_user(sk)) {
-			sk->sk_state = BT_DISCONN;
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ / 5);
-			break;
-		}
-
-		l2cap_chan_del(sk, ECONNREFUSED);
-		break;
-	}
-
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline void set_default_fcs(struct l2cap_pinfo *pi)
-{
-	/* FCS is enabled only in ERTM or streaming mode, if one or both
-	 * sides request it.
-	 */
-	if (pi->mode != L2CAP_MODE_ERTM && pi->mode != L2CAP_MODE_STREAMING)
-		pi->fcs = L2CAP_FCS_NONE;
-	else if (!(pi->conf_state & L2CAP_CONF_NO_FCS_RECV))
-		pi->fcs = L2CAP_FCS_CRC16;
-}
-
-static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
-{
-	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
-	u16 dcid, flags;
-	u8 rspbuf[64];
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *) rspbuf;
-	struct sock *sk;
-	int len;
-	u8 amp_move_reconf = 0;
-
-	dcid  = __le16_to_cpu(req->dcid);
-	flags = __le16_to_cpu(req->flags);
-
-	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return -ENOENT;
-
-	BT_DBG("sk_state 0x%2.2x rx_state 0x%2.2x "
-		"reconf_state 0x%2.2x amp_id 0x%2.2x amp_move_id 0x%2.2x",
-		sk->sk_state, l2cap_pi(sk)->rx_state,
-		l2cap_pi(sk)->reconf_state, l2cap_pi(sk)->amp_id,
-		l2cap_pi(sk)->amp_move_id);
-
-	/* Detect a reconfig request due to channel move between
-	 * BR/EDR and AMP
-	 */
-	if (sk->sk_state == BT_CONNECTED &&
-		l2cap_pi(sk)->rx_state ==
-			L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE)
-		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_ACC;
-
-	if (l2cap_pi(sk)->reconf_state != L2CAP_RECONF_NONE)
-		amp_move_reconf = 1;
-
-	if (sk->sk_state != BT_CONFIG && !amp_move_reconf) {
-		struct l2cap_cmd_rej rej;
-
-		rej.reason = cpu_to_le16(0x0002);
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
-				sizeof(rej), &rej);
-		goto unlock;
-	}
-
-	/* Reject if config buffer is too small. */
-	len = cmd_len - sizeof(*req);
-	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rspbuf,
-					L2CAP_CONF_REJECT, flags), rspbuf);
-		goto unlock;
-	}
-
-	/* Store config. */
-	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
-	l2cap_pi(sk)->conf_len += len;
-
-	if (flags & 0x0001) {
-		/* Incomplete config. Send empty response. */
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rspbuf,
-					L2CAP_CONF_SUCCESS, 0x0001), rspbuf);
-		goto unlock;
-	}
-
-	/* Complete config. */
-	if (!amp_move_reconf)
-		len = l2cap_parse_conf_req(sk, rspbuf);
-	else
-		len = l2cap_parse_amp_move_reconf_req(sk, rspbuf);
-
-	if (len < 0) {
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
-		goto unlock;
-	}
-
-	l2cap_pi(sk)->conf_ident = cmd->ident;
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_LOCKSTEP &&
-			rsp->result == cpu_to_le16(L2CAP_CONF_PENDING) &&
-			!l2cap_pi(sk)->amp_id) {
-		/* Send success response right after pending if using
-		 * lockstep config on BR/EDR
-		 */
-		rsp->result = cpu_to_le16(L2CAP_CONF_SUCCESS);
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_OUTPUT_DONE;
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
-	}
-
-	/* Reset config buffer. */
-	l2cap_pi(sk)->conf_len = 0;
-
-	if (amp_move_reconf)
-		goto unlock;
-
-	l2cap_pi(sk)->num_conf_rsp++;
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))
-		goto unlock;
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
-		set_default_fcs(l2cap_pi(sk));
-
-		sk->sk_state = BT_CONNECTED;
-
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
-			l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-			l2cap_ertm_init(sk);
-
-		l2cap_chan_ready(sk);
-		goto unlock;
-	}
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {
-		u8 buf[64];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-unlock:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
-	u16 scid, flags, result;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	int len = cmd->len - sizeof(*rsp);
-
-	scid   = __le16_to_cpu(rsp->scid);
-	flags  = __le16_to_cpu(rsp->flags);
-	result = __le16_to_cpu(rsp->result);
-
-	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
-			scid, flags, result);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
-
-	pi = l2cap_pi(sk);
-
-	if (pi->reconf_state != L2CAP_RECONF_NONE)  {
-		l2cap_amp_move_reconf_rsp(sk, rsp->data, len, result);
-		goto done;
-	}
-
-	switch (result) {
-	case L2CAP_CONF_SUCCESS:
-		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
-				!(pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND)) {
-			/* Lockstep procedure requires a pending response
-			 * before success.
-			 */
-			l2cap_send_disconn_req(conn, sk, ECONNRESET);
-			goto done;
-		}
-
-		l2cap_conf_rfc_get(sk, rsp->data, len);
-		break;
-
-	case L2CAP_CONF_PENDING:
-		if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
-			l2cap_send_disconn_req(conn, sk, ECONNRESET);
-			goto done;
-		}
-
-		l2cap_conf_rfc_get(sk, rsp->data, len);
-
-		pi->conf_state |= L2CAP_CONF_LOCKSTEP_PEND;
-
-		l2cap_conf_ext_fs_get(sk, rsp->data, len);
-
-		if (pi->amp_id && pi->conf_state & L2CAP_CONF_PEND_SENT) {
-			struct hci_chan *chan;
-
-			/* Already sent a 'pending' response, so set up
-			 * the logical link now
-			 */
-			chan = l2cap_chan_admit(pi->amp_id, sk);
-			if (!chan) {
-				l2cap_send_disconn_req(pi->conn, sk,
-							ECONNRESET);
-				goto done;
-			}
-
-			if (chan->state == BT_CONNECTED)
-				l2cap_create_cfm(chan, 0);
-		}
-
-		goto done;
-
-	case L2CAP_CONF_UNACCEPT:
-		if (pi->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
-			char req[64];
-
-			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
 
-			/* throw out any old stored conf requests */
-			result = L2CAP_CONF_SUCCESS;
-			len = l2cap_parse_conf_rsp(sk, rsp->data,
-							len, req, &result);
-			if (len < 0) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
+		if (type != L2CAP_CONF_RFC)
+			continue;
 
-			l2cap_send_cmd(conn, l2cap_get_ident(conn),
-						L2CAP_CONF_REQ, len, req);
-			pi->num_conf_req++;
-			if (result != L2CAP_CONF_SUCCESS)
-				goto done;
+		if (olen != sizeof(rfc))
 			break;
-		}
 
-	default:
-		sk->sk_err = ECONNRESET;
-		l2cap_sock_set_timer(sk, HZ * 5);
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
+		memcpy(&rfc, (void *)val, olen);
 		goto done;
 	}
 
-	if (flags & 0x01)
-		goto done;
-
-	pi->conf_state |= L2CAP_CONF_INPUT_DONE;
-
-	if (pi->conf_state & L2CAP_CONF_OUTPUT_DONE) {
-		set_default_fcs(pi);
-
-		sk->sk_state = BT_CONNECTED;
-
-		if (pi->mode == L2CAP_MODE_ERTM ||
-			pi->mode == L2CAP_MODE_STREAMING)
-			l2cap_ertm_init(sk);
+	/* Use sane default values in case a misbehaving remote device
+	 * did not send an RFC option.
+	 */
+	rfc.mode = chan->mode;
+	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
+	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
+	rfc.max_pdu_size = cpu_to_le16(chan->imtu);
 
-		l2cap_chan_ready(sk);
-	}
+	BT_ERR("Expected RFC option was not found, using defaults");
 
 done:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
-	struct l2cap_disconn_rsp rsp;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(req->scid);
-	dcid = __le16_to_cpu(req->dcid);
-
-	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return 0;
-
-	rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
-	rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
-
-	/* Only do cleanup if a disconnect request was not sent already */
-	if (sk->sk_state != BT_DISCONN) {
-		sk->sk_shutdown = SHUTDOWN_MASK;
-
-		sk->sk_send_head = NULL;
-		skb_queue_purge(TX_QUEUE(sk));
-
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-			skb_queue_purge(SREJ_QUEUE(sk));
-
-			__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-			__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-			__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
-		}
-	}
-
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		return 0;
+	switch (rfc.mode) {
+	case L2CAP_MODE_ERTM:
+		chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+		chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+		break;
+	case L2CAP_MODE_STREAMING:
+		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
 	}
-
-	l2cap_chan_del(sk, ECONNRESET);
-
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
 }
 
-static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(rsp->scid);
-	dcid = __le16_to_cpu(rsp->dcid);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
+	struct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;
 
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
+	if (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)
 		return 0;
-	}
-
-	l2cap_chan_del(sk, 0);
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
-}
-
-static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
-	u16 type;
-
-	type = __le16_to_cpu(req->type);
-
-	BT_DBG("type 0x%4.4x", type);
-
-	if (type == L2CAP_IT_FEAT_MASK) {
-		u8 buf[8];
-		u32 feat_mask = l2cap_feat_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (!disable_ertm)
-			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
-				| L2CAP_FEAT_FCS | L2CAP_FEAT_EXT_WINDOW;
-		put_unaligned_le32(feat_mask, rsp->data);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		u8 buf[12];
-		u8 fc_mask = l2cap_fc_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (enable_hs)
-			fc_mask |= L2CAP_FC_A2MP;
-		memset(rsp->data, 0, 8);
-		rsp->data[0] = fc_mask;
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else {
-		struct l2cap_info_rsp rsp;
-		rsp.type   = cpu_to_le16(type);
-		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
+
+	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
+					cmd->ident == conn->info_ident) {
+		cancel_delayed_work(&conn->info_timer);
+
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
 	}
 
 	return 0;
 }
 
-static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
-	u16 type, result;
-
-	type   = __le16_to_cpu(rsp->type);
-	result = __le16_to_cpu(rsp->result);
+	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
+	struct l2cap_conn_rsp rsp;
+	struct l2cap_chan *chan = NULL, *pchan;
+	struct sock *parent, *sk = NULL;
+	int result, status = L2CAP_CS_NO_INFO;
 
-	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
+	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
+	__le16 psm = req->psm;
 
-	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
-	if (cmd->ident != conn->info_ident ||
-			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
-		return 0;
+	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
 
-	del_timer(&conn->info_timer);
+	/* Check if we have socket listening on psm */
+	pchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, conn->src);
+	if (!pchan) {
+		result = L2CAP_CR_BAD_PSM;
+		goto sendresp;
+	}
 
-	if (result != L2CAP_IR_SUCCESS) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	parent = pchan->sk;
 
-		l2cap_conn_start(conn);
+	mutex_lock(&conn->chan_lock);
+	lock_sock(parent);
 
-		return 0;
+	/* Check if the ACL is secure enough (if not SDP) */
+	if (psm != cpu_to_le16(0x0001) &&
+				!hci_conn_check_link_mode(conn->hcon)) {
+		conn->disc_reason = HCI_ERROR_AUTH_FAILURE;
+		result = L2CAP_CR_SEC_BLOCK;
+		goto response;
 	}
 
-	if (type == L2CAP_IT_FEAT_MASK) {
-		conn->feat_mask = get_unaligned_le32(rsp->data);
-
-		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
-			struct l2cap_info_req req;
-			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+	result = L2CAP_CR_NO_MEM;
 
-			conn->info_ident = l2cap_get_ident(conn);
+	/* Check for backlog size */
+	if (sk_acceptq_is_full(parent)) {
+		BT_DBG("backlog full %d", parent->sk_ack_backlog);
+		goto response;
+	}
 
-			l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(req), &req);
-		} else {
-			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-			conn->info_ident = 0;
+	chan = pchan->ops->new_connection(pchan->data);
+	if (!chan)
+		goto response;
 
-			l2cap_conn_start(conn);
-		}
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		conn->fc_mask = rsp->data[0];
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	sk = chan->sk;
 
-		l2cap_conn_start(conn);
+	/* Check if we already have channel with that dcid */
+	if (__l2cap_get_chan_by_dcid(conn, scid)) {
+		sock_set_flag(sk, SOCK_ZAPPED);
+		chan->ops->close(chan->data);
+		goto response;
 	}
 
-	return 0;
-}
+	hci_conn_hold(conn->hcon);
 
-static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id)
-{
-	struct l2cap_move_chan_req req;
-	u8 ident;
+	bacpy(&bt_sk(sk)->src, conn->src);
+	bacpy(&bt_sk(sk)->dst, conn->dst);
+	chan->psm  = psm;
+	chan->dcid = scid;
 
-	BT_DBG("pi %p, icid %d, dest_amp_id %d", pi, (int) icid,
-		(int) dest_amp_id);
+	bt_accept_enqueue(parent, sk);
 
-	ident = l2cap_get_ident(conn);
-	if (pi)
-		pi->ident = ident;
+	__l2cap_chan_add(conn, chan);
 
-	req.icid = cpu_to_le16(icid);
-	req.dest_amp_id = dest_amp_id;
+	dcid = chan->scid;
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req), &req);
-}
+	__set_chan_timer(chan, sk->sk_sndtimeo);
 
-static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
-				u16 icid, u16 result)
-{
-	struct l2cap_move_chan_rsp rsp;
+	chan->ident = cmd->ident;
+
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
+		if (l2cap_chan_check_security(chan)) {
+			if (bt_sk(sk)->defer_setup) {
+				__l2cap_state_change(chan, BT_CONNECT2);
+				result = L2CAP_CR_PEND;
+				status = L2CAP_CS_AUTHOR_PEND;
+				parent->sk_data_ready(parent, 0);
+			} else {
+				__l2cap_state_change(chan, BT_CONFIG);
+				result = L2CAP_CR_SUCCESS;
+				status = L2CAP_CS_NO_INFO;
+			}
+		} else {
+			__l2cap_state_change(chan, BT_CONNECT2);
+			result = L2CAP_CR_PEND;
+			status = L2CAP_CS_AUTHEN_PEND;
+		}
+	} else {
+		__l2cap_state_change(chan, BT_CONNECT2);
+		result = L2CAP_CR_PEND;
+		status = L2CAP_CS_NO_INFO;
+	}
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+response:
+	release_sock(parent);
+	mutex_unlock(&conn->chan_lock);
 
-	rsp.icid = cpu_to_le16(icid);
+sendresp:
+	rsp.scid   = cpu_to_le16(scid);
+	rsp.dcid   = cpu_to_le16(dcid);
 	rsp.result = cpu_to_le16(result);
+	rsp.status = cpu_to_le16(status);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
-}
+	if (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {
+		struct l2cap_info_req info;
+		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
 
-static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
-				struct l2cap_pinfo *pi, u16 icid, u16 result)
-{
-	struct l2cap_move_chan_cfm cfm;
-	u8 ident;
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
+		conn->info_ident = l2cap_get_ident(conn);
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+		schedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);
 
-	ident = l2cap_get_ident(conn);
-	if (pi)
-		pi->ident = ident;
+		l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(info), &info);
+	}
 
-	cfm.icid = cpu_to_le16(icid);
-	cfm.result = cpu_to_le16(result);
+	if (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&
+				result == L2CAP_CR_SUCCESS) {
+		u8 buf[128];
+		set_bit(CONF_REQ_SENT, &chan->conf_state);
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, buf), buf);
+		chan->num_conf_req++;
+	}
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
+	return 0;
 }
 
-static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
-					u16 icid)
+static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm_rsp rsp;
+	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
+	u16 scid, dcid, result, status;
+	struct l2cap_chan *chan;
+	u8 req[128];
+	int err;
 
-	BT_DBG("icid %d", (int) icid);
+	scid   = __le16_to_cpu(rsp->scid);
+	dcid   = __le16_to_cpu(rsp->dcid);
+	result = __le16_to_cpu(rsp->result);
+	status = __le16_to_cpu(rsp->status);
 
-	rsp.icid = cpu_to_le16(icid);
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
-}
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x",
+						dcid, scid, result, status);
 
-static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_create_chan_req *req =
-		(struct l2cap_create_chan_req *) data;
-	struct sock *sk;
-	u16 psm, scid;
+	mutex_lock(&conn->chan_lock);
 
-	psm = le16_to_cpu(req->psm);
-	scid = le16_to_cpu(req->scid);
+	if (scid) {
+		chan = __l2cap_get_chan_by_scid(conn, scid);
+		if (!chan) {
+			err = -EFAULT;
+			goto unlock;
+		}
+	} else {
+		chan = __l2cap_get_chan_by_ident(conn, cmd->ident);
+		if (!chan) {
+			err = -EFAULT;
+			goto unlock;
+		}
+	}
 
-	BT_DBG("psm %d, scid %d, amp_id %d", (int) psm, (int) scid,
-		(int) req->amp_id);
+	err = 0;
 
-	if (req->amp_id) {
-		struct hci_dev *hdev;
+	l2cap_chan_lock(chan);
 
-		/* Validate AMP controller id */
-		hdev = hci_dev_get(req->amp_id);
-		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
-			struct l2cap_create_chan_rsp rsp;
-
-			rsp.dcid = 0;
-			rsp.scid = cpu_to_le16(scid);
-			rsp.result = L2CAP_CREATE_CHAN_REFUSED_CONTROLLER;
-			rsp.status = L2CAP_CREATE_CHAN_STATUS_NONE;
+	switch (result) {
+	case L2CAP_CR_SUCCESS:
+		l2cap_state_change(chan, BT_CONFIG);
+		chan->ident = 0;
+		chan->dcid = dcid;
+		clear_bit(CONF_CONNECT_PEND, &chan->conf_state);
 
-			l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
-				       sizeof(rsp), &rsp);
+		if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
+			break;
 
-			if (hdev)
-				hci_dev_put(hdev);
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, req), req);
+		chan->num_conf_req++;
+		break;
 
-			return 0;
-		}
+	case L2CAP_CR_PEND:
+		set_bit(CONF_CONNECT_PEND, &chan->conf_state);
+		break;
 
-		hci_dev_put(hdev);
+	default:
+		l2cap_chan_del(chan, ECONNREFUSED);
+		break;
 	}
 
-	sk = l2cap_create_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,
-					req->amp_id);
-
-	if (sk)
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
+	l2cap_chan_unlock(chan);
 
-	if (sk && req->amp_id &&
-			(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
-		amp_accept_physical(conn, req->amp_id, sk);
+unlock:
+	mutex_unlock(&conn->chan_lock);
 
-	return 0;
+	return err;
 }
 
-static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline void set_default_fcs(struct l2cap_chan *chan)
 {
-	BT_DBG("conn %p", conn);
-
-	return l2cap_connect_rsp(conn, cmd, data);
+	/* FCS is enabled only in ERTM or streaming mode, if one or both
+	 * sides request it.
+	 */
+	if (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)
+		chan->fcs = L2CAP_FCS_NONE;
+	else if (!test_bit(CONF_NO_FCS_RECV, &chan->conf_state))
+		chan->fcs = L2CAP_FCS_CRC16;
 }
 
-static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
 {
-	struct l2cap_move_chan_req *req = (struct l2cap_move_chan_req *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid = 0;
-	u16 result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
+	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
+	u16 dcid, flags;
+	u8 rsp[64];
+	struct l2cap_chan *chan;
+	int len;
 
-	icid = le16_to_cpu(req->icid);
+	dcid  = __le16_to_cpu(req->dcid);
+	flags = __le16_to_cpu(req->flags);
 
-	BT_DBG("icid %d, dest_amp_id %d", (int) icid, (int) req->dest_amp_id);
+	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
+
+	chan = l2cap_get_chan_by_scid(conn, dcid);
+	if (!chan)
+		return -ENOENT;
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
+	l2cap_chan_lock(chan);
 
-	if (!sk)
-		goto send_move_response;
+	if (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {
+		struct l2cap_cmd_rej_cid rej;
 
-	lock_sock(sk);
-	pi = l2cap_pi(sk);
+		rej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);
+		rej.scid = cpu_to_le16(chan->scid);
+		rej.dcid = cpu_to_le16(chan->dcid);
 
-	if (pi->scid < L2CAP_CID_DYN_START ||
-		(pi->mode != L2CAP_MODE_ERTM &&
-		 pi->mode != L2CAP_MODE_STREAMING)) {
-		goto send_move_response;
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
+				sizeof(rej), &rej);
+		goto unlock;
 	}
 
-	if (pi->amp_id == req->dest_amp_id) {
-		result = L2CAP_MOVE_CHAN_REFUSED_SAME_ID;
-		goto send_move_response;
+	/* Reject if config buffer is too small. */
+	len = cmd_len - sizeof(*req);
+	if (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_REJECT, flags), rsp);
+		goto unlock;
 	}
 
-	if (req->dest_amp_id) {
-		struct hci_dev *hdev;
-		hdev = hci_dev_get(req->dest_amp_id);
-		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
-			if (hdev)
-				hci_dev_put(hdev);
+	/* Store config. */
+	memcpy(chan->conf_req + chan->conf_len, req->data, len);
+	chan->conf_len += len;
 
-			result = L2CAP_MOVE_CHAN_REFUSED_CONTROLLER;
-			goto send_move_response;
-		}
-		hci_dev_put(hdev);
+	if (flags & 0x0001) {
+		/* Incomplete config. Send empty response. */
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_SUCCESS, 0x0001), rsp);
+		goto unlock;
 	}
 
-	if (((pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE) ||
-		pi->amp_move_role != L2CAP_AMP_MOVE_NONE) &&
-		bacmp(conn->src, conn->dst) > 0) {
-		result = L2CAP_MOVE_CHAN_REFUSED_COLLISION;
-		goto send_move_response;
+	/* Complete config. */
+	len = l2cap_parse_conf_req(chan, rsp);
+	if (len < 0) {
+		l2cap_send_disconn_req(conn, chan, ECONNRESET);
+		goto unlock;
 	}
 
-	if (pi->amp_pref == BT_AMP_POLICY_REQUIRE_BR_EDR) {
-		result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
-		goto send_move_response;
-	}
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
+	chan->num_conf_rsp++;
 
-	pi->amp_move_cmd_ident = cmd->ident;
-	pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
-	l2cap_amp_move_setup(sk);
-	pi->amp_move_id = req->dest_amp_id;
-	icid = pi->dcid;
+	/* Reset config buffer. */
+	chan->conf_len = 0;
 
-	if (req->dest_amp_id == 0) {
-		/* Moving to BR/EDR */
-		if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			result = L2CAP_MOVE_CHAN_PENDING;
-		} else {
-			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-			result = L2CAP_MOVE_CHAN_SUCCESS;
-		}
-	} else {
-		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
-		amp_accept_physical(pi->conn, req->dest_amp_id, sk);
-		result = L2CAP_MOVE_CHAN_PENDING;
+	if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
+		goto unlock;
+
+	if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
+		set_default_fcs(chan);
+
+		l2cap_state_change(chan, BT_CONNECTED);
+
+		chan->next_tx_seq = 0;
+		chan->expected_tx_seq = 0;
+		skb_queue_head_init(&chan->tx_q);
+		if (chan->mode == L2CAP_MODE_ERTM)
+			l2cap_ertm_init(chan);
+
+		l2cap_chan_ready(chan);
+		goto unlock;
 	}
 
-send_move_response:
-	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
+	if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
+		u8 buf[64];
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, buf), buf);
+		chan->num_conf_req++;
+	}
 
-	if (sk)
-		release_sock(sk);
+	/* Got Conf Rsp PENDING from remote side and asume we sent
+	   Conf Rsp PENDING in the code above */
+	if (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&
+			test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
 
+		/* check compatibility */
+
+		clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+		set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
+
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+					l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_SUCCESS, 0x0000), rsp);
+	}
+
+unlock:
+	l2cap_chan_unlock(chan);
 	return 0;
 }
 
-static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_rsp *rsp = (struct l2cap_move_chan_rsp *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid, result;
+	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
+	u16 scid, flags, result;
+	struct l2cap_chan *chan;
+	int len = cmd->len - sizeof(*rsp);
+
+	scid   = __le16_to_cpu(rsp->scid);
+	flags  = __le16_to_cpu(rsp->flags);
+	result = __le16_to_cpu(rsp->result);
+
+	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
+			scid, flags, result);
+
+	chan = l2cap_get_chan_by_scid(conn, scid);
+	if (!chan)
+		return 0;
+
+	l2cap_chan_lock(chan);
+
+	switch (result) {
+	case L2CAP_CONF_SUCCESS:
+		l2cap_conf_rfc_get(chan, rsp->data, len);
+		clear_bit(CONF_REM_CONF_PEND, &chan->conf_state);
+		break;
+
+	case L2CAP_CONF_PENDING:
+		set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
+
+		if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
+			char buf[64];
+
+			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
+								buf, &result);
+			if (len < 0) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
+			}
 
-	icid = le16_to_cpu(rsp->icid);
-	result = le16_to_cpu(rsp->result);
+			/* check compatibility */
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+			clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
 
-	switch (result) {
-	case L2CAP_MOVE_CHAN_SUCCESS:
-	case L2CAP_MOVE_CHAN_PENDING:
-		read_lock(&conn->chan_list.lock);
-		sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
-		read_unlock(&conn->chan_list.lock);
-
-		if (!sk) {
-			l2cap_send_move_chan_cfm(conn, NULL, icid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			break;
+			l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+						l2cap_build_conf_rsp(chan, buf,
+						L2CAP_CONF_SUCCESS, 0x0000), buf);
 		}
+		goto done;
 
-		lock_sock(sk);
-		pi = l2cap_pi(sk);
+	case L2CAP_CONF_UNACCEPT:
+		if (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
+			char req[64];
 
-		l2cap_sock_clear_timer(sk);
-		if (result == L2CAP_MOVE_CHAN_PENDING)
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_ERTX_TIMEOUT);
-
-		if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
-			/* Move confirm will be sent when logical link
-			 * is complete.
-			 */
-			pi->amp_move_state =
-				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) {
-			if (result == L2CAP_MOVE_CHAN_PENDING) {
-				break;
-			} else if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			} else {
-				/* Logical link is up or moving to BR/EDR,
-				 * proceed with move */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			}
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP) {
-			struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
-					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-			struct hci_chan *chan;
-			/* Moving to AMP */
-			if (result == L2CAP_MOVE_CHAN_SUCCESS) {
-				/* Remote is ready, send confirm immediately
-				 * after logical link is ready
-				 */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-			} else {
-				/* Both logical link and move success
-				 * are required to confirm
-				 */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE;
-			}
-			pi->remote_fs = default_fs;
-			pi->local_fs = default_fs;
-			chan = l2cap_chan_admit(pi->amp_move_id, sk);
-			if (!chan) {
-				/* Logical link not available */
-				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-				break;
+			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
 			}
 
-			if (chan->state == BT_CONNECTED) {
-				/* Logical link is already ready to go */
-				pi->ampcon = chan->conn;
-				pi->ampcon->l2cap_data = pi->conn;
-				if (result == L2CAP_MOVE_CHAN_SUCCESS) {
-					/* Can confirm now */
-					l2cap_send_move_chan_cfm(conn, pi,
-						pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				} else {
-					/* Now only need move success
-					 * required to confirm
-					 */
-					pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-				}
-
-				l2cap_create_cfm(chan, 0);
+			/* throw out any old stored conf requests */
+			result = L2CAP_CONF_SUCCESS;
+			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
+								req, &result);
+			if (len < 0) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
 			}
-		} else {
-			/* Any other amp move state means the move failed. */
-			pi->amp_move_id = pi->amp_id;
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			l2cap_amp_move_revert(sk);
-			pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		}
-		break;
-	default:
-		/* Failed (including collision case) */
-		read_lock(&conn->chan_list.lock);
-		sk = __l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
-		read_unlock(&conn->chan_list.lock);
-
-		if (!sk) {
-			/* Could not locate channel, icid is best guess */
-			l2cap_send_move_chan_cfm(conn, NULL, icid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
+
+			l2cap_send_cmd(conn, l2cap_get_ident(conn),
+						L2CAP_CONF_REQ, len, req);
+			chan->num_conf_req++;
+			if (result != L2CAP_CONF_SUCCESS)
+				goto done;
 			break;
 		}
 
-		lock_sock(sk);
-		pi = l2cap_pi(sk);
+	default:
+		l2cap_chan_set_err(chan, ECONNRESET);
 
-		l2cap_sock_clear_timer(sk);
+		__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);
+		l2cap_send_disconn_req(conn, chan, ECONNRESET);
+		goto done;
+	}
 
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-			if (result == L2CAP_MOVE_CHAN_REFUSED_COLLISION)
-				pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
-			else {
-				/* Cleanup - cancel move */
-				pi->amp_move_id = pi->amp_id;
-				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-				l2cap_amp_move_revert(sk);
-				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			}
-		}
+	if (flags & 0x01)
+		goto done;
 
-		l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-					L2CAP_MOVE_CHAN_UNCONFIRMED);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		break;
-	}
+	set_bit(CONF_INPUT_DONE, &chan->conf_state);
 
-	if (sk)
-		release_sock(sk);
+	if (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {
+		set_default_fcs(chan);
+
+		l2cap_state_change(chan, BT_CONNECTED);
+		chan->next_tx_seq = 0;
+		chan->expected_tx_seq = 0;
+		skb_queue_head_init(&chan->tx_q);
+		if (chan->mode ==  L2CAP_MODE_ERTM)
+			l2cap_ertm_init(chan);
+
+		l2cap_chan_ready(chan);
+	}
 
+done:
+	l2cap_chan_unlock(chan);
 	return 0;
 }
 
-static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm *cfm = (struct l2cap_move_chan_cfm *) data;
+	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
+	struct l2cap_disconn_rsp rsp;
+	u16 dcid, scid;
+	struct l2cap_chan *chan;
 	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid, result;
 
-	icid = le16_to_cpu(cfm->icid);
-	result = le16_to_cpu(cfm->result);
+	scid = __le16_to_cpu(req->scid);
+	dcid = __le16_to_cpu(req->dcid);
+
+	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+	mutex_lock(&conn->chan_lock);
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
-
-	if (!sk) {
-		BT_DBG("Bad channel (%d)", (int) icid);
-		goto send_move_confirm_response;
+	chan = __l2cap_get_chan_by_scid(conn, dcid);
+	if (!chan) {
+		mutex_unlock(&conn->chan_lock);
+		return 0;
 	}
 
+	l2cap_chan_lock(chan);
+
+	sk = chan->sk;
+
+	rsp.dcid = cpu_to_le16(chan->scid);
+	rsp.scid = cpu_to_le16(chan->dcid);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
+
 	lock_sock(sk);
-	pi = l2cap_pi(sk);
+	sk->sk_shutdown = SHUTDOWN_MASK;
+	release_sock(sk);
 
-	if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) {
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		if (result == L2CAP_MOVE_CHAN_CONFIRMED) {
-			pi->amp_id = pi->amp_move_id;
-			if (!pi->amp_id && pi->ampchan) {
-				struct hci_chan *ampchan = pi->ampchan;
-				struct hci_conn *ampcon = pi->ampcon;
-				/* Have moved off of AMP, free the channel */
-				pi->ampchan = NULL;
-				pi->ampcon = NULL;
-				if (hci_chan_put(ampchan))
-					ampcon->l2cap_data = NULL;
-				else
-					l2cap_deaggregate(ampchan, pi);
-			}
-			l2cap_amp_move_success(sk);
-		} else {
-			pi->amp_move_id = pi->amp_id;
-			l2cap_amp_move_revert(sk);
-		}
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	} else if (pi->amp_move_state ==
-			L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
-		BT_DBG("Bad AMP_MOVE_STATE (%d)", pi->amp_move_state);
-	}
+	l2cap_chan_del(chan, ECONNRESET);
 
-send_move_confirm_response:
-	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
+	l2cap_chan_unlock(chan);
 
-	if (sk)
-		release_sock(sk);
+	chan->ops->close(chan->data);
+
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm_rsp *rsp =
-		(struct l2cap_move_chan_cfm_rsp *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-
-	u16 icid;
+	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
+	u16 dcid, scid;
+	struct l2cap_chan *chan;
 
-	icid = le16_to_cpu(rsp->icid);
+	scid = __le16_to_cpu(rsp->scid);
+	dcid = __le16_to_cpu(rsp->dcid);
 
-	BT_DBG("icid %d", (int) icid);
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
+	mutex_lock(&conn->chan_lock);
 
-	if (!sk)
+	chan = __l2cap_get_chan_by_scid(conn, scid);
+	if (!chan) {
+		mutex_unlock(&conn->chan_lock);
 		return 0;
+	}
 
-	lock_sock(sk);
-	pi = l2cap_pi(sk);
-
-	l2cap_sock_clear_timer(sk);
+	l2cap_chan_lock(chan);
 
-	if (pi->amp_move_state ==
-			L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP) {
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		pi->amp_id = pi->amp_move_id;
-
-		if (!pi->amp_id && pi->ampchan) {
-			struct hci_chan *ampchan = pi->ampchan;
-			struct hci_conn *ampcon = pi->ampcon;
-			/* Have moved off of AMP, free the channel */
-			pi->ampchan = NULL;
-			pi->ampcon = NULL;
-			if (hci_chan_put(ampchan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(ampchan, pi);
-		}
+	l2cap_chan_del(chan, 0);
 
-		l2cap_amp_move_success(sk);
+	l2cap_chan_unlock(chan);
 
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	}
+	chan->ops->close(chan->data);
 
-	release_sock(sk);
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static void l2cap_amp_signal_worker(struct work_struct *work)
+static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	int err = 0;
-	struct l2cap_amp_signal_work *ampwork =
-		container_of(work, struct l2cap_amp_signal_work, work);
-
-	switch (ampwork->cmd.code) {
-	case L2CAP_MOVE_CHAN_REQ:
-		err = l2cap_move_channel_req(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
+	u16 type;
 
-	case L2CAP_MOVE_CHAN_RSP:
-		err = l2cap_move_channel_rsp(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	type = __le16_to_cpu(req->type);
 
-	case L2CAP_MOVE_CHAN_CFM:
-		err = l2cap_move_channel_confirm(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	BT_DBG("type 0x%4.4x", type);
 
-	case L2CAP_MOVE_CHAN_CFM_RSP:
-		err = l2cap_move_channel_confirm_rsp(ampwork->conn,
-						&ampwork->cmd, ampwork->data);
-		break;
+	if (type == L2CAP_IT_FEAT_MASK) {
+		u8 buf[8];
+		u32 feat_mask = l2cap_feat_mask;
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		if (!disable_ertm)
+			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
+							 | L2CAP_FEAT_FCS;
+		if (enable_hs)
+			feat_mask |= L2CAP_FEAT_EXT_FLOW
+						| L2CAP_FEAT_EXT_WINDOW;
 
-	default:
-		BT_ERR("Unknown signaling command 0x%2.2x", ampwork->cmd.code);
-		err = -EINVAL;
-		break;
-	}
+		put_unaligned_le32(feat_mask, rsp->data);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		u8 buf[12];
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
 
-	if (err) {
-		struct l2cap_cmd_rej rej;
-		BT_DBG("error %d", err);
+		if (enable_hs)
+			l2cap_fixed_chan[0] |= L2CAP_FC_A2MP;
+		else
+			l2cap_fixed_chan[0] &= ~L2CAP_FC_A2MP;
 
-		/* In this context, commands are only rejected with
-		 * "command not understood", code 0.
-		 */
-		rej.reason = cpu_to_le16(0);
-		l2cap_send_cmd(ampwork->conn, ampwork->cmd.ident,
-				L2CAP_COMMAND_REJ, sizeof(rej), &rej);
+		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		memcpy(rsp->data, l2cap_fixed_chan, sizeof(l2cap_fixed_chan));
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else {
+		struct l2cap_info_rsp rsp;
+		rsp.type   = cpu_to_le16(type);
+		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
 	}
 
-	kfree_skb(ampwork->skb);
-	kfree(ampwork);
+	return 0;
 }
 
-void l2cap_amp_physical_complete(int result, u8 local_id, u8 remote_id,
-				struct sock *sk)
+static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_pinfo *pi;
+	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
+	u16 type, result;
 
-	BT_DBG("result %d, local_id %d, remote_id %d, sk %p", result,
-		(int) local_id, (int) remote_id, sk);
+	type   = __le16_to_cpu(rsp->type);
+	result = __le16_to_cpu(rsp->result);
 
-	lock_sock(sk);
+	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
 
-	if (sk->sk_state == BT_DISCONN || sk->sk_state == BT_CLOSED) {
-		release_sock(sk);
-		return;
+	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
+	if (cmd->ident != conn->info_ident ||
+			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
+		return 0;
+
+	cancel_delayed_work(&conn->info_timer);
+
+	if (result != L2CAP_IR_SUCCESS) {
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
+
+		return 0;
 	}
 
-	pi = l2cap_pi(sk);
+	switch (type) {
+	case L2CAP_IT_FEAT_MASK:
+		conn->feat_mask = get_unaligned_le32(rsp->data);
 
-	if (sk->sk_state != BT_CONNECTED) {
-		if (bt_sk(sk)->parent) {
-			struct l2cap_conn_rsp rsp;
-			char buf[128];
-			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
+			struct l2cap_info_req req;
+			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
 
-			/* Incoming channel on AMP */
-			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
-				/* Send successful response */
-				rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			} else {
-				/* Send negative response */
-				rsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);
-				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			}
+			conn->info_ident = l2cap_get_ident(conn);
 
-			l2cap_send_cmd(pi->conn, pi->ident,
-					L2CAP_CREATE_CHAN_RSP,
-					sizeof(rsp), &rsp);
-
-			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
-				sk->sk_state = BT_CONFIG;
-				pi->conf_state |= L2CAP_CONF_REQ_SENT;
-				l2cap_send_cmd(pi->conn,
-					l2cap_get_ident(pi->conn),
-					L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-				l2cap_pi(sk)->num_conf_req++;
-			}
+			l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(req), &req);
 		} else {
-			/* Outgoing channel on AMP */
-			if (result != L2CAP_CREATE_CHAN_SUCCESS) {
-				/* Revert to BR/EDR connect */
-				l2cap_send_conn_req(sk);
-			} else {
-				pi->amp_id = local_id;
-				l2cap_send_create_chan_req(sk, remote_id);
-			}
-		}
-	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
-		pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		l2cap_amp_move_setup(sk);
-		pi->amp_move_id = local_id;
-		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_RSP;
-
-		l2cap_send_move_chan_req(pi->conn, pi, pi->scid, remote_id);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
-		pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-		struct hci_chan *chan;
-		struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
-				0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-		pi->remote_fs = default_fs;
-		pi->local_fs = default_fs;
-		chan = l2cap_chan_admit(local_id, sk);
-		if (chan) {
-			if (chan->state == BT_CONNECTED) {
-				/* Logical link is ready to go */
-				pi->ampcon = chan->conn;
-				pi->ampcon->l2cap_data = pi->conn;
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_SUCCESS);
+			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+			conn->info_ident = 0;
 
-				l2cap_create_cfm(chan, 0);
-			} else {
-				/* Wait for logical link to be ready */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-			}
-		} else {
-			/* Logical link not available */
-			l2cap_send_move_chan_rsp(pi->conn,
-				pi->amp_move_cmd_ident, pi->dcid,
-				L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
-		}
-	} else {
-		BT_DBG("result %d, role %d, local_busy %d", result,
-			(int) pi->amp_move_role,
-			(int) ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) != 0));
-
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-			if (result == -EINVAL)
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_CONTROLLER);
-			else
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
+			l2cap_conn_start(conn);
 		}
+		break;
 
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-
-		if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-			l2cap_rmem_available(sk))
-			l2cap_ertm_tx(sk, 0, 0,
-					L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
+	case L2CAP_IT_FIXED_CHAN:
+		conn->fixed_chan_mask = rsp->data[0];
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
 
-		/* Restart data transmission */
-		l2cap_ertm_send(sk);
+		l2cap_conn_start(conn);
+		break;
 	}
 
-	release_sock(sk);
+	return 0;
 }
 
-static void l2cap_logical_link_complete(struct hci_chan *chan, u8 status)
+static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u16 cmd_len,
+					void *data)
 {
-	struct l2cap_pinfo *pi;
-	struct sock *sk;
-	struct hci_chan *ampchan;
-	struct hci_conn *ampcon;
+	struct l2cap_create_chan_req *req = data;
+	struct l2cap_create_chan_rsp rsp;
+	u16 psm, scid;
 
-	BT_DBG("status %d, chan %p, conn %p", (int) status, chan, chan->conn);
+	if (cmd_len != sizeof(*req))
+		return -EPROTO;
 
-	sk = chan->l2cap_sk;
-	chan->l2cap_sk = NULL;
+	if (!enable_hs)
+		return -EINVAL;
 
-	BT_DBG("sk %p", sk);
+	psm = le16_to_cpu(req->psm);
+	scid = le16_to_cpu(req->scid);
 
-	lock_sock(sk);
+	BT_DBG("psm %d, scid %d, amp_id %d", psm, scid, req->amp_id);
 
-	if (sk->sk_state != BT_CONNECTED && !l2cap_pi(sk)->amp_id) {
-		release_sock(sk);
-		return;
-	}
+	/* Placeholder: Always reject */
+	rsp.dcid = 0;
+	rsp.scid = cpu_to_le16(scid);
+	rsp.result = L2CAP_CR_NO_MEM;
+	rsp.status = L2CAP_CS_NO_INFO;
 
-	pi = l2cap_pi(sk);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
+		       sizeof(rsp), &rsp);
 
-	if ((!status) && (chan != NULL)) {
-		pi->ampcon = chan->conn;
-		pi->ampcon->l2cap_data = pi->conn;
+	return 0;
+}
 
-		BT_DBG("amp_move_state %d", pi->amp_move_state);
+static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, void *data)
+{
+	BT_DBG("conn %p", conn);
 
-		if (sk->sk_state != BT_CONNECTED) {
-			struct l2cap_conf_rsp rsp;
+	return l2cap_connect_rsp(conn, cmd, data);
+}
 
-			/* Must use spinlock to prevent concurrent
-			 * execution of l2cap_config_rsp()
-			 */
-			bh_lock_sock(sk);
-			l2cap_send_cmd(pi->conn, pi->conf_ident, L2CAP_CONF_RSP,
-					l2cap_build_conf_rsp(sk, &rsp,
-						L2CAP_CONF_SUCCESS, 0), &rsp);
-			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
+static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
+							u16 icid, u16 result)
+{
+	struct l2cap_move_chan_rsp rsp;
 
-			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
-				set_default_fcs(l2cap_pi(sk));
+	BT_DBG("icid %d, result %d", icid, result);
 
-				sk->sk_state = BT_CONNECTED;
+	rsp.icid = cpu_to_le16(icid);
+	rsp.result = cpu_to_le16(result);
 
-				if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
-				    l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-					l2cap_ertm_init(sk);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
+}
 
-				l2cap_chan_ready(sk);
-			}
-			bh_unlock_sock(sk);
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
-			/* Move confirm will be sent after a success
-			 * response is received
-			 */
-			pi->amp_move_state =
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_INITIATOR) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
-					L2CAP_MOVE_CHAN_SUCCESS);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			} else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_RESPONDER) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_SUCCESS);
-			}
-		} else if ((pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) &&
-			(pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) &&
-			(pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP)) {
-			/* Move was not in expected state, free the channel */
-			ampchan = pi->ampchan;
-			ampcon = pi->ampcon;
-			pi->ampchan = NULL;
-			pi->ampcon = NULL;
-			if (ampchan) {
-				if (hci_chan_put(ampchan))
-					ampcon->l2cap_data = NULL;
-				else
-					l2cap_deaggregate(ampchan, pi);
-			}
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		}
-	} else {
-		/* Logical link setup failed. */
+static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
+				struct l2cap_chan *chan, u16 icid, u16 result)
+{
+	struct l2cap_move_chan_cfm cfm;
+	u8 ident;
 
-		if (sk->sk_state != BT_CONNECTED)
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-			l2cap_amp_move_revert(sk);
-			l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_CONFIG);
-		} else if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-			if ((pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) ||
-				(pi->amp_move_state ==
-				    L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM)) {
-				/* Remote has only sent pending or
-				 * success responses, clean up
-				 */
-				l2cap_amp_move_revert(sk);
-				l2cap_pi(sk)->amp_move_role =
-					L2CAP_AMP_MOVE_NONE;
-				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			}
+	BT_DBG("icid %d, result %d", icid, result);
 
-			/* Other amp move states imply that the move
-			 * has already aborted
-			 */
-			l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		}
-		ampchan = pi->ampchan;
-		ampcon = pi->ampcon;
-		pi->ampchan = NULL;
-		pi->ampcon = NULL;
-		if (ampchan) {
-			if (hci_chan_put(ampchan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(ampchan, pi);
-		}
-	}
+	ident = l2cap_get_ident(conn);
+	if (chan)
+		chan->ident = ident;
 
-	release_sock(sk);
+	cfm.icid = cpu_to_le16(icid);
+	cfm.result = cpu_to_le16(result);
+
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
 }
 
-static void l2cap_logical_link_worker(struct work_struct *work)
+static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
+								u16 icid)
 {
-	struct l2cap_logical_link_work *log_link_work =
-		container_of(work, struct l2cap_logical_link_work, work);
-	struct sock *sk = log_link_work->chan->l2cap_sk;
+	struct l2cap_move_chan_cfm_rsp rsp;
 
-	if (sk) {
-		l2cap_logical_link_complete(log_link_work->chan,
-							log_link_work->status);
-		sock_put(sk);
-	}
-	hci_chan_put(log_link_work->chan);
-	kfree(log_link_work);
+	BT_DBG("icid %d", icid);
+
+	rsp.icid = cpu_to_le16(icid);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
 }
 
-static int l2cap_create_cfm(struct hci_chan *chan, u8 status)
+static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_logical_link_work *amp_work;
+	struct l2cap_move_chan_req *req = data;
+	u16 icid = 0;
+	u16 result = L2CAP_MR_NOT_ALLOWED;
 
-	if (!chan->l2cap_sk) {
-		BT_ERR("Expected l2cap_sk to point to connecting socket");
-		return -EFAULT;
-	}
+	if (cmd_len != sizeof(*req))
+		return -EPROTO;
 
-	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
-	if (!amp_work) {
-		sock_put(chan->l2cap_sk);
-		return -ENOMEM;
-	}
-
-	INIT_WORK(&amp_work->work, l2cap_logical_link_worker);
-	amp_work->chan = chan;
-	amp_work->status = status;
-
-	hci_chan_hold(chan);
-
-	if (!queue_work(_l2cap_wq, &amp_work->work)) {
-		kfree(amp_work);
-		sock_put(chan->l2cap_sk);
-		hci_chan_put(chan);
-		return -ENOMEM;
-	}
+	icid = le16_to_cpu(req->icid);
 
-	return 0;
-}
+	BT_DBG("icid %d, dest_amp_id %d", icid, req->dest_amp_id);
 
-int l2cap_modify_cfm(struct hci_chan *chan, u8 status)
-{
-	struct l2cap_conn *conn = chan->conn->l2cap_data;
+	if (!enable_hs)
+		return -EINVAL;
 
-	BT_DBG("chan %p conn %p status %d", chan, conn, status);
+	/* Placeholder: Always refuse */
+	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
 
-	/* TODO: if failed status restore previous fs */
 	return 0;
 }
 
-int l2cap_destroy_cfm(struct hci_chan *chan, u8 reason)
+static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_chan_list *l;
-	struct l2cap_conn *conn = chan->conn->l2cap_data;
-	struct sock *sk;
+	struct l2cap_move_chan_rsp *rsp = data;
+	u16 icid, result;
 
-	BT_DBG("chan %p conn %p", chan, conn);
+	if (cmd_len != sizeof(*rsp))
+		return -EPROTO;
 
-	if (!conn)
-		return 0;
+	icid = le16_to_cpu(rsp->icid);
+	result = le16_to_cpu(rsp->result);
 
-	l = &conn->chan_list;
+	BT_DBG("icid %d, result %d", icid, result);
 
-	read_lock(&l->lock);
+	/* Placeholder: Always unconfirmed */
+	l2cap_send_move_chan_cfm(conn, NULL, icid, L2CAP_MC_UNCONFIRMED);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
-		/* TODO MM/PK - What to do if connection is LOCAL_BUSY?  */
-		if (l2cap_pi(sk)->ampchan == chan) {
-			struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
-			l2cap_pi(sk)->ampchan = NULL;
-			l2cap_pi(sk)->ampcon = NULL;
-			if (hci_chan_put(chan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(chan, l2cap_pi(sk));
+	return 0;
+}
 
-			l2cap_amp_move_init(sk);
-		}
-		bh_unlock_sock(sk);
-	}
+static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+{
+	struct l2cap_move_chan_cfm *cfm = data;
+	u16 icid, result;
+
+	if (cmd_len != sizeof(*cfm))
+		return -EPROTO;
 
-	read_unlock(&l->lock);
+	icid = le16_to_cpu(cfm->icid);
+	result = le16_to_cpu(cfm->result);
 
-	return 0;
+	BT_DBG("icid %d, result %d", icid, result);
 
+	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
 
+	return 0;
 }
 
-static int l2cap_sig_amp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd,
-			u8 *data, struct sk_buff *skb)
+static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_amp_signal_work *amp_work;
+	struct l2cap_move_chan_cfm_rsp *rsp = data;
+	u16 icid;
 
-	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
-	if (!amp_work)
-		return -ENOMEM;
-
-	INIT_WORK(&amp_work->work, l2cap_amp_signal_worker);
-	amp_work->conn = conn;
-	amp_work->cmd = *cmd;
-	amp_work->data = data;
-	amp_work->skb = skb_clone(skb, GFP_ATOMIC);
-	if (!amp_work->skb) {
-		kfree(amp_work);
-		return -ENOMEM;
-	}
-
-	if (!queue_work(_l2cap_wq, &amp_work->work)) {
-		kfree_skb(amp_work->skb);
-		kfree(amp_work);
-		return -ENOMEM;
-	}
+	if (cmd_len != sizeof(*rsp))
+		return -EPROTO;
+
+	icid = le16_to_cpu(rsp->icid);
+
+	BT_DBG("icid %d", icid);
 
 	return 0;
 }
@@ -5720,8 +3436,7 @@
 	struct hci_conn *hcon = conn->hcon;
 	struct l2cap_conn_param_update_req *req;
 	struct l2cap_conn_param_update_rsp rsp;
-	struct sock *sk;
-	u16 min, max, latency, timeout, cmd_len;
+	u16 min, max, latency, to_multiplier, cmd_len;
 	int err;
 
 	if (!(hcon->link_mode & HCI_LM_MASTER))
@@ -5731,39 +3446,34 @@
 	if (cmd_len != sizeof(struct l2cap_conn_param_update_req))
 		return -EPROTO;
 
-	memset(&rsp, 0, sizeof(rsp));
-	rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
+	req = (struct l2cap_conn_param_update_req *) data;
+	min		= __le16_to_cpu(req->min);
+	max		= __le16_to_cpu(req->max);
+	latency		= __le16_to_cpu(req->latency);
+	to_multiplier	= __le16_to_cpu(req->to_multiplier);
 
-	sk = l2cap_find_sock_by_fixed_cid_and_dir(4, conn->src, conn->dst, 0);
+	BT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",
+						min, max, latency, to_multiplier);
 
-	if (sk && !bt_sk(sk)->le_params.prohibit_remote_chg) {
-		req = (struct l2cap_conn_param_update_req *) data;
-		min = __le16_to_cpu(req->min);
-		max = __le16_to_cpu(req->max);
-		latency = __le16_to_cpu(req->latency);
-		timeout = __le16_to_cpu(req->to_multiplier);
+	memset(&rsp, 0, sizeof(rsp));
 
-		err = l2cap_check_conn_param(min, max, latency, timeout);
-		if (!err) {
-			rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
-			hci_le_conn_update(hcon, min, max, latency, timeout);
-			bt_sk(sk)->le_params.interval_min = min;
-			bt_sk(sk)->le_params.interval_max = max;
-			bt_sk(sk)->le_params.latency = latency;
-			bt_sk(sk)->le_params.supervision_timeout = timeout;
-		}
-	}
+	err = l2cap_check_conn_param(min, max, latency, to_multiplier);
+	if (err)
+		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
+	else
+		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
 
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,
 							sizeof(rsp), &rsp);
 
+	if (!err)
+		hci_le_conn_update(hcon, min, max, latency, to_multiplier);
 
 	return 0;
 }
 
 static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data,
-			struct sk_buff *skb)
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
 {
 	int err = 0;
 
@@ -5812,7 +3522,7 @@
 		break;
 
 	case L2CAP_CREATE_CHAN_REQ:
-		err = l2cap_create_channel_req(conn, cmd, data);
+		err = l2cap_create_channel_req(conn, cmd, cmd_len, data);
 		break;
 
 	case L2CAP_CREATE_CHAN_RSP:
@@ -5820,11 +3530,21 @@
 		break;
 
 	case L2CAP_MOVE_CHAN_REQ:
+		err = l2cap_move_channel_req(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_RSP:
+		err = l2cap_move_channel_rsp(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_CFM:
+		err = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_CFM_RSP:
-		err = l2cap_sig_amp(conn, cmd, data, skb);
+		err = l2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);
 		break;
+
 	default:
 		BT_ERR("Unknown BR/EDR signaling command 0x%2.2x", cmd->code);
 		err = -EINVAL;
@@ -5881,16 +3601,15 @@
 		if (conn->hcon->type == LE_LINK)
 			err = l2cap_le_sig_cmd(conn, &cmd, data);
 		else
-			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len,
-							data, skb);
+			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len, data);
 
 		if (err) {
-			struct l2cap_cmd_rej rej;
+			struct l2cap_cmd_rej_unk rej;
 
 			BT_ERR("Wrong link type (%d)", err);
 
 			/* FIXME: Map err to a valid reason */
-			rej.reason = cpu_to_le16(0);
+			rej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);
 			l2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);
 		}
 
@@ -5901,183 +3620,94 @@
 	kfree_skb(skb);
 }
 
-static int l2cap_check_fcs(struct l2cap_pinfo *pi,  struct sk_buff *skb)
+static int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)
 {
 	u16 our_fcs, rcv_fcs;
 	int hdr_size;
 
-	if (pi->extended_control)
-		hdr_size = L2CAP_EXTENDED_HDR_SIZE;
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hdr_size = L2CAP_EXT_HDR_SIZE;
 	else
-		hdr_size = L2CAP_ENHANCED_HDR_SIZE;
+		hdr_size = L2CAP_ENH_HDR_SIZE;
 
-	if (pi->fcs == L2CAP_FCS_CRC16) {
+	if (chan->fcs == L2CAP_FCS_CRC16) {
 		skb_trim(skb, skb->len - L2CAP_FCS_SIZE);
 		rcv_fcs = get_unaligned_le16(skb->data + skb->len);
 		our_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);
 
-		if (our_fcs != rcv_fcs) {
-			BT_DBG("Bad FCS");
+		if (our_fcs != rcv_fcs)
 			return -EBADMSG;
-		}
 	}
 	return 0;
 }
 
-static void l2cap_ertm_pass_to_tx(struct sock *sk,
-				struct bt_l2cap_control *control)
-{
-	BT_DBG("sk %p, control %p", sk, control);
-	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT);
-}
-
-static void l2cap_ertm_pass_to_tx_fbit(struct sock *sk,
-				struct bt_l2cap_control *control)
+static inline void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)
 {
-	BT_DBG("sk %p, control %p", sk, control);
-	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_FBIT);
-}
-
-static void l2cap_ertm_resend(struct sock *sk)
-{
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-	struct sk_buff *tx_skb;
-	u16 seq;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
-
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return;
-
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return;
-
-	while (pi->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {
-		seq = l2cap_seq_list_pop(&pi->retrans_list);
-
-		skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), seq);
-		if (!skb) {
-			BT_DBG("Error: Can't retransmit seq %d, frame missing",
-				(int) seq);
-			continue;
-		}
-
-		bt_cb(skb)->retries += 1;
-		control = bt_cb(skb)->control;
-
-		if ((pi->max_tx != 0) && (bt_cb(skb)->retries > pi->max_tx)) {
-			BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			l2cap_seq_list_clear(&pi->retrans_list);
-			break;
-		}
-
-		control.reqseq = pi->buffer_seq;
-		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-			control.final = 1;
-			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-		} else {
-			control.final = 0;
-		}
-
-		if (skb_cloned(skb)) {
-			/* Cloned sk_buffs are read-only, so we need a
-			 * writeable copy
-			 */
-			tx_skb = skb_copy(skb, GFP_ATOMIC);
-		} else {
-			tx_skb = skb_clone(skb, GFP_ATOMIC);
-		}
+	u32 control = 0;
 
-		if (!tx_skb) {
-			l2cap_seq_list_clear(&pi->retrans_list);
-			break;
-		}
-
-		/* Update skb contents */
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(&control),
-					tx_skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(&control),
-					tx_skb->data + L2CAP_HDR_SIZE);
-		}
+	chan->frames_sent = 0;
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(tx_skb);
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-		sock_hold(sk);
-		tx_skb->sk = sk;
-		tx_skb->destructor = l2cap_skb_destructor;
-		atomic_inc(&pi->ertm_queued);
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		l2cap_send_sframe(chan, control);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+	}
 
-		l2cap_do_send(sk, tx_skb);
+	if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))
+		l2cap_retransmit_frames(chan);
 
-		BT_DBG("Resent txseq %d", (int)control.txseq);
+	l2cap_ertm_send(chan);
 
-		pi->last_acked_seq = pi->buffer_seq;
+	if (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&
+			chan->frames_sent == 0) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+		l2cap_send_sframe(chan, control);
 	}
 }
 
-static inline void l2cap_ertm_retransmit(struct sock *sk,
-					struct bt_l2cap_control *control)
-{
-	BT_DBG("sk %p, control %p", sk, control);
-
-	l2cap_seq_list_append(&l2cap_pi(sk)->retrans_list, control->reqseq);
-	l2cap_ertm_resend(sk);
-}
-
-static void l2cap_ertm_retransmit_all(struct sock *sk,
-				struct bt_l2cap_control *control)
+static int l2cap_add_to_srej_queue(struct l2cap_chan *chan, struct sk_buff *skb, u16 tx_seq, u8 sar)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
+	struct sk_buff *next_skb;
+	int tx_seq_offset, next_tx_seq_offset;
 
-	BT_DBG("sk %p, control %p", sk, control);
+	bt_cb(skb)->tx_seq = tx_seq;
+	bt_cb(skb)->sar = sar;
 
-	pi = l2cap_pi(sk);
+	next_skb = skb_peek(&chan->srej_q);
 
-	if (control->poll)
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
 
-	l2cap_seq_list_clear(&pi->retrans_list);
+	while (next_skb) {
+		if (bt_cb(next_skb)->tx_seq == tx_seq)
+			return -EINVAL;
 
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return;
+		next_tx_seq_offset = __seq_offset(chan,
+				bt_cb(next_skb)->tx_seq, chan->buffer_seq);
 
-	if (pi->unacked_frames) {
-		skb_queue_walk(TX_QUEUE(sk), skb) {
-			if ((bt_cb(skb)->control.txseq == control->reqseq) ||
-				skb == sk->sk_send_head)
-				break;
+		if (next_tx_seq_offset > tx_seq_offset) {
+			__skb_queue_before(&chan->srej_q, next_skb, skb);
+			return 0;
 		}
 
-		skb_queue_walk_from(TX_QUEUE(sk), skb) {
-			if (skb == sk->sk_send_head)
-				break;
+		if (skb_queue_is_last(&chan->srej_q, next_skb))
+			next_skb = NULL;
+		else
+			next_skb = skb_queue_next(&chan->srej_q, next_skb);
+	}
 
-			l2cap_seq_list_append(&pi->retrans_list,
-					bt_cb(skb)->control.txseq);
-		}
+	__skb_queue_tail(&chan->srej_q, skb);
 
-		l2cap_ertm_resend(sk);
-	}
+	return 0;
 }
 
-static inline void append_skb_frag(struct sk_buff *skb,
+static void append_skb_frag(struct sk_buff *skb,
 			struct sk_buff *new_frag, struct sk_buff **last_frag)
 {
 	/* skb->len reflects data in skb as well as all fragments
-	   skb->data_len reflects only data in fragments
+	 * skb->data_len reflects only data in fragments
 	 */
-	BT_DBG("skb %p, new_frag %p, *last_frag %p", skb, new_frag, *last_frag);
-
 	if (!skb_has_frag_list(skb))
 		skb_shinfo(skb)->frag_list = new_frag;
 
@@ -6091,1147 +3721,651 @@
 	skb->truesize += new_frag->truesize;
 }
 
-static int l2cap_ertm_rx_expected_iframe(struct sock *sk,
-			struct bt_l2cap_control *control, struct sk_buff *skb)
+static int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb, u32 control)
 {
-	struct l2cap_pinfo *pi;
 	int err = -EINVAL;
 
-	BT_DBG("sk %p, control %p, skb %p len %d truesize %d", sk, control,
-		skb, skb->len, skb->truesize);
-
-	if (!control)
-		return err;
-
-	pi = l2cap_pi(sk);
-
-	BT_DBG("type %c, sar %d, txseq %d, reqseq %d, final %d",
-		control->frame_type, control->sar, control->txseq,
-		control->reqseq, control->final);
-
-	switch (control->sar) {
+	switch (__get_ctrl_sar(chan, control)) {
 	case L2CAP_SAR_UNSEGMENTED:
-		if (pi->sdu) {
-			BT_DBG("Unexpected unsegmented PDU during reassembly");
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-			pi->sdu_last_frag = NULL;
-			pi->sdu_len = 0;
-		}
+		if (chan->sdu)
+			break;
 
-		BT_DBG("Unsegmented");
-		err = sock_queue_rcv_skb(sk, skb);
+		err = chan->ops->recv(chan->data, skb);
 		break;
 
 	case L2CAP_SAR_START:
-		if (pi->sdu) {
-			BT_DBG("Unexpected start PDU during reassembly");
-			kfree_skb(pi->sdu);
-		}
+		if (chan->sdu)
+			break;
 
-		pi->sdu_len = get_unaligned_le16(skb->data);
-		skb_pull(skb, 2);
+		chan->sdu_len = get_unaligned_le16(skb->data);
+		skb_pull(skb, L2CAP_SDULEN_SIZE);
 
-		if (pi->sdu_len > pi->imtu) {
+		if (chan->sdu_len > chan->imtu) {
 			err = -EMSGSIZE;
 			break;
 		}
 
-		if (skb->len >= pi->sdu_len)
+		if (skb->len >= chan->sdu_len)
 			break;
 
-		pi->sdu = skb;
-		pi->sdu_last_frag = skb;
-
-		BT_DBG("Start");
+		chan->sdu = skb;
+		chan->sdu_last_frag = skb;
 
 		skb = NULL;
 		err = 0;
 		break;
 
 	case L2CAP_SAR_CONTINUE:
-		if (!pi->sdu)
+		if (!chan->sdu)
 			break;
 
-		append_skb_frag(pi->sdu, skb,
-				&pi->sdu_last_frag);
+		append_skb_frag(chan->sdu, skb,
+				&chan->sdu_last_frag);
 		skb = NULL;
 
-		if (pi->sdu->len >= pi->sdu_len)
+		if (chan->sdu->len >= chan->sdu_len)
 			break;
 
-		BT_DBG("Continue, reassembled %d", pi->sdu->len);
-
 		err = 0;
 		break;
 
 	case L2CAP_SAR_END:
-		if (!pi->sdu)
+		if (!chan->sdu)
 			break;
 
-		append_skb_frag(pi->sdu, skb,
-				&pi->sdu_last_frag);
+		append_skb_frag(chan->sdu, skb,
+				&chan->sdu_last_frag);
 		skb = NULL;
 
-		if (pi->sdu->len != pi->sdu_len)
+		if (chan->sdu->len != chan->sdu_len)
 			break;
 
-		BT_DBG("End, reassembled %d", pi->sdu->len);
-		/* If the sender used tiny PDUs, the rcv queuing could fail.
-		 * Applications that have issues here should use a larger
-		 * sk_rcvbuf.
-		 */
-		err = sock_queue_rcv_skb(sk, pi->sdu);
+		err = chan->ops->recv(chan->data, chan->sdu);
 
 		if (!err) {
 			/* Reassembly complete */
-			pi->sdu = NULL;
-			pi->sdu_last_frag = NULL;
-			pi->sdu_len = 0;
+			chan->sdu = NULL;
+			chan->sdu_last_frag = NULL;
+			chan->sdu_len = 0;
 		}
 		break;
-
-	default:
-		BT_DBG("Bad SAR value");
-		break;
 	}
 
 	if (err) {
-		BT_DBG("Reassembly error %d, sk_rcvbuf %d, sk_rmem_alloc %d",
-			err, sk->sk_rcvbuf, atomic_read(&sk->sk_rmem_alloc));
-		if (pi->sdu) {
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-		}
-		pi->sdu_last_frag = NULL;
-		pi->sdu_len = 0;
-		if (skb)
-			kfree_skb(skb);
+		kfree_skb(skb);
+		kfree_skb(chan->sdu);
+		chan->sdu = NULL;
+		chan->sdu_last_frag = NULL;
+		chan->sdu_len = 0;
 	}
 
-	/* Update local busy state */
-	if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY) && l2cap_rmem_full(sk))
-		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED);
-
 	return err;
 }
 
-static int l2cap_ertm_rx_queued_iframes(struct sock *sk)
+static void l2cap_ertm_enter_local_busy(struct l2cap_chan *chan)
 {
-	int err = 0;
-	/* Pass sequential frames to l2cap_ertm_rx_expected_iframe()
-	 * until a gap is encountered.
-	 */
-
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p", sk);
-	pi = l2cap_pi(sk);
-
-	while (l2cap_rmem_available(sk)) {
-		struct sk_buff *skb;
-		BT_DBG("Searching for skb with txseq %d (queue len %d)",
-			(int) pi->buffer_seq, skb_queue_len(SREJ_QUEUE(sk)));
-
-		skb = l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), pi->buffer_seq);
+	BT_DBG("chan %p, Enter local busy", chan);
 
-		if (!skb)
-			break;
-
-		skb_unlink(skb, SREJ_QUEUE(sk));
-		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
-		err = l2cap_ertm_rx_expected_iframe(sk,
-						&bt_cb(skb)->control, skb);
-		if (err)
-			break;
-	}
-
-	if (skb_queue_empty(SREJ_QUEUE(sk))) {
-		pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-		l2cap_ertm_send_ack(sk);
-	}
+	set_bit(CONN_LOCAL_BUSY, &chan->conn_state);
 
-	return err;
+	__set_ack_timer(chan);
 }
 
-static void l2cap_ertm_handle_srej(struct sock *sk,
-				struct bt_l2cap_control *control)
+static void l2cap_ertm_exit_local_busy(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-
-	BT_DBG("sk %p, control %p", sk, control);
-
-	pi = l2cap_pi(sk);
-
-	if (control->reqseq == pi->next_tx_seq) {
-		BT_DBG("Invalid reqseq %d, disconnecting",
-			(int) control->reqseq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
+	u32 control;
 
-	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
-
-	if (skb == NULL) {
-		BT_DBG("Seq %d not available for retransmission",
-			(int) control->reqseq);
-		return;
-	}
+	if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
+		goto done;
 
-	if ((pi->max_tx != 0) && (bt_cb(skb)->retries >= pi->max_tx)) {
-		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
+	control = __set_reqseq(chan, chan->buffer_seq);
+	control |= __set_ctrl_poll(chan);
+	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+	l2cap_send_sframe(chan, control);
+	chan->retry_count = 1;
 
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	__clear_retrans_timer(chan);
+	__set_monitor_timer(chan);
 
-	if (control->poll) {
-		l2cap_ertm_pass_to_tx(sk, control);
+	set_bit(CONN_WAIT_F, &chan->conn_state);
 
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-		l2cap_ertm_retransmit(sk, control);
-		l2cap_ertm_send(sk);
-
-		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
-			pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-			pi->srej_save_reqseq = control->reqseq;
-		}
-	} else {
-		l2cap_ertm_pass_to_tx_fbit(sk, control);
+done:
+	clear_bit(CONN_LOCAL_BUSY, &chan->conn_state);
+	clear_bit(CONN_RNR_SENT, &chan->conn_state);
 
-		if (control->final) {
-			if ((pi->conn_state & L2CAP_CONN_SREJ_ACT) &&
-				(pi->srej_save_reqseq == control->reqseq)) {
-				pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
-			} else {
-				l2cap_ertm_retransmit(sk, control);
-			}
-		} else {
-			l2cap_ertm_retransmit(sk, control);
-			if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
-				pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-				pi->srej_save_reqseq = control->reqseq;
-			}
-		}
-	}
+	BT_DBG("chan %p, Exit local busy", chan);
 }
 
-static void l2cap_ertm_handle_rej(struct sock *sk,
-				struct bt_l2cap_control *control)
+void l2cap_chan_busy(struct l2cap_chan *chan, int busy)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-
-	BT_DBG("sk %p, control %p", sk, control);
-
-	pi = l2cap_pi(sk);
-
-	if (control->reqseq == pi->next_tx_seq) {
-		BT_DBG("Invalid reqseq %d, disconnecting",
-			(int) control->reqseq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
-
-	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
-
-	if (pi->max_tx && skb && bt_cb(skb)->retries >= pi->max_tx) {
-		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
-
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-	l2cap_ertm_pass_to_tx(sk, control);
-
-	if (control->final) {
-		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		if (busy)
+			l2cap_ertm_enter_local_busy(chan);
 		else
-			l2cap_ertm_retransmit_all(sk, control);
-	} else {
-		l2cap_ertm_retransmit_all(sk, control);
-		l2cap_ertm_send(sk);
-		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F)
-			pi->conn_state |= L2CAP_CONN_REJ_ACT;
+			l2cap_ertm_exit_local_busy(chan);
 	}
 }
 
-static u8 l2cap_ertm_classify_txseq(struct sock *sk, u16 txseq)
+static void l2cap_check_srej_gap(struct l2cap_chan *chan, u16 tx_seq)
 {
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
-	pi = l2cap_pi(sk);
+	struct sk_buff *skb;
+	u32 control;
 
-	BT_DBG("last_acked_seq %d, expected_tx_seq %d", (int)pi->last_acked_seq,
-		(int)pi->expected_tx_seq);
+	while ((skb = skb_peek(&chan->srej_q)) &&
+			!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		int err;
 
-	if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-			/* See notes below regarding "double poll" and
-			 * invalid packets.
-			 */
-			if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
-				BT_DBG("Invalid/Ignore - txseq outside "
-					"tx window after SREJ sent");
-				return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
-			} else {
-				BT_DBG("Invalid - bad txseq within tx "
-					"window after SREJ sent");
-				return L2CAP_ERTM_TXSEQ_INVALID;
-			}
-		}
+		if (bt_cb(skb)->tx_seq != tx_seq)
+			break;
 
-		if (pi->srej_list.head == txseq) {
-			BT_DBG("Expected SREJ");
-			return L2CAP_ERTM_TXSEQ_EXPECTED_SREJ;
-		}
+		skb = skb_dequeue(&chan->srej_q);
+		control = __set_ctrl_sar(chan, bt_cb(skb)->sar);
+		err = l2cap_reassemble_sdu(chan, skb, control);
 
-		if (l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), txseq)) {
-			BT_DBG("Duplicate SREJ - txseq already stored");
-			return L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ;
+		if (err < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			break;
 		}
 
-		if (l2cap_seq_list_contains(&pi->srej_list, txseq)) {
-			BT_DBG("Unexpected SREJ - txseq not requested "
-				"with SREJ");
-			return L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ;
-		}
+		chan->buffer_seq_srej = __next_seq(chan, chan->buffer_seq_srej);
+		tx_seq = __next_seq(chan, tx_seq);
 	}
+}
 
-	if (pi->expected_tx_seq == txseq) {
-		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-			BT_DBG("Invalid - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID;
-		} else {
-			BT_DBG("Expected");
-			return L2CAP_ERTM_TXSEQ_EXPECTED;
-		}
-	}
+static void l2cap_resend_srejframe(struct l2cap_chan *chan, u16 tx_seq)
+{
+	struct srej_list *l, *tmp;
+	u32 control;
 
-	if (__delta_seq(txseq, pi->last_acked_seq, pi) <
-		__delta_seq(pi->expected_tx_seq, pi->last_acked_seq, pi)) {
-		BT_DBG("Duplicate - expected_tx_seq later than txseq");
-		return L2CAP_ERTM_TXSEQ_DUPLICATE;
-	}
-
-	if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-		/* A source of invalid packets is a "double poll" condition,
-		 * where delays cause us to send multiple poll packets.  If
-		 * the remote stack receives and processes both polls,
-		 * sequence numbers can wrap around in such a way that a
-		 * resent frame has a sequence number that looks like new data
-		 * with a sequence gap.  This would trigger an erroneous SREJ
-		 * request.
-		 *
-		 * Fortunately, this is impossible with a tx window that's
-		 * less than half of the maximum sequence number, which allows
-		 * invalid frames to be safely ignored.
-		 *
-		 * With tx window sizes greater than half of the tx window
-		 * maximum, the frame is invalid and cannot be ignored.  This
-		 * causes a disconnect.
-		 */
-
-		if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
-			BT_DBG("Invalid/Ignore - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
-		} else {
-			BT_DBG("Invalid - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID;
+	list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
+		if (l->tx_seq == tx_seq) {
+			list_del(&l->list);
+			kfree(l);
+			return;
 		}
-	} else {
-		BT_DBG("Unexpected - txseq indicates missing frames");
-		return L2CAP_ERTM_TXSEQ_UNEXPECTED;
+		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+		control |= __set_reqseq(chan, l->tx_seq);
+		l2cap_send_sframe(chan, control);
+		list_del(&l->list);
+		list_add_tail(&l->list, &chan->srej_l);
 	}
 }
 
-static int l2cap_ertm_rx_state_recv(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff *skb, u8 event)
+static int l2cap_send_srejframe(struct l2cap_chan *chan, u16 tx_seq)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
-	bool skb_in_use = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		switch (l2cap_ertm_classify_txseq(sk, control->txseq)) {
-		case L2CAP_ERTM_TXSEQ_EXPECTED:
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding expected seq %d",
-					control->txseq);
-				break;
-			}
+	struct srej_list *new;
+	u32 control;
 
-			pi->expected_tx_seq = __next_seq(control->txseq, pi);
-			pi->buffer_seq = pi->expected_tx_seq;
-			skb_in_use = 1;
+	while (tx_seq != chan->expected_tx_seq) {
+		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+		control |= __set_reqseq(chan, chan->expected_tx_seq);
+		l2cap_send_sframe(chan, control);
 
-			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
-			if (err)
-				break;
-
-			if (control->final) {
-				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-				else {
-					control->final = 0;
-					l2cap_ertm_retransmit_all(sk, control);
-					l2cap_ertm_send(sk);
-				}
-			}
-
-			if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY))
-				l2cap_ertm_send_ack(sk);
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			/* Can't issue SREJ frames in the local busy state.
-			 * Drop this frame, it will be seen as missing
-			 * when local busy is exited.
-			 */
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding unexpected seq %d",
-					control->txseq);
-				break;
-			}
+		new = kzalloc(sizeof(struct srej_list), GFP_ATOMIC);
+		if (!new)
+			return -ENOMEM;
 
-			/* There was a gap in the sequence, so an SREJ
-			 * must be sent for each missing frame.  The
-			 * current frame is stored for later use.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
-			l2cap_seq_list_clear(&pi->srej_list);
-			l2cap_ertm_send_srej(sk, control->txseq);
+		new->tx_seq = chan->expected_tx_seq;
 
-			pi->rx_state = L2CAP_ERTM_RX_STATE_SREJ_SENT;
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE:
-			l2cap_ertm_pass_to_tx(sk, control);
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID:
-		default:
-			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
-					ECONNRESET);
-			break;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->final) {
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-			else if (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
-				pi->amp_move_state ==
-						L2CAP_AMP_STATE_WAIT_PREPARE) {
-				control->final = 0;
-				l2cap_ertm_retransmit_all(sk, control);
-			}
+		chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-			l2cap_ertm_send(sk);
-		} else if (control->poll) {
-			l2cap_ertm_send_i_or_rr_or_rnr(sk);
-		} else {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames)
-				l2cap_ertm_start_retrans_timer(pi);
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			l2cap_ertm_send(sk);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control && control->poll) {
-			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-			l2cap_ertm_send_rr_or_rnr(sk, 0);
-		}
-		l2cap_ertm_stop_retrans_timer(pi);
-		l2cap_seq_list_clear(&pi->retrans_list);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_handle_rej(sk, control);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		l2cap_ertm_handle_srej(sk, control);
-		break;
-	default:
-		break;
+		list_add_tail(&new->list, &chan->srej_l);
 	}
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
-	}
+	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-	return err;
+	return 0;
 }
 
-static int l2cap_ertm_rx_state_srej_sent(struct sock *sk,
-					struct bt_l2cap_control *control,
-					struct sk_buff *skb, u8 event)
+static inline int l2cap_data_channel_iframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
+	u16 tx_seq = __get_txseq(chan, rx_control);
+	u16 req_seq = __get_reqseq(chan, rx_control);
+	u8 sar = __get_ctrl_sar(chan, rx_control);
+	int tx_seq_offset, expected_tx_seq_offset;
+	int num_to_ack = (chan->tx_win/6) + 1;
 	int err = 0;
-	u16 txseq = control->txseq;
-	bool skb_in_use = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		switch (l2cap_ertm_classify_txseq(sk, txseq)) {
-		case L2CAP_ERTM_TXSEQ_EXPECTED:
-			/* Keep frame for reassembly later */
-			l2cap_ertm_pass_to_tx(sk, control);
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			pi->expected_tx_seq = __next_seq(txseq, pi);
-			break;
-		case L2CAP_ERTM_TXSEQ_EXPECTED_SREJ:
-			l2cap_seq_list_pop(&pi->srej_list);
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
 
-			err = l2cap_ertm_rx_queued_iframes(sk);
-			if (err)
-				break;
+	BT_DBG("chan %p len %d tx_seq %d rx_control 0x%8.8x", chan, skb->len,
+							tx_seq, rx_control);
 
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
-			/* Got a frame that can't be reassembled yet.
-			 * Save it for later, and send SREJs to cover
-			 * the missing frames.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			l2cap_ertm_send_srej(sk, control->txseq);
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ:
-			/* This frame was requested with an SREJ, but
-			 * some expected retransmitted frames are
-			 * missing.  Request retransmission of missing
-			 * SREJ'd frames.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			l2cap_ertm_send_srej_list(sk, control->txseq);
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ:
-			/* We've already queued this frame.  Drop this copy. */
-			l2cap_ertm_pass_to_tx(sk, control);
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE:
-			/* Expecting a later sequence number, so this frame
-			 * was already received.  Ignore it completely.
-			 */
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID:
-		default:
-			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
-					ECONNRESET);
-			break;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->final) {
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	if (__is_ctrl_final(chan, rx_control) &&
+			test_bit(CONN_WAIT_F, &chan->conn_state)) {
+		__clear_monitor_timer(chan);
+		if (chan->unacked_frames > 0)
+			__set_retrans_timer(chan);
+		clear_bit(CONN_WAIT_F, &chan->conn_state);
+	}
 
-			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-			else {
-				control->final = 0;
-				l2cap_ertm_retransmit_all(sk, control);
-			}
+	chan->expected_ack_seq = req_seq;
+	l2cap_drop_acked_frames(chan);
 
-			l2cap_ertm_send(sk);
-		} else if (control->poll) {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames) {
-				l2cap_ertm_start_retrans_timer(pi);
-			}
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-			l2cap_ertm_send_srej_tail(sk);
-		} else {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames) {
-				l2cap_ertm_start_retrans_timer(pi);
-			}
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			l2cap_ertm_send_ack(sk);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->poll)
-			l2cap_ertm_send_srej_tail(sk);
-		else {
-			struct bt_l2cap_control rr_control;
-			memset(&rr_control, 0, sizeof(rr_control));
-			rr_control.frame_type = 's';
-			rr_control.super = L2CAP_SFRAME_RR;
-			rr_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &rr_control);
-		}
+	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
 
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_handle_rej(sk, control);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		l2cap_ertm_handle_srej(sk, control);
-		break;
+	/* invalid tx_seq */
+	if (tx_seq_offset >= chan->tx_win) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
 	}
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
+			l2cap_send_ack(chan);
+		goto drop;
 	}
 
-	return err;
-}
+	if (tx_seq == chan->expected_tx_seq)
+		goto expected;
 
-static int l2cap_ertm_rx_state_amp_move(struct sock *sk,
-					struct bt_l2cap_control *control,
-					struct sk_buff *skb, u8 event)
-{
-	struct l2cap_pinfo *pi;
-	int err = 0;
-	bool skb_in_use = 0;
+	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		struct srej_list *first;
 
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	/* Only handle expected frames, to avoid state changes. */
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
-				L2CAP_ERTM_TXSEQ_EXPECTED) {
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding expected seq %d",
-					control->txseq);
-				break;
+		first = list_first_entry(&chan->srej_l,
+				struct srej_list, list);
+		if (tx_seq == first->tx_seq) {
+			l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
+			l2cap_check_srej_gap(chan, tx_seq);
+
+			list_del(&first->list);
+			kfree(first);
+
+			if (list_empty(&chan->srej_l)) {
+				chan->buffer_seq = chan->buffer_seq_srej;
+				clear_bit(CONN_SREJ_SENT, &chan->conn_state);
+				l2cap_send_ack(chan);
+				BT_DBG("chan %p, Exit SREJ_SENT", chan);
 			}
+		} else {
+			struct srej_list *l;
 
-			pi->expected_tx_seq = __next_seq(control->txseq, pi);
-			pi->buffer_seq = pi->expected_tx_seq;
-			skb_in_use = 1;
+			/* duplicated tx_seq */
+			if (l2cap_add_to_srej_queue(chan, skb, tx_seq, sar) < 0)
+				goto drop;
 
-			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
-			if (err)
-				break;
+			list_for_each_entry(l, &chan->srej_l, list) {
+				if (l->tx_seq == tx_seq) {
+					l2cap_resend_srejframe(chan, tx_seq);
+					return 0;
+				}
+			}
 
-			if (control->final) {
-				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-				else
-					control->final = 0;
+			err = l2cap_send_srejframe(chan, tx_seq);
+			if (err < 0) {
+				l2cap_send_disconn_req(chan->conn, chan, -err);
+				return err;
 			}
 		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		/* Ignore */
-		break;
-	default:
-		break;
-	}
+	} else {
+		expected_tx_seq_offset = __seq_offset(chan,
+				chan->expected_tx_seq, chan->buffer_seq);
+
+		/* duplicated tx_seq */
+		if (tx_seq_offset < expected_tx_seq_offset)
+			goto drop;
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
-	}
+		set_bit(CONN_SREJ_SENT, &chan->conn_state);
 
-	return err;
-}
+		BT_DBG("chan %p, Enter SREJ", chan);
 
-static int l2cap_answer_move_poll(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
-	int err = 0;
+		INIT_LIST_HEAD(&chan->srej_l);
+		chan->buffer_seq_srej = chan->buffer_seq;
 
-	BT_DBG("sk %p", sk);
+		__skb_queue_head_init(&chan->srej_q);
+		l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
 
-	pi = l2cap_pi(sk);
+		/* Set P-bit only if there are some I-frames to ack. */
+		if (__clear_ack_timer(chan))
+			set_bit(CONN_SEND_PBIT, &chan->conn_state);
 
-	l2cap_ertm_process_reqseq(sk, pi->amp_move_reqseq);
+		err = l2cap_send_srejframe(chan, tx_seq);
+		if (err < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, -err);
+			return err;
+		}
+	}
+	return 0;
 
-	if (!skb_queue_empty(TX_QUEUE(sk)))
-		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
-	else
-		sk->sk_send_head = NULL;
+expected:
+	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-	/* Rewind next_tx_seq to the point expected
-	 * by the receiver.
-	 */
-	pi->next_tx_seq = pi->amp_move_reqseq;
-	pi->unacked_frames = 0;
+	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		bt_cb(skb)->tx_seq = tx_seq;
+		bt_cb(skb)->sar = sar;
+		__skb_queue_tail(&chan->srej_q, skb);
+		return 0;
+	}
 
-	err = l2cap_finish_amp_move(sk);
+	err = l2cap_reassemble_sdu(chan, skb, rx_control);
+	chan->buffer_seq = __next_seq(chan, chan->buffer_seq);
 
-	if (err)
+	if (err < 0) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
 		return err;
+	}
 
-	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-	l2cap_ertm_send_i_or_rr_or_rnr(sk);
+	if (__is_ctrl_final(chan, rx_control)) {
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+	}
 
-	memset(&control, 0, sizeof(control));
-	control.reqseq = pi->amp_move_reqseq;
 
-	if (pi->amp_move_event == L2CAP_ERTM_EVENT_RECV_IFRAME)
-		err = -EPROTO;
+	chan->num_acked = (chan->num_acked + 1) % num_to_ack;
+	if (chan->num_acked == num_to_ack - 1)
+		l2cap_send_ack(chan);
 	else
-		err = l2cap_ertm_rx_state_recv(sk, &control, NULL,
-					pi->amp_move_event);
+		__set_ack_timer(chan);
 
-	return err;
+	return 0;
+
+drop:
+	kfree_skb(skb);
+	return 0;
 }
 
-static void l2cap_amp_move_setup(struct sock *sk)
+static inline void l2cap_data_channel_rrframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan,
+				__get_reqseq(chan, rx_control), rx_control);
 
-	BT_DBG("sk %p", sk);
+	chan->expected_ack_seq = __get_reqseq(chan, rx_control);
+	l2cap_drop_acked_frames(chan);
 
-	pi = l2cap_pi(sk);
+	if (__is_ctrl_poll(chan, rx_control)) {
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+		if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+			if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+					(chan->unacked_frames > 0))
+				__set_retrans_timer(chan);
 
-	l2cap_ertm_stop_ack_timer(pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	l2cap_ertm_stop_monitor_timer(pi);
-
-	pi->retry_count = 0;
-	skb_queue_walk(TX_QUEUE(sk), skb) {
-		if (bt_cb(skb)->retries)
-			bt_cb(skb)->retries = 1;
+			clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+			l2cap_send_srejtail(chan);
+		} else {
+			l2cap_send_i_or_rr_or_rnr(chan);
+		}
+
+	} else if (__is_ctrl_final(chan, rx_control)) {
+		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+
+	} else {
+		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+				(chan->unacked_frames > 0))
+			__set_retrans_timer(chan);
+
+		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+		if (test_bit(CONN_SREJ_SENT, &chan->conn_state))
+			l2cap_send_ack(chan);
 		else
-			break;
+			l2cap_ertm_send(chan);
 	}
+}
 
-	pi->expected_tx_seq = pi->buffer_seq;
+static inline void l2cap_data_channel_rejframe(struct l2cap_chan *chan, u32 rx_control)
+{
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	pi->conn_state &= ~(L2CAP_CONN_REJ_ACT | L2CAP_CONN_SREJ_ACT);
-	l2cap_seq_list_clear(&pi->retrans_list);
-	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
-	skb_queue_purge(SREJ_QUEUE(sk));
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-	pi->rx_state = L2CAP_ERTM_RX_STATE_AMP_MOVE;
+	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
 
-	BT_DBG("tx_state 0x2.2%x rx_state  0x2.2%x", pi->tx_state,
-		pi->rx_state);
+	chan->expected_ack_seq = tx_seq;
+	l2cap_drop_acked_frames(chan);
 
-	pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-}
+	if (__is_ctrl_final(chan, rx_control)) {
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+	} else {
+		l2cap_retransmit_frames(chan);
 
-static void l2cap_amp_move_revert(struct sock *sk)
+		if (test_bit(CONN_WAIT_F, &chan->conn_state))
+			set_bit(CONN_REJ_ACT, &chan->conn_state);
+	}
+}
+static inline void l2cap_data_channel_srejframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p", sk);
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	pi = l2cap_pi(sk);
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		l2cap_ertm_tx(sk, NULL, NULL, L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER)
-		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_P_FLAG;
-}
+	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
 
-static int l2cap_amp_move_reconf(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	u8 buf[64];
-	int err = 0;
+	if (__is_ctrl_poll(chan, rx_control)) {
+		chan->expected_ack_seq = tx_seq;
+		l2cap_drop_acked_frames(chan);
 
-	BT_DBG("sk %p", sk);
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+		l2cap_retransmit_one_frame(chan, tx_seq);
 
-	pi = l2cap_pi(sk);
+		l2cap_ertm_send(chan);
 
-	l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn), L2CAP_CONF_REQ,
-				l2cap_build_amp_reconf_req(sk, buf), buf);
-	return err;
+		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			chan->srej_save_reqseq = tx_seq;
+			set_bit(CONN_SREJ_ACT, &chan->conn_state);
+		}
+	} else if (__is_ctrl_final(chan, rx_control)) {
+		if (test_bit(CONN_SREJ_ACT, &chan->conn_state) &&
+				chan->srej_save_reqseq == tx_seq)
+			clear_bit(CONN_SREJ_ACT, &chan->conn_state);
+		else
+			l2cap_retransmit_one_frame(chan, tx_seq);
+	} else {
+		l2cap_retransmit_one_frame(chan, tx_seq);
+		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			chan->srej_save_reqseq = tx_seq;
+			set_bit(CONN_SREJ_ACT, &chan->conn_state);
+		}
+	}
 }
 
-static void l2cap_amp_move_success(struct sock *sk)
+static inline void l2cap_data_channel_rnrframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	BT_DBG("sk %p", sk);
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	pi = l2cap_pi(sk);
+	set_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+	chan->expected_ack_seq = tx_seq;
+	l2cap_drop_acked_frames(chan);
 
-	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		int err = 0;
-		/* Send reconfigure request */
-		if (pi->mode == L2CAP_MODE_ERTM) {
-			pi->reconf_state = L2CAP_RECONF_INT;
-			if (enable_reconfig)
-				err = l2cap_amp_move_reconf(sk);
-
-			if (err || !enable_reconfig) {
-				pi->reconf_state = L2CAP_RECONF_NONE;
-				l2cap_ertm_tx(sk, NULL, NULL,
-						L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-				pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-			}
-		} else
-			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-		if (pi->mode == L2CAP_MODE_ERTM)
-			pi->rx_state =
-				L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE;
-		else
-			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+	if (__is_ctrl_poll(chan, rx_control))
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+
+	if (!test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		__clear_retrans_timer(chan);
+		if (__is_ctrl_poll(chan, rx_control))
+			l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_FINAL);
+		return;
 	}
-}
 
-static inline bool __valid_reqseq(struct l2cap_pinfo *pi, u16 reqseq)
-{
-	/* Make sure reqseq is for a packet that has been sent but not acked */
-	u16 unacked = __delta_seq(pi->next_tx_seq, pi->expected_ack_seq, pi);
-	return __delta_seq(pi->next_tx_seq, reqseq, pi) <= unacked;
+	if (__is_ctrl_poll(chan, rx_control)) {
+		l2cap_send_srejtail(chan);
+	} else {
+		rx_control = __set_ctrl_super(chan, L2CAP_SUPER_RR);
+		l2cap_send_sframe(chan, rx_control);
+	}
 }
 
-static int l2cap_strm_rx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff *skb)
+static inline int l2cap_data_channel_sframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, state %d",
-		sk, control, skb, l2cap_pi(sk)->rx_state);
+	BT_DBG("chan %p rx_control 0x%8.8x len %d", chan, rx_control, skb->len);
 
-	pi = l2cap_pi(sk);
-
-	if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
-		L2CAP_ERTM_TXSEQ_EXPECTED) {
-		l2cap_ertm_pass_to_tx(sk, control);
+	if (__is_ctrl_final(chan, rx_control) &&
+			test_bit(CONN_WAIT_F, &chan->conn_state)) {
+		__clear_monitor_timer(chan);
+		if (chan->unacked_frames > 0)
+			__set_retrans_timer(chan);
+		clear_bit(CONN_WAIT_F, &chan->conn_state);
+	}
 
-		BT_DBG("buffer_seq %d->%d", pi->buffer_seq,
-			   __next_seq(pi->buffer_seq, pi));
+	switch (__get_ctrl_super(chan, rx_control)) {
+	case L2CAP_SUPER_RR:
+		l2cap_data_channel_rrframe(chan, rx_control);
+		break;
 
-		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
+	case L2CAP_SUPER_REJ:
+		l2cap_data_channel_rejframe(chan, rx_control);
+		break;
 
-		l2cap_ertm_rx_expected_iframe(sk, control, skb);
-	} else {
-		if (pi->sdu) {
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-		}
-		pi->sdu_last_frag = NULL;
-		pi->sdu_len = 0;
+	case L2CAP_SUPER_SREJ:
+		l2cap_data_channel_srejframe(chan, rx_control);
+		break;
 
-		if (skb) {
-			BT_DBG("Freeing %p", skb);
-			kfree_skb(skb);
-		}
+	case L2CAP_SUPER_RNR:
+		l2cap_data_channel_rnrframe(chan, rx_control);
+		break;
 	}
 
-	pi->last_acked_seq = control->txseq;
-	pi->expected_tx_seq = __next_seq(control->txseq, pi);
-
-	return err;
+	kfree_skb(skb);
+	return 0;
 }
 
-static int l2cap_ertm_rx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff *skb, u8 event)
+static int l2cap_ertm_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	u32 control;
+	u16 req_seq;
+	int len, next_tx_seq_offset, req_seq_offset;
+
+	control = __get_control(chan, skb->data);
+	skb_pull(skb, __ctrl_size(chan));
+	len = skb->len;
+
+	/*
+	 * We can just drop the corrupted I-frame here.
+	 * Receiver will miss it and start proper recovery
+	 * procedures and ask retransmission.
+	 */
+	if (l2cap_check_fcs(chan, skb))
+		goto drop;
 
-	BT_DBG("sk %p, control %p, skb %p, event %d, state %d",
-		sk, control, skb, (int)event, l2cap_pi(sk)->rx_state);
+	if (__is_sar_start(chan, control) && !__is_sframe(chan, control))
+		len -= L2CAP_SDULEN_SIZE;
 
-	pi = l2cap_pi(sk);
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		len -= L2CAP_FCS_SIZE;
 
-	if (__valid_reqseq(pi, control->reqseq)) {
-		switch (pi->rx_state) {
-		case L2CAP_ERTM_RX_STATE_RECV:
-			err = l2cap_ertm_rx_state_recv(sk, control, skb, event);
-			break;
-		case L2CAP_ERTM_RX_STATE_SREJ_SENT:
-			err = l2cap_ertm_rx_state_srej_sent(sk, control, skb,
-							event);
-			break;
-		case L2CAP_ERTM_RX_STATE_AMP_MOVE:
-			err = l2cap_ertm_rx_state_amp_move(sk, control, skb,
-							event);
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_F_FLAG:
-			if (control->final) {
-				pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-
-				pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-				l2cap_ertm_process_reqseq(sk, control->reqseq);
-
-				if (!skb_queue_empty(TX_QUEUE(sk)))
-					sk->sk_send_head =
-						skb_peek(TX_QUEUE(sk));
-				else
-					sk->sk_send_head = NULL;
-
-				/* Rewind next_tx_seq to the point expected
-				 * by the receiver.
-				 */
-				pi->next_tx_seq = control->reqseq;
-				pi->unacked_frames = 0;
-
-				if (pi->ampcon)
-					pi->conn->mtu =
-						pi->ampcon->hdev->acl_mtu;
-				else
-					pi->conn->mtu =
-						pi->conn->hcon->hdev->acl_mtu;
+	if (len > chan->mps) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
+	}
 
-				err = l2cap_setup_resegment(sk);
+	req_seq = __get_reqseq(chan, control);
 
-				if (err)
-					break;
+	req_seq_offset = __seq_offset(chan, req_seq, chan->expected_ack_seq);
 
-				err = l2cap_ertm_rx_state_recv(sk, control, skb,
-							event);
-			}
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG:
-			if (control->poll) {
-				pi->amp_move_reqseq = control->reqseq;
-				pi->amp_move_event = event;
-				err = l2cap_answer_move_poll(sk);
-			}
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE:
-			if (control->poll) {
-				pi->amp_move_reqseq = control->reqseq;
-				pi->amp_move_event = event;
-
-				BT_DBG("amp_move_role 0x%2.2x, "
-					"reconf_state 0x%2.2x",
-					pi->amp_move_role, pi->reconf_state);
-
-				if (pi->reconf_state == L2CAP_RECONF_ACC)
-					err = l2cap_amp_move_reconf(sk);
-				else
-					err = l2cap_answer_move_poll(sk);
-			}
-			break;
-		default:
-			/* shut it down */
-			break;
-		}
-	} else {
-		BT_DBG("Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d",
-			control->reqseq, pi->next_tx_seq, pi->expected_ack_seq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-	}
+	next_tx_seq_offset = __seq_offset(chan, chan->next_tx_seq,
+						chan->expected_ack_seq);
 
-	return err;
-}
+	/* check for invalid req-seq */
+	if (req_seq_offset > next_tx_seq_offset) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
+	}
 
-void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt)
-{
-	lock_sock(sk);
+	if (!__is_sframe(chan, control)) {
+		if (len < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			goto drop;
+		}
 
-	l2cap_pi(sk)->fixed_channel = 1;
+		l2cap_data_channel_iframe(chan, control, skb);
+	} else {
+		if (len != 0) {
+			BT_ERR("%d", len);
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			goto drop;
+		}
 
-	l2cap_pi(sk)->imtu = opt->imtu;
-	l2cap_pi(sk)->omtu = opt->omtu;
-	l2cap_pi(sk)->remote_mps = opt->omtu;
-	l2cap_pi(sk)->mps = opt->omtu;
-	l2cap_pi(sk)->flush_to = opt->flush_to;
-	l2cap_pi(sk)->mode = opt->mode;
-	l2cap_pi(sk)->fcs = opt->fcs;
-	l2cap_pi(sk)->max_tx = opt->max_tx;
-	l2cap_pi(sk)->remote_max_tx = opt->max_tx;
-	l2cap_pi(sk)->tx_win = opt->txwin_size;
-	l2cap_pi(sk)->remote_tx_win = opt->txwin_size;
-	l2cap_pi(sk)->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
-	l2cap_pi(sk)->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;
-
-	if (opt->mode == L2CAP_MODE_ERTM ||
-		l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-		l2cap_ertm_init(sk);
+		l2cap_data_channel_sframe(chan, control, skb);
+	}
 
-	release_sock(sk);
+	return 0;
 
-	return;
+drop:
+	kfree_skb(skb);
+	return 0;
 }
 
-static const u8 l2cap_ertm_rx_func_to_event[4] = {
-	L2CAP_ERTM_EVENT_RECV_RR, L2CAP_ERTM_EVENT_RECV_REJ,
-	L2CAP_ERTM_EVENT_RECV_RNR, L2CAP_ERTM_EVENT_RECV_SREJ
-};
-
-int l2cap_data_channel(struct sock *sk, struct sk_buff *skb)
+static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control *control;
-	u16 len;
-	u8 event;
-	pi = l2cap_pi(sk);
+	struct l2cap_chan *chan;
+	u32 control;
+	u16 tx_seq;
+	int len;
+
+	chan = l2cap_get_chan_by_scid(conn, cid);
+	if (!chan) {
+		BT_DBG("unknown cid 0x%4.4x", cid);
+		/* Drop packet and return */
+		kfree_skb(skb);
+		return 0;
+	}
+
+	l2cap_chan_lock(chan);
 
-	BT_DBG("sk %p, len %d, mode %d", sk, skb->len, pi->mode);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	if (sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_CONNECTED)
 		goto drop;
 
-	switch (pi->mode) {
+	switch (chan->mode) {
 	case L2CAP_MODE_BASIC:
 		/* If socket recv buffers overflows we drop data here
 		 * which is *bad* because L2CAP has to be reliable.
 		 * But we don't have any other choice. L2CAP doesn't
 		 * provide flow control mechanism. */
 
-		if (pi->imtu < skb->len)
+		if (chan->imtu < skb->len)
 			goto drop;
 
-		if (!sock_queue_rcv_skb(sk, skb))
+		if (!chan->ops->recv(chan->data, skb))
 			goto done;
 		break;
 
 	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		control = &bt_cb(skb)->control;
-		if (pi->extended_control) {
-			__get_extended_control(get_unaligned_le32(skb->data),
-						control);
-			skb_pull(skb, 4);
-		} else {
-			__get_enhanced_control(get_unaligned_le16(skb->data),
-						control);
-			skb_pull(skb, 2);
-		}
+		l2cap_ertm_data_rcv(chan, skb);
+
+		goto done;
 
+	case L2CAP_MODE_STREAMING:
+		control = __get_control(chan, skb->data);
+		skb_pull(skb, __ctrl_size(chan));
 		len = skb->len;
 
-		if (l2cap_check_fcs(pi, skb))
+		if (l2cap_check_fcs(chan, skb))
 			goto drop;
 
-		if ((control->frame_type == 'i') &&
-			(control->sar == L2CAP_SAR_START))
-			len -= 2;
-
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			len -= 2;
-
-		/*
-		 * We can just drop the corrupted I-frame here.
-		 * Receiver will miss it and start proper recovery
-		 * procedures and ask for retransmission.
-		 */
-		if (len > pi->mps) {
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			goto drop;
-		}
+		if (__is_sar_start(chan, control))
+			len -= L2CAP_SDULEN_SIZE;
 
-		if (control->frame_type == 'i') {
+		if (chan->fcs == L2CAP_FCS_CRC16)
+			len -= L2CAP_FCS_SIZE;
 
-			int err;
+		if (len > chan->mps || len < 0 || __is_sframe(chan, control))
+			goto drop;
 
-			BT_DBG("iframe sar %d, reqseq %d, final %d, txseq %d",
-				control->sar, control->reqseq, control->final,
-				control->txseq);
-
-			/* Validate F-bit - F=0 always valid, F=1 only
-			 * valid in TX WAIT_F
-			 */
-			if (control->final && (pi->tx_state !=
-					L2CAP_ERTM_TX_STATE_WAIT_F))
-				goto drop;
+		tx_seq = __get_txseq(chan, control);
 
-			if (pi->mode != L2CAP_MODE_STREAMING) {
-				event = L2CAP_ERTM_EVENT_RECV_IFRAME;
-				err = l2cap_ertm_rx(sk, control, skb, event);
-			} else
-				err = l2cap_strm_rx(sk, control, skb);
-			if (err)
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-		} else {
-			/* Only I-frames are expected in streaming mode */
-			if (pi->mode == L2CAP_MODE_STREAMING)
-				goto drop;
+		if (chan->expected_tx_seq != tx_seq) {
+			/* Frame(s) missing - must discard partial SDU */
+			kfree_skb(chan->sdu);
+			chan->sdu = NULL;
+			chan->sdu_last_frag = NULL;
+			chan->sdu_len = 0;
 
-			BT_DBG("sframe reqseq %d, final %d, poll %d, super %d",
-				control->reqseq, control->final, control->poll,
-				control->super);
-
-			if (len != 0) {
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-				goto drop;
-			}
+			/* TODO: Notify userland of missing data */
+		}
 
-			/* Validate F and P bits */
-			if (control->final &&
-				((pi->tx_state != L2CAP_ERTM_TX_STATE_WAIT_F)
-					|| control->poll))
-				goto drop;
+		chan->expected_tx_seq = __next_seq(chan, tx_seq);
 
-			event = l2cap_ertm_rx_func_to_event[control->super];
-			if (l2cap_ertm_rx(sk, control, skb, event))
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-		}
+		if (l2cap_reassemble_sdu(chan, skb, control) == -EMSGSIZE)
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
 
 		goto done;
 
 	default:
-		BT_DBG("sk %p: bad mode 0x%2.2x", sk, pi->mode);
+		BT_DBG("chan %p: bad mode 0x%2.2x", chan, chan->mode);
 		break;
 	}
 
@@ -7239,158 +4373,64 @@
 	kfree_skb(skb);
 
 done:
-	return 0;
-}
+	l2cap_chan_unlock(chan);
 
-void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb)
-{
-	lock_sock(sk);
-	l2cap_data_channel(sk, skb);
-	release_sock(sk);
+	return 0;
 }
 
 static inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)
 {
-	struct sock *sk;
+	struct l2cap_chan *chan;
 
-	sk = l2cap_get_sock_by_psm(0, psm, conn->src);
-	if (!sk)
+	chan = l2cap_global_chan_by_psm(0, psm, conn->src);
+	if (!chan)
 		goto drop;
 
-	bh_lock_sock(sk);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	BT_DBG("sk %p, len %d", sk, skb->len);
-
-	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
 		goto drop;
 
-	if (l2cap_pi(sk)->imtu < skb->len)
+	if (chan->imtu < skb->len)
 		goto drop;
 
-	if (!sock_queue_rcv_skb(sk, skb))
-		goto done;
+	if (!chan->ops->recv(chan->data, skb))
+		return 0;
 
 drop:
 	kfree_skb(skb);
 
-done:
-	if (sk)
-		bh_unlock_sock(sk);
 	return 0;
 }
 
-static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid,
-							struct sk_buff *skb)
+static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid, struct sk_buff *skb)
 {
-	struct sock *sk = NULL;
-	struct sk_buff *skb_rsp;
-	struct l2cap_hdr *lh;
-	int dir;
-	struct work_struct *open_worker;
-	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
-						L2CAP_ATT_NOT_SUPPORTED};
-
-	if (skb->data[0] == L2CAP_ATT_MTU_REQ) {
-		u8 mtu_rsp[] = {L2CAP_ATT_MTU_RSP, 23, 0};
-
-		skb_rsp = bt_skb_alloc(sizeof(mtu_rsp) + L2CAP_HDR_SIZE,
-								GFP_ATOMIC);
-		if (!skb_rsp)
-			goto drop;
-
-		lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-		lh->len = cpu_to_le16(sizeof(mtu_rsp));
-		lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-		memcpy(skb_put(skb_rsp, sizeof(mtu_rsp)), mtu_rsp,
-							sizeof(mtu_rsp));
-		hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-
-		goto free_skb;
-	}
+	struct l2cap_chan *chan;
 
-	dir = (skb->data[0] & L2CAP_ATT_RESPONSE_BIT) ? 0 : 1;
-
-	sk = l2cap_find_sock_by_fixed_cid_and_dir(cid, conn->src,
-							conn->dst, dir);
-
-	BT_DBG("sk %p, dir:%d", sk, dir);
-
-	if (!sk)
+	chan = l2cap_global_chan_by_scid(0, cid, conn->src);
+	if (!chan)
 		goto drop;
 
-	bh_lock_sock(sk);
-
-	BT_DBG("sk %p, len %d", sk, skb->len);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED) {
-		att_chn_params.cid = cid;
-		att_chn_params.conn = conn;
-		att_chn_params.dir = dir;
-		att_chn_params.skb = skb;
-		open_worker = kzalloc(sizeof(*open_worker), GFP_ATOMIC);
-		if (!open_worker)
-			BT_ERR("Out of memory");
-		INIT_WORK(open_worker, l2cap_queue_acl_data);
-		schedule_work(open_worker);
-		goto done;
-	}
+	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
+		goto drop;
 
-	if (l2cap_pi(sk)->imtu < skb->len)
+	if (chan->imtu < skb->len)
 		goto drop;
 
-	if (!sock_queue_rcv_skb(sk, skb))
-		goto done;
+	if (!chan->ops->recv(chan->data, skb))
+		return 0;
 
 drop:
-	if (skb->data[0] != L2CAP_ATT_INDICATE)
-		goto not_indicate;
-
-	/* If this is an incoming Indication, we are required to confirm */
-
-	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(u8));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[0] = L2CAP_ATT_CONFIRM;
-	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
-	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-	goto free_skb;
-
-not_indicate:
-	if (skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
-			skb->data[0] == L2CAP_ATT_CONFIRM)
-		goto free_skb;
-
-	/* If this is an incoming PDU that requires a response, respond with
-	 * a generic error so remote device doesn't hang */
-
-	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(err_rsp));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[1] = skb->data[0];
-	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
-	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-
-free_skb:
 	kfree_skb(skb);
 
-done:
-	if (sk)
-		bh_unlock_sock(sk);
 	return 0;
 }
 
 static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 {
 	struct l2cap_hdr *lh = (void *) skb->data;
-	struct sock *sk;
 	u16 cid, len;
 	__le16 psm;
 
@@ -7423,246 +4463,204 @@
 
 	case L2CAP_CID_SMP:
 		if (smp_sig_channel(conn, skb))
-			l2cap_conn_del(conn->hcon, EACCES, 0);
+			l2cap_conn_del(conn->hcon, EACCES);
 		break;
 
 	default:
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);
-		if (sk) {
-			if (sock_owned_by_user(sk)) {
-				BT_DBG("backlog sk %p", sk);
-				if (sk_add_backlog(sk, skb))
-					kfree_skb(skb);
-			} else
-				l2cap_data_channel(sk, skb);
-
-			bh_unlock_sock(sk);
-		} else if ((cid == L2CAP_CID_A2MP) && enable_hs) {
-			BT_DBG("A2MP");
-			amp_conn_ind(conn->hcon, skb);
-		} else {
-			BT_DBG("unknown cid 0x%4.4x", cid);
-			kfree_skb(skb);
-		}
-
+		l2cap_data_channel(conn, cid, skb);
 		break;
 	}
 }
 
 /* ---- L2CAP interface with lower layer (HCI) ---- */
 
-static int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
+int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	int exact = 0, lm1 = 0, lm2 = 0;
-	register struct sock *sk;
-	struct hlist_node *node;
-
-	if (type != ACL_LINK)
-		return 0;
+	struct l2cap_chan *c;
 
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets and check their link_mode */
-	read_lock(&l2cap_sk_list.lock);
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (sk->sk_state != BT_LISTEN)
+	read_lock(&chan_list_lock);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
+
+		if (c->state != BT_LISTEN)
 			continue;
 
 		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {
 			lm1 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
+			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
 				lm1 |= HCI_LM_MASTER;
 			exact++;
 		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
 			lm2 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
+			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
 				lm2 |= HCI_LM_MASTER;
 		}
 	}
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
 	return exact ? lm1 : lm2;
 }
 
-static int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
+int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn;
 
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
 
-	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
-		return -EINVAL;
-
 	if (!status) {
 		conn = l2cap_conn_add(hcon, status);
 		if (conn)
 			l2cap_conn_ready(conn);
 	} else
-		l2cap_conn_del(hcon, bt_err(status), 0);
+		l2cap_conn_del(hcon, bt_to_errno(status));
 
 	return 0;
 }
 
-static int l2cap_disconn_ind(struct hci_conn *hcon)
+int l2cap_disconn_ind(struct hci_conn *hcon)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
 	BT_DBG("hcon %p", hcon);
 
-	if (hcon->type != ACL_LINK || !conn)
-		return 0x13;
-
+	if (!conn)
+		return HCI_ERROR_REMOTE_USER_TERM;
 	return conn->disc_reason;
 }
 
-static int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason, u8 is_process)
+int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
-		return -EINVAL;
-
-	l2cap_conn_del(hcon, bt_err(reason), is_process);
-
+	l2cap_conn_del(hcon, bt_to_errno(reason));
 	return 0;
 }
 
-static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)
+static inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)
 {
-	if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)
+	if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)
 		return;
 
 	if (encrypt == 0x00) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ * 5);
-		} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
-			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
-			__l2cap_sock_close(sk, ECONNREFUSED);
+		if (chan->sec_level == BT_SECURITY_MEDIUM) {
+			__clear_chan_timer(chan);
+			__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);
+		} else if (chan->sec_level == BT_SECURITY_HIGH)
+			l2cap_chan_close(chan, ECONNREFUSED);
 	} else {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)
-			l2cap_sock_clear_timer(sk);
+		if (chan->sec_level == BT_SECURITY_MEDIUM)
+			__clear_chan_timer(chan);
 	}
 }
 
-static int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
+int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
 {
-	struct l2cap_chan_list *l;
 	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-	int smp = 0;
+	struct l2cap_chan *chan;
 
 	if (!conn)
 		return 0;
 
-	l = &conn->chan_list;
-
 	BT_DBG("conn %p", conn);
 
-	read_lock(&l->lock);
+	if (hcon->type == LE_LINK) {
+		smp_distribute_keys(conn, 0);
+		cancel_delayed_work(&conn->security_timer);
+	}
+
+	mutex_lock(&conn->chan_lock);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		l2cap_chan_lock(chan);
 
-		BT_DBG("sk->scid %d", l2cap_pi(sk)->scid);
+		BT_DBG("chan->scid %d", chan->scid);
 
-		if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
+		if (chan->scid == L2CAP_CID_LE_DATA) {
 			if (!status && encrypt) {
-				l2cap_pi(sk)->sec_level = hcon->sec_level;
-				l2cap_chan_ready(sk);
+				chan->sec_level = hcon->sec_level;
+				l2cap_chan_ready(chan);
 			}
 
-			smp = 1;
-			bh_unlock_sock(sk);
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {
-			bh_unlock_sock(sk);
+		if (test_bit(CONF_CONNECT_PEND, &chan->conf_state)) {
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (!status && (sk->sk_state == BT_CONNECTED ||
-						sk->sk_state == BT_CONFIG)) {
-			l2cap_check_encryption(sk, encrypt);
-			bh_unlock_sock(sk);
+		if (!status && (chan->state == BT_CONNECTED ||
+						chan->state == BT_CONFIG)) {
+			struct sock *sk = chan->sk;
+
+			bt_sk(sk)->suspended = false;
+			sk->sk_state_change(sk);
+
+			l2cap_check_encryption(chan, encrypt);
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (sk->sk_state == BT_CONNECT) {
+		if (chan->state == BT_CONNECT) {
 			if (!status) {
-				l2cap_pi(sk)->conf_state |=
-						L2CAP_CONF_CONNECT_PEND;
-				if ((l2cap_pi(sk)->amp_pref ==
-						BT_AMP_POLICY_PREFER_AMP) &&
-						enable_hs) {
-					amp_create_physical(l2cap_pi(sk)->conn,
-								sk);
-				} else
-					l2cap_send_conn_req(sk);
+				l2cap_send_conn_req(chan);
 			} else {
-				l2cap_sock_clear_timer(sk);
-				l2cap_sock_set_timer(sk, HZ / 10);
+				__clear_chan_timer(chan);
+				__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);
 			}
-		} else if (sk->sk_state == BT_CONNECT2) {
+		} else if (chan->state == BT_CONNECT2) {
+			struct sock *sk = chan->sk;
 			struct l2cap_conn_rsp rsp;
-			__u16 result;
+			__u16 res, stat;
+
+			lock_sock(sk);
 
 			if (!status) {
-				if (l2cap_pi(sk)->amp_id) {
-					amp_accept_physical(conn,
-						l2cap_pi(sk)->amp_id, sk);
-					bh_unlock_sock(sk);
-					continue;
+				if (bt_sk(sk)->defer_setup) {
+					struct sock *parent = bt_sk(sk)->parent;
+					res = L2CAP_CR_PEND;
+					stat = L2CAP_CS_AUTHOR_PEND;
+					if (parent)
+						parent->sk_data_ready(parent, 0);
+				} else {
+					__l2cap_state_change(chan, BT_CONFIG);
+					res = L2CAP_CR_SUCCESS;
+					stat = L2CAP_CS_NO_INFO;
 				}
-
-				sk->sk_state = BT_CONFIG;
-				result = L2CAP_CR_SUCCESS;
 			} else {
-				sk->sk_state = BT_DISCONN;
-				l2cap_sock_set_timer(sk, HZ / 10);
-				result = L2CAP_CR_SEC_BLOCK;
+				__l2cap_state_change(chan, BT_DISCONN);
+				__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);
+				res = L2CAP_CR_SEC_BLOCK;
+				stat = L2CAP_CS_NO_INFO;
 			}
 
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-			if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
-				result == L2CAP_CR_SUCCESS) {
-				char buf[128];
-				l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-				l2cap_send_cmd(conn, l2cap_get_ident(conn),
-					       L2CAP_CONF_REQ,
-					       l2cap_build_conf_req(sk, buf),
-					       buf);
-				l2cap_pi(sk)->num_conf_req++;
-			}
+			release_sock(sk);
+
+			rsp.scid   = cpu_to_le16(chan->dcid);
+			rsp.dcid   = cpu_to_le16(chan->scid);
+			rsp.result = cpu_to_le16(res);
+			rsp.status = cpu_to_le16(stat);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
 		}
 
-		bh_unlock_sock(sk);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	if (smp) {
-		del_timer(&hcon->smp_timer);
-		smp_link_encrypt_cmplt(conn, status, encrypt);
-	}
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
+int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
-	if (!conn && hcon->hdev->dev_type != HCI_BREDR)
-		goto drop;
-
 	if (!conn)
 		conn = l2cap_conn_add(hcon, 0);
 
@@ -7671,8 +4669,10 @@
 
 	BT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);
 
-	if (flags & ACL_START) {
+	if (!(flags & ACL_CONT)) {
 		struct l2cap_hdr *hdr;
+		struct l2cap_chan *chan;
+		u16 cid;
 		int len;
 
 		if (conn->rx_len) {
@@ -7692,6 +4692,7 @@
 
 		hdr = (struct l2cap_hdr *) skb->data;
 		len = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;
+		cid = __le16_to_cpu(hdr->cid);
 
 		if (len == skb->len) {
 			/* Complete frame received */
@@ -7699,14 +4700,6 @@
 			return 0;
 		}
 
-		if (flags & ACL_CONT) {
-			BT_ERR("Complete frame is incomplete "
-				"(len %d, expected len %d)",
-				skb->len, len);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
 		BT_DBG("Start: total len %d, frag len %d", len, skb->len);
 
 		if (skb->len > len) {
@@ -7716,6 +4709,23 @@
 			goto drop;
 		}
 
+		chan = l2cap_get_chan_by_scid(conn, cid);
+
+		if (chan && chan->sk) {
+			struct sock *sk = chan->sk;
+			lock_sock(sk);
+
+			if (chan->imtu < len - L2CAP_HDR_SIZE) {
+				BT_ERR("Frame exceeding recv MTU (len %d, "
+							"MTU %d)", len,
+							chan->imtu);
+				release_sock(sk);
+				l2cap_conn_unreliable(conn, ECOMM);
+				goto drop;
+			}
+			release_sock(sk);
+		}
+
 		/* Allocate skb for the complete frame (with header) */
 		conn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);
 		if (!conn->rx_skb)
@@ -7759,131 +4769,28 @@
 	return 0;
 }
 
-static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to)
-{
-	struct hci_cp_write_automatic_flush_timeout flush_tm;
-	if (hcon && hcon->hdev) {
-		flush_tm.handle = hcon->handle;
-		if (flush_to == L2CAP_DEFAULT_FLUSH_TO)
-			flush_to = 0;
-		flush_tm.timeout = (flush_to < L2CAP_MAX_FLUSH_TO) ?
-				flush_to : L2CAP_MAX_FLUSH_TO;
-		hci_send_cmd(hcon->hdev,
-			HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT,
-			4, &(flush_tm));
-	}
-}
-
-static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l)
-{
-	int ret_flush_to = L2CAP_DEFAULT_FLUSH_TO;
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->flush_to > 0 &&
-				l2cap_pi(s)->flush_to < ret_flush_to)
-			ret_flush_to = l2cap_pi(s)->flush_to;
-	}
-	return ret_flush_to;
-}
-
 static int l2cap_debugfs_show(struct seq_file *f, void *p)
 {
-	struct sock *sk;
-	struct hlist_node *node;
+	struct l2cap_chan *c;
 
-	read_lock_bh(&l2cap_sk_list.lock);
+	read_lock(&chan_list_lock);
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		struct l2cap_pinfo *pi = l2cap_pi(sk);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
 
 		seq_printf(f, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d %d\n",
 					batostr(&bt_sk(sk)->src),
 					batostr(&bt_sk(sk)->dst),
-					sk->sk_state, __le16_to_cpu(pi->psm),
-					pi->scid, pi->dcid,
-					pi->imtu, pi->omtu, pi->sec_level,
-					pi->mode);
+					c->state, __le16_to_cpu(c->psm),
+					c->scid, c->dcid, c->imtu, c->omtu,
+					c->sec_level, c->mode);
 	}
 
-	read_unlock_bh(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
 	return 0;
 }
 
-static void l2cap_queue_acl_data(struct work_struct *worker)
-{
-	struct sock *sk = NULL;
-	int attempts = 0;
-	struct sk_buff *skb_rsp;
-	struct l2cap_hdr *lh;
-	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
-						L2CAP_ATT_NOT_SUPPORTED};
-
-	for (attempts = 0; attempts < 40; attempts++) {
-		msleep(50);
-		if (!att_chn_params.conn) {
-			BT_DBG("att_chn_params.conn is NULL");
-			return;
-		}
-		sk = l2cap_find_sock_by_fixed_cid_and_dir
-				(att_chn_params.cid,
-				att_chn_params.conn->src,
-				att_chn_params.conn->dst,
-				att_chn_params.dir);
-		bh_lock_sock(sk);
-		if (sk->sk_state == BT_CONNECTED) {
-			sock_queue_rcv_skb(sk, att_chn_params.skb);
-			if (sk)
-				bh_unlock_sock(sk);
-			return;
-		}
-		bh_unlock_sock(sk);
-	}
-	bh_lock_sock(sk);
-
-	if (att_chn_params.skb->data[0] != L2CAP_ATT_INDICATE)
-		goto not_indicate;
-
-	/* If this is an incoming Indication, we are required to confirm */
-	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(u8));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[0] = L2CAP_ATT_CONFIRM;
-	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
-	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
-	goto free_skb;
-
-not_indicate:
-	if (att_chn_params.skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
-			att_chn_params.skb->data[0] == L2CAP_ATT_CONFIRM)
-		goto free_skb;
-
-	/* If this is an incoming PDU that requires a response, respond with
-	 * a generic error so remote device doesn't hang */
-
-	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(err_rsp));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[1] = att_chn_params.skb->data[0];
-	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
-	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
-
-free_skb:
-	kfree_skb(att_chn_params.skb);
-
-	if (sk)
-		bh_unlock_sock(sk);
-
-}
-
 static int l2cap_debugfs_open(struct inode *inode, struct file *file)
 {
 	return single_open(file, l2cap_debugfs_show, inode->i_private);
@@ -7898,20 +4805,6 @@
 
 static struct dentry *l2cap_debugfs;
 
-static struct hci_proto l2cap_hci_proto = {
-	.name		= "L2CAP",
-	.id		= HCI_PROTO_L2CAP,
-	.connect_ind	= l2cap_connect_ind,
-	.connect_cfm	= l2cap_connect_cfm,
-	.disconn_ind	= l2cap_disconn_ind,
-	.disconn_cfm	= l2cap_disconn_cfm,
-	.security_cfm	= l2cap_security_cfm,
-	.recv_acldata	= l2cap_recv_acldata,
-	.create_cfm	= l2cap_create_cfm,
-	.modify_cfm	= l2cap_modify_cfm,
-	.destroy_cfm	= l2cap_destroy_cfm,
-};
-
 int __init l2cap_init(void)
 {
 	int err;
@@ -7920,19 +4813,6 @@
 	if (err < 0)
 		return err;
 
-	_l2cap_wq = create_singlethread_workqueue("l2cap");
-	if (!_l2cap_wq) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	err = hci_register_proto(&l2cap_hci_proto);
-	if (err < 0) {
-		BT_ERR("L2CAP protocol registration failed");
-		bt_sock_unregister(BTPROTO_L2CAP);
-		goto error;
-	}
-
 	if (bt_debugfs) {
 		l2cap_debugfs = debugfs_create_file("l2cap", 0444,
 					bt_debugfs, NULL, &l2cap_debugfs_fops);
@@ -7940,39 +4820,14 @@
 			BT_ERR("Failed to create L2CAP debug file");
 	}
 
-	if (amp_init() < 0) {
-		BT_ERR("AMP Manager initialization failed");
-		goto error;
-	}
-
 	return 0;
-
-error:
-	destroy_workqueue(_l2cap_wq);
-	l2cap_cleanup_sockets();
-	return err;
 }
 
 void l2cap_exit(void)
 {
-	amp_exit();
-
 	debugfs_remove(l2cap_debugfs);
-
-	flush_workqueue(_l2cap_wq);
-	destroy_workqueue(_l2cap_wq);
-
-	if (hci_unregister_proto(&l2cap_hci_proto) < 0)
-		BT_ERR("L2CAP protocol unregistration failed");
-
 	l2cap_cleanup_sockets();
 }
 
 module_param(disable_ertm, bool, 0644);
 MODULE_PARM_DESC(disable_ertm, "Disable enhanced retransmission mode");
-
-module_param(enable_hs, bool, 0644);
-MODULE_PARM_DESC(enable_hs, "Enable A2MP protocol");
-
-module_param(enable_reconfig, bool, 0644);
-MODULE_PARM_DESC(enable_reconfig, "Enable reconfig after initiating AMP move");
diff -urN flo-ElementalX-5.00/net/bluetooth/l2cap_sock.c flo-ElementalX-5.00-patched/net/bluetooth/l2cap_sock.c
--- flo-ElementalX-5.00/net/bluetooth/l2cap_sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/l2cap_sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,8 +1,9 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2011-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -26,107 +27,22 @@
 
 /* Bluetooth L2CAP sockets. */
 
-#include <linux/interrupt.h>
-#include <linux/module.h>
+#include <linux/security.h>
+#include <linux/export.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
-#include <net/bluetooth/amp.h>
 
-/* ---- L2CAP timers ---- */
-static void l2cap_sock_timeout(unsigned long arg)
-{
-	struct sock *sk = (struct sock *) arg;
-	int reason;
-
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-
-	bh_lock_sock(sk);
-
-	if (sock_owned_by_user(sk)) {
-		/* sk is owned by user. Try again later */
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		sock_put(sk);
-		return;
-	}
-
-	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
-		reason = ECONNREFUSED;
-	else if (sk->sk_state == BT_CONNECT &&
-				l2cap_pi(sk)->sec_level != BT_SECURITY_SDP)
-		reason = ECONNREFUSED;
-	else
-		reason = ETIMEDOUT;
-
-	__l2cap_sock_close(sk, reason);
-
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	sock_put(sk);
-}
-
-void l2cap_sock_set_timer(struct sock *sk, long timeout)
-{
-	BT_DBG("sk %p state %d timeout %ld", sk, sk->sk_state, timeout);
-	sk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);
-}
-
-void l2cap_sock_clear_timer(struct sock *sk)
-{
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-	sk_stop_timer(sk, &sk->sk_timer);
-}
-
-int l2cap_sock_le_params_valid(struct bt_le_params *le_params)
-{
-	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
-			le_params->scan_window > BT_LE_SCAN_WINDOW_MAX ||
-			le_params->scan_interval < BT_LE_SCAN_INTERVAL_MIN ||
-			le_params->scan_window > le_params->scan_interval ||
-			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
-			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
-			le_params->interval_min > le_params->interval_max ||
-			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
-			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
-		return 0;
-	}
-
-	return 1;
-}
-
-int l2cap_sock_le_conn_update_params_valid(struct bt_le_params *le_params)
-{
-	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
-			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
-			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
-			le_params->interval_min > le_params->interval_max ||
-			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
-			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
-		return 0;
-	}
-
-	return 1;
-}
-
-static struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)
-{
-	struct sock *sk;
-	struct hlist_node *node;
-	sk_for_each(sk, node, &l2cap_sk_list.head)
-		if (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))
-			goto found;
-	sk = NULL;
-found:
-	return sk;
-}
+static const struct proto_ops l2cap_sock_ops;
+static void l2cap_sock_init(struct sock *sk, struct sock *parent);
+static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio);
 
 static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
@@ -165,26 +81,22 @@
 		}
 	}
 
-	write_lock_bh(&l2cap_sk_list.lock);
+	if (la.l2_cid)
+		err = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));
+	else
+		err = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);
 
-	if (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {
-		err = -EADDRINUSE;
-	} else {
-		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
-		l2cap_pi(sk)->psm   = la.l2_psm;
-		l2cap_pi(sk)->sport = la.l2_psm;
-		sk->sk_state = BT_BOUND;
-
-		if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
-					__le16_to_cpu(la.l2_psm) == 0x0003)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
-	}
+	if (err < 0)
+		goto done;
 
-	if (la.l2_cid)
-		l2cap_pi(sk)->scid = la.l2_cid;
+	if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
+				__le16_to_cpu(la.l2_psm) == 0x0003)
+		chan->sec_level = BT_SECURITY_SDP;
 
-	write_unlock_bh(&l2cap_sk_list.lock);
+	bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
+
+	chan->state = BT_BOUND;
+	sk->sk_state = BT_BOUND;
 
 done:
 	release_sock(sk);
@@ -194,14 +106,14 @@
 static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
-	BT_DBG("sk %p type %d mode %d state %d", sk, sk->sk_type,
-		l2cap_pi(sk)->mode, sk->sk_state);
+	BT_DBG("sk %p", sk);
 
 	if (!addr || alen < sizeof(addr->sa_family) ||
-		addr->sa_family != AF_BLUETOOTH)
+	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
 	memset(&la, 0, sizeof(la));
@@ -211,80 +123,25 @@
 	if (la.l2_cid && la.l2_psm)
 		return -EINVAL;
 
-	lock_sock(sk);
-
-	if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)
-		&& !(la.l2_psm || la.l2_cid || l2cap_pi(sk)->fixed_channel)) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	switch (l2cap_pi(sk)->mode) {
-	case L2CAP_MODE_BASIC:
-		break;
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		if (!disable_ertm)
-			break;
-		/* fall through */
-	default:
-		err = -ENOTSUPP;
-		goto done;
-	}
-
-	switch (sk->sk_state) {
-	case BT_CONNECT:
-	case BT_CONNECT2:
-	case BT_CONFIG:
-		/* Already connecting */
-		goto wait;
-
-	case BT_CONNECTED:
-		/* Already connected */
-		err = -EISCONN;
-		goto done;
-
-	case BT_OPEN:
-	case BT_BOUND:
-		/* Can connect */
-		break;
-
-	default:
-		err = -EBADFD;
-		goto done;
-	}
-
-	/* PSM must be odd and lsb of upper byte must be 0 */
-	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 &&
-		!l2cap_pi(sk)->fixed_channel &&
-				sk->sk_type != SOCK_RAW && !la.l2_cid) {
-		BT_DBG("Bad PSM 0x%x", (int)__le16_to_cpu(la.l2_psm));
-		err = -EINVAL;
-		goto done;
-	}
-
-	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);
-	l2cap_pi(sk)->psm = la.l2_psm;
-	l2cap_pi(sk)->dcid = la.l2_cid;
-
-	err = l2cap_do_connect(sk);
+	err = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),
+				&la.l2_bdaddr);
 	if (err)
-		goto done;
+		return err;
+
+	lock_sock(sk);
 
-wait:
 	err = bt_sock_wait_state(sk, BT_CONNECTED,
 			sock_sndtimeo(sk, flags & O_NONBLOCK));
-done:
-	if (err)
-		BT_ERR("failed %d", err);
+
 	release_sock(sk);
+
 	return err;
 }
 
 static int l2cap_sock_listen(struct socket *sock, int backlog)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err = 0;
 
 	BT_DBG("sk %p backlog %d", sk, backlog);
@@ -297,7 +154,7 @@
 		goto done;
 	}
 
-	switch (l2cap_pi(sk)->mode) {
+	switch (chan->mode) {
 	case L2CAP_MODE_BASIC:
 		break;
 	case L2CAP_MODE_ERTM:
@@ -310,30 +167,10 @@
 		goto done;
 	}
 
-	if (!l2cap_pi(sk)->psm && !l2cap_pi(sk)->scid) {
-		bdaddr_t *src = &bt_sk(sk)->src;
-		u16 psm;
-
-		err = -EINVAL;
-
-		write_lock_bh(&l2cap_sk_list.lock);
-
-		for (psm = 0x1001; psm < 0x1100; psm += 2)
-			if (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {
-				l2cap_pi(sk)->psm   = cpu_to_le16(psm);
-				l2cap_pi(sk)->sport = cpu_to_le16(psm);
-				err = 0;
-				break;
-			}
-
-		write_unlock_bh(&l2cap_sk_list.lock);
-
-		if (err < 0)
-			goto done;
-	}
-
 	sk->sk_max_ack_backlog = backlog;
 	sk->sk_ack_backlog = 0;
+
+	chan->state = BT_LISTEN;
 	sk->sk_state = BT_LISTEN;
 
 done:
@@ -350,30 +187,26 @@
 
 	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
+		nsk = bt_accept_dequeue(sk, newsock);
+		if (nsk)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -381,8 +214,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -401,20 +238,22 @@
 {
 	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
+	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
 	if (peer) {
-		la->l2_psm = l2cap_pi(sk)->psm;
+		la->l2_psm = chan->psm;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+		la->l2_cid = cpu_to_le16(chan->dcid);
 	} else {
-		la->l2_psm = l2cap_pi(sk)->sport;
+		la->l2_psm = chan->sport;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);
+		la->l2_cid = cpu_to_le16(chan->scid);
 	}
 
 	return 0;
@@ -423,6 +262,7 @@
 static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
 	struct l2cap_conninfo cinfo;
 	int len, err = 0;
@@ -438,13 +278,13 @@
 	switch (optname) {
 	case L2CAP_OPTIONS:
 		memset(&opts, 0, sizeof(opts));
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = l2cap_pi(sk)->tx_win;
+		opts.imtu     = chan->imtu;
+		opts.omtu     = chan->omtu;
+		opts.flush_to = chan->flush_to;
+		opts.mode     = chan->mode;
+		opts.fcs      = chan->fcs;
+		opts.max_tx   = chan->max_tx;
+		opts.txwin_size = chan->tx_win;
 
 		len = min_t(unsigned int, len, sizeof(opts));
 		if (copy_to_user(optval, (char *) &opts, len))
@@ -453,7 +293,7 @@
 		break;
 
 	case L2CAP_LM:
-		switch (l2cap_pi(sk)->sec_level) {
+		switch (chan->sec_level) {
 		case BT_SECURITY_LOW:
 			opt = L2CAP_LM_AUTH;
 			break;
@@ -469,15 +309,12 @@
 			break;
 		}
 
-		if (l2cap_pi(sk)->role_switch)
+		if (test_bit(FLAG_ROLE_SWITCH, &chan->flags))
 			opt |= L2CAP_LM_MASTER;
 
-		if (l2cap_pi(sk)->force_reliable)
+		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
 			opt |= L2CAP_LM_RELIABLE;
 
-		if (l2cap_pi(sk)->flushable)
-			opt |= L2CAP_LM_FLUSHABLE;
-
 		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
@@ -490,8 +327,9 @@
 			break;
 		}
 
-		cinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;
-		memcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);
+		memset(&cinfo, 0, sizeof(cinfo));
+		cinfo.hci_handle = chan->conn->hcon->handle;
+		memcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -511,6 +349,7 @@
 static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
 	int len, err = 0;
@@ -530,19 +369,17 @@
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
 
 		memset(&sec, 0, sizeof(sec));
-		sec.level = l2cap_pi(sk)->sec_level;
+		sec.level = chan->sec_level;
 
-		if (sk->sk_state == BT_CONNECTED) {
-			sec.key_size = l2cap_pi(sk)->conn->hcon->enc_key_size;
-			sec.level = l2cap_pi(sk)->conn->hcon->sec_level;
-		}
+		if (sk->sk_state == BT_CONNECTED)
+			sec.key_size = chan->conn->hcon->enc_key_size;
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))
@@ -561,6 +398,13 @@
 
 		break;
 
+	case BT_FLUSHABLE:
+		if (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),
+						(u32 __user *) optval))
+			err = -EFAULT;
+
+		break;
+
 	case BT_POWER:
 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
 				&& sk->sk_type != SOCK_RAW) {
@@ -568,7 +412,7 @@
 			break;
 		}
 
-		pwr.force_active = l2cap_pi(sk)->force_active;
+		pwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 
 		len = min_t(unsigned int, len, sizeof(pwr));
 		if (copy_to_user(optval, (char *) &pwr, len))
@@ -576,19 +420,13 @@
 
 		break;
 
-	case BT_AMP_POLICY:
-		if (put_user(l2cap_pi(sk)->amp_pref, (u32 __user *) optval))
-			err = -EFAULT;
-		break;
-
-	case BT_LE_PARAMS:
-		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			err = -EINVAL;
+	case BT_CHANNEL_POLICY:
+		if (!enable_hs) {
+			err = -ENOPROTOOPT;
 			break;
 		}
 
-		if (copy_to_user(optval, (char *) &bt_sk(sk)->le_params,
-						sizeof(bt_sk(sk)->le_params)))
+		if (put_user(chan->chan_policy, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
 
@@ -604,30 +442,29 @@
 static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
-	int len, le_sock, err = 0;
+	int len, err = 0;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
 
 	lock_sock(sk);
 
-	le_sock = l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA;
-
 	switch (optname) {
 	case L2CAP_OPTIONS:
-		if (sk->sk_state == BT_CONNECTED && !le_sock) {
+		if (sk->sk_state == BT_CONNECTED) {
 			err = -EINVAL;
 			break;
 		}
 
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = l2cap_pi(sk)->tx_win;
+		opts.imtu     = chan->imtu;
+		opts.omtu     = chan->omtu;
+		opts.flush_to = chan->flush_to;
+		opts.mode     = chan->mode;
+		opts.fcs      = chan->fcs;
+		opts.max_tx   = chan->max_tx;
+		opts.txwin_size = chan->tx_win;
 
 		len = min_t(unsigned int, sizeof(opts), optlen);
 		if (copy_from_user((char *) &opts, optval, len)) {
@@ -635,39 +472,18 @@
 			break;
 		}
 
-		if ((opts.imtu || opts.omtu) && le_sock &&
-				(sk->sk_state == BT_CONNECTED)) {
-			if (opts.imtu >= L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->imtu = opts.imtu;
-			if (opts.omtu >= L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->omtu = opts.omtu;
-			if (opts.imtu < L2CAP_LE_DEFAULT_MTU ||
-					opts.omtu < L2CAP_LE_DEFAULT_MTU)
-				err = -EINVAL;
-			break;
-		}
-
-		if (opts.txwin_size < 1 ||
-			opts.txwin_size > L2CAP_TX_WIN_MAX_EXTENDED) {
+		if (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {
 			err = -EINVAL;
 			break;
 		}
 
-		l2cap_pi(sk)->mode = opts.mode;
-		switch (l2cap_pi(sk)->mode) {
+		chan->mode = opts.mode;
+		switch (chan->mode) {
 		case L2CAP_MODE_BASIC:
-			l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;
-			break;
-		case L2CAP_MODE_STREAMING:
-			if (!disable_ertm) {
-				/* No fallback to ERTM or Basic mode */
-				l2cap_pi(sk)->conf_state |=
-						L2CAP_CONF_STATE2_DEVICE;
-				break;
-			}
-			err = -EINVAL;
+			clear_bit(CONF_STATE2_DEVICE, &chan->conf_state);
 			break;
 		case L2CAP_MODE_ERTM:
+		case L2CAP_MODE_STREAMING:
 			if (!disable_ertm)
 				break;
 			/* fall through */
@@ -676,12 +492,11 @@
 			break;
 		}
 
-		l2cap_pi(sk)->imtu = opts.imtu;
-		l2cap_pi(sk)->omtu = opts.omtu;
-		l2cap_pi(sk)->fcs  = opts.fcs;
-		l2cap_pi(sk)->max_tx = opts.max_tx;
-		l2cap_pi(sk)->tx_win = opts.txwin_size;
-		l2cap_pi(sk)->flush_to = opts.flush_to;
+		chan->imtu = opts.imtu;
+		chan->omtu = opts.omtu;
+		chan->fcs  = opts.fcs;
+		chan->max_tx = opts.max_tx;
+		chan->tx_win = opts.txwin_size;
 		break;
 
 	case L2CAP_LM:
@@ -691,15 +506,21 @@
 		}
 
 		if (opt & L2CAP_LM_AUTH)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_LOW;
+			chan->sec_level = BT_SECURITY_LOW;
 		if (opt & L2CAP_LM_ENCRYPT)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
+			chan->sec_level = BT_SECURITY_MEDIUM;
 		if (opt & L2CAP_LM_SECURE)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;
+			chan->sec_level = BT_SECURITY_HIGH;
 
-		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
-		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
-		l2cap_pi(sk)->flushable = (opt & L2CAP_LM_FLUSHABLE);
+		if (opt & L2CAP_LM_MASTER)
+			set_bit(FLAG_ROLE_SWITCH, &chan->flags);
+		else
+			clear_bit(FLAG_ROLE_SWITCH, &chan->flags);
+
+		if (opt & L2CAP_LM_RELIABLE)
+			set_bit(FLAG_FORCE_RELIABLE, &chan->flags);
+		else
+			clear_bit(FLAG_FORCE_RELIABLE, &chan->flags);
 		break;
 
 	default:
@@ -714,9 +535,9 @@
 static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
-	struct bt_le_params le_params;
 	struct l2cap_conn *conn;
 	int len, err = 0;
 	u32 opt;
@@ -733,8 +554,8 @@
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
@@ -753,20 +574,35 @@
 			break;
 		}
 
-		l2cap_pi(sk)->sec_level = sec.level;
+		chan->sec_level = sec.level;
 
-		conn = l2cap_pi(sk)->conn;
-		if (conn && l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
+		if (!chan->conn)
+			break;
+
+		conn = chan->conn;
+
+		/*change security for LE channels */
+		if (chan->scid == L2CAP_CID_LE_DATA) {
 			if (!conn->hcon->out) {
 				err = -EINVAL;
 				break;
 			}
 
-			if (smp_conn_security(conn, sec.level))
+			if (smp_conn_security(conn->hcon, sec.level))
 				break;
-
-			err = 0;
 			sk->sk_state = BT_CONFIG;
+			chan->state = BT_CONFIG;
+
+		/* or for ACL link */
+		} else if ((sk->sk_state == BT_CONNECT2 &&
+			   bt_sk(sk)->defer_setup) ||
+			   sk->sk_state == BT_CONNECTED) {
+			if (!l2cap_chan_check_security(chan))
+				bt_sk(sk)->suspended = true;
+			else
+				sk->sk_state_change(sk);
+		} else {
+			err = -EINVAL;
 		}
 		break;
 
@@ -784,88 +620,77 @@
 		bt_sk(sk)->defer_setup = opt;
 		break;
 
-	case BT_POWER:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
+	case BT_FLUSHABLE:
+		if (get_user(opt, (u32 __user *) optval)) {
+			err = -EFAULT;
 			break;
 		}
 
-		pwr.force_active = 1;
-
-		len = min_t(unsigned int, sizeof(pwr), optlen);
-		if (copy_from_user((char *) &pwr, optval, len)) {
-			err = -EFAULT;
+		if (opt > BT_FLUSHABLE_ON) {
+			err = -EINVAL;
 			break;
 		}
-		l2cap_pi(sk)->force_active = pwr.force_active;
-		break;
 
-	case BT_AMP_POLICY:
-		if (get_user(opt, (u32 __user *) optval)) {
-			err = -EFAULT;
-			break;
+		if (opt == BT_FLUSHABLE_OFF) {
+			struct l2cap_conn *conn = chan->conn;
+			/* proceed further only when we have l2cap_conn and
+			   No Flush support in the LM */
+			if (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {
+				err = -EINVAL;
+				break;
+			}
 		}
 
-		if ((opt > BT_AMP_POLICY_PREFER_AMP) ||
-			((l2cap_pi(sk)->mode != L2CAP_MODE_ERTM) &&
-			 (l2cap_pi(sk)->mode != L2CAP_MODE_STREAMING))) {
+		if (opt)
+			set_bit(FLAG_FLUSHABLE, &chan->flags);
+		else
+			clear_bit(FLAG_FLUSHABLE, &chan->flags);
+		break;
+
+	case BT_POWER:
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
 
-		l2cap_pi(sk)->amp_pref = (u8) opt;
-		BT_DBG("BT_AMP_POLICY now %d", opt);
-
-		if ((sk->sk_state == BT_CONNECTED) &&
-			(l2cap_pi(sk)->amp_move_role == L2CAP_AMP_MOVE_NONE))
-			l2cap_amp_move_init(sk);
-
-		break;
+		pwr.force_active = BT_POWER_FORCE_ACTIVE_ON;
 
-	case BT_FLUSHABLE:
-		if (get_user(opt, (u32 __user *) optval)) {
+		len = min_t(unsigned int, sizeof(pwr), optlen);
+		if (copy_from_user((char *) &pwr, optval, len)) {
 			err = -EFAULT;
 			break;
 		}
-		l2cap_pi(sk)->flushable = opt;
 
+		if (pwr.force_active)
+			set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+		else
+			clear_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 		break;
 
-	case BT_LE_PARAMS:
-		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			err = -EINVAL;
+	case BT_CHANNEL_POLICY:
+		if (!enable_hs) {
+			err = -ENOPROTOOPT;
 			break;
 		}
 
-		if (copy_from_user((char *) &le_params, optval,
-					sizeof(struct bt_le_params))) {
+		if (get_user(opt, (u32 __user *) optval)) {
 			err = -EFAULT;
 			break;
 		}
 
-		conn = l2cap_pi(sk)->conn;
-		if (!conn || !conn->hcon ||
-				l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			memcpy(&bt_sk(sk)->le_params, &le_params,
-							sizeof(le_params));
+		if (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {
+			err = -EINVAL;
 			break;
 		}
 
-		if (!conn->hcon->out ||
-				!l2cap_sock_le_conn_update_params_valid(
-					&le_params)) {
-			err = -EINVAL;
+		if (chan->mode != L2CAP_MODE_ERTM &&
+				chan->mode != L2CAP_MODE_STREAMING) {
+			err = -EOPNOTSUPP;
 			break;
 		}
 
-		memcpy(&bt_sk(sk)->le_params, &le_params, sizeof(le_params));
-
-		hci_le_conn_update(conn->hcon,
-				le_params.interval_min,
-				le_params.interval_max,
-				le_params.latency,
-				le_params.supervision_timeout);
+		chan->chan_policy = (u8) opt;
 		break;
 
 	default:
@@ -880,11 +705,8 @@
 static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb;
-	struct sk_buff_head seg_queue;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err;
-	u8 amp_id;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
@@ -898,102 +720,12 @@
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_CONNECTED) {
-		err = -ENOTCONN;
-		goto done;
-	}
-
-	/* Connectionless channel */
-	if (sk->sk_type == SOCK_DGRAM) {
-		skb = l2cap_create_connless_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-		} else {
-			l2cap_do_send(sk, skb);
-			err = len;
-		}
-		goto done;
+		release_sock(sk);
+		return -ENOTCONN;
 	}
 
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		/* Check outgoing MTU */
-		if (len > pi->omtu) {
-			err = -EMSGSIZE;
-			goto done;
-		}
+	err = l2cap_chan_send(chan, msg, len, sk->sk_priority);
 
-		/* Create a basic PDU */
-		skb = l2cap_create_basic_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-			goto done;
-		}
-
-		l2cap_do_send(sk, skb);
-		err = len;
-		break;
-
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-
-		/* Check outgoing MTU */
-		if (len > pi->omtu) {
-			err = -EMSGSIZE;
-			goto done;
-		}
-
-		__skb_queue_head_init(&seg_queue);
-
-		/* Do segmentation before calling in to the state machine,
-		 * since it's possible to block while waiting for memory
-		 * allocation.
-		 */
-		amp_id = pi->amp_id;
-		err = l2cap_segment_sdu(sk, &seg_queue, msg, len, 0);
-
-		/* The socket lock is released while segmenting, so check
-		 * that the socket is still connected
-		 */
-		if (sk->sk_state != BT_CONNECTED) {
-			__skb_queue_purge(&seg_queue);
-			err = -ENOTCONN;
-		}
-
-		if (err) {
-			BT_DBG("Error %d, sk_sndbuf %d, sk_wmem_alloc %d",
-				err, sk->sk_sndbuf,
-				atomic_read(&sk->sk_wmem_alloc));
-			break;
-		}
-
-		if (pi->amp_id != amp_id) {
-			/* Channel moved while unlocked. Resegment. */
-			err = l2cap_resegment_queue(sk, &seg_queue);
-
-			if (err)
-				break;
-		}
-
-		if (pi->mode != L2CAP_MODE_STREAMING)
-			err = l2cap_ertm_tx(sk, 0, &seg_queue,
-				L2CAP_ERTM_EVENT_DATA_REQUEST);
-		else
-			err = l2cap_strm_tx(sk, &seg_queue);
-		if (!err)
-			err = len;
-
-		/* If the skbs were not queued for sending, they'll still be in
-		 * seg_queue and need to be purged.
-		 */
-		__skb_queue_purge(&seg_queue);
-		break;
-
-	default:
-		BT_DBG("bad state %1.1x", pi->mode);
-		err = -EBADFD;
-	}
-
-done:
 	release_sock(sk);
 	return err;
 }
@@ -1001,43 +733,16 @@
 static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
 	int err;
 
 	lock_sock(sk);
 
 	if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {
-		struct l2cap_conn_rsp rsp;
-		struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-		u8 buf[128];
-
-		if (l2cap_pi(sk)->amp_id) {
-			/* Physical link must be brought up before connection
-			 * completes.
-			 */
-			amp_accept_physical(conn, l2cap_pi(sk)->amp_id, sk);
-			release_sock(sk);
-			return 0;
-		}
-
 		sk->sk_state = BT_CONFIG;
+		pi->chan->state = BT_CONFIG;
 
-		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-		rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-		rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-		l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) {
-			release_sock(sk);
-			return 0;
-		}
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-				l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-
+		__l2cap_connect_rsp_defer(pi->chan);
 		release_sock(sk);
 		return 0;
 	}
@@ -1049,112 +754,57 @@
 	else
 		err = bt_sock_recvmsg(iocb, sock, msg, len, flags);
 
-	if (err >= 0)
-		l2cap_ertm_recv_done(sk);
+	if (pi->chan->mode != L2CAP_MODE_ERTM)
+		return err;
+
+	/* Attempt to put pending rx data in the socket buffer */
+
+	lock_sock(sk);
+
+	if (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))
+		goto done;
+
+	if (pi->rx_busy_skb) {
+		if (!sock_queue_rcv_skb(sk, pi->rx_busy_skb))
+			pi->rx_busy_skb = NULL;
+		else
+			goto done;
+	}
+
+	/* Restore data flow when half of the receive buffer is
+	 * available.  This avoids resending large numbers of
+	 * frames.
+	 */
+	if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)
+		l2cap_chan_busy(pi->chan, 0);
 
+done:
+	release_sock(sk);
 	return err;
 }
 
 /* Kill socket (only if zapped and orphan)
  * Must be called on unlocked socket.
  */
-void l2cap_sock_kill(struct sock *sk)
+static void l2cap_sock_kill(struct sock *sk)
 {
 	if (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)
 		return;
 
-	BT_DBG("sk %p state %d", sk, sk->sk_state);
+	BT_DBG("sk %p state %s", sk, state_to_string(sk->sk_state));
 
 	/* Kill poor orphan */
-	bt_sock_unlink(&l2cap_sk_list, sk);
+
+	l2cap_chan_destroy(l2cap_pi(sk)->chan);
 	sock_set_flag(sk, SOCK_DEAD);
 	sock_put(sk);
 }
 
-/* Must be called on unlocked socket. */
-static void l2cap_sock_close(struct sock *sk)
-{
-	l2cap_sock_clear_timer(sk);
-	lock_sock(sk);
-	__l2cap_sock_close(sk, ECONNRESET);
-	release_sock(sk);
-	l2cap_sock_kill(sk);
-}
-
-static void l2cap_sock_cleanup_listen(struct sock *parent)
-{
-	struct sock *sk;
-
-	BT_DBG("parent %p", parent);
-
-	/* Close not yet accepted channels */
-	while ((sk = bt_accept_dequeue(parent, NULL)))
-		l2cap_sock_close(sk);
-
-	parent->sk_state = BT_CLOSED;
-	sock_set_flag(parent, SOCK_ZAPPED);
-}
-
-void __l2cap_sock_close(struct sock *sk, int reason)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-
-	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
-
-	switch (sk->sk_state) {
-	case BT_LISTEN:
-		l2cap_sock_cleanup_listen(sk);
-		break;
-
-	case BT_CONNECTED:
-	case BT_CONFIG:
-		if ((sk->sk_type == SOCK_SEQPACKET ||
-					sk->sk_type == SOCK_STREAM) &&
-					conn->hcon->type == ACL_LINK) {
-			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-			l2cap_send_disconn_req(conn, sk, reason);
-		} else
-			l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT2:
-		if ((sk->sk_type == SOCK_SEQPACKET ||
-					sk->sk_type == SOCK_STREAM) &&
-					conn->hcon->type == ACL_LINK) {
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
-
-			if (bt_sk(sk)->defer_setup)
-				result = L2CAP_CR_SEC_BLOCK;
-			else
-				result = L2CAP_CR_BAD_PSM;
-			sk->sk_state = BT_DISCONN;
-
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-		}
-
-		l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT:
-	case BT_DISCONN:
-		l2cap_chan_del(sk, reason);
-		break;
-
-	default:
-		sock_set_flag(sk, SOCK_ZAPPED);
-		break;
-	}
-}
-
 static int l2cap_sock_shutdown(struct socket *sock, int how)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan;
+	struct l2cap_conn *conn;
 	int err = 0;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -1162,17 +812,24 @@
 	if (!sk)
 		return 0;
 
+	chan = l2cap_pi(sk)->chan;
+	conn = chan->conn;
+
+	if (conn)
+		mutex_lock(&conn->chan_lock);
+
+	l2cap_chan_lock(chan);
 	lock_sock(sk);
-	if (!sk->sk_shutdown) {
 
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
+	if (!sk->sk_shutdown) {
+		if (chan->mode == L2CAP_MODE_ERTM)
 			err = __l2cap_wait_ack(sk);
-			l2cap_ertm_shutdown(sk);
-		}
 
 		sk->sk_shutdown = SHUTDOWN_MASK;
-		l2cap_sock_clear_timer(sk);
-		__l2cap_sock_close(sk, 0);
+
+		release_sock(sk);
+		l2cap_chan_close(chan, 0);
+		lock_sock(sk);
 
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
@@ -1183,13 +840,17 @@
 		err = -sk->sk_err;
 
 	release_sock(sk);
+	l2cap_chan_unlock(chan);
+
+	if (conn)
+		mutex_unlock(&conn->chan_lock);
+
 	return err;
 }
 
 static int l2cap_sock_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
-	struct sock *sk2 = NULL;
 	int err;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -1197,17 +858,6 @@
 	if (!sk)
 		return 0;
 
-	/* If this is an ATT socket, find it's matching server/client */
-	if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA)
-		sk2 = l2cap_find_sock_by_fixed_cid_and_dir(L2CAP_CID_LE_DATA,
-					&bt_sk(sk)->src, &bt_sk(sk)->dst,
-					l2cap_pi(sk)->incoming ? 0 : 1);
-
-	/* If matching socket found, request tear down */
-	BT_DBG("sock:%p companion:%p", sk, sk2);
-	if (sk2)
-		l2cap_sock_set_timer(sk2, 1);
-
 	err = l2cap_sock_shutdown(sock, 2);
 
 	sock_orphan(sk);
@@ -1215,87 +865,166 @@
 	return err;
 }
 
-static void l2cap_sock_destruct(struct sock *sk)
+static struct l2cap_chan *l2cap_sock_new_connection_cb(void *data)
 {
-	BT_DBG("sk %p", sk);
+	struct sock *sk, *parent = data;
 
-	skb_queue_purge(&sk->sk_receive_queue);
-	skb_queue_purge(&sk->sk_write_queue);
+	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
+								GFP_ATOMIC);
+	if (!sk)
+		return NULL;
+
+	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);
+
+	l2cap_sock_init(sk, parent);
+
+	return l2cap_pi(sk)->chan;
+}
+
+static int l2cap_sock_recv_cb(void *data, struct sk_buff *skb)
+{
+	int err;
+	struct sock *sk = data;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+
+	lock_sock(sk);
+
+	if (pi->rx_busy_skb) {
+		err = -ENOMEM;
+		goto done;
+	}
+
+	err = sock_queue_rcv_skb(sk, skb);
+
+	/* For ERTM, handle one skb that doesn't fit into the recv
+	 * buffer.  This is important to do because the data frames
+	 * have already been acked, so the skb cannot be discarded.
+	 *
+	 * Notify the l2cap core that the buffer is full, so the
+	 * LOCAL_BUSY state is entered and no more frames are
+	 * acked and reassembled until there is buffer space
+	 * available.
+	 */
+	if (err < 0 && pi->chan->mode == L2CAP_MODE_ERTM) {
+		pi->rx_busy_skb = skb;
+		l2cap_chan_busy(pi->chan, 1);
+		err = 0;
+	}
+
+done:
+	release_sock(sk);
+
+	return err;
+}
+
+static void l2cap_sock_close_cb(void *data)
+{
+	struct sock *sk = data;
+
+	l2cap_sock_kill(sk);
+}
+
+static void l2cap_sock_state_change_cb(void *data, int state)
+{
+	struct sock *sk = data;
 
-	l2cap_ertm_destruct(sk);
+	sk->sk_state = state;
 }
 
-static void set_default_config(struct l2cap_conf_prm *conf_prm)
+static struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,
+					       unsigned long len, int nb,
+					       int *err)
+{
+	struct sock *sk = chan->sk;
+
+	return bt_skb_send_alloc(sk, len, nb, err);
+}
+
+static struct l2cap_ops l2cap_chan_ops = {
+	.name		= "L2CAP Socket Interface",
+	.new_connection	= l2cap_sock_new_connection_cb,
+	.recv		= l2cap_sock_recv_cb,
+	.close		= l2cap_sock_close_cb,
+	.state_change	= l2cap_sock_state_change_cb,
+	.alloc_skb	= l2cap_sock_alloc_skb_cb,
+};
+
+static void l2cap_sock_destruct(struct sock *sk)
 {
-	conf_prm->fcs = L2CAP_FCS_CRC16;
-	conf_prm->flush_to = L2CAP_DEFAULT_FLUSH_TO;
+	BT_DBG("sk %p", sk);
+
+	if (l2cap_pi(sk)->rx_busy_skb) {
+		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
+		l2cap_pi(sk)->rx_busy_skb = NULL;
+	}
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	skb_queue_purge(&sk->sk_write_queue);
 }
 
-void l2cap_sock_init(struct sock *sk, struct sock *parent)
+static void l2cap_sock_init(struct sock *sk, struct sock *parent)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_chan *chan = pi->chan;
 
-	BT_DBG("sk %p parent %p", sk, parent);
+	BT_DBG("sk %p", sk);
 
 	if (parent) {
+		struct l2cap_chan *pchan = l2cap_pi(parent)->chan;
+
 		sk->sk_type = parent->sk_type;
-		sk->sk_rcvbuf = parent->sk_rcvbuf;
-		sk->sk_sndbuf = parent->sk_sndbuf;
 		bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;
 
-		pi->imtu = l2cap_pi(parent)->imtu;
-		pi->omtu = l2cap_pi(parent)->omtu;
-		pi->conf_state = l2cap_pi(parent)->conf_state;
-		pi->mode = l2cap_pi(parent)->mode;
-		pi->fcs  = l2cap_pi(parent)->fcs;
-		pi->max_tx = l2cap_pi(parent)->max_tx;
-		pi->tx_win = l2cap_pi(parent)->tx_win;
-		pi->sec_level = l2cap_pi(parent)->sec_level;
-		pi->role_switch = l2cap_pi(parent)->role_switch;
-		pi->force_reliable = l2cap_pi(parent)->force_reliable;
-		pi->flushable = l2cap_pi(parent)->flushable;
-		pi->force_active = l2cap_pi(parent)->force_active;
-		pi->amp_pref = l2cap_pi(parent)->amp_pref;
+		chan->chan_type = pchan->chan_type;
+		chan->imtu = pchan->imtu;
+		chan->omtu = pchan->omtu;
+		chan->conf_state = pchan->conf_state;
+		chan->mode = pchan->mode;
+		chan->fcs  = pchan->fcs;
+		chan->max_tx = pchan->max_tx;
+		chan->tx_win = pchan->tx_win;
+		chan->tx_win_max = pchan->tx_win_max;
+		chan->sec_level = pchan->sec_level;
+		chan->flags = pchan->flags;
+
+		security_sk_clone(parent, sk);
 	} else {
-		pi->imtu = L2CAP_DEFAULT_MTU;
-		pi->omtu = 0;
+
+		switch (sk->sk_type) {
+		case SOCK_RAW:
+			chan->chan_type = L2CAP_CHAN_RAW;
+			break;
+		case SOCK_DGRAM:
+			chan->chan_type = L2CAP_CHAN_CONN_LESS;
+			break;
+		case SOCK_SEQPACKET:
+		case SOCK_STREAM:
+			chan->chan_type = L2CAP_CHAN_CONN_ORIENTED;
+			break;
+		}
+
+		chan->imtu = L2CAP_DEFAULT_MTU;
+		chan->omtu = 0;
 		if (!disable_ertm && sk->sk_type == SOCK_STREAM) {
-			pi->mode = L2CAP_MODE_ERTM;
-			pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
+			chan->mode = L2CAP_MODE_ERTM;
+			set_bit(CONF_STATE2_DEVICE, &chan->conf_state);
 		} else {
-			pi->mode = L2CAP_MODE_BASIC;
+			chan->mode = L2CAP_MODE_BASIC;
 		}
-		pi->reconf_state = L2CAP_RECONF_NONE;
-		pi->max_tx = L2CAP_DEFAULT_MAX_TX;
-		pi->fcs = L2CAP_FCS_CRC16;
-		pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;
-		pi->sec_level = BT_SECURITY_LOW;
-		pi->role_switch = 0;
-		pi->force_reliable = 0;
-		pi->flushable = 0;
-		pi->force_active = 1;
-		pi->amp_pref = BT_AMP_POLICY_REQUIRE_BR_EDR;
+		chan->max_tx = L2CAP_DEFAULT_MAX_TX;
+		chan->fcs  = L2CAP_FCS_CRC16;
+		chan->tx_win = L2CAP_DEFAULT_TX_WINDOW;
+		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
+		chan->sec_level = BT_SECURITY_LOW;
+		chan->flags = 0;
+		set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 	}
 
 	/* Default config options */
-	sk->sk_backlog_rcv = l2cap_data_channel;
-	pi->ampcon = NULL;
-	pi->ampchan = NULL;
-	pi->conf_len = 0;
-	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
-	pi->scid = 0;
-	pi->dcid = 0;
-	pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
-	pi->ack_win = pi->tx_win;
-	pi->extended_control = 0;
+	chan->flush_to = L2CAP_DEFAULT_FLUSH_TO;
 
-	pi->local_conf.fcs = pi->fcs;
-	pi->local_conf.flush_to = pi->flush_to;
-
-	set_default_config(&pi->remote_conf);
-
-	skb_queue_head_init(TX_QUEUE(sk));
-	skb_queue_head_init(SREJ_QUEUE(sk));
+	chan->data = sk;
+	chan->ops = &l2cap_chan_ops;
 }
 
 static struct proto l2cap_proto = {
@@ -1304,9 +1033,10 @@
 	.obj_size	= sizeof(struct l2cap_pinfo)
 };
 
-struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
+static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct sock *sk;
+	struct l2cap_chan *chan;
 
 	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);
 	if (!sk)
@@ -1316,16 +1046,21 @@
 	INIT_LIST_HEAD(&bt_sk(sk)->accept_q);
 
 	sk->sk_destruct = l2cap_sock_destruct;
-	sk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);
+	sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;
 
 	sock_reset_flag(sk, SOCK_ZAPPED);
 
 	sk->sk_protocol = proto;
 	sk->sk_state = BT_OPEN;
 
-	setup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);
+	chan = l2cap_chan_create(sk);
+	if (!chan) {
+		l2cap_sock_kill(sk);
+		return NULL;
+	}
+
+	l2cap_pi(sk)->chan = chan;
 
-	bt_sock_link(&l2cap_sk_list, sk);
 	return sk;
 }
 
@@ -1355,7 +1090,7 @@
 	return 0;
 }
 
-const struct proto_ops l2cap_sock_ops = {
+static const struct proto_ops l2cap_sock_ops = {
 	.family		= PF_BLUETOOTH,
 	.owner		= THIS_MODULE,
 	.release	= l2cap_sock_release,
diff -urN flo-ElementalX-5.00/net/bluetooth/lib.c flo-ElementalX-5.00-patched/net/bluetooth/lib.c
--- flo-ElementalX-5.00/net/bluetooth/lib.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/lib.c	2016-06-02 00:28:55.000000000 +0000
@@ -24,6 +24,8 @@
 
 /* Bluetooth kernel library. */
 
+#define pr_fmt(fmt) "Bluetooth: " fmt
+
 #include <linux/module.h>
 
 #include <linux/kernel.h>
@@ -59,7 +61,7 @@
 EXPORT_SYMBOL(batostr);
 
 /* Bluetooth error codes to Unix errno mapping */
-int bt_err(__u16 code)
+int bt_to_errno(__u16 code)
 {
 	switch (code) {
 	case 0:
@@ -149,4 +151,42 @@
 		return ENOSYS;
 	}
 }
+EXPORT_SYMBOL(bt_to_errno);
+
+int bt_info(const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	r = pr_info("%pV", &vaf);
+
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(bt_info);
+
+int bt_err(const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	r = pr_err("%pV", &vaf);
+
+	va_end(args);
+
+	return r;
+}
 EXPORT_SYMBOL(bt_err);
diff -urN flo-ElementalX-5.00/net/bluetooth/mgmt.c flo-ElementalX-5.00-patched/net/bluetooth/mgmt.c
--- flo-ElementalX-5.00/net/bluetooth/mgmt.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/mgmt.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
+
    Copyright (C) 2010  Nokia Corporation
-   Copyright (c) 2011-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2011-2012 Intel Corporation
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -23,45 +24,191 @@
 
 /* Bluetooth HCI Management interface */
 
+#include <linux/kernel.h>
 #include <linux/uaccess.h>
-#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 
-#define MGMT_VERSION	0
-#define MGMT_REVISION	1
+bool enable_hs;
+bool enable_le;
+
+#define MGMT_VERSION	1
+#define MGMT_REVISION	0
+
+static const u16 mgmt_commands[] = {
+	MGMT_OP_READ_INDEX_LIST,
+	MGMT_OP_READ_INFO,
+	MGMT_OP_SET_POWERED,
+	MGMT_OP_SET_DISCOVERABLE,
+	MGMT_OP_SET_CONNECTABLE,
+	MGMT_OP_SET_FAST_CONNECTABLE,
+	MGMT_OP_SET_PAIRABLE,
+	MGMT_OP_SET_LINK_SECURITY,
+	MGMT_OP_SET_SSP,
+	MGMT_OP_SET_HS,
+	MGMT_OP_SET_LE,
+	MGMT_OP_SET_DEV_CLASS,
+	MGMT_OP_SET_LOCAL_NAME,
+	MGMT_OP_ADD_UUID,
+	MGMT_OP_REMOVE_UUID,
+	MGMT_OP_LOAD_LINK_KEYS,
+	MGMT_OP_LOAD_LONG_TERM_KEYS,
+	MGMT_OP_DISCONNECT,
+	MGMT_OP_GET_CONNECTIONS,
+	MGMT_OP_PIN_CODE_REPLY,
+	MGMT_OP_PIN_CODE_NEG_REPLY,
+	MGMT_OP_SET_IO_CAPABILITY,
+	MGMT_OP_PAIR_DEVICE,
+	MGMT_OP_CANCEL_PAIR_DEVICE,
+	MGMT_OP_UNPAIR_DEVICE,
+	MGMT_OP_USER_CONFIRM_REPLY,
+	MGMT_OP_USER_CONFIRM_NEG_REPLY,
+	MGMT_OP_USER_PASSKEY_REPLY,
+	MGMT_OP_USER_PASSKEY_NEG_REPLY,
+	MGMT_OP_READ_LOCAL_OOB_DATA,
+	MGMT_OP_ADD_REMOTE_OOB_DATA,
+	MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+	MGMT_OP_START_DISCOVERY,
+	MGMT_OP_STOP_DISCOVERY,
+	MGMT_OP_CONFIRM_NAME,
+	MGMT_OP_BLOCK_DEVICE,
+	MGMT_OP_UNBLOCK_DEVICE,
+};
+
+static const u16 mgmt_events[] = {
+	MGMT_EV_CONTROLLER_ERROR,
+	MGMT_EV_INDEX_ADDED,
+	MGMT_EV_INDEX_REMOVED,
+	MGMT_EV_NEW_SETTINGS,
+	MGMT_EV_CLASS_OF_DEV_CHANGED,
+	MGMT_EV_LOCAL_NAME_CHANGED,
+	MGMT_EV_NEW_LINK_KEY,
+	MGMT_EV_NEW_LONG_TERM_KEY,
+	MGMT_EV_DEVICE_CONNECTED,
+	MGMT_EV_DEVICE_DISCONNECTED,
+	MGMT_EV_CONNECT_FAILED,
+	MGMT_EV_PIN_CODE_REQUEST,
+	MGMT_EV_USER_CONFIRM_REQUEST,
+	MGMT_EV_USER_PASSKEY_REQUEST,
+	MGMT_EV_AUTH_FAILED,
+	MGMT_EV_DEVICE_FOUND,
+	MGMT_EV_DISCOVERING,
+	MGMT_EV_DEVICE_BLOCKED,
+	MGMT_EV_DEVICE_UNBLOCKED,
+	MGMT_EV_DEVICE_UNPAIRED,
+};
+
+/*
+ * These LE scan and inquiry parameters were chosen according to LE General
+ * Discovery Procedure specification.
+ */
+#define LE_SCAN_TYPE			0x01
+#define LE_SCAN_WIN			0x12
+#define LE_SCAN_INT			0x12
+#define LE_SCAN_TIMEOUT_LE_ONLY		10240	/* TGAP(gen_disc_scan_min) */
+#define LE_SCAN_TIMEOUT_BREDR_LE	5120	/* TGAP(100)/2 */
+
+#define INQUIRY_LEN_BREDR		0x08	/* TGAP(100) */
+#define INQUIRY_LEN_BREDR_LE		0x04	/* TGAP(100)/2 */
+
+#define CACHE_TIMEOUT	msecs_to_jiffies(2 * 1000)
 
-#define SCAN_IDLE	0x00
-#define SCAN_LE		0x01
-#define SCAN_BR		0x02
+#define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
+				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
 
 struct pending_cmd {
 	struct list_head list;
-	__u16 opcode;
+	u16 opcode;
 	int index;
 	void *param;
 	struct sock *sk;
 	void *user_data;
 };
 
-struct mgmt_pending_free_work {
-	struct work_struct work;
-	struct sock *sk;
+/* HCI to MGMT error code conversion table */
+static u8 mgmt_status_table[] = {
+	MGMT_STATUS_SUCCESS,
+	MGMT_STATUS_UNKNOWN_COMMAND,	/* Unknown Command */
+	MGMT_STATUS_NOT_CONNECTED,	/* No Connection */
+	MGMT_STATUS_FAILED,		/* Hardware Failure */
+	MGMT_STATUS_CONNECT_FAILED,	/* Page Timeout */
+	MGMT_STATUS_AUTH_FAILED,	/* Authentication Failed */
+	MGMT_STATUS_NOT_PAIRED,		/* PIN or Key Missing */
+	MGMT_STATUS_NO_RESOURCES,	/* Memory Full */
+	MGMT_STATUS_TIMEOUT,		/* Connection Timeout */
+	MGMT_STATUS_NO_RESOURCES,	/* Max Number of Connections */
+	MGMT_STATUS_NO_RESOURCES,	/* Max Number of SCO Connections */
+	MGMT_STATUS_ALREADY_CONNECTED,	/* ACL Connection Exists */
+	MGMT_STATUS_BUSY,		/* Command Disallowed */
+	MGMT_STATUS_NO_RESOURCES,	/* Rejected Limited Resources */
+	MGMT_STATUS_REJECTED,		/* Rejected Security */
+	MGMT_STATUS_REJECTED,		/* Rejected Personal */
+	MGMT_STATUS_TIMEOUT,		/* Host Timeout */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Feature */
+	MGMT_STATUS_INVALID_PARAMS,	/* Invalid Parameters */
+	MGMT_STATUS_DISCONNECTED,	/* OE User Ended Connection */
+	MGMT_STATUS_NO_RESOURCES,	/* OE Low Resources */
+	MGMT_STATUS_DISCONNECTED,	/* OE Power Off */
+	MGMT_STATUS_DISCONNECTED,	/* Connection Terminated */
+	MGMT_STATUS_BUSY,		/* Repeated Attempts */
+	MGMT_STATUS_REJECTED,		/* Pairing Not Allowed */
+	MGMT_STATUS_FAILED,		/* Unknown LMP PDU */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Remote Feature */
+	MGMT_STATUS_REJECTED,		/* SCO Offset Rejected */
+	MGMT_STATUS_REJECTED,		/* SCO Interval Rejected */
+	MGMT_STATUS_REJECTED,		/* Air Mode Rejected */
+	MGMT_STATUS_INVALID_PARAMS,	/* Invalid LMP Parameters */
+	MGMT_STATUS_FAILED,		/* Unspecified Error */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported LMP Parameter Value */
+	MGMT_STATUS_FAILED,		/* Role Change Not Allowed */
+	MGMT_STATUS_TIMEOUT,		/* LMP Response Timeout */
+	MGMT_STATUS_FAILED,		/* LMP Error Transaction Collision */
+	MGMT_STATUS_FAILED,		/* LMP PDU Not Allowed */
+	MGMT_STATUS_REJECTED,		/* Encryption Mode Not Accepted */
+	MGMT_STATUS_FAILED,		/* Unit Link Key Used */
+	MGMT_STATUS_NOT_SUPPORTED,	/* QoS Not Supported */
+	MGMT_STATUS_TIMEOUT,		/* Instant Passed */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Pairing Not Supported */
+	MGMT_STATUS_FAILED,		/* Transaction Collision */
+	MGMT_STATUS_INVALID_PARAMS,	/* Unacceptable Parameter */
+	MGMT_STATUS_REJECTED,		/* QoS Rejected */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Classification Not Supported */
+	MGMT_STATUS_REJECTED,		/* Insufficient Security */
+	MGMT_STATUS_INVALID_PARAMS,	/* Parameter Out Of Range */
+	MGMT_STATUS_BUSY,		/* Role Switch Pending */
+	MGMT_STATUS_FAILED,		/* Slot Violation */
+	MGMT_STATUS_FAILED,		/* Role Switch Failed */
+	MGMT_STATUS_INVALID_PARAMS,	/* EIR Too Large */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Simple Pairing Not Supported */
+	MGMT_STATUS_BUSY,		/* Host Busy Pairing */
+	MGMT_STATUS_REJECTED,		/* Rejected, No Suitable Channel */
+	MGMT_STATUS_BUSY,		/* Controller Busy */
+	MGMT_STATUS_INVALID_PARAMS,	/* Unsuitable Connection Interval */
+	MGMT_STATUS_TIMEOUT,		/* Directed Advertising Timeout */
+	MGMT_STATUS_AUTH_FAILED,	/* Terminated Due to MIC Failure */
+	MGMT_STATUS_CONNECT_FAILED,	/* Connection Establishment Failed */
+	MGMT_STATUS_CONNECT_FAILED,	/* MAC Connection Failed */
 };
 
-LIST_HEAD(cmd_list);
+static u8 mgmt_status(u8 hci_status)
+{
+	if (hci_status < ARRAY_SIZE(mgmt_status_table))
+		return mgmt_status_table[hci_status];
+
+	return MGMT_STATUS_FAILED;
+}
 
 static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_status *ev;
+	int err;
 
 	BT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);
 
@@ -79,18 +226,20 @@
 	ev->status = status;
 	put_unaligned_le16(cmd, &ev->opcode);
 
-	if (sock_queue_rcv_skb(sk, skb) < 0)
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0)
 		kfree_skb(skb);
 
-	return 0;
+	return err;
 }
 
-static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
-								size_t rp_len)
+static int cmd_complete(struct sock *sk, u16 index, u16 cmd, u8 status,
+			void *rp, size_t rp_len)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_complete *ev;
+	int err;
 
 	BT_DBG("sock %p", sk);
 
@@ -106,17 +255,20 @@
 
 	ev = (void *) skb_put(skb, sizeof(*ev) + rp_len);
 	put_unaligned_le16(cmd, &ev->opcode);
+	ev->status = status;
 
 	if (rp)
 		memcpy(ev->data, rp, rp_len);
 
-	if (sock_queue_rcv_skb(sk, skb) < 0)
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0)
 		kfree_skb(skb);
 
-	return 0;
+	return err;
 }
 
-static int read_version(struct sock *sk)
+static int read_version(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 data_len)
 {
 	struct mgmt_rp_read_version rp;
 
@@ -125,14 +277,50 @@
 	rp.version = MGMT_VERSION;
 	put_unaligned_le16(MGMT_REVISION, &rp.revision);
 
-	return cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, &rp,
-								sizeof(rp));
+	return cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0, &rp,
+			    sizeof(rp));
+}
+
+static int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 data_len)
+{
+	struct mgmt_rp_read_commands *rp;
+	u16 num_commands = ARRAY_SIZE(mgmt_commands);
+	u16 num_events = ARRAY_SIZE(mgmt_events);
+	u16 *opcode;
+	size_t rp_size;
+	int i, err;
+
+	BT_DBG("sock %p", sk);
+
+	rp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));
+
+	rp = kmalloc(rp_size, GFP_KERNEL);
+	if (!rp)
+		return -ENOMEM;
+
+	put_unaligned_le16(num_commands, &rp->num_commands);
+	put_unaligned_le16(num_events, &rp->num_events);
+
+	for (i = 0, opcode = rp->opcodes; i < num_commands; i++, opcode++)
+		put_unaligned_le16(mgmt_commands[i], opcode);
+
+	for (i = 0; i < num_events; i++, opcode++)
+		put_unaligned_le16(mgmt_events[i], opcode);
+
+	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0, rp,
+			   rp_size);
+	kfree(rp);
+
+	return err;
 }
 
-static int read_index_list(struct sock *sk)
+static int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 data_len)
 {
 	struct mgmt_rp_read_index_list *rp;
 	struct list_head *p;
+	struct hci_dev *d;
 	size_t rp_len;
 	u16 count;
 	int i, err;
@@ -143,9 +331,6 @@
 
 	count = 0;
 	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-		if (d->dev_type != HCI_BREDR)
-			continue;
 		count++;
 	}
 
@@ -156,268 +341,231 @@
 		return -ENOMEM;
 	}
 
-	put_unaligned_le16(0, &rp->num_controllers);
+	put_unaligned_le16(count, &rp->num_controllers);
 
 	i = 0;
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-
-		hci_del_off_timer(d);
-
-		if (d->dev_type != HCI_BREDR)
-			continue;
-
-		set_bit(HCI_MGMT, &d->flags);
-
-		if (test_bit(HCI_SETUP, &d->flags))
+	list_for_each_entry(d, &hci_dev_list, list) {
+		if (test_bit(HCI_SETUP, &d->dev_flags))
 			continue;
 
 		put_unaligned_le16(d->id, &rp->index[i++]);
-		put_unaligned_le16((u16)i, &rp->num_controllers);
 		BT_DBG("Added hci%u", d->id);
 	}
 
 	read_unlock(&hci_dev_list_lock);
 
-	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST, rp,
-									rp_len);
+	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST, 0, rp,
+			   rp_len);
 
 	kfree(rp);
 
 	return err;
 }
 
-static int read_controller_info(struct sock *sk, u16 index)
+static u32 get_supported_settings(struct hci_dev *hdev)
 {
-	struct mgmt_rp_read_info rp;
-	struct hci_dev *hdev;
+	u32 settings = 0;
 
-	BT_DBG("sock %p hci%u", sk, index);
+	settings |= MGMT_SETTING_POWERED;
+	settings |= MGMT_SETTING_CONNECTABLE;
+	settings |= MGMT_SETTING_FAST_CONNECTABLE;
+	settings |= MGMT_SETTING_DISCOVERABLE;
+	settings |= MGMT_SETTING_PAIRABLE;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_INFO, ENODEV);
+	if (hdev->features[6] & LMP_SIMPLE_PAIR)
+		settings |= MGMT_SETTING_SSP;
 
-	hci_del_off_timer(hdev);
-
-	hci_dev_lock_bh(hdev);
-
-	set_bit(HCI_MGMT, &hdev->flags);
-
-	memset(&rp, 0, sizeof(rp));
-
-	rp.type = hdev->dev_type;
+	if (!(hdev->features[4] & LMP_NO_BREDR)) {
+		settings |= MGMT_SETTING_BREDR;
+		settings |= MGMT_SETTING_LINK_SECURITY;
+	}
 
-	rp.powered = test_bit(HCI_UP, &hdev->flags);
-	rp.connectable = test_bit(HCI_PSCAN, &hdev->flags);
-	rp.discoverable = test_bit(HCI_ISCAN, &hdev->flags);
-	rp.pairable = test_bit(HCI_PSCAN, &hdev->flags);
-
-	if (test_bit(HCI_AUTH, &hdev->flags))
-		rp.sec_mode = 3;
-	else if (hdev->ssp_mode > 0)
-		rp.sec_mode = 4;
-	else
-		rp.sec_mode = 2;
+	if (enable_hs)
+		settings |= MGMT_SETTING_HS;
 
-	bacpy(&rp.bdaddr, &hdev->bdaddr);
-	memcpy(rp.features, hdev->features, 8);
-	memcpy(rp.dev_class, hdev->dev_class, 3);
-	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
-	rp.hci_ver = hdev->hci_ver;
-	put_unaligned_le16(hdev->hci_rev, &rp.hci_rev);
+	if (enable_le) {
+		if (hdev->features[4] & LMP_LE)
+			settings |= MGMT_SETTING_LE;
+	}
 
-	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
+	return settings;
+}
 
-	rp.le_white_list_size = hdev->le_white_list_size;
+static u32 get_current_settings(struct hci_dev *hdev)
+{
+	u32 settings = 0;
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (hdev_is_powered(hdev))
+		settings |= MGMT_SETTING_POWERED;
 
-	return cmd_complete(sk, index, MGMT_OP_READ_INFO, &rp, sizeof(rp));
-}
+	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_CONNECTABLE;
 
-static void mgmt_pending_free_worker(struct work_struct *work)
-{
-	struct mgmt_pending_free_work *free_work =
-		container_of(work, struct mgmt_pending_free_work, work);
+	if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_DISCOVERABLE;
 
-	BT_DBG("sk %p", free_work->sk);
+	if (test_bit(HCI_PAIRABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_PAIRABLE;
 
-	sock_put(free_work->sk);
-	kfree(free_work);
-}
+	if (!(hdev->features[4] & LMP_NO_BREDR))
+		settings |= MGMT_SETTING_BREDR;
 
-static void mgmt_pending_free(struct pending_cmd *cmd)
-{
-	struct mgmt_pending_free_work *free_work;
-	struct sock *sk = cmd->sk;
+	if (test_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_LE;
 
-	BT_DBG("opcode %d, sk %p", cmd->opcode, sk);
+	if (test_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+		settings |= MGMT_SETTING_LINK_SECURITY;
 
-	kfree(cmd->param);
-	kfree(cmd);
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_SSP;
 
-	free_work = kzalloc(sizeof(*free_work), GFP_ATOMIC);
-	if (free_work) {
-		INIT_WORK(&free_work->work, mgmt_pending_free_worker);
-		free_work->sk = sk;
+	if (test_bit(HCI_HS_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_HS;
 
-		if (!schedule_work(&free_work->work))
-			kfree(free_work);
-	}
+	return settings;
 }
 
-static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
-						u16 index, void *data, u16 len)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG("%d", opcode);
+#define PNP_INFO_SVCLASS_ID		0x1200
 
-	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
-	if (!cmd)
-		return NULL;
+static u8 bluetooth_base_uuid[] = {
+			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
+			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
 
-	cmd->opcode = opcode;
-	cmd->index = index;
+static u16 get_uuid16(u8 *uuid128)
+{
+	u32 val;
+	int i;
 
-	cmd->param = kmalloc(len, GFP_ATOMIC);
-	if (!cmd->param) {
-		kfree(cmd);
-		return NULL;
+	for (i = 0; i < 12; i++) {
+		if (bluetooth_base_uuid[i] != uuid128[i])
+			return 0;
 	}
 
-	if (data)
-		memcpy(cmd->param, data, len);
-
-	cmd->sk = sk;
-	sock_hold(sk);
+	memcpy(&val, &uuid128[12], 4);
 
-	list_add(&cmd->list, &cmd_list);
+	val = le32_to_cpu(val);
+	if (val > 0xffff)
+		return 0;
 
-	return cmd;
+	return (u16) val;
 }
 
-static void mgmt_pending_foreach(u16 opcode, int index,
-				void (*cb)(struct pending_cmd *cmd, void *data),
-				void *data)
+static void create_eir(struct hci_dev *hdev, u8 *data)
 {
-	struct list_head *p, *n;
-
-	BT_DBG(" %d", opcode);
+	u8 *ptr = data;
+	u16 eir_len = 0;
+	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
+	int i, truncated = 0;
+	struct bt_uuid *uuid;
+	size_t name_len;
 
-	list_for_each_safe(p, n, &cmd_list) {
-		struct pending_cmd *cmd;
+	name_len = strlen(hdev->dev_name);
 
-		cmd = list_entry(p, struct pending_cmd, list);
+	if (name_len > 0) {
+		/* EIR Data type */
+		if (name_len > 48) {
+			name_len = 48;
+			ptr[1] = EIR_NAME_SHORT;
+		} else
+			ptr[1] = EIR_NAME_COMPLETE;
 
-		if (opcode > 0 && cmd->opcode != opcode)
-			continue;
+		/* EIR Data length */
+		ptr[0] = name_len + 1;
 
-		if (index >= 0 && cmd->index != index)
-			continue;
+		memcpy(ptr + 2, hdev->dev_name, name_len);
 
-		cb(cmd, data);
+		eir_len += (name_len + 2);
+		ptr += (name_len + 2);
 	}
-}
-
-static struct pending_cmd *mgmt_pending_find(u16 opcode, int index)
-{
-	struct list_head *p;
 
-	BT_DBG(" %d", opcode);
+	memset(uuid16_list, 0, sizeof(uuid16_list));
 
-	list_for_each(p, &cmd_list) {
-		struct pending_cmd *cmd;
+	/* Group all UUID16 types */
+	list_for_each_entry(uuid, &hdev->uuids, list) {
+		u16 uuid16;
 
-		cmd = list_entry(p, struct pending_cmd, list);
+		uuid16 = get_uuid16(uuid->uuid);
+		if (uuid16 == 0)
+			return;
 
-		if (cmd->opcode != opcode)
+		if (uuid16 < 0x1100)
 			continue;
 
-		if (index >= 0 && cmd->index != index)
+		if (uuid16 == PNP_INFO_SVCLASS_ID)
 			continue;
 
-		return cmd;
-	}
+		/* Stop if not enough space to put next UUID */
+		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
+			truncated = 1;
+			break;
+		}
 
-	return NULL;
-}
+		/* Check for duplicates */
+		for (i = 0; uuid16_list[i] != 0; i++)
+			if (uuid16_list[i] == uuid16)
+				break;
 
-static void mgmt_pending_remove(struct pending_cmd *cmd)
-{
-	BT_DBG(" %d", cmd->opcode);
+		if (uuid16_list[i] == 0) {
+			uuid16_list[i] = uuid16;
+			eir_len += sizeof(u16);
+		}
+	}
 
-	list_del(&cmd->list);
-	mgmt_pending_free(cmd);
-}
+	if (uuid16_list[0] != 0) {
+		u8 *length = ptr;
 
-static int set_powered(struct sock *sk, u16 index, unsigned char *data, u16 len)
-{
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	int err, up;
+		/* EIR Data type */
+		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
 
-	cp = (void *) data;
+		ptr += 2;
+		eir_len += 2;
 
-	BT_DBG("request for hci%u", index);
+		for (i = 0; uuid16_list[i] != 0; i++) {
+			*ptr++ = (uuid16_list[i] & 0x00ff);
+			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
+		}
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED, EINVAL);
+		/* EIR Data length */
+		*length = (i * sizeof(u16)) + 1;
+	}
+}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED, ENODEV);
+static int update_eir(struct hci_dev *hdev)
+{
+	struct hci_cp_write_eir cp;
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev))
+		return 0;
 
-	up = test_bit(HCI_UP, &hdev->flags);
-	if ((cp->val && up) || (!cp->val && !up)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EALREADY);
-		goto failed;
-	}
+	if (!(hdev->features[6] & LMP_EXT_INQ))
+		return 0;
 
-	if (mgmt_pending_find(MGMT_OP_SET_POWERED, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EBUSY);
-		goto failed;
-	}
+	if (!test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		return 0;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, index, data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
+	if (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		return 0;
 
-	hci_dev_unlock_bh(hdev);
+	memset(&cp, 0, sizeof(cp));
 
-	if (cp->val)
-		queue_work(hdev->workqueue, &hdev->power_on);
-	else
-		queue_work(hdev->workqueue, &hdev->power_off);
+	create_eir(hdev, cp.data);
 
-	err = 0;
-	hci_dev_put(hdev);
+	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
+		return 0;
 
-	return err;
+	memcpy(hdev->eir, cp.data, sizeof(cp.data));
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-	return err;
+	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
 }
 
 static u8 get_service_classes(struct hci_dev *hdev)
 {
-	struct list_head *p;
+	struct bt_uuid *uuid;
 	u8 val = 0;
 
-	list_for_each(p, &hdev->uuids) {
-		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
-
+	list_for_each_entry(uuid, &hdev->uuids, list)
 		val |= uuid->svc_hint;
-	}
 
 	return val;
 }
@@ -425,11 +573,14 @@
 static int update_class(struct hci_dev *hdev)
 {
 	u8 cod[3];
-	int err = 0;
+	int err;
 
 	BT_DBG("%s", hdev->name);
 
-	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
+	if (!hdev_is_powered(hdev))
+		return 0;
+
+	if (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
 		return 0;
 
 	cod[0] = hdev->minor_class;
@@ -439,139 +590,317 @@
 	if (memcmp(cod, hdev->dev_class, 3) == 0)
 		return 0;
 
-	err =  hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
-
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
 	if (err == 0)
-		memcpy(hdev->dev_class, cod, 3);
+		set_bit(HCI_PENDING_CLASS, &hdev->dev_flags);
 
 	return err;
 }
 
-static int set_limited_discoverable(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+static void service_cache_off(struct work_struct *work)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	struct hci_cp_write_current_iac_lap dcp;
-	int update_cod;
-	int err = 0;
-	/* General Inquiry LAP: 0x9E8B33, Limited Inquiry LAP: 0x9E8B00 */
-	u8 lap[] = { 0x33, 0x8b, 0x9e, 0x00, 0x8b, 0x9e };
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    service_cache.work);
 
-	cp = (void *) data;
+	if (!test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		return;
 
-	BT_DBG("hci%u discoverable: %d", index, cp->val);
+	hci_dev_lock(hdev);
 
-	if (!cp || len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									EINVAL);
+	update_eir(hdev);
+	update_class(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									ENODEV);
+	hci_dev_unlock(hdev);
+}
 
-	hci_dev_lock_bh(hdev);
+static void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)
+{
+	if (test_and_set_bit(HCI_MGMT, &hdev->dev_flags))
+		return;
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-								ENETDOWN);
-		goto failed;
-	}
+	INIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);
 
-	if (mgmt_pending_find(MGMT_OP_SET_LIMIT_DISCOVERABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									EBUSY);
-		goto failed;
-	}
+	/* Non-mgmt controlled devices get this bit set
+	 * implicitly so that pairing works for them, however
+	 * for mgmt we require user-space to explicitly enable
+	 * it
+	 */
+	clear_bit(HCI_PAIRABLE, &hdev->dev_flags);
+}
 
-	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
-					test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-								EALREADY);
-		goto failed;
-	}
+static int read_controller_info(struct sock *sk, struct hci_dev *hdev,
+				void *data, u16 data_len)
+{
+	struct mgmt_rp_read_info rp;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LIMIT_DISCOVERABLE, index, data,
-									len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
+	BT_DBG("sock %p %s", sk, hdev->name);
 
-	memset(&dcp, 0, sizeof(dcp));
-	dcp.num_current_iac = cp->val ? 2 : 1;
-	memcpy(&dcp.lap, lap, dcp.num_current_iac * 3);
-	update_cod = 1;
+	hci_dev_lock(hdev);
 
-	if (cp->val) {
-		if (hdev->major_class & MGMT_MAJOR_CLASS_LIMITED)
-			update_cod = 0;
-		hdev->major_class |= MGMT_MAJOR_CLASS_LIMITED;
-	} else {
-		if (!(hdev->major_class & MGMT_MAJOR_CLASS_LIMITED))
-			update_cod = 0;
-		hdev->major_class &= ~MGMT_MAJOR_CLASS_LIMITED;
-	}
+	memset(&rp, 0, sizeof(rp));
 
-	if (update_cod)
-		err = update_class(hdev);
+	bacpy(&rp.bdaddr, &hdev->bdaddr);
 
-	if (err >= 0)
-		err = hci_send_cmd(hdev, HCI_OP_WRITE_CURRENT_IAC_LAP,
-							sizeof(dcp), &dcp);
+	rp.version = hdev->hci_ver;
 
-	if (err < 0)
-		mgmt_pending_remove(cmd);
+	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	rp.supported_settings = cpu_to_le32(get_supported_settings(hdev));
+	rp.current_settings = cpu_to_le32(get_current_settings(hdev));
 
-	return err;
-}
+	memcpy(rp.dev_class, hdev->dev_class, 3);
+
+	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
+	memcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));
+
+	hci_dev_unlock(hdev);
+
+	return cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,
+			    sizeof(rp));
+}
+
+static void mgmt_pending_free(struct pending_cmd *cmd)
+{
+	sock_put(cmd->sk);
+	kfree(cmd->param);
+	kfree(cmd);
+}
 
-static int set_discoverable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
+					    struct hci_dev *hdev, void *data,
+					    u16 len)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
+
+	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
+	if (!cmd)
+		return NULL;
+
+	cmd->opcode = opcode;
+	cmd->index = hdev->id;
+
+	cmd->param = kmalloc(len, GFP_ATOMIC);
+	if (!cmd->param) {
+		kfree(cmd);
+		return NULL;
+	}
+
+	if (data)
+		memcpy(cmd->param, data, len);
+
+	cmd->sk = sk;
+	sock_hold(sk);
+
+	list_add(&cmd->list, &hdev->mgmt_pending);
+
+	return cmd;
+}
+
+static void mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,
+				 void (*cb)(struct pending_cmd *cmd, void *data),
+				 void *data)
+{
+	struct list_head *p, *n;
+
+	list_for_each_safe(p, n, &hdev->mgmt_pending) {
+		struct pending_cmd *cmd;
+
+		cmd = list_entry(p, struct pending_cmd, list);
+
+		if (opcode > 0 && cmd->opcode != opcode)
+			continue;
+
+		cb(cmd, data);
+	}
+}
+
+static struct pending_cmd *mgmt_pending_find(u16 opcode, struct hci_dev *hdev)
+{
+	struct pending_cmd *cmd;
+
+	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
+		if (cmd->opcode == opcode)
+			return cmd;
+	}
+
+	return NULL;
+}
+
+static void mgmt_pending_remove(struct pending_cmd *cmd)
+{
+	list_del(&cmd->list);
+	mgmt_pending_free(cmd);
+}
+
+static int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)
+{
+	__le32 settings = cpu_to_le32(get_current_settings(hdev));
+
+	return cmd_complete(sk, hdev->id, opcode, 0, &settings,
+			    sizeof(settings));
+}
+
+static int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,
+		       u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	int err;
+
+	BT_DBG("request for %s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags)) {
+		cancel_delayed_work(&hdev->power_off);
+
+		if (cp->val) {
+			err = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);
+			mgmt_powered(hdev, 1);
+			goto failed;
+		}
+	}
+
+	if (!!cp->val == hdev_is_powered(hdev)) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);
+		goto failed;
+	}
+
+	if (mgmt_pending_find(MGMT_OP_SET_POWERED, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	if (cp->val)
+		schedule_work(&hdev->power_on);
+	else
+		schedule_work(&hdev->power_off.work);
+
+	err = 0;
+
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
+
+static int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 data_len,
+		      struct sock *skip_sk)
+{
+	struct sk_buff *skb;
+	struct mgmt_hdr *hdr;
+
+	skb = alloc_skb(sizeof(*hdr) + data_len, GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+
+	hdr = (void *) skb_put(skb, sizeof(*hdr));
+	hdr->opcode = cpu_to_le16(event);
+	if (hdev)
+		hdr->index = cpu_to_le16(hdev->id);
+	else
+		hdr->index = cpu_to_le16(MGMT_INDEX_NONE);
+	hdr->len = cpu_to_le16(data_len);
+
+	if (data)
+		memcpy(skb_put(skb, data_len), data, data_len);
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	hci_send_to_control(skb, skip_sk);
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static int new_settings(struct hci_dev *hdev, struct sock *skip)
+{
+	__le32 ev;
+
+	ev = cpu_to_le32(get_current_settings(hdev));
+
+	return mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev), skip);
+}
+
+static int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,
+			    u16 len)
+{
+	struct mgmt_cp_set_discoverable *cp = data;
+	struct pending_cmd *cmd;
+	u16 timeout;
 	u8 scan;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	timeout = get_unaligned_le16(&cp->timeout);
+	if (!cp->val && timeout > 0)
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				  MGMT_STATUS_INVALID_PARAMS);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENODEV);
+	if (!hdev_is_powered(hdev) && timeout > 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto failed;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENETDOWN);
+	if (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_REJECTED);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EBUSY);
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
+
+		if (!!cp->val != test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {
+			change_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+			changed = true;
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);
+		if (err < 0)
+			goto failed;
+
+		if (changed)
+			err = new_settings(hdev, sk);
+
 		goto failed;
 	}
 
-	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
-					test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EALREADY);
+	if (!!cp->val == test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {
+		if (hdev->discov_timeout > 0) {
+			cancel_delayed_work(&hdev->discov_off);
+			hdev->discov_timeout = 0;
+		}
+
+		if (cp->val && timeout > 0) {
+			hdev->discov_timeout = timeout;
+			queue_delayed_work(hdev->workqueue, &hdev->discov_off,
+				msecs_to_jiffies(hdev->discov_timeout * 1000));
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -581,318 +910,349 @@
 
 	if (cp->val)
 		scan |= SCAN_INQUIRY;
+	else
+		cancel_delayed_work(&hdev->discov_off);
 
 	err = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (cp->val)
+		hdev->discov_timeout = timeout;
 
+failed:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_connectable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 len)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
+	struct mgmt_mode *cp = data;
 	struct pending_cmd *cmd;
 	u8 scan;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EINVAL);
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENODEV);
+		if (!!cp->val != test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
 
-	hci_dev_lock_bh(hdev);
+		if (cp->val) {
+			set_bit(HCI_CONNECTABLE, &hdev->dev_flags);
+		} else {
+			clear_bit(HCI_CONNECTABLE, &hdev->dev_flags);
+			clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);
+		if (err < 0)
+			goto failed;
+
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENETDOWN);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EBUSY);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	if (cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EALREADY);
+	if (!!cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	if (cp->val)
+	if (cp->val) {
 		scan = SCAN_PAGE;
-	else
+	} else {
 		scan = 0;
 
+		if (test_bit(HCI_ISCAN, &hdev->flags) &&
+						hdev->discov_timeout > 0)
+			cancel_delayed_work(&hdev->discov_off);
+	}
+
 	err = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int mgmt_event(u16 event, u16 index, void *data, u16 data_len,
-							struct sock *skip_sk)
+static int set_pairable(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
 {
-	struct sk_buff *skb;
-	struct mgmt_hdr *hdr;
-
-	BT_DBG("hci%d %d", index, event);
+	struct mgmt_mode *cp = data;
+	int err;
 
-	skb = alloc_skb(sizeof(*hdr) + data_len, GFP_ATOMIC);
-	if (!skb)
-		return -ENOMEM;
+	BT_DBG("request for %s", hdev->name);
 
-	bt_cb(skb)->channel = HCI_CHANNEL_CONTROL;
+	hci_dev_lock(hdev);
 
-	hdr = (void *) skb_put(skb, sizeof(*hdr));
-	hdr->opcode = cpu_to_le16(event);
-	hdr->index = cpu_to_le16(index);
-	hdr->len = cpu_to_le16(data_len);
+	if (cp->val)
+		set_bit(HCI_PAIRABLE, &hdev->dev_flags);
+	else
+		clear_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
-	if (data)
-		memcpy(skb_put(skb, data_len), data, data_len);
+	err = send_settings_rsp(sk, MGMT_OP_SET_PAIRABLE, hdev);
+	if (err < 0)
+		goto failed;
 
-	hci_send_to_sock(NULL, skb, skip_sk);
-	kfree_skb(skb);
+	err = new_settings(hdev, sk);
 
-	return 0;
+failed:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int send_mode_rsp(struct sock *sk, u16 opcode, u16 index, u8 val)
+static int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,
+			     u16 len)
 {
-	struct mgmt_mode rp;
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	u8 val;
+	int err;
 
-	rp.val = val;
+	BT_DBG("request for %s", hdev->name);
 
-	return cmd_complete(sk, index, opcode, &rp, sizeof(rp));
-}
+	hci_dev_lock(hdev);
 
-static int set_pairable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct mgmt_mode *cp, ev;
-	struct hci_dev *hdev;
-	int err;
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	cp = (void *) data;
+		if (!!cp->val != test_bit(HCI_LINK_SECURITY,
+							&hdev->dev_flags)) {
+			change_bit(HCI_LINK_SECURITY, &hdev->dev_flags);
+			changed = true;
+		}
 
-	BT_DBG("request for hci%u", index);
+		err = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);
+		if (err < 0)
+			goto failed;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, EINVAL);
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, ENODEV);
+		goto failed;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-	if (cp->val)
-		set_bit(HCI_PAIRABLE, &hdev->flags);
-	else
-		clear_bit(HCI_PAIRABLE, &hdev->flags);
+	val = !!cp->val;
 
-	err = send_mode_rsp(sk, MGMT_OP_SET_PAIRABLE, index, cp->val);
-	if (err < 0)
+	if (test_bit(HCI_AUTH, &hdev->flags) == val) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);
 		goto failed;
+	}
 
-	ev.val = cp->val;
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
 
-	err = mgmt_event(MGMT_EV_PAIRABLE, index, &ev, sizeof(ev), sk);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto failed;
+	}
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-#define EIR_FLAGS		0x01 /* flags */
-#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
-#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
-#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
-#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
-#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
-#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
-#define EIR_NAME_SHORT		0x08 /* shortened local name */
-#define EIR_NAME_COMPLETE	0x09 /* complete local name */
-#define EIR_TX_POWER		0x0A /* transmit power level */
-#define EIR_DEVICE_ID		0x10 /* device ID */
-
-#define PNP_INFO_SVCLASS_ID		0x1200
+static int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	u8 val;
+	int err;
 
-static u8 bluetooth_base_uuid[] = {
-			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
-			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
+	BT_DBG("request for %s", hdev->name);
 
-static u16 get_uuid16(u8 *uuid128)
-{
-	u32 val;
-	int i;
+	hci_dev_lock(hdev);
 
-	for (i = 0; i < 12; i++) {
-		if (bluetooth_base_uuid[i] != uuid128[i])
-			return 0;
+	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto failed;
 	}
 
-	memcpy(&val, &uuid128[12], 4);
+	val = !!cp->val;
 
-	val = le32_to_cpu(val);
-	if (val > 0xffff)
-		return 0;
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	return (u16) val;
-}
+		if (val != test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			change_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+			changed = true;
+		}
 
-static void create_eir(struct hci_dev *hdev, u8 *data)
-{
-	u8 *ptr = data;
-	u16 eir_len = 0;
-	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
-	int i, truncated = 0;
-	struct list_head *p;
-	size_t name_len;
+		err = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);
+		if (err < 0)
+			goto failed;
 
-	name_len = strnlen(hdev->dev_name, HCI_MAX_EIR_LENGTH);
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (name_len > 0) {
-		/* EIR Data type */
-		if (name_len > 48) {
-			name_len = 48;
-			ptr[1] = EIR_NAME_SHORT;
-		} else
-			ptr[1] = EIR_NAME_COMPLETE;
+		goto failed;
+	}
 
-		/* EIR Data length */
-		ptr[0] = name_len + 1;
+	if (mgmt_pending_find(MGMT_OP_SET_SSP, hdev)) {
+	     err = cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,
+			      MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-		memcpy(ptr + 2, hdev->dev_name, name_len);
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) == val) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);
+		goto failed;
+	}
 
-		eir_len += (name_len + 2);
-		ptr += (name_len + 2);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
 	}
 
-	memset(uuid16_list, 0, sizeof(uuid16_list));
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, sizeof(val), &val);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto failed;
+	}
 
-	/* Group all UUID16 types */
-	list_for_each(p, &hdev->uuids) {
-		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
-		u16 uuid16;
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
 
-		uuid16 = get_uuid16(uuid->uuid);
-		if (uuid16 == 0)
-			return;
+static int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
 
-		if (uuid16 < 0x1100)
-			continue;
+	BT_DBG("request for %s", hdev->name);
 
-		if (uuid16 == PNP_INFO_SVCLASS_ID)
-			continue;
+	if (!enable_hs)
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_HS,
+				  MGMT_STATUS_NOT_SUPPORTED);
 
-		/* Stop if not enough space to put next UUID */
-		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
-			truncated = 1;
-			break;
-		}
+	if (cp->val)
+		set_bit(HCI_HS_ENABLED, &hdev->dev_flags);
+	else
+		clear_bit(HCI_HS_ENABLED, &hdev->dev_flags);
 
-		/* Check for duplicates */
-		for (i = 0; uuid16_list[i] != 0; i++)
-			if (uuid16_list[i] == uuid16)
-				break;
+	return send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);
+}
 
-		if (uuid16_list[i] == 0) {
-			uuid16_list[i] = uuid16;
-			eir_len += sizeof(u16);
-		}
-	}
+static int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct hci_cp_write_le_host_supported hci_cp;
+	struct pending_cmd *cmd;
+	int err;
+	u8 val, enabled;
 
-	if (uuid16_list[0] != 0) {
-		u8 *length = ptr;
+	BT_DBG("request for %s", hdev->name);
 
-		/* EIR Data type */
-		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
+	hci_dev_lock(hdev);
 
-		ptr += 2;
-		eir_len += 2;
+	if (!enable_le || !(hdev->features[4] & LMP_LE)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LE,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto unlock;
+	}
 
-		for (i = 0; uuid16_list[i] != 0; i++) {
-			*ptr++ = (uuid16_list[i] & 0x00ff);
-			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
-		}
+	val = !!cp->val;
+	enabled = !!(hdev->host_features[0] & LMP_HOST_LE);
 
-		/* EIR Data length */
-		*length = (i * sizeof(u16)) + 1;
-	}
-}
+	if (!hdev_is_powered(hdev) || val == enabled) {
+		bool changed = false;
 
-static int update_eir(struct hci_dev *hdev)
-{
-	struct hci_cp_write_eir cp;
+		if (val != test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+			change_bit(HCI_LE_ENABLED, &hdev->dev_flags);
+			changed = true;
+		}
 
-	if (!(hdev->features[6] & LMP_EXT_INQ))
-		return 0;
+		err = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);
+		if (err < 0)
+			goto unlock;
 
-	if (hdev->ssp_mode == 0)
-		return 0;
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		return 0;
+		goto unlock;
+	}
 
-	memset(&cp, 0, sizeof(cp));
+	if (mgmt_pending_find(MGMT_OP_SET_LE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LE,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	create_eir(hdev, cp.data);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
-	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
-		return 0;
+	memset(&hci_cp, 0, sizeof(hci_cp));
 
-	memcpy(hdev->eir, cp.data, sizeof(cp.data));
+	if (val) {
+		hci_cp.le = val;
+		hci_cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+	}
 
-	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(hci_cp),
+			   &hci_cp);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto unlock;
+	}
+
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int add_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
 {
-	struct mgmt_cp_add_uuid *cp;
-	struct hci_dev *hdev;
+	struct mgmt_cp_add_uuid *cp = data;
+	struct pending_cmd *cmd;
 	struct bt_uuid *uuid;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
 	uuid = kmalloc(sizeof(*uuid), GFP_ATOMIC);
 	if (!uuid) {
@@ -905,51 +1265,73 @@
 
 	list_add(&uuid->list, &hdev->uuids);
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
+	err = update_class(hdev);
+	if (err < 0)
+		goto failed;
 
-		err = update_class(hdev);
-		if (err < 0)
-			goto failed;
+	err = update_eir(hdev);
+	if (err < 0)
+		goto failed;
 
-		err = update_eir(hdev);
-		if (err < 0)
-			goto failed;
-	} else
-		err = 0;
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_UUID, 0,
+				   hdev->dev_class, 3);
+		goto failed;
+	}
 
-	err = cmd_complete(sk, index, MGMT_OP_ADD_UUID, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_ADD_UUID, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int remove_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static bool enable_service_cache(struct hci_dev *hdev)
+{
+	if (!hdev_is_powered(hdev))
+		return false;
+
+	if (!test_and_set_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {
+		schedule_delayed_work(&hdev->service_cache, CACHE_TIMEOUT);
+		return true;
+	}
+
+	return false;
+}
+
+static int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,
+								u16 len)
 {
+	struct mgmt_cp_remove_uuid *cp = data;
+	struct pending_cmd *cmd;
 	struct list_head *p, *n;
-	struct mgmt_cp_remove_uuid *cp;
-	struct hci_dev *hdev;
 	u8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	int err, found;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
 	if (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {
 		err = hci_uuids_clear(hdev);
-		goto unlock;
+
+		if (enable_service_cache(hdev)) {
+			err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+					   0, hdev->dev_class, 3);
+			goto unlock;
+		}
+
+		goto update_class;
 	}
 
 	found = 0;
@@ -965,232 +1347,222 @@
 	}
 
 	if (found == 0) {
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENOENT);
+		err = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+				 MGMT_STATUS_INVALID_PARAMS);
 		goto unlock;
 	}
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		err = update_class(hdev);
-		if (err < 0)
-			goto unlock;
-
-		err = update_eir(hdev);
-		if (err < 0)
-			goto unlock;
-	} else
-		err = 0;
-
-	err = cmd_complete(sk, index, MGMT_OP_REMOVE_UUID, NULL, 0);
-
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int set_dev_class(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_dev_class *cp;
-	int err;
-
-	cp = (void *) data;
-
-	BT_DBG("request for hci%u", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+update_class:
+	err = update_class(hdev);
+	if (err < 0)
+		goto unlock;
 
-	hdev->major_class &= ~MGMT_MAJOR_CLASS_MASK;
-	hdev->major_class |= cp->major & MGMT_MAJOR_CLASS_MASK;
-	hdev->minor_class = cp->minor;
+	err = update_eir(hdev);
+	if (err < 0)
+		goto unlock;
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		err = update_class(hdev);
-		if (err == 0)
-			err = cmd_complete(sk, index,
-		MGMT_OP_SET_DEV_CLASS, hdev->dev_class, sizeof(u8)*3);
-	} else
-		err = cmd_complete(sk, index, MGMT_OP_SET_DEV_CLASS, NULL, 0);
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_service_cache(struct sock *sk, u16 index,  unsigned char *data,
-									u16 len)
+static int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_service_cache *cp;
+	struct mgmt_cp_set_dev_class *cp = data;
+	struct pending_cmd *cmd;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, ENODEV);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	hdev->major_class = cp->major;
+	hdev->minor_class = cp->minor;
 
-	BT_DBG("hci%u enable %d", index, cp->enable);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	if (cp->enable) {
-		set_bit(HCI_SERVICE_CACHE, &hdev->flags);
-		err = 0;
-	} else {
-		clear_bit(HCI_SERVICE_CACHE, &hdev->flags);
-		if (test_bit(HCI_UP, &hdev->flags)) {
-			err = update_class(hdev);
-			if (err == 0)
-				err = update_eir(hdev);
-		} else
-			err = 0;
+	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {
+		hci_dev_unlock(hdev);
+		cancel_delayed_work_sync(&hdev->service_cache);
+		hci_dev_lock(hdev);
+		update_eir(hdev);
 	}
 
-	if (err == 0)
-		err = cmd_complete(sk, index, MGMT_OP_SET_SERVICE_CACHE, NULL,
-									0);
+	err = update_class(hdev);
+	if (err < 0)
+		goto unlock;
+
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int load_keys(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,
+								u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_load_keys *cp;
+	struct mgmt_cp_load_link_keys *cp = data;
 	u16 key_count, expected_len;
-	int i, err;
-
-	cp = (void *) data;
-
-	if (len < sizeof(*cp))
-		return -EINVAL;
+	int i;
 
 	key_count = get_unaligned_le16(&cp->key_count);
 
-	expected_len = sizeof(*cp) + key_count * sizeof(struct mgmt_key_info);
-	if (expected_len > len) {
-		BT_ERR("load_keys: expected at least %u bytes, got %u bytes",
-							expected_len, len);
-		return -EINVAL;
+	expected_len = sizeof(*cp) + key_count *
+					sizeof(struct mgmt_link_key_info);
+	if (expected_len != len) {
+		BT_ERR("load_link_keys: expected %u bytes, got %u bytes",
+							len, expected_len);
+		return cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,
+				  MGMT_STATUS_INVALID_PARAMS);
 	}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LOAD_KEYS, ENODEV);
-
-	BT_DBG("hci%u debug_keys %u key_count %u", index, cp->debug_keys,
+	BT_DBG("%s debug_keys %u key_count %u", hdev->name, cp->debug_keys,
 								key_count);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	hci_link_keys_clear(hdev);
 
-	set_bit(HCI_LINK_KEYS, &hdev->flags);
+	set_bit(HCI_LINK_KEYS, &hdev->dev_flags);
 
 	if (cp->debug_keys)
-		set_bit(HCI_DEBUG_KEYS, &hdev->flags);
+		set_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);
 	else
-		clear_bit(HCI_DEBUG_KEYS, &hdev->flags);
-
-	len -= sizeof(*cp);
-	i = 0;
-
-	while (i < len) {
-		struct mgmt_key_info *key = (void *) cp->keys + i;
+		clear_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);
 
-		i += sizeof(*key);
+	for (i = 0; i < key_count; i++) {
+		struct mgmt_link_key_info *key = &cp->keys[i];
 
-		if (key->key_type == KEY_TYPE_LTK) {
-			struct key_master_id *id = (void *) key->data;
-
-			if (key->dlen != sizeof(struct key_master_id))
-				continue;
+		hci_add_link_key(hdev, NULL, 0, &key->addr.bdaddr, key->val,
+				 key->type, key->pin_len);
+	}
 
-			hci_add_ltk(hdev, 0, &key->bdaddr, key->addr_type,
-					key->pin_len, key->auth, id->ediv,
-					id->rand, key->val);
+	cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);
 
-			continue;
-		}
+	hci_dev_unlock(hdev);
 
-		hci_add_link_key(hdev, 0, &key->bdaddr, key->val, key->key_type,
-								key->pin_len);
-	}
+	return 0;
+}
 
-	err = cmd_complete(sk, index, MGMT_OP_LOAD_KEYS, NULL, 0);
+static int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 addr_type, struct sock *skip_sk)
+{
+	struct mgmt_ev_device_unpaired ev;
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = addr_type;
 
-	return err;
+	return mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),
+			  skip_sk);
 }
 
-static int remove_key(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_remove_key *cp;
+	struct mgmt_cp_unpair_device *cp = data;
+	struct mgmt_rp_unpair_device rp;
+	struct hci_cp_disconnect dc;
+	struct pending_cmd *cmd;
 	struct hci_conn *conn;
 	int err;
 
-	cp = (void *) data;
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, EINVAL);
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, ENODEV);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,
+				   MGMT_STATUS_NOT_POWERED, &rp, sizeof(rp));
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		err = hci_remove_link_key(hdev, &cp->addr.bdaddr);
+	else
+		err = hci_remove_ltk(hdev, &cp->addr.bdaddr);
 
-	err = hci_remove_link_key(hdev, &cp->bdaddr);
 	if (err < 0) {
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_KEY, -err);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,
+				   MGMT_STATUS_NOT_PAIRED, &rp, sizeof(rp));
 		goto unlock;
 	}
 
-	err = 0;
+	if (cp->disconnect) {
+		if (cp->addr.type == MGMT_ADDR_BREDR)
+			conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+							&cp->addr.bdaddr);
+		else
+			conn = hci_conn_hash_lookup_ba(hdev, LE_LINK,
+							&cp->addr.bdaddr);
+	} else {
+		conn = NULL;
+	}
 
-	if (!test_bit(HCI_UP, &hdev->flags) || !cp->disconnect)
+	if (!conn) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,
+				   &rp, sizeof(rp));
+		device_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);
 		goto unlock;
+	}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn) {
-		struct hci_cp_disconnect dc;
-
-		put_unaligned_le16(conn->handle, &dc.handle);
-		dc.reason = 0x13; /* Remote User Terminated Connection */
-		err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, 0, NULL);
+	cmd = mgmt_pending_add(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,
+			       sizeof(*cp));
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
 	}
 
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	put_unaligned_le16(conn->handle, &dc.handle);
+	dc.reason = 0x13; /* Remote User Terminated Connection */
+	err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int disconnect(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,
+		      u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_disconnect *cp;
+	struct mgmt_cp_disconnect *cp = data;
 	struct hci_cp_disconnect dc;
 	struct pending_cmd *cmd;
 	struct hci_conn *conn;
@@ -1198,38 +1570,32 @@
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, ENETDOWN);
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_DISCONNECT, index)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, EBUSY);
+	if (mgmt_pending_find(MGMT_OP_DISCONNECT, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);
+	else
+		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);
+
 	if (!conn) {
-		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-		if (!conn) {
-			err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
-							ENOTCONN);
-			goto failed;
-		}
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_NOT_CONNECTED);
+		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1243,445 +1609,218 @@
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int get_connections(struct sock *sk, u16 index)
+static u8 link_to_mgmt(u8 link_type, u8 addr_type)
+{
+	switch (link_type) {
+	case LE_LINK:
+		switch (addr_type) {
+		case ADDR_LE_DEV_PUBLIC:
+			return MGMT_ADDR_LE_PUBLIC;
+		case ADDR_LE_DEV_RANDOM:
+			return MGMT_ADDR_LE_RANDOM;
+		default:
+			return MGMT_ADDR_INVALID;
+		}
+	case ACL_LINK:
+		return MGMT_ADDR_BREDR;
+	default:
+		return MGMT_ADDR_INVALID;
+	}
+}
+
+static int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 data_len)
 {
 	struct mgmt_rp_get_connections *rp;
-	struct hci_dev *hdev;
-	struct list_head *p;
+	struct hci_conn *c;
 	size_t rp_len;
-	u16 count;
-	int i, err;
+	int err;
+	u16 i;
 
 	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_GET_CONNECTIONS, ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
 
-	count = 0;
-	list_for_each(p, &hdev->conn_hash.list) {
-		count++;
+	i = 0;
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
+		if (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))
+			i++;
 	}
 
-	rp_len = sizeof(*rp) + (count * sizeof(bdaddr_t));
+	rp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));
 	rp = kmalloc(rp_len, GFP_ATOMIC);
 	if (!rp) {
 		err = -ENOMEM;
 		goto unlock;
 	}
 
-	put_unaligned_le16(count, &rp->conn_count);
-
-	read_lock(&hci_dev_list_lock);
-
 	i = 0;
-	list_for_each(p, &hdev->conn_hash.list) {
-		struct hci_conn *c = list_entry(p, struct hci_conn, list);
-
-		bacpy(&rp->conn[i++], &c->dst);
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
+		if (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))
+			continue;
+		bacpy(&rp->addr[i].bdaddr, &c->dst);
+		rp->addr[i].type = link_to_mgmt(c->type, c->dst_type);
+		if (rp->addr[i].type == MGMT_ADDR_INVALID)
+			continue;
+		i++;
 	}
 
-	read_unlock(&hci_dev_list_lock);
+	put_unaligned_le16(i, &rp->conn_count);
 
-	err = cmd_complete(sk, index, MGMT_OP_GET_CONNECTIONS, rp, rp_len);
+	/* Recalculate length in case of filtered SCO connections, etc */
+	rp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,
+			   rp_len);
 
-unlock:
 	kfree(rp);
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int pin_code_reply(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				   struct mgmt_cp_pin_code_neg_reply *cp)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_pin_code_reply *cp;
-	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENETDOWN);
-		goto failed;
-	}
-
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, index, data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
-
-	bacpy(&reply.bdaddr, &cp->bdaddr);
-	reply.pin_len = cp->pin_len;
-	memcpy(reply.pin_code, cp->pin_code, 16);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,
+			       sizeof(*cp));
+	if (!cmd)
+		return -ENOMEM;
 
-	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);
+	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,
+			   sizeof(cp->addr.bdaddr), &cp->addr.bdaddr);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
 	return err;
 }
 
-static int encrypt_link(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_encrypt_link *cp;
-	struct hci_cp_set_conn_encrypt enc;
 	struct hci_conn *conn;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENETDOWN);
-		goto done;
-	}
-
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENOTCONN);
-		goto done;
-	}
-
-	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINPROGRESS);
-		goto done;
-	}
-
-	if (conn->link_mode & HCI_LM_AUTH) {
-		enc.handle = cpu_to_le16(conn->handle);
-		enc.encrypt = cp->enable;
-		err = hci_send_cmd(hdev,
-				HCI_OP_SET_CONN_ENCRYPT, sizeof(enc), &enc);
-	} else {
-		conn->auth_initiator = 1;
-		if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
-			struct hci_cp_auth_requested cp;
-			cp.handle = cpu_to_le16(conn->handle);
-			err = hci_send_cmd(conn->hdev,
-				HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
-		}
-	}
-
-done:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-
-static int pin_code_neg_reply(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_pin_code_neg_reply *cp;
+	struct mgmt_cp_pin_code_reply *cp = data;
+	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-								ENETDOWN);
-		goto failed;
-	}
-
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, index,
-								data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
-
-	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
-								&cp->bdaddr);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_add_dev_white_list(struct sock *sk, u16 index,
-					unsigned char *data, u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_le_add_dev_white_list *cp;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-								ENETDOWN);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	hci_le_add_dev_white_list(hdev, &cp->bdaddr);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_remove_dev_white_list(struct sock *sk, u16 index,
-					unsigned char *data, u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_le_remove_dev_white_list *cp;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-								ENETDOWN);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);
+	if (!conn) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+				 MGMT_STATUS_NOT_CONNECTED);
 		goto failed;
 	}
 
-	hci_le_remove_dev_white_list(hdev, &cp->bdaddr);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_create_conn_white_list(struct sock *sk, u16 index)
-{
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	u8 sec_level, auth_type;
-	struct pending_cmd *cmd;
-	bdaddr_t bdaddr;
-	int err = 0;
+	if (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {
+		struct mgmt_cp_pin_code_neg_reply ncp;
 
-	BT_DBG("");
+		memcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
-									ENODEV);
+		BT_ERR("PIN code is not 16 bytes long");
 
-	hci_dev_lock_bh(hdev);
+		err = send_pin_code_neg_reply(sk, hdev, &ncp);
+		if (err >= 0)
+			err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+					 MGMT_STATUS_INVALID_PARAMS);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
-								ENETDOWN);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index,
-								NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	sec_level = BT_SECURITY_MEDIUM;
-	auth_type = HCI_AT_GENERAL_BONDING;
-	memset(&bdaddr, 0, sizeof(bdaddr));
-	conn = hci_le_connect(hdev, 0, BDADDR_ANY, sec_level, auth_type, NULL);
-	if (IS_ERR(conn)) {
-		err = PTR_ERR(conn);
-		mgmt_pending_remove(cmd);
-	}
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_cancel_create_conn_white_list(struct sock *sk, u16 index)
-{
-	struct hci_dev *hdev;
-	int err = 0;
-
-	BT_DBG("");
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index,
-			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index,
-			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENETDOWN);
-		goto failed;
-	}
+	bacpy(&reply.bdaddr, &cp->addr.bdaddr);
+	reply.pin_len = cp->pin_len;
+	memcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));
 
-	hci_le_cancel_create_connect(hdev, BDADDR_ANY);
+	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int le_clear_white_list(struct sock *sk, u16 index)
+static int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,
+			      void *data, u16 len)
 {
-	struct hci_dev *hdev;
+	struct mgmt_cp_pin_code_neg_reply *cp = data;
 	int err;
 
 	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index,
-			MGMT_OP_LE_CLEAR_WHITE_LIST, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index,
-			MGMT_OP_LE_CLEAR_WHITE_LIST, ENETDOWN);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	err = hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
+	err = send_pin_code_neg_reply(sk, hdev, cp);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_io_capability(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,
+			     u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_io_capability *cp;
+	struct mgmt_cp_set_io_capability *cp = data;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	hdev->io_capability = cp->io_capability;
 
 	BT_DBG("%s IO capability set to 0x%02x", hdev->name,
 							hdev->io_capability);
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
-	return cmd_complete(sk, index, MGMT_OP_SET_IO_CAPABILITY, NULL, 0);
+	return cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0, NULL,
+			    0);
 }
 
 static inline struct pending_cmd *find_pairing(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	struct list_head *p;
-
-	list_for_each(p, &cmd_list) {
-		struct pending_cmd *cmd;
-
-		cmd = list_entry(p, struct pending_cmd, list);
+	struct pending_cmd *cmd;
 
+	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
 		if (cmd->opcode != MGMT_OP_PAIR_DEVICE)
 			continue;
 
-		if (cmd->index != hdev->id)
-			continue;
-
 		if (cmd->user_data != conn)
 			continue;
 
@@ -1696,18 +1835,19 @@
 	struct mgmt_rp_pair_device rp;
 	struct hci_conn *conn = cmd->user_data;
 
-	BT_DBG(" %u", status);
-
-	bacpy(&rp.bdaddr, &conn->dst);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, &conn->dst);
+	rp.addr.type = link_to_mgmt(conn->type, conn->dst_type);
 
-	cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, &rp, sizeof(rp));
+	cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, status,
+		     &rp, sizeof(rp));
 
 	/* So we don't get further callbacks for this connection */
 	conn->connect_cfm_cb = NULL;
 	conn->security_cfm_cb = NULL;
 	conn->disconn_cfm_cb = NULL;
 
+	hci_conn_put(conn);
+
 	mgmt_pending_remove(cmd);
 }
 
@@ -1715,141 +1855,80 @@
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG(" %u", status);
-
-	cmd = find_pairing(conn);
-	if (!cmd) {
-		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	pairing_complete(cmd, status);
-	hci_conn_put(conn);
-}
-
-static void pairing_security_complete_cb(struct hci_conn *conn, u8 status)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG(" %u", status);
+	BT_DBG("status %u", status);
 
 	cmd = find_pairing(conn);
-	if (!cmd) {
+	if (!cmd)
 		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	if (conn->type == LE_LINK)
-		smp_link_encrypt_cmplt(conn->l2cap_data, status,
-				status ? 0 : 1);
 	else
-		pairing_complete(cmd, status);
-}
-
-static void pairing_connect_complete_cb(struct hci_conn *conn, u8 status)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG("conn: %p %u", conn, status);
-
-	cmd = find_pairing(conn);
-	if (!cmd) {
-		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	if (status || conn->pending_sec_level < BT_SECURITY_MEDIUM)
-		pairing_complete(cmd, status);
-
-	hci_conn_put(conn);
-}
-
-static void discovery_terminated(struct pending_cmd *cmd, void *data)
-{
-	struct hci_dev *hdev;
-	struct mgmt_mode ev = {0};
-
-	BT_DBG("");
-	hdev = hci_dev_get(cmd->index);
-	if (!hdev)
-		goto not_found;
-
-	del_timer(&hdev->disco_le_timer);
-	del_timer(&hdev->disco_timer);
-	hci_dev_put(hdev);
-
-not_found:
-	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
-
-	list_del(&cmd->list);
-
-	mgmt_pending_free(cmd);
+		pairing_complete(cmd, mgmt_status(status));
 }
 
-static int pair_device(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+		       u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_pair_device *cp;
+	struct mgmt_cp_pair_device *cp = data;
+	struct mgmt_rp_pair_device rp;
 	struct pending_cmd *cmd;
-	u8 sec_level, auth_type, io_cap;
+	u8 sec_level, auth_type;
 	struct hci_conn *conn;
-	struct adv_entry *entry;
 	int err;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EINVAL);
-
-	hdev = hci_dev_get(index);
-
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
-
-	io_cap = cp->io_cap;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
 
 	sec_level = BT_SECURITY_MEDIUM;
-	auth_type = HCI_AT_DEDICATED_BONDING;
+	if (cp->io_cap == 0x03)
+		auth_type = HCI_AT_DEDICATED_BONDING;
+	else
+		auth_type = HCI_AT_DEDICATED_BONDING_MITM;
 
-	entry = hci_find_adv_entry(hdev, &cp->bdaddr);
-	if (entry && entry->flags & 0x04) {
-		conn = hci_le_connect(hdev, 0, &cp->bdaddr, sec_level,
-							auth_type, NULL);
-	} else {
-		/* ACL-SSP does not support io_cap 0x04 (KeyboadDisplay) */
-		if (io_cap == 0x04)
-			io_cap = 0x01;
-		conn = hci_connect(hdev, ACL_LINK, 0, &cp->bdaddr, sec_level,
-								auth_type);
-		conn->auth_initiator = 1;
-	}
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn = hci_connect(hdev, ACL_LINK, &cp->addr.bdaddr, sec_level,
+				   auth_type);
+	else
+		conn = hci_connect(hdev, LE_LINK, &cp->addr.bdaddr, sec_level,
+				   auth_type);
+
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
 	if (IS_ERR(conn)) {
-		err = PTR_ERR(conn);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				   MGMT_STATUS_CONNECT_FAILED, &rp,
+				   sizeof(rp));
 		goto unlock;
 	}
 
 	if (conn->connect_cfm_cb) {
 		hci_conn_put(conn);
-		err = cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EBUSY);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				   MGMT_STATUS_BUSY, &rp, sizeof(rp));
 		goto unlock;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		hci_conn_put(conn);
 		goto unlock;
 	}
 
-	conn->connect_cfm_cb = pairing_connect_complete_cb;
-	conn->security_cfm_cb = pairing_security_complete_cb;
+	/* For LE, just connecting isn't a proof that the pairing finished */
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn->connect_cfm_cb = pairing_complete_cb;
+
+	conn->security_cfm_cb = pairing_complete_cb;
 	conn->disconn_cfm_cb = pairing_complete_cb;
-	conn->io_capability = io_cap;
+	conn->io_capability = cp->io_cap;
 	cmd->user_data = conn;
 
 	if (conn->state == BT_CONNECTED &&
@@ -1859,742 +1938,726 @@
 	err = 0;
 
 unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int user_confirm_reply(struct sock *sk, u16 index, unsigned char *data,
-							u16 len, u16 opcode)
+static int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_user_confirm_reply *cp = (void *) data;
-	u16 mgmt_op = opcode, hci_op;
+	struct mgmt_addr_info *addr = data;
 	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
-	struct hci_conn *le_conn;
+	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("%d", mgmt_op);
-
-	if (mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY)
-		hci_op = HCI_OP_USER_CONFIRM_NEG_REPLY;
-	else
-		hci_op = HCI_OP_USER_CONFIRM_REPLY;
-
-	if (len < sizeof(*cp))
-		return cmd_status(sk, index, mgmt_op, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, mgmt_op, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	BT_DBG("");
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, mgmt_op, ENETDOWN);
-		goto done;
-	}
+	hci_dev_lock(hdev);
 
-	le_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-	if (le_conn) {
-		err = le_user_confirm_reply(le_conn, mgmt_op, (void *) cp);
-		goto done;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
 	}
-	BT_DBG("BR/EDR: %s", mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY ?
-							"Reject" : "Accept");
 
-	cmd = mgmt_pending_add(sk, mgmt_op, index, data, len);
+	cmd = mgmt_pending_find(MGMT_OP_PAIR_DEVICE, hdev);
 	if (!cmd) {
-		err = -ENOMEM;
-		goto done;
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto unlock;
 	}
 
-	err = hci_send_cmd(hdev, hci_op, sizeof(cp->bdaddr), &cp->bdaddr);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
+	conn = cmd->user_data;
 
-done:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (bacmp(&addr->bdaddr, &conn->dst) != 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto unlock;
+	}
 
+	pairing_complete(cmd, MGMT_STATUS_CANCELLED);
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,
+			   addr, sizeof(*addr));
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int resolve_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,
+			     bdaddr_t *bdaddr, u8 type, u16 mgmt_op,
+			     u16 hci_op, __le32 passkey)
 {
-	struct mgmt_cp_resolve_name *mgmt_cp = (void *) data;
-	struct hci_cp_remote_name_req hci_cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
+	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("");
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, EINVAL);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, mgmt_op,
+				 MGMT_STATUS_NOT_POWERED);
+		goto done;
+	}
+
+	if (type == MGMT_ADDR_BREDR)
+		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+	else
+		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, bdaddr);
+
+	if (!conn) {
+		err = cmd_status(sk, hdev->id, mgmt_op,
+				 MGMT_STATUS_NOT_CONNECTED);
+		goto done;
+	}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, ENODEV);
+	if (type == MGMT_ADDR_LE_PUBLIC || type == MGMT_ADDR_LE_RANDOM) {
+		/* Continue with pairing via SMP */
+		err = smp_user_confirm_reply(conn, mgmt_op, passkey);
+
+		if (!err)
+			err = cmd_status(sk, hdev->id, mgmt_op,
+					 MGMT_STATUS_SUCCESS);
+		else
+			err = cmd_status(sk, hdev->id, mgmt_op,
+					 MGMT_STATUS_FAILED);
 
-	hci_dev_lock_bh(hdev);
+		goto done;
+	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_RESOLVE_NAME, index, data, len);
+	cmd = mgmt_pending_add(sk, mgmt_op, hdev, bdaddr, sizeof(*bdaddr));
 	if (!cmd) {
 		err = -ENOMEM;
-		goto failed;
+		goto done;
 	}
 
-	memset(&hci_cp, 0, sizeof(hci_cp));
-	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
-	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(hci_cp),
-								&hci_cp);
+	/* Continue with pairing via HCI */
+	if (hci_op == HCI_OP_USER_PASSKEY_REPLY) {
+		struct hci_cp_user_passkey_reply cp;
+
+		bacpy(&cp.bdaddr, bdaddr);
+		cp.passkey = passkey;
+		err = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);
+	} else
+		err = hci_send_cmd(hdev, hci_op, sizeof(*bdaddr), bdaddr);
+
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+done:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int cancel_resolve_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_cancel_resolve_name *mgmt_cp = (void *) data;
-	struct hci_cp_remote_name_req_cancel hci_cp;
-	struct hci_dev *hdev;
-	int err;
+	struct mgmt_cp_user_confirm_reply *cp = data;
 
 	BT_DBG("");
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
-								EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
-								ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	memset(&hci_cp, 0, sizeof(hci_cp));
-	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
-	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(hci_cp),
-								&hci_cp);
-
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (len != sizeof(*cp))
+		return cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,
+				  MGMT_STATUS_INVALID_PARAMS);
 
-	return err;
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_CONFIRM_REPLY,
+				 HCI_OP_USER_CONFIRM_REPLY, 0);
 }
 
-static int set_connection_params(struct sock *sk, u16 index,
-				unsigned char *data, u16 len)
+static int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				  void *data, u16 len)
 {
-	struct mgmt_cp_set_connection_params *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err;
+	struct mgmt_cp_user_confirm_neg_reply *cp = data;
 
 	BT_DBG("");
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-								ENOTCONN);
-		goto failed;
-	}
-
-	hci_le_conn_update(conn, le16_to_cpu(cp->interval_min),
-				le16_to_cpu(cp->interval_max),
-				le16_to_cpu(cp->slave_latency),
-				le16_to_cpu(cp->timeout_multiplier));
-
-	err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS, 0);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_CONFIRM_NEG_REPLY,
+				 HCI_OP_USER_CONFIRM_NEG_REPLY, 0);
 }
 
-static int set_rssi_reporter(struct sock *sk, u16 index,
-				unsigned char *data, u16 len)
+static int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_set_rssi_reporter *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err = 0;
+	struct mgmt_cp_user_passkey_reply *cp = data;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-								EINVAL);
+	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-							ENODEV);
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_PASSKEY_REPLY,
+				 HCI_OP_USER_PASSKEY_REPLY, cp->passkey);
+}
 
-	hci_dev_lock_bh(hdev);
+static int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				  void *data, u16 len)
+{
+	struct mgmt_cp_user_passkey_neg_reply *cp = data;
 
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+	BT_DBG("");
 
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-						ENOTCONN);
-		goto failed;
-	}
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_PASSKEY_NEG_REPLY,
+				 HCI_OP_USER_PASSKEY_NEG_REPLY, 0);
+}
 
-	BT_DBG("updateOnThreshExceed %d ", cp->updateOnThreshExceed);
-	hci_conn_set_rssi_reporter(conn, cp->rssi_threshold,
-			__le16_to_cpu(cp->interval), cp->updateOnThreshExceed);
+static int update_name(struct hci_dev *hdev, const char *name)
+{
+	struct hci_cp_write_local_name cp;
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	memcpy(cp.name, name, sizeof(cp.name));
 
-	return err;
+	return hci_send_cmd(hdev, HCI_OP_WRITE_LOCAL_NAME, sizeof(cp), &cp);
 }
 
-static int unset_rssi_reporter(struct sock *sk, u16 index,
-			unsigned char *data, u16 len)
+static int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct mgmt_cp_unset_rssi_reporter *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err = 0;
+	struct mgmt_cp_set_local_name *cp = data;
+	struct pending_cmd *cmd;
+	int err;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					EINVAL);
+	BT_DBG("");
 
-	hdev = hci_dev_get(index);
+	hci_dev_lock(hdev);
 
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					ENODEV);
+	memcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		memcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));
+
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,
+				   data, len);
+		if (err < 0)
+			goto failed;
 
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+		err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, data, len,
+				 sk);
 
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					ENOTCONN);
 		goto failed;
 	}
 
-	hci_conn_unset_rssi_reporter(conn);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_cancel_create_conn(struct sock *sk, u16 index,
-	unsigned char *data, u16 len)
-{
-	struct mgmt_cp_le_cancel_create_conn *cp = (void *) data;
-	struct hci_dev *hdev;
-	int err = 0;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-							EINVAL);
-
-	hdev = hci_dev_get(index);
-
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-							ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-						ENETDOWN);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
 		goto failed;
 	}
 
-	hci_le_cancel_create_connect(hdev, &cp->bdaddr);
+	err = update_name(hdev, cp->name);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-return err;
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int set_local_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,
+			       void *data, u16 data_len)
 {
-	struct mgmt_cp_set_local_name *mgmt_cp = (void *) data;
-	struct hci_cp_write_local_name hci_cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, ENODEV);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
+
+	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
-		goto failed;
+		goto unlock;
 	}
 
-	memcpy(hci_cp.name, mgmt_cp->name, sizeof(hci_cp.name));
-	err = hci_send_cmd(hdev, HCI_OP_WRITE_LOCAL_NAME, sizeof(hci_cp),
-								&hci_cp);
+	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static void discovery_rsp(struct pending_cmd *cmd, void *data)
-{
-	struct mgmt_mode ev;
-
-	BT_DBG("");
-	if (cmd->opcode == MGMT_OP_START_DISCOVERY) {
-		ev.val = 1;
-		cmd_status(cmd->sk, cmd->index, MGMT_OP_START_DISCOVERY, 0);
-	} else {
-		ev.val = 0;
-		cmd_complete(cmd->sk, cmd->index, MGMT_OP_STOP_DISCOVERY,
-								NULL, 0);
-		if (cmd->opcode == MGMT_OP_STOP_DISCOVERY) {
-			struct hci_dev *hdev = hci_dev_get(cmd->index);
-			if (hdev) {
-				del_timer(&hdev->disco_le_timer);
-				del_timer(&hdev->disco_timer);
-				hci_dev_put(hdev);
-			}
-		}
-	}
-
-	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
-
-	list_del(&cmd->list);
-
-	mgmt_pending_free(cmd);
-}
-
-void mgmt_inquiry_started(u16 index)
-{
-	BT_DBG("");
-	mgmt_pending_foreach(MGMT_OP_START_DISCOVERY, index,
-						discovery_rsp, NULL);
-}
-
-void mgmt_inquiry_complete_evt(u16 index, u8 status)
+static int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
+			       void *data, u16 len)
 {
-	struct hci_dev *hdev;
-	struct hci_cp_le_set_scan_enable le_cp = {1, 0};
-	struct mgmt_mode cp = {0};
-	int err = -1;
-
-	hdev = hci_dev_get(index);
-
-	if (hdev)
-		BT_DBG("disco_state: %d", hdev->disco_state);
-
-	if (!hdev || !lmp_le_capable(hdev)) {
-
-		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
-
-		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
+	struct mgmt_cp_add_remote_oob_data *cp = data;
+	u8 status;
+	int err;
 
-		hdev->disco_state = SCAN_IDLE;
+	BT_DBG("%s ", hdev->name);
 
-		if (hdev)
-			goto done;
-		else
-			return;
-	}
+	hci_dev_lock(hdev);
 
-	if (hdev->disco_state != SCAN_IDLE) {
-		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-						sizeof(le_cp), &le_cp);
-		if (err >= 0) {
-			mod_timer(&hdev->disco_le_timer, jiffies +
-				msecs_to_jiffies(hdev->disco_int_phase * 1000));
-			hdev->disco_state = SCAN_LE;
-		} else
-			hdev->disco_state = SCAN_IDLE;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA,
+				   MGMT_STATUS_NOT_POWERED, &cp->addr,
+				   sizeof(cp->addr));
+		goto unlock;
 	}
 
-	if (hdev->disco_state == SCAN_IDLE)
-		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
-
+	err = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr, cp->hash,
+				      cp->randomizer);
 	if (err < 0)
-		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
+		status = MGMT_STATUS_FAILED;
+	else
+		status = 0;
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA, status,
+			   &cp->addr, sizeof(cp->addr));
 
-done:
-	hci_dev_put(hdev);
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-void mgmt_disco_timeout(unsigned long data)
+static int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
+						void *data, u16 len)
 {
-	struct hci_dev *hdev = (void *) data;
-	struct pending_cmd *cmd;
-	struct mgmt_mode cp = {0};
-
-	BT_DBG("hci%d", hdev->id);
-
-	hdev = hci_dev_get(hdev->id);
-
-	if (!hdev)
-		return;
+	struct mgmt_cp_remove_remote_oob_data *cp = data;
+	u8 status;
+	int err;
 
-	hci_dev_lock_bh(hdev);
-	del_timer(&hdev->disco_le_timer);
+	BT_DBG("%s", hdev->name);
 
-	if (hdev->disco_state != SCAN_IDLE) {
-		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
+	hci_dev_lock(hdev);
 
-		if (test_bit(HCI_UP, &hdev->flags)) {
-			if (hdev->disco_state == SCAN_LE)
-				hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-							sizeof(le_cp), &le_cp);
-			else
-				hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0,
-									 NULL);
-		}
-		hdev->disco_state = SCAN_IDLE;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id,
+				   MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+				   MGMT_STATUS_NOT_POWERED, &cp->addr,
+				   sizeof(cp->addr));
+		goto unlock;
 	}
 
-	mgmt_event(MGMT_EV_DISCOVERING, hdev->id, &cp, sizeof(cp), NULL);
+	err = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr);
+	if (err < 0)
+		status = MGMT_STATUS_INVALID_PARAMS;
+	else
+		status = 0;
 
-	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev->id);
-	if (cmd)
-		mgmt_pending_remove(cmd);
+	err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+			   status, &cp->addr, sizeof(cp->addr));
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-void mgmt_disco_le_timeout(unsigned long data)
+int mgmt_interleaved_discovery(struct hci_dev *hdev)
 {
-	struct hci_dev *hdev = (void *)data;
-	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-
-	BT_DBG("hci%d", hdev->id);
+	int err;
 
-	hdev = hci_dev_get(hdev->id);
+	BT_DBG("%s", hdev->name);
 
-	if (!hdev)
-		return;
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	err = hci_do_inquiry(hdev, INQUIRY_LEN_BREDR_LE);
+	if (err < 0)
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		if (hdev->disco_state == SCAN_LE)
-			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-					sizeof(le_cp), &le_cp);
-
-	/* re-start BR scan */
-		if (hdev->disco_state != SCAN_IDLE) {
-			struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
-			hdev->disco_int_phase *= 2;
-			hdev->disco_int_count = 0;
-			cp.num_rsp = (u8) hdev->disco_int_phase;
-			hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
-			hdev->disco_state = SCAN_BR;
-		}
-	}
+	hci_dev_unlock(hdev);
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	return err;
 }
 
-static int start_discovery(struct sock *sk, u16 index)
+static int start_discovery(struct sock *sk, struct hci_dev *hdev,
+			   void *data, u16 len)
 {
-	struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 8, 0};
-	struct hci_dev *hdev;
+	struct mgmt_cp_start_discovery *cp = data;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, ENODEV);
+	hci_dev_lock(hdev);
 
-	BT_DBG("disco_state: %d", hdev->disco_state);
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,
+				 MGMT_STATUS_NOT_POWERED);
+		goto failed;
+	}
 
-	if (hdev->disco_state && timer_pending(&hdev->disco_timer)) {
-		err = -EBUSY;
+	if (hdev->discovery.state != DISCOVERY_STOPPED) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, index, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, hdev, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	/* If LE Capable, we will alternate between BR/EDR and LE */
-	if (lmp_le_capable(hdev)) {
-		struct hci_cp_le_set_scan_parameters le_cp;
-
-		/* Shorten BR scan params */
-		cp.num_rsp = 1;
-		cp.length /= 2;
-
-		/* Setup LE scan params */
-		memset(&le_cp, 0, sizeof(le_cp));
-		le_cp.type = 0x01;		/* Active scanning */
-		/* The recommended value for scan interval and window is
-		 * 11.25 msec. It is calculated by: time = n * 0.625 msec */
-		le_cp.interval = cpu_to_le16(0x0012);
-		le_cp.window = cpu_to_le16(0x0012);
-		le_cp.own_bdaddr_type = 0;	/* Public address */
-		le_cp.filter = 0;		/* Accept all adv packets */
+	hdev->discovery.type = cp->type;
 
-		hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_PARAMETERS,
-						sizeof(le_cp), &le_cp);
-	}
+	switch (hdev->discovery.type) {
+	case DISCOV_TYPE_BREDR:
+		if (lmp_bredr_capable(hdev))
+			err = hci_do_inquiry(hdev, INQUIRY_LEN_BREDR);
+		else
+			err = -ENOTSUPP;
+		break;
 
-	err = hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+	case DISCOV_TYPE_LE:
+		if (lmp_host_le_capable(hdev))
+			err = hci_le_scan(hdev, LE_SCAN_TYPE, LE_SCAN_INT,
+					  LE_SCAN_WIN, LE_SCAN_TIMEOUT_LE_ONLY);
+		else
+			err = -ENOTSUPP;
+		break;
 
-	if (err < 0) {
-		mgmt_pending_remove(cmd);
-		hdev->disco_state = SCAN_IDLE;
-	} else if (lmp_le_capable(hdev)) {
-		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
-		if (!cmd)
-			mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, index,
-								NULL, 0);
-		hdev->disco_int_phase = 1;
-		hdev->disco_int_count = 0;
-		hdev->disco_state = SCAN_BR;
-		del_timer(&hdev->disco_le_timer);
-		del_timer(&hdev->disco_timer);
-		mod_timer(&hdev->disco_timer,
-				jiffies + msecs_to_jiffies(20000));
-	} else
-		hdev->disco_state = SCAN_BR;
+	case DISCOV_TYPE_INTERLEAVED:
+		if (lmp_host_le_capable(hdev) && lmp_bredr_capable(hdev))
+			err = hci_le_scan(hdev, LE_SCAN_TYPE, LE_SCAN_INT,
+					  LE_SCAN_WIN,
+					  LE_SCAN_TIMEOUT_BREDR_LE);
+		else
+			err = -ENOTSUPP;
+		break;
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	default:
+		err = -EINVAL;
+	}
 
 	if (err < 0)
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, -err);
+		mgmt_pending_remove(cmd);
+	else
+		hci_discovery_set_state(hdev, DISCOVERY_STARTING);
 
+failed:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int stop_discovery(struct sock *sk, u16 index)
+static int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-	struct mgmt_mode mode_cp = {0};
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd = NULL;
-	int err = -EPERM;
-	u8 state;
+	struct mgmt_cp_stop_discovery *mgmt_cp = data;
+	struct pending_cmd *cmd;
+	struct hci_cp_remote_name_req_cancel cp;
+	struct inquiry_entry *e;
+	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, ENODEV);
-
-	BT_DBG("disco_state: %d", hdev->disco_state);
-
-	hci_dev_lock_bh(hdev);
-
-	state = hdev->disco_state;
-	hdev->disco_state = SCAN_IDLE;
-	del_timer(&hdev->disco_le_timer);
-	del_timer(&hdev->disco_timer);
-
-	if (state == SCAN_LE) {
-		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-							sizeof(le_cp), &le_cp);
-		if (err >= 0) {
-			mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
+	hci_dev_lock(hdev);
 
-			err = cmd_complete(sk, index, MGMT_OP_STOP_DISCOVERY,
-								NULL, 0);
-		}
-	} else if (state == SCAN_BR)
-		err = hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
+	if (!hci_discovery_active(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,
+				   MGMT_STATUS_REJECTED, &mgmt_cp->type,
+				   sizeof(mgmt_cp->type));
+		goto unlock;
+	}
 
-	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
-	if (err < 0 && cmd)
-		mgmt_pending_remove(cmd);
+	if (hdev->discovery.type != mgmt_cp->type) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,
+				   MGMT_STATUS_INVALID_PARAMS, &mgmt_cp->type,
+				   sizeof(mgmt_cp->type));
+		goto unlock;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, NULL, 0);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
-	mgmt_event(MGMT_EV_DISCOVERING, index, &mode_cp, sizeof(mode_cp), NULL);
+	if (hdev->discovery.state == DISCOVERY_FINDING) {
+		err = hci_cancel_inquiry(hdev);
+		if (err < 0)
+			mgmt_pending_remove(cmd);
+		else
+			hci_discovery_set_state(hdev, DISCOVERY_STOPPING);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_PENDING);
+	if (!e) {
+		mgmt_pending_remove(cmd);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY, 0,
+				   &mgmt_cp->type, sizeof(mgmt_cp->type));
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+		goto unlock;
+	}
 
+	bacpy(&cp.bdaddr, &e->data.bdaddr);
+	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(cp),
+			   &cp);
 	if (err < 0)
-		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, -err);
+		mgmt_pending_remove(cmd);
 	else
-		return err;
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPING);
+
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int read_local_oob_data(struct sock *sk, u16 index)
+static int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
 {
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
+	struct mgmt_cp_confirm_name *cp = data;
+	struct inquiry_entry *e;
 	int err;
 
-	BT_DBG("hci%u", index);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-									ENODEV);
+	BT_DBG("%s", hdev->name);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-								ENETDOWN);
-		goto unlock;
+	if (!hci_discovery_active(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,
+				 MGMT_STATUS_FAILED);
+		goto failed;
 	}
 
-	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-								EOPNOTSUPP);
-		goto unlock;
+	e = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);
+	if (!e) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA, EBUSY);
-		goto unlock;
+	if (cp->name_known) {
+		e->name_state = NAME_KNOWN;
+		list_del(&e->list);
+	} else {
+		e->name_state = NAME_NEEDED;
+		hci_inquiry_cache_update_resolve(hdev, e);
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, index, NULL, 0);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto unlock;
-	}
+	err = 0;
 
-	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
+
+static int block_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
+{
+	struct mgmt_cp_block_device *cp = data;
+	u8 status;
+	int err;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	err = hci_blacklist_add(hdev, &cp->addr.bdaddr, cp->addr.type);
 	if (err < 0)
-		mgmt_pending_remove(cmd);
+		status = MGMT_STATUS_FAILED;
+	else
+		status = 0;
 
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	err = cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,
+			   &cp->addr, sizeof(cp->addr));
+
+	hci_dev_unlock(hdev);
 
 	return err;
 }
 
-static int add_remote_oob_data(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_add_remote_oob_data *cp = (void *) data;
+	struct mgmt_cp_unblock_device *cp = data;
+	u8 status;
 	int err;
 
-	BT_DBG("hci%u ", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-									ENODEV);
+	BT_DBG("%s", hdev->name);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	err = hci_add_remote_oob_data(hdev, &cp->bdaddr, cp->hash,
-								cp->randomizer);
+	err = hci_blacklist_del(hdev, &cp->addr.bdaddr, cp->addr.type);
 	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, -err);
+		status = MGMT_STATUS_INVALID_PARAMS;
 	else
-		err = cmd_complete(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, NULL,
-									0);
+		status = 0;
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,
+			   &cp->addr, sizeof(cp->addr));
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
 	return err;
 }
 
-static int remove_remote_oob_data(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+static int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,
+				void *data, u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_remove_remote_oob_data *cp = (void *) data;
+	struct mgmt_mode *cp = data;
+	struct hci_cp_write_page_scan_activity acp;
+	u8 type;
 	int err;
 
-	BT_DBG("hci%u ", index);
+	BT_DBG("%s", hdev->name);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									EINVAL);
+	if (!hdev_is_powered(hdev))
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				  MGMT_STATUS_NOT_POWERED);
+
+	if (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				  MGMT_STATUS_REJECTED);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	if (cp->val) {
+		type = PAGE_SCAN_TYPE_INTERLACED;
 
-	err = hci_remove_remote_oob_data(hdev, &cp->bdaddr);
-	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									-err);
-	else
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-								NULL, 0);
+		/* 22.5 msec page scan interval */
+		acp.interval = __constant_cpu_to_le16(0x0024);
+	} else {
+		type = PAGE_SCAN_TYPE_STANDARD;	/* default */
+
+		/* default 1.28 sec page scan */
+		acp.interval = __constant_cpu_to_le16(0x0800);
+	}
+
+	/* default 11.25 msec page scan window */
+	acp.window = __constant_cpu_to_le16(0x0012);
+
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY, sizeof(acp),
+			   &acp);
+	if (err < 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				 MGMT_STATUS_FAILED);
+		goto done;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_TYPE, 1, &type);
+	if (err < 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				 MGMT_STATUS_FAILED);
+		goto done;
+	}
 
+	err = cmd_complete(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE, 0,
+			   NULL, 0);
+done:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
+static int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,
+			       void *cp_data, u16 len)
+{
+	struct mgmt_cp_load_long_term_keys *cp = cp_data;
+	u16 key_count, expected_len;
+	int i;
+
+	key_count = get_unaligned_le16(&cp->key_count);
+
+	expected_len = sizeof(*cp) + key_count *
+					sizeof(struct mgmt_ltk_info);
+	if (expected_len != len) {
+		BT_ERR("load_keys: expected %u bytes, got %u bytes",
+							len, expected_len);
+		return cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,
+				  EINVAL);
+	}
+
+	BT_DBG("%s key_count %u", hdev->name, key_count);
+
+	hci_dev_lock(hdev);
+
+	hci_smp_ltks_clear(hdev);
+
+	for (i = 0; i < key_count; i++) {
+		struct mgmt_ltk_info *key = &cp->keys[i];
+		u8 type;
+
+		if (key->master)
+			type = HCI_SMP_LTK;
+		else
+			type = HCI_SMP_LTK_SLAVE;
+
+		hci_add_ltk(hdev, &key->addr.bdaddr, key->addr.type,
+			    type, 0, key->authenticated, key->val,
+			    key->enc_size, key->ediv, key->rand);
+	}
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+struct mgmt_handler {
+	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
+		     u16 data_len);
+	bool var_len;
+	size_t data_len;
+} mgmt_handlers[] = {
+	{ NULL }, /* 0x0000 (no command) */
+	{ read_version,           false, MGMT_READ_VERSION_SIZE },
+	{ read_commands,          false, MGMT_READ_COMMANDS_SIZE },
+	{ read_index_list,        false, MGMT_READ_INDEX_LIST_SIZE },
+	{ read_controller_info,   false, MGMT_READ_INFO_SIZE },
+	{ set_powered,            false, MGMT_SETTING_SIZE },
+	{ set_discoverable,       false, MGMT_SET_DISCOVERABLE_SIZE },
+	{ set_connectable,        false, MGMT_SETTING_SIZE },
+	{ set_fast_connectable,   false, MGMT_SETTING_SIZE },
+	{ set_pairable,           false, MGMT_SETTING_SIZE },
+	{ set_link_security,      false, MGMT_SETTING_SIZE },
+	{ set_ssp,                false, MGMT_SETTING_SIZE },
+	{ set_hs,                 false, MGMT_SETTING_SIZE },
+	{ set_le,                 false, MGMT_SETTING_SIZE },
+	{ set_dev_class,          false, MGMT_SET_DEV_CLASS_SIZE },
+	{ set_local_name,         false, MGMT_SET_LOCAL_NAME_SIZE },
+	{ add_uuid,               false, MGMT_ADD_UUID_SIZE },
+	{ remove_uuid,            false, MGMT_REMOVE_UUID_SIZE },
+	{ load_link_keys,         true,  MGMT_LOAD_LINK_KEYS_SIZE },
+	{ load_long_term_keys,    true,  MGMT_LOAD_LONG_TERM_KEYS_SIZE },
+	{ disconnect,             false, MGMT_DISCONNECT_SIZE },
+	{ get_connections,        false, MGMT_GET_CONNECTIONS_SIZE },
+	{ pin_code_reply,         false, MGMT_PIN_CODE_REPLY_SIZE },
+	{ pin_code_neg_reply,     false, MGMT_PIN_CODE_NEG_REPLY_SIZE },
+	{ set_io_capability,      false, MGMT_SET_IO_CAPABILITY_SIZE },
+	{ pair_device,            false, MGMT_PAIR_DEVICE_SIZE },
+	{ cancel_pair_device,     false, MGMT_CANCEL_PAIR_DEVICE_SIZE },
+	{ unpair_device,          false, MGMT_UNPAIR_DEVICE_SIZE },
+	{ user_confirm_reply,     false, MGMT_USER_CONFIRM_REPLY_SIZE },
+	{ user_confirm_neg_reply, false, MGMT_USER_CONFIRM_NEG_REPLY_SIZE },
+	{ user_passkey_reply,     false, MGMT_USER_PASSKEY_REPLY_SIZE },
+	{ user_passkey_neg_reply, false, MGMT_USER_PASSKEY_NEG_REPLY_SIZE },
+	{ read_local_oob_data,    false, MGMT_READ_LOCAL_OOB_DATA_SIZE },
+	{ add_remote_oob_data,    false, MGMT_ADD_REMOTE_OOB_DATA_SIZE },
+	{ remove_remote_oob_data, false, MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },
+	{ start_discovery,        false, MGMT_START_DISCOVERY_SIZE },
+	{ stop_discovery,         false, MGMT_STOP_DISCOVERY_SIZE },
+	{ confirm_name,           false, MGMT_CONFIRM_NAME_SIZE },
+	{ block_device,           false, MGMT_BLOCK_DEVICE_SIZE },
+	{ unblock_device,         false, MGMT_UNBLOCK_DEVICE_SIZE },
+};
+
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 {
-	unsigned char *buf;
+	void *buf;
+	u8 *cp;
 	struct mgmt_hdr *hdr;
 	u16 opcode, index, len;
+	struct hci_dev *hdev = NULL;
+	struct mgmt_handler *handler;
 	int err;
 
 	BT_DBG("got %zu bytes", msglen);
@@ -2611,7 +2674,7 @@
 		goto done;
 	}
 
-	hdr = (struct mgmt_hdr *) buf;
+	hdr = buf;
 	opcode = get_unaligned_le16(&hdr->opcode);
 	index = get_unaligned_le16(&hdr->index);
 	len = get_unaligned_le16(&hdr->len);
@@ -2621,144 +2684,54 @@
 		goto done;
 	}
 
-	BT_DBG("got opcode %x", opcode);
-	switch (opcode) {
-	case MGMT_OP_READ_VERSION:
-		err = read_version(sk);
-		break;
-	case MGMT_OP_READ_INDEX_LIST:
-		err = read_index_list(sk);
-		break;
-	case MGMT_OP_READ_INFO:
-		err = read_controller_info(sk, index);
-		break;
-	case MGMT_OP_SET_POWERED:
-		err = set_powered(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_DISCOVERABLE:
-		err = set_discoverable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_LIMIT_DISCOVERABLE:
-		err = set_limited_discoverable(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_SET_CONNECTABLE:
-		err = set_connectable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_PAIRABLE:
-		err = set_pairable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_ADD_UUID:
-		err = add_uuid(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_UUID:
-		err = remove_uuid(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_DEV_CLASS:
-		err = set_dev_class(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_SERVICE_CACHE:
-		err = set_service_cache(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_LOAD_KEYS:
-		err = load_keys(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_KEY:
-		err = remove_key(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_DISCONNECT:
-		err = disconnect(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_GET_CONNECTIONS:
-		err = get_connections(sk, index);
-		break;
-	case MGMT_OP_PIN_CODE_REPLY:
-		err = pin_code_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_PIN_CODE_NEG_REPLY:
-		err = pin_code_neg_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_IO_CAPABILITY:
-		err = set_io_capability(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_PAIR_DEVICE:
-		err = pair_device(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_USER_CONFIRM_REPLY:
-	case MGMT_OP_USER_PASSKEY_REPLY:
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		err = user_confirm_reply(sk, index, buf + sizeof(*hdr),
-								len, opcode);
-		break;
-	case MGMT_OP_SET_LOCAL_NAME:
-		err = set_local_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_START_DISCOVERY:
-		err = start_discovery(sk, index);
-		break;
-	case MGMT_OP_STOP_DISCOVERY:
-		err = stop_discovery(sk, index);
-		break;
-	case MGMT_OP_RESOLVE_NAME:
-		err = resolve_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_CANCEL_RESOLVE_NAME:
-		err = cancel_resolve_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_CONNECTION_PARAMS:
-		err = set_connection_params(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_RSSI_REPORTER:
-		err = set_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_UNSET_RSSI_REPORTER:
-		err = unset_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_READ_LOCAL_OOB_DATA:
-		err = read_local_oob_data(sk, index);
-		break;
-	case MGMT_OP_ADD_REMOTE_OOB_DATA:
-		err = add_remote_oob_data(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_REMOTE_OOB_DATA:
-		err = remove_remote_oob_data(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_ENCRYPT_LINK:
-		err = encrypt_link(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_LE_ADD_DEV_WHITE_LIST:
-		err = le_add_dev_white_list(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_LE_REMOVE_DEV_WHITE_LIST:
-		err = le_remove_dev_white_list(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_LE_CLEAR_WHITE_LIST:
-		err = le_clear_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CREATE_CONN_WHITE_LIST:
-		err = le_create_conn_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST:
-		err = le_cancel_create_conn_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CANCEL_CREATE_CONN:
-		err = le_cancel_create_conn(sk, index, buf + sizeof(*hdr), len);
-		break;
-	default:
+	if (index != MGMT_INDEX_NONE) {
+		hdev = hci_dev_get(index);
+		if (!hdev) {
+			err = cmd_status(sk, index, opcode,
+					 MGMT_STATUS_INVALID_INDEX);
+			goto done;
+		}
+	}
+
+	if (opcode >= ARRAY_SIZE(mgmt_handlers) ||
+					mgmt_handlers[opcode].func == NULL) {
 		BT_DBG("Unknown op %u", opcode);
-		err = cmd_status(sk, index, opcode, 0x01);
-		break;
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_UNKNOWN_COMMAND);
+		goto done;
+	}
+
+	if ((hdev && opcode < MGMT_OP_READ_INFO) ||
+			(!hdev && opcode >= MGMT_OP_READ_INFO)) {
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_INVALID_INDEX);
+		goto done;
+	}
+
+	handler = &mgmt_handlers[opcode];
+
+	if ((handler->var_len && len < handler->data_len) ||
+			(!handler->var_len && len != handler->data_len)) {
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto done;
 	}
 
+	if (hdev)
+		mgmt_init_hdev(sk, hdev);
+
+	cp = buf + sizeof(*hdr);
+
+	err = handler->func(sk, hdev, cp, len);
 	if (err < 0)
 		goto done;
 
 	err = msglen;
 
 done:
+	if (hdev)
+		hci_dev_put(hdev);
+
 	kfree(buf);
 	return err;
 }
@@ -2771,175 +2744,247 @@
 	mgmt_pending_remove(cmd);
 }
 
-int mgmt_index_added(u16 index)
+int mgmt_index_added(struct hci_dev *hdev)
+{
+	return mgmt_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0, NULL);
+}
+
+int mgmt_index_removed(struct hci_dev *hdev)
+{
+	u8 status = MGMT_STATUS_INVALID_INDEX;
+
+	mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+
+	return mgmt_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0, NULL);
+}
+
+struct cmd_lookup {
+	struct sock *sk;
+	struct hci_dev *hdev;
+	u8 mgmt_status;
+};
+
+static void settings_rsp(struct pending_cmd *cmd, void *data)
 {
-	BT_DBG("%d", index);
-	return mgmt_event(MGMT_EV_INDEX_ADDED, index, NULL, 0, NULL);
+	struct cmd_lookup *match = data;
+
+	send_settings_rsp(cmd->sk, cmd->opcode, match->hdev);
+
+	list_del(&cmd->list);
+
+	if (match->sk == NULL) {
+		match->sk = cmd->sk;
+		sock_hold(match->sk);
+	}
+
+	mgmt_pending_free(cmd);
 }
 
-int mgmt_index_removed(u16 index)
+int mgmt_powered(struct hci_dev *hdev, u8 powered)
 {
-	u8 status = ENODEV;
+	struct cmd_lookup match = { NULL, hdev };
+	int err;
+
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		return 0;
+
+	mgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);
+
+	if (powered) {
+		u8 scan = 0;
+
+		if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			scan |= SCAN_PAGE;
+		if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			scan |= SCAN_INQUIRY;
+
+		if (scan)
+			hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
+
+		if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			u8 ssp = 1;
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, 1, &ssp);
+		}
+
+		if (test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+			struct hci_cp_write_le_host_supported cp;
+
+			cp.le = 1;
+			cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED,
+				     sizeof(cp), &cp);
+		}
+
+		update_class(hdev);
+		update_name(hdev, hdev->dev_name);
+		update_eir(hdev);
+	} else {
+		u8 status = MGMT_STATUS_NOT_POWERED;
+		mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+	}
 
-	BT_DBG("%d", index);
+	err = new_settings(hdev, match.sk);
 
-	mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
+	if (match.sk)
+		sock_put(match.sk);
 
-	return mgmt_event(MGMT_EV_INDEX_REMOVED, index, NULL, 0, NULL);
+	return err;
 }
 
-struct cmd_lookup {
-	u8 val;
-	struct sock *sk;
-};
-
-static void mode_rsp(struct pending_cmd *cmd, void *data)
+int mgmt_set_powered_failed(struct hci_dev *hdev, int err)
 {
-	struct mgmt_mode *cp = cmd->param;
-	struct cmd_lookup *match = data;
+	struct pending_cmd *cmd;
+	u8 status;
 
-	if (cp->val != match->val)
-		return;
+	cmd = mgmt_pending_find(MGMT_OP_SET_POWERED, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	send_mode_rsp(cmd->sk, cmd->opcode, cmd->index, cp->val);
+	if (err == -ERFKILL)
+		status = MGMT_STATUS_RFKILLED;
+	else
+		status = MGMT_STATUS_FAILED;
 
-	list_del(&cmd->list);
+	err = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);
 
-	if (match->sk == NULL) {
-		match->sk = cmd->sk;
-		sock_hold(match->sk);
-	}
+	mgmt_pending_remove(cmd);
 
-	mgmt_pending_free(cmd);
+	return err;
 }
 
-int mgmt_powered(u16 index, u8 powered)
+int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { powered, NULL };
-	int ret;
-
-	BT_DBG("hci%u %d", index, powered);
-
-	mgmt_pending_foreach(MGMT_OP_SET_POWERED, index, mode_rsp, &match);
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	if (!powered) {
-		u8 status = ENETDOWN;
-		mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
+	if (discoverable) {
+		if (!test_and_set_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			changed = true;
 	}
 
-	ev.val = powered;
+	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev, settings_rsp,
+			     &match);
 
-	ret = mgmt_event(MGMT_EV_POWERED, index, &ev, sizeof(ev), match.sk);
+	if (changed)
+		err = new_settings(hdev, match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
 
-	return ret;
+	return err;
 }
 
-int mgmt_discoverable(u16 index, u8 discoverable)
+int mgmt_connectable(struct hci_dev *hdev, u8 connectable)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { discoverable, NULL };
-	int ret;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, index, mode_rsp, &match);
+	if (connectable) {
+		if (!test_and_set_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
+	}
 
-	ev.val = discoverable;
+	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev, settings_rsp,
+			     &match);
 
-	ret = mgmt_event(MGMT_EV_DISCOVERABLE, index, &ev, sizeof(ev),
-								match.sk);
+	if (changed)
+		err = new_settings(hdev, match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
 
-	return ret;
+	return err;
 }
 
-int mgmt_connectable(u16 index, u8 connectable)
+int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { connectable, NULL };
-	int ret;
-
-	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, index, mode_rsp, &match);
+	u8 mgmt_err = mgmt_status(status);
 
-	ev.val = connectable;
+	if (scan & SCAN_PAGE)
+		mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	ret = mgmt_event(MGMT_EV_CONNECTABLE, index, &ev, sizeof(ev), match.sk);
+	if (scan & SCAN_INQUIRY)
+		mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	if (match.sk)
-		sock_put(match.sk);
-
-	return ret;
+	return 0;
 }
 
-int mgmt_new_key(u16 index, struct link_key *key, u8 bonded)
+int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key, bool persistent)
 {
-	struct mgmt_ev_new_key *ev;
-	int err, total;
-
-	total = sizeof(struct mgmt_ev_new_key) + key->dlen;
-	ev = kzalloc(total, GFP_ATOMIC);
-	if (!ev)
-		return -ENOMEM;
-
-	bacpy(&ev->key.bdaddr, &key->bdaddr);
-	ev->key.addr_type = key->addr_type;
-	ev->key.key_type = key->key_type;
-	memcpy(ev->key.val, key->val, 16);
-	ev->key.pin_len = key->pin_len;
-	ev->key.auth = key->auth;
-	ev->store_hint = bonded;
-	ev->key.dlen = key->dlen;
-
-	memcpy(ev->key.data, key->data, key->dlen);
+	struct mgmt_ev_new_link_key ev;
 
-	err = mgmt_event(MGMT_EV_NEW_KEY, index, ev, total, NULL);
+	memset(&ev, 0, sizeof(ev));
 
-	kfree(ev);
+	ev.store_hint = persistent;
+	bacpy(&ev.key.addr.bdaddr, &key->bdaddr);
+	ev.key.addr.type = MGMT_ADDR_BREDR;
+	ev.key.type = key->type;
+	memcpy(ev.key.val, key->val, 16);
+	ev.key.pin_len = key->pin_len;
 
-	return err;
+	return mgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le)
+int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent)
 {
-	struct mgmt_ev_connected ev;
-	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
+	struct mgmt_ev_new_long_term_key ev;
 
-	BT_DBG("hci%u", index);
-
-	hdev = hci_dev_get(index);
+	memset(&ev, 0, sizeof(ev));
 
-	if (!hdev)
-		return -ENODEV;
+	ev.store_hint = persistent;
+	bacpy(&ev.key.addr.bdaddr, &key->bdaddr);
+	ev.key.addr.type = key->bdaddr_type;
+	ev.key.authenticated = key->authenticated;
+	ev.key.enc_size = key->enc_size;
+	ev.key.ediv = key->ediv;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.le = le;
+	if (key->type == HCI_SMP_LTK)
+		ev.key.master = 1;
 
-	cmd = mgmt_pending_find(MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index);
-	if (cmd) {
-		BT_ERR("mgmt_connected remove mgmt pending white_list");
-		mgmt_pending_remove(cmd);
-	}
+	memcpy(ev.key.rand, key->rand, sizeof(key->rand));
+	memcpy(ev.key.val, key->val, sizeof(key->val));
 
-	return mgmt_event(MGMT_EV_CONNECTED, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev),
+			  NULL);
 }
 
-int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
-						u16 latency, u16 timeout)
+int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			  u8 *dev_class)
 {
-	struct mgmt_ev_le_conn_params ev;
+	char buf[512];
+	struct mgmt_ev_device_connected *ev = (void *) buf;
+	u16 eir_len = 0;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.interval = interval;
-	ev.latency = latency;
-	ev.timeout = timeout;
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+
+	ev->flags = __cpu_to_le32(flags);
 
-	return mgmt_event(MGMT_EV_LE_CONN_PARAMS, index, &ev, sizeof(ev),
-									NULL);
+	if (name_len > 0)
+		eir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE,
+					  name, name_len);
+
+	if (dev_class && memcmp(dev_class, "\0\0\0", 3) != 0)
+		eir_len = eir_append_data(ev->eir, eir_len,
+					  EIR_CLASS_OF_DEV, dev_class, 3);
+
+	put_unaligned_le16(eir_len, &ev->eir_len);
+
+	return mgmt_event(MGMT_EV_DEVICE_CONNECTED, hdev, buf,
+			  sizeof(*ev) + eir_len, NULL);
 }
 
 static void disconnect_rsp(struct pending_cmd *cmd, void *data)
@@ -2948,9 +2993,11 @@
 	struct sock **sk = data;
 	struct mgmt_rp_disconnect rp;
 
-	bacpy(&rp.bdaddr, &cp->bdaddr);
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
-	cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, &rp, sizeof(rp));
+	cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, 0, &rp,
+		     sizeof(rp));
 
 	*sk = cmd->sk;
 	sock_hold(*sk);
@@ -2958,250 +3005,402 @@
 	mgmt_pending_remove(cmd);
 }
 
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason)
+static void unpair_device_rsp(struct pending_cmd *cmd, void *data)
+{
+	struct hci_dev *hdev = data;
+	struct mgmt_cp_unpair_device *cp = cmd->param;
+	struct mgmt_rp_unpair_device rp;
+
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
+
+	device_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);
+
+	cmd_complete(cmd->sk, cmd->index, cmd->opcode, 0, &rp, sizeof(rp));
+
+	mgmt_pending_remove(cmd);
+}
+
+int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 link_type, u8 addr_type)
 {
-	struct mgmt_ev_disconnected ev;
+	struct mgmt_addr_info ev;
 	struct sock *sk = NULL;
 	int err;
 
+	mgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);
+
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.reason = reason;
+	ev.type = link_to_mgmt(link_type, addr_type);
 
-	err = mgmt_event(MGMT_EV_DISCONNECTED, index, &ev, sizeof(ev), sk);
+	err = mgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev),
+			 sk);
 
 	if (sk)
-		sock_put(sk);
+	  sock_put(sk);
 
-	mgmt_pending_foreach(MGMT_OP_DISCONNECT, index, disconnect_rsp, &sk);
+	mgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,
+			     hdev);
 
 	return err;
 }
 
-int mgmt_disconnect_failed(u16 index)
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 link_type, u8 addr_type, u8 status)
 {
+	struct mgmt_rp_disconnect rp;
 	struct pending_cmd *cmd;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, index);
+	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	err = cmd_status(cmd->sk, index, MGMT_OP_DISCONNECT, EIO);
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = link_to_mgmt(link_type, addr_type);
+
+	err = cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
+	mgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,
+									hdev);
 	return err;
 }
 
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			u8 addr_type, u8 status)
 {
 	struct mgmt_ev_connect_failed ev;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.status = mgmt_status(status);
 
-	return mgmt_event(MGMT_EV_CONNECT_FAILED, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr)
+int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)
 {
 	struct mgmt_ev_pin_code_request ev;
 
-	BT_DBG("hci%u", index);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = MGMT_ADDR_BREDR;
+	ev.secure = secure;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.secure = 0;
-
-	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
 }
 
-int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				 u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, index);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = MGMT_ADDR_BREDR;
 
-	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_REPLY, &rp,
-								sizeof(rp));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, index);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = MGMT_ADDR_BREDR;
 
-	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_NEG_REPLY, &rp,
-								sizeof(rp));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_user_confirm_request(u16 index, u8 event,
-					bdaddr_t *bdaddr, __le32 value)
+int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 confirm_hint)
 {
 	struct mgmt_ev_user_confirm_request ev;
-	struct hci_conn *conn = NULL;
-	struct hci_dev *hdev;
-	u8 loc_cap, rem_cap, loc_mitm, rem_mitm;
 
-	BT_DBG("hci%u", index);
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.confirm_hint = confirm_hint;
+	put_unaligned_le32(value, &ev.value);
 
-	if (!hdev)
-		return -ENODEV;
+	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
+}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+						u8 link_type, u8 addr_type)
+{
+	struct mgmt_ev_user_passkey_request ev;
 
-	ev.auto_confirm = 0;
+	BT_DBG("%s", hdev->name);
 
-	if (!conn || event != HCI_EV_USER_CONFIRM_REQUEST)
-		goto no_auto_confirm;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
 
-	loc_cap = (conn->io_capability == 0x04) ? 0x01 : conn->io_capability;
-	rem_cap = conn->remote_cap;
-	loc_mitm = conn->auth_type & 0x01;
-	rem_mitm = conn->remote_auth & 0x01;
+	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
+}
 
-	if ((conn->auth_type & HCI_AT_DEDICATED_BONDING) &&
-			conn->auth_initiator && rem_cap == 0x03)
-		ev.auto_confirm = 1;
-	else if (loc_cap == 0x01 && (rem_cap == 0x00 || rem_cap == 0x03)) {
-		if (!loc_mitm && !rem_mitm)
-			value = 0;
-		goto no_auto_confirm;
-	}
+static int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					u8 link_type, u8 addr_type, u8 status,
+					u8 opcode)
+{
+	struct pending_cmd *cmd;
+	struct mgmt_rp_user_confirm_reply rp;
+	int err;
 
-	/* Show bonding dialog if neither side requires no bonding */
-	if ((conn->auth_type > 0x01) && (conn->remote_auth > 0x01)) {
-		if (!loc_mitm && !rem_mitm)
-			value = 0;
-		goto no_auto_confirm;
-	}
+	cmd = mgmt_pending_find(opcode, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	if ((!loc_mitm || rem_cap == 0x03) && (!rem_mitm || loc_cap == 0x03))
-		ev.auto_confirm = 1;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = link_to_mgmt(link_type, addr_type);
+	err = cmd_complete(cmd->sk, hdev->id, opcode, mgmt_status(status),
+			   &rp, sizeof(rp));
 
-no_auto_confirm:
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.event = event;
-	put_unaligned_le32(value, &ev.value);
+	mgmt_pending_remove(cmd);
+
+	return err;
+}
 
-	hci_dev_put(hdev);
+int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_CONFIRM_REPLY);
+}
 
-	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_CONFIRM_NEG_REPLY);
 }
 
-int mgmt_user_passkey_request(u16 index, bdaddr_t *bdaddr)
+int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status)
 {
-	struct mgmt_ev_user_passkey_request ev;
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_PASSKEY_REPLY);
+}
 
-	BT_DBG("hci%u", index);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_PASSKEY_NEG_REPLY);
+}
 
-	bacpy(&ev.bdaddr, bdaddr);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, u8 status)
+{
+	struct mgmt_ev_auth_failed ev;
 
-	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.status = mgmt_status(status);
+
+	return mgmt_event(MGMT_EV_AUTH_FAILED, hdev, &ev, sizeof(ev), NULL);
 }
 
-static int confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status,
-								u8 opcode)
+int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)
 {
-	struct pending_cmd *cmd;
-	struct mgmt_rp_user_confirm_reply rp;
-	int err;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	cmd = mgmt_pending_find(opcode, index);
-	if (!cmd)
-		return -ENOENT;
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
+		mgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,
+				     cmd_status_rsp, &mgmt_err);
+		return 0;
+	}
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
-	err = cmd_complete(cmd->sk, index, opcode, &rp, sizeof(rp));
+	if (test_bit(HCI_AUTH, &hdev->flags)) {
+		if (!test_and_set_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+			changed = true;
+	}
 
-	mgmt_pending_remove(cmd);
+	mgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,
+			     &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
 
 	return err;
 }
 
-int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+static int clear_eir(struct hci_dev *hdev)
+{
+	struct hci_cp_write_eir cp;
+
+	if (!(hdev->features[6] & LMP_EXT_INQ))
+		return 0;
+
+	memset(hdev->eir, 0, sizeof(hdev->eir));
+
+	memset(&cp, 0, sizeof(cp));
+
+	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+}
+
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 {
-	return confirm_reply_complete(index, bdaddr, status,
-						MGMT_OP_USER_CONFIRM_REPLY);
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
+
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
+
+		if (enable && test_and_clear_bit(HCI_SSP_ENABLED,
+						 &hdev->dev_flags))
+			err = new_settings(hdev, NULL);
+
+		mgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,
+				     &mgmt_err);
+
+		return err;
+	}
+
+	if (enable) {
+		if (!test_and_set_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+			changed = true;
+	}
+
+	mgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
+
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		update_eir(hdev);
+	else
+		clear_eir(hdev);
+
+	return err;
 }
 
-int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+static void class_rsp(struct pending_cmd *cmd, void *data)
 {
-	return confirm_reply_complete(index, bdaddr, status,
-					MGMT_OP_USER_CONFIRM_NEG_REPLY);
+	struct cmd_lookup *match = data;
+
+	cmd_complete(cmd->sk, cmd->index, cmd->opcode, match->mgmt_status,
+		     match->hdev->dev_class, 3);
+
+	list_del(&cmd->list);
+
+	if (match->sk == NULL) {
+		match->sk = cmd->sk;
+		sock_hold(match->sk);
+	}
+
+	mgmt_pending_free(cmd);
 }
 
-int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+				   u8 status)
 {
-	struct mgmt_ev_auth_failed ev;
+	struct cmd_lookup match = { NULL, hdev, mgmt_status(status) };
+	int err = 0;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	clear_bit(HCI_PENDING_CLASS, &hdev->dev_flags);
+
+	mgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, class_rsp, &match);
+	mgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, class_rsp, &match);
+	mgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, class_rsp, &match);
+
+	if (!status)
+		err = mgmt_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev, dev_class,
+				 3, NULL);
+
+	if (match.sk)
+		sock_put(match.sk);
 
-	return mgmt_event(MGMT_EV_AUTH_FAILED, index, &ev, sizeof(ev), NULL);
+	return err;
 }
 
-int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status)
+int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)
 {
 	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
 	struct mgmt_cp_set_local_name ev;
-	int err;
+	bool changed = false;
+	int err = 0;
+
+	if (memcmp(name, hdev->dev_name, sizeof(hdev->dev_name)) != 0) {
+		memcpy(hdev->dev_name, name, sizeof(hdev->dev_name));
+		changed = true;
+	}
 
 	memset(&ev, 0, sizeof(ev));
 	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
+	memcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);
 
-	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, index);
+	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);
 	if (!cmd)
 		goto send_event;
 
+	/* Always assume that either the short or the complete name has
+	 * changed if there was a pending mgmt command */
+	changed = true;
+
 	if (status) {
-		err = cmd_status(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, EIO);
+		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,
+				 mgmt_status(status));
 		goto failed;
 	}
 
-	hdev = hci_dev_get(index);
-	if (hdev) {
-		update_eir(hdev);
-		hci_dev_put(hdev);
-	}
-
-	err = cmd_complete(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, &ev,
-								sizeof(ev));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0, &ev,
+			   sizeof(ev));
 	if (err < 0)
 		goto failed;
 
 send_event:
-	err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, index, &ev, sizeof(ev),
-							cmd ? cmd->sk : NULL);
+	if (changed)
+		err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev,
+				 sizeof(ev), cmd ? cmd->sk : NULL);
+
+	update_eir(hdev);
 
 failed:
 	if (cmd)
@@ -3209,29 +3408,30 @@
 	return err;
 }
 
-int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
-								u8 status)
+int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+					    u8 *randomizer, u8 status)
 {
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("hci%u status %u", index, status);
+	BT_DBG("%s status %u", hdev->name, status);
 
-	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index);
+	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 	if (!cmd)
 		return -ENOENT;
 
 	if (status) {
-		err = cmd_status(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-									EIO);
+		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 mgmt_status(status));
 	} else {
 		struct mgmt_rp_read_local_oob_data rp;
 
 		memcpy(rp.hash, hash, sizeof(rp.hash));
 		memcpy(rp.randomizer, randomizer, sizeof(rp.randomizer));
 
-		err = cmd_complete(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-							&rp, sizeof(rp));
+		err = cmd_complete(cmd->sk, hdev->id,
+				   MGMT_OP_READ_LOCAL_OOB_DATA, 0, &rp,
+				   sizeof(rp));
 	}
 
 	mgmt_pending_remove(cmd);
@@ -3239,182 +3439,198 @@
 	return err;
 }
 
-void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
-		u16 handle, u8 status)
+int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 {
-	struct mgmt_ev_rssi_update ev;
-	struct hci_conn *conn;
-	struct hci_dev *hdev;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	if (status)
-		return;
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
 
-	hdev = hci_dev_get(index);
-	conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (enable && test_and_clear_bit(HCI_LE_ENABLED,
+						 &hdev->dev_flags))
+		  err = new_settings(hdev, NULL);
 
-	if (!conn)
-		return;
+		mgmt_pending_foreach(MGMT_OP_SET_LE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	BT_DBG("rssi_update_thresh_exceed : %d ",
-		   conn->rssi_update_thresh_exceed);
-	BT_DBG("RSSI Threshold : %d , recvd RSSI : %d ",
-			conn->rssi_threshold, rssi);
-
-	if (conn->rssi_update_thresh_exceed == 1) {
-		BT_DBG("rssi_update_thresh_exceed == 1");
-		if (rssi > conn->rssi_threshold) {
-			memset(&ev, 0, sizeof(ev));
-			bacpy(&ev.bdaddr, bdaddr);
-			ev.rssi = rssi;
-			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
-				sizeof(ev), NULL);
-		} else {
-			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
-				conn->rssi_update_interval,
-				conn->rssi_update_thresh_exceed);
-		}
+		return err;
+	}
+
+	if (enable) {
+		if (!test_and_set_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+			changed = true;
 	} else {
-		BT_DBG("rssi_update_thresh_exceed == 0");
-		if (rssi < conn->rssi_threshold) {
-			memset(&ev, 0, sizeof(ev));
-			bacpy(&ev.bdaddr, bdaddr);
-			ev.rssi = rssi;
-			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
-				sizeof(ev), NULL);
-		} else {
-			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
-				conn->rssi_update_interval,
-				conn->rssi_update_thresh_exceed);
-		}
+		if (test_and_clear_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+			changed = true;
 	}
+
+	mgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
+
+	return err;
 }
 
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name, u8
+		      ssp, u8 *eir, u16 eir_len)
+{
+	char buf[512];
+	struct mgmt_ev_device_found *ev = (void *) buf;
+	size_t ev_size;
 
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
-			u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir)
-{
-	struct mgmt_ev_device_found ev;
-	struct hci_dev *hdev;
-	int err;
+	/* Leave 5 bytes for a potential CoD field */
+	if (sizeof(*ev) + eir_len + 5 > sizeof(buf))
+		return -EINVAL;
 
-	BT_DBG("le: %d", le);
+	memset(buf, 0, sizeof(buf));
 
-	memset(&ev, 0, sizeof(ev));
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+	ev->rssi = rssi;
+	if (cfm_name)
+		ev->flags[0] |= MGMT_DEV_FOUND_CONFIRM_NAME;
+	if (!ssp)
+		ev->flags[0] |= MGMT_DEV_FOUND_LEGACY_PAIRING;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.rssi = rssi;
-	ev.type = type;
-	ev.le = le;
+	if (eir_len > 0)
+		memcpy(ev->eir, eir, eir_len);
 
-	if (dev_class)
-		memcpy(ev.dev_class, dev_class, sizeof(ev.dev_class));
+	if (dev_class && !eir_has_data_type(ev->eir, eir_len, EIR_CLASS_OF_DEV))
+		eir_len = eir_append_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,
+					  dev_class, 3);
 
-	if (eir && eir_len)
-		memcpy(ev.eir, eir, eir_len);
+	put_unaligned_le16(eir_len, &ev->eir_len);
 
-	err = mgmt_event(MGMT_EV_DEVICE_FOUND, index, &ev, sizeof(ev), NULL);
+	ev_size = sizeof(*ev) + eir_len;
 
-	if (err < 0)
-		return err;
+	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, ev_size, NULL);
+}
 
-	hdev = hci_dev_get(index);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, s8 rssi, u8 *name, u8 name_len)
+{
+	struct mgmt_ev_device_found *ev;
+	char buf[sizeof(*ev) + HCI_MAX_NAME_LENGTH + 2];
+	u16 eir_len;
 
-	if (!hdev)
-		return 0;
+	ev = (struct mgmt_ev_device_found *) buf;
 
-	if (hdev->disco_state == SCAN_IDLE)
-		goto done;
+	memset(buf, 0, sizeof(buf));
 
-	hdev->disco_int_count++;
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+	ev->rssi = rssi;
 
-	if (hdev->disco_int_count >= hdev->disco_int_phase) {
-		/* Inquiry scan for General Discovery LAP */
-		struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
-		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-
-		hdev->disco_int_phase *= 2;
-		hdev->disco_int_count = 0;
-		if (hdev->disco_state == SCAN_LE) {
-			/* cancel LE scan */
-			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-					sizeof(le_cp), &le_cp);
-			/* start BR scan */
-			cp.num_rsp = (u8) hdev->disco_int_phase;
-			hci_send_cmd(hdev, HCI_OP_INQUIRY,
-					sizeof(cp), &cp);
-			hdev->disco_state = SCAN_BR;
-			del_timer_sync(&hdev->disco_le_timer);
-		}
-	}
+	eir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,
+				  name_len);
 
-done:
-	hci_dev_put(hdev);
-	return 0;
-}
+	put_unaligned_le16(eir_len, &ev->eir_len);
 
+	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev,
+			  sizeof(*ev) + eir_len, NULL);
+}
 
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name)
+int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status)
 {
-	struct mgmt_ev_remote_name ev;
+	struct pending_cmd *cmd;
+	u8 type;
+	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
-	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
+	cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
+	if (!cmd)
+		return -ENOENT;
+
+	type = hdev->discovery.type;
 
-	return mgmt_event(MGMT_EV_REMOTE_NAME, index, &ev, sizeof(ev), NULL);
+	err = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),
+			   &type, sizeof(type));
+	mgmt_pending_remove(cmd);
+
+	return err;
 }
 
-int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status)
 {
-	struct mgmt_ev_encrypt_change ev;
+	struct pending_cmd *cmd;
+	int err;
 
-	BT_DBG("hci%u", index);
+	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	err = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),
+			   &hdev->discovery.type, sizeof(hdev->discovery.type));
+	mgmt_pending_remove(cmd);
 
-	return mgmt_event(MGMT_EV_ENCRYPT_CHANGE, index, &ev, sizeof(ev),
-									NULL);
+	return err;
 }
 
-int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3])
+int mgmt_discovering(struct hci_dev *hdev, u8 discovering)
 {
-	struct mgmt_ev_remote_class ev;
+	struct mgmt_ev_discovering ev;
+	struct pending_cmd *cmd;
 
-	memset(&ev, 0, sizeof(ev));
+	BT_DBG("%s discovering %u", hdev->name, discovering);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	memcpy(ev.dev_class, dev_class, 3);
+	if (discovering)
+		cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
+	else
+		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
+
+	if (cmd != NULL) {
+		u8 type = hdev->discovery.type;
+
+		cmd_complete(cmd->sk, hdev->id, cmd->opcode, 0, &type,
+			     sizeof(type));
+		mgmt_pending_remove(cmd);
+	}
+
+	memset(&ev, 0, sizeof(ev));
+	ev.type = hdev->discovery.type;
+	ev.discovering = discovering;
 
-	return mgmt_event(MGMT_EV_REMOTE_CLASS, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
-							u16 sub_ver)
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct mgmt_ev_remote_version ev;
+	struct pending_cmd *cmd;
+	struct mgmt_ev_device_blocked ev;
 
-	memset(&ev, 0, sizeof(ev));
+	cmd = mgmt_pending_find(MGMT_OP_BLOCK_DEVICE, hdev);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.lmp_ver = ver;
-	ev.manufacturer = mnf;
-	ev.lmp_subver = sub_ver;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = type;
 
-	return mgmt_event(MGMT_EV_REMOTE_VERSION, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &ev, sizeof(ev),
+			  cmd ? cmd->sk : NULL);
 }
 
-int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8])
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct mgmt_ev_remote_features ev;
+	struct pending_cmd *cmd;
+	struct mgmt_ev_device_unblocked ev;
 
-	memset(&ev, 0, sizeof(ev));
+	cmd = mgmt_pending_find(MGMT_OP_UNBLOCK_DEVICE, hdev);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	memcpy(ev.features, features, sizeof(ev.features));
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = type;
 
-	return mgmt_event(MGMT_EV_REMOTE_FEATURES, index, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &ev, sizeof(ev),
+			  cmd ? cmd->sk : NULL);
 }
+
+module_param(enable_hs, bool, 0644);
+MODULE_PARM_DESC(enable_hs, "Enable High Speed support");
+
+module_param(enable_le, bool, 0644);
+MODULE_PARM_DESC(enable_le, "Enable Low Energy support");
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/core.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/core.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    RFCOMM implementation for Linux Bluetooth stack (BlueZ).
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>
    Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>
 
@@ -40,7 +39,6 @@
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
-#include <linux/interrupt.h>
 
 #include <net/sock.h>
 #include <linux/uaccess.h>
@@ -52,9 +50,6 @@
 #include <net/bluetooth/rfcomm.h>
 
 #define VERSION "1.11"
-/* 1 Byte DLCI, 1 Byte Control filed, 2 Bytes Length, 1 Byte for Credits,
- * 1 Byte FCS */
-#define RFCOMM_HDR_SIZE 6
 
 static bool disable_cfc;
 static bool l2cap_ertm;
@@ -67,7 +62,6 @@
 #define rfcomm_lock()	mutex_lock(&rfcomm_mutex)
 #define rfcomm_unlock()	mutex_unlock(&rfcomm_mutex)
 
-static unsigned long rfcomm_event;
 
 static LIST_HEAD(session_list);
 
@@ -87,9 +81,7 @@
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err,
-							u8 channel,
-							struct rfcomm_dlc *d);
+							int *err);
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst);
 static void rfcomm_session_del(struct rfcomm_session *s);
 
@@ -123,37 +115,15 @@
 #define __get_rpn_stop_bits(line) (((line) >> 2) & 0x1)
 #define __get_rpn_parity(line)    (((line) >> 3) & 0x7)
 
-struct rfcomm_sock_release_work {
-	struct work_struct work;
-	struct socket *sock;
-	int state;
-};
-
 static inline void rfcomm_schedule(void)
 {
 	if (!rfcomm_thread)
 		return;
-	set_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 	wake_up_process(rfcomm_thread);
 }
 
 static inline void rfcomm_session_put(struct rfcomm_session *s)
 {
-	bool match = false;
-	struct rfcomm_session *sess;
-	struct list_head *p, *n;
-	list_for_each_safe(p, n, &session_list) {
-		sess = list_entry(p, struct rfcomm_session, list);
-		if (s == sess) {
-			match = true;
-			break;
-		}
-	}
-	if (!match) {
-		BT_ERR("session already freed previously");
-		dump_stack();
-		return;
-	}
 	if (atomic_dec_and_test(&s->refcnt))
 		rfcomm_session_del(s);
 }
@@ -260,10 +230,11 @@
 static inline int rfcomm_check_security(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
+
 	__u8 auth_type;
 
 	switch (d->sec_level) {
-	case BT_SECURITY_VERY_HIGH:
 	case BT_SECURITY_HIGH:
 		auth_type = HCI_AT_GENERAL_BONDING_MITM;
 		break;
@@ -275,8 +246,7 @@
 		break;
 	}
 
-	return hci_conn_security(l2cap_pi(sk)->conn->hcon, d->sec_level,
-								auth_type);
+	return hci_conn_security(conn->hcon, d->sec_level, auth_type);
 }
 
 static void rfcomm_session_timeout(unsigned long arg)
@@ -407,13 +377,11 @@
 static struct rfcomm_dlc *rfcomm_dlc_get(struct rfcomm_session *s, u8 dlci)
 {
 	struct rfcomm_dlc *d;
-	struct list_head *p;
 
-	list_for_each(p, &s->dlcs) {
-		d = list_entry(p, struct rfcomm_dlc, list);
+	list_for_each_entry(d, &s->dlcs, list)
 		if (d->dlci == dlci)
 			return d;
-	}
+
 	return NULL;
 }
 
@@ -434,31 +402,31 @@
 
 	s = rfcomm_session_get(src, dst);
 	if (!s) {
-		s = rfcomm_session_create(src, dst,
-						d->sec_level, &err, channel, d);
+		s = rfcomm_session_create(src, dst, d->sec_level, &err);
 		if (!s)
 			return err;
-	} else {
-		dlci = __dlci(!s->initiator, channel);
+	}
 
-		/* Check if DLCI already exists */
-		if (rfcomm_dlc_get(s, dlci))
-			return -EBUSY;
+	dlci = __dlci(!s->initiator, channel);
 
-		rfcomm_dlc_clear_state(d);
+	/* Check if DLCI already exists */
+	if (rfcomm_dlc_get(s, dlci))
+		return -EBUSY;
 
-		d->dlci     = dlci;
-		d->addr     = __addr(s->initiator, dlci);
-		d->priority = 7;
+	rfcomm_dlc_clear_state(d);
 
-		d->state = BT_CONFIG;
-		rfcomm_dlc_link(s, d);
+	d->dlci     = dlci;
+	d->addr     = __addr(s->initiator, dlci);
+	d->priority = 7;
+
+	d->state = BT_CONFIG;
+	rfcomm_dlc_link(s, d);
 
-		d->out = 1;
+	d->out = 1;
+
+	d->mtu = s->mtu;
+	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 
-		d->mtu = s->mtu;
-		d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
-	}
 	if (s->state == BT_CONNECTED) {
 		if (rfcomm_check_security(d))
 			rfcomm_send_pn(s, 1, d);
@@ -494,6 +462,7 @@
 
 	switch (d->state) {
 	case BT_CONNECT:
+	case BT_CONFIG:
 		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
 			rfcomm_schedule();
@@ -654,25 +623,9 @@
 	return s;
 }
 
-static void rfcomm_sock_release_worker(struct work_struct *work)
-{
-	struct rfcomm_sock_release_work *release_work =
-		container_of(work, struct rfcomm_sock_release_work, work);
-
-	BT_DBG("sock %p", release_work->sock);
-
-	sock_release(release_work->sock);
-	if (release_work->state != BT_LISTEN)
-		module_put(THIS_MODULE);
-
-	kfree(release_work);
-}
-
 static void rfcomm_session_del(struct rfcomm_session *s)
 {
 	int state = s->state;
-	struct socket *sock = s->sock;
-	struct rfcomm_sock_release_work *release_work;
 
 	BT_DBG("session %p state %ld", s, s->state);
 
@@ -682,19 +635,11 @@
 		rfcomm_send_disc(s, 0);
 
 	rfcomm_session_clear_timer(s);
-
+	sock_release(s->sock);
 	kfree(s);
 
-	release_work = kzalloc(sizeof(*release_work), GFP_ATOMIC);
-	if (release_work) {
-		INIT_WORK(&release_work->work, rfcomm_sock_release_worker);
-		release_work->sock = sock;
-		release_work->state = state;
-
-		if (!schedule_work(&release_work->work))
-			kfree(release_work);
-	}
-
+	if (state != BT_LISTEN)
+		module_put(THIS_MODULE);
 }
 
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst)
@@ -738,15 +683,12 @@
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err,
-							u8 channel,
-							struct rfcomm_dlc *d)
+							int *err)
 {
 	struct rfcomm_session *s = NULL;
 	struct sockaddr_l2 addr;
 	struct socket *sock;
 	struct sock *sk;
-	u8 dlci;
 
 	BT_DBG("%s %s", batostr(src), batostr(dst));
 
@@ -765,10 +707,10 @@
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->imtu = l2cap_mtu;
-	l2cap_pi(sk)->sec_level = sec_level;
+	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
+	l2cap_pi(sk)->chan->sec_level = sec_level;
 	if (l2cap_ertm)
-		l2cap_pi(sk)->mode = L2CAP_MODE_ERTM;
+		l2cap_pi(sk)->chan->mode = L2CAP_MODE_ERTM;
 	release_sock(sk);
 
 	s = rfcomm_session_add(sock, BT_BOUND);
@@ -783,30 +725,11 @@
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = cpu_to_le16(RFCOMM_PSM);
 	addr.l2_cid    = 0;
-	dlci = __dlci(!s->initiator, channel);
-
-	/* Check if DLCI already exists */
-	if (rfcomm_dlc_get(s, dlci))
-		return NULL;
-
-	rfcomm_dlc_clear_state(d);
-
-	d->dlci     = dlci;
-	d->addr     = __addr(s->initiator, dlci);
-	d->priority = 7;
-
-	d->state = BT_CONFIG;
-	rfcomm_dlc_link(s, d);
-
-	d->out = 1;
-
-	d->mtu = s->mtu;
-	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 	*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
 	if (*err == 0 || *err == -EINPROGRESS)
 		return s;
-	BT_ERR("error ret is %d, going to delete session", *err);
-	rfcomm_dlc_unlink(d);
+
+	rfcomm_session_del(s);
 	return NULL;
 
 failed:
@@ -826,7 +749,6 @@
 /* ---- RFCOMM frame sending ---- */
 static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 {
-	struct socket *sock = s->sock;
 	struct kvec iv = { data, len };
 	struct msghdr msg;
 
@@ -834,7 +756,14 @@
 
 	memset(&msg, 0, sizeof(msg));
 
-	return kernel_sendmsg(sock, &msg, &iv, 1, len);
+	return kernel_sendmsg(s->sock, &msg, &iv, 1, len);
+}
+
+static int rfcomm_send_cmd(struct rfcomm_session *s, struct rfcomm_cmd *cmd)
+{
+	BT_DBG("%p cmd %u", s, cmd->ctrl);
+
+	return rfcomm_send_frame(s, (void *) cmd, sizeof(*cmd));
 }
 
 static int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci)
@@ -848,7 +777,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_ua(struct rfcomm_session *s, u8 dlci)
@@ -862,7 +791,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci)
@@ -876,7 +805,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_queue_disc(struct rfcomm_dlc *d)
@@ -912,7 +841,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_nsc(struct rfcomm_session *s, int cr, u8 type)
@@ -1235,12 +1164,18 @@
 			break;
 
 		case BT_DISCONN:
-			/* When socket is closed and we are not RFCOMM
-			 * initiator rfcomm_process_rx already calls
-			 * rfcomm_session_put() */
-			if (s->sock->sk->sk_state != BT_CLOSED)
-				if (list_empty(&s->dlcs))
-					rfcomm_session_put(s);
+			/* rfcomm_session_put is called later so don't do
+			 * anything here otherwise we will mess up the session
+			 * reference counter:
+			 *
+			 * (a) when we are the initiator dlc_unlink will drive
+			 * the reference counter to 0 (there is no initial put
+			 * after session_add)
+			 *
+			 * (b) when we are not the initiator rfcomm_rx_process
+			 * will explicitly call put to balance the initial hold
+			 * done after session add.
+			 */
 			break;
 		}
 	}
@@ -1316,6 +1251,7 @@
 void rfcomm_dlc_accept(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 
 	BT_DBG("dlc %p", d);
 
@@ -1329,7 +1265,7 @@
 	rfcomm_dlc_unlock(d);
 
 	if (d->role_switch)
-		hci_conn_switch_role(l2cap_pi(sk)->conn->hcon, 0x00);
+		hci_conn_switch_role(conn->hcon, 0x00);
 
 	rfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);
 }
@@ -1877,6 +1813,11 @@
 			continue;
 		}
 
+		if (test_bit(RFCOMM_ENC_DROP, &d->flags)) {
+			__rfcomm_dlc_close(d, ECONNREFUSED);
+			continue;
+		}
+
 		if (test_and_clear_bit(RFCOMM_AUTH_ACCEPT, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (d->out) {
@@ -1967,10 +1908,9 @@
 		rfcomm_session_hold(s);
 
 		/* We should adjust MTU on incoming sessions.
-		 * L2CAP MTU minus UIH header and FCS.
-		 * Need to accomodate 1 Byte credits information */
-		s->mtu = min(l2cap_pi(nsock->sk)->omtu,
-				l2cap_pi(nsock->sk)->imtu) - RFCOMM_HDR_SIZE;
+		 * L2CAP MTU minus UIH header and FCS. */
+		s->mtu = min(l2cap_pi(nsock->sk)->chan->omtu,
+				l2cap_pi(nsock->sk)->chan->imtu) - 5;
 
 		rfcomm_schedule();
 	} else
@@ -1988,9 +1928,8 @@
 		s->state = BT_CONNECT;
 
 		/* We can adjust MTU on outgoing sessions.
-		 * L2CAP MTU minus UIH header, Credits and FCS. */
-		s->mtu = min(l2cap_pi(sk)->omtu, l2cap_pi(sk)->imtu) -
-						RFCOMM_HDR_SIZE;
+		 * L2CAP MTU minus UIH header and FCS. */
+		s->mtu = min(l2cap_pi(sk)->chan->omtu, l2cap_pi(sk)->chan->imtu) - 5;
 
 		rfcomm_send_sabm(s, 0);
 		break;
@@ -2073,7 +2012,7 @@
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->imtu = l2cap_mtu;
+	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
 	release_sock(sk);
 
 	/* Start listening on the socket */
@@ -2116,19 +2055,18 @@
 
 	rfcomm_add_listener(BDADDR_ANY);
 
-	while (!kthread_should_stop()) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
-			/* No pending events. Let's sleep.
-			 * Incoming connections and data will wake us up. */
-			schedule();
-		}
-		set_current_state(TASK_RUNNING);
+
+		if (kthread_should_stop())
+			break;
 
 		/* Process stuff */
-		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 		rfcomm_process_sessions();
+
+		schedule();
 	}
+	__set_current_state(TASK_RUNNING);
 
 	rfcomm_kill_listener();
 
@@ -2155,7 +2093,7 @@
 		if (test_and_clear_bit(RFCOMM_SEC_PENDING, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (status || encrypt == 0x00) {
-				__rfcomm_dlc_close(d, ECONNREFUSED);
+				set_bit(RFCOMM_ENC_DROP, &d->flags);
 				continue;
 			}
 		}
@@ -2165,9 +2103,8 @@
 				set_bit(RFCOMM_SEC_PENDING, &d->flags);
 				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
 				continue;
-			} else if (d->sec_level == BT_SECURITY_HIGH ||
-				d->sec_level == BT_SECURITY_VERY_HIGH) {
-				__rfcomm_dlc_close(d, ECONNREFUSED);
+			} else if (d->sec_level == BT_SECURITY_HIGH) {
+				set_bit(RFCOMM_ENC_DROP, &d->flags);
 				continue;
 			}
 		}
@@ -2175,7 +2112,7 @@
 		if (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))
 			continue;
 
-		if (!status)
+		if (!status && hci_conn_check_secure(conn, d->sec_level))
 			set_bit(RFCOMM_AUTH_ACCEPT, &d->flags);
 		else
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
@@ -2194,15 +2131,13 @@
 static int rfcomm_dlc_debugfs_show(struct seq_file *f, void *x)
 {
 	struct rfcomm_session *s;
-	struct list_head *pp, *p;
 
 	rfcomm_lock();
 
-	list_for_each(p, &session_list) {
-		s = list_entry(p, struct rfcomm_session, list);
-		list_for_each(pp, &s->dlcs) {
+	list_for_each_entry(s, &session_list, list) {
+		struct rfcomm_dlc *d;
+		list_for_each_entry(d, &s->dlcs, list) {
 			struct sock *sk = s->sock->sk;
-			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);
 
 			seq_printf(f, "%s %s %ld %d %d %d %d\n",
 						batostr(&bt_sk(sk)->src),
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/sock.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/sock.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    RFCOMM implementation for Linux Bluetooth stack (BlueZ).
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>
    Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>
 
@@ -43,9 +42,9 @@
 #include <linux/device.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/security.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -265,6 +264,8 @@
 
 		pi->sec_level = rfcomm_pi(parent)->sec_level;
 		pi->role_switch = rfcomm_pi(parent)->role_switch;
+
+		security_sk_clone(parent, sk);
 	} else {
 		pi->dlc->defer_setup = 0;
 
@@ -368,7 +369,7 @@
 		goto done;
 	}
 
-	write_lock_bh(&rfcomm_sk_list.lock);
+	write_lock(&rfcomm_sk_list.lock);
 
 	if (sa->rc_channel && __rfcomm_get_sock_by_addr(sa->rc_channel, &sa->rc_bdaddr)) {
 		err = -EADDRINUSE;
@@ -379,7 +380,7 @@
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock_bh(&rfcomm_sk_list.lock);
+	write_unlock(&rfcomm_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -453,7 +454,7 @@
 
 		err = -EINVAL;
 
-		write_lock_bh(&rfcomm_sk_list.lock);
+		write_lock(&rfcomm_sk_list.lock);
 
 		for (channel = 1; channel < 31; channel++)
 			if (!__rfcomm_get_sock_by_addr(channel, src)) {
@@ -462,7 +463,7 @@
 				break;
 			}
 
-		write_unlock_bh(&rfcomm_sk_list.lock);
+		write_unlock(&rfcomm_sk_list.lock);
 
 		if (err < 0)
 			goto done;
@@ -484,12 +485,7 @@
 	long timeo;
 	int err = 0;
 
-	lock_sock(sk);
-
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
+	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
 	if (sk->sk_type != SOCK_STREAM) {
 		err = -EINVAL;
@@ -502,19 +498,20 @@
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
+		nsk = bt_accept_dequeue(sk, newsock);
+		if (nsk)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -522,8 +519,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -545,6 +546,7 @@
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
+	memset(sa, 0, sizeof(*sa));
 	sa->rc_family  = AF_BLUETOOTH;
 	sa->rc_channel = rfcomm_pi(sk)->channel;
 	if (peer)
@@ -598,6 +600,8 @@
 			break;
 		}
 
+		skb->priority = sk->sk_priority;
+
 		err = rfcomm_dlc_send(d, skb);
 		if (err < 0) {
 			kfree_skb(skb);
@@ -680,7 +684,8 @@
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
-	int len, err = 0;
+	int err = 0;
+	size_t len;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
@@ -708,13 +713,12 @@
 			break;
 		}
 
-		if (sec.level > BT_SECURITY_VERY_HIGH) {
+		if (sec.level > BT_SECURITY_HIGH) {
 			err = -EINVAL;
 			break;
 		}
 
 		rfcomm_pi(sk)->sec_level = sec.level;
-		BT_DBG("set to %d", sec.level);
 		break;
 
 	case BT_DEFER_SETUP:
@@ -743,8 +747,8 @@
 static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
-	struct sock *l2cap_sk;
 	struct rfcomm_conninfo cinfo;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 	int len, err = 0;
 	u32 opt;
 
@@ -765,7 +769,6 @@
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
 			break;
 		case BT_SECURITY_HIGH:
-		case BT_SECURITY_VERY_HIGH:
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |
 							RFCOMM_LM_SECURE;
 			break;
@@ -788,10 +791,9 @@
 			break;
 		}
 
-		l2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;
-
-		cinfo.hci_handle = l2cap_pi(l2cap_sk)->conn->hcon->handle;
-		memcpy(cinfo.dev_class, l2cap_pi(l2cap_sk)->conn->hcon->dev_class, 3);
+		memset(&cinfo, 0, sizeof(cinfo));
+		cinfo.hci_handle = conn->hcon->handle;
+		memcpy(cinfo.dev_class, conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -835,6 +837,7 @@
 		}
 
 		sec.level = rfcomm_pi(sk)->sec_level;
+		sec.key_size = 0;
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))
@@ -954,6 +957,8 @@
 	if (!sk)
 		goto done;
 
+	bt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);
+
 	rfcomm_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, &src);
 	bacpy(&bt_sk(sk)->dst, &dst);
@@ -980,7 +985,7 @@
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock_bh(&rfcomm_sk_list.lock);
+	read_lock(&rfcomm_sk_list.lock);
 
 	sk_for_each(sk, node, &rfcomm_sk_list.head) {
 		seq_printf(f, "%s %s %d %d\n",
@@ -989,7 +994,7 @@
 				sk->sk_state, rfcomm_pi(sk)->channel);
 	}
 
-	read_unlock_bh(&rfcomm_sk_list.lock);
+	read_unlock(&rfcomm_sk_list.lock);
 
 	return 0;
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/tty.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/tty.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/tty.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/tty.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
@@ -35,6 +34,7 @@
 #include <linux/capability.h>
 #include <linux/slab.h>
 #include <linux/skbuff.h>
+#include <linux/workqueue.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -66,7 +66,7 @@
 	struct rfcomm_dlc	*dlc;
 	struct tty_struct	*tty;
 	wait_queue_head_t       wait;
-	struct tasklet_struct   wakeup_task;
+	struct work_struct	wakeup_task;
 
 	struct device		*tty_dev;
 
@@ -76,13 +76,13 @@
 };
 
 static LIST_HEAD(rfcomm_dev_list);
-static DEFINE_RWLOCK(rfcomm_dev_lock);
+static DEFINE_SPINLOCK(rfcomm_dev_lock);
 
 static void rfcomm_dev_data_ready(struct rfcomm_dlc *dlc, struct sk_buff *skb);
 static void rfcomm_dev_state_change(struct rfcomm_dlc *dlc, int err);
 static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig);
 
-static void rfcomm_tty_wakeup(unsigned long arg);
+static void rfcomm_tty_wakeup(struct work_struct *work);
 
 /* ---- Device functions ---- */
 static void rfcomm_dev_destruct(struct rfcomm_dev *dev)
@@ -134,13 +134,10 @@
 static struct rfcomm_dev *__rfcomm_dev_get(int id)
 {
 	struct rfcomm_dev *dev;
-	struct list_head  *p;
 
-	list_for_each(p, &rfcomm_dev_list) {
-		dev = list_entry(p, struct rfcomm_dev, list);
+	list_for_each_entry(dev, &rfcomm_dev_list, list)
 		if (dev->id == id)
 			return dev;
-	}
 
 	return NULL;
 }
@@ -149,7 +146,7 @@
 {
 	struct rfcomm_dev *dev;
 
-	read_lock(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
 	dev = __rfcomm_dev_get(id);
 
@@ -160,7 +157,7 @@
 			rfcomm_dev_hold(dev);
 	}
 
-	read_unlock(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	return dev;
 }
@@ -198,8 +195,8 @@
 
 static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 {
-	struct rfcomm_dev *dev;
-	struct list_head *head = &rfcomm_dev_list, *p;
+	struct rfcomm_dev *dev, *entry;
+	struct list_head *head = &rfcomm_dev_list;
 	int err = 0;
 
 	BT_DBG("id %d channel %d", req->dev_id, req->channel);
@@ -208,24 +205,22 @@
 	if (!dev)
 		return -ENOMEM;
 
-	write_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
 	if (req->dev_id < 0) {
 		dev->id = 0;
 
-		list_for_each(p, &rfcomm_dev_list) {
-			if (list_entry(p, struct rfcomm_dev, list)->id != dev->id)
+		list_for_each_entry(entry, &rfcomm_dev_list, list) {
+			if (entry->id != dev->id)
 				break;
 
 			dev->id++;
-			head = p;
+			head = &entry->list;
 		}
 	} else {
 		dev->id = req->dev_id;
 
-		list_for_each(p, &rfcomm_dev_list) {
-			struct rfcomm_dev *entry = list_entry(p, struct rfcomm_dev, list);
-
+		list_for_each_entry(entry, &rfcomm_dev_list, list) {
 			if (entry->id == dev->id) {
 				err = -EADDRINUSE;
 				goto out;
@@ -234,7 +229,7 @@
 			if (entry->id > dev->id - 1)
 				break;
 
-			head = p;
+			head = &entry->list;
 		}
 	}
 
@@ -258,7 +253,7 @@
 	atomic_set(&dev->opened, 0);
 
 	init_waitqueue_head(&dev->wait);
-	tasklet_init(&dev->wakeup_task, rfcomm_tty_wakeup, (unsigned long) dev);
+	INIT_WORK(&dev->wakeup_task, rfcomm_tty_wakeup);
 
 	skb_queue_head_init(&dev->pending);
 
@@ -295,7 +290,7 @@
 	__module_get(THIS_MODULE);
 
 out:
-	write_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	if (err < 0)
 		goto free;
@@ -332,9 +327,9 @@
 	if (atomic_read(&dev->opened) > 0)
 		return;
 
-	write_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 	list_del_init(&dev->list);
-	write_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	rfcomm_dev_put(dev);
 }
@@ -352,7 +347,7 @@
 	struct rfcomm_dev *dev = (void *) skb->sk;
 	atomic_sub(skb->truesize, &dev->wmem_alloc);
 	if (test_bit(RFCOMM_TTY_ATTACHED, &dev->flags))
-		tasklet_schedule(&dev->wakeup_task);
+		queue_work(system_nrt_wq, &dev->wakeup_task);
 	rfcomm_dev_put(dev);
 }
 
@@ -456,9 +451,9 @@
 
 static int rfcomm_get_dev_list(void __user *arg)
 {
+	struct rfcomm_dev *dev;
 	struct rfcomm_dev_list_req *dl;
 	struct rfcomm_dev_info *di;
-	struct list_head *p;
 	int n = 0, size, err;
 	u16 dev_num;
 
@@ -472,16 +467,15 @@
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
-	dl = kmalloc(size, GFP_KERNEL);
+	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
 	di = dl->dev_info;
 
-	read_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
-	list_for_each(p, &rfcomm_dev_list) {
-		struct rfcomm_dev *dev = list_entry(p, struct rfcomm_dev, list);
+	list_for_each_entry(dev, &rfcomm_dev_list, list) {
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
 			continue;
 		(di + n)->id      = dev->id;
@@ -494,7 +488,7 @@
 			break;
 	}
 
-	read_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*di);
@@ -636,9 +630,10 @@
 }
 
 /* ---- TTY functions ---- */
-static void rfcomm_tty_wakeup(unsigned long arg)
+static void rfcomm_tty_wakeup(struct work_struct *work)
 {
-	struct rfcomm_dev *dev = (void *) arg;
+	struct rfcomm_dev *dev = container_of(work, struct rfcomm_dev,
+								wakeup_task);
 	struct tty_struct *tty = dev->tty;
 	if (!tty)
 		return;
@@ -763,7 +758,7 @@
 		rfcomm_dlc_close(dev->dlc, 0);
 
 		clear_bit(RFCOMM_TTY_ATTACHED, &dev->flags);
-		tasklet_kill(&dev->wakeup_task);
+		cancel_work_sync(&dev->wakeup_task);
 
 		rfcomm_dlc_lock(dev->dlc);
 		tty->driver_data = NULL;
@@ -771,9 +766,9 @@
 		rfcomm_dlc_unlock(dev->dlc);
 
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags)) {
-			write_lock_bh(&rfcomm_dev_lock);
+			spin_lock(&rfcomm_dev_lock);
 			list_del_init(&dev->list);
-			write_unlock_bh(&rfcomm_dev_lock);
+			spin_unlock(&rfcomm_dev_lock);
 
 			rfcomm_dev_put(dev);
 		}
@@ -1156,11 +1151,12 @@
 
 int __init rfcomm_init_ttys(void)
 {
+	int error;
+
 	rfcomm_tty_driver = alloc_tty_driver(RFCOMM_TTY_PORTS);
 	if (!rfcomm_tty_driver)
-		return -1;
+		return -ENOMEM;
 
-	rfcomm_tty_driver->owner	= THIS_MODULE;
 	rfcomm_tty_driver->driver_name	= "rfcomm";
 	rfcomm_tty_driver->name		= "rfcomm";
 	rfcomm_tty_driver->major	= RFCOMM_TTY_MAJOR;
@@ -1173,10 +1169,11 @@
 	rfcomm_tty_driver->init_termios.c_lflag &= ~ICANON;
 	tty_set_operations(rfcomm_tty_driver, &rfcomm_ops);
 
-	if (tty_register_driver(rfcomm_tty_driver)) {
+	error = tty_register_driver(rfcomm_tty_driver);
+	if (error) {
 		BT_ERR("Can't register RFCOMM TTY driver");
 		put_tty_driver(rfcomm_tty_driver);
-		return -1;
+		return error;
 	}
 
 	BT_INFO("RFCOMM TTY layer initialized");
diff -urN flo-ElementalX-5.00/net/bluetooth/sco.c flo-ElementalX-5.00-patched/net/bluetooth/sco.c
--- flo-ElementalX-5.00/net/bluetooth/sco.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/sco.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,7 +24,6 @@
 
 /* Bluetooth SCO sockets. */
 
-#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <linux/types.h>
@@ -43,9 +41,9 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/list.h>
+#include <linux/security.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -63,7 +61,7 @@
 static void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent);
 static void sco_chan_del(struct sock *sk, int err);
 
-static int  sco_conn_del(struct hci_conn *conn, int err, u8 is_process);
+static int  sco_conn_del(struct hci_conn *conn, int err);
 
 static void sco_sock_close(struct sock *sk);
 static void sco_sock_kill(struct sock *sk);
@@ -136,7 +134,7 @@
 	return sk;
 }
 
-static int sco_conn_del(struct hci_conn *hcon, int err, u8 is_process)
+static int sco_conn_del(struct hci_conn *hcon, int err)
 {
 	struct sco_conn *conn = hcon->sco_data;
 	struct sock *sk;
@@ -149,16 +147,10 @@
 	/* Kill socket */
 	sk = sco_chan_get(conn);
 	if (sk) {
-		if (is_process)
-			lock_sock(sk);
-		else
-			bh_lock_sock(sk);
+		bh_lock_sock(sk);
 		sco_sock_clear_timer(sk);
 		sco_chan_del(sk, err);
-		if (is_process)
-			release_sock(sk);
-		else
-			bh_unlock_sock(sk);
+		bh_unlock_sock(sk);
 		sco_sock_kill(sk);
 	}
 
@@ -181,11 +173,10 @@
 	return err;
 }
 
-static int sco_connect(struct sock *sk, __s8 is_wbs)
+static int sco_connect(struct sock *sk)
 {
 	bdaddr_t *src = &bt_sk(sk)->src;
 	bdaddr_t *dst = &bt_sk(sk)->dst;
-	__u16 pkt_type = sco_pi(sk)->pkt_type;
 	struct sco_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev  *hdev;
@@ -197,35 +188,19 @@
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	hdev->is_wbs = is_wbs;
-
-	if (lmp_esco_capable(hdev) && !disable_esco) {
+	if (lmp_esco_capable(hdev) && !disable_esco)
 		type = ESCO_LINK;
-	} else if (is_wbs) {
-		return -ENAVAIL;
-	} else {
+	else
 		type = SCO_LINK;
-		pkt_type &= SCO_ESCO_MASK;
-	}
-
-	BT_DBG("type: %d, pkt_type: 0x%x", type, pkt_type);
 
-	hcon = hci_connect(hdev, type, pkt_type, dst,
-					BT_SECURITY_LOW, HCI_AT_NO_BONDING);
+	hcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (IS_ERR(hcon)) {
 		err = PTR_ERR(hcon);
 		goto done;
 	}
 
-	if (is_wbs && (hcon->type != ESCO_LINK)) {
-		BT_ERR("WBS [ hcon->type: 0x%x, hcon->pkt_type: 0x%x ]",
-				hcon->type, hcon->pkt_type);
-		err = -EREMOTEIO;
-		goto done;
-	}
-
 	conn = sco_conn_add(hcon, 0);
 	if (!conn) {
 		hci_conn_put(hcon);
@@ -249,7 +224,7 @@
 	}
 
 done:
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
@@ -397,14 +372,13 @@
 		if (sco_pi(sk)->conn) {
 			sk->sk_state = BT_DISCONN;
 			sco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);
-			if (sco_pi(sk)->conn->hcon != NULL) {
-				hci_conn_put(sco_pi(sk)->conn->hcon);
-				sco_pi(sk)->conn->hcon = NULL;
-			}
+			hci_conn_put(sco_pi(sk)->conn->hcon);
+			sco_pi(sk)->conn->hcon = NULL;
 		} else
 			sco_chan_del(sk, ECONNRESET);
 		break;
 
+	case BT_CONNECT2:
 	case BT_CONNECT:
 	case BT_DISCONN:
 		sco_chan_del(sk, ECONNRESET);
@@ -430,8 +404,10 @@
 {
 	BT_DBG("sk %p", sk);
 
-	if (parent)
+	if (parent) {
 		sk->sk_type = parent->sk_type;
+		security_sk_clone(parent, sk);
+	}
 }
 
 static struct proto sco_proto = {
@@ -487,22 +463,18 @@
 	return 0;
 }
 
-static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
+static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
-	struct sockaddr_sco sa;
+	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	bdaddr_t *src = &sa.sco_bdaddr;
-	int len, err = 0;
+	bdaddr_t *src = &sa->sco_bdaddr;
+	int err = 0;
 
-	BT_DBG("sk %p %s", sk, batostr(&sa.sco_bdaddr));
+	BT_DBG("sk %p %s", sk, batostr(&sa->sco_bdaddr));
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
-	len = min_t(unsigned int, sizeof(sa), alen);
-	memcpy(&sa, addr, len);
-
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -510,18 +482,17 @@
 		goto done;
 	}
 
-	write_lock_bh(&sco_sk_list.lock);
+	write_lock(&sco_sk_list.lock);
 
 	if (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &sa.sco_bdaddr);
-		sco_pi(sk)->pkt_type = sa.sco_pkt_type;
+		bacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock_bh(&sco_sk_list.lock);
+	write_unlock(&sco_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -530,36 +501,29 @@
 
 static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
+	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	struct sockaddr_sco sa;
-	int len, err = 0;
+	int err = 0;
+
 
 	BT_DBG("sk %p", sk);
 
-	if (!addr || addr->sa_family != AF_BLUETOOTH)
+	if (alen < sizeof(struct sockaddr_sco) ||
+	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
-	len = min_t(unsigned int, sizeof(sa), alen);
-	memcpy(&sa, addr, len);
-
-	lock_sock(sk);
+	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)
+		return -EBADFD;
 
-	if (sk->sk_type != SOCK_SEQPACKET) {
-		err = -EINVAL;
-		goto done;
-	}
+	if (sk->sk_type != SOCK_SEQPACKET)
+		return -EINVAL;
 
-	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {
-		err = -EBADFD;
-		goto done;
-	}
+	lock_sock(sk);
 
 	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
-	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
+	bacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);
 
-	err = sco_connect(sk, sa.is_wbs);
+	err = sco_connect(sk);
 	if (err)
 		goto done;
 
@@ -603,30 +567,26 @@
 
 	lock_sock(sk);
 
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(ch = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
+		ch = bt_accept_dequeue(sk, newsock);
+		if (ch)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -634,8 +594,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock(sk);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -664,7 +628,6 @@
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);
 	else
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);
-	sa->sco_pkt_type = sco_pi(sk)->pkt_type;
 
 	return 0;
 }
@@ -814,9 +777,6 @@
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
 							sk->sk_lingertime);
-		else
-			err = bt_sock_wait_state(sk, BT_CLOSED,
-							SCO_DISCONN_TIMEOUT);
 	}
 	release_sock(sk);
 	return err;
@@ -838,11 +798,6 @@
 		lock_sock(sk);
 		err = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);
 		release_sock(sk);
-	} else {
-		lock_sock(sk);
-		err = bt_sock_wait_state(sk, BT_CLOSED,
-							SCO_DISCONN_TIMEOUT);
-		release_sock(sk);
 	}
 
 	sock_orphan(sk);
@@ -938,15 +893,12 @@
 }
 
 /* ----- SCO interface with lower layer (HCI) ----- */
-static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	register struct sock *sk;
 	struct hlist_node *node;
 	int lm = 0;
 
-	if (type != SCO_LINK && type != ESCO_LINK)
-		return 0;
-
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets */
@@ -966,13 +918,9 @@
 	return lm;
 }
 
-static int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
+int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
 {
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
-
-	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
-		return -EINVAL;
-
 	if (!status) {
 		struct sco_conn *conn;
 
@@ -980,24 +928,20 @@
 		if (conn)
 			sco_conn_ready(conn);
 	} else
-		sco_conn_del(hcon, bt_err(status), 0);
+		sco_conn_del(hcon, bt_to_errno(status));
 
 	return 0;
 }
 
-static int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason, __u8 is_process)
+int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
-		return -EINVAL;
-
-	sco_conn_del(hcon, bt_err(reason), is_process);
-
+	sco_conn_del(hcon, bt_to_errno(reason));
 	return 0;
 }
 
-static int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
+int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
 {
 	struct sco_conn *conn = hcon->sco_data;
 
@@ -1021,14 +965,14 @@
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock_bh(&sco_sk_list.lock);
+	read_lock(&sco_sk_list.lock);
 
 	sk_for_each(sk, node, &sco_sk_list.head) {
 		seq_printf(f, "%s %s %d\n", batostr(&bt_sk(sk)->src),
 				batostr(&bt_sk(sk)->dst), sk->sk_state);
 	}
 
-	read_unlock_bh(&sco_sk_list.lock);
+	read_unlock(&sco_sk_list.lock);
 
 	return 0;
 }
@@ -1073,15 +1017,6 @@
 	.create	= sco_sock_create,
 };
 
-static struct hci_proto sco_hci_proto = {
-	.name		= "SCO",
-	.id		= HCI_PROTO_SCO,
-	.connect_ind	= sco_connect_ind,
-	.connect_cfm	= sco_connect_cfm,
-	.disconn_cfm	= sco_disconn_cfm,
-	.recv_scodata	= sco_recv_scodata
-};
-
 int __init sco_init(void)
 {
 	int err;
@@ -1096,13 +1031,6 @@
 		goto error;
 	}
 
-	err = hci_register_proto(&sco_hci_proto);
-	if (err < 0) {
-		BT_ERR("SCO protocol registration failed");
-		bt_sock_unregister(BTPROTO_SCO);
-		goto error;
-	}
-
 	if (bt_debugfs) {
 		sco_debugfs = debugfs_create_file("sco", 0444,
 					bt_debugfs, NULL, &sco_debugfs_fops);
@@ -1126,9 +1054,6 @@
 	if (bt_sock_unregister(BTPROTO_SCO) < 0)
 		BT_ERR("SCO socket unregistration failed");
 
-	if (hci_unregister_proto(&sco_hci_proto) < 0)
-		BT_ERR("SCO protocol unregistration failed");
-
 	proto_unregister(&sco_proto);
 }
 
diff -urN flo-ElementalX-5.00/net/bluetooth/smp.c flo-ElementalX-5.00-patched/net/bluetooth/smp.c
--- flo-ElementalX-5.00/net/bluetooth/smp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/smp.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
 
    This program is free software; you can redistribute it and/or modify
@@ -21,31 +20,18 @@
    SOFTWARE IS DISCLAIMED.
 */
 
-#include <linux/interrupt.h>
-#include <linux/module.h>
-
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 #include <linux/crypto.h>
+#include <linux/scatterlist.h>
 #include <crypto/b128ops.h>
-#include <asm/unaligned.h>
-
-#define SMP_TIMEOUT 30000 /* 30 seconds */
-
-#define SMP_MIN_CONN_INTERVAL	40	/* 50ms (40 * 1.25ms) */
-#define SMP_MAX_CONN_INTERVAL	56	/* 70ms (56 * 1.25ms) */
-#define SMP_MAX_CONN_LATENCY	0	/* 0ms (0 * 1.25ms) */
-#define SMP_SUPERVISION_TIMEOUT	500	/* 5 seconds (500 * 10ms) */
 
-#ifndef FALSE
-#define FALSE 0
-#define TRUE (!FALSE)
-#endif
+#define SMP_TIMEOUT	msecs_to_jiffies(30000)
 
-static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+#define AUTH_REQ_MASK   0x07
 
 static inline void swap128(u8 src[16], u8 dst[16])
 {
@@ -163,7 +149,7 @@
 }
 
 static struct sk_buff *smp_build_cmd(struct l2cap_conn *conn, u8 code,
-		u16 dlen, void *data)
+						u16 dlen, void *data)
 {
 	struct sk_buff *skb;
 	struct l2cap_hdr *lh;
@@ -198,26 +184,28 @@
 	if (!skb)
 		return;
 
-	hci_send_acl(conn->hcon, NULL, skb, 0);
+	skb->priority = HCI_PRIO_MAX;
+	hci_send_acl(conn->hchan, skb, 0);
+
+	cancel_delayed_work_sync(&conn->security_timer);
+	schedule_delayed_work(&conn->security_timer, SMP_TIMEOUT);
 }
 
 static __u8 authreq_to_seclevel(__u8 authreq)
 {
 	if (authreq & SMP_AUTH_MITM)
 		return BT_SECURITY_HIGH;
-	else if (authreq & SMP_AUTH_BONDING)
-		return BT_SECURITY_MEDIUM;
 	else
-		return BT_SECURITY_LOW;
+		return BT_SECURITY_MEDIUM;
 }
 
-static __u8 seclevel_to_authreq(__u8 level)
+static __u8 seclevel_to_authreq(__u8 sec_level)
 {
-	switch (level) {
-	case BT_SECURITY_VERY_HIGH:
+	switch (sec_level) {
 	case BT_SECURITY_HIGH:
 		return SMP_AUTH_MITM | SMP_AUTH_BONDING;
-
+	case BT_SECURITY_MEDIUM:
+		return SMP_AUTH_BONDING;
 	default:
 		return SMP_AUTH_NONE;
 	}
@@ -228,562 +216,583 @@
 				struct smp_cmd_pairing *rsp,
 				__u8 authreq)
 {
-	struct hci_conn *hcon = conn->hcon;
-	u8 all_keys = 0;
 	u8 dist_keys = 0;
 
-	dist_keys = SMP_DIST_ENC_KEY;
-	authreq |= SMP_AUTH_BONDING;
-
-	BT_DBG("conn->hcon->io_capability:%d", conn->hcon->io_capability);
+	if (test_bit(HCI_PAIRABLE, &conn->hcon->hdev->dev_flags)) {
+		dist_keys = SMP_DIST_ENC_KEY;
+		authreq |= SMP_AUTH_BONDING;
+	} else {
+		authreq &= ~SMP_AUTH_BONDING;
+	}
 
 	if (rsp == NULL) {
 		req->io_capability = conn->hcon->io_capability;
-		req->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
-							SMP_OOB_NOT_PRESENT;
+		req->oob_flag = SMP_OOB_NOT_PRESENT;
 		req->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-		req->init_key_dist = all_keys;
+		req->init_key_dist = 0;
 		req->resp_key_dist = dist_keys;
-		req->auth_req = authreq;
-		BT_DBG("SMP_CMD_PAIRING_REQ %d %d %d %d %2.2x %2.2x",
-				req->io_capability, req->oob_flag,
-				req->auth_req, req->max_key_size,
-				req->init_key_dist, req->resp_key_dist);
+		req->auth_req = (authreq & AUTH_REQ_MASK);
 		return;
 	}
 
-	/* Only request OOB if remote AND we support it */
-	if (req->oob_flag)
-		rsp->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
-						SMP_OOB_NOT_PRESENT;
-	else
-		rsp->oob_flag = SMP_OOB_NOT_PRESENT;
-
 	rsp->io_capability = conn->hcon->io_capability;
+	rsp->oob_flag = SMP_OOB_NOT_PRESENT;
 	rsp->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-	rsp->init_key_dist = req->init_key_dist & all_keys;
+	rsp->init_key_dist = 0;
 	rsp->resp_key_dist = req->resp_key_dist & dist_keys;
-	rsp->auth_req = authreq;
-	BT_DBG("SMP_CMD_PAIRING_RSP %d %d %d %d %2.2x %2.2x",
-			req->io_capability, req->oob_flag, req->auth_req,
-			req->max_key_size, req->init_key_dist,
-			req->resp_key_dist);
+	rsp->auth_req = (authreq & AUTH_REQ_MASK);
 }
 
 static u8 check_enc_key_size(struct l2cap_conn *conn, __u8 max_key_size)
 {
-	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp = conn->smp_chan;
 
 	if ((max_key_size > SMP_MAX_ENC_KEY_SIZE) ||
 			(max_key_size < SMP_MIN_ENC_KEY_SIZE))
 		return SMP_ENC_KEY_SIZE;
 
-	hcon->smp_key_size = max_key_size;
+	smp->enc_key_size = max_key_size;
 
 	return 0;
 }
 
-#define JUST_WORKS	SMP_JUST_WORKS
-#define REQ_PASSKEY	SMP_REQ_PASSKEY
-#define CFM_PASSKEY	SMP_CFM_PASSKEY
-#define JUST_CFM	SMP_JUST_CFM
-#define OVERLAP		SMP_OVERLAP
-static const u8	gen_method[5][5] = {
-	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
-	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
-	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY},
-	{JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM},
-	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP}
+static void smp_failure(struct l2cap_conn *conn, u8 reason, u8 send)
+{
+	struct hci_conn *hcon = conn->hcon;
+
+	if (send)
+		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
+								&reason);
+
+	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->flags);
+	mgmt_auth_failed(conn->hcon->hdev, conn->dst, hcon->type,
+			 hcon->dst_type, reason);
+
+	cancel_delayed_work_sync(&conn->security_timer);
+
+	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		smp_chan_destroy(conn);
+}
+
+#define JUST_WORKS	0x00
+#define JUST_CFM	0x01
+#define REQ_PASSKEY	0x02
+#define CFM_PASSKEY	0x03
+#define REQ_OOB		0x04
+#define OVERLAP		0xFF
+
+static const u8 gen_method[5][5] = {
+	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
+	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
+	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },
+	{ JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM    },
+	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP     },
 };
 
 static int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,
 						u8 local_io, u8 remote_io)
 {
 	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp = conn->smp_chan;
 	u8 method;
 	u32 passkey = 0;
 	int ret = 0;
 
-	/* Initialize key to JUST WORKS */
-	memset(hcon->tk, 0, sizeof(hcon->tk));
-	hcon->tk_valid = FALSE;
-	hcon->auth = auth;
-
-	/* By definition, OOB data will be used if both sides have it available
-	 */
-	if (remote_oob && hcon->oob) {
-		method = SMP_REQ_OOB;
-		goto agent_request;
-	}
+	/* Initialize key for JUST WORKS */
+	memset(smp->tk, 0, sizeof(smp->tk));
+	clear_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 
 	BT_DBG("tk_request: auth:%d lcl:%d rem:%d", auth, local_io, remote_io);
 
 	/* If neither side wants MITM, use JUST WORKS */
-	/* If either side has unknown io_caps, use JUST_WORKS */
+	/* If either side has unknown io_caps, use JUST WORKS */
+	/* Otherwise, look up method from the table */
 	if (!(auth & SMP_AUTH_MITM) ||
 			local_io > SMP_IO_KEYBOARD_DISPLAY ||
-			remote_io > SMP_IO_KEYBOARD_DISPLAY) {
-		hcon->auth &= ~SMP_AUTH_MITM;
-		hcon->tk_valid = TRUE;
+			remote_io > SMP_IO_KEYBOARD_DISPLAY)
+		method = JUST_WORKS;
+	else
+		method = gen_method[remote_io][local_io];
+
+	/* If not bonding, don't ask user to confirm a Zero TK */
+	if (!(auth & SMP_AUTH_BONDING) && method == JUST_CFM)
+		method = JUST_WORKS;
+
+	/* If Just Works, Continue with Zero TK */
+	if (method == JUST_WORKS) {
+		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 		return 0;
 	}
 
-	/* MITM is now officially requested, but not required */
-	/* Determine what we need (if anything) from the agent */
-	method = gen_method[local_io][remote_io];
-
-	BT_DBG("tk_method: %d", method);
-
-	if (method == SMP_JUST_WORKS || method == SMP_JUST_CFM)
-		hcon->auth &= ~SMP_AUTH_MITM;
-
-	/* Don't bother confirming unbonded JUST_WORKS */
-	if (!(auth & SMP_AUTH_BONDING) && method == SMP_JUST_CFM) {
-		hcon->tk_valid = TRUE;
-		return 0;
-	} else if (method == SMP_JUST_WORKS) {
-		hcon->tk_valid = TRUE;
-		return 0;
-	} else if (method == SMP_OVERLAP) {
+	/* Not Just Works/Confirm results in MITM Authentication */
+	if (method != JUST_CFM)
+		set_bit(SMP_FLAG_MITM_AUTH, &smp->smp_flags);
+
+	/* If both devices have Keyoard-Display I/O, the master
+	 * Confirms and the slave Enters the passkey.
+	 */
+	if (method == OVERLAP) {
 		if (hcon->link_mode & HCI_LM_MASTER)
-			method = SMP_CFM_PASSKEY;
+			method = CFM_PASSKEY;
 		else
-			method = SMP_REQ_PASSKEY;
+			method = REQ_PASSKEY;
 	}
 
-	BT_DBG("tk_method-2: %d", method);
-
-	if (method == SMP_CFM_PASSKEY) {
+	/* Generate random passkey. Not valid until confirmed. */
+	if (method == CFM_PASSKEY) {
 		u8 key[16];
-		/* Generate a passkey for display. It is not valid until
-		 * confirmed.
-		 */
+
 		memset(key, 0, sizeof(key));
 		get_random_bytes(&passkey, sizeof(passkey));
 		passkey %= 1000000;
 		put_unaligned_le32(passkey, key);
-		swap128(key, hcon->tk);
+		swap128(key, smp->tk);
 		BT_DBG("PassKey: %d", passkey);
 	}
 
-agent_request:
 	hci_dev_lock(hcon->hdev);
 
-	switch (method) {
-	case SMP_REQ_PASSKEY:
-		ret = mgmt_user_confirm_request(hcon->hdev->id,
-				HCI_EV_USER_PASSKEY_REQUEST, conn->dst, 0);
-		break;
-	case SMP_CFM_PASSKEY:
-	default:
-		ret = mgmt_user_confirm_request(hcon->hdev->id,
-			HCI_EV_USER_CONFIRM_REQUEST, conn->dst, passkey);
-		break;
-	}
+	if (method == REQ_PASSKEY)
+		ret = mgmt_user_passkey_request(hcon->hdev, conn->dst,
+						hcon->type, hcon->dst_type);
+	else
+		ret = mgmt_user_confirm_request(hcon->hdev, conn->dst,
+						hcon->type, hcon->dst_type,
+						cpu_to_le32(passkey), 0);
 
 	hci_dev_unlock(hcon->hdev);
 
 	return ret;
 }
 
-static int send_pairing_confirm(struct l2cap_conn *conn)
+static void confirm_work(struct work_struct *work)
 {
-	struct hci_conn *hcon = conn->hcon;
-	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
+	struct smp_chan *smp = container_of(work, struct smp_chan, confirm);
+	struct l2cap_conn *conn = smp->conn;
+	struct crypto_blkcipher *tfm;
 	struct smp_cmd_pairing_confirm cp;
 	int ret;
-	u8 res[16];
+	u8 res[16], reason;
+
+	BT_DBG("conn %p", conn);
+
+	tfm = crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	smp->tfm = tfm;
 
 	if (conn->hcon->out)
-		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
-				0, conn->src, hcon->dst_type, conn->dst, res);
+		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp, 0,
+			     conn->src, conn->hcon->dst_type, conn->dst, res);
 	else
-		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
-				hcon->dst_type, conn->dst, 0, conn->src, res);
+		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp,
+			     conn->hcon->dst_type, conn->dst, 0, conn->src,
+			     res);
+	if (ret) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
 
-	if (ret)
-		return SMP_CONFIRM_FAILED;
+	clear_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
 
 	swap128(res, cp.confirm_val);
+	smp_send_cmd(smp->conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
 
-	hcon->cfm_pending = FALSE;
+	return;
 
-	smp_send_cmd(conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
+error:
+	smp_failure(conn, reason, 1);
+}
 
-	return 0;
+static void random_work(struct work_struct *work)
+{
+	struct smp_chan *smp = container_of(work, struct smp_chan, random);
+	struct l2cap_conn *conn = smp->conn;
+	struct hci_conn *hcon = conn->hcon;
+	struct crypto_blkcipher *tfm = smp->tfm;
+	u8 reason, confirm[16], res[16], key[16];
+	int ret;
+
+	if (IS_ERR_OR_NULL(tfm)) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
+
+	if (hcon->out)
+		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp, 0,
+			     conn->src, hcon->dst_type, conn->dst, res);
+	else
+		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp,
+			     hcon->dst_type, conn->dst, 0, conn->src, res);
+	if (ret) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	swap128(res, confirm);
+
+	if (memcmp(smp->pcnf, confirm, sizeof(smp->pcnf)) != 0) {
+		BT_ERR("Pairing failed (confirmation values mismatch)");
+		reason = SMP_CONFIRM_FAILED;
+		goto error;
+	}
+
+	if (hcon->out) {
+		u8 stk[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		smp_s1(tfm, smp->tk, smp->rrnd, smp->prnd, key);
+		swap128(key, stk);
+
+		memset(stk + smp->enc_key_size, 0,
+		       SMP_MAX_ENC_KEY_SIZE - smp->enc_key_size);
+
+		if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags)) {
+			reason = SMP_UNSPECIFIED;
+			goto error;
+		}
+
+		hci_le_start_enc(hcon, ediv, rand, stk);
+		hcon->enc_key_size = smp->enc_key_size;
+	} else {
+		u8 stk[16], r[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		swap128(smp->prnd, r);
+		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
+
+		smp_s1(tfm, smp->tk, smp->prnd, smp->rrnd, key);
+		swap128(key, stk);
+
+		memset(stk + smp->enc_key_size, 0,
+				SMP_MAX_ENC_KEY_SIZE - smp->enc_key_size);
+
+		hci_add_ltk(hcon->hdev, conn->dst, hcon->dst_type,
+			    HCI_SMP_STK_SLAVE, 0, 0, stk, smp->enc_key_size,
+			    ediv, rand);
+	}
+
+	return;
+
+error:
+	smp_failure(conn, reason, 1);
 }
 
-int le_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, void *cp)
+static struct smp_chan *smp_chan_create(struct l2cap_conn *conn)
+{
+	struct smp_chan *smp;
+
+	smp = kzalloc(sizeof(struct smp_chan), GFP_ATOMIC);
+	if (!smp)
+		return NULL;
+
+	INIT_WORK(&smp->confirm, confirm_work);
+	INIT_WORK(&smp->random, random_work);
+
+	smp->conn = conn;
+	conn->smp_chan = smp;
+	conn->hcon->smp_conn = conn;
+
+	hci_conn_hold(conn->hcon);
+
+	return smp;
+}
+
+void smp_chan_destroy(struct l2cap_conn *conn)
+{
+	struct smp_chan *smp = conn->smp_chan;
+
+	BUG_ON(!smp);
+
+	if (smp->tfm)
+		crypto_free_blkcipher(smp->tfm);
+
+	kfree(smp);
+	conn->smp_chan = NULL;
+	conn->hcon->smp_conn = NULL;
+	hci_conn_put(conn->hcon);
+}
+
+int smp_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, __le32 passkey)
 {
-	struct mgmt_cp_user_passkey_reply *psk_reply = cp;
 	struct l2cap_conn *conn = hcon->smp_conn;
+	struct smp_chan *smp;
+	u32 value;
 	u8 key[16];
-	u8 reason = 0;
-	int ret = 0;
 
 	BT_DBG("");
 
-	hcon->tk_valid = TRUE;
+	if (!conn)
+		return -ENOTCONN;
+
+	smp = conn->smp_chan;
 
 	switch (mgmt_op) {
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		reason = SMP_CONFIRM_FAILED;
-		break;
-	case MGMT_OP_USER_CONFIRM_REPLY:
-		break;
 	case MGMT_OP_USER_PASSKEY_REPLY:
+		value = le32_to_cpu(passkey);
 		memset(key, 0, sizeof(key));
-		BT_DBG("PassKey: %d", psk_reply->passkey);
-		put_unaligned_le32(psk_reply->passkey, key);
-		swap128(key, hcon->tk);
+		BT_DBG("PassKey: %d", value);
+		put_unaligned_le32(value, key);
+		swap128(key, smp->tk);
+		/* Fall Through */
+	case MGMT_OP_USER_CONFIRM_REPLY:
+		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 		break;
+	case MGMT_OP_USER_PASSKEY_NEG_REPLY:
+	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
+		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
+		return 0;
 	default:
-		reason = SMP_CONFIRM_FAILED;
-		ret = -EOPNOTSUPP;
-		break;
+		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
+		return -EOPNOTSUPP;
 	}
 
-	if (reason) {
-		BT_DBG("smp_send_cmd: SMP_CMD_PAIRING_FAIL");
-		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
-								&reason);
-		del_timer(&hcon->smp_timer);
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
-		hci_conn_put(hcon);
-	} else if (hcon->cfm_pending) {
-		BT_DBG("send_pairing_confirm");
-		ret = send_pairing_confirm(conn);
-	}
+	/* If it is our turn to send Pairing Confirm, do so now */
+	if (test_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags))
+		queue_work(hcon->hdev->workqueue, &smp->confirm);
 
-	return ret;
+	return 0;
 }
 
 static u8 smp_cmd_pairing_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing rsp, *req = (void *) skb->data;
+	struct smp_chan *smp;
 	u8 key_size;
 	u8 auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
-	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&hcon->preq[1], req, sizeof(*req));
+	if (conn->hcon->link_mode & HCI_LM_MASTER)
+		return SMP_CMD_NOTSUPP;
+
+	if (!test_and_set_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		smp = smp_chan_create(conn);
+
+	smp = conn->smp_chan;
+
+	smp->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&smp->preq[1], req, sizeof(*req));
 	skb_pull(skb, sizeof(*req));
 
-	if (req->oob_flag && hcon->oob) {
-		/* By definition, OOB data pairing will have MITM protection */
-		auth = req->auth_req | SMP_AUTH_MITM;
-	} else if (req->auth_req & SMP_AUTH_BONDING) {
-		/* We will attempt MITM for all Bonding attempts */
-		auth = SMP_AUTH_BONDING | SMP_AUTH_MITM;
-	}
+	/* We didn't start the pairing, so match remote */
+	if (req->auth_req & SMP_AUTH_BONDING)
+		auth = req->auth_req;
+
+	conn->hcon->pending_sec_level = authreq_to_seclevel(auth);
 
-	/* We didn't start the pairing, so no requirements */
 	build_pairing_cmd(conn, req, &rsp, auth);
 
 	key_size = min(req->max_key_size, rsp.max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	ret = smp_rand(hcon->prnd);
+	ret = smp_rand(smp->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	/* Request setup of TK */
-	ret = tk_request(conn, req->oob_flag, auth, rsp.io_capability,
-							req->io_capability);
-	if (ret)
-		return SMP_UNSPECIFIED;
-
-	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&hcon->prsp[1], &rsp, sizeof(rsp));
+	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&smp->prsp[1], &rsp, sizeof(rsp));
 
 	smp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);
 
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+	/* Request setup of TK */
+	ret = tk_request(conn, 0, auth, rsp.io_capability, req->io_capability);
+	if (ret)
+		return SMP_UNSPECIFIED;
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_rsp(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp = (void *) skb->data;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 	u8 key_size, auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
+	if (!(conn->hcon->link_mode & HCI_LM_MASTER))
+		return SMP_CMD_NOTSUPP;
+
 	skb_pull(skb, sizeof(*rsp));
 
-	req = (void *) &hcon->preq[1];
+	req = (void *) &smp->preq[1];
 
 	key_size = min(req->max_key_size, rsp->max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&hcon->prsp[1], rsp, sizeof(*rsp));
-
-	ret = smp_rand(hcon->prnd);
+	ret = smp_rand(smp->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
+	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&smp->prsp[1], rsp, sizeof(*rsp));
+
 	if ((req->auth_req & SMP_AUTH_BONDING) &&
 			(rsp->auth_req & SMP_AUTH_BONDING))
 		auth = SMP_AUTH_BONDING;
 
 	auth |= (req->auth_req | rsp->auth_req) & SMP_AUTH_MITM;
 
-	ret = tk_request(conn, req->oob_flag, auth, rsp->io_capability,
-							req->io_capability);
+	ret = tk_request(conn, 0, auth, rsp->io_capability, req->io_capability);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	hcon->cfm_pending = TRUE;
+	set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
 
 	/* Can't compose response until we have been confirmed */
-	if (!hcon->tk_valid)
+	if (!test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags))
 		return 0;
 
-	ret = send_pairing_confirm(conn);
-	if (ret)
-		return SMP_CONFIRM_FAILED;
+	queue_work(hdev->workqueue, &smp->confirm);
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_confirm(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
-	int ret;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 
 	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
 
-	memcpy(hcon->pcnf, skb->data, sizeof(hcon->pcnf));
-	skb_pull(skb, sizeof(hcon->pcnf));
+	memcpy(smp->pcnf, skb->data, sizeof(smp->pcnf));
+	skb_pull(skb, sizeof(smp->pcnf));
 
 	if (conn->hcon->out) {
 		u8 random[16];
 
-		swap128(hcon->prnd, random);
+		swap128(smp->prnd, random);
 		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(random),
 								random);
-	} else if (hcon->tk_valid) {
-		ret = send_pairing_confirm(conn);
-
-		if (ret)
-			return SMP_CONFIRM_FAILED;
-	} else
-		hcon->cfm_pending = TRUE;
-
-
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+	} else if (test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags)) {
+		queue_work(hdev->workqueue, &smp->confirm);
+	} else {
+		set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
+	}
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
-	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
-	int ret;
-	u8 key[16], res[16], random[16], confirm[16];
-
-	swap128(skb->data, random);
-	skb_pull(skb, sizeof(random));
-
-	if (conn->hcon->out)
-		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp, 0,
-				conn->src, hcon->dst_type, conn->dst,
-				res);
-	else
-		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp,
-				hcon->dst_type, conn->dst, 0, conn->src,
-				res);
-	if (ret)
-		return SMP_UNSPECIFIED;
-
-	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
-
-	swap128(res, confirm);
-
-	if (memcmp(hcon->pcnf, confirm, sizeof(hcon->pcnf)) != 0) {
-		BT_ERR("Pairing failed (confirmation values mismatch)");
-		return SMP_CONFIRM_FAILED;
-	}
-
-	if (conn->hcon->out) {
-		u8 stk[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		smp_s1(tfm, hcon->tk, random, hcon->prnd, key);
-		swap128(key, stk);
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 
-		memset(stk + hcon->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
-
-		hci_le_start_enc(hcon, ediv, rand, stk);
-		hcon->enc_key_size = hcon->smp_key_size;
-	} else {
-		u8 stk[16], r[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		swap128(hcon->prnd, r);
-		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
-
-		smp_s1(tfm, hcon->tk, hcon->prnd, random, key);
-		swap128(key, stk);
+	BT_DBG("conn %p", conn);
 
-		memset(stk + hcon->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
+	swap128(skb->data, smp->rrnd);
+	skb_pull(skb, sizeof(smp->rrnd));
 
-		hci_add_ltk(conn->hcon->hdev, 0, conn->dst, hcon->dst_type,
-			hcon->smp_key_size, hcon->auth, ediv, rand, stk);
-	}
+	queue_work(hdev->workqueue, &smp->random);
 
 	return 0;
 }
 
-static int smp_encrypt_link(struct hci_conn *hcon, struct link_key *key)
+static u8 smp_ltk_encrypt(struct l2cap_conn *conn)
 {
-	struct key_master_id *master;
-	u8 sec_level;
-	u8 zerobuf[8];
-
-	if (!hcon || !key || !key->data)
-		return -EINVAL;
-
-	memset(zerobuf, 0, sizeof(zerobuf));
-
-	master = (void *) key->data;
-
-	if (!master->ediv && !memcmp(master->rand, zerobuf, sizeof(zerobuf)))
-		return -EINVAL;
-
-	hcon->enc_key_size = key->pin_len;
-	hcon->sec_req = TRUE;
-	sec_level = authreq_to_seclevel(key->auth);
-
-	BT_DBG("cur %d, req: %d", hcon->sec_level, sec_level);
+	struct smp_ltk *key;
+	struct hci_conn *hcon = conn->hcon;
 
-	if (sec_level > hcon->sec_level)
-		hcon->pending_sec_level = sec_level;
+	key = hci_find_ltk_by_addr(hcon->hdev, conn->dst, hcon->dst_type);
+	if (!key)
+		return 0;
 
+	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags))
+		return 1;
 
-	if (!(hcon->link_mode & HCI_LM_ENCRYPT))
-		hci_conn_hold(hcon);
+	hci_le_start_enc(hcon, key->ediv, key->rand, key->val);
+	hcon->enc_key_size = key->enc_size;
 
-	hci_le_start_enc(hcon, master->ediv, master->rand, key->val);
+	return 1;
 
-	return 0;
 }
-
 static u8 smp_cmd_security_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_security_req *rp = (void *) skb->data;
 	struct smp_cmd_pairing cp;
-	struct link_key *key;
+	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp;
 
 	BT_DBG("conn %p", conn);
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
-		return 0;
-
-	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
-	if (key && ((key->auth & SMP_AUTH_MITM) ||
-					!(rp->auth_req & SMP_AUTH_MITM))) {
+	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
 
-		if (smp_encrypt_link(hcon, key) < 0)
-			goto invalid_key;
+	if (smp_ltk_encrypt(conn))
+		return 0;
 
+	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags))
 		return 0;
-	}
 
-invalid_key:
-	hcon->sec_req = FALSE;
+	smp = smp_chan_create(conn);
 
 	skb_pull(skb, sizeof(*rp));
 
 	memset(&cp, 0, sizeof(cp));
 	build_pairing_cmd(conn, &cp, NULL, rp->auth_req);
 
-	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
-	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&hcon->preq[1], &cp, sizeof(cp));
+	smp->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&smp->preq[1], &cp, sizeof(cp));
 
 	smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
 
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
-
-	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-
-	hci_conn_hold(hcon);
-
 	return 0;
 }
 
-int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level)
+int smp_conn_security(struct hci_conn *hcon, __u8 sec_level)
 {
-	struct hci_conn *hcon = conn->hcon;
+	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct smp_chan *smp = conn->smp_chan;
 	__u8 authreq;
 
-	BT_DBG("conn %p hcon %p %d req: %d",
-			conn, hcon, hcon->sec_level, sec_level);
+	BT_DBG("conn %p hcon %p level 0x%2.2x", conn, hcon, sec_level);
 
-	if (IS_ERR(hcon->hdev->tfm))
+	if (!lmp_host_le_capable(hcon->hdev))
 		return 1;
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
-		return -EINPROGRESS;
-
 	if (sec_level == BT_SECURITY_LOW)
 		return 1;
 
-
 	if (hcon->sec_level >= sec_level)
 		return 1;
 
-	authreq = seclevel_to_authreq(sec_level);
-
-	hcon->smp_conn = conn;
-	hcon->pending_sec_level = sec_level;
-	if (hcon->link_mode & HCI_LM_MASTER) {
-		struct link_key *key;
+	if (hcon->link_mode & HCI_LM_MASTER)
+		if (smp_ltk_encrypt(conn))
+			goto done;
 
-		key = hci_find_link_key_type(hcon->hdev, conn->dst,
-							KEY_TYPE_LTK);
+	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags))
+		return 0;
 
-		if (smp_encrypt_link(hcon, key) == 0)
-			goto done;
-	}
+	smp = smp_chan_create(conn);
+	if (!smp)
+		return 1;
 
-	hcon->sec_req = FALSE;
+	authreq = seclevel_to_authreq(sec_level);
 
 	if (hcon->link_mode & HCI_LM_MASTER) {
 		struct smp_cmd_pairing cp;
 
 		build_pairing_cmd(conn, &cp, NULL, authreq);
-		hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-		memcpy(&hcon->preq[1], &cp, sizeof(cp));
-
-		mod_timer(&hcon->smp_timer, jiffies +
-					msecs_to_jiffies(SMP_TIMEOUT));
+		smp->preq[0] = SMP_CMD_PAIRING_REQ;
+		memcpy(&smp->preq[1], &cp, sizeof(cp));
 
 		smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
-		hci_conn_hold(hcon);
 	} else {
 		struct smp_cmd_security_req cp;
 		cp.auth_req = authreq;
@@ -791,95 +800,80 @@
 	}
 
 done:
-	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+	hcon->pending_sec_level = sec_level;
 
 	return 0;
 }
 
 static int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_encrypt_info *rp = (void *) skb->data;
-	u8 rand[8];
-	int err;
+	struct smp_chan *smp = conn->smp_chan;
 
 	skb_pull(skb, sizeof(*rp));
 
-	BT_DBG("conn %p", conn);
-
-	memset(rand, 0, sizeof(rand));
-
-	err = hci_add_ltk(hcon->hdev, 0, conn->dst, hcon->dst_type,
-						0, 0, 0, rand, rp->ltk);
-	if (err)
-		return SMP_UNSPECIFIED;
+	memcpy(smp->tk, rp->ltk, sizeof(smp->tk));
 
 	return 0;
 }
 
 static int smp_cmd_master_ident(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_master_ident *rp = (void *) skb->data;
-	struct smp_cmd_pairing *paircmd = (void *) &hcon->prsp[1];
-	struct link_key *key;
-	u8 *keydist;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
+	struct hci_conn *hcon = conn->hcon;
+	u8 authenticated;
 
 	skb_pull(skb, sizeof(*rp));
 
-	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
-	if (key == NULL)
-		return SMP_UNSPECIFIED;
-
-	if (hcon->out)
-		keydist = &paircmd->resp_key_dist;
-	else
-		keydist = &paircmd->init_key_dist;
-
-	BT_DBG("keydist 0x%x", *keydist);
-
-	hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
-			hcon->smp_key_size, hcon->auth, rp->ediv,
-			rp->rand, key->val);
-
-	*keydist &= ~SMP_DIST_ENC_KEY;
-	if (hcon->out) {
-		if (!(*keydist))
-			smp_distribute_keys(conn, 1);
-	}
+	hci_dev_lock(hdev);
+	authenticated = (conn->hcon->sec_level == BT_SECURITY_HIGH);
+	hci_add_ltk(conn->hcon->hdev, conn->dst, hcon->dst_type,
+		    HCI_SMP_LTK, 1, authenticated, smp->tk, smp->enc_key_size,
+		    rp->ediv, rp->rand);
+	smp_distribute_keys(conn, 1);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
 
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	__u8 code = skb->data[0];
 	__u8 reason;
 	int err = 0;
 
-	if (IS_ERR(hcon->hdev->tfm)) {
-		err = PTR_ERR(hcon->hdev->tfm);
+	if (!lmp_host_le_capable(conn->hcon->hdev)) {
+		err = -ENOTSUPP;
 		reason = SMP_PAIRING_NOTSUPP;
-		BT_ERR("SMP_PAIRING_NOTSUPP %p", hcon->hdev->tfm);
 		goto done;
 	}
 
-	hcon->smp_conn = conn;
 	skb_pull(skb, sizeof(code));
 
+	/*
+	 * The SMP context must be initialized for all other PDUs except
+	 * pairing and security requests. If we get any other PDU when
+	 * not initialized simply disconnect (done if this function
+	 * returns an error).
+	 */
+	if (code != SMP_CMD_PAIRING_REQ && code != SMP_CMD_SECURITY_REQ &&
+	    !conn->smp_chan) {
+		BT_ERR("Unexpected SMP command 0x%02x. Disconnecting.", code);
+		kfree_skb(skb);
+		return -ENOTSUPP;
+	}
+
 	switch (code) {
 	case SMP_CMD_PAIRING_REQ:
 		reason = smp_cmd_pairing_req(conn, skb);
 		break;
 
 	case SMP_CMD_PAIRING_FAIL:
+		smp_failure(conn, skb->data[0], 0);
 		reason = 0;
 		err = -EPERM;
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, skb->data[0]);
-		hci_conn_put(hcon);
 		break;
 
 	case SMP_CMD_PAIRING_RSP:
@@ -922,40 +916,33 @@
 	}
 
 done:
-	if (reason) {
-		BT_ERR("SMP_CMD_PAIRING_FAIL: %d", reason);
-		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
-								&reason);
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
-		hci_conn_put(hcon);
-	}
+	if (reason)
+		smp_failure(conn, reason, 1);
 
 	kfree_skb(skb);
 	return err;
 }
 
-static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
+int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp;
+	struct smp_chan *smp = conn->smp_chan;
 	__u8 *keydist;
 
 	BT_DBG("conn %p force %d", conn, force);
 
-	if (IS_ERR(hcon->hdev->tfm))
-		return PTR_ERR(hcon->hdev->tfm);
+	if (!test_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		return 0;
 
-	rsp = (void *) &hcon->prsp[1];
+	rsp = (void *) &smp->prsp[1];
 
 	/* The responder sends its keys first */
-	if (!force && hcon->out && (rsp->resp_key_dist & 0x07))
+	if (!force && conn->hcon->out && (rsp->resp_key_dist & 0x07))
 		return 0;
 
-	req = (void *) &hcon->preq[1];
+	req = (void *) &smp->preq[1];
 
-	if (hcon->out) {
+	if (conn->hcon->out) {
 		keydist = &rsp->init_key_dist;
 		*keydist &= req->init_key_dist;
 	} else {
@@ -969,6 +956,8 @@
 	if (*keydist & SMP_DIST_ENC_KEY) {
 		struct smp_cmd_encrypt_info enc;
 		struct smp_cmd_master_ident ident;
+		struct hci_conn *hcon = conn->hcon;
+		u8 authenticated;
 		__le16 ediv;
 
 		get_random_bytes(enc.ltk, sizeof(enc.ltk));
@@ -977,9 +966,10 @@
 
 		smp_send_cmd(conn, SMP_CMD_ENCRYPT_INFO, sizeof(enc), &enc);
 
-		hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
-				hcon->smp_key_size, hcon->auth, ediv,
-				ident.rand, enc.ltk);
+		authenticated = hcon->sec_level == BT_SECURITY_HIGH;
+		hci_add_ltk(conn->hcon->hdev, conn->dst, hcon->dst_type,
+			    HCI_SMP_LTK_SLAVE, 1, authenticated,
+			    enc.ltk, smp->enc_key_size, ediv, ident.rand);
 
 		ident.ediv = cpu_to_le16(ediv);
 
@@ -1018,55 +1008,11 @@
 		*keydist &= ~SMP_DIST_SIGN;
 	}
 
-	if (hcon->out) {
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, 0);
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		hci_conn_put(hcon);
-	} else if (rsp->resp_key_dist) {
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
-		hci_conn_put(hcon);
+	if (conn->hcon->out || force) {
+		clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags);
+		cancel_delayed_work_sync(&conn->security_timer);
+		smp_chan_destroy(conn);
 	}
 
 	return 0;
 }
-
-int smp_link_encrypt_cmplt(struct l2cap_conn *conn, u8 status, u8 encrypt)
-{
-	struct hci_conn *hcon = conn->hcon;
-
-	BT_DBG("smp: %d %d %d", status, encrypt, hcon->sec_req);
-
-	clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-
-	if (!status && encrypt && hcon->sec_level < hcon->pending_sec_level)
-		hcon->sec_level = hcon->pending_sec_level;
-
-	if (!status && encrypt && !hcon->sec_req)
-		return smp_distribute_keys(conn, 0);
-
-	/* Fall back to Pairing request if failed a Link Security request */
-	else if (hcon->sec_req  && (status || !encrypt))
-		smp_conn_security(conn, hcon->pending_sec_level);
-
-	hci_conn_put(hcon);
-
-	return 0;
-}
-
-void smp_timeout(unsigned long arg)
-{
-	struct l2cap_conn *conn = (void *) arg;
-	u8 reason = SMP_UNSPECIFIED;
-
-	BT_DBG("%p", conn);
-
-	smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason), &reason);
-	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->pend);
-	mgmt_auth_failed(conn->hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
-	hci_conn_put(conn->hcon);
-}
Binary files flo-ElementalX-5.00/scripts/basic/fixdep and flo-ElementalX-5.00-patched/scripts/basic/fixdep differ
Binary files flo-ElementalX-5.00/scripts/bin2c and flo-ElementalX-5.00-patched/scripts/bin2c differ
Binary files flo-ElementalX-5.00/scripts/conmakehash and flo-ElementalX-5.00-patched/scripts/conmakehash differ
Binary files flo-ElementalX-5.00/scripts/kallsyms and flo-ElementalX-5.00-patched/scripts/kallsyms differ
Binary files flo-ElementalX-5.00/scripts/kconfig/conf and flo-ElementalX-5.00-patched/scripts/kconfig/conf differ
diff -urN flo-ElementalX-5.00/scripts/kconfig/zconf.hash.c flo-ElementalX-5.00-patched/scripts/kconfig/zconf.hash.c
--- flo-ElementalX-5.00/scripts/kconfig/zconf.hash.c	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/scripts/kconfig/zconf.hash.c	2016-06-01 15:48:04.000000000 +0000
@@ -0,0 +1,286 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 10 "scripts/kconfig/zconf.gperf"
+struct kconf_id;
+
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
+  };
+static const struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "if",
+    "int",
+    "endif",
+    "default",
+    "tristate",
+    "endchoice",
+    "def_tristate",
+    "def_bool",
+    "defconfig_list",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
+    "modules",
+    "menu",
+    "select",
+    "comment",
+    "env",
+    "range",
+    "choice",
+    "bool",
+    "source",
+    "visible",
+    "hex",
+    "config",
+    "boolean",
+    "string",
+    "help",
+    "prompt",
+    "depends"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 72
+    };
+
+  static const struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {-1},
+#line 16 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
+      {-1}, {-1},
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+#line 47 "scripts/kconfig/zconf.gperf"
+
diff -urN flo-ElementalX-5.00/scripts/kconfig/zconf.lex.c flo-ElementalX-5.00-patched/scripts/kconfig/zconf.lex.c
--- flo-ElementalX-5.00/scripts/kconfig/zconf.lex.c	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/scripts/kconfig/zconf.lex.c	2016-06-01 15:48:04.000000000 +0000
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -urN flo-ElementalX-5.00/scripts/kconfig/zconf.tab.c flo-ElementalX-5.00-patched/scripts/kconfig/zconf.tab.c
--- flo-ElementalX-5.00/scripts/kconfig/zconf.tab.c	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/scripts/kconfig/zconf.tab.c	2016-06-01 15:48:04.000000000 +0000
@@ -0,0 +1,2504 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	const struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   104,   104,   104,   106,   106,   108,   110,   111,   112,
+     113,   114,   115,   119,   123,   123,   123,   123,   123,   123,
+     123,   123,   127,   128,   129,   130,   131,   132,   136,   137,
+     143,   151,   157,   165,   175,   177,   178,   179,   180,   181,
+     182,   185,   193,   199,   209,   215,   221,   224,   226,   237,
+     238,   243,   252,   257,   265,   268,   270,   271,   272,   273,
+     274,   277,   283,   294,   300,   310,   312,   317,   325,   333,
+     336,   338,   339,   340,   345,   352,   359,   364,   372,   375,
+     377,   378,   379,   382,   390,   397,   404,   410,   417,   419,
+     420,   421,   424,   432,   434,   435,   438,   445,   447,   452,
+     453,   456,   457,   458,   462,   463,   466,   467,   470,   471,
+     472,   473,   474,   475,   476,   479,   480,   483,   484
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "zconf.lex.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -urN flo-ElementalX-5.00/scripts/mod/elfconfig.h flo-ElementalX-5.00-patched/scripts/mod/elfconfig.h
--- flo-ElementalX-5.00/scripts/mod/elfconfig.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/scripts/mod/elfconfig.h	2016-06-01 21:26:28.000000000 +0000
@@ -0,0 +1,4 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS64
+#define HOST_ELFDATA ELFDATA2LSB
Binary files flo-ElementalX-5.00/scripts/mod/mk_elfconfig and flo-ElementalX-5.00-patched/scripts/mod/mk_elfconfig differ
Binary files flo-ElementalX-5.00/scripts/mod/modpost and flo-ElementalX-5.00-patched/scripts/mod/modpost differ
Binary files flo-ElementalX-5.00/scripts/selinux/genheaders/genheaders and flo-ElementalX-5.00-patched/scripts/selinux/genheaders/genheaders differ
Binary files flo-ElementalX-5.00/scripts/selinux/mdp/mdp and flo-ElementalX-5.00-patched/scripts/selinux/mdp/mdp differ
diff -urN flo-ElementalX-5.00/sound/oss/midi_ctrl.h flo-ElementalX-5.00-patched/sound/oss/midi_ctrl.h
--- flo-ElementalX-5.00/sound/oss/midi_ctrl.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/sound/oss/midi_ctrl.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,22 +0,0 @@
-static unsigned char ctrl_def_values[128] =
-{
-	0x40,0x00,0x40,0x40,  0x40,0x40,0x40,0x7f,	/*   0 to   7 */
-	0x40,0x40,0x40,0x7f,  0x40,0x40,0x40,0x40,	/*   8 to  15 */
-	0x40,0x40,0x40,0x40,  0x40,0x40,0x40,0x40,	/*  16 to  23 */
-	0x40,0x40,0x40,0x40,  0x40,0x40,0x40,0x40,	/*  24 to  31 */
-
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  32 to  39 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  40 to  47 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  48 to  55 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  56 to  63 */
-	
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  64 to  71 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  72 to  79 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  80 to  87 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/*  88 to  95 */
-
-	0x00,0x00,0x7f,0x7f,  0x7f,0x7f,0x00,0x00,	/*  96 to 103 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/* 104 to 111 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/* 112 to 119 */
-	0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,	/* 120 to 127 */
-};
diff -urN flo-ElementalX-5.00/sound/pci/ctxfi/ct20k2reg.h flo-ElementalX-5.00-patched/sound/pci/ctxfi/ct20k2reg.h
--- flo-ElementalX-5.00/sound/pci/ctxfi/ct20k2reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/sound/pci/ctxfi/ct20k2reg.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,89 +0,0 @@
-/**
- * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
- *
- * This source file is released under GPL v2 license (no other versions).
- * See the COPYING file included in the main directory of this source
- * distribution for the license terms and conditions.
- */
-
-#ifndef _20K2REGISTERS_H_
-#define _20K2REGISTERS_H_
-
-
-/* Timer Registers */
-#define WC		0x1b7000
-#define TIMR		0x1b7004
-# define	TIMR_IE		(1<<15)
-# define	TIMR_IP		(1<<14)
-#define GIP		0x1b7010
-#define GIE		0x1b7014
-
-/* I2C Registers */
-#define I2C_IF_ADDRESS   0x1B9000
-#define I2C_IF_WDATA     0x1B9004
-#define I2C_IF_RDATA     0x1B9008
-#define I2C_IF_STATUS    0x1B900C
-#define I2C_IF_WLOCK     0x1B9010
-
-/* Global Control Registers */
-#define GLOBAL_CNTL_GCTL    0x1B7090
-
-/* PLL Registers */
-#define PLL_CTL 		0x1B7080
-#define PLL_STAT		0x1B7084
-#define PLL_ENB			0x1B7088
-
-/* SRC Registers */
-#define SRC_CTL             0x1A0000 /* 0x1A0000 + (256 * Chn) */
-#define SRC_CCR             0x1A0004 /* 0x1A0004 + (256 * Chn) */
-#define SRC_IMAP            0x1A0008 /* 0x1A0008 + (256 * Chn) */
-#define SRC_CA              0x1A0010 /* 0x1A0010 + (256 * Chn) */
-#define SRC_CF              0x1A0014 /* 0x1A0014 + (256 * Chn) */
-#define SRC_SA              0x1A0018 /* 0x1A0018 + (256 * Chn) */
-#define SRC_LA              0x1A001C /* 0x1A001C + (256 * Chn) */
-#define SRC_CTLSWR	    0x1A0020 /* 0x1A0020 + (256 * Chn) */
-#define SRC_CD		    0x1A0080 /* 0x1A0080 + (256 * Chn) + (4 * Regn) */
-#define SRC_MCTL		0x1A012C
-#define SRC_IP			0x1A102C /* 0x1A102C + (256 * Regn) */
-#define SRC_ENB			0x1A282C /* 0x1A282C + (256 * Regn) */
-#define SRC_ENBSTAT		0x1A202C
-#define SRC_ENBSA		0x1A232C
-#define SRC_DN0Z		0x1A0030
-#define SRC_DN1Z		0x1A0040
-#define SRC_UPZ			0x1A0060
-
-/* GPIO Registers */
-#define GPIO_DATA           0x1B7020
-#define GPIO_CTRL           0x1B7024
-#define GPIO_EXT_DATA       0x1B70A0
-
-/* Virtual memory registers */
-#define VMEM_PTPAL          0x1C6300 /* 0x1C6300 + (16 * Chn) */
-#define VMEM_PTPAH          0x1C6304 /* 0x1C6304 + (16 * Chn) */
-#define VMEM_CTL            0x1C7000
-
-/* Transport Registers */
-#define TRANSPORT_ENB       0x1B6000
-#define TRANSPORT_CTL       0x1B6004
-#define TRANSPORT_INT       0x1B6008
-
-/* Audio IO */
-#define AUDIO_IO_AIM        0x1B5000 /* 0x1B5000 + (0x04 * Chn) */
-#define AUDIO_IO_TX_CTL     0x1B5400 /* 0x1B5400 + (0x40 * Chn) */
-#define AUDIO_IO_TX_CSTAT_L 0x1B5408 /* 0x1B5408 + (0x40 * Chn) */
-#define AUDIO_IO_TX_CSTAT_H 0x1B540C /* 0x1B540C + (0x40 * Chn) */
-#define AUDIO_IO_RX_CTL     0x1B5410 /* 0x1B5410 + (0x40 * Chn) */
-#define AUDIO_IO_RX_SRT_CTL 0x1B5420 /* 0x1B5420 + (0x40 * Chn) */
-#define AUDIO_IO_MCLK       0x1B5600
-#define AUDIO_IO_TX_BLRCLK  0x1B5604
-#define AUDIO_IO_RX_BLRCLK  0x1B5608
-
-/* Mixer */
-#define MIXER_AMOPLO		0x130000 /* 0x130000 + (8 * Chn) [4095 : 0] */
-#define MIXER_AMOPHI		0x130004 /* 0x130004 + (8 * Chn) [4095 : 0] */
-#define MIXER_PRING_LO_HI	0x188000 /* 0x188000 + (4 * Chn) [4095 : 0] */
-#define MIXER_PMOPLO		0x138000 /* 0x138000 + (8 * Chn) [4095 : 0] */
-#define MIXER_PMOPHI		0x138004 /* 0x138004 + (8 * Chn) [4095 : 0] */
-#define MIXER_AR_ENABLE		0x19000C
-
-#endif
diff -urN flo-ElementalX-5.00/sound/soc/codecs/wcd9320.c flo-ElementalX-5.00-patched/sound/soc/codecs/wcd9320.c
--- flo-ElementalX-5.00/sound/soc/codecs/wcd9320.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/sound/soc/codecs/wcd9320.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,7679 +0,0 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/firmware.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/printk.h>
-#include <linux/ratelimit.h>
-#include <linux/debugfs.h>
-#include <linux/mfd/wcd9xxx/core.h>
-#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
-#include <linux/mfd/wcd9xxx/wcd9320_registers.h>
-#include <linux/mfd/wcd9xxx/pdata.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/tlv.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <linux/kernel.h>
-#include <linux/gpio.h>
-#include "wcd9320.h"
-
-#define WCD9320_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\
-			SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 |\
-			SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
-
-
-#define NUM_DECIMATORS 10
-#define NUM_INTERPOLATORS 7
-#define BITS_PER_REG 8
-#define TAIKO_CFILT_FAST_MODE 0x00
-#define TAIKO_CFILT_SLOW_MODE 0x40
-#define MBHC_FW_READ_ATTEMPTS 15
-#define MBHC_FW_READ_TIMEOUT 2000000
-
-enum {
-	MBHC_USE_HPHL_TRIGGER = 1,
-	MBHC_USE_MB_TRIGGER = 2
-};
-
-#define MBHC_NUM_DCE_PLUG_DETECT 3
-#define NUM_ATTEMPTS_INSERT_DETECT 25
-#define NUM_ATTEMPTS_TO_REPORT 5
-
-#define TAIKO_JACK_MASK (SND_JACK_HEADSET | SND_JACK_OC_HPHL | \
-			 SND_JACK_OC_HPHR | SND_JACK_UNSUPPORTED)
-
-#define TAIKO_I2S_MASTER_MODE_MASK 0x08
-
-#define TAIKO_OCP_ATTEMPT 1
-
-#define AIF1_PB 1
-#define AIF1_CAP 2
-#define AIF2_PB 3
-#define AIF2_CAP 4
-#define AIF3_CAP 5
-#define AIF3_PB  6
-
-#define NUM_CODEC_DAIS 6
-#define TAIKO_COMP_DIGITAL_GAIN_OFFSET 3
-
-struct taiko_codec_dai_data {
-	u32 rate;
-	u32 *ch_num;
-	u32 ch_act;
-	u32 ch_tot;
-};
-
-#define TAIKO_MCLK_RATE_12288KHZ 12288000
-#define TAIKO_MCLK_RATE_9600KHZ 9600000
-
-#define TAIKO_FAKE_INS_THRESHOLD_MS 2500
-#define TAIKO_FAKE_REMOVAL_MIN_PERIOD_MS 50
-
-#define TAIKO_MBHC_BUTTON_MIN 0x8000
-
-#define TAIKO_MBHC_FAKE_INSERT_LOW 10
-#define TAIKO_MBHC_FAKE_INSERT_HIGH 80
-#define TAIKO_MBHC_FAKE_INS_HIGH_NO_GPIO 150
-
-#define TAIKO_MBHC_STATUS_REL_DETECTION 0x0C
-
-#define TAIKO_MBHC_GPIO_REL_DEBOUNCE_TIME_MS 200
-
-#define TAIKO_MBHC_FAKE_INS_DELTA_MV 200
-#define TAIKO_MBHC_FAKE_INS_DELTA_SCALED_MV 300
-
-#define TAIKO_HS_DETECT_PLUG_TIME_MS (5 * 1000)
-#define TAIKO_HS_DETECT_PLUG_INERVAL_MS 100
-
-#define TAIKO_GPIO_IRQ_DEBOUNCE_TIME_US 5000
-
-#define TAIKO_MBHC_GND_MIC_SWAP_THRESHOLD 2
-
-#define TAIKO_ACQUIRE_LOCK(x) do { mutex_lock(&x); } while (0)
-#define TAIKO_RELEASE_LOCK(x) do { mutex_unlock(&x); } while (0)
-
-static const DECLARE_TLV_DB_SCALE(digital_gain, 0, 1, 0);
-static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
-static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
-static struct snd_soc_dai_driver taiko_dai[];
-static const DECLARE_TLV_DB_SCALE(aux_pga_gain, 0, 2, 0);
-
-enum taiko_bandgap_type {
-	TAIKO_BANDGAP_OFF = 0,
-	TAIKO_BANDGAP_AUDIO_MODE,
-	TAIKO_BANDGAP_MBHC_MODE,
-};
-
-struct mbhc_micbias_regs {
-	u16 cfilt_val;
-	u16 cfilt_ctl;
-	u16 mbhc_reg;
-	u16 int_rbias;
-	u16 ctl_reg;
-	u8 cfilt_sel;
-};
-
-/* Codec supports 2 IIR filters */
-enum {
-	IIR1 = 0,
-	IIR2,
-	IIR_MAX,
-};
-/* Codec supports 5 bands */
-enum {
-	BAND1 = 0,
-	BAND2,
-	BAND3,
-	BAND4,
-	BAND5,
-	BAND_MAX,
-};
-
-enum {
-	COMPANDER_1 = 0,
-	COMPANDER_2,
-	COMPANDER_MAX,
-};
-
-enum {
-	COMPANDER_FS_8KHZ = 0,
-	COMPANDER_FS_16KHZ,
-	COMPANDER_FS_32KHZ,
-	COMPANDER_FS_48KHZ,
-	COMPANDER_FS_96KHZ,
-	COMPANDER_FS_192KHZ,
-	COMPANDER_FS_MAX,
-};
-
-/* Flags to track of PA and DAC state.
- * PA and DAC should be tracked separately as AUXPGA loopback requires
- * only PA to be turned on without DAC being on. */
-enum taiko_priv_ack_flags {
-	TAIKO_HPHL_PA_OFF_ACK = 0,
-	TAIKO_HPHR_PA_OFF_ACK,
-	TAIKO_HPHL_DAC_OFF_ACK,
-	TAIKO_HPHR_DAC_OFF_ACK
-};
-
-
-struct comp_sample_dependent_params {
-	u32 peak_det_timeout;
-	u32 rms_meter_div_fact;
-	u32 rms_meter_resamp_fact;
-};
-
-/* Data used by MBHC */
-struct mbhc_internal_cal_data {
-	u16 dce_z;
-	u16 dce_mb;
-	u16 sta_z;
-	u16 sta_mb;
-	u32 t_sta_dce;
-	u32 t_dce;
-	u32 t_sta;
-	u32 micb_mv;
-	u16 v_ins_hu;
-	u16 v_ins_h;
-	u16 v_b1_hu;
-	u16 v_b1_h;
-	u16 v_b1_huc;
-	u16 v_brh;
-	u16 v_brl;
-	u16 v_no_mic;
-	u8 npoll;
-	u8 nbounce_wait;
-	s16 adj_v_hs_max;
-	u16 adj_v_ins_hu;
-	u16 adj_v_ins_h;
-	s16 v_inval_ins_low;
-	s16 v_inval_ins_high;
-};
-
-struct taiko_reg_address {
-	u16 micb_4_ctl;
-	u16 micb_4_int_rbias;
-	u16 micb_4_mbhc;
-};
-
-enum taiko_mbhc_plug_type {
-	PLUG_TYPE_INVALID = -1,
-	PLUG_TYPE_NONE,
-	PLUG_TYPE_HEADSET,
-	PLUG_TYPE_HEADPHONE,
-	PLUG_TYPE_HIGH_HPH,
-	PLUG_TYPE_GND_MIC_SWAP,
-};
-
-enum taiko_mbhc_state {
-	MBHC_STATE_NONE = -1,
-	MBHC_STATE_POTENTIAL,
-	MBHC_STATE_POTENTIAL_RECOVERY,
-	MBHC_STATE_RELEASE,
-};
-
-struct hpf_work {
-	struct taiko_priv *taiko;
-	u32 decimator;
-	u8 tx_hpf_cut_of_freq;
-	struct delayed_work dwork;
-};
-
-static struct hpf_work tx_hpf_work[NUM_DECIMATORS];
-
-struct taiko_priv {
-	struct snd_soc_codec *codec;
-	struct taiko_reg_address reg_addr;
-	u32 adc_count;
-	u32 cfilt1_cnt;
-	u32 cfilt2_cnt;
-	u32 cfilt3_cnt;
-	u32 rx_bias_count;
-	s32 dmic_1_2_clk_cnt;
-	s32 dmic_3_4_clk_cnt;
-	s32 dmic_5_6_clk_cnt;
-
-	enum taiko_bandgap_type bandgap_type;
-	bool mclk_enabled;
-	bool clock_active;
-	bool config_mode_active;
-	bool mbhc_polling_active;
-	unsigned long mbhc_fake_ins_start;
-	int buttons_pressed;
-	enum taiko_mbhc_state mbhc_state;
-	struct taiko_mbhc_config mbhc_cfg;
-	struct mbhc_internal_cal_data mbhc_data;
-
-	struct wcd9xxx_pdata *pdata;
-	u32 anc_slot;
-
-	bool no_mic_headset_override;
-	/* Delayed work to report long button press */
-	struct delayed_work mbhc_btn_dwork;
-
-	struct mbhc_micbias_regs mbhc_bias_regs;
-	bool mbhc_micbias_switched;
-
-	/* track PA/DAC state */
-	unsigned long hph_pa_dac_state;
-
-	/*track taiko interface type*/
-	u8 intf_type;
-
-	u32 hph_status; /* track headhpone status */
-	/* define separate work for left and right headphone OCP to avoid
-	 * additional checking on which OCP event to report so no locking
-	 * to ensure synchronization is required
-	 */
-	struct work_struct hphlocp_work; /* reporting left hph ocp off */
-	struct work_struct hphrocp_work; /* reporting right hph ocp off */
-
-	u8 hphlocp_cnt; /* headphone left ocp retry */
-	u8 hphrocp_cnt; /* headphone right ocp retry */
-
-	/* Work to perform MBHC Firmware Read */
-	struct delayed_work mbhc_firmware_dwork;
-	const struct firmware *mbhc_fw;
-
-	/* num of slim ports required */
-	struct taiko_codec_dai_data dai[NUM_CODEC_DAIS];
-
-	/*compander*/
-	int comp_enabled[COMPANDER_MAX];
-	u32 comp_fs[COMPANDER_MAX];
-
-	/* Maintain the status of AUX PGA */
-	int aux_pga_cnt;
-	u8 aux_l_gain;
-	u8 aux_r_gain;
-
-	struct delayed_work mbhc_insert_dwork;
-	unsigned long mbhc_last_resume; /* in jiffies */
-
-	u8 current_plug;
-	struct work_struct hs_correct_plug_work;
-	bool hs_detect_work_stop;
-	bool hs_polling_irq_prepared;
-	bool lpi_enabled; /* low power insertion detection */
-	bool in_gpio_handler;
-	/* Currently, only used for mbhc purpose, to protect
-	 * concurrent execution of mbhc threaded irq handlers and
-	 * kill race between DAPM and MBHC.But can serve as a
-	 * general lock to protect codec resource
-	 */
-	struct mutex codec_resource_lock;
-
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs_poke;
-	struct dentry *debugfs_mbhc;
-#endif
-};
-
-
-static const u32 comp_shift[] = {
-	0,
-	2,
-};
-
-static const int comp_rx_path[] = {
-	COMPANDER_1,
-	COMPANDER_1,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_MAX,
-};
-
-static const struct comp_sample_dependent_params comp_samp_params[] = {
-	{
-		.peak_det_timeout = 0x2,
-		.rms_meter_div_fact = 0x8 << 4,
-		.rms_meter_resamp_fact = 0x21,
-	},
-	{
-		.peak_det_timeout = 0x3,
-		.rms_meter_div_fact = 0x9 << 4,
-		.rms_meter_resamp_fact = 0x28,
-	},
-
-	{
-		.peak_det_timeout = 0x5,
-		.rms_meter_div_fact = 0xB << 4,
-		.rms_meter_resamp_fact = 0x28,
-	},
-
-	{
-		.peak_det_timeout = 0x5,
-		.rms_meter_div_fact = 0xB << 4,
-		.rms_meter_resamp_fact = 0x28,
-	},
-};
-
-static unsigned short rx_digital_gain_reg[] = {
-	TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL,
-};
-
-
-static unsigned short tx_digital_gain_reg[] = {
-	TAIKO_A_CDC_TX1_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX2_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX3_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX4_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX5_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX6_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX7_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX8_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX9_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX10_VOL_CTL_GAIN,
-};
-
-static int taiko_codec_enable_class_h_clk(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %s  %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLSH_B1_CTL, 0x01, 0x01);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_1, 0x80, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLSH_B1_CTL, 0x01, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_class_h(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %s  %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_5, 0x02, 0x02);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_4, 0xFF, 0xFF);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_1, 0x04, 0x04);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x04, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x08, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_1, 0x80, 0x80);
-		usleep_range(1000, 1000);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_charge_pump(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		usleep_range(1000, 1000);
-		break;
-	}
-	return 0;
-}
-
-
-static int taiko_get_anc_slot(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	ucontrol->value.integer.value[0] = taiko->anc_slot;
-	return 0;
-}
-
-static int taiko_put_anc_slot(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	taiko->anc_slot = ucontrol->value.integer.value[0];
-	return 0;
-}
-
-static int taiko_pa_gain_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	u8 ear_pa_gain;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-
-	ear_pa_gain = snd_soc_read(codec, TAIKO_A_RX_EAR_GAIN);
-
-	ear_pa_gain = ear_pa_gain >> 5;
-
-	if (ear_pa_gain == 0x00) {
-		ucontrol->value.integer.value[0] = 0;
-	} else if (ear_pa_gain == 0x04) {
-		ucontrol->value.integer.value[0] = 1;
-	} else  {
-		pr_err("%s: ERROR: Unsupported Ear Gain = 0x%x\n",
-				__func__, ear_pa_gain);
-		return -EINVAL;
-	}
-
-	pr_debug("%s: ear_pa_gain = 0x%x\n", __func__, ear_pa_gain);
-
-	return 0;
-}
-
-static int taiko_pa_gain_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	u8 ear_pa_gain;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-
-	pr_debug("%s: ucontrol->value.integer.value[0]  = %ld\n", __func__,
-			ucontrol->value.integer.value[0]);
-
-	switch (ucontrol->value.integer.value[0]) {
-	case 0:
-		ear_pa_gain = 0x00;
-		break;
-	case 1:
-		ear_pa_gain = 0x80;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_RX_EAR_GAIN, 0xE0, ear_pa_gain);
-	return 0;
-}
-
-static int taiko_get_iir_enable_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	ucontrol->value.integer.value[0] =
-		snd_soc_read(codec, (TAIKO_A_CDC_IIR1_CTL + 16 * iir_idx)) &
-		(1 << band_idx);
-
-	pr_debug("%s: IIR #%d band #%d enable %d\n", __func__,
-		iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[0]);
-	return 0;
-}
-
-static int taiko_put_iir_enable_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-	int value = ucontrol->value.integer.value[0];
-
-	/* Mask first 5 bits, 6-8 are reserved */
-	snd_soc_update_bits(codec, (TAIKO_A_CDC_IIR1_CTL + 16 * iir_idx),
-		(1 << band_idx), (value << band_idx));
-
-	pr_debug("%s: IIR #%d band #%d enable %d\n", __func__,
-		iir_idx, band_idx, value);
-	return 0;
-}
-static uint32_t get_iir_band_coeff(struct snd_soc_codec *codec,
-				int iir_idx, int band_idx,
-				int coeff_idx)
-{
-	/* Address does not automatically update if reading */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		(band_idx * BAND_MAX + coeff_idx) & 0x1F);
-
-	/* Mask bits top 2 bits since they are reserved */
-	return ((snd_soc_read(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx)) << 24)) &
-		0x3FFFFFFF;
-}
-
-static int taiko_get_iir_band_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	ucontrol->value.integer.value[0] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 0);
-	ucontrol->value.integer.value[1] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 1);
-	ucontrol->value.integer.value[2] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 2);
-	ucontrol->value.integer.value[3] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 3);
-	ucontrol->value.integer.value[4] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 4);
-
-	pr_debug("%s: IIR #%d band #%d b0 = 0x%x\n"
-		"%s: IIR #%d band #%d b1 = 0x%x\n"
-		"%s: IIR #%d band #%d b2 = 0x%x\n"
-		"%s: IIR #%d band #%d a1 = 0x%x\n"
-		"%s: IIR #%d band #%d a2 = 0x%x\n",
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[0],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[1],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[2],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[3],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[4]);
-	return 0;
-}
-
-static void set_iir_band_coeff(struct snd_soc_codec *codec,
-				int iir_idx, int band_idx,
-				int coeff_idx, uint32_t value)
-{
-	/* Mask top 3 bits, 6-8 are reserved */
-	/* Update address manually each time */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		(band_idx * BAND_MAX + coeff_idx) & 0x1F);
-
-	/* Mask top 2 bits, 7-8 are reserved */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
-		(value >> 24) & 0x3F);
-
-}
-
-static int taiko_put_iir_band_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	set_iir_band_coeff(codec, iir_idx, band_idx, 0,
-				ucontrol->value.integer.value[0]);
-	set_iir_band_coeff(codec, iir_idx, band_idx, 1,
-				ucontrol->value.integer.value[1]);
-	set_iir_band_coeff(codec, iir_idx, band_idx, 2,
-				ucontrol->value.integer.value[2]);
-	set_iir_band_coeff(codec, iir_idx, band_idx, 3,
-				ucontrol->value.integer.value[3]);
-	set_iir_band_coeff(codec, iir_idx, band_idx, 4,
-				ucontrol->value.integer.value[4]);
-
-	pr_debug("%s: IIR #%d band #%d b0 = 0x%x\n"
-		"%s: IIR #%d band #%d b1 = 0x%x\n"
-		"%s: IIR #%d band #%d b2 = 0x%x\n"
-		"%s: IIR #%d band #%d a1 = 0x%x\n"
-		"%s: IIR #%d band #%d a2 = 0x%x\n",
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 0),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 1),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 2),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 3),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 4));
-	return 0;
-}
-
-static int taiko_compander_gain_offset(
-	struct snd_soc_codec *codec, u32 enable,
-	unsigned int reg, int mask,	int event)
-{
-	int pa_mode = snd_soc_read(codec, reg) & mask;
-	int gain_offset = 0;
-	/*  if PMU && enable is 1-> offset is 3
-	 *  if PMU && enable is 0-> offset is 0
-	 *  if PMD && pa_mode is PA -> offset is 0: PMU compander is off
-	 *  if PMD && pa_mode is comp -> offset is -3: PMU compander is on.
-	 */
-
-	if (SND_SOC_DAPM_EVENT_ON(event) && (enable != 0))
-		gain_offset = TAIKO_COMP_DIGITAL_GAIN_OFFSET;
-	if (SND_SOC_DAPM_EVENT_OFF(event) && (pa_mode == 0))
-		gain_offset = -TAIKO_COMP_DIGITAL_GAIN_OFFSET;
-	return gain_offset;
-}
-
-
-static int taiko_config_gain_compander(
-				struct snd_soc_codec *codec,
-				u32 compander, u32 enable, int event)
-{
-	int value = 0;
-	int mask = 1 << 4;
-	int gain = 0;
-	int gain_offset;
-	if (compander >= COMPANDER_MAX) {
-		pr_err("%s: Error, invalid compander channel\n", __func__);
-		return -EINVAL;
-	}
-
-	if ((enable == 0) || SND_SOC_DAPM_EVENT_OFF(event))
-		value = 1 << 4;
-
-	if (compander == COMPANDER_1) {
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_HPH_L_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_L_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_HPH_R_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_R_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-	} else if (compander == COMPANDER_2) {
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_LINE_1_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_1_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_LINE_3_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_3_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_LINE_2_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_2_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-		gain_offset = taiko_compander_gain_offset(codec, enable,
-				TAIKO_A_RX_LINE_4_GAIN, mask, event);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_4_GAIN, mask, value);
-		gain = snd_soc_read(codec, TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL,
-				0xFF, gain - gain_offset);
-	}
-	return 0;
-}
-static int taiko_get_compander(struct snd_kcontrol *kcontrol,
-					   struct snd_ctl_elem_value *ucontrol)
-{
-
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int comp = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->max;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	ucontrol->value.integer.value[0] = taiko->comp_enabled[comp];
-
-	return 0;
-}
-
-static int taiko_set_compander(struct snd_kcontrol *kcontrol,
-					   struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	int comp = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->max;
-	int value = ucontrol->value.integer.value[0];
-
-	if (value == taiko->comp_enabled[comp]) {
-		pr_debug("%s: compander #%d enable %d no change\n",
-			    __func__, comp, value);
-		return 0;
-	}
-	taiko->comp_enabled[comp] = value;
-	return 0;
-}
-
-
-static int taiko_config_compander(struct snd_soc_dapm_widget *w,
-						  struct snd_kcontrol *kcontrol,
-						  int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u32 rate = taiko->comp_fs[w->shift];
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		if (taiko->comp_enabled[w->shift] != 0) {
-			/* Enable both L/R compander clocks */
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_RX_B2_CTL,
-					0x03 << comp_shift[w->shift],
-					0x03 << comp_shift[w->shift]);
-			/* Clar the HALT for the compander*/
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_COMP1_B1_CTL +
-					w->shift * 8, 1 << 2, 0);
-			/* Toggle compander reset bits*/
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-					0x03 << comp_shift[w->shift],
-					0x03 << comp_shift[w->shift]);
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-					0x03 << comp_shift[w->shift], 0);
-			taiko_config_gain_compander(codec, w->shift, 1, event);
-			/* Update the RMS meter resampling*/
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_COMP1_B3_CTL +
-					w->shift * 8, 0xFF, 0x01);
-			/* Wait for 1ms*/
-			usleep_range(1000, 1000);
-		}
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		/* Set sample rate dependent paramater*/
-		if (taiko->comp_enabled[w->shift] != 0) {
-			snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_FS_CFG +
-			w->shift * 8, 0x03,	rate);
-			snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B2_CTL +
-			w->shift * 8, 0x0F,
-			comp_samp_params[rate].peak_det_timeout);
-			snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B2_CTL +
-			w->shift * 8, 0xF0,
-			comp_samp_params[rate].rms_meter_div_fact);
-			snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B3_CTL +
-			w->shift * 8, 0xFF,
-			comp_samp_params[rate].rms_meter_resamp_fact);
-			/* Compander enable -> 0x370/0x378*/
-			snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B1_CTL +
-			w->shift * 8, 0x03, 0x03);
-		}
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		/* Halt the compander*/
-		snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B1_CTL +
-			w->shift * 8, 1 << 2, 1 << 2);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		/* Restore the gain */
-		taiko_config_gain_compander(codec, w->shift,
-				taiko->comp_enabled[w->shift], event);
-		/* Disable the compander*/
-		snd_soc_update_bits(codec, TAIKO_A_CDC_COMP1_B1_CTL +
-			w->shift * 8, 0x03, 0x00);
-		/* Turn off the clock for compander in pair*/
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_B2_CTL,
-			0x03 << comp_shift[w->shift], 0);
-		break;
-	}
-	return 0;
-}
-
-static const char * const taiko_ear_pa_gain_text[] = {"POS_6_DB", "POS_2_DB"};
-static const struct soc_enum taiko_ear_pa_gain_enum[] = {
-		SOC_ENUM_SINGLE_EXT(2, taiko_ear_pa_gain_text),
-};
-
-/*cut of frequency for high pass filter*/
-static const char * const cf_text[] = {
-	"MIN_3DB_4Hz", "MIN_3DB_75Hz", "MIN_3DB_150Hz"
-};
-
-static const struct soc_enum cf_dec1_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX1_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec2_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX2_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec3_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX3_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec4_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX4_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec5_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX5_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec6_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX6_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec7_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX7_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec8_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX8_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec9_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX9_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec10_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX10_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_rxmix1_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX1_B4_CTL, 1, 3, cf_text);
-
-static const struct soc_enum cf_rxmix2_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX2_B4_CTL, 1, 3, cf_text);
-
-static const struct soc_enum cf_rxmix3_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX3_B4_CTL, 1, 3, cf_text);
-
-static const struct soc_enum cf_rxmix4_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX4_B4_CTL, 1, 3, cf_text);
-
-static const struct soc_enum cf_rxmix5_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX5_B4_CTL, 1, 3, cf_text)
-;
-static const struct soc_enum cf_rxmix6_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX6_B4_CTL, 1, 3, cf_text);
-
-static const struct soc_enum cf_rxmix7_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX7_B4_CTL, 1, 3, cf_text);
-
-static const struct snd_kcontrol_new taiko_snd_controls[] = {
-
-	SOC_ENUM_EXT("EAR PA Gain", taiko_ear_pa_gain_enum[0],
-		taiko_pa_gain_get, taiko_pa_gain_put),
-
-	SOC_SINGLE_TLV("LINEOUT1 Volume", TAIKO_A_RX_LINE_1_GAIN, 0, 12, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT2 Volume", TAIKO_A_RX_LINE_2_GAIN, 0, 12, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT3 Volume", TAIKO_A_RX_LINE_3_GAIN, 0, 12, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT4 Volume", TAIKO_A_RX_LINE_4_GAIN, 0, 12, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("HPHL Volume", TAIKO_A_RX_HPH_L_GAIN, 0, 12, 1,
-		line_gain),
-	SOC_SINGLE_TLV("HPHR Volume", TAIKO_A_RX_HPH_R_GAIN, 0, 12, 1,
-		line_gain),
-
-	SOC_SINGLE_S8_TLV("RX1 Digital Volume", TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX2 Digital Volume", TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX3 Digital Volume", TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX4 Digital Volume", TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX5 Digital Volume", TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX6 Digital Volume", TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX7 Digital Volume", TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-
-	SOC_SINGLE_S8_TLV("DEC1 Volume", TAIKO_A_CDC_TX1_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC2 Volume", TAIKO_A_CDC_TX2_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC3 Volume", TAIKO_A_CDC_TX3_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC4 Volume", TAIKO_A_CDC_TX4_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC5 Volume", TAIKO_A_CDC_TX5_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC6 Volume", TAIKO_A_CDC_TX6_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC7 Volume", TAIKO_A_CDC_TX7_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC8 Volume", TAIKO_A_CDC_TX8_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC9 Volume", TAIKO_A_CDC_TX9_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC10 Volume", TAIKO_A_CDC_TX10_VOL_CTL_GAIN, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP1 Volume", TAIKO_A_CDC_IIR1_GAIN_B1_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP2 Volume", TAIKO_A_CDC_IIR1_GAIN_B2_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP3 Volume", TAIKO_A_CDC_IIR1_GAIN_B3_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP4 Volume", TAIKO_A_CDC_IIR1_GAIN_B4_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_TLV("ADC1 Volume", TAIKO_A_TX_1_2_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC2 Volume", TAIKO_A_TX_1_2_EN, 1, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC3 Volume", TAIKO_A_TX_3_4_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC4 Volume", TAIKO_A_TX_3_4_EN, 1, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC5 Volume", TAIKO_A_TX_5_6_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC6 Volume", TAIKO_A_TX_5_6_EN, 1, 3, 0, analog_gain),
-
-
-	SOC_SINGLE("MICBIAS1 CAPLESS Switch", TAIKO_A_MICB_1_CTL, 4, 1, 1),
-	SOC_SINGLE("MICBIAS2 CAPLESS Switch", TAIKO_A_MICB_2_CTL, 4, 1, 1),
-	SOC_SINGLE("MICBIAS3 CAPLESS Switch", TAIKO_A_MICB_3_CTL, 4, 1, 1),
-	SOC_SINGLE("MICBIAS4 CAPLESS Switch", TAIKO_A_MICB_4_CTL, 4, 1, 1),
-
-	SOC_SINGLE_EXT("ANC Slot", SND_SOC_NOPM, 0, 0, 100, taiko_get_anc_slot,
-		taiko_put_anc_slot),
-	SOC_ENUM("TX1 HPF cut off", cf_dec1_enum),
-	SOC_ENUM("TX2 HPF cut off", cf_dec2_enum),
-	SOC_ENUM("TX3 HPF cut off", cf_dec3_enum),
-	SOC_ENUM("TX4 HPF cut off", cf_dec4_enum),
-	SOC_ENUM("TX5 HPF cut off", cf_dec5_enum),
-	SOC_ENUM("TX6 HPF cut off", cf_dec6_enum),
-	SOC_ENUM("TX7 HPF cut off", cf_dec7_enum),
-	SOC_ENUM("TX8 HPF cut off", cf_dec8_enum),
-	SOC_ENUM("TX9 HPF cut off", cf_dec9_enum),
-	SOC_ENUM("TX10 HPF cut off", cf_dec10_enum),
-
-	SOC_SINGLE("TX1 HPF Switch", TAIKO_A_CDC_TX1_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX2 HPF Switch", TAIKO_A_CDC_TX2_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX3 HPF Switch", TAIKO_A_CDC_TX3_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX4 HPF Switch", TAIKO_A_CDC_TX4_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX5 HPF Switch", TAIKO_A_CDC_TX5_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX6 HPF Switch", TAIKO_A_CDC_TX6_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX7 HPF Switch", TAIKO_A_CDC_TX7_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX8 HPF Switch", TAIKO_A_CDC_TX8_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX9 HPF Switch", TAIKO_A_CDC_TX9_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX10 HPF Switch", TAIKO_A_CDC_TX10_MUX_CTL, 3, 1, 0),
-
-	SOC_SINGLE("RX1 HPF Switch", TAIKO_A_CDC_RX1_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX2 HPF Switch", TAIKO_A_CDC_RX2_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX3 HPF Switch", TAIKO_A_CDC_RX3_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX4 HPF Switch", TAIKO_A_CDC_RX4_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX5 HPF Switch", TAIKO_A_CDC_RX5_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX6 HPF Switch", TAIKO_A_CDC_RX6_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX7 HPF Switch", TAIKO_A_CDC_RX7_B5_CTL, 2, 1, 0),
-
-	SOC_ENUM("RX1 HPF cut off", cf_rxmix1_enum),
-	SOC_ENUM("RX2 HPF cut off", cf_rxmix2_enum),
-	SOC_ENUM("RX3 HPF cut off", cf_rxmix3_enum),
-	SOC_ENUM("RX4 HPF cut off", cf_rxmix4_enum),
-	SOC_ENUM("RX5 HPF cut off", cf_rxmix5_enum),
-	SOC_ENUM("RX6 HPF cut off", cf_rxmix6_enum),
-	SOC_ENUM("RX7 HPF cut off", cf_rxmix7_enum),
-
-	SOC_SINGLE_EXT("IIR1 Enable Band1", IIR1, BAND1, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band2", IIR1, BAND2, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band3", IIR1, BAND3, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band4", IIR1, BAND4, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band5", IIR1, BAND5, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band1", IIR2, BAND1, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band2", IIR2, BAND2, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band3", IIR2, BAND3, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band4", IIR2, BAND4, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band5", IIR2, BAND5, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-
-	SOC_SINGLE_MULTI_EXT("IIR1 Band1", IIR1, BAND1, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band2", IIR1, BAND2, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band3", IIR1, BAND3, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band4", IIR1, BAND4, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band5", IIR1, BAND5, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band1", IIR2, BAND1, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band2", IIR2, BAND2, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band3", IIR2, BAND3, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band4", IIR2, BAND4, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band5", IIR2, BAND5, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-
-	SOC_SINGLE_EXT("COMP1 Switch", SND_SOC_NOPM, 1, COMPANDER_1, 0,
-				   taiko_get_compander, taiko_set_compander),
-	SOC_SINGLE_EXT("COMP2 Switch", SND_SOC_NOPM, 0, COMPANDER_2, 0,
-				   taiko_get_compander, taiko_set_compander),
-
-};
-
-static const char * const rx_mix1_text[] = {
-	"ZERO", "SRC1", "SRC2", "IIR1", "IIR2", "RX1", "RX2", "RX3", "RX4",
-		"RX5", "RX6", "RX7"
-};
-
-static const char * const rx_mix2_text[] = {
-	"ZERO", "SRC1", "SRC2", "IIR1", "IIR2"
-};
-
-static const char * const rx_dsm_text[] = {
-	"CIC_OUT", "DSM_INV"
-};
-
-static const char * const sb_tx1_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC1"
-};
-
-static const char * const sb_tx2_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC2"
-};
-
-static const char * const sb_tx3_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC3"
-};
-
-static const char * const sb_tx4_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC4"
-};
-
-static const char * const sb_tx5_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC5"
-};
-
-static const char * const sb_tx6_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC6"
-};
-
-static const char * const sb_tx7_to_tx10_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC1", "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8",
-		"DEC9", "DEC10"
-};
-
-static const char * const dec1_mux_text[] = {
-	"ZERO", "DMIC1", "ADC6",
-};
-
-static const char * const dec2_mux_text[] = {
-	"ZERO", "DMIC2", "ADC5",
-};
-
-static const char * const dec3_mux_text[] = {
-	"ZERO", "DMIC3", "ADC4",
-};
-
-static const char * const dec4_mux_text[] = {
-	"ZERO", "DMIC4", "ADC3",
-};
-
-static const char * const dec5_mux_text[] = {
-	"ZERO", "DMIC5", "ADC2",
-};
-
-static const char * const dec6_mux_text[] = {
-	"ZERO", "DMIC6", "ADC1",
-};
-
-static const char * const dec7_mux_text[] = {
-	"ZERO", "DMIC1", "DMIC6", "ADC1", "ADC6", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const dec8_mux_text[] = {
-	"ZERO", "DMIC2", "DMIC5", "ADC2", "ADC5",
-};
-
-static const char * const dec9_mux_text[] = {
-	"ZERO", "DMIC4", "DMIC5", "ADC2", "ADC3", "ADCMB", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const dec10_mux_text[] = {
-	"ZERO", "DMIC3", "DMIC6", "ADC1", "ADC4", "ADCMB", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const anc_mux_text[] = {
-	"ZERO", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6", "ADC_MB",
-		"RSVD_1", "DMIC1", "DMIC2", "DMIC3", "DMIC4", "DMIC5", "DMIC6"
-};
-
-static const char * const anc1_fb_mux_text[] = {
-	"ZERO", "EAR_HPH_L", "EAR_LINE_1",
-};
-
-static const char * const iir1_inp1_text[] = {
-	"ZERO", "DEC1", "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8",
-	"DEC9", "DEC10", "RX1", "RX2", "RX3", "RX4", "RX5", "RX6", "RX7"
-};
-
-static const struct soc_enum rx_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx_mix1_inp3_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B2_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx2_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx2_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx3_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX3_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx3_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX3_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx4_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX4_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx4_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX4_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx5_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX5_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx5_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX5_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx6_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX6_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx6_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX6_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx7_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx7_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx1_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx1_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx2_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx2_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx7_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx7_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx4_dsm_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX4_B6_CTL, 4, 2, rx_dsm_text);
-
-static const struct soc_enum rx6_dsm_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX6_B6_CTL, 4, 2, rx_dsm_text);
-
-static const struct soc_enum sb_tx1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B1_CTL, 0, 9, sb_tx1_mux_text);
-
-static const struct soc_enum sb_tx2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B2_CTL, 0, 9, sb_tx2_mux_text);
-
-static const struct soc_enum sb_tx3_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B3_CTL, 0, 9, sb_tx3_mux_text);
-
-static const struct soc_enum sb_tx4_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B4_CTL, 0, 9, sb_tx4_mux_text);
-
-static const struct soc_enum sb_tx5_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B5_CTL, 0, 9, sb_tx5_mux_text);
-
-static const struct soc_enum sb_tx6_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B6_CTL, 0, 9, sb_tx6_mux_text);
-
-static const struct soc_enum sb_tx7_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B7_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx8_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B8_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx9_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B9_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx10_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B10_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum dec1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 0, 3, dec1_mux_text);
-
-static const struct soc_enum dec2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 2, 3, dec2_mux_text);
-
-static const struct soc_enum dec3_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 4, 3, dec3_mux_text);
-
-static const struct soc_enum dec4_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 6, 3, dec4_mux_text);
-
-static const struct soc_enum dec5_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 0, 3, dec5_mux_text);
-
-static const struct soc_enum dec6_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 2, 3, dec6_mux_text);
-
-static const struct soc_enum dec7_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 4, 7, dec7_mux_text);
-
-static const struct soc_enum dec8_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B3_CTL, 0, 7, dec8_mux_text);
-
-static const struct soc_enum dec9_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B3_CTL, 3, 8, dec9_mux_text);
-
-static const struct soc_enum dec10_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B4_CTL, 0, 8, dec10_mux_text);
-
-static const struct soc_enum anc1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B1_CTL, 0, 16, anc_mux_text);
-
-static const struct soc_enum anc2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B1_CTL, 4, 16, anc_mux_text);
-
-static const struct soc_enum anc1_fb_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B2_CTL, 0, 3, anc1_fb_mux_text);
-
-static const struct soc_enum iir1_inp1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_EQ1_B1_CTL, 0, 18, iir1_inp1_text);
-
-static const struct snd_kcontrol_new rx_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP1 Mux", rx_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP2 Mux", rx_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx_mix1_inp3_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP3 Mux", rx_mix1_inp3_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX2 MIX1 INP1 Mux", rx2_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX2 MIX1 INP2 Mux", rx2_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx3_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX3 MIX1 INP1 Mux", rx3_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx3_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX3 MIX1 INP2 Mux", rx3_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx4_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX4 MIX1 INP1 Mux", rx4_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx4_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX4 MIX1 INP2 Mux", rx4_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx5_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX5 MIX1 INP1 Mux", rx5_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx5_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX5 MIX1 INP2 Mux", rx5_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx6_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX6 MIX1 INP1 Mux", rx6_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx6_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX6 MIX1 INP2 Mux", rx6_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX7 MIX1 INP1 Mux", rx7_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX7 MIX1 INP2 Mux", rx7_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx1_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX1 MIX2 INP1 Mux", rx1_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx1_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX1 MIX2 INP2 Mux", rx1_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX2 MIX2 INP1 Mux", rx2_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX2 MIX2 INP2 Mux", rx2_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX7 MIX2 INP1 Mux", rx7_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX7 MIX2 INP2 Mux", rx7_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx4_dsm_mux =
-	SOC_DAPM_ENUM("RX4 DSM MUX Mux", rx4_dsm_enum);
-
-static const struct snd_kcontrol_new rx6_dsm_mux =
-	SOC_DAPM_ENUM("RX6 DSM MUX Mux", rx6_dsm_enum);
-
-static const struct snd_kcontrol_new sb_tx1_mux =
-	SOC_DAPM_ENUM("SLIM TX1 MUX Mux", sb_tx1_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx2_mux =
-	SOC_DAPM_ENUM("SLIM TX2 MUX Mux", sb_tx2_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx3_mux =
-	SOC_DAPM_ENUM("SLIM TX3 MUX Mux", sb_tx3_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx4_mux =
-	SOC_DAPM_ENUM("SLIM TX4 MUX Mux", sb_tx4_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx5_mux =
-	SOC_DAPM_ENUM("SLIM TX5 MUX Mux", sb_tx5_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx6_mux =
-	SOC_DAPM_ENUM("SLIM TX6 MUX Mux", sb_tx6_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx7_mux =
-	SOC_DAPM_ENUM("SLIM TX7 MUX Mux", sb_tx7_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx8_mux =
-	SOC_DAPM_ENUM("SLIM TX8 MUX Mux", sb_tx8_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx9_mux =
-	SOC_DAPM_ENUM("SLIM TX9 MUX Mux", sb_tx9_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx10_mux =
-	SOC_DAPM_ENUM("SLIM TX10 MUX Mux", sb_tx10_mux_enum);
-
-
-static int wcd9320_put_dec_enum(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *w = wlist->widgets[0];
-	struct snd_soc_codec *codec = w->codec;
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int dec_mux, decimator;
-	char *dec_name = NULL;
-	char *widget_name = NULL;
-	char *temp;
-	u16 tx_mux_ctl_reg;
-	u8 adc_dmic_sel = 0x0;
-	int ret = 0;
-
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
-		return -EINVAL;
-
-	dec_mux = ucontrol->value.enumerated.item[0];
-
-	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
-	if (!widget_name)
-		return -ENOMEM;
-	temp = widget_name;
-
-	dec_name = strsep(&widget_name, " ");
-	widget_name = temp;
-	if (!dec_name) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, w->name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
-	if (ret < 0) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	dev_dbg(w->dapm->dev, "%s(): widget = %s decimator = %u dec_mux = %u\n"
-		, __func__, w->name, decimator, dec_mux);
-
-
-	switch (decimator) {
-	case 1:
-	case 2:
-	case 3:
-	case 4:
-	case 5:
-	case 6:
-		if (dec_mux == 1)
-			adc_dmic_sel = 0x1;
-		else
-			adc_dmic_sel = 0x0;
-		break;
-	case 7:
-	case 8:
-	case 9:
-	case 10:
-		if ((dec_mux == 1) || (dec_mux == 2))
-			adc_dmic_sel = 0x1;
-		else
-			adc_dmic_sel = 0x0;
-		break;
-	default:
-		pr_err("%s: Invalid Decimator = %u\n", __func__, decimator);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL + 8 * (decimator - 1);
-
-	snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x1, adc_dmic_sel);
-
-	ret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
-
-out:
-	kfree(widget_name);
-	return ret;
-}
-
-#define WCD9320_DEC_ENUM(xname, xenum) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.info = snd_soc_info_enum_double, \
-	.get = snd_soc_dapm_get_enum_double, \
-	.put = wcd9320_put_dec_enum, \
-	.private_value = (unsigned long)&xenum }
-
-static const struct snd_kcontrol_new dec1_mux =
-	WCD9320_DEC_ENUM("DEC1 MUX Mux", dec1_mux_enum);
-
-static const struct snd_kcontrol_new dec2_mux =
-	WCD9320_DEC_ENUM("DEC2 MUX Mux", dec2_mux_enum);
-
-static const struct snd_kcontrol_new dec3_mux =
-	WCD9320_DEC_ENUM("DEC3 MUX Mux", dec3_mux_enum);
-
-static const struct snd_kcontrol_new dec4_mux =
-	WCD9320_DEC_ENUM("DEC4 MUX Mux", dec4_mux_enum);
-
-static const struct snd_kcontrol_new dec5_mux =
-	WCD9320_DEC_ENUM("DEC5 MUX Mux", dec5_mux_enum);
-
-static const struct snd_kcontrol_new dec6_mux =
-	WCD9320_DEC_ENUM("DEC6 MUX Mux", dec6_mux_enum);
-
-static const struct snd_kcontrol_new dec7_mux =
-	WCD9320_DEC_ENUM("DEC7 MUX Mux", dec7_mux_enum);
-
-static const struct snd_kcontrol_new dec8_mux =
-	WCD9320_DEC_ENUM("DEC8 MUX Mux", dec8_mux_enum);
-
-static const struct snd_kcontrol_new dec9_mux =
-	WCD9320_DEC_ENUM("DEC9 MUX Mux", dec9_mux_enum);
-
-static const struct snd_kcontrol_new dec10_mux =
-	WCD9320_DEC_ENUM("DEC10 MUX Mux", dec10_mux_enum);
-
-static const struct snd_kcontrol_new iir1_inp1_mux =
-	SOC_DAPM_ENUM("IIR1 INP1 Mux", iir1_inp1_mux_enum);
-
-static const struct snd_kcontrol_new anc1_mux =
-	SOC_DAPM_ENUM("ANC1 MUX Mux", anc1_mux_enum);
-
-static const struct snd_kcontrol_new anc2_mux =
-	SOC_DAPM_ENUM("ANC2 MUX Mux", anc2_mux_enum);
-
-static const struct snd_kcontrol_new anc1_fb_mux =
-	SOC_DAPM_ENUM("ANC1 FB MUX Mux", anc1_fb_mux_enum);
-
-static const struct snd_kcontrol_new dac1_switch[] = {
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_EAR_EN, 5, 1, 0)
-};
-static const struct snd_kcontrol_new hphl_switch[] = {
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_HPH_L_DAC_CTL, 6, 1, 0)
-};
-
-static const struct snd_kcontrol_new hphl_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					7, 1, 0),
-};
-
-static const struct snd_kcontrol_new hphr_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					6, 1, 0),
-};
-
-static const struct snd_kcontrol_new ear_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					5, 1, 0),
-};
-static const struct snd_kcontrol_new lineout1_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					4, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout2_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					3, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout3_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					2, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout4_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					1, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout3_ground_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_LINE_3_DAC_CTL, 6, 1, 0);
-
-static const struct snd_kcontrol_new lineout4_ground_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_LINE_4_DAC_CTL, 6, 1, 0);
-
-static void taiko_codec_enable_adc_block(struct snd_soc_codec *codec,
-					 int enable)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %d\n", __func__, enable);
-
-	if (enable) {
-		taiko->adc_count++;
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_CTL, 0x2, 0x2);
-	} else {
-		taiko->adc_count--;
-		if (!taiko->adc_count)
-			snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_CTL,
-					    0x2, 0x0);
-	}
-}
-
-static int taiko_codec_enable_adc(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	u16 adc_reg;
-	u8 init_bit_shift;
-
-	pr_debug("%s %d\n", __func__, event);
-
-	if (w->reg == TAIKO_A_TX_1_2_EN)
-		adc_reg = TAIKO_A_TX_1_2_TEST_CTL;
-	else if (w->reg == TAIKO_A_TX_3_4_EN)
-		adc_reg = TAIKO_A_TX_3_4_TEST_CTL;
-	else if (w->reg == TAIKO_A_TX_5_6_EN)
-		adc_reg = TAIKO_A_TX_5_6_TEST_CTL;
-	else {
-		pr_err("%s: Error, invalid adc register\n", __func__);
-		return -EINVAL;
-	}
-
-	if (w->shift == 3)
-		init_bit_shift = 6;
-	else if  (w->shift == 7)
-		init_bit_shift = 7;
-	else {
-		pr_err("%s: Error, invalid init bit postion adc register\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		taiko_codec_enable_adc_block(codec, 1);
-		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift,
-				1 << init_bit_shift);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-
-		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift, 0x00);
-
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		taiko_codec_enable_adc_block(codec, 0);
-		break;
-	}
-	return 0;
-}
-
-static void taiko_codec_enable_audio_mode_bandgap(struct snd_soc_codec *codec)
-{
-	snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x80,
-		0x80);
-	snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x04,
-		0x04);
-	snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x01,
-		0x01);
-	usleep_range(1000, 1000);
-	snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x80,
-		0x00);
-}
-
-static void taiko_codec_enable_bandgap(struct snd_soc_codec *codec,
-	enum taiko_bandgap_type choice)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	/* TODO lock resources accessed by audio streams and threaded
-	 * interrupt handlers
-	 */
-
-	pr_debug("%s, choice is %d, current is %d\n", __func__, choice,
-		taiko->bandgap_type);
-
-	if (taiko->bandgap_type == choice)
-		return;
-
-	if ((taiko->bandgap_type == TAIKO_BANDGAP_OFF) &&
-		(choice == TAIKO_BANDGAP_AUDIO_MODE)) {
-		taiko_codec_enable_audio_mode_bandgap(codec);
-	} else if (choice == TAIKO_BANDGAP_MBHC_MODE) {
-		/* bandgap mode becomes fast,
-		 * mclk should be off or clk buff source souldn't be VBG
-		 * Let's turn off mclk always */
-		WARN_ON(snd_soc_read(codec, TAIKO_A_CLK_BUFF_EN2) & (1 << 2));
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x2,
-			0x2);
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x80,
-			0x80);
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x4,
-			0x4);
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x01,
-			0x01);
-		usleep_range(1000, 1000);
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x80,
-			0x00);
-	} else if ((taiko->bandgap_type == TAIKO_BANDGAP_MBHC_MODE) &&
-		(choice == TAIKO_BANDGAP_AUDIO_MODE)) {
-		snd_soc_write(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x00);
-		usleep_range(100, 100);
-		taiko_codec_enable_audio_mode_bandgap(codec);
-	} else if (choice == TAIKO_BANDGAP_OFF) {
-		snd_soc_write(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x00);
-	} else {
-		pr_err("%s: Error, Invalid bandgap settings\n", __func__);
-	}
-	taiko->bandgap_type = choice;
-}
-
-static void taiko_codec_disable_clock_block(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	pr_debug("%s\n", __func__);
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN2, 0x04, 0x00);
-	usleep_range(50, 50);
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN2, 0x02, 0x02);
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x05, 0x00);
-	usleep_range(50, 50);
-	taiko->clock_active = false;
-}
-
-static int taiko_codec_mclk_index(const struct taiko_priv *taiko)
-{
-	if (taiko->mbhc_cfg.mclk_rate == TAIKO_MCLK_RATE_12288KHZ)
-		return 0;
-	else if (taiko->mbhc_cfg.mclk_rate == TAIKO_MCLK_RATE_9600KHZ)
-		return 1;
-	else {
-		BUG_ON(1);
-		return -EINVAL;
-	}
-}
-
-static void taiko_enable_rx_bias(struct snd_soc_codec *codec, u32  enable)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	if (enable) {
-		taiko->rx_bias_count++;
-		if (taiko->rx_bias_count == 1)
-			snd_soc_update_bits(codec, TAIKO_A_RX_COM_BIAS,
-				0x80, 0x80);
-	} else {
-		taiko->rx_bias_count--;
-		if (!taiko->rx_bias_count)
-			snd_soc_update_bits(codec, TAIKO_A_RX_COM_BIAS,
-				0x80, 0x00);
-	}
-}
-
-static int taiko_codec_enable_config_mode(struct snd_soc_codec *codec,
-	int enable)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: enable = %d\n", __func__, enable);
-	if (enable) {
-
-		snd_soc_update_bits(codec, TAIKO_A_RC_OSC_FREQ, 0x10, 0);
-		/* bandgap mode to fast */
-		snd_soc_write(codec, TAIKO_A_BIAS_OSC_BG_CTL, 0x17);
-		usleep_range(5, 5);
-		snd_soc_update_bits(codec, TAIKO_A_RC_OSC_FREQ, 0x80,
-				    0x80);
-		snd_soc_update_bits(codec, TAIKO_A_RC_OSC_TEST, 0x80,
-				    0x80);
-		usleep_range(10, 10);
-		snd_soc_update_bits(codec, TAIKO_A_RC_OSC_TEST, 0x80, 0);
-		usleep_range(10000, 10000);
-		snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x08, 0x08);
-
-	} else {
-		snd_soc_update_bits(codec, TAIKO_A_BIAS_OSC_BG_CTL, 0x1,
-				    0);
-		snd_soc_update_bits(codec, TAIKO_A_RC_OSC_FREQ, 0x80, 0);
-		/* clk source to ext clk and clk buff ref to VBG */
-		snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x0C, 0x04);
-	}
-	taiko->config_mode_active = enable ? true : false;
-
-	return 0;
-}
-
-static int taiko_codec_enable_clock_block(struct snd_soc_codec *codec,
-					  int config_mode)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: config_mode = %d\n", __func__, config_mode);
-
-	/* transit to RCO requires mclk off */
-	WARN_ON(snd_soc_read(codec, TAIKO_A_CLK_BUFF_EN2) & (1 << 2));
-	if (config_mode) {
-		/* enable RCO and switch to it */
-		taiko_codec_enable_config_mode(codec, 1);
-		snd_soc_write(codec, TAIKO_A_CLK_BUFF_EN2, 0x02);
-		usleep_range(1000, 1000);
-	} else {
-		/* switch to MCLK */
-		snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x08, 0x00);
-
-		if (taiko->mbhc_polling_active) {
-			snd_soc_write(codec, TAIKO_A_CLK_BUFF_EN2, 0x02);
-			taiko_codec_enable_config_mode(codec, 0);
-		}
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x01, 0x01);
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN2, 0x02, 0x00);
-	/* on MCLK */
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN2, 0x04, 0x04);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_MCLK_CTL, 0x01, 0x01);
-	usleep_range(50, 50);
-	taiko->clock_active = true;
-	return 0;
-}
-
-static int taiko_codec_enable_aux_pga(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: %d\n", __func__, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		taiko_codec_enable_bandgap(codec, TAIKO_BANDGAP_AUDIO_MODE);
-		taiko_enable_rx_bias(codec, 1);
-
-		if (taiko->aux_pga_cnt++ == 1
-			&& !taiko->mclk_enabled) {
-			taiko_codec_enable_clock_block(codec, 1);
-			pr_debug("AUX PGA enabled RC osc\n");
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		taiko_enable_rx_bias(codec, 0);
-
-		if (taiko->aux_pga_cnt-- == 0) {
-			if (taiko->mbhc_polling_active)
-				taiko_codec_enable_bandgap(codec,
-					TAIKO_BANDGAP_MBHC_MODE);
-			else
-				taiko_codec_enable_bandgap(codec,
-					TAIKO_BANDGAP_OFF);
-
-			if (!taiko->mclk_enabled &&
-				!taiko->mbhc_polling_active) {
-				taiko_codec_enable_clock_block(codec, 0);
-			}
-		}
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_lineout(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	u16 lineout_gain_reg;
-
-	pr_debug("%s %d %s\n", __func__, event, w->name);
-
-	switch (w->shift) {
-	case 0:
-		lineout_gain_reg = TAIKO_A_RX_LINE_1_GAIN;
-		break;
-	case 1:
-		lineout_gain_reg = TAIKO_A_RX_LINE_2_GAIN;
-		break;
-	case 2:
-		lineout_gain_reg = TAIKO_A_RX_LINE_3_GAIN;
-		break;
-	case 3:
-		lineout_gain_reg = TAIKO_A_RX_LINE_4_GAIN;
-		break;
-	default:
-		pr_err("%s: Error, incorrect lineout register value\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, lineout_gain_reg, 0x40, 0x40);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		pr_debug("%s: sleeping 16 ms after %s PA turn on\n",
-				__func__, w->name);
-		usleep_range(16000, 16000);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, lineout_gain_reg, 0x40, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_spk_pa(struct snd_soc_dapm_widget *w,
-				     struct snd_kcontrol *kcontrol, int event)
-{
-	pr_debug("%s %d %s\n", __func__, event, w->name);
-	return 0;
-}
-
-static int taiko_codec_enable_dmic(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u8  dmic_clk_en;
-	u16 dmic_clk_reg;
-	s32 *dmic_clk_cnt;
-	unsigned int dmic;
-	int ret;
-
-	ret = kstrtouint(strpbrk(w->name, "123456"), 10, &dmic);
-	if (ret < 0) {
-		pr_err("%s: Invalid DMIC line on the codec\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (dmic) {
-	case 1:
-	case 2:
-		dmic_clk_en = 0x01;
-		dmic_clk_cnt = &(taiko->dmic_1_2_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B1_CTL;
-		pr_debug("%s() event %d DMIC%d dmic_1_2_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-
-		break;
-
-	case 3:
-	case 4:
-		dmic_clk_en = 0x10;
-		dmic_clk_cnt = &(taiko->dmic_3_4_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B1_CTL;
-
-		pr_debug("%s() event %d DMIC%d dmic_3_4_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-		break;
-
-	case 5:
-	case 6:
-		dmic_clk_en = 0x01;
-		dmic_clk_cnt = &(taiko->dmic_5_6_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B2_CTL;
-
-		pr_debug("%s() event %d DMIC%d dmic_5_6_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-
-		break;
-
-	default:
-		pr_err("%s: Invalid DMIC Selection\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-
-		(*dmic_clk_cnt)++;
-		if (*dmic_clk_cnt == 1)
-			snd_soc_update_bits(codec, dmic_clk_reg,
-					dmic_clk_en, dmic_clk_en);
-
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-
-		(*dmic_clk_cnt)--;
-		if (*dmic_clk_cnt  == 0)
-			snd_soc_update_bits(codec, dmic_clk_reg,
-					dmic_clk_en, 0);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_anc(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	const char *filename;
-	const struct firmware *fw;
-	int i;
-	int ret;
-	int num_anc_slots;
-	struct anc_header *anc_head;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u32 anc_writes_size = 0;
-	int anc_size_remaining;
-	u32 *anc_ptr;
-	u16 reg;
-	u8 mask, val, old_val;
-
-	pr_debug("%s %d\n", __func__, event);
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-
-		filename = "wcd9320/wcd9320_anc.bin";
-
-		ret = request_firmware(&fw, filename, codec->dev);
-		if (ret != 0) {
-			dev_err(codec->dev, "Failed to acquire ANC data: %d\n",
-				ret);
-			return -ENODEV;
-		}
-
-		if (fw->size < sizeof(struct anc_header)) {
-			dev_err(codec->dev, "Not enough data\n");
-			release_firmware(fw);
-			return -ENOMEM;
-		}
-
-		/* First number is the number of register writes */
-		anc_head = (struct anc_header *)(fw->data);
-		anc_ptr = (u32 *)((u32)fw->data + sizeof(struct anc_header));
-		anc_size_remaining = fw->size - sizeof(struct anc_header);
-		num_anc_slots = anc_head->num_anc_slots;
-
-		if (taiko->anc_slot >= num_anc_slots) {
-			dev_err(codec->dev, "Invalid ANC slot selected\n");
-			release_firmware(fw);
-			return -EINVAL;
-		}
-
-		for (i = 0; i < num_anc_slots; i++) {
-
-			if (anc_size_remaining < TAIKO_PACKED_REG_SIZE) {
-				dev_err(codec->dev, "Invalid register format\n");
-				release_firmware(fw);
-				return -EINVAL;
-			}
-			anc_writes_size = (u32)(*anc_ptr);
-			anc_size_remaining -= sizeof(u32);
-			anc_ptr += 1;
-
-			if (anc_writes_size * TAIKO_PACKED_REG_SIZE
-				> anc_size_remaining) {
-				dev_err(codec->dev, "Invalid register format\n");
-				release_firmware(fw);
-				return -ENOMEM;
-			}
-
-			if (taiko->anc_slot == i)
-				break;
-
-			anc_size_remaining -= (anc_writes_size *
-				TAIKO_PACKED_REG_SIZE);
-			anc_ptr += anc_writes_size;
-		}
-		if (i == num_anc_slots) {
-			dev_err(codec->dev, "Selected ANC slot not present\n");
-			release_firmware(fw);
-			return -ENOMEM;
-		}
-
-		for (i = 0; i < anc_writes_size; i++) {
-			TAIKO_CODEC_UNPACK_ENTRY(anc_ptr[i], reg,
-				mask, val);
-			old_val = snd_soc_read(codec, reg);
-			snd_soc_write(codec, reg, (old_val & ~mask) |
-				(val & mask));
-		}
-		release_firmware(fw);
-
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_write(codec, TAIKO_A_CDC_CLK_ANC_RESET_CTL, 0xFF);
-		snd_soc_write(codec, TAIKO_A_CDC_CLK_ANC_CLK_EN_CTL, 0);
-		break;
-	}
-	return 0;
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_start_hs_polling(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	int mbhc_state = taiko->mbhc_state;
-
-	pr_debug("%s: enter\n", __func__);
-	if (!taiko->mbhc_polling_active) {
-		pr_debug("Polling is not active, do not start polling\n");
-		return;
-	}
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x84);
-
-	if (!taiko->no_mic_headset_override) {
-		if (mbhc_state == MBHC_STATE_POTENTIAL) {
-			pr_debug("%s recovering MBHC state macine\n", __func__);
-			taiko->mbhc_state = MBHC_STATE_POTENTIAL_RECOVERY;
-			/* set to max button press threshold */
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B2_CTL,
-				      0x7F);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B1_CTL,
-				      0xFF);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B4_CTL,
-				       0x7F);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B3_CTL,
-				      0xFF);
-			/* set to max */
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B6_CTL,
-				      0x7F);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B5_CTL,
-				      0xFF);
-		}
-	}
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x1);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x0);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x1);
-	pr_debug("%s: leave\n", __func__);
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_pause_hs_polling(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: enter\n", __func__);
-	if (!taiko->mbhc_polling_active) {
-		pr_debug("polling not active, nothing to pause\n");
-		return;
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-	pr_debug("%s: leave\n", __func__);
-}
-
-static void taiko_codec_switch_cfilt_mode(struct snd_soc_codec *codec, int mode)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u8 reg_mode_val, cur_mode_val;
-	bool mbhc_was_polling = false;
-
-	if (mode)
-		reg_mode_val = TAIKO_CFILT_FAST_MODE;
-	else
-		reg_mode_val = TAIKO_CFILT_SLOW_MODE;
-
-	cur_mode_val = snd_soc_read(codec,
-					taiko->mbhc_bias_regs.cfilt_ctl) & 0x40;
-
-	if (cur_mode_val != reg_mode_val) {
-		TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-		if (taiko->mbhc_polling_active) {
-			taiko_codec_pause_hs_polling(codec);
-			mbhc_was_polling = true;
-		}
-		snd_soc_update_bits(codec,
-			taiko->mbhc_bias_regs.cfilt_ctl, 0x40, reg_mode_val);
-		if (mbhc_was_polling)
-			taiko_codec_start_hs_polling(codec);
-		TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-		pr_debug("%s: CFILT mode change (%x to %x)\n", __func__,
-			cur_mode_val, reg_mode_val);
-	} else {
-		pr_debug("%s: CFILT Value is already %x\n",
-			__func__, cur_mode_val);
-	}
-}
-
-static void taiko_codec_update_cfilt_usage(struct snd_soc_codec *codec,
-					   u8 cfilt_sel, int inc)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u32 *cfilt_cnt_ptr = NULL;
-	u16 micb_cfilt_reg;
-
-	switch (cfilt_sel) {
-	case TAIKO_CFILT1_SEL:
-		cfilt_cnt_ptr = &taiko->cfilt1_cnt;
-		micb_cfilt_reg = TAIKO_A_MICB_CFILT_1_CTL;
-		break;
-	case TAIKO_CFILT2_SEL:
-		cfilt_cnt_ptr = &taiko->cfilt2_cnt;
-		micb_cfilt_reg = TAIKO_A_MICB_CFILT_2_CTL;
-		break;
-	case TAIKO_CFILT3_SEL:
-		cfilt_cnt_ptr = &taiko->cfilt3_cnt;
-		micb_cfilt_reg = TAIKO_A_MICB_CFILT_3_CTL;
-		break;
-	default:
-		return; /* should not happen */
-	}
-
-	if (inc) {
-		if (!(*cfilt_cnt_ptr)++) {
-			/* Switch CFILT to slow mode if MBHC CFILT being used */
-			if (cfilt_sel == taiko->mbhc_bias_regs.cfilt_sel)
-				taiko_codec_switch_cfilt_mode(codec, 0);
-
-			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0x80);
-		}
-	} else {
-		/* check if count not zero, decrement
-		 * then check if zero, go ahead disable cfilter
-		 */
-		if ((*cfilt_cnt_ptr) && !--(*cfilt_cnt_ptr)) {
-			snd_soc_update_bits(codec, micb_cfilt_reg, 0x80, 0);
-
-			/* Switch CFILT to fast mode if MBHC CFILT being used */
-			if (cfilt_sel == taiko->mbhc_bias_regs.cfilt_sel)
-				taiko_codec_switch_cfilt_mode(codec, 1);
-		}
-	}
-}
-
-static int taiko_find_k_value(unsigned int ldoh_v, unsigned int cfilt_mv)
-{
-	int rc = -EINVAL;
-	unsigned min_mv, max_mv;
-
-	switch (ldoh_v) {
-	case TAIKO_LDOH_1P95_V:
-		min_mv = 160;
-		max_mv = 1800;
-		break;
-	case TAIKO_LDOH_2P35_V:
-		min_mv = 200;
-		max_mv = 2200;
-		break;
-	case TAIKO_LDOH_2P75_V:
-		min_mv = 240;
-		max_mv = 2600;
-		break;
-	case TAIKO_LDOH_2P85_V:
-		min_mv = 250;
-		max_mv = 2700;
-		break;
-	default:
-		goto done;
-	}
-
-	if (cfilt_mv < min_mv || cfilt_mv > max_mv)
-		goto done;
-
-	for (rc = 4; rc <= 44; rc++) {
-		min_mv = max_mv * (rc) / 44;
-		if (min_mv >= cfilt_mv) {
-			rc -= 4;
-			break;
-		}
-	}
-done:
-	return rc;
-}
-
-static bool taiko_is_hph_pa_on(struct snd_soc_codec *codec)
-{
-	u8 hph_reg_val = 0;
-	hph_reg_val = snd_soc_read(codec, TAIKO_A_RX_HPH_CNP_EN);
-
-	return (hph_reg_val & 0x30) ? true : false;
-}
-
-static bool taiko_is_hph_dac_on(struct snd_soc_codec *codec, int left)
-{
-	u8 hph_reg_val = 0;
-	if (left)
-		hph_reg_val = snd_soc_read(codec,
-					   TAIKO_A_RX_HPH_L_DAC_CTL);
-	else
-		hph_reg_val = snd_soc_read(codec,
-					   TAIKO_A_RX_HPH_R_DAC_CTL);
-
-	return (hph_reg_val & 0xC0) ? true : false;
-}
-
-static void taiko_turn_onoff_override(struct snd_soc_codec *codec, bool on)
-{
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x04, on << 2);
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_drive_v_to_micbias(struct snd_soc_codec *codec,
-					   int usec)
-{
-	int cfilt_k_val;
-	bool set = true;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	if (taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV &&
-	    taiko->mbhc_micbias_switched) {
-		pr_debug("%s: set mic V to micbias V\n", __func__);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x2, 0x2);
-		taiko_turn_onoff_override(codec, true);
-		while (1) {
-			cfilt_k_val = taiko_find_k_value(
-						taiko->pdata->micbias.ldoh_v,
-						set ? taiko->mbhc_data.micb_mv :
-						      VDDIO_MICBIAS_MV);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.cfilt_val,
-					    0xFC, (cfilt_k_val << 2));
-			if (!set)
-				break;
-			usleep_range(usec, usec);
-			set = false;
-		}
-		taiko_turn_onoff_override(codec, false);
-	}
-}
-
-/* called under codec_resource_lock acquisition */
-static void __taiko_codec_switch_micbias(struct snd_soc_codec *codec,
-					 int vddio_switch, bool restartpolling,
-					 bool checkpolling)
-{
-	int cfilt_k_val;
-	bool override;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	if (vddio_switch && !taiko->mbhc_micbias_switched &&
-	    (!checkpolling || taiko->mbhc_polling_active)) {
-		if (restartpolling)
-			taiko_codec_pause_hs_polling(codec);
-		override = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B1_CTL) & 0x04;
-		if (!override)
-			taiko_turn_onoff_override(codec, true);
-		/* Adjust threshold if Mic Bias voltage changes */
-		if (taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) {
-			cfilt_k_val = taiko_find_k_value(
-						   taiko->pdata->micbias.ldoh_v,
-						   VDDIO_MICBIAS_MV);
-			usleep_range(10000, 10000);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.cfilt_val,
-					    0xFC, (cfilt_k_val << 2));
-			usleep_range(10000, 10000);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B1_CTL,
-				      taiko->mbhc_data.adj_v_ins_hu & 0xFF);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B2_CTL,
-				      (taiko->mbhc_data.adj_v_ins_hu >> 8) &
-				       0xFF);
-			pr_debug("%s: Programmed MBHC thresholds to VDDIO\n",
-				 __func__);
-		}
-
-		/* enable MIC BIAS Switch to VDDIO */
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-				    0x80, 0x80);
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-				    0x10, 0x00);
-		if (!override)
-			taiko_turn_onoff_override(codec, false);
-		if (restartpolling)
-			taiko_codec_start_hs_polling(codec);
-
-		taiko->mbhc_micbias_switched = true;
-		pr_debug("%s: VDDIO switch enabled\n", __func__);
-	} else if (!vddio_switch && taiko->mbhc_micbias_switched) {
-		if ((!checkpolling || taiko->mbhc_polling_active) &&
-		    restartpolling)
-			taiko_codec_pause_hs_polling(codec);
-		/* Reprogram thresholds */
-		if (taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) {
-			cfilt_k_val = taiko_find_k_value(
-						   taiko->pdata->micbias.ldoh_v,
-						   taiko->mbhc_data.micb_mv);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.cfilt_val,
-					    0xFC, (cfilt_k_val << 2));
-			usleep_range(10000, 10000);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B1_CTL,
-				      taiko->mbhc_data.v_ins_hu & 0xFF);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B2_CTL,
-				      (taiko->mbhc_data.v_ins_hu >> 8) & 0xFF);
-			pr_debug("%s: Programmed MBHC thresholds to MICBIAS\n",
-				 __func__);
-		}
-
-		/* Disable MIC BIAS Switch to VDDIO */
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-				    0x80, 0x00);
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-				    0x10, 0x00);
-
-		if ((!checkpolling || taiko->mbhc_polling_active) &&
-		    restartpolling)
-			taiko_codec_start_hs_polling(codec);
-
-		taiko->mbhc_micbias_switched = false;
-		pr_debug("%s: VDDIO switch disabled\n", __func__);
-	}
-}
-
-static void taiko_codec_switch_micbias(struct snd_soc_codec *codec,
-				       int vddio_switch)
-{
-	return __taiko_codec_switch_micbias(codec, vddio_switch, true, true);
-}
-
-static int taiko_codec_enable_micbias(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u16 micb_int_reg;
-	int micb_line;
-	u8 cfilt_sel_val = 0;
-	char *internal1_text = "Internal1";
-	char *internal2_text = "Internal2";
-	char *internal3_text = "Internal3";
-
-	pr_debug("%s %d\n", __func__, event);
-	switch (w->reg) {
-	case TAIKO_A_MICB_1_CTL:
-		micb_int_reg = TAIKO_A_MICB_1_INT_RBIAS;
-		cfilt_sel_val = taiko->pdata->micbias.bias1_cfilt_sel;
-		micb_line = TAIKO_MICBIAS1;
-		break;
-	case TAIKO_A_MICB_2_CTL:
-		micb_int_reg = TAIKO_A_MICB_2_INT_RBIAS;
-		cfilt_sel_val = taiko->pdata->micbias.bias2_cfilt_sel;
-		micb_line = TAIKO_MICBIAS2;
-		break;
-	case TAIKO_A_MICB_3_CTL:
-		micb_int_reg = TAIKO_A_MICB_3_INT_RBIAS;
-		cfilt_sel_val = taiko->pdata->micbias.bias3_cfilt_sel;
-		micb_line = TAIKO_MICBIAS3;
-		break;
-	case TAIKO_A_MICB_4_CTL:
-		micb_int_reg = taiko->reg_addr.micb_4_int_rbias;
-		cfilt_sel_val = taiko->pdata->micbias.bias4_cfilt_sel;
-		micb_line = TAIKO_MICBIAS4;
-		break;
-	default:
-		pr_err("%s: Error, invalid micbias register\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/* Decide whether to switch the micbias for MBHC */
-		if (w->reg == taiko->mbhc_bias_regs.ctl_reg) {
-			TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-			taiko_codec_switch_micbias(codec, 0);
-			TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-		}
-
-		snd_soc_update_bits(codec, w->reg, 0x0E, 0x0A);
-		taiko_codec_update_cfilt_usage(codec, cfilt_sel_val, 1);
-
-		if (strnstr(w->name, internal1_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0xE0, 0xE0);
-		else if (strnstr(w->name, internal2_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x1C, 0x1C);
-		else if (strnstr(w->name, internal3_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x3, 0x3);
-
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-
-		usleep_range(20000, 20000);
-
-		if (taiko->mbhc_polling_active &&
-		    taiko->mbhc_cfg.micbias == micb_line) {
-			TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-			taiko_codec_pause_hs_polling(codec);
-			taiko_codec_start_hs_polling(codec);
-			TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		if ((w->reg == taiko->mbhc_bias_regs.ctl_reg) &&
-		    taiko_is_hph_pa_on(codec)) {
-			TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-			taiko_codec_switch_micbias(codec, 1);
-			TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-		}
-
-		if (strnstr(w->name, internal1_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x80, 0x00);
-		else if (strnstr(w->name, internal2_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x10, 0x00);
-		else if (strnstr(w->name, internal3_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x2, 0x0);
-
-		taiko_codec_update_cfilt_usage(codec, cfilt_sel_val, 0);
-		break;
-	}
-
-	return 0;
-}
-
-
-static void tx_hpf_corner_freq_callback(struct work_struct *work)
-{
-	struct delayed_work *hpf_delayed_work;
-	struct hpf_work *hpf_work;
-	struct taiko_priv *taiko;
-	struct snd_soc_codec *codec;
-	u16 tx_mux_ctl_reg;
-	u8 hpf_cut_of_freq;
-
-	hpf_delayed_work = to_delayed_work(work);
-	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
-	taiko = hpf_work->taiko;
-	codec = hpf_work->taiko->codec;
-	hpf_cut_of_freq = hpf_work->tx_hpf_cut_of_freq;
-
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL +
-			(hpf_work->decimator - 1) * 8;
-
-	pr_debug("%s(): decimator %u hpf_cut_of_freq 0x%x\n", __func__,
-		hpf_work->decimator, (unsigned int)hpf_cut_of_freq);
-
-	snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30, hpf_cut_of_freq << 4);
-}
-
-#define  TX_MUX_CTL_CUT_OFF_FREQ_MASK	0x30
-#define  CF_MIN_3DB_4HZ			0x0
-#define  CF_MIN_3DB_75HZ		0x1
-#define  CF_MIN_3DB_150HZ		0x2
-
-static int taiko_codec_enable_dec(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	unsigned int decimator;
-	char *dec_name = NULL;
-	char *widget_name = NULL;
-	char *temp;
-	int ret = 0;
-	u16 dec_reset_reg, tx_vol_ctl_reg, tx_mux_ctl_reg;
-	u8 dec_hpf_cut_of_freq;
-	int offset;
-
-
-	pr_debug("%s %d\n", __func__, event);
-
-	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
-	if (!widget_name)
-		return -ENOMEM;
-	temp = widget_name;
-
-	dec_name = strsep(&widget_name, " ");
-	widget_name = temp;
-	if (!dec_name) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, w->name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
-	if (ret < 0) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	pr_debug("%s(): widget = %s dec_name = %s decimator = %u\n", __func__,
-			w->name, dec_name, decimator);
-
-	if (w->reg == TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL) {
-		dec_reset_reg = TAIKO_A_CDC_CLK_TX_RESET_B1_CTL;
-		offset = 0;
-	} else if (w->reg == TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL) {
-		dec_reset_reg = TAIKO_A_CDC_CLK_TX_RESET_B2_CTL;
-		offset = 8;
-	} else {
-		pr_err("%s: Error, incorrect dec\n", __func__);
-		return -EINVAL;
-	}
-
-	tx_vol_ctl_reg = TAIKO_A_CDC_TX1_VOL_CTL_CFG + 8 * (decimator - 1);
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL + 8 * (decimator - 1);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-
-		/* Enableable TX digital mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-
-		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift,
-			1 << w->shift);
-		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift, 0x0);
-
-		dec_hpf_cut_of_freq = snd_soc_read(codec, tx_mux_ctl_reg);
-
-		dec_hpf_cut_of_freq = (dec_hpf_cut_of_freq & 0x30) >> 4;
-
-		tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq =
-			dec_hpf_cut_of_freq;
-
-		if ((dec_hpf_cut_of_freq != CF_MIN_3DB_150HZ)) {
-
-			/* set cut of freq to CF_MIN_3DB_150HZ (0x1); */
-			snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30,
-					    CF_MIN_3DB_150HZ << 4);
-		}
-
-		/* enable HPF */
-		snd_soc_update_bits(codec, tx_mux_ctl_reg , 0x08, 0x00);
-
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-
-		/* Disable TX digital mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x00);
-
-		if (tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq !=
-				CF_MIN_3DB_150HZ) {
-
-			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
-					msecs_to_jiffies(300));
-		}
-		/* apply the digital gain after the decimator is enabled*/
-		if ((w->shift) < ARRAY_SIZE(rx_digital_gain_reg))
-			snd_soc_write(codec,
-				  tx_digital_gain_reg[w->shift + offset],
-				  snd_soc_read(codec,
-				  tx_digital_gain_reg[w->shift + offset])
-				  );
-
-		break;
-
-	case SND_SOC_DAPM_PRE_PMD:
-
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x08, 0x08);
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30,
-			(tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq) << 4);
-
-		break;
-	}
-out:
-	kfree(widget_name);
-	return ret;
-}
-
-static int taiko_codec_reset_interpolator(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %d %s\n", __func__, event, w->name);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_RESET_CTL,
-			1 << w->shift, 1 << w->shift);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_RESET_CTL,
-			1 << w->shift, 0x0);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		/* apply the digital gain after the interpolator is enabled*/
-		if ((w->shift) < ARRAY_SIZE(rx_digital_gain_reg))
-			snd_soc_write(codec,
-				  rx_digital_gain_reg[w->shift],
-				  snd_soc_read(codec,
-				  rx_digital_gain_reg[w->shift])
-				  );
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_ldo_h(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-	case SND_SOC_DAPM_POST_PMD:
-		usleep_range(1000, 1000);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_rx_bias(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %d\n", __func__, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		taiko_enable_rx_bias(codec, 1);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		taiko_enable_rx_bias(codec, 0);
-		break;
-	}
-	return 0;
-}
-static int taiko_hphr_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static void taiko_snd_soc_jack_report(struct taiko_priv *taiko,
-				      struct snd_soc_jack *jack, int status,
-				      int mask)
-{
-	/* XXX: wake_lock_timeout()? */
-	snd_soc_jack_report_no_dapm(jack, status, mask);
-}
-
-static void hphocp_off_report(struct taiko_priv *taiko,
-	u32 jack_status, int irq)
-{
-	struct snd_soc_codec *codec;
-	if (!taiko) {
-		pr_err("%s: Bad taiko private data\n", __func__);
-		return;
-	}
-
-	pr_debug("%s: clear ocp status %x\n", __func__, jack_status);
-	codec = taiko->codec;
-	if (taiko->hph_status & jack_status) {
-		taiko->hph_status &= ~jack_status;
-		if (taiko->mbhc_cfg.headset_jack)
-			taiko_snd_soc_jack_report(taiko,
-						  taiko->mbhc_cfg.headset_jack,
-						  taiko->hph_status,
-						  TAIKO_JACK_MASK);
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10, 0x10);
-		/* reset retry counter as PA is turned off signifying
-		 * start of new OCP detection session
-		 */
-		if (TAIKO_IRQ_HPH_PA_OCPL_FAULT)
-			taiko->hphlocp_cnt = 0;
-		else
-			taiko->hphrocp_cnt = 0;
-		wcd9xxx_enable_irq(codec->control_data, irq);
-	}
-}
-
-static void hphlocp_off_report(struct work_struct *work)
-{
-	struct taiko_priv *taiko = container_of(work, struct taiko_priv,
-		hphlocp_work);
-	hphocp_off_report(taiko, SND_JACK_OC_HPHL, TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-}
-
-static void hphrocp_off_report(struct work_struct *work)
-{
-	struct taiko_priv *taiko = container_of(work, struct taiko_priv,
-		hphrocp_work);
-	hphocp_off_report(taiko, SND_JACK_OC_HPHR, TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-}
-
-static int taiko_hph_pa_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u8 mbhc_micb_ctl_val;
-	pr_debug("%s: %s event = %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		mbhc_micb_ctl_val = snd_soc_read(codec,
-				taiko->mbhc_bias_regs.ctl_reg);
-
-		if (!(mbhc_micb_ctl_val & 0x80)) {
-			TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-			taiko_codec_switch_micbias(codec, 1);
-			TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-
-		usleep_range(10000, 10000);
-
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_5, 0x02, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_NCP_STATIC, 0x20, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x04, 0x04);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x08, 0x00);
-
-		usleep_range(10, 10);
-
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		/* schedule work is required because at the time HPH PA DAPM
-		 * event callback is called by DAPM framework, CODEC dapm mutex
-		 * would have been locked while snd_soc_jack_report also
-		 * attempts to acquire same lock.
-		 */
-		if (w->shift == 5) {
-			clear_bit(TAIKO_HPHL_PA_OFF_ACK,
-				  &taiko->hph_pa_dac_state);
-			clear_bit(TAIKO_HPHL_DAC_OFF_ACK,
-				  &taiko->hph_pa_dac_state);
-			if (taiko->hph_status & SND_JACK_OC_HPHL)
-				schedule_work(&taiko->hphlocp_work);
-		} else if (w->shift == 4) {
-			clear_bit(TAIKO_HPHR_PA_OFF_ACK,
-				  &taiko->hph_pa_dac_state);
-			clear_bit(TAIKO_HPHR_DAC_OFF_ACK,
-				  &taiko->hph_pa_dac_state);
-			if (taiko->hph_status & SND_JACK_OC_HPHR)
-				schedule_work(&taiko->hphrocp_work);
-		}
-
-		TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-		taiko_codec_switch_micbias(codec, 0);
-		TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-
-		pr_debug("%s: sleep 10 ms after %s PA disable.\n", __func__,
-				w->name);
-		usleep_range(10000, 10000);
-		break;
-	}
-	return 0;
-}
-
-static void taiko_get_mbhc_micbias_regs(struct snd_soc_codec *codec,
-					struct mbhc_micbias_regs *micbias_regs)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	unsigned int cfilt;
-
-	switch (taiko->mbhc_cfg.micbias) {
-	case TAIKO_MICBIAS1:
-		cfilt = taiko->pdata->micbias.bias1_cfilt_sel;
-		micbias_regs->mbhc_reg = TAIKO_A_MICB_1_MBHC;
-		micbias_regs->int_rbias = TAIKO_A_MICB_1_INT_RBIAS;
-		micbias_regs->ctl_reg = TAIKO_A_MICB_1_CTL;
-		break;
-	case TAIKO_MICBIAS2:
-		cfilt = taiko->pdata->micbias.bias2_cfilt_sel;
-		micbias_regs->mbhc_reg = TAIKO_A_MICB_2_MBHC;
-		micbias_regs->int_rbias = TAIKO_A_MICB_2_INT_RBIAS;
-		micbias_regs->ctl_reg = TAIKO_A_MICB_2_CTL;
-		break;
-	case TAIKO_MICBIAS3:
-		cfilt = taiko->pdata->micbias.bias3_cfilt_sel;
-		micbias_regs->mbhc_reg = TAIKO_A_MICB_3_MBHC;
-		micbias_regs->int_rbias = TAIKO_A_MICB_3_INT_RBIAS;
-		micbias_regs->ctl_reg = TAIKO_A_MICB_3_CTL;
-		break;
-	case TAIKO_MICBIAS4:
-		cfilt = taiko->pdata->micbias.bias4_cfilt_sel;
-		micbias_regs->mbhc_reg = taiko->reg_addr.micb_4_mbhc;
-		micbias_regs->int_rbias = taiko->reg_addr.micb_4_int_rbias;
-		micbias_regs->ctl_reg = taiko->reg_addr.micb_4_ctl;
-		break;
-	default:
-		/* Should never reach here */
-		pr_err("%s: Invalid MIC BIAS for MBHC\n", __func__);
-		return;
-	}
-
-	micbias_regs->cfilt_sel = cfilt;
-
-	switch (cfilt) {
-	case TAIKO_CFILT1_SEL:
-		micbias_regs->cfilt_val = TAIKO_A_MICB_CFILT_1_VAL;
-		micbias_regs->cfilt_ctl = TAIKO_A_MICB_CFILT_1_CTL;
-		taiko->mbhc_data.micb_mv = taiko->pdata->micbias.cfilt1_mv;
-		break;
-	case TAIKO_CFILT2_SEL:
-		micbias_regs->cfilt_val = TAIKO_A_MICB_CFILT_2_VAL;
-		micbias_regs->cfilt_ctl = TAIKO_A_MICB_CFILT_2_CTL;
-		taiko->mbhc_data.micb_mv = taiko->pdata->micbias.cfilt2_mv;
-		break;
-	case TAIKO_CFILT3_SEL:
-		micbias_regs->cfilt_val = TAIKO_A_MICB_CFILT_3_VAL;
-		micbias_regs->cfilt_ctl = TAIKO_A_MICB_CFILT_3_CTL;
-		taiko->mbhc_data.micb_mv = taiko->pdata->micbias.cfilt3_mv;
-		break;
-	}
-}
-static const struct snd_soc_dapm_widget taiko_dapm_i2s_widgets[] = {
-	SND_SOC_DAPM_SUPPLY("RX_I2S_CLK", TAIKO_A_CDC_CLK_RX_I2S_CTL,
-	4, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("TX_I2S_CLK", TAIKO_A_CDC_CLK_TX_I2S_CTL, 4,
-	0, NULL, 0),
-};
-
-static int taiko_lineout_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_spk_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-	return 0;
-}
-
-static const struct snd_soc_dapm_route audio_i2s_map[] = {
-	{"RX_I2S_CLK", NULL, "CDC_CONN"},
-	{"SLIM RX1", NULL, "RX_I2S_CLK"},
-	{"SLIM RX2", NULL, "RX_I2S_CLK"},
-	{"SLIM RX3", NULL, "RX_I2S_CLK"},
-	{"SLIM RX4", NULL, "RX_I2S_CLK"},
-
-	{"SLIM TX7", NULL, "TX_I2S_CLK"},
-	{"SLIM TX8", NULL, "TX_I2S_CLK"},
-	{"SLIM TX9", NULL, "TX_I2S_CLK"},
-	{"SLIM TX10", NULL, "TX_I2S_CLK"},
-};
-
-static const struct snd_soc_dapm_route audio_map[] = {
-	/* SLIMBUS Connections */
-
-	{"SLIM TX1", NULL, "SLIM TX1 MUX"},
-	{"SLIM TX1 MUX", "DEC1", "DEC1 MUX"},
-
-	{"SLIM TX2", NULL, "SLIM TX2 MUX"},
-	{"SLIM TX2 MUX", "DEC2", "DEC2 MUX"},
-
-	{"SLIM TX3", NULL, "SLIM TX3 MUX"},
-	{"SLIM TX3 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX3 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX3 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX3 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX3 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX3 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX3 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX3 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX4", NULL, "SLIM TX4 MUX"},
-	{"SLIM TX4 MUX", "DEC4", "DEC4 MUX"},
-
-	{"SLIM TX5", NULL, "SLIM TX5 MUX"},
-	{"SLIM TX5 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX5 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX5 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX5 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX5 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX5 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX5 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX5 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX6", NULL, "SLIM TX6 MUX"},
-	{"SLIM TX6 MUX", "DEC6", "DEC6 MUX"},
-
-	{"SLIM TX7", NULL, "SLIM TX7 MUX"},
-	{"SLIM TX7 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX7 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX7 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX7 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX7 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX7 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX7 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX7 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX7 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX7 MUX", "DEC10", "DEC10 MUX"},
-	{"SLIM TX7 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX7 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX7 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX7 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX7 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX7 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX7 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX8", NULL, "SLIM TX8 MUX"},
-	{"SLIM TX8 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX8 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX8 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX8 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX8 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX8 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX8 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX8 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX8 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX8 MUX", "DEC10", "DEC10 MUX"},
-
-	{"SLIM TX9", NULL, "SLIM TX9 MUX"},
-	{"SLIM TX9 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX9 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX9 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX9 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX9 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX9 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX9 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX9 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX9 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX9 MUX", "DEC10", "DEC10 MUX"},
-
-	{"SLIM TX10", NULL, "SLIM TX10 MUX"},
-	{"SLIM TX10 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX10 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX10 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX10 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX10 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX10 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX10 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX10 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX10 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX10 MUX", "DEC10", "DEC10 MUX"},
-
-	/* Earpiece (RX MIX1) */
-	{"EAR", NULL, "EAR PA"},
-	{"EAR PA", NULL, "EAR_PA_MIXER"},
-	{"EAR_PA_MIXER", NULL, "DAC1"},
-	{"DAC1", NULL, "CP"},
-	{"CP", NULL, "CLASS_H_EAR"},
-	{"CLASS_H_EAR", NULL, "CLASS_H_CLK"},
-
-	{"ANC1 FB MUX", "EAR_HPH_L", "RX1 MIX2"},
-	{"ANC1 FB MUX", "EAR_LINE_1", "RX2 MIX2"},
-	{"ANC", NULL, "ANC1 FB MUX"},
-
-	/* Headset (RX MIX1 and RX MIX2) */
-	{"HEADPHONE", NULL, "HPHL"},
-	{"HEADPHONE", NULL, "HPHR"},
-
-	{"HPHL", NULL, "HPHL_PA_MIXER"},
-	{"HPHL_PA_MIXER", NULL, "HPHL DAC"},
-
-	{"HPHR", NULL, "HPHR_PA_MIXER"},
-	{"HPHR_PA_MIXER", NULL, "HPHR DAC"},
-
-	{"HPHL DAC", NULL, "CP"},
-	{"CP", NULL, "CLASS_H_HPH_L"},
-	{"CLASS_H_HPH_L", NULL, "CLASS_H_CLK"},
-
-	{"HPHR DAC", NULL, "CP"},
-	{"CP", NULL, "CLASS_H_HPH_R"},
-	{"CLASS_H_HPH_R", NULL, "CLASS_H_CLK"},
-
-	{"ANC", NULL, "ANC1 MUX"},
-	{"ANC", NULL, "ANC2 MUX"},
-	{"ANC1 MUX", "ADC1", "ADC1"},
-	{"ANC1 MUX", "ADC2", "ADC2"},
-	{"ANC1 MUX", "ADC3", "ADC3"},
-	{"ANC1 MUX", "ADC4", "ADC4"},
-	{"ANC2 MUX", "ADC1", "ADC1"},
-	{"ANC2 MUX", "ADC2", "ADC2"},
-	{"ANC2 MUX", "ADC3", "ADC3"},
-	{"ANC2 MUX", "ADC4", "ADC4"},
-
-	{"ANC", NULL, "CDC_CONN"},
-
-	{"DAC1", "Switch", "RX1 CHAIN"},
-	{"HPHL DAC", "Switch", "RX1 CHAIN"},
-	{"HPHR DAC", NULL, "RX2 CHAIN"},
-
-	{"LINEOUT1", NULL, "LINEOUT1 PA"},
-	{"LINEOUT2", NULL, "LINEOUT2 PA"},
-	{"LINEOUT3", NULL, "LINEOUT3 PA"},
-	{"LINEOUT4", NULL, "LINEOUT4 PA"},
-	{"SPK_OUT", NULL, "SPK PA"},
-
-	{"LINEOUT1 PA", NULL, "LINEOUT1_PA_MIXER"},
-	{"LINEOUT1_PA_MIXER", NULL, "LINEOUT1 DAC"},
-	{"LINEOUT2 PA", NULL, "LINEOUT2_PA_MIXER"},
-	{"LINEOUT2_PA_MIXER", NULL, "LINEOUT2 DAC"},
-	{"LINEOUT3 PA", NULL, "LINEOUT3_PA_MIXER"},
-	{"LINEOUT3_PA_MIXER", NULL, "LINEOUT3 DAC"},
-	{"LINEOUT4 PA", NULL, "LINEOUT4_PA_MIXER"},
-	{"LINEOUT4_PA_MIXER", NULL, "LINEOUT4 DAC"},
-
-	{"LINEOUT1 DAC", NULL, "RX3 MIX1"},
-
-	{"RX4 DSM MUX", "DSM_INV", "RX3 MIX1"},
-	{"RX4 DSM MUX", "CIC_OUT", "RX4 MIX1"},
-	{"LINEOUT3 DAC", NULL, "RX4 DSM MUX"},
-
-	{"LINEOUT2 DAC", NULL, "RX5 MIX1"},
-
-	{"RX6 DSM MUX", "DSM_INV", "RX5 MIX1"},
-	{"RX6 DSM MUX", "CIC_OUT", "RX6 MIX1"},
-	{"LINEOUT4 DAC", NULL, "RX6 DSM MUX"},
-
-	{"SPK PA", NULL, "SPK DAC"},
-	{"SPK DAC", NULL, "RX7 MIX1"},
-
-	{"RX1 CHAIN", NULL, "RX1 MIX2"},
-	{"RX2 CHAIN", NULL, "RX2 MIX2"},
-	{"RX1 CHAIN", NULL, "ANC"},
-	{"RX2 CHAIN", NULL, "ANC"},
-
-	{"CLASS_H_CLK", NULL, "RX_BIAS"},
-	{"LINEOUT1 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT2 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT3 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT4 DAC", NULL, "RX_BIAS"},
-	{"SPK DAC", NULL, "RX_BIAS"},
-
-	{"RX1 MIX1", NULL, "COMP1_CLK"},
-	{"RX2 MIX1", NULL, "COMP1_CLK"},
-	{"RX3 MIX1", NULL, "COMP2_CLK"},
-	{"RX5 MIX1", NULL, "COMP2_CLK"},
-
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP1"},
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP2"},
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP3"},
-	{"RX2 MIX1", NULL, "RX2 MIX1 INP1"},
-	{"RX2 MIX1", NULL, "RX2 MIX1 INP2"},
-	{"RX3 MIX1", NULL, "RX3 MIX1 INP1"},
-	{"RX3 MIX1", NULL, "RX3 MIX1 INP2"},
-	{"RX4 MIX1", NULL, "RX4 MIX1 INP1"},
-	{"RX4 MIX1", NULL, "RX4 MIX1 INP2"},
-	{"RX5 MIX1", NULL, "RX5 MIX1 INP1"},
-	{"RX5 MIX1", NULL, "RX5 MIX1 INP2"},
-	{"RX6 MIX1", NULL, "RX6 MIX1 INP1"},
-	{"RX6 MIX1", NULL, "RX6 MIX1 INP2"},
-	{"RX7 MIX1", NULL, "RX7 MIX1 INP1"},
-	{"RX7 MIX1", NULL, "RX7 MIX1 INP2"},
-	{"RX1 MIX2", NULL, "RX1 MIX1"},
-	{"RX1 MIX2", NULL, "RX1 MIX2 INP1"},
-	{"RX1 MIX2", NULL, "RX1 MIX2 INP2"},
-	{"RX2 MIX2", NULL, "RX2 MIX1"},
-	{"RX2 MIX2", NULL, "RX2 MIX2 INP1"},
-	{"RX2 MIX2", NULL, "RX2 MIX2 INP2"},
-	{"RX7 MIX2", NULL, "RX7 MIX1"},
-	{"RX7 MIX2", NULL, "RX7 MIX2 INP1"},
-	{"RX7 MIX2", NULL, "RX7 MIX2 INP2"},
-
-	{"RX1 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX1 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX1 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX1 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX1 MIX1 INP3", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP3", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP3", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP3", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP3", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP3", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP3", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX2 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX2 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX2 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX2 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX2 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX2 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX2 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX2 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX2 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX2 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX2 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX2 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX2 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX3 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX3 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX3 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX3 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX3 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX3 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX3 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX3 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX3 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX3 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX3 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX3 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX3 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX3 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX3 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX3 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX4 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX4 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX4 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX4 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX4 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX4 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX4 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX4 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX4 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX4 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX4 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX4 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX4 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX4 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX4 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX4 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX5 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX5 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX5 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX5 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX5 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX5 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX5 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX5 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX5 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX5 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX5 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX5 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX5 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX5 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX5 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX5 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX6 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX6 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX6 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX6 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX6 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX6 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX6 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX6 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX6 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX6 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX6 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX6 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX6 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX6 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX6 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX6 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX7 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX7 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX7 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX7 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX7 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX7 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX7 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX7 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX7 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX7 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX7 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX7 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX7 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX7 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX7 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX7 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX1 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX1 MIX2 INP2", "IIR1", "IIR1"},
-	{"RX2 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX2 MIX2 INP2", "IIR1", "IIR1"},
-	{"RX7 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX7 MIX2 INP2", "IIR1", "IIR1"},
-
-	/* Decimator Inputs */
-	{"DEC1 MUX", "DMIC1", "DMIC1"},
-	{"DEC1 MUX", "ADC6", "ADC6"},
-	{"DEC1 MUX", NULL, "CDC_CONN"},
-	{"DEC2 MUX", "DMIC2", "DMIC2"},
-	{"DEC2 MUX", "ADC5", "ADC5"},
-	{"DEC2 MUX", NULL, "CDC_CONN"},
-	{"DEC3 MUX", "DMIC3", "DMIC3"},
-	{"DEC3 MUX", "ADC4", "ADC4"},
-	{"DEC3 MUX", NULL, "CDC_CONN"},
-	{"DEC4 MUX", "DMIC4", "DMIC4"},
-	{"DEC4 MUX", "ADC3", "ADC3"},
-	{"DEC4 MUX", NULL, "CDC_CONN"},
-	{"DEC5 MUX", "DMIC5", "DMIC5"},
-	{"DEC5 MUX", "ADC2", "ADC2"},
-	{"DEC5 MUX", NULL, "CDC_CONN"},
-	{"DEC6 MUX", "DMIC6", "DMIC6"},
-	{"DEC6 MUX", "ADC1", "ADC1"},
-	{"DEC6 MUX", NULL, "CDC_CONN"},
-	{"DEC7 MUX", "DMIC1", "DMIC1"},
-	{"DEC7 MUX", "DMIC6", "DMIC6"},
-	{"DEC7 MUX", "ADC1", "ADC1"},
-	{"DEC7 MUX", "ADC6", "ADC6"},
-	{"DEC7 MUX", NULL, "CDC_CONN"},
-	{"DEC8 MUX", "DMIC2", "DMIC2"},
-	{"DEC8 MUX", "DMIC5", "DMIC5"},
-	{"DEC8 MUX", "ADC2", "ADC2"},
-	{"DEC8 MUX", "ADC5", "ADC5"},
-	{"DEC8 MUX", NULL, "CDC_CONN"},
-	{"DEC9 MUX", "DMIC4", "DMIC4"},
-	{"DEC9 MUX", "DMIC5", "DMIC5"},
-	{"DEC9 MUX", "ADC2", "ADC2"},
-	{"DEC9 MUX", "ADC3", "ADC3"},
-	{"DEC9 MUX", NULL, "CDC_CONN"},
-	{"DEC10 MUX", "DMIC3", "DMIC3"},
-	{"DEC10 MUX", "DMIC6", "DMIC6"},
-	{"DEC10 MUX", "ADC1", "ADC1"},
-	{"DEC10 MUX", "ADC4", "ADC4"},
-	{"DEC10 MUX", NULL, "CDC_CONN"},
-
-	/* ADC Connections */
-	{"ADC1", NULL, "AMIC1"},
-	{"ADC2", NULL, "AMIC2"},
-	{"ADC3", NULL, "AMIC3"},
-	{"ADC4", NULL, "AMIC4"},
-	{"ADC5", NULL, "AMIC5"},
-	{"ADC6", NULL, "AMIC6"},
-
-	/* AUX PGA Connections */
-	{"EAR_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"HPHL_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"HPHR_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"LINEOUT1_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"LINEOUT2_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"LINEOUT3_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"LINEOUT4_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"AUX_PGA_Left", NULL, "AMIC5"},
-	{"AUX_PGA_Right", NULL, "AMIC6"},
-
-	{"IIR1", NULL, "IIR1 INP1 MUX"},
-	{"IIR1 INP1 MUX", "DEC1", "DEC1 MUX"},
-	{"IIR1 INP1 MUX", "DEC2", "DEC2 MUX"},
-	{"IIR1 INP1 MUX", "DEC3", "DEC3 MUX"},
-	{"IIR1 INP1 MUX", "DEC4", "DEC4 MUX"},
-	{"IIR1 INP1 MUX", "DEC5", "DEC5 MUX"},
-	{"IIR1 INP1 MUX", "DEC6", "DEC6 MUX"},
-	{"IIR1 INP1 MUX", "DEC7", "DEC7 MUX"},
-	{"IIR1 INP1 MUX", "DEC8", "DEC8 MUX"},
-	{"IIR1 INP1 MUX", "DEC9", "DEC9 MUX"},
-	{"IIR1 INP1 MUX", "DEC10", "DEC10 MUX"},
-
-	{"MIC BIAS1 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS1 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS1 External", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal3", NULL, "LDO_H"},
-	{"MIC BIAS2 External", NULL, "LDO_H"},
-	{"MIC BIAS3 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS3 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS3 External", NULL, "LDO_H"},
-	{"MIC BIAS4 External", NULL, "LDO_H"},
-};
-
-static int taiko_readable(struct snd_soc_codec *ssc, unsigned int reg)
-{
-	return taiko_reg_readable[reg];
-}
-
-static bool taiko_is_digital_gain_register(unsigned int reg)
-{
-	bool rtn = false;
-	switch (reg) {
-	case TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_TX1_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX2_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX3_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX4_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX5_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX6_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX7_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX8_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX9_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX10_VOL_CTL_GAIN:
-		rtn = true;
-		break;
-	default:
-		break;
-	}
-	return rtn;
-}
-
-static int taiko_volatile(struct snd_soc_codec *ssc, unsigned int reg)
-{
-	/* Registers lower than 0x100 are top level registers which can be
-	 * written by the Taiko core driver.
-	 */
-
-	if ((reg >= TAIKO_A_CDC_MBHC_EN_CTL) || (reg < 0x100))
-		return 1;
-
-	/* IIR Coeff registers are not cacheable */
-	if ((reg >= TAIKO_A_CDC_IIR1_COEF_B1_CTL) &&
-		(reg <= TAIKO_A_CDC_IIR2_COEF_B2_CTL))
-		return 1;
-
-	/* Digital gain register is not cacheable so we have to write
-	 * the setting even it is the same
-	 */
-	if (taiko_is_digital_gain_register(reg))
-		return 1;
-
-	/* HPH status registers */
-	if (reg == TAIKO_A_RX_HPH_L_STATUS || reg == TAIKO_A_RX_HPH_R_STATUS)
-		return 1;
-
-	return 0;
-}
-
-#define TAIKO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
-static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
-	unsigned int value)
-{
-	int ret;
-	BUG_ON(reg > TAIKO_MAX_REGISTER);
-
-	if (!taiko_volatile(codec, reg)) {
-		ret = snd_soc_cache_write(codec, reg, value);
-		if (ret != 0)
-			dev_err(codec->dev, "Cache write to %x failed: %d\n",
-				reg, ret);
-	}
-
-	return wcd9xxx_reg_write(codec->control_data, reg, value);
-}
-static unsigned int taiko_read(struct snd_soc_codec *codec,
-				unsigned int reg)
-{
-	unsigned int val;
-	int ret;
-
-	BUG_ON(reg > TAIKO_MAX_REGISTER);
-
-	if (!taiko_volatile(codec, reg) && taiko_readable(codec, reg) &&
-		reg < codec->driver->reg_cache_size) {
-		ret = snd_soc_cache_read(codec, reg, &val);
-		if (ret >= 0) {
-			return val;
-		} else
-			dev_err(codec->dev, "Cache read from %x failed: %d\n",
-				reg, ret);
-	}
-
-	val = wcd9xxx_reg_read(codec->control_data, reg);
-	return val;
-}
-
-static s16 taiko_get_current_v_ins(struct taiko_priv *taiko, bool hu)
-{
-	s16 v_ins;
-	if ((taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) &&
-	    taiko->mbhc_micbias_switched)
-		v_ins = hu ? (s16)taiko->mbhc_data.adj_v_ins_hu :
-			     (s16)taiko->mbhc_data.adj_v_ins_h;
-	else
-		v_ins = hu ? (s16)taiko->mbhc_data.v_ins_hu :
-			     (s16)taiko->mbhc_data.v_ins_h;
-	return v_ins;
-}
-
-static s16 taiko_get_current_v_hs_max(struct taiko_priv *taiko)
-{
-	s16 v_hs_max;
-	struct taiko_mbhc_plug_type_cfg *plug_type;
-
-	plug_type = TAIKO_MBHC_CAL_PLUG_TYPE_PTR(taiko->mbhc_cfg.calibration);
-	if ((taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) &&
-	    taiko->mbhc_micbias_switched)
-		v_hs_max = taiko->mbhc_data.adj_v_hs_max;
-	else
-		v_hs_max = plug_type->v_hs_max;
-	return v_hs_max;
-}
-
-static void taiko_codec_calibrate_hs_polling(struct snd_soc_codec *codec)
-{
-	u8 *n_ready, *n_cic;
-	struct taiko_mbhc_btn_detect_cfg *btn_det;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const s16 v_ins_hu = taiko_get_current_v_ins(taiko, true);
-
-	btn_det = TAIKO_MBHC_CAL_BTN_DET_PTR(taiko->mbhc_cfg.calibration);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B1_CTL,
-		      v_ins_hu & 0xFF);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B2_CTL,
-		      (v_ins_hu >> 8) & 0xFF);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B3_CTL,
-		      taiko->mbhc_data.v_b1_hu & 0xFF);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B4_CTL,
-		      (taiko->mbhc_data.v_b1_hu >> 8) & 0xFF);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B5_CTL,
-		      taiko->mbhc_data.v_b1_h & 0xFF);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B6_CTL,
-		      (taiko->mbhc_data.v_b1_h >> 8) & 0xFF);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B9_CTL,
-		      taiko->mbhc_data.v_brh & 0xFF);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B10_CTL,
-		      (taiko->mbhc_data.v_brh >> 8) & 0xFF);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B11_CTL,
-		      taiko->mbhc_data.v_brl & 0xFF);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_VOLT_B12_CTL,
-		      (taiko->mbhc_data.v_brl >> 8) & 0xFF);
-
-	n_ready = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_N_READY);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_TIMER_B1_CTL,
-		      n_ready[taiko_codec_mclk_index(taiko)]);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_TIMER_B2_CTL,
-		      taiko->mbhc_data.npoll);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_TIMER_B3_CTL,
-		      taiko->mbhc_data.nbounce_wait);
-	n_cic = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_N_CIC);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_TIMER_B6_CTL,
-		      n_cic[taiko_codec_mclk_index(taiko)]);
-}
-
-static int taiko_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	struct wcd9xxx *taiko_core = dev_get_drvdata(dai->codec->dev->parent);
-	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
-		 substream->name, substream->stream);
-	if ((taiko_core != NULL) &&
-	    (taiko_core->dev != NULL) &&
-	    (taiko_core->dev->parent != NULL))
-		pm_runtime_get_sync(taiko_core->dev->parent);
-
-	return 0;
-}
-
-static void taiko_shutdown(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	struct wcd9xxx *taiko_core = dev_get_drvdata(dai->codec->dev->parent);
-	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
-		 substream->name, substream->stream);
-	if ((taiko_core != NULL) &&
-	    (taiko_core->dev != NULL) &&
-	    (taiko_core->dev->parent != NULL)) {
-		pm_runtime_mark_last_busy(taiko_core->dev->parent);
-		pm_runtime_put(taiko_core->dev->parent);
-	}
-}
-
-int taiko_mclk_enable(struct snd_soc_codec *codec, int mclk_enable, bool dapm)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: mclk_enable = %u, dapm = %d\n", __func__, mclk_enable,
-		 dapm);
-	if (dapm)
-		TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-	if (mclk_enable) {
-		taiko->mclk_enabled = true;
-
-		if (taiko->mbhc_polling_active) {
-			taiko_codec_pause_hs_polling(codec);
-			taiko_codec_disable_clock_block(codec);
-			taiko_codec_enable_bandgap(codec,
-						   TAIKO_BANDGAP_AUDIO_MODE);
-			taiko_codec_enable_clock_block(codec, 0);
-			taiko_codec_calibrate_hs_polling(codec);
-			taiko_codec_start_hs_polling(codec);
-		} else {
-			taiko_codec_disable_clock_block(codec);
-			taiko_codec_enable_bandgap(codec,
-						   TAIKO_BANDGAP_AUDIO_MODE);
-			taiko_codec_enable_clock_block(codec, 0);
-		}
-	} else {
-
-		if (!taiko->mclk_enabled) {
-			if (dapm)
-				TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-			pr_err("Error, MCLK already diabled\n");
-			return -EINVAL;
-		}
-		taiko->mclk_enabled = false;
-
-		if (taiko->mbhc_polling_active) {
-			taiko_codec_pause_hs_polling(codec);
-			taiko_codec_disable_clock_block(codec);
-			taiko_codec_enable_bandgap(codec,
-						   TAIKO_BANDGAP_MBHC_MODE);
-			taiko_enable_rx_bias(codec, 1);
-			taiko_codec_enable_clock_block(codec, 1);
-			taiko_codec_calibrate_hs_polling(codec);
-			taiko_codec_start_hs_polling(codec);
-			snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1,
-					0x05, 0x01);
-		} else {
-			taiko_codec_disable_clock_block(codec);
-			taiko_codec_enable_bandgap(codec,
-						   TAIKO_BANDGAP_OFF);
-		}
-	}
-	if (dapm)
-		TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-	return 0;
-}
-
-static int taiko_set_dai_sysclk(struct snd_soc_dai *dai,
-		int clk_id, unsigned int freq, int dir)
-{
-	pr_debug("%s\n", __func__);
-	return 0;
-}
-
-static int taiko_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	u8 val = 0;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-
-	pr_debug("%s\n", __func__);
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBS_CFS:
-		/* CPU is master */
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			if (dai->id == AIF1_CAP)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					TAIKO_I2S_MASTER_MODE_MASK, 0);
-			else if (dai->id == AIF1_PB)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					TAIKO_I2S_MASTER_MODE_MASK, 0);
-		}
-		break;
-	case SND_SOC_DAIFMT_CBM_CFM:
-	/* CPU is slave */
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			val = TAIKO_I2S_MASTER_MODE_MASK;
-			if (dai->id == AIF1_CAP)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL, val, val);
-			else if (dai->id == AIF1_PB)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL, val, val);
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int taiko_set_channel_map(struct snd_soc_dai *dai,
-				unsigned int tx_num, unsigned int *tx_slot,
-				unsigned int rx_num, unsigned int *rx_slot)
-
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-	u32 i = 0;
-	if (!tx_slot && !rx_slot) {
-		pr_err("%s: Invalid\n", __func__);
-		return -EINVAL;
-	}
-	pr_debug("%s(): dai_name = %s DAI-ID %x tx_ch %d rx_ch %d\n",
-			__func__, dai->name, dai->id, tx_num, rx_num);
-
-	if (dai->id == AIF1_PB || dai->id == AIF2_PB || dai->id == AIF3_PB) {
-		for (i = 0; i < rx_num; i++) {
-			taiko->dai[dai->id - 1].ch_num[i]  = rx_slot[i];
-			taiko->dai[dai->id - 1].ch_act = 0;
-			taiko->dai[dai->id - 1].ch_tot = rx_num;
-		}
-	} else if (dai->id == AIF1_CAP || dai->id == AIF2_CAP ||
-		   dai->id == AIF3_CAP) {
-		for (i = 0; i < tx_num; i++) {
-			taiko->dai[dai->id - 1].ch_num[i]  = tx_slot[i];
-			taiko->dai[dai->id - 1].ch_act = 0;
-			taiko->dai[dai->id - 1].ch_tot = tx_num;
-		}
-	}
-	return 0;
-}
-
-static int taiko_get_channel_map(struct snd_soc_dai *dai,
-				unsigned int *tx_num, unsigned int *tx_slot,
-				unsigned int *rx_num, unsigned int *rx_slot)
-
-{
-	struct wcd9xxx *taiko = dev_get_drvdata(dai->codec->control_data);
-
-	u32 cnt = 0;
-	u32 tx_ch[SLIM_MAX_TX_PORTS];
-	u32 rx_ch[SLIM_MAX_RX_PORTS];
-
-	if (!rx_slot && !tx_slot) {
-		pr_err("%s: Invalid\n", __func__);
-		return -EINVAL;
-	}
-
-	/* for virtual port, codec driver needs to do
-	 * housekeeping, for now should be ok
-	 */
-	wcd9xxx_get_channel(taiko, rx_ch, tx_ch);
-	if (dai->id == AIF1_PB) {
-		*rx_num = taiko_dai[dai->id - 1].playback.channels_max;
-		while (cnt < *rx_num) {
-			rx_slot[cnt] = rx_ch[cnt];
-			cnt++;
-		}
-	} else if (dai->id == AIF1_CAP) {
-		*tx_num = taiko_dai[dai->id - 1].capture.channels_max;
-		while (cnt < *tx_num) {
-			tx_slot[cnt] = tx_ch[6 + cnt];
-			cnt++;
-		}
-	} else if (dai->id == AIF2_PB) {
-		*rx_num = taiko_dai[dai->id - 1].playback.channels_max;
-		while (cnt < *rx_num) {
-			rx_slot[cnt] = rx_ch[5 + cnt];
-			cnt++;
-		}
-	} else if (dai->id == AIF2_CAP) {
-		*tx_num = taiko_dai[dai->id - 1].capture.channels_max;
-		tx_slot[0] = tx_ch[cnt];
-		tx_slot[1] = tx_ch[1 + cnt];
-		tx_slot[2] = tx_ch[5 + cnt];
-		tx_slot[3] = tx_ch[3 + cnt];
-
-	} else if (dai->id == AIF3_PB) {
-		*rx_num = taiko_dai[dai->id - 1].playback.channels_max;
-		rx_slot[0] = rx_ch[3];
-		rx_slot[1] = rx_ch[4];
-
-	} else if (dai->id == AIF3_CAP) {
-		*tx_num = taiko_dai[dai->id - 1].capture.channels_max;
-		tx_slot[cnt] = tx_ch[2 + cnt];
-		tx_slot[cnt + 1] = tx_ch[4 + cnt];
-	}
-	pr_debug("%s(): dai_name = %s DAI-ID %x tx_ch %d rx_ch %d\n",
-			__func__, dai->name, dai->id, *tx_num, *rx_num);
-
-
-	return 0;
-}
-
-static int taiko_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-	u8 path, shift;
-	u16 tx_fs_reg, rx_fs_reg;
-	u8 tx_fs_rate, rx_fs_rate, rx_state, tx_state;
-	u32 compander_fs;
-
-	pr_debug("%s: dai_name = %s DAI-ID %x rate %d num_ch %d\n", __func__,
-		 dai->name, dai->id, params_rate(params),
-		 params_channels(params));
-
-	switch (params_rate(params)) {
-	case 8000:
-		tx_fs_rate = 0x00;
-		rx_fs_rate = 0x00;
-		compander_fs = COMPANDER_FS_8KHZ;
-		break;
-	case 16000:
-		tx_fs_rate = 0x01;
-		rx_fs_rate = 0x20;
-		compander_fs = COMPANDER_FS_16KHZ;
-		break;
-	case 32000:
-		tx_fs_rate = 0x02;
-		rx_fs_rate = 0x40;
-		compander_fs = COMPANDER_FS_32KHZ;
-		break;
-	case 48000:
-		tx_fs_rate = 0x03;
-		rx_fs_rate = 0x60;
-		compander_fs = COMPANDER_FS_48KHZ;
-		break;
-	case 96000:
-		tx_fs_rate = 0x04;
-		rx_fs_rate = 0x80;
-		compander_fs = COMPANDER_FS_96KHZ;
-		break;
-	case 192000:
-		tx_fs_rate = 0x05;
-		rx_fs_rate = 0xA0;
-		compander_fs = COMPANDER_FS_192KHZ;
-		break;
-	default:
-		pr_err("%s: Invalid sampling rate %d\n", __func__,
-				params_rate(params));
-		return -EINVAL;
-	}
-
-
-	/**
-	 * If current dai is a tx dai, set sample rate to
-	 * all the txfe paths that are currently not active
-	 */
-	if ((dai->id == AIF1_CAP) || (dai->id == AIF2_CAP) ||
-	    (dai->id == AIF3_CAP)) {
-
-		tx_state = snd_soc_read(codec,
-				TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL);
-
-		for (path = 1, shift = 0;
-				path <= NUM_DECIMATORS; path++, shift++) {
-
-			if (path == BITS_PER_REG + 1) {
-				shift = 0;
-				tx_state = snd_soc_read(codec,
-					TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL);
-			}
-
-			if (!(tx_state & (1 << shift))) {
-				tx_fs_reg = TAIKO_A_CDC_TX1_CLK_FS_CTL
-						+ (BITS_PER_REG*(path-1));
-				snd_soc_update_bits(codec, tx_fs_reg,
-							0x07, tx_fs_rate);
-			}
-		}
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			switch (params_format(params)) {
-			case SNDRV_PCM_FORMAT_S16_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					0x20, 0x20);
-				break;
-			case SNDRV_PCM_FORMAT_S32_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					0x20, 0x00);
-				break;
-			default:
-				pr_err("invalid format\n");
-				break;
-			}
-			snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_TX_I2S_CTL,
-						0x07, tx_fs_rate);
-		} else {
-			taiko->dai[dai->id - 1].rate   = params_rate(params);
-		}
-	}
-	/**
-	 * TODO: Need to handle case where same RX chain takes 2 or more inputs
-	 * with varying sample rates
-	 */
-
-	/**
-	 * If current dai is a rx dai, set sample rate to
-	 * all the rx paths that are currently not active
-	 */
-	if (dai->id == AIF1_PB || dai->id == AIF2_PB || dai->id == AIF3_PB) {
-
-		rx_state = snd_soc_read(codec,
-			TAIKO_A_CDC_CLK_RX_B1_CTL);
-
-		for (path = 1, shift = 0;
-				path <= NUM_INTERPOLATORS; path++, shift++) {
-
-			if (!(rx_state & (1 << shift))) {
-				rx_fs_reg = TAIKO_A_CDC_RX1_B5_CTL
-						+ (BITS_PER_REG*(path-1));
-				snd_soc_update_bits(codec, rx_fs_reg,
-						0xE0, rx_fs_rate);
-				if (comp_rx_path[shift] < COMPANDER_MAX)
-					taiko->comp_fs[comp_rx_path[shift]]
-					= compander_fs;
-			}
-		}
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			switch (params_format(params)) {
-			case SNDRV_PCM_FORMAT_S16_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					0x20, 0x20);
-				break;
-			case SNDRV_PCM_FORMAT_S32_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					0x20, 0x00);
-				break;
-			default:
-				pr_err("invalid format\n");
-				break;
-			}
-			snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_I2S_CTL,
-						0x03, (rx_fs_rate >> 0x05));
-		} else {
-			taiko->dai[dai->id - 1].rate   = params_rate(params);
-		}
-	}
-
-	return 0;
-}
-
-static struct snd_soc_dai_ops taiko_dai_ops = {
-	.startup = taiko_startup,
-	.shutdown = taiko_shutdown,
-	.hw_params = taiko_hw_params,
-	.set_sysclk = taiko_set_dai_sysclk,
-	.set_fmt = taiko_set_dai_fmt,
-	.set_channel_map = taiko_set_channel_map,
-	.get_channel_map = taiko_get_channel_map,
-};
-
-static struct snd_soc_dai_driver taiko_dai[] = {
-	{
-		.name = "taiko_rx1",
-		.id = AIF1_PB,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx1",
-		.id = AIF1_CAP,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_rx2",
-		.id = AIF2_PB,
-		.playback = {
-			.stream_name = "AIF2 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_min = 8000,
-			.rate_max = 192000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx2",
-		.id = AIF2_CAP,
-		.capture = {
-			.stream_name = "AIF2 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx3",
-		.id = AIF3_CAP,
-		.capture = {
-			.stream_name = "AIF3 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 48000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_rx3",
-		.id = AIF3_PB,
-		.playback = {
-			.stream_name = "AIF3 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_min = 8000,
-			.rate_max = 192000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-};
-
-static struct snd_soc_dai_driver taiko_i2s_dai[] = {
-	{
-		.name = "taiko_i2s_rx1",
-		.id = 1,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_i2s_tx1",
-		.id = 2,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-};
-
-static int taiko_codec_enable_slimrx(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct wcd9xxx *taiko;
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	u32  j = 0;
-	u32  ret = 0;
-	codec->control_data = dev_get_drvdata(codec->dev->parent);
-	taiko = codec->control_data;
-	/* Execute the callback only if interface type is slimbus */
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		return 0;
-
-	pr_debug("%s: %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		for (j = 0; j < ARRAY_SIZE(taiko_dai); j++) {
-			if ((taiko_dai[j].id == AIF1_CAP) ||
-			    (taiko_dai[j].id == AIF2_CAP) ||
-			    (taiko_dai[j].id == AIF3_CAP))
-				continue;
-			if (!strncmp(w->sname,
-				taiko_dai[j].playback.stream_name, 13)) {
-				++taiko_p->dai[j].ch_act;
-				break;
-			}
-		}
-		if (taiko_p->dai[j].ch_act == taiko_p->dai[j].ch_tot)
-			ret = wcd9xxx_cfg_slim_sch_rx(taiko,
-					taiko_p->dai[j].ch_num,
-					taiko_p->dai[j].ch_tot,
-					taiko_p->dai[j].rate);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		for (j = 0; j < ARRAY_SIZE(taiko_dai); j++) {
-			if ((taiko_dai[j].id == AIF1_CAP) ||
-			    (taiko_dai[j].id == AIF2_CAP) ||
-			    (taiko_dai[j].id == AIF3_CAP))
-				continue;
-			if (!strncmp(w->sname,
-				taiko_dai[j].playback.stream_name, 13)) {
-				--taiko_p->dai[j].ch_act;
-				break;
-			}
-		}
-		if (!taiko_p->dai[j].ch_act) {
-			ret = wcd9xxx_close_slim_sch_rx(taiko,
-						taiko_p->dai[j].ch_num,
-						taiko_p->dai[j].ch_tot);
-			usleep_range(15000, 15000);
-			taiko_p->dai[j].rate = 0;
-			memset(taiko_p->dai[j].ch_num, 0, (sizeof(u32)*
-					taiko_p->dai[j].ch_tot));
-			taiko_p->dai[j].ch_tot = 0;
-		}
-	}
-	return ret;
-}
-
-static int taiko_codec_enable_slimtx(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct wcd9xxx *taiko;
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	/* index to the DAI ID, for now hardcoding */
-	u32  j = 0;
-	u32  ret = 0;
-
-	codec->control_data = dev_get_drvdata(codec->dev->parent);
-	taiko = codec->control_data;
-
-	/* Execute the callback only if interface type is slimbus */
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		return 0;
-
-	pr_debug("%s(): %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		for (j = 0; j < ARRAY_SIZE(taiko_dai); j++) {
-			if (taiko_dai[j].id == AIF1_PB ||
-				taiko_dai[j].id == AIF2_PB ||
-				taiko_dai[j].id == AIF3_PB)
-				continue;
-			if (!strncmp(w->sname,
-				taiko_dai[j].capture.stream_name, 13)) {
-				++taiko_p->dai[j].ch_act;
-				break;
-			}
-		}
-		if (taiko_p->dai[j].ch_act == taiko_p->dai[j].ch_tot)
-			ret = wcd9xxx_cfg_slim_sch_tx(taiko,
-						taiko_p->dai[j].ch_num,
-						taiko_p->dai[j].ch_tot,
-						taiko_p->dai[j].rate);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		for (j = 0; j < ARRAY_SIZE(taiko_dai); j++) {
-			if (taiko_dai[j].id == AIF1_PB ||
-				taiko_dai[j].id == AIF2_PB ||
-				taiko_dai[j].id == AIF3_PB)
-				continue;
-			if (!strncmp(w->sname,
-				taiko_dai[j].capture.stream_name, 13)) {
-				--taiko_p->dai[j].ch_act;
-				break;
-			}
-		}
-		if (!taiko_p->dai[j].ch_act) {
-			ret = wcd9xxx_close_slim_sch_tx(taiko,
-						taiko_p->dai[j].ch_num,
-						taiko_p->dai[j].ch_tot);
-			taiko_p->dai[j].rate = 0;
-			memset(taiko_p->dai[j].ch_num, 0, (sizeof(u32)*
-					taiko_p->dai[j].ch_tot));
-			taiko_p->dai[j].ch_tot = 0;
-		}
-	}
-	return ret;
-}
-
-static int taiko_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_5, 0x02, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_NCP_STATIC, 0x20, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x04, 0x04);
-		snd_soc_update_bits(codec, TAIKO_A_BUCK_MODE_3, 0x08, 0x00);
-
-		usleep_range(5000, 5000);
-		break;
-	}
-	return 0;
-}
-
-/* Todo: Have seperate dapm widgets for I2S and Slimbus.
- * Might Need to have callbacks registered only for slimbus
- */
-static const struct snd_soc_dapm_widget taiko_dapm_widgets[] = {
-	/*RX stuff */
-	SND_SOC_DAPM_OUTPUT("EAR"),
-
-	SND_SOC_DAPM_PGA_E("EAR PA", TAIKO_A_RX_EAR_EN, 4, 0, NULL, 0,
-			taiko_codec_enable_ear_pa, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_MIXER("DAC1", TAIKO_A_RX_EAR_EN, 6, 0, dac1_switch,
-		ARRAY_SIZE(dac1_switch)),
-
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX1", "AIF1 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX2", "AIF1 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX3", "AIF1 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX4", "AIF3 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX5", "AIF3 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX6", "AIF2 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("SLIM RX7", "AIF2 Playback", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	/* Headphone */
-	SND_SOC_DAPM_OUTPUT("HEADPHONE"),
-	SND_SOC_DAPM_PGA_E("HPHL", TAIKO_A_RX_HPH_CNP_EN, 5, 0, NULL, 0,
-		taiko_hph_pa_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MIXER("HPHL DAC", TAIKO_A_RX_HPH_L_DAC_CTL, 7, 0,
-		hphl_switch, ARRAY_SIZE(hphl_switch)),
-
-	SND_SOC_DAPM_PGA_E("HPHR", TAIKO_A_RX_HPH_CNP_EN, 4, 0, NULL, 0,
-		taiko_hph_pa_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU |	SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_DAC_E("HPHR DAC", NULL, TAIKO_A_RX_HPH_R_DAC_CTL, 7, 0,
-		taiko_hphr_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	/* Speaker */
-	SND_SOC_DAPM_OUTPUT("LINEOUT1"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT2"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT3"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT4"),
-	SND_SOC_DAPM_OUTPUT("SPK_OUT"),
-
-	SND_SOC_DAPM_PGA_E("LINEOUT1 PA", TAIKO_A_RX_LINE_CNP_EN, 0, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT2 PA", TAIKO_A_RX_LINE_CNP_EN, 1, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT3 PA", TAIKO_A_RX_LINE_CNP_EN, 2, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT4 PA", TAIKO_A_RX_LINE_CNP_EN, 3, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("SPK PA", TAIKO_A_SPKR_DRV_EN, 7, 0 , NULL,
-			   0, taiko_codec_enable_spk_pa, SND_SOC_DAPM_PRE_PMU |
-			   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_DAC_E("LINEOUT1 DAC", NULL, TAIKO_A_RX_LINE_1_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_DAC_E("LINEOUT2 DAC", NULL, TAIKO_A_RX_LINE_2_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_DAC_E("LINEOUT3 DAC", NULL, TAIKO_A_RX_LINE_3_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_SWITCH("LINEOUT3 DAC GROUND", SND_SOC_NOPM, 0, 0,
-				&lineout3_ground_switch),
-	SND_SOC_DAPM_DAC_E("LINEOUT4 DAC", NULL, TAIKO_A_RX_LINE_4_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_SWITCH("LINEOUT4 DAC GROUND", SND_SOC_NOPM, 0, 0,
-				&lineout4_ground_switch),
-
-	SND_SOC_DAPM_DAC_E("SPK DAC", NULL, SND_SOC_NOPM, 0, 0,
-			   taiko_spk_dac_event,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MIXER_E("RX1 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 0, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX2 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 1, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX7 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 2, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX4 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 3, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX5 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 4, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX6 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 5, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX7 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 6, 0, NULL,
-		0, taiko_codec_reset_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_MIXER("RX1 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX2 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX3 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX_E("RX4 DSM MUX", TAIKO_A_CDC_CLK_RX_B1_CTL, 3, 0,
-		&rx4_dsm_mux, taiko_codec_reset_interpolator,
-		SND_SOC_DAPM_PRE_PMU),
-
-	SND_SOC_DAPM_MUX_E("RX6 DSM MUX", TAIKO_A_CDC_CLK_RX_B1_CTL, 5, 0,
-		&rx6_dsm_mux, taiko_codec_reset_interpolator,
-		SND_SOC_DAPM_PRE_PMU),
-
-	SND_SOC_DAPM_MIXER("RX1 CHAIN", TAIKO_A_CDC_RX1_B6_CTL, 5, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX2 CHAIN", TAIKO_A_CDC_RX2_B6_CTL, 5, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP3", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp3_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx2_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx2_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX3 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx3_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX3 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx3_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX4 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx4_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX4 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx4_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX5 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx5_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX5 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx5_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX6 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx6_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX6 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx6_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx7_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx7_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx1_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx1_mix2_inp2_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx2_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx2_mix2_inp2_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx7_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx7_mix2_inp2_mux),
-
-	SND_SOC_DAPM_SUPPLY("CLASS_H_CLK", TAIKO_A_CDC_CLK_OTHR_CTL, 0, 0,
-		taiko_codec_enable_class_h_clk, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_PRE_PMD),
-
-	SND_SOC_DAPM_SUPPLY("CLASS_H_EAR", TAIKO_A_CDC_CLSH_B1_CTL, 4, 0,
-		taiko_codec_enable_class_h, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_SUPPLY("CLASS_H_HPH_R", TAIKO_A_CDC_CLSH_B1_CTL, 3, 0,
-		taiko_codec_enable_class_h, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_SUPPLY("CLASS_H_HPH_L", TAIKO_A_CDC_CLSH_B1_CTL, 2, 0,
-		taiko_codec_enable_class_h, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_SUPPLY("CP", TAIKO_A_NCP_EN, 0, 0,
-		taiko_codec_enable_charge_pump, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-
-	SND_SOC_DAPM_SUPPLY("RX_BIAS", SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_rx_bias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	/* TX */
-
-	SND_SOC_DAPM_SUPPLY("CDC_CONN", TAIKO_A_CDC_CLK_OTHR_CTL, 2, 0, NULL,
-		0),
-
-	SND_SOC_DAPM_SUPPLY("LDO_H", TAIKO_A_LDO_H_MODE_1, 7, 0,
-		taiko_codec_enable_ldo_h, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_SUPPLY("COMP1_CLK", SND_SOC_NOPM, 0, 0,
-		taiko_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_SUPPLY("COMP2_CLK", SND_SOC_NOPM, 1, 0,
-		taiko_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-
-
-	SND_SOC_DAPM_INPUT("AMIC1"),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 External", TAIKO_A_MICB_1_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 Internal1", TAIKO_A_MICB_1_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 Internal2", TAIKO_A_MICB_1_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC1", NULL, TAIKO_A_TX_1_2_EN, 7, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_INPUT("AMIC3"),
-	SND_SOC_DAPM_ADC_E("ADC3", NULL, TAIKO_A_TX_3_4_EN, 7, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_INPUT("AMIC4"),
-	SND_SOC_DAPM_ADC_E("ADC4", NULL, TAIKO_A_TX_3_4_EN, 3, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_INPUT("AMIC5"),
-	SND_SOC_DAPM_ADC_E("ADC5", NULL, TAIKO_A_TX_5_6_EN, 7, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_INPUT("AMIC6"),
-	SND_SOC_DAPM_ADC_E("ADC6", NULL, TAIKO_A_TX_5_6_EN, 3, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_MUX_E("DEC1 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 0, 0,
-		&dec1_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC2 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 1, 0,
-		&dec2_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC3 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 2, 0,
-		&dec3_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC4 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 3, 0,
-		&dec4_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC5 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 4, 0,
-		&dec5_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC6 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 5, 0,
-		&dec6_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC7 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 6, 0,
-		&dec7_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC8 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 7, 0,
-		&dec8_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC9 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 0, 0,
-		&dec9_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC10 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 1, 0,
-		&dec10_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("ANC1 MUX", SND_SOC_NOPM, 0, 0, &anc1_mux),
-	SND_SOC_DAPM_MUX("ANC2 MUX", SND_SOC_NOPM, 0, 0, &anc2_mux),
-
-	SND_SOC_DAPM_MIXER_E("ANC", SND_SOC_NOPM, 0, 0, NULL, 0,
-		taiko_codec_enable_anc, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("ANC1 FB MUX", SND_SOC_NOPM, 0, 0, &anc1_fb_mux),
-
-	SND_SOC_DAPM_INPUT("AMIC2"),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 External", TAIKO_A_MICB_2_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU |	SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal1", TAIKO_A_MICB_2_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal2", TAIKO_A_MICB_2_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal3", TAIKO_A_MICB_2_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 External", TAIKO_A_MICB_3_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 Internal1", TAIKO_A_MICB_3_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 Internal2", TAIKO_A_MICB_3_CTL, 7, 0,
-		taiko_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS4 External", TAIKO_A_MICB_4_CTL, 7,
-				0, taiko_codec_enable_micbias,
-				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-				SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("ADC2", NULL, TAIKO_A_TX_1_2_EN, 3, 0,
-		taiko_codec_enable_adc, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX1 MUX", SND_SOC_NOPM, 0, 0, &sb_tx1_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX1", "AIF2 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX2 MUX", SND_SOC_NOPM, 0, 0, &sb_tx2_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX2", "AIF2 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX3 MUX", SND_SOC_NOPM, 0, 0, &sb_tx3_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX3", "AIF3 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX4 MUX", SND_SOC_NOPM, 0, 0, &sb_tx4_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX4", "AIF2 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX5 MUX", SND_SOC_NOPM, 0, 0, &sb_tx5_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX5", "AIF3 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX6 MUX", SND_SOC_NOPM, 0, 0, &sb_tx6_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX6", "AIF2 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX7 MUX", SND_SOC_NOPM, 0, 0, &sb_tx7_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX7", "AIF1 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX8 MUX", SND_SOC_NOPM, 0, 0, &sb_tx8_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX8", "AIF1 Capture", 0, SND_SOC_NOPM, 0,
-				0, taiko_codec_enable_slimtx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX9 MUX", SND_SOC_NOPM, 0, 0, &sb_tx9_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX9", "AIF1 Capture", NULL, SND_SOC_NOPM,
-			0, 0, taiko_codec_enable_slimtx,
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM TX10 MUX", SND_SOC_NOPM, 0, 0, &sb_tx10_mux),
-	SND_SOC_DAPM_AIF_OUT_E("SLIM TX10", "AIF1 Capture", NULL, SND_SOC_NOPM,
-			0, 0, taiko_codec_enable_slimtx,
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	/* Digital Mic Inputs */
-	SND_SOC_DAPM_ADC_E("DMIC1", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC2", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC3", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC4", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC5", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("DMIC6", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	/* Sidetone */
-	SND_SOC_DAPM_MUX("IIR1 INP1 MUX", SND_SOC_NOPM, 0, 0, &iir1_inp1_mux),
-	SND_SOC_DAPM_PGA("IIR1", TAIKO_A_CDC_CLK_SD_CTL, 0, 0, NULL, 0),
-
-	/* AUX PGA */
-	SND_SOC_DAPM_ADC_E("AUX_PGA_Left", NULL, TAIKO_A_RX_AUX_SW_CTL, 7, 0,
-		taiko_codec_enable_aux_pga, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("AUX_PGA_Right", NULL, TAIKO_A_RX_AUX_SW_CTL, 6, 0,
-		taiko_codec_enable_aux_pga, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	/* Lineout, ear and HPH PA Mixers */
-
-	SND_SOC_DAPM_MIXER("EAR_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		ear_pa_mix, ARRAY_SIZE(ear_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("HPHL_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		hphl_pa_mix, ARRAY_SIZE(hphl_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("HPHR_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		hphr_pa_mix, ARRAY_SIZE(hphr_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT1_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout1_pa_mix, ARRAY_SIZE(lineout1_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT2_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout2_pa_mix, ARRAY_SIZE(lineout2_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT3_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout3_pa_mix, ARRAY_SIZE(lineout3_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT4_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout4_pa_mix, ARRAY_SIZE(lineout4_pa_mix)),
-
-};
-
-static short taiko_codec_read_sta_result(struct snd_soc_codec *codec)
-{
-	u8 bias_msb, bias_lsb;
-	short bias_value;
-
-	bias_msb = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B3_STATUS);
-	bias_lsb = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B2_STATUS);
-	bias_value = (bias_msb << 8) | bias_lsb;
-	return bias_value;
-}
-
-static short taiko_codec_read_dce_result(struct snd_soc_codec *codec)
-{
-	u8 bias_msb, bias_lsb;
-	short bias_value;
-
-	bias_msb = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B5_STATUS);
-	bias_lsb = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B4_STATUS);
-	bias_value = (bias_msb << 8) | bias_lsb;
-	return bias_value;
-}
-
-static void taiko_turn_onoff_rel_detection(struct snd_soc_codec *codec, bool on)
-{
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x02, on << 1);
-}
-
-static short __taiko_codec_sta_dce(struct snd_soc_codec *codec, int dce,
-				   bool override_bypass, bool noreldetection)
-{
-	short bias_value;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL);
-	if (noreldetection)
-		taiko_turn_onoff_rel_detection(codec, false);
-
-	/* Turn on the override */
-	if (!override_bypass)
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x4, 0x4);
-	if (dce) {
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-		snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x4);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x0);
-		usleep_range(taiko->mbhc_data.t_sta_dce,
-			     taiko->mbhc_data.t_sta_dce);
-		snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x4);
-		usleep_range(taiko->mbhc_data.t_dce,
-			     taiko->mbhc_data.t_dce);
-		bias_value = taiko_codec_read_dce_result(codec);
-	} else {
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-		snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x2);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x0);
-		usleep_range(taiko->mbhc_data.t_sta_dce,
-			     taiko->mbhc_data.t_sta_dce);
-		snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x2);
-		usleep_range(taiko->mbhc_data.t_sta,
-			     taiko->mbhc_data.t_sta);
-		bias_value = taiko_codec_read_sta_result(codec);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-		snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x0);
-	}
-	/* Turn off the override after measuring mic voltage */
-	if (!override_bypass)
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x04, 0x00);
-
-	if (noreldetection)
-		taiko_turn_onoff_rel_detection(codec, true);
-	wcd9xxx_enable_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL);
-
-	return bias_value;
-}
-
-static short taiko_codec_sta_dce(struct snd_soc_codec *codec, int dce,
-				 bool norel)
-{
-	return __taiko_codec_sta_dce(codec, dce, false, norel);
-}
-
-/* called only from interrupt which is under codec_resource_lock acquisition */
-static short taiko_codec_setup_hs_polling(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	short bias_value;
-	u8 cfilt_mode;
-
-	pr_debug("%s: enter, mclk_enabled %d\n", __func__, taiko->mclk_enabled);
-	if (!taiko->mbhc_cfg.calibration) {
-		pr_err("Error, no taiko calibration\n");
-		return -ENODEV;
-	}
-
-	if (!taiko->mclk_enabled) {
-		taiko_codec_disable_clock_block(codec);
-		taiko_codec_enable_bandgap(codec, TAIKO_BANDGAP_MBHC_MODE);
-		taiko_enable_rx_bias(codec, 1);
-		taiko_codec_enable_clock_block(codec, 1);
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CLK_BUFF_EN1, 0x05, 0x01);
-
-	/* Make sure CFILT is in fast mode, save current mode */
-	cfilt_mode = snd_soc_read(codec, taiko->mbhc_bias_regs.cfilt_ctl);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.cfilt_ctl, 0x70, 0x00);
-
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x1F, 0x16);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x2, 0x2);
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x84);
-
-	snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_EN, 0x80, 0x80);
-	snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_EN, 0x1F, 0x1C);
-	snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_TEST_CTL, 0x40, 0x40);
-
-	snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_EN, 0x80, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x00);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x2, 0x2);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x8, 0x8);
-
-	taiko_codec_calibrate_hs_polling(codec);
-
-	/* don't flip override */
-	bias_value = __taiko_codec_sta_dce(codec, 1, true, true);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.cfilt_ctl, 0x40,
-			    cfilt_mode);
-	snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x13, 0x00);
-
-	return bias_value;
-}
-
-static int taiko_cancel_btn_work(struct taiko_priv *taiko)
-{
-	int r = 0;
-	struct wcd9xxx *core = dev_get_drvdata(taiko->codec->dev->parent);
-
-	if (cancel_delayed_work_sync(&taiko->mbhc_btn_dwork)) {
-		/* if scheduled mbhc_btn_dwork is canceled from here,
-		* we have to unlock from here instead btn_work */
-		wcd9xxx_unlock_sleep(core);
-		r = 1;
-	}
-	return r;
-}
-
-/* called under codec_resource_lock acquisition */
-void taiko_set_and_turnoff_hph_padac(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u8 wg_time;
-
-	wg_time = snd_soc_read(codec, TAIKO_A_RX_HPH_CNP_WG_TIME) ;
-	wg_time += 1;
-
-	/* If headphone PA is on, check if userspace receives
-	 * removal event to sync-up PA's state */
-	if (taiko_is_hph_pa_on(codec)) {
-		pr_debug("%s PA is on, setting PA_OFF_ACK\n", __func__);
-		set_bit(TAIKO_HPHL_PA_OFF_ACK, &taiko->hph_pa_dac_state);
-		set_bit(TAIKO_HPHR_PA_OFF_ACK, &taiko->hph_pa_dac_state);
-	} else {
-		pr_debug("%s PA is off\n", __func__);
-	}
-
-	if (taiko_is_hph_dac_on(codec, 1))
-		set_bit(TAIKO_HPHL_DAC_OFF_ACK, &taiko->hph_pa_dac_state);
-	if (taiko_is_hph_dac_on(codec, 0))
-		set_bit(TAIKO_HPHR_DAC_OFF_ACK, &taiko->hph_pa_dac_state);
-
-	snd_soc_update_bits(codec, TAIKO_A_RX_HPH_CNP_EN, 0x30, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_RX_HPH_L_DAC_CTL,
-			    0xC0, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_RX_HPH_R_DAC_CTL,
-			    0xC0, 0x00);
-	usleep_range(wg_time * 1000, wg_time * 1000);
-}
-
-static void taiko_clr_and_turnon_hph_padac(struct taiko_priv *taiko)
-{
-	bool pa_turned_on = false;
-	struct snd_soc_codec *codec = taiko->codec;
-	u8 wg_time;
-
-	wg_time = snd_soc_read(codec, TAIKO_A_RX_HPH_CNP_WG_TIME) ;
-	wg_time += 1;
-
-	if (test_and_clear_bit(TAIKO_HPHR_DAC_OFF_ACK,
-			       &taiko->hph_pa_dac_state)) {
-		pr_debug("%s: HPHR clear flag and enable DAC\n", __func__);
-		snd_soc_update_bits(taiko->codec, TAIKO_A_RX_HPH_R_DAC_CTL,
-				    0xC0, 0xC0);
-	}
-	if (test_and_clear_bit(TAIKO_HPHL_DAC_OFF_ACK,
-			       &taiko->hph_pa_dac_state)) {
-		pr_debug("%s: HPHL clear flag and enable DAC\n", __func__);
-		snd_soc_update_bits(taiko->codec, TAIKO_A_RX_HPH_L_DAC_CTL,
-				    0xC0, 0xC0);
-	}
-
-	if (test_and_clear_bit(TAIKO_HPHR_PA_OFF_ACK,
-			       &taiko->hph_pa_dac_state)) {
-		pr_debug("%s: HPHR clear flag and enable PA\n", __func__);
-		snd_soc_update_bits(taiko->codec, TAIKO_A_RX_HPH_CNP_EN, 0x10,
-				    1 << 4);
-		pa_turned_on = true;
-	}
-	if (test_and_clear_bit(TAIKO_HPHL_PA_OFF_ACK,
-			       &taiko->hph_pa_dac_state)) {
-		pr_debug("%s: HPHL clear flag and enable PA\n", __func__);
-		snd_soc_update_bits(taiko->codec, TAIKO_A_RX_HPH_CNP_EN, 0x20,
-				    1 << 5);
-		pa_turned_on = true;
-	}
-
-	if (pa_turned_on) {
-		pr_debug("%s: PA was turned off by MBHC and not by DAPM\n",
-				__func__);
-		usleep_range(wg_time * 1000, wg_time * 1000);
-	}
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_report_plug(struct snd_soc_codec *codec, int insertion,
-				    enum snd_jack_types jack_type)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	if (!insertion) {
-		/* Report removal */
-		taiko->hph_status &= ~jack_type;
-		if (taiko->mbhc_cfg.headset_jack) {
-			/* cancel possibly scheduled btn work and
-			* report release if we reported button press */
-			if (taiko_cancel_btn_work(taiko)) {
-				pr_debug("%s: button press is canceled\n",
-					__func__);
-			} else if (taiko->buttons_pressed) {
-				pr_debug("%s: release of button press%d\n",
-					  __func__, jack_type);
-				taiko_snd_soc_jack_report(taiko,
-						 taiko->mbhc_cfg.button_jack, 0,
-						 taiko->buttons_pressed);
-				taiko->buttons_pressed &=
-							~TAIKO_JACK_BUTTON_MASK;
-			}
-			pr_debug("%s: Reporting removal %d(%x)\n", __func__,
-				 jack_type, taiko->hph_status);
-			taiko_snd_soc_jack_report(taiko,
-						  taiko->mbhc_cfg.headset_jack,
-						  taiko->hph_status,
-						  TAIKO_JACK_MASK);
-		}
-		taiko_set_and_turnoff_hph_padac(codec);
-		hphocp_off_report(taiko, SND_JACK_OC_HPHR,
-				  TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-		hphocp_off_report(taiko, SND_JACK_OC_HPHL,
-				  TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-		taiko->current_plug = PLUG_TYPE_NONE;
-		taiko->mbhc_polling_active = false;
-	} else {
-		/* Report insertion */
-		taiko->hph_status |= jack_type;
-
-		if (jack_type == SND_JACK_HEADPHONE)
-			taiko->current_plug = PLUG_TYPE_HEADPHONE;
-		else if (jack_type == SND_JACK_UNSUPPORTED)
-			taiko->current_plug = PLUG_TYPE_GND_MIC_SWAP;
-		else if (jack_type == SND_JACK_HEADSET) {
-			taiko->mbhc_polling_active = true;
-			taiko->current_plug = PLUG_TYPE_HEADSET;
-		}
-		if (taiko->mbhc_cfg.headset_jack) {
-			pr_debug("%s: Reporting insertion %d(%x)\n", __func__,
-				 jack_type, taiko->hph_status);
-			taiko_snd_soc_jack_report(taiko,
-						  taiko->mbhc_cfg.headset_jack,
-						  taiko->hph_status,
-						  TAIKO_JACK_MASK);
-		}
-		taiko_clr_and_turnon_hph_padac(taiko);
-	}
-}
-
-static int taiko_codec_enable_hs_detect(struct snd_soc_codec *codec,
-					int insertion, int trigger,
-					bool padac_off)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	int central_bias_enabled = 0;
-	const struct taiko_mbhc_general_cfg *generic =
-	    TAIKO_MBHC_CAL_GENERAL_PTR(taiko->mbhc_cfg.calibration);
-	const struct taiko_mbhc_plug_detect_cfg *plug_det =
-	    TAIKO_MBHC_CAL_PLUG_DET_PTR(taiko->mbhc_cfg.calibration);
-
-	if (!taiko->mbhc_cfg.calibration) {
-		pr_err("Error, no taiko calibration\n");
-		return -EINVAL;
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_INT_CTL, 0x1, 0);
-
-	/* Make sure mic bias and Mic line schmitt trigger
-	 * are turned OFF
-	 */
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x01, 0x01);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg, 0x90, 0x00);
-
-	if (insertion) {
-		taiko_codec_switch_micbias(codec, 0);
-
-		/* DAPM can manipulate PA/DAC bits concurrently */
-		if (padac_off == true)
-			taiko_set_and_turnoff_hph_padac(codec);
-
-		if (trigger & MBHC_USE_HPHL_TRIGGER) {
-			/* Enable HPH Schmitt Trigger */
-			snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x11,
-					    0x11);
-			snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x0C,
-					    plug_det->hph_current << 2);
-			snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x02,
-					    0x02);
-		}
-		if (trigger & MBHC_USE_MB_TRIGGER) {
-			/* enable the mic line schmitt trigger */
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.mbhc_reg,
-					    0x60, plug_det->mic_current << 5);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.mbhc_reg,
-					    0x80, 0x80);
-			usleep_range(plug_det->t_mic_pid, plug_det->t_mic_pid);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.ctl_reg, 0x01,
-					    0x00);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.mbhc_reg,
-					    0x10, 0x10);
-		}
-
-		/* setup for insetion detection */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_INT_CTL, 0x2, 0);
-	} else {
-		pr_debug("setup for removal detection\n");
-		/* Make sure the HPH schmitt trigger is OFF */
-		snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x12, 0x00);
-
-		/* enable the mic line schmitt trigger */
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg,
-				    0x01, 0x00);
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg, 0x60,
-				    plug_det->mic_current << 5);
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-			0x80, 0x80);
-		usleep_range(plug_det->t_mic_pid, plug_det->t_mic_pid);
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg,
-			0x10, 0x10);
-
-		/* Setup for low power removal detection */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_INT_CTL, 0x2, 0x2);
-	}
-
-	if (snd_soc_read(codec, TAIKO_A_CDC_MBHC_B1_CTL) & 0x4) {
-		/* called called by interrupt */
-		if (!(taiko->clock_active)) {
-			taiko_codec_enable_config_mode(codec, 1);
-			snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL,
-				0x06, 0);
-			usleep_range(generic->t_shutdown_plug_rem,
-				     generic->t_shutdown_plug_rem);
-			taiko_codec_enable_config_mode(codec, 0);
-		} else
-			snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL,
-				0x06, 0);
-	}
-
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.int_rbias, 0x80, 0);
-
-	/* If central bandgap disabled */
-	if (!(snd_soc_read(codec, TAIKO_A_PIN_CTL_OE1) & 1)) {
-		snd_soc_update_bits(codec, TAIKO_A_PIN_CTL_OE1, 0x3, 0x3);
-		usleep_range(generic->t_bg_fast_settle,
-			     generic->t_bg_fast_settle);
-		central_bias_enabled = 1;
-	}
-
-	/* If LDO_H disabled */
-	if (snd_soc_read(codec, TAIKO_A_PIN_CTL_OE0) & 0x80) {
-		snd_soc_update_bits(codec, TAIKO_A_PIN_CTL_OE0, 0x10, 0);
-		snd_soc_update_bits(codec, TAIKO_A_PIN_CTL_OE0, 0x80, 0x80);
-		usleep_range(generic->t_ldoh, generic->t_ldoh);
-		snd_soc_update_bits(codec, TAIKO_A_PIN_CTL_OE0, 0x80, 0);
-
-		if (central_bias_enabled)
-			snd_soc_update_bits(codec, TAIKO_A_PIN_CTL_OE1, 0x1, 0);
-	}
-
-	snd_soc_update_bits(codec, taiko->reg_addr.micb_4_mbhc, 0x3,
-			    taiko->mbhc_cfg.micbias);
-
-	wcd9xxx_enable_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_INT_CTL, 0x1, 0x1);
-	return 0;
-}
-
-static u16 taiko_codec_v_sta_dce(struct snd_soc_codec *codec, bool dce,
-				 s16 vin_mv)
-{
-	struct taiko_priv *taiko;
-	s16 diff, zero;
-	u32 mb_mv, in;
-	u16 value;
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	mb_mv = taiko->mbhc_data.micb_mv;
-
-	if (mb_mv == 0) {
-		pr_err("%s: Mic Bias voltage is set to zero\n", __func__);
-		return -EINVAL;
-	}
-
-	if (dce) {
-		diff = (taiko->mbhc_data.dce_mb) - (taiko->mbhc_data.dce_z);
-		zero = (taiko->mbhc_data.dce_z);
-	} else {
-		diff = (taiko->mbhc_data.sta_mb) - (taiko->mbhc_data.sta_z);
-		zero = (taiko->mbhc_data.sta_z);
-	}
-	in = (u32) diff * vin_mv;
-
-	value = (u16) (in / mb_mv) + zero;
-	return value;
-}
-
-static s32 taiko_codec_sta_dce_v(struct snd_soc_codec *codec, s8 dce,
-				 u16 bias_value)
-{
-	struct taiko_priv *taiko;
-	s16 value, z, mb;
-	s32 mv;
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	value = bias_value;
-	if (dce) {
-		z = (taiko->mbhc_data.dce_z);
-		mb = (taiko->mbhc_data.dce_mb);
-		mv = (value - z) * (s32)taiko->mbhc_data.micb_mv / (mb - z);
-	} else {
-		z = (taiko->mbhc_data.sta_z);
-		mb = (taiko->mbhc_data.sta_mb);
-		mv = (value - z) * (s32)taiko->mbhc_data.micb_mv / (mb - z);
-	}
-
-	return mv;
-}
-
-static void btn_lpress_fn(struct work_struct *work)
-{
-	struct delayed_work *delayed_work;
-	struct taiko_priv *taiko;
-	short bias_value;
-	int dce_mv, sta_mv;
-	struct wcd9xxx *core;
-
-	pr_debug("%s:\n", __func__);
-
-	delayed_work = to_delayed_work(work);
-	taiko = container_of(delayed_work, struct taiko_priv, mbhc_btn_dwork);
-	core = dev_get_drvdata(taiko->codec->dev->parent);
-
-	if (taiko) {
-		if (taiko->mbhc_cfg.button_jack) {
-			bias_value = taiko_codec_read_sta_result(taiko->codec);
-			sta_mv = taiko_codec_sta_dce_v(taiko->codec, 0,
-						bias_value);
-			bias_value = taiko_codec_read_dce_result(taiko->codec);
-			dce_mv = taiko_codec_sta_dce_v(taiko->codec, 1,
-						bias_value);
-			pr_debug("%s: Reporting long button press event\n",
-				__func__);
-			pr_debug("%s: STA: %d, DCE: %d\n", __func__, sta_mv,
-					dce_mv);
-			taiko_snd_soc_jack_report(taiko,
-						  taiko->mbhc_cfg.button_jack,
-						  taiko->buttons_pressed,
-						  taiko->buttons_pressed);
-		}
-	} else {
-		pr_err("%s: Bad taiko private data\n", __func__);
-	}
-
-	pr_debug("%s: leave\n", __func__);
-	wcd9xxx_unlock_sleep(core);
-}
-
-void taiko_mbhc_cal(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko;
-	struct taiko_mbhc_btn_detect_cfg *btn_det;
-	u8 cfilt_mode, bg_mode;
-	u8 ncic, nmeas, navg;
-	u32 mclk_rate;
-	u32 dce_wait, sta_wait;
-	u8 *n_cic;
-	void *calibration;
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	calibration = taiko->mbhc_cfg.calibration;
-
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL);
-	taiko_turn_onoff_rel_detection(codec, false);
-
-	/* First compute the DCE / STA wait times
-	 * depending on tunable parameters.
-	 * The value is computed in microseconds
-	 */
-	btn_det = TAIKO_MBHC_CAL_BTN_DET_PTR(calibration);
-	n_cic = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_N_CIC);
-	ncic = n_cic[taiko_codec_mclk_index(taiko)];
-	nmeas = TAIKO_MBHC_CAL_BTN_DET_PTR(calibration)->n_meas;
-	navg = TAIKO_MBHC_CAL_GENERAL_PTR(calibration)->mbhc_navg;
-	mclk_rate = taiko->mbhc_cfg.mclk_rate;
-	dce_wait = (1000 * 512 * ncic * (nmeas + 1)) / (mclk_rate / 1000);
-	sta_wait = (1000 * 128 * (navg + 1)) / (mclk_rate / 1000);
-
-	taiko->mbhc_data.t_dce = dce_wait;
-	taiko->mbhc_data.t_sta = sta_wait;
-
-	/* LDOH and CFILT are already configured during pdata handling.
-	 * Only need to make sure CFILT and bandgap are in Fast mode.
-	 * Need to restore defaults once calculation is done.
-	 */
-	cfilt_mode = snd_soc_read(codec, taiko->mbhc_bias_regs.cfilt_ctl);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.cfilt_ctl, 0x40, 0x00);
-	bg_mode = snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x02,
-				      0x02);
-
-	/* Micbias, CFILT, LDOH, MBHC MUX mode settings
-	 * to perform ADC calibration
-	 */
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x60,
-			    taiko->mbhc_cfg.micbias << 5);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x01, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_LDO_H_MODE_1, 0x60, 0x60);
-	snd_soc_write(codec, TAIKO_A_TX_7_MBHC_TEST_CTL, 0x78);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x04, 0x04);
-
-	/* DCE measurement for 0 volts */
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x0A);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x04);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x02);
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x81);
-	usleep_range(100, 100);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x04);
-	usleep_range(taiko->mbhc_data.t_dce, taiko->mbhc_data.t_dce);
-	taiko->mbhc_data.dce_z = taiko_codec_read_dce_result(codec);
-
-	/* DCE measurment for MB voltage */
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x0A);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x02);
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x82);
-	usleep_range(100, 100);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x04);
-	usleep_range(taiko->mbhc_data.t_dce, taiko->mbhc_data.t_dce);
-	taiko->mbhc_data.dce_mb = taiko_codec_read_dce_result(codec);
-
-	/* Sta measuremnt for 0 volts */
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x0A);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x02);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x02);
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x81);
-	usleep_range(100, 100);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x02);
-	usleep_range(taiko->mbhc_data.t_sta, taiko->mbhc_data.t_sta);
-	taiko->mbhc_data.sta_z = taiko_codec_read_sta_result(codec);
-
-	/* STA Measurement for MB Voltage */
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x82);
-	usleep_range(100, 100);
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_EN_CTL, 0x02);
-	usleep_range(taiko->mbhc_data.t_sta, taiko->mbhc_data.t_sta);
-	taiko->mbhc_data.sta_mb = taiko_codec_read_sta_result(codec);
-
-	/* Restore default settings. */
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x04, 0x00);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.cfilt_ctl, 0x40,
-			    cfilt_mode);
-	snd_soc_update_bits(codec, TAIKO_A_BIAS_CENTRAL_BG_CTL, 0x02, bg_mode);
-
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x84);
-	usleep_range(100, 100);
-
-	wcd9xxx_enable_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL);
-	taiko_turn_onoff_rel_detection(codec, true);
-}
-
-void *taiko_mbhc_cal_btn_det_mp(const struct taiko_mbhc_btn_detect_cfg *btn_det,
-				const enum taiko_mbhc_btn_det_mem mem)
-{
-	void *ret = &btn_det->_v_btn_low;
-
-	switch (mem) {
-	case TAIKO_BTN_DET_GAIN:
-		ret += sizeof(btn_det->_n_cic);
-	case TAIKO_BTN_DET_N_CIC:
-		ret += sizeof(btn_det->_n_ready);
-	case TAIKO_BTN_DET_N_READY:
-		ret += sizeof(btn_det->_v_btn_high[0]) * btn_det->num_btn;
-	case TAIKO_BTN_DET_V_BTN_HIGH:
-		ret += sizeof(btn_det->_v_btn_low[0]) * btn_det->num_btn;
-	case TAIKO_BTN_DET_V_BTN_LOW:
-		/* do nothing */
-		break;
-	default:
-		ret = NULL;
-	}
-
-	return ret;
-}
-
-static s16 taiko_scale_v_micb_vddio(struct taiko_priv *taiko, int v,
-				    bool tovddio)
-{
-	int r;
-	int vddio_k, mb_k;
-	vddio_k = taiko_find_k_value(taiko->pdata->micbias.ldoh_v,
-				     VDDIO_MICBIAS_MV);
-	mb_k = taiko_find_k_value(taiko->pdata->micbias.ldoh_v,
-				  taiko->mbhc_data.micb_mv);
-	if (tovddio)
-		r = v * vddio_k / mb_k;
-	else
-		r = v * mb_k / vddio_k;
-	return r;
-}
-
-static void taiko_mbhc_calc_thres(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko;
-	s16 btn_mv = 0, btn_delta_mv;
-	struct taiko_mbhc_btn_detect_cfg *btn_det;
-	struct taiko_mbhc_plug_type_cfg *plug_type;
-	u16 *btn_high;
-	u8 *n_ready;
-	int i;
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	btn_det = TAIKO_MBHC_CAL_BTN_DET_PTR(taiko->mbhc_cfg.calibration);
-	plug_type = TAIKO_MBHC_CAL_PLUG_TYPE_PTR(taiko->mbhc_cfg.calibration);
-
-	n_ready = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_N_READY);
-	if (taiko->mbhc_cfg.mclk_rate == TAIKO_MCLK_RATE_12288KHZ) {
-		taiko->mbhc_data.npoll = 4;
-		taiko->mbhc_data.nbounce_wait = 30;
-	} else if (taiko->mbhc_cfg.mclk_rate == TAIKO_MCLK_RATE_9600KHZ) {
-		taiko->mbhc_data.npoll = 7;
-		taiko->mbhc_data.nbounce_wait = 23;
-	}
-
-	taiko->mbhc_data.t_sta_dce = ((1000 * 256) /
-				      (taiko->mbhc_cfg.mclk_rate / 1000) *
-				      n_ready[taiko_codec_mclk_index(taiko)]) +
-				     10;
-	taiko->mbhc_data.v_ins_hu =
-	    taiko_codec_v_sta_dce(codec, STA, plug_type->v_hs_max);
-	taiko->mbhc_data.v_ins_h =
-	    taiko_codec_v_sta_dce(codec, DCE, plug_type->v_hs_max);
-
-	taiko->mbhc_data.v_inval_ins_low = TAIKO_MBHC_FAKE_INSERT_LOW;
-	if (taiko->mbhc_cfg.gpio)
-		taiko->mbhc_data.v_inval_ins_high =
-		    TAIKO_MBHC_FAKE_INSERT_HIGH;
-	else
-		taiko->mbhc_data.v_inval_ins_high =
-		    TAIKO_MBHC_FAKE_INS_HIGH_NO_GPIO;
-
-	if (taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV) {
-		taiko->mbhc_data.adj_v_hs_max =
-		    taiko_scale_v_micb_vddio(taiko, plug_type->v_hs_max, true);
-		taiko->mbhc_data.adj_v_ins_hu =
-		    taiko_codec_v_sta_dce(codec, STA,
-					  taiko->mbhc_data.adj_v_hs_max);
-		taiko->mbhc_data.adj_v_ins_h =
-		    taiko_codec_v_sta_dce(codec, DCE,
-					  taiko->mbhc_data.adj_v_hs_max);
-		taiko->mbhc_data.v_inval_ins_low =
-		    taiko_scale_v_micb_vddio(taiko,
-					     taiko->mbhc_data.v_inval_ins_low,
-					     false);
-		taiko->mbhc_data.v_inval_ins_high =
-		    taiko_scale_v_micb_vddio(taiko,
-					     taiko->mbhc_data.v_inval_ins_high,
-					     false);
-	}
-
-	btn_high = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_V_BTN_HIGH);
-	for (i = 0; i < btn_det->num_btn; i++)
-		btn_mv = btn_high[i] > btn_mv ? btn_high[i] : btn_mv;
-
-	taiko->mbhc_data.v_b1_h = taiko_codec_v_sta_dce(codec, DCE, btn_mv);
-	btn_delta_mv = btn_mv + btn_det->v_btn_press_delta_sta;
-	taiko->mbhc_data.v_b1_hu =
-	    taiko_codec_v_sta_dce(codec, STA, btn_delta_mv);
-
-	btn_delta_mv = btn_mv + btn_det->v_btn_press_delta_cic;
-
-	taiko->mbhc_data.v_b1_huc =
-	    taiko_codec_v_sta_dce(codec, DCE, btn_delta_mv);
-
-	taiko->mbhc_data.v_brh = taiko->mbhc_data.v_b1_h;
-	taiko->mbhc_data.v_brl = TAIKO_MBHC_BUTTON_MIN;
-
-	taiko->mbhc_data.v_no_mic =
-	    taiko_codec_v_sta_dce(codec, STA, plug_type->v_no_mic);
-}
-
-void taiko_mbhc_init(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko;
-	struct taiko_mbhc_general_cfg *generic;
-	struct taiko_mbhc_btn_detect_cfg *btn_det;
-	int n;
-	u8 *n_cic, *gain;
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	generic = TAIKO_MBHC_CAL_GENERAL_PTR(taiko->mbhc_cfg.calibration);
-	btn_det = TAIKO_MBHC_CAL_BTN_DET_PTR(taiko->mbhc_cfg.calibration);
-
-	for (n = 0; n < 8; n++) {
-			snd_soc_update_bits(codec,
-					    TAIKO_A_CDC_MBHC_FIR_B1_CFG,
-					    0x07, n);
-			snd_soc_write(codec, TAIKO_A_CDC_MBHC_FIR_B2_CFG,
-				      btn_det->c[n]);
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B2_CTL, 0x07,
-			    btn_det->nc);
-
-	n_cic = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_N_CIC);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_TIMER_B6_CTL, 0xFF,
-			    n_cic[taiko_codec_mclk_index(taiko)]);
-
-	gain = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_GAIN);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B2_CTL, 0x78,
-			    gain[taiko_codec_mclk_index(taiko)] << 3);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_TIMER_B4_CTL, 0x70,
-			    generic->mbhc_nsa << 4);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_TIMER_B4_CTL, 0x0F,
-			    btn_det->n_meas);
-
-	snd_soc_write(codec, TAIKO_A_CDC_MBHC_TIMER_B5_CTL, generic->mbhc_navg);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x80, 0x80);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x78,
-			    btn_det->mbhc_nsc << 3);
-
-	snd_soc_update_bits(codec, taiko->reg_addr.micb_4_mbhc, 0x03,
-			    TAIKO_MICBIAS2);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x02, 0x02);
-
-	snd_soc_update_bits(codec, TAIKO_A_MBHC_SCALING_MUX_2, 0xF0, 0xF0);
-}
-
-static bool taiko_mbhc_fw_validate(const struct firmware *fw)
-{
-	u32 cfg_offset;
-	struct taiko_mbhc_imped_detect_cfg *imped_cfg;
-	struct taiko_mbhc_btn_detect_cfg *btn_cfg;
-
-	if (fw->size < TAIKO_MBHC_CAL_MIN_SIZE)
-		return false;
-
-	/* previous check guarantees that there is enough fw data up
-	 * to num_btn
-	 */
-	btn_cfg = TAIKO_MBHC_CAL_BTN_DET_PTR(fw->data);
-	cfg_offset = (u32) ((void *) btn_cfg - (void *) fw->data);
-	if (fw->size < (cfg_offset + TAIKO_MBHC_CAL_BTN_SZ(btn_cfg)))
-		return false;
-
-	/* previous check guarantees that there is enough fw data up
-	 * to start of impedance detection configuration
-	 */
-	imped_cfg = TAIKO_MBHC_CAL_IMPED_DET_PTR(fw->data);
-	cfg_offset = (u32) ((void *) imped_cfg - (void *) fw->data);
-
-	if (fw->size < (cfg_offset + TAIKO_MBHC_CAL_IMPED_MIN_SZ))
-		return false;
-
-	if (fw->size < (cfg_offset + TAIKO_MBHC_CAL_IMPED_SZ(imped_cfg)))
-		return false;
-
-	return true;
-}
-
-/* called under codec_resource_lock acquisition */
-static int taiko_determine_button(const struct taiko_priv *priv,
-				  const s32 micmv)
-{
-	s16 *v_btn_low, *v_btn_high;
-	struct taiko_mbhc_btn_detect_cfg *btn_det;
-	int i, btn = -1;
-
-	btn_det = TAIKO_MBHC_CAL_BTN_DET_PTR(priv->mbhc_cfg.calibration);
-	v_btn_low = taiko_mbhc_cal_btn_det_mp(btn_det, TAIKO_BTN_DET_V_BTN_LOW);
-	v_btn_high = taiko_mbhc_cal_btn_det_mp(btn_det,
-				TAIKO_BTN_DET_V_BTN_HIGH);
-
-	for (i = 0; i < btn_det->num_btn; i++) {
-		if ((v_btn_low[i] <= micmv) && (v_btn_high[i] >= micmv)) {
-			btn = i;
-			break;
-		}
-	}
-
-	if (btn == -1)
-		pr_debug("%s: couldn't find button number for mic mv %d\n",
-			 __func__, micmv);
-
-	return btn;
-}
-
-static int taiko_get_button_mask(const int btn)
-{
-	int mask = 0;
-	switch (btn) {
-	case 0:
-		mask = SND_JACK_BTN_0;
-		break;
-	case 1:
-		mask = SND_JACK_BTN_1;
-		break;
-	case 2:
-		mask = SND_JACK_BTN_2;
-		break;
-	case 3:
-		mask = SND_JACK_BTN_3;
-		break;
-	case 4:
-		mask = SND_JACK_BTN_4;
-		break;
-	case 5:
-		mask = SND_JACK_BTN_5;
-		break;
-	case 6:
-		mask = SND_JACK_BTN_6;
-		break;
-	case 7:
-		mask = SND_JACK_BTN_7;
-		break;
-	}
-	return mask;
-}
-
-static irqreturn_t taiko_dce_handler(int irq, void *data)
-{
-	int i, mask;
-	short dce, sta;
-	s32 mv, mv_s, stamv_s;
-	bool vddio;
-	int btn = -1, meas = 0;
-	struct taiko_priv *priv = data;
-	const struct taiko_mbhc_btn_detect_cfg *d =
-	    TAIKO_MBHC_CAL_BTN_DET_PTR(priv->mbhc_cfg.calibration);
-	short btnmeas[d->n_btn_meas + 1];
-	struct snd_soc_codec *codec = priv->codec;
-	struct wcd9xxx *core = dev_get_drvdata(priv->codec->dev->parent);
-	int n_btn_meas = d->n_btn_meas;
-	u8 mbhc_status = snd_soc_read(codec, TAIKO_A_CDC_MBHC_B1_STATUS) & 0x3E;
-
-	pr_debug("%s: enter\n", __func__);
-
-	TAIKO_ACQUIRE_LOCK(priv->codec_resource_lock);
-	if (priv->mbhc_state == MBHC_STATE_POTENTIAL_RECOVERY) {
-		pr_debug("%s: mbhc is being recovered, skip button press\n",
-			 __func__);
-		goto done;
-	}
-
-	priv->mbhc_state = MBHC_STATE_POTENTIAL;
-
-	if (!priv->mbhc_polling_active) {
-		pr_warn("%s: mbhc polling is not active, skip button press\n",
-			__func__);
-		goto done;
-	}
-
-	dce = taiko_codec_read_dce_result(codec);
-	mv = taiko_codec_sta_dce_v(codec, 1, dce);
-
-	/* If GPIO interrupt already kicked in, ignore button press */
-	if (priv->in_gpio_handler) {
-		pr_debug("%s: GPIO State Changed, ignore button press\n",
-			 __func__);
-		btn = -1;
-		goto done;
-	}
-
-	vddio = (priv->mbhc_data.micb_mv != VDDIO_MICBIAS_MV &&
-		 priv->mbhc_micbias_switched);
-	mv_s = vddio ? taiko_scale_v_micb_vddio(priv, mv, false) : mv;
-
-	if (mbhc_status != TAIKO_MBHC_STATUS_REL_DETECTION) {
-		if (priv->mbhc_last_resume &&
-		    !time_after(jiffies, priv->mbhc_last_resume + HZ)) {
-			pr_debug("%s: Button is already released shortly after resume\n",
-				__func__);
-			n_btn_meas = 0;
-		} else {
-			pr_debug("%s: Button is already released without resume",
-				__func__);
-			sta = taiko_codec_read_sta_result(codec);
-			stamv_s = taiko_codec_sta_dce_v(codec, 0, sta);
-			if (vddio)
-				stamv_s = taiko_scale_v_micb_vddio(priv,
-								   stamv_s,
-								   false);
-			btn = taiko_determine_button(priv, mv_s);
-			if (btn != taiko_determine_button(priv, stamv_s))
-				btn = -1;
-			goto done;
-		}
-	}
-
-	/* determine pressed button */
-	btnmeas[meas++] = taiko_determine_button(priv, mv_s);
-	pr_debug("%s: meas %d - DCE %d,%d,%d button %d\n", __func__,
-		 meas - 1, dce, mv, mv_s, btnmeas[meas - 1]);
-	if (n_btn_meas == 0)
-		btn = btnmeas[0];
-	for (; ((d->n_btn_meas) && (meas < (d->n_btn_meas + 1))); meas++) {
-		dce = taiko_codec_sta_dce(codec, 1, false);
-		mv = taiko_codec_sta_dce_v(codec, 1, dce);
-		mv_s = vddio ? taiko_scale_v_micb_vddio(priv, mv, false) : mv;
-
-		btnmeas[meas] = taiko_determine_button(priv, mv_s);
-		pr_debug("%s: meas %d - DCE %d,%d,%d button %d\n",
-			 __func__, meas, dce, mv, mv_s, btnmeas[meas]);
-		/* if large enough measurements are collected,
-		 * start to check if last all n_btn_con measurements were
-		 * in same button low/high range */
-		if (meas + 1 >= d->n_btn_con) {
-			for (i = 0; i < d->n_btn_con; i++)
-				if ((btnmeas[meas] < 0) ||
-				    (btnmeas[meas] != btnmeas[meas - i]))
-					break;
-			if (i == d->n_btn_con) {
-				/* button pressed */
-				btn = btnmeas[meas];
-				break;
-			} else if ((n_btn_meas - meas) < (d->n_btn_con - 1)) {
-				/* if left measurements are less than n_btn_con,
-				 * it's impossible to find button number */
-				break;
-			}
-		}
-	}
-
-	if (btn >= 0) {
-		if (priv->in_gpio_handler) {
-			pr_debug(
-			"%s: GPIO already triggered, ignore button press\n",
-			__func__);
-			goto done;
-		}
-		mask = taiko_get_button_mask(btn);
-		priv->buttons_pressed |= mask;
-		wcd9xxx_lock_sleep(core);
-		if (schedule_delayed_work(&priv->mbhc_btn_dwork,
-					  msecs_to_jiffies(400)) == 0) {
-			WARN(1, "Button pressed twice without release event\n");
-			wcd9xxx_unlock_sleep(core);
-		}
-	} else {
-		pr_debug("%s: bogus button press, too short press?\n",
-			 __func__);
-	}
-
- done:
-	pr_debug("%s: leave\n", __func__);
-	TAIKO_RELEASE_LOCK(priv->codec_resource_lock);
-	return IRQ_HANDLED;
-}
-
-static int taiko_is_fake_press(struct taiko_priv *priv)
-{
-	int i;
-	int r = 0;
-	struct snd_soc_codec *codec = priv->codec;
-	const int dces = MBHC_NUM_DCE_PLUG_DETECT;
-	s16 mb_v, v_ins_hu, v_ins_h;
-
-	v_ins_hu = taiko_get_current_v_ins(priv, true);
-	v_ins_h = taiko_get_current_v_ins(priv, false);
-
-	for (i = 0; i < dces; i++) {
-		usleep_range(10000, 10000);
-		if (i == 0) {
-			mb_v = taiko_codec_sta_dce(codec, 0, true);
-			pr_debug("%s: STA[0]: %d,%d\n", __func__, mb_v,
-				 taiko_codec_sta_dce_v(codec, 0, mb_v));
-			if (mb_v < (s16)priv->mbhc_data.v_b1_hu ||
-			    mb_v > v_ins_hu) {
-				r = 1;
-				break;
-			}
-		} else {
-			mb_v = taiko_codec_sta_dce(codec, 1, true);
-			pr_debug("%s: DCE[%d]: %d,%d\n", __func__, i, mb_v,
-				 taiko_codec_sta_dce_v(codec, 1, mb_v));
-			if (mb_v < (s16)priv->mbhc_data.v_b1_h ||
-			    mb_v > v_ins_h) {
-				r = 1;
-				break;
-			}
-		}
-	}
-
-	return r;
-}
-
-static irqreturn_t taiko_release_handler(int irq, void *data)
-{
-	int ret;
-	struct taiko_priv *priv = data;
-	struct snd_soc_codec *codec = priv->codec;
-
-	pr_debug("%s: enter\n", __func__);
-
-	TAIKO_ACQUIRE_LOCK(priv->codec_resource_lock);
-	priv->mbhc_state = MBHC_STATE_RELEASE;
-
-	taiko_codec_drive_v_to_micbias(codec, 10000);
-
-	if (priv->buttons_pressed & TAIKO_JACK_BUTTON_MASK) {
-		ret = taiko_cancel_btn_work(priv);
-		if (ret == 0) {
-			pr_debug("%s: Reporting long button release event\n",
-				 __func__);
-			if (priv->mbhc_cfg.button_jack)
-				taiko_snd_soc_jack_report(priv,
-						  priv->mbhc_cfg.button_jack, 0,
-						  priv->buttons_pressed);
-		} else {
-			if (taiko_is_fake_press(priv)) {
-				pr_debug("%s: Fake button press interrupt\n",
-					 __func__);
-			} else if (priv->mbhc_cfg.button_jack) {
-				if (priv->in_gpio_handler) {
-					pr_debug("%s: GPIO kicked in, ignore\n",
-						 __func__);
-				} else {
-					pr_debug(
-					"%s: Reporting short button press and release\n",
-					 __func__);
-					taiko_snd_soc_jack_report(priv,
-						     priv->mbhc_cfg.button_jack,
-						     priv->buttons_pressed,
-						     priv->buttons_pressed);
-					taiko_snd_soc_jack_report(priv,
-						  priv->mbhc_cfg.button_jack, 0,
-						  priv->buttons_pressed);
-				}
-			}
-		}
-
-		priv->buttons_pressed &= ~TAIKO_JACK_BUTTON_MASK;
-	}
-
-	taiko_codec_calibrate_hs_polling(codec);
-
-	if (priv->mbhc_cfg.gpio)
-		msleep(TAIKO_MBHC_GPIO_REL_DEBOUNCE_TIME_MS);
-
-	taiko_codec_start_hs_polling(codec);
-
-	pr_debug("%s: leave\n", __func__);
-	TAIKO_RELEASE_LOCK(priv->codec_resource_lock);
-	return IRQ_HANDLED;
-}
-
-static void taiko_codec_shutdown_hs_removal_detect(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const struct taiko_mbhc_general_cfg *generic =
-	    TAIKO_MBHC_CAL_GENERAL_PTR(taiko->mbhc_cfg.calibration);
-
-	if (!taiko->mclk_enabled && !taiko->mbhc_polling_active)
-		taiko_codec_enable_config_mode(codec, 1);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0x2, 0x2);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x6, 0x0);
-
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg, 0x80, 0x00);
-
-	usleep_range(generic->t_shutdown_plug_rem,
-		     generic->t_shutdown_plug_rem);
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL, 0xA, 0x8);
-	if (!taiko->mclk_enabled && !taiko->mbhc_polling_active)
-		taiko_codec_enable_config_mode(codec, 0);
-
-	snd_soc_write(codec, TAIKO_A_MBHC_SCALING_MUX_1, 0x00);
-}
-
-static void taiko_codec_cleanup_hs_polling(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	taiko_codec_shutdown_hs_removal_detect(codec);
-
-	if (!taiko->mclk_enabled) {
-		taiko_codec_disable_clock_block(codec);
-		taiko_codec_enable_bandgap(codec, TAIKO_BANDGAP_OFF);
-	}
-
-	taiko->mbhc_polling_active = false;
-	taiko->mbhc_state = MBHC_STATE_NONE;
-}
-
-static irqreturn_t taiko_hphl_ocp_irq(int irq, void *data)
-{
-	struct taiko_priv *taiko = data;
-	struct snd_soc_codec *codec;
-
-	pr_info("%s: received HPHL OCP irq\n", __func__);
-
-	if (taiko) {
-		codec = taiko->codec;
-		if (taiko->hphlocp_cnt++ < TAIKO_OCP_ATTEMPT) {
-			pr_info("%s: retry\n", __func__);
-			snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10,
-					    0x00);
-			snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10,
-					    0x10);
-		} else {
-			wcd9xxx_disable_irq(codec->control_data,
-					  TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-			taiko->hphlocp_cnt = 0;
-			taiko->hph_status |= SND_JACK_OC_HPHL;
-			if (taiko->mbhc_cfg.headset_jack)
-				taiko_snd_soc_jack_report(taiko,
-						   taiko->mbhc_cfg.headset_jack,
-						   taiko->hph_status,
-						   TAIKO_JACK_MASK);
-		}
-	} else {
-		pr_err("%s: Bad taiko private data\n", __func__);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t taiko_hphr_ocp_irq(int irq, void *data)
-{
-	struct taiko_priv *taiko = data;
-	struct snd_soc_codec *codec;
-
-	pr_info("%s: received HPHR OCP irq\n", __func__);
-
-	if (taiko) {
-		codec = taiko->codec;
-		if (taiko->hphrocp_cnt++ < TAIKO_OCP_ATTEMPT) {
-			pr_info("%s: retry\n", __func__);
-			snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10,
-					    0x00);
-			snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10,
-					    0x10);
-		} else {
-			wcd9xxx_disable_irq(codec->control_data,
-					  TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-			taiko->hphrocp_cnt = 0;
-			taiko->hph_status |= SND_JACK_OC_HPHR;
-			if (taiko->mbhc_cfg.headset_jack)
-				taiko_snd_soc_jack_report(taiko,
-						   taiko->mbhc_cfg.headset_jack,
-						   taiko->hph_status,
-						   TAIKO_JACK_MASK);
-		}
-	} else {
-		pr_err("%s: Bad taiko private data\n", __func__);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static bool taiko_is_inval_ins_range(struct snd_soc_codec *codec,
-				     s32 mic_volt, bool highhph, bool *highv)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	bool invalid = false;
-	s16 v_hs_max;
-
-	/* Perform this check only when the high voltage headphone
-	 * needs to be considered as invalid
-	 */
-	v_hs_max = taiko_get_current_v_hs_max(taiko);
-	*highv = mic_volt > v_hs_max;
-	if (!highhph && *highv)
-		invalid = true;
-	else if (mic_volt < taiko->mbhc_data.v_inval_ins_high &&
-		 (mic_volt > taiko->mbhc_data.v_inval_ins_low))
-		invalid = true;
-
-	return invalid;
-}
-
-static bool taiko_is_inval_ins_delta(struct snd_soc_codec *codec,
-				     int mic_volt, int mic_volt_prev,
-				     int threshold)
-{
-	return abs(mic_volt - mic_volt_prev) > threshold;
-}
-
-/* called under codec_resource_lock acquisition */
-void taiko_find_plug_and_report(struct snd_soc_codec *codec,
-				enum taiko_mbhc_plug_type plug_type)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	if (plug_type == PLUG_TYPE_HEADPHONE &&
-	    taiko->current_plug == PLUG_TYPE_NONE) {
-		/* Nothing was reported previously
-		 * report a headphone or unsupported
-		 */
-		taiko_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
-		taiko_codec_cleanup_hs_polling(codec);
-	} else if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-		if (taiko->current_plug == PLUG_TYPE_HEADSET)
-			taiko_codec_report_plug(codec, 0, SND_JACK_HEADSET);
-		else if (taiko->current_plug == PLUG_TYPE_HEADPHONE)
-			taiko_codec_report_plug(codec, 0, SND_JACK_HEADPHONE);
-
-		taiko_codec_report_plug(codec, 1, SND_JACK_UNSUPPORTED);
-		taiko_codec_cleanup_hs_polling(codec);
-	} else if (plug_type == PLUG_TYPE_HEADSET) {
-		/* If Headphone was reported previously, this will
-		 * only report the mic line
-		 */
-		taiko_codec_report_plug(codec, 1, SND_JACK_HEADSET);
-		msleep(100);
-		taiko_codec_start_hs_polling(codec);
-	} else if (plug_type == PLUG_TYPE_HIGH_HPH) {
-		if (taiko->current_plug == PLUG_TYPE_NONE)
-			taiko_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
-		taiko_codec_cleanup_hs_polling(codec);
-		pr_debug("setup mic trigger for further detection\n");
-		taiko->lpi_enabled = true;
-		taiko_codec_enable_hs_detect(codec, 1,
-					     MBHC_USE_MB_TRIGGER |
-					     MBHC_USE_HPHL_TRIGGER,
-					     false);
-	} else {
-		WARN(1, "Unexpected current plug_type %d, plug_type %d\n",
-		     taiko->current_plug, plug_type);
-	}
-}
-
-/* should be called under interrupt context that hold suspend */
-static void taiko_schedule_hs_detect_plug(struct taiko_priv *taiko)
-{
-	pr_debug("%s: scheduling taiko_hs_correct_gpio_plug\n", __func__);
-	taiko->hs_detect_work_stop = false;
-	wcd9xxx_lock_sleep(taiko->codec->control_data);
-	schedule_work(&taiko->hs_correct_plug_work);
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_cancel_hs_detect_plug(struct taiko_priv *taiko)
-{
-	pr_debug("%s: canceling hs_correct_plug_work\n", __func__);
-	taiko->hs_detect_work_stop = true;
-	wmb();
-	TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-	if (cancel_work_sync(&taiko->hs_correct_plug_work)) {
-		pr_debug("%s: hs_correct_plug_work is canceled\n", __func__);
-		wcd9xxx_unlock_sleep(taiko->codec->control_data);
-	}
-	TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-}
-
-static bool taiko_hs_gpio_level_remove(struct taiko_priv *taiko)
-{
-	return (gpio_get_value_cansleep(taiko->mbhc_cfg.gpio) !=
-		taiko->mbhc_cfg.gpio_level_insert);
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_hphr_gnd_switch(struct snd_soc_codec *codec, bool on)
-{
-	snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x01, on);
-	if (on)
-		usleep_range(5000, 5000);
-}
-
-/* called under codec_resource_lock acquisition and mbhc override = 1 */
-static enum taiko_mbhc_plug_type
-taiko_codec_get_plug_type(struct snd_soc_codec *codec, bool highhph)
-{
-	int i;
-	bool gndswitch, vddioswitch;
-	int scaled;
-	struct taiko_mbhc_plug_type_cfg *plug_type_ptr;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const bool vddio = (taiko->mbhc_data.micb_mv != VDDIO_MICBIAS_MV);
-	int num_det = (MBHC_NUM_DCE_PLUG_DETECT + vddio);
-	enum taiko_mbhc_plug_type plug_type[num_det];
-	s16 mb_v[num_det];
-	s32 mic_mv[num_det];
-	bool inval;
-	bool highdelta;
-	bool ahighv = false, highv;
-
-	/* make sure override is on */
-	WARN_ON(!(snd_soc_read(codec, TAIKO_A_CDC_MBHC_B1_CTL) & 0x04));
-
-	/* GND and MIC swap detection requires at least 2 rounds of DCE */
-	BUG_ON(num_det < 2);
-
-	plug_type_ptr =
-	    TAIKO_MBHC_CAL_PLUG_TYPE_PTR(taiko->mbhc_cfg.calibration);
-
-	plug_type[0] = PLUG_TYPE_INVALID;
-
-	/* performs DCEs for N times
-	 * 1st: check if voltage is in invalid range
-	 * 2nd - N-2nd: check voltage range and delta
-	 * N-1st: check voltage range, delta with HPHR GND switch
-	 * Nth: check voltage range with VDDIO switch if micbias V != vddio V*/
-	for (i = 0; i < num_det; i++) {
-		gndswitch = (i == (num_det - 1 - vddio));
-		vddioswitch = (vddio && ((i == num_det - 1) ||
-					 (i == num_det - 2)));
-		if (i == 0) {
-			mb_v[i] = taiko_codec_setup_hs_polling(codec);
-			mic_mv[i] = taiko_codec_sta_dce_v(codec, 1 , mb_v[i]);
-			inval = taiko_is_inval_ins_range(codec, mic_mv[i],
-							 highhph, &highv);
-			ahighv |= highv;
-			scaled = mic_mv[i];
-		} else {
-			if (vddioswitch)
-				__taiko_codec_switch_micbias(taiko->codec, 1,
-							     false, false);
-			if (gndswitch)
-				taiko_codec_hphr_gnd_switch(codec, true);
-			mb_v[i] = __taiko_codec_sta_dce(codec, 1, true, true);
-			mic_mv[i] = taiko_codec_sta_dce_v(codec, 1 , mb_v[i]);
-			if (vddioswitch)
-				scaled = taiko_scale_v_micb_vddio(taiko,
-								  mic_mv[i],
-								  false);
-			else
-				scaled = mic_mv[i];
-			/* !gndswitch & vddioswitch means the previous DCE
-			 * was done with gndswitch, don't compare with DCE
-			 * with gndswitch */
-			highdelta = taiko_is_inval_ins_delta(codec, scaled,
-					mic_mv[i - !gndswitch - vddioswitch],
-					TAIKO_MBHC_FAKE_INS_DELTA_SCALED_MV);
-			inval = (taiko_is_inval_ins_range(codec, mic_mv[i],
-							  highhph, &highv) ||
-				 highdelta);
-			ahighv |= highv;
-			if (gndswitch)
-				taiko_codec_hphr_gnd_switch(codec, false);
-			if (vddioswitch)
-				__taiko_codec_switch_micbias(taiko->codec, 0,
-							     false, false);
-			/* claim UNSUPPORTED plug insertion when
-			 * good headset is detected but HPHR GND switch makes
-			 * delta difference */
-			if (i == (num_det - 2) && highdelta && !ahighv)
-				plug_type[0] = PLUG_TYPE_GND_MIC_SWAP;
-			else if (i == (num_det - 1) && inval)
-				plug_type[0] = PLUG_TYPE_INVALID;
-		}
-		pr_debug("%s: DCE #%d, %04x, V %d, scaled V %d, GND %d, VDDIO %d, inval %d\n",
-			__func__, i + 1, mb_v[i] & 0xffff, mic_mv[i], scaled,
-			gndswitch, vddioswitch, inval);
-		/* don't need to run further DCEs */
-		if (ahighv && inval)
-			break;
-		mic_mv[i] = scaled;
-	}
-
-	for (i = 0; (plug_type[0] != PLUG_TYPE_GND_MIC_SWAP && !inval) &&
-		     i < num_det; i++) {
-		/*
-		 * If we are here, means none of the all
-		 * measurements are fake, continue plug type detection.
-		 * If all three measurements do not produce same
-		 * plug type, restart insertion detection
-		 */
-		if (mic_mv[i] < plug_type_ptr->v_no_mic) {
-			plug_type[i] = PLUG_TYPE_HEADPHONE;
-			pr_debug("%s: Detect attempt %d, detected Headphone\n",
-				 __func__, i);
-		} else if (highhph && (mic_mv[i] > plug_type_ptr->v_hs_max)) {
-			plug_type[i] = PLUG_TYPE_HIGH_HPH;
-			pr_debug(
-			"%s: Detect attempt %d, detected High Headphone\n",
-			__func__, i);
-		} else {
-			plug_type[i] = PLUG_TYPE_HEADSET;
-			pr_debug("%s: Detect attempt %d, detected Headset\n",
-				 __func__, i);
-		}
-
-		if (i > 0 && (plug_type[i - 1] != plug_type[i])) {
-			pr_err("%s: Detect attempt %d and %d are not same",
-			       __func__, i - 1, i);
-			plug_type[0] = PLUG_TYPE_INVALID;
-			inval = true;
-			break;
-		}
-	}
-
-	pr_debug("%s: Detected plug type %d\n", __func__, plug_type[0]);
-	return plug_type[0];
-}
-
-static void taiko_hs_correct_gpio_plug(struct work_struct *work)
-{
-	struct taiko_priv *taiko;
-	struct snd_soc_codec *codec;
-	int retry = 0, pt_gnd_mic_swap_cnt = 0;
-	bool correction = false;
-	enum taiko_mbhc_plug_type plug_type;
-	unsigned long timeout;
-
-	taiko = container_of(work, struct taiko_priv, hs_correct_plug_work);
-	codec = taiko->codec;
-
-	pr_debug("%s: enter\n", __func__);
-	taiko->mbhc_cfg.mclk_cb_fn(codec, 1, false);
-
-	/* Keep override on during entire plug type correction work.
-	 *
-	 * This is okay under the assumption that any GPIO irqs which use
-	 * MBHC block cancel and sync this work so override is off again
-	 * prior to GPIO interrupt handler's MBHC block usage.
-	 * Also while this correction work is running, we can guarantee
-	 * DAPM doesn't use any MBHC block as this work only runs with
-	 * headphone detection.
-	 */
-	taiko_turn_onoff_override(codec, true);
-
-	timeout = jiffies + msecs_to_jiffies(TAIKO_HS_DETECT_PLUG_TIME_MS);
-	while (!time_after(jiffies, timeout)) {
-		++retry;
-		rmb();
-		if (taiko->hs_detect_work_stop) {
-			pr_debug("%s: stop requested\n", __func__);
-			break;
-		}
-
-		msleep(TAIKO_HS_DETECT_PLUG_INERVAL_MS);
-		if (taiko_hs_gpio_level_remove(taiko)) {
-			pr_debug("%s: GPIO value is low\n", __func__);
-			break;
-		}
-
-		/* can race with removal interrupt */
-		TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-		plug_type = taiko_codec_get_plug_type(codec, true);
-		TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-
-		if (plug_type == PLUG_TYPE_INVALID) {
-			pr_debug("Invalid plug in attempt # %d\n", retry);
-			if (retry == NUM_ATTEMPTS_TO_REPORT &&
-			    taiko->current_plug == PLUG_TYPE_NONE) {
-				taiko_codec_report_plug(codec, 1,
-							SND_JACK_HEADPHONE);
-			}
-		} else if (plug_type == PLUG_TYPE_HEADPHONE) {
-			pr_debug("Good headphone detected, continue polling mic\n");
-			if (taiko->current_plug == PLUG_TYPE_NONE)
-				taiko_codec_report_plug(codec, 1,
-							SND_JACK_HEADPHONE);
-		} else {
-			if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-				pt_gnd_mic_swap_cnt++;
-				if (pt_gnd_mic_swap_cnt <
-				    TAIKO_MBHC_GND_MIC_SWAP_THRESHOLD)
-					continue;
-				else if (pt_gnd_mic_swap_cnt >
-					 TAIKO_MBHC_GND_MIC_SWAP_THRESHOLD) {
-					/* This is due to GND/MIC switch didn't
-					 * work,  Report unsupported plug */
-				} else if (taiko->mbhc_cfg.swap_gnd_mic) {
-					/* if switch is toggled, check again,
-					 * otherwise report unsupported plug */
-					if (taiko->mbhc_cfg.swap_gnd_mic(codec))
-						continue;
-				}
-			} else
-				pt_gnd_mic_swap_cnt = 0;
-
-			TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-			/* Turn off override */
-			taiko_turn_onoff_override(codec, false);
-			/* The valid plug also includes PLUG_TYPE_GND_MIC_SWAP
-			 */
-			taiko_find_plug_and_report(codec, plug_type);
-			TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-			pr_debug("Attempt %d found correct plug %d\n", retry,
-				 plug_type);
-			correction = true;
-			break;
-		}
-	}
-
-	/* Turn off override */
-	if (!correction)
-		taiko_turn_onoff_override(codec, false);
-
-	taiko->mbhc_cfg.mclk_cb_fn(codec, 0, false);
-	pr_debug("%s: leave\n", __func__);
-	/* unlock sleep */
-	wcd9xxx_unlock_sleep(taiko->codec->control_data);
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_decide_gpio_plug(struct snd_soc_codec *codec)
-{
-	enum taiko_mbhc_plug_type plug_type;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: enter\n", __func__);
-
-	taiko_turn_onoff_override(codec, true);
-	plug_type = taiko_codec_get_plug_type(codec, true);
-	taiko_turn_onoff_override(codec, false);
-
-	if (taiko_hs_gpio_level_remove(taiko)) {
-		pr_debug("%s: GPIO value is low when determining plug\n",
-			 __func__);
-		return;
-	}
-
-	if (plug_type == PLUG_TYPE_INVALID ||
-	    plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-		taiko_schedule_hs_detect_plug(taiko);
-	} else if (plug_type == PLUG_TYPE_HEADPHONE) {
-		taiko_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
-
-		taiko_schedule_hs_detect_plug(taiko);
-	} else {
-		pr_debug("%s: Valid plug found, determine plug type %d\n",
-			 __func__, plug_type);
-		taiko_find_plug_and_report(codec, plug_type);
-	}
-}
-
-/* called under codec_resource_lock acquisition */
-static void taiko_codec_detect_plug_type(struct snd_soc_codec *codec)
-{
-	enum taiko_mbhc_plug_type plug_type;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const struct taiko_mbhc_plug_detect_cfg *plug_det =
-	    TAIKO_MBHC_CAL_PLUG_DET_PTR(taiko->mbhc_cfg.calibration);
-
-	/* Turn on the override,
-	 * taiko_codec_setup_hs_polling requires override on */
-	taiko_turn_onoff_override(codec, true);
-
-	if (plug_det->t_ins_complete > 20)
-		msleep(plug_det->t_ins_complete);
-	else
-		usleep_range(plug_det->t_ins_complete * 1000,
-			     plug_det->t_ins_complete * 1000);
-
-	if (taiko->mbhc_cfg.gpio) {
-		/* Turn off the override */
-		taiko_turn_onoff_override(codec, false);
-		if (taiko_hs_gpio_level_remove(taiko))
-			pr_debug(
-			"%s: GPIO value is low when determining plug\n",
-			__func__);
-		else
-			taiko_codec_decide_gpio_plug(codec);
-		return;
-	}
-
-	plug_type = taiko_codec_get_plug_type(codec, false);
-	taiko_turn_onoff_override(codec, false);
-
-	if (plug_type == PLUG_TYPE_INVALID) {
-		pr_debug("%s: Invalid plug type detected\n", __func__);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_B1_CTL, 0x02, 0x02);
-		taiko_codec_cleanup_hs_polling(codec);
-		taiko_codec_enable_hs_detect(codec, 1,
-					     MBHC_USE_MB_TRIGGER |
-					     MBHC_USE_HPHL_TRIGGER, false);
-	} else if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
-		pr_debug("%s: GND-MIC swapped plug type detected\n", __func__);
-		taiko_codec_report_plug(codec, 1, SND_JACK_UNSUPPORTED);
-		taiko_codec_cleanup_hs_polling(codec);
-		taiko_codec_enable_hs_detect(codec, 0, 0, false);
-	} else if (plug_type == PLUG_TYPE_HEADPHONE) {
-		pr_debug("%s: Headphone Detected\n", __func__);
-		taiko_codec_report_plug(codec, 1, SND_JACK_HEADPHONE);
-		taiko_codec_cleanup_hs_polling(codec);
-		taiko_codec_enable_hs_detect(codec, 0, 0, false);
-	} else if (plug_type == PLUG_TYPE_HEADSET) {
-		pr_debug("%s: Headset detected\n", __func__);
-		taiko_codec_report_plug(codec, 1, SND_JACK_HEADSET);
-
-		/* avoid false button press detect */
-		msleep(50);
-		taiko_codec_start_hs_polling(codec);
-	}
-}
-
-/* called only from interrupt which is under codec_resource_lock acquisition */
-static void taiko_hs_insert_irq_gpio(struct taiko_priv *priv, bool is_removal)
-{
-	struct snd_soc_codec *codec = priv->codec;
-
-	if (!is_removal) {
-		pr_debug("%s: MIC trigger insertion interrupt\n", __func__);
-
-		rmb();
-		if (priv->lpi_enabled)
-			msleep(100);
-
-		rmb();
-		if (!priv->lpi_enabled) {
-			pr_debug("%s: lpi is disabled\n", __func__);
-		} else if (gpio_get_value_cansleep(priv->mbhc_cfg.gpio) ==
-			   priv->mbhc_cfg.gpio_level_insert) {
-			pr_debug(
-			"%s: Valid insertion, detect plug type\n", __func__);
-			taiko_codec_decide_gpio_plug(codec);
-		} else {
-			pr_debug(
-			"%s: Invalid insertion stop plug detection\n",
-			__func__);
-		}
-	} else {
-		pr_err("%s: GPIO used, invalid MBHC Removal\n", __func__);
-	}
-}
-
-/* called only from interrupt which is under codec_resource_lock acquisition */
-static void taiko_hs_insert_irq_nogpio(struct taiko_priv *priv, bool is_removal,
-				       bool is_mb_trigger)
-{
-	int ret;
-	struct snd_soc_codec *codec = priv->codec;
-	struct wcd9xxx *core = dev_get_drvdata(priv->codec->dev->parent);
-
-	if (is_removal) {
-		/* cancel possiblely running hs detect work */
-		taiko_cancel_hs_detect_plug(priv);
-
-		/*
-		 * If headphone is removed while playback is in progress,
-		 * it is possible that micbias will be switched to VDDIO.
-		 */
-		taiko_codec_switch_micbias(codec, 0);
-		if (priv->current_plug == PLUG_TYPE_HEADPHONE)
-			taiko_codec_report_plug(codec, 0, SND_JACK_HEADPHONE);
-		else if (priv->current_plug == PLUG_TYPE_GND_MIC_SWAP)
-			taiko_codec_report_plug(codec, 0, SND_JACK_UNSUPPORTED);
-		else
-			WARN(1, "%s: Unexpected current plug type %d\n",
-			     __func__, priv->current_plug);
-		taiko_codec_shutdown_hs_removal_detect(codec);
-		taiko_codec_enable_hs_detect(codec, 1,
-					     MBHC_USE_MB_TRIGGER |
-					     MBHC_USE_HPHL_TRIGGER,
-					     true);
-	} else if (is_mb_trigger && !is_removal) {
-		pr_debug("%s: Waiting for Headphone left trigger\n",
-			__func__);
-		wcd9xxx_lock_sleep(core);
-		if (schedule_delayed_work(&priv->mbhc_insert_dwork,
-					  usecs_to_jiffies(1000000)) == 0) {
-			pr_err("%s: mbhc_insert_dwork is already scheduled\n",
-			       __func__);
-			wcd9xxx_unlock_sleep(core);
-		}
-		taiko_codec_enable_hs_detect(codec, 1, MBHC_USE_HPHL_TRIGGER,
-					     false);
-	} else  {
-		ret = cancel_delayed_work(&priv->mbhc_insert_dwork);
-		if (ret != 0) {
-			pr_debug(
-			"%s: Complete plug insertion, Detecting plug type\n",
-			__func__);
-			taiko_codec_detect_plug_type(codec);
-			wcd9xxx_unlock_sleep(core);
-		} else {
-			wcd9xxx_enable_irq(codec->control_data,
-					   TAIKO_IRQ_MBHC_INSERTION);
-			pr_err("%s: Error detecting plug insertion\n",
-			       __func__);
-		}
-	}
-}
-
-static irqreturn_t taiko_hs_insert_irq(int irq, void *data)
-{
-	bool is_mb_trigger, is_removal;
-	struct taiko_priv *priv = data;
-	struct snd_soc_codec *codec = priv->codec;
-
-	pr_debug("%s: enter\n", __func__);
-	TAIKO_ACQUIRE_LOCK(priv->codec_resource_lock);
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION);
-
-	is_mb_trigger = !!(snd_soc_read(codec, priv->mbhc_bias_regs.mbhc_reg) &
-					0x10);
-	is_removal = !!(snd_soc_read(codec, TAIKO_A_CDC_MBHC_INT_CTL) & 0x02);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_INT_CTL, 0x03, 0x00);
-
-	/* Turn off both HPH and MIC line schmitt triggers */
-	snd_soc_update_bits(codec, priv->mbhc_bias_regs.mbhc_reg, 0x90, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x13, 0x00);
-	snd_soc_update_bits(codec, priv->mbhc_bias_regs.ctl_reg, 0x01, 0x00);
-
-	if (priv->mbhc_cfg.gpio)
-		taiko_hs_insert_irq_gpio(priv, is_removal);
-	else
-		taiko_hs_insert_irq_nogpio(priv, is_removal, is_mb_trigger);
-
-	TAIKO_RELEASE_LOCK(priv->codec_resource_lock);
-	return IRQ_HANDLED;
-}
-
-static bool is_valid_mic_voltage(struct snd_soc_codec *codec, s32 mic_mv)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const struct taiko_mbhc_plug_type_cfg *plug_type =
-	    TAIKO_MBHC_CAL_PLUG_TYPE_PTR(taiko->mbhc_cfg.calibration);
-	const s16 v_hs_max = taiko_get_current_v_hs_max(taiko);
-
-	return (!(mic_mv > 10 && mic_mv < 80) && (mic_mv > plug_type->v_no_mic)
-		&& (mic_mv < v_hs_max)) ? true : false;
-}
-
-/* called under codec_resource_lock acquisition
- * returns true if mic voltage range is back to normal insertion
- * returns false either if timedout or removed */
-static bool taiko_hs_remove_settle(struct snd_soc_codec *codec)
-{
-	int i;
-	bool timedout, settled = false;
-	s32 mic_mv[MBHC_NUM_DCE_PLUG_DETECT];
-	short mb_v[MBHC_NUM_DCE_PLUG_DETECT];
-	unsigned long retry = 0, timeout;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const s16 v_hs_max = taiko_get_current_v_hs_max(taiko);
-
-	timeout = jiffies + msecs_to_jiffies(TAIKO_HS_DETECT_PLUG_TIME_MS);
-	while (!(timedout = time_after(jiffies, timeout))) {
-		retry++;
-		if (taiko->mbhc_cfg.gpio && taiko_hs_gpio_level_remove(taiko)) {
-			pr_debug("%s: GPIO indicates removal\n", __func__);
-			break;
-		}
-
-		if (taiko->mbhc_cfg.gpio) {
-			if (retry > 1)
-				msleep(250);
-			else
-				msleep(50);
-		}
-
-		if (taiko->mbhc_cfg.gpio && taiko_hs_gpio_level_remove(taiko)) {
-			pr_debug("%s: GPIO indicates removal\n", __func__);
-			break;
-		}
-
-		for (i = 0; i < MBHC_NUM_DCE_PLUG_DETECT; i++) {
-			mb_v[i] = taiko_codec_sta_dce(codec, 1,  true);
-			mic_mv[i] = taiko_codec_sta_dce_v(codec, 1 , mb_v[i]);
-			pr_debug("%s : DCE run %lu, mic_mv = %d(%x)\n",
-				 __func__, retry, mic_mv[i], mb_v[i]);
-		}
-
-		if (taiko->mbhc_cfg.gpio && taiko_hs_gpio_level_remove(taiko)) {
-			pr_debug("%s: GPIO indicates removal\n", __func__);
-			break;
-		}
-
-		if (taiko->current_plug == PLUG_TYPE_NONE) {
-			pr_debug("%s : headset/headphone is removed\n",
-				 __func__);
-			break;
-		}
-
-		for (i = 0; i < MBHC_NUM_DCE_PLUG_DETECT; i++)
-			if (!is_valid_mic_voltage(codec, mic_mv[i]))
-				break;
-
-		if (i == MBHC_NUM_DCE_PLUG_DETECT) {
-			pr_debug("%s: MIC voltage settled\n", __func__);
-			settled = true;
-			msleep(200);
-			break;
-		}
-
-		/* only for non-GPIO remove irq */
-		if (!taiko->mbhc_cfg.gpio) {
-			for (i = 0; i < MBHC_NUM_DCE_PLUG_DETECT; i++)
-				if (mic_mv[i] < v_hs_max)
-					break;
-			if (i == MBHC_NUM_DCE_PLUG_DETECT) {
-				pr_debug("%s: Headset is removed\n", __func__);
-				break;
-			}
-		}
-	}
-
-	if (timedout)
-		pr_debug("%s: Microphone did not settle in %d seconds\n",
-			 __func__, TAIKO_HS_DETECT_PLUG_TIME_MS);
-	return settled;
-}
-
-/* called only from interrupt which is under codec_resource_lock acquisition */
-static void taiko_hs_remove_irq_gpio(struct taiko_priv *priv)
-{
-	struct snd_soc_codec *codec = priv->codec;
-
-	if (taiko_hs_remove_settle(codec))
-		taiko_codec_start_hs_polling(codec);
-	pr_debug("%s: remove settle done\n", __func__);
-}
-
-/* called only from interrupt which is under codec_resource_lock acquisition */
-static void taiko_hs_remove_irq_nogpio(struct taiko_priv *priv)
-{
-	short bias_value;
-	bool removed = true;
-	struct snd_soc_codec *codec = priv->codec;
-	const struct taiko_mbhc_general_cfg *generic =
-	    TAIKO_MBHC_CAL_GENERAL_PTR(priv->mbhc_cfg.calibration);
-	int min_us = TAIKO_FAKE_REMOVAL_MIN_PERIOD_MS * 1000;
-
-	if (priv->current_plug != PLUG_TYPE_HEADSET) {
-		pr_debug("%s(): Headset is not inserted, ignore removal\n",
-			 __func__);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL,
-				    0x08, 0x08);
-		return;
-	}
-
-	usleep_range(generic->t_shutdown_plug_rem,
-		     generic->t_shutdown_plug_rem);
-
-	do {
-		bias_value = taiko_codec_sta_dce(codec, 1,  true);
-		pr_debug("%s: DCE %d,%d, %d us left\n", __func__, bias_value,
-			 taiko_codec_sta_dce_v(codec, 1, bias_value), min_us);
-		if (bias_value < taiko_get_current_v_ins(priv, false)) {
-			pr_debug("%s: checking false removal\n", __func__);
-			msleep(500);
-			removed = !taiko_hs_remove_settle(codec);
-			pr_debug("%s: headset %sactually removed\n", __func__,
-				 removed ? "" : "not ");
-			break;
-		}
-		min_us -= priv->mbhc_data.t_dce;
-	} while (min_us > 0);
-
-	if (removed) {
-		/* cancel possiblely running hs detect work */
-		taiko_cancel_hs_detect_plug(priv);
-		/*
-		 * If this removal is not false, first check the micbias
-		 * switch status and switch it to LDOH if it is already
-		 * switched to VDDIO.
-		 */
-		taiko_codec_switch_micbias(codec, 0);
-
-		taiko_codec_report_plug(codec, 0, SND_JACK_HEADSET);
-		taiko_codec_cleanup_hs_polling(codec);
-		taiko_codec_enable_hs_detect(codec, 1,
-					     MBHC_USE_MB_TRIGGER |
-					     MBHC_USE_HPHL_TRIGGER,
-					     true);
-	} else {
-		taiko_codec_start_hs_polling(codec);
-	}
-}
-
-static irqreturn_t taiko_hs_remove_irq(int irq, void *data)
-{
-	struct taiko_priv *priv = data;
-	bool vddio;
-	pr_debug("%s: enter, removal interrupt\n", __func__);
-
-	TAIKO_ACQUIRE_LOCK(priv->codec_resource_lock);
-	vddio = (priv->mbhc_data.micb_mv != VDDIO_MICBIAS_MV &&
-		 priv->mbhc_micbias_switched);
-	if (vddio)
-		__taiko_codec_switch_micbias(priv->codec, 0, false, true);
-
-	if (priv->mbhc_cfg.gpio)
-		taiko_hs_remove_irq_gpio(priv);
-	else
-		taiko_hs_remove_irq_nogpio(priv);
-
-	/* if driver turned off vddio switch and headset is not removed,
-	 * turn on the vddio switch back, if headset is removed then vddio
-	 * switch is off by time now and shouldn't be turn on again from here */
-	if (vddio && priv->current_plug == PLUG_TYPE_HEADSET)
-		__taiko_codec_switch_micbias(priv->codec, 1, true, true);
-	TAIKO_RELEASE_LOCK(priv->codec_resource_lock);
-
-	return IRQ_HANDLED;
-}
-
-static void taiko_mbhc_insert_work(struct work_struct *work)
-{
-	struct delayed_work *dwork;
-	struct taiko_priv *taiko;
-	struct snd_soc_codec *codec;
-	struct wcd9xxx *taiko_core;
-
-	dwork = to_delayed_work(work);
-	taiko = container_of(dwork, struct taiko_priv, mbhc_insert_dwork);
-	codec = taiko->codec;
-	taiko_core = dev_get_drvdata(codec->dev->parent);
-
-	pr_debug("%s:\n", __func__);
-
-	/* Turn off both HPH and MIC line schmitt triggers */
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.mbhc_reg, 0x90, 0x00);
-	snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x13, 0x00);
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x01, 0x00);
-	wcd9xxx_disable_irq_sync(codec->control_data, TAIKO_IRQ_MBHC_INSERTION);
-	taiko_codec_detect_plug_type(codec);
-	wcd9xxx_unlock_sleep(taiko_core);
-}
-
-static void taiko_hs_gpio_handler(struct snd_soc_codec *codec)
-{
-	bool insert;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	bool is_removed = false;
-
-	pr_debug("%s: enter\n", __func__);
-
-	taiko->in_gpio_handler = true;
-	/* Wait here for debounce time */
-	usleep_range(TAIKO_GPIO_IRQ_DEBOUNCE_TIME_US,
-		     TAIKO_GPIO_IRQ_DEBOUNCE_TIME_US);
-
-	TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-
-	/* cancel pending button press */
-	if (taiko_cancel_btn_work(taiko))
-		pr_debug("%s: button press is canceled\n", __func__);
-
-	insert = (gpio_get_value_cansleep(taiko->mbhc_cfg.gpio) ==
-		  taiko->mbhc_cfg.gpio_level_insert);
-	if ((taiko->current_plug == PLUG_TYPE_NONE) && insert) {
-		taiko->lpi_enabled = false;
-		wmb();
-
-		/* cancel detect plug */
-		taiko_cancel_hs_detect_plug(taiko);
-
-		/* Disable Mic Bias pull down and HPH Switch to GND */
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg, 0x01,
-				    0x00);
-		snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x01, 0x00);
-		taiko_codec_detect_plug_type(codec);
-	} else if ((taiko->current_plug != PLUG_TYPE_NONE) && !insert) {
-		taiko->lpi_enabled = false;
-		wmb();
-
-		/* cancel detect plug */
-		taiko_cancel_hs_detect_plug(taiko);
-
-		if (taiko->current_plug == PLUG_TYPE_HEADPHONE) {
-			taiko_codec_report_plug(codec, 0, SND_JACK_HEADPHONE);
-			is_removed = true;
-		} else if (taiko->current_plug == PLUG_TYPE_GND_MIC_SWAP) {
-			taiko_codec_report_plug(codec, 0, SND_JACK_UNSUPPORTED);
-			is_removed = true;
-		} else if (taiko->current_plug == PLUG_TYPE_HEADSET) {
-			taiko_codec_pause_hs_polling(codec);
-			taiko_codec_cleanup_hs_polling(codec);
-			taiko_codec_report_plug(codec, 0, SND_JACK_HEADSET);
-			is_removed = true;
-		}
-
-		if (is_removed) {
-			/* Enable Mic Bias pull down and HPH Switch to GND */
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.ctl_reg, 0x01,
-					    0x01);
-			snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x01,
-					    0x01);
-			/* Make sure mic trigger is turned off */
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.ctl_reg,
-					    0x01, 0x01);
-			snd_soc_update_bits(codec,
-					    taiko->mbhc_bias_regs.mbhc_reg,
-					    0x90, 0x00);
-			/* Reset MBHC State Machine */
-			snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL,
-					    0x08, 0x08);
-			snd_soc_update_bits(codec, TAIKO_A_CDC_MBHC_CLK_CTL,
-					    0x08, 0x00);
-			/* Turn off override */
-			taiko_turn_onoff_override(codec, false);
-		}
-	}
-
-	taiko->in_gpio_handler = false;
-	TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-	pr_debug("%s: leave\n", __func__);
-}
-
-static irqreturn_t taiko_mechanical_plug_detect_irq(int irq, void *data)
-{
-	int r = IRQ_HANDLED;
-	struct snd_soc_codec *codec = data;
-
-	if (unlikely(wcd9xxx_lock_sleep(codec->control_data) == false)) {
-		pr_warn("%s: failed to hold suspend\n", __func__);
-		r = IRQ_NONE;
-	} else {
-		taiko_hs_gpio_handler(codec);
-		wcd9xxx_unlock_sleep(codec->control_data);
-	}
-
-	return r;
-}
-
-static int taiko_mbhc_init_and_calibrate(struct taiko_priv *taiko)
-{
-	int ret = 0;
-	struct snd_soc_codec *codec = taiko->codec;
-
-	taiko->mbhc_cfg.mclk_cb_fn(codec, 1, false);
-	taiko_mbhc_init(codec);
-	taiko_mbhc_cal(codec);
-	taiko_mbhc_calc_thres(codec);
-	taiko->mbhc_cfg.mclk_cb_fn(codec, 0, false);
-	taiko_codec_calibrate_hs_polling(codec);
-	if (!taiko->mbhc_cfg.gpio) {
-		ret = taiko_codec_enable_hs_detect(codec, 1,
-						   MBHC_USE_MB_TRIGGER |
-						   MBHC_USE_HPHL_TRIGGER,
-						   false);
-
-		if (IS_ERR_VALUE(ret))
-			pr_err("%s: Failed to setup MBHC detection\n",
-			       __func__);
-	} else {
-		/* Enable Mic Bias pull down and HPH Switch to GND */
-		snd_soc_update_bits(codec, taiko->mbhc_bias_regs.ctl_reg,
-				    0x01, 0x01);
-		snd_soc_update_bits(codec, TAIKO_A_MBHC_HPH, 0x01, 0x01);
-		INIT_WORK(&taiko->hs_correct_plug_work,
-			  taiko_hs_correct_gpio_plug);
-	}
-
-	if (!IS_ERR_VALUE(ret)) {
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL, 0x10, 0x10);
-		wcd9xxx_enable_irq(codec->control_data,
-				 TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-		wcd9xxx_enable_irq(codec->control_data,
-				 TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-
-		if (taiko->mbhc_cfg.gpio) {
-			ret = request_threaded_irq(taiko->mbhc_cfg.gpio_irq,
-					       NULL,
-					       taiko_mechanical_plug_detect_irq,
-					       (IRQF_TRIGGER_RISING |
-						IRQF_TRIGGER_FALLING),
-					       "taiko-gpio", codec);
-			if (!IS_ERR_VALUE(ret)) {
-				ret = enable_irq_wake(taiko->mbhc_cfg.gpio_irq);
-				/* Bootup time detection */
-				taiko_hs_gpio_handler(codec);
-			}
-		}
-	}
-
-	return ret;
-}
-
-static void mbhc_fw_read(struct work_struct *work)
-{
-	struct delayed_work *dwork;
-	struct taiko_priv *taiko;
-	struct snd_soc_codec *codec;
-	const struct firmware *fw;
-	int ret = -1, retry = 0;
-
-	dwork = to_delayed_work(work);
-	taiko = container_of(dwork, struct taiko_priv, mbhc_firmware_dwork);
-	codec = taiko->codec;
-
-	while (retry < MBHC_FW_READ_ATTEMPTS) {
-		retry++;
-		pr_info("%s:Attempt %d to request MBHC firmware\n",
-			__func__, retry);
-		ret = request_firmware(&fw, "wcd9320/wcd9320_mbhc.bin",
-					codec->dev);
-
-		if (ret != 0) {
-			usleep_range(MBHC_FW_READ_TIMEOUT,
-				     MBHC_FW_READ_TIMEOUT);
-		} else {
-			pr_info("%s: MBHC Firmware read succesful\n", __func__);
-			break;
-		}
-	}
-
-	if (ret != 0) {
-		pr_err("%s: Cannot load MBHC firmware use default cal\n",
-			__func__);
-	} else if (taiko_mbhc_fw_validate(fw) == false) {
-		pr_err("%s: Invalid MBHC cal data size use default cal\n",
-			 __func__);
-		release_firmware(fw);
-	} else {
-		taiko->mbhc_cfg.calibration = (void *)fw->data;
-		taiko->mbhc_fw = fw;
-	}
-
-	(void) taiko_mbhc_init_and_calibrate(taiko);
-}
-
-int taiko_hs_detect(struct snd_soc_codec *codec,
-		    const struct taiko_mbhc_config *cfg)
-{
-	struct taiko_priv *taiko;
-	int rc = 0;
-
-	if (!codec) {
-		pr_err("%s: no codec\n", __func__);
-		return -EINVAL;
-	}
-
-	if (!cfg->calibration) {
-		pr_warn("%s: mbhc is not configured\n", __func__);
-		return 0;
-	}
-
-	if (cfg->mclk_rate != TAIKO_MCLK_RATE_12288KHZ) {
-		if (cfg->mclk_rate == TAIKO_MCLK_RATE_9600KHZ)
-			pr_err("Error: clock rate %dHz is not yet supported\n",
-			       cfg->mclk_rate);
-		else
-			pr_err("Error: unsupported clock rate %d\n",
-			       cfg->mclk_rate);
-		return -EINVAL;
-	}
-
-	taiko = snd_soc_codec_get_drvdata(codec);
-	taiko->mbhc_cfg = *cfg;
-	taiko->in_gpio_handler = false;
-	taiko->current_plug = PLUG_TYPE_NONE;
-	taiko->lpi_enabled = false;
-	taiko_get_mbhc_micbias_regs(codec, &taiko->mbhc_bias_regs);
-
-	/* Put CFILT in fast mode by default */
-	snd_soc_update_bits(codec, taiko->mbhc_bias_regs.cfilt_ctl,
-			    0x40, TAIKO_CFILT_FAST_MODE);
-	INIT_DELAYED_WORK(&taiko->mbhc_firmware_dwork, mbhc_fw_read);
-	INIT_DELAYED_WORK(&taiko->mbhc_btn_dwork, btn_lpress_fn);
-	INIT_WORK(&taiko->hphlocp_work, hphlocp_off_report);
-	INIT_WORK(&taiko->hphrocp_work, hphrocp_off_report);
-	INIT_DELAYED_WORK(&taiko->mbhc_insert_dwork, taiko_mbhc_insert_work);
-
-	if (!taiko->mbhc_cfg.read_fw_bin)
-		rc = taiko_mbhc_init_and_calibrate(taiko);
-	else
-		schedule_delayed_work(&taiko->mbhc_firmware_dwork,
-				      usecs_to_jiffies(MBHC_FW_READ_TIMEOUT));
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(taiko_hs_detect);
-
-static unsigned long slimbus_value;
-
-static irqreturn_t taiko_slimbus_irq(int irq, void *data)
-{
-	struct taiko_priv *priv = data;
-	struct snd_soc_codec *codec = priv->codec;
-	int i, j;
-	u8 val;
-
-	for (i = 0; i < WCD9XXX_SLIM_NUM_PORT_REG; i++) {
-		slimbus_value = wcd9xxx_interface_reg_read(codec->control_data,
-			TAIKO_SLIM_PGD_PORT_INT_STATUS0 + i);
-		for_each_set_bit(j, &slimbus_value, BITS_PER_BYTE) {
-			val = wcd9xxx_interface_reg_read(codec->control_data,
-				TAIKO_SLIM_PGD_PORT_INT_SOURCE0 + i*8 + j);
-			if (val & 0x1)
-				pr_err_ratelimited(
-				"overflow error on port %x, value %x\n",
-				i*8 + j, val);
-			if (val & 0x2)
-				pr_err_ratelimited(
-				"underflow error on port %x, value %x\n",
-				i*8 + j, val);
-		}
-		wcd9xxx_interface_reg_write(codec->control_data,
-			TAIKO_SLIM_PGD_PORT_INT_CLR0 + i, 0xFF);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static const struct taiko_reg_mask_val taiko_1_0_class_h_ear[] = {
-
-	/* CLASS-H EAR  IDLE_THRESHOLD Table */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_IDLE_EAR_THSD, 0x26),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_FCLKONLY_EAR_THSD, 0x2C),
-
-	/* CLASS-H EAR I_PA_FACT Table. */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_I_PA_FACT_EAR_L,	0xA9),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_I_PA_FACT_EAR_U, 0x07),
-
-	/* CLASS-H EAR Voltage Headroom , Voltage Min. */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_V_PA_HD_EAR, 0x0D),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_V_PA_MIN_EAR, 0x3A),
-
-	/* CLASS-H EAR K values --chnages from load. */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_ADDR, 0x08),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x1B),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x2D),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x36),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x37),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	/** end of Ear PA load 32 */
-};
-
-
-static const struct taiko_reg_mask_val taiko_1_0_class_h_hph[] = {
-
-	/* CLASS-H HPH  IDLE_THRESHOLD Table */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_IDLE_HPH_THSD, 0x13),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_FCLKONLY_HPH_THSD, 0x19),
-
-	/* CLASS-H HPH I_PA_FACT Table */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_I_PA_FACT_HPH_L,	0x9A),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_I_PA_FACT_HPH_U, 0x06),
-
-	/* CLASS-H HPH Voltage Headroom , Voltage Min */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_V_PA_HD_HPH, 0x0D),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_V_PA_MIN_HPH, 0x1D),
-
-	/* CLASS-H HPH K values --chnages from load .*/
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_ADDR, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0xAE),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x01),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x1C),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x25),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x27),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_K_DATA, 0x00),
-};
-
-static int taiko_config_ear_class_h(struct snd_soc_codec *codec, u32 ear_load)
-{
-	u32 i;
-
-	if (ear_load  != 32)
-		return -EINVAL;
-
-	for (i = 0; i < ARRAY_SIZE(taiko_1_0_class_h_ear); i++)
-		snd_soc_write(codec, taiko_1_0_class_h_ear[i].reg,
-				taiko_1_0_class_h_ear[i].val);
-	return 0;
-}
-
-static int taiko_config_hph_class_h(struct snd_soc_codec *codec, u32 hph_load)
-{
-	u32 i;
-	if (hph_load  != 16)
-		return -EINVAL;
-
-	for (i = 0; i < ARRAY_SIZE(taiko_1_0_class_h_hph); i++)
-		snd_soc_write(codec, taiko_1_0_class_h_hph[i].reg,
-				taiko_1_0_class_h_hph[i].val);
-	return 0;
-}
-
-static int taiko_handle_pdata(struct taiko_priv *taiko)
-{
-	struct snd_soc_codec *codec = taiko->codec;
-	struct wcd9xxx_pdata *pdata = taiko->pdata;
-	int k1, k2, k3, rc = 0;
-	u8 leg_mode, txfe_bypass, txfe_buff, flag;
-	u8 i = 0, j = 0;
-	u8 val_txfe = 0, value = 0;
-
-	if (!pdata) {
-		pr_err("%s: NULL pdata\n", __func__);
-		rc = -ENODEV;
-		goto done;
-	}
-
-	leg_mode = pdata->amic_settings.legacy_mode;
-	txfe_bypass = pdata->amic_settings.txfe_enable;
-	txfe_buff = pdata->amic_settings.txfe_buff;
-	flag = pdata->amic_settings.use_pdata;
-
-	/* Make sure settings are correct */
-	if ((pdata->micbias.ldoh_v > TAIKO_LDOH_2P85_V) ||
-	    (pdata->micbias.bias1_cfilt_sel > TAIKO_CFILT3_SEL) ||
-	    (pdata->micbias.bias2_cfilt_sel > TAIKO_CFILT3_SEL) ||
-	    (pdata->micbias.bias3_cfilt_sel > TAIKO_CFILT3_SEL) ||
-	    (pdata->micbias.bias4_cfilt_sel > TAIKO_CFILT3_SEL)) {
-		rc = -EINVAL;
-		goto done;
-	}
-
-	/* figure out k value */
-	k1 = taiko_find_k_value(pdata->micbias.ldoh_v,
-		pdata->micbias.cfilt1_mv);
-	k2 = taiko_find_k_value(pdata->micbias.ldoh_v,
-		pdata->micbias.cfilt2_mv);
-	k3 = taiko_find_k_value(pdata->micbias.ldoh_v,
-		pdata->micbias.cfilt3_mv);
-
-	if (IS_ERR_VALUE(k1) || IS_ERR_VALUE(k2) || IS_ERR_VALUE(k3)) {
-		rc = -EINVAL;
-		goto done;
-	}
-
-	/* Set voltage level and always use LDO */
-	snd_soc_update_bits(codec, TAIKO_A_LDO_H_MODE_1, 0x0C,
-		(pdata->micbias.ldoh_v << 2));
-
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_1_VAL, 0xFC,
-		(k1 << 2));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_2_VAL, 0xFC,
-		(k2 << 2));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_3_VAL, 0xFC,
-		(k3 << 2));
-
-	snd_soc_update_bits(codec, TAIKO_A_MICB_1_CTL, 0x60,
-		(pdata->micbias.bias1_cfilt_sel << 5));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_2_CTL, 0x60,
-		(pdata->micbias.bias2_cfilt_sel << 5));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_3_CTL, 0x60,
-		(pdata->micbias.bias3_cfilt_sel << 5));
-	snd_soc_update_bits(codec, taiko->reg_addr.micb_4_ctl, 0x60,
-			    (pdata->micbias.bias4_cfilt_sel << 5));
-
-	for (i = 0; i < 6; j++, i += 2) {
-		if (flag & (0x01 << i)) {
-			value = (leg_mode & (0x01 << i)) ? 0x10 : 0x00;
-			val_txfe = (txfe_bypass & (0x01 << i)) ? 0x20 : 0x00;
-			val_txfe = val_txfe |
-				((txfe_buff & (0x01 << i)) ? 0x10 : 0x00);
-			snd_soc_update_bits(codec, TAIKO_A_TX_1_2_EN + j * 10,
-				0x10, value);
-			snd_soc_update_bits(codec,
-				TAIKO_A_TX_1_2_TEST_EN + j * 10,
-				0x30, val_txfe);
-		}
-		if (flag & (0x01 << (i + 1))) {
-			value = (leg_mode & (0x01 << (i + 1))) ? 0x01 : 0x00;
-			val_txfe = (txfe_bypass &
-					(0x01 << (i + 1))) ? 0x02 : 0x00;
-			val_txfe |= (txfe_buff &
-					(0x01 << (i + 1))) ? 0x01 : 0x00;
-			snd_soc_update_bits(codec, TAIKO_A_TX_1_2_EN + j * 10,
-				0x01, value);
-			snd_soc_update_bits(codec,
-				TAIKO_A_TX_1_2_TEST_EN + j * 10,
-				0x03, val_txfe);
-		}
-	}
-	if (flag & 0x40) {
-		value = (leg_mode & 0x40) ? 0x10 : 0x00;
-		value = value | ((txfe_bypass & 0x40) ? 0x02 : 0x00);
-		value = value | ((txfe_buff & 0x40) ? 0x01 : 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_EN,
-			0x13, value);
-	}
-
-	if (pdata->ocp.use_pdata) {
-		/* not defined in CODEC specification */
-		if (pdata->ocp.hph_ocp_limit == 1 ||
-			pdata->ocp.hph_ocp_limit == 5) {
-			rc = -EINVAL;
-			goto done;
-		}
-		snd_soc_update_bits(codec, TAIKO_A_RX_COM_OCP_CTL,
-			0x0F, pdata->ocp.num_attempts);
-		snd_soc_write(codec, TAIKO_A_RX_COM_OCP_COUNT,
-			((pdata->ocp.run_time << 4) | pdata->ocp.wait_time));
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL,
-			0xE0, (pdata->ocp.hph_ocp_limit << 5));
-	}
-
-	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
-		if (!strncmp(pdata->regulator[i].name, "CDC_VDDA_RX", 11)) {
-			if (pdata->regulator[i].min_uV == 1800000 &&
-			    pdata->regulator[i].max_uV == 1800000) {
-				snd_soc_write(codec, TAIKO_A_BIAS_REF_CTL,
-					      0x1C);
-			} else if (pdata->regulator[i].min_uV == 2200000 &&
-				   pdata->regulator[i].max_uV == 2200000) {
-				snd_soc_write(codec, TAIKO_A_BIAS_REF_CTL,
-					      0x1E);
-			} else {
-				pr_err("%s: unsupported CDC_VDDA_RX voltage\n"
-				       "min %d, max %d\n", __func__,
-				       pdata->regulator[i].min_uV,
-				       pdata->regulator[i].max_uV);
-				rc = -EINVAL;
-			}
-			break;
-		}
-	}
-
-	taiko_config_ear_class_h(codec, 32);
-	taiko_config_hph_class_h(codec, 16);
-
-done:
-	return rc;
-}
-
-static const struct taiko_reg_mask_val taiko_1_0_reg_defaults[] = {
-
-	/* set MCLk to 9.6 */
-	TAIKO_REG_VAL(TAIKO_A_CHIP_CTL, 0x0A),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLK_POWER_CTL, 0x03),
-
-	/* EAR PA deafults  */
-	TAIKO_REG_VAL(TAIKO_A_RX_EAR_CMBUFF, 0x05),
-	/* HPH PA */
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_BIAS_PA, 0x7A),
-
-	/** BUCK and NCP defaults for EAR and HS */
-	TAIKO_REG_VAL(TAIKO_A_BUCK_CTRL_CCL_4, 0x50),
-	TAIKO_REG_VAL(TAIKO_A_BUCK_CTRL_VCL_1, 0x08),
-	TAIKO_REG_VAL(TAIKO_A_BUCK_CTRL_CCL_1, 0x5B),
-	TAIKO_REG_VAL(TAIKO_A_NCP_CLK, 0xFC),
-
-	/* CLASS-H defaults for EAR and HS */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_BUCK_NCP_VARS, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_BUCK_NCP_VARS, 0x04),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B2_CTL, 0x01),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B2_CTL, 0x05),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B2_CTL, 0x35),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B3_CTL, 0x30),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B3_CTL, 0x3B),
-
-	/*
-	 * For CLASS-H, Enable ANC delay buffer,
-	 * set HPHL and EAR PA ref gain to 0 DB.
-	 */
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLSH_B1_CTL, 0x26),
-
-
-	/* RX deafults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX1_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX2_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX3_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX4_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX5_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX6_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX7_B5_CTL, 0x78),
-
-	/* RX1 and RX2 defaults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX1_B6_CTL, 0xA0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX2_B6_CTL, 0xA0),
-
-	/* RX3 to RX7 defaults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX3_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX4_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX5_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX6_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX7_B6_CTL, 0x80),
-};
-
-static void taiko_update_reg_defaults(struct snd_soc_codec *codec)
-{
-	u32 i;
-
-	for (i = 0; i < ARRAY_SIZE(taiko_1_0_reg_defaults); i++)
-		snd_soc_write(codec, taiko_1_0_reg_defaults[i].reg,
-				taiko_1_0_reg_defaults[i].val);
-}
-
-static const struct taiko_reg_mask_val taiko_codec_reg_init_val[] = {
-	/* Initialize current threshold to 350MA
-	 * number of wait and run cycles to 4096
-	 */
-	{TAIKO_A_RX_HPH_OCP_CTL, 0xE0, 0x60},
-	{TAIKO_A_RX_COM_OCP_COUNT, 0xFF, 0xFF},
-
-	/* Initialize gain registers to use register gain */
-	{TAIKO_A_RX_HPH_L_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_HPH_R_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_1_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_2_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_3_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_4_GAIN, 0x20, 0x20},
-
-	/* CLASS H config */
-	{TAIKO_A_CDC_CONN_CLSH_CTL, 0x3C, 0x14},
-
-	/* Use 16 bit sample size for TX1 to TX6 */
-	{TAIKO_A_CDC_CONN_TX_SB_B1_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B2_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B3_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B4_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B5_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B6_CTL, 0x30, 0x20},
-
-	/* Use 16 bit sample size for TX7 to TX10 */
-	{TAIKO_A_CDC_CONN_TX_SB_B7_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B8_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B9_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B10_CTL, 0x60, 0x40},
-
-	/* Use 16 bit sample size for RX */
-	{TAIKO_A_CDC_CONN_RX_SB_B1_CTL, 0xFF, 0xAA},
-	{TAIKO_A_CDC_CONN_RX_SB_B2_CTL, 0xFF, 0xAA},
-
-	/*enable HPF filter for TX paths */
-	{TAIKO_A_CDC_TX1_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX2_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX3_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX4_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX5_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX6_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX7_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX8_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX9_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX10_MUX_CTL, 0x8, 0x0},
-
-	/* config Decimator for DMIC CLK_MODE_1(3.2Mhz@9.6Mhz mclk) */
-	{TAIKO_A_CDC_TX1_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX2_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX3_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX4_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX5_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX6_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX7_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX8_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX9_DMIC_CTL, 0x7, 0x1},
-	{TAIKO_A_CDC_TX10_DMIC_CTL, 0x7, 0x1},
-
-	/* config DMIC clk to CLK_MODE_1 (3.2Mhz@9.6Mhz mclk) */
-	{TAIKO_A_CDC_CLK_DMIC_B1_CTL, 0xEE, 0x22},
-	{TAIKO_A_CDC_CLK_DMIC_B2_CTL, 0x0E, 0x02},
-
-};
-
-static void taiko_codec_init_reg(struct snd_soc_codec *codec)
-{
-	u32 i;
-
-	for (i = 0; i < ARRAY_SIZE(taiko_codec_reg_init_val); i++)
-		snd_soc_update_bits(codec, taiko_codec_reg_init_val[i].reg,
-				taiko_codec_reg_init_val[i].mask,
-				taiko_codec_reg_init_val[i].val);
-}
-
-static void taiko_update_reg_address(struct taiko_priv *priv)
-{
-	struct taiko_reg_address *reg_addr = &priv->reg_addr;
-	reg_addr->micb_4_mbhc = TAIKO_A_MICB_4_MBHC;
-	reg_addr->micb_4_int_rbias = TAIKO_A_MICB_4_INT_RBIAS;
-	reg_addr->micb_4_ctl = TAIKO_A_MICB_4_CTL;
-
-}
-
-#ifdef CONFIG_DEBUG_FS
-static int codec_debug_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t codec_debug_write(struct file *filp,
-	const char __user *ubuf, size_t cnt, loff_t *ppos)
-{
-	char lbuf[32];
-	char *buf;
-	int rc;
-	struct taiko_priv *taiko = filp->private_data;
-
-	if (cnt > sizeof(lbuf) - 1)
-		return -EINVAL;
-
-	rc = copy_from_user(lbuf, ubuf, cnt);
-	if (rc)
-		return -EFAULT;
-
-	lbuf[cnt] = '\0';
-	buf = (char *)lbuf;
-	taiko->no_mic_headset_override = (*strsep(&buf, " ") == '0') ?
-					     false : true;
-	return rc;
-}
-
-static ssize_t codec_mbhc_debug_read(struct file *file, char __user *buf,
-				     size_t count, loff_t *pos)
-{
-	const int size = 768;
-	char buffer[size];
-	int n = 0;
-	struct taiko_priv *taiko = file->private_data;
-	struct snd_soc_codec *codec = taiko->codec;
-	const struct mbhc_internal_cal_data *p = &taiko->mbhc_data;
-	const s16 v_ins_hu_cur = taiko_get_current_v_ins(taiko, true);
-	const s16 v_ins_h_cur = taiko_get_current_v_ins(taiko, false);
-
-	n = scnprintf(buffer, size - n, "dce_z = %x(%dmv)\n",  p->dce_z,
-		     taiko_codec_sta_dce_v(codec, 1, p->dce_z));
-	n += scnprintf(buffer + n, size - n, "dce_mb = %x(%dmv)\n",
-		       p->dce_mb, taiko_codec_sta_dce_v(codec, 1, p->dce_mb));
-	n += scnprintf(buffer + n, size - n, "sta_z = %x(%dmv)\n",
-		       p->sta_z, taiko_codec_sta_dce_v(codec, 0, p->sta_z));
-	n += scnprintf(buffer + n, size - n, "sta_mb = %x(%dmv)\n",
-		       p->sta_mb, taiko_codec_sta_dce_v(codec, 0, p->sta_mb));
-	n += scnprintf(buffer + n, size - n, "t_dce = %x\n",  p->t_dce);
-	n += scnprintf(buffer + n, size - n, "t_sta = %x\n",  p->t_sta);
-	n += scnprintf(buffer + n, size - n, "micb_mv = %dmv\n",
-		       p->micb_mv);
-	n += scnprintf(buffer + n, size - n, "v_ins_hu = %x(%dmv)%s\n",
-		       p->v_ins_hu,
-		       taiko_codec_sta_dce_v(codec, 0, p->v_ins_hu),
-		       p->v_ins_hu == v_ins_hu_cur ? "*" : "");
-	n += scnprintf(buffer + n, size - n, "v_ins_h = %x(%dmv)%s\n",
-		       p->v_ins_h, taiko_codec_sta_dce_v(codec, 1, p->v_ins_h),
-		       p->v_ins_h == v_ins_h_cur ? "*" : "");
-	n += scnprintf(buffer + n, size - n, "adj_v_ins_hu = %x(%dmv)%s\n",
-		       p->adj_v_ins_hu,
-		       taiko_codec_sta_dce_v(codec, 0, p->adj_v_ins_hu),
-		       p->adj_v_ins_hu == v_ins_hu_cur ? "*" : "");
-	n += scnprintf(buffer + n, size - n, "adj_v_ins_h = %x(%dmv)%s\n",
-		       p->adj_v_ins_h,
-		       taiko_codec_sta_dce_v(codec, 1, p->adj_v_ins_h),
-		       p->adj_v_ins_h == v_ins_h_cur ? "*" : "");
-	n += scnprintf(buffer + n, size - n, "v_b1_hu = %x(%dmv)\n",
-		       p->v_b1_hu, taiko_codec_sta_dce_v(codec, 0, p->v_b1_hu));
-	n += scnprintf(buffer + n, size - n, "v_b1_h = %x(%dmv)\n",
-		       p->v_b1_h, taiko_codec_sta_dce_v(codec, 1, p->v_b1_h));
-	n += scnprintf(buffer + n, size - n, "v_b1_huc = %x(%dmv)\n",
-		       p->v_b1_huc,
-		       taiko_codec_sta_dce_v(codec, 1, p->v_b1_huc));
-	n += scnprintf(buffer + n, size - n, "v_brh = %x(%dmv)\n",
-		       p->v_brh, taiko_codec_sta_dce_v(codec, 1, p->v_brh));
-	n += scnprintf(buffer + n, size - n, "v_brl = %x(%dmv)\n",  p->v_brl,
-		       taiko_codec_sta_dce_v(codec, 0, p->v_brl));
-	n += scnprintf(buffer + n, size - n, "v_no_mic = %x(%dmv)\n",
-		       p->v_no_mic,
-		       taiko_codec_sta_dce_v(codec, 0, p->v_no_mic));
-	n += scnprintf(buffer + n, size - n, "npoll = %d\n",  p->npoll);
-	n += scnprintf(buffer + n, size - n, "nbounce_wait = %d\n",
-		       p->nbounce_wait);
-	n += scnprintf(buffer + n, size - n, "v_inval_ins_low = %d\n",
-		       p->v_inval_ins_low);
-	n += scnprintf(buffer + n, size - n, "v_inval_ins_high = %d\n",
-		       p->v_inval_ins_high);
-	if (taiko->mbhc_cfg.gpio)
-		n += scnprintf(buffer + n, size - n, "GPIO insert = %d\n",
-			       taiko_hs_gpio_level_remove(taiko));
-	buffer[n] = 0;
-
-	return simple_read_from_buffer(buf, count, pos, buffer, n);
-}
-
-static const struct file_operations codec_debug_ops = {
-	.open = codec_debug_open,
-	.write = codec_debug_write,
-};
-
-static const struct file_operations codec_mbhc_debug_ops = {
-	.open = codec_debug_open,
-	.read = codec_mbhc_debug_read,
-};
-#endif
-
-static int taiko_setup_irqs(struct taiko_priv *taiko)
-{
-	int ret;
-	int i;
-	struct snd_soc_codec *codec = taiko->codec;
-
-	ret = wcd9xxx_request_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION,
-				  taiko_hs_insert_irq, "Headset insert detect",
-				  taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_MBHC_INSERTION);
-		goto err_insert_irq;
-	}
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION);
-
-	ret = wcd9xxx_request_irq(codec->control_data, TAIKO_IRQ_MBHC_REMOVAL,
-				  taiko_hs_remove_irq, "Headset remove detect",
-				  taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_MBHC_REMOVAL);
-		goto err_remove_irq;
-	}
-
-	ret = wcd9xxx_request_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL,
-				  taiko_dce_handler, "DC Estimation detect",
-				  taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_MBHC_POTENTIAL);
-		goto err_potential_irq;
-	}
-
-	ret = wcd9xxx_request_irq(codec->control_data, TAIKO_IRQ_MBHC_RELEASE,
-				 taiko_release_handler, "Button Release detect",
-				 taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_MBHC_RELEASE);
-		goto err_release_irq;
-	}
-
-	ret = wcd9xxx_request_irq(codec->control_data, TAIKO_IRQ_SLIMBUS,
-				  taiko_slimbus_irq, "SLIMBUS Slave", taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_SLIMBUS);
-		goto err_slimbus_irq;
-	}
-
-	for (i = 0; i < WCD9XXX_SLIM_NUM_PORT_REG; i++)
-		wcd9xxx_interface_reg_write(codec->control_data,
-					   TAIKO_SLIM_PGD_PORT_INT_EN0 + i,
-					   0xFF);
-
-	ret = wcd9xxx_request_irq(codec->control_data,
-				  TAIKO_IRQ_HPH_PA_OCPL_FAULT,
-				  taiko_hphl_ocp_irq,
-				  "HPH_L OCP detect", taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-			TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-		goto err_hphl_ocp_irq;
-	}
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_HPH_PA_OCPL_FAULT);
-
-	ret = wcd9xxx_request_irq(codec->control_data,
-				  TAIKO_IRQ_HPH_PA_OCPR_FAULT,
-				  taiko_hphr_ocp_irq,
-				  "HPH_R OCP detect", taiko);
-	if (ret) {
-		pr_err("%s: Failed to request irq %d\n", __func__,
-		       TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-		goto err_hphr_ocp_irq;
-	}
-	wcd9xxx_disable_irq(codec->control_data, TAIKO_IRQ_HPH_PA_OCPR_FAULT);
-
-err_hphr_ocp_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_HPH_PA_OCPL_FAULT,
-			 taiko);
-err_hphl_ocp_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_SLIMBUS, taiko);
-err_slimbus_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_RELEASE, taiko);
-err_release_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL, taiko);
-err_potential_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_REMOVAL, taiko);
-err_remove_irq:
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION, taiko);
-err_insert_irq:
-
-	return ret;
-}
-
-static int taiko_codec_probe(struct snd_soc_codec *codec)
-{
-	struct wcd9xxx *control;
-	struct taiko_priv *taiko;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	int ret = 0;
-	int i;
-	int ch_cnt;
-
-	codec->control_data = dev_get_drvdata(codec->dev->parent);
-	control = codec->control_data;
-
-	dev_info(codec->dev, "%s()\n", __func__);
-
-	taiko = kzalloc(sizeof(struct taiko_priv), GFP_KERNEL);
-	if (!taiko) {
-		dev_err(codec->dev, "Failed to allocate private data\n");
-		return -ENOMEM;
-	}
-	for (i = 0 ; i < NUM_DECIMATORS; i++) {
-		tx_hpf_work[i].taiko = taiko;
-		tx_hpf_work[i].decimator = i + 1;
-		INIT_DELAYED_WORK(&tx_hpf_work[i].dwork,
-			tx_hpf_corner_freq_callback);
-	}
-
-	/* Make sure mbhc micbias register addresses are zeroed out */
-	memset(&taiko->mbhc_bias_regs, 0,
-		sizeof(struct mbhc_micbias_regs));
-	taiko->mbhc_micbias_switched = false;
-
-	/* Make sure mbhc intenal calibration data is zeroed out */
-	memset(&taiko->mbhc_data, 0,
-		sizeof(struct mbhc_internal_cal_data));
-	taiko->mbhc_data.t_sta_dce = DEFAULT_DCE_STA_WAIT;
-	taiko->mbhc_data.t_dce = DEFAULT_DCE_WAIT;
-	taiko->mbhc_data.t_sta = DEFAULT_STA_WAIT;
-	snd_soc_codec_set_drvdata(codec, taiko);
-
-	taiko->mclk_enabled = false;
-	taiko->bandgap_type = TAIKO_BANDGAP_OFF;
-	taiko->clock_active = false;
-	taiko->config_mode_active = false;
-	taiko->mbhc_polling_active = false;
-	taiko->mbhc_fake_ins_start = 0;
-	taiko->no_mic_headset_override = false;
-	taiko->hs_polling_irq_prepared = false;
-	mutex_init(&taiko->codec_resource_lock);
-	taiko->codec = codec;
-	taiko->mbhc_state = MBHC_STATE_NONE;
-	taiko->mbhc_last_resume = 0;
-	for (i = 0; i < COMPANDER_MAX; i++) {
-		taiko->comp_enabled[i] = 0;
-		taiko->comp_fs[i] = COMPANDER_FS_48KHZ;
-	}
-	taiko->pdata = dev_get_platdata(codec->dev->parent);
-	taiko->intf_type = wcd9xxx_get_intf_type();
-	taiko->aux_pga_cnt = 0;
-	taiko->aux_l_gain = 0x1F;
-	taiko->aux_r_gain = 0x1F;
-	taiko_update_reg_address(taiko);
-	taiko_update_reg_defaults(codec);
-	taiko_codec_init_reg(codec);
-	ret = taiko_handle_pdata(taiko);
-	if (IS_ERR_VALUE(ret)) {
-		pr_err("%s: bad pdata\n", __func__);
-		goto err_pdata;
-	}
-
-	if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-		snd_soc_dapm_new_controls(dapm, taiko_dapm_i2s_widgets,
-			ARRAY_SIZE(taiko_dapm_i2s_widgets));
-		snd_soc_dapm_add_routes(dapm, audio_i2s_map,
-			ARRAY_SIZE(audio_i2s_map));
-	}
-
-	snd_soc_dapm_sync(dapm);
-
-	(void) taiko_setup_irqs(taiko);
-
-	for (i = 0; i < ARRAY_SIZE(taiko_dai); i++) {
-		switch (taiko_dai[i].id) {
-		case AIF1_PB:
-			ch_cnt = taiko_dai[i].playback.channels_max;
-			break;
-		case AIF1_CAP:
-			ch_cnt = taiko_dai[i].capture.channels_max;
-			break;
-		case AIF2_PB:
-			ch_cnt = taiko_dai[i].playback.channels_max;
-			break;
-		case AIF2_CAP:
-			ch_cnt = taiko_dai[i].capture.channels_max;
-			break;
-		case AIF3_PB:
-			ch_cnt = taiko_dai[i].playback.channels_max;
-			break;
-		case AIF3_CAP:
-			ch_cnt = taiko_dai[i].capture.channels_max;
-			break;
-		default:
-			continue;
-		}
-		taiko->dai[i].ch_num = kzalloc((sizeof(unsigned int)*
-					ch_cnt), GFP_KERNEL);
-	}
-
-#ifdef CONFIG_DEBUG_FS
-	if (ret == 0) {
-		taiko->debugfs_poke =
-		    debugfs_create_file("TRRS", S_IFREG | S_IRUGO, NULL, taiko,
-					&codec_debug_ops);
-		taiko->debugfs_mbhc =
-		    debugfs_create_file("taiko_mbhc", S_IFREG | S_IRUGO,
-					NULL, taiko, &codec_mbhc_debug_ops);
-	}
-#endif
-	codec->ignore_pmdown_time = 1;
-	return ret;
-
-err_pdata:
-	mutex_destroy(&taiko->codec_resource_lock);
-	kfree(taiko);
-	return ret;
-}
-static int taiko_codec_remove(struct snd_soc_codec *codec)
-{
-	int i;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_SLIMBUS, taiko);
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_RELEASE, taiko);
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_POTENTIAL, taiko);
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_REMOVAL, taiko);
-	wcd9xxx_free_irq(codec->control_data, TAIKO_IRQ_MBHC_INSERTION, taiko);
-	TAIKO_ACQUIRE_LOCK(taiko->codec_resource_lock);
-	taiko_codec_disable_clock_block(codec);
-	TAIKO_RELEASE_LOCK(taiko->codec_resource_lock);
-	taiko_codec_enable_bandgap(codec, TAIKO_BANDGAP_OFF);
-	if (taiko->mbhc_fw)
-		release_firmware(taiko->mbhc_fw);
-	for (i = 0; i < ARRAY_SIZE(taiko_dai); i++)
-		kfree(taiko->dai[i].ch_num);
-	mutex_destroy(&taiko->codec_resource_lock);
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(taiko->debugfs_poke);
-	debugfs_remove(taiko->debugfs_mbhc);
-#endif
-	kfree(taiko);
-	return 0;
-}
-static struct snd_soc_codec_driver soc_codec_dev_taiko = {
-	.probe	= taiko_codec_probe,
-	.remove	= taiko_codec_remove,
-
-	.read = taiko_read,
-	.write = taiko_write,
-
-	.readable_register = taiko_readable,
-	.volatile_register = taiko_volatile,
-
-	.reg_cache_size = TAIKO_CACHE_SIZE,
-	.reg_cache_default = taiko_reg_defaults,
-	.reg_word_size = 1,
-
-	.controls = taiko_snd_controls,
-	.num_controls = ARRAY_SIZE(taiko_snd_controls),
-	.dapm_widgets = taiko_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(taiko_dapm_widgets),
-	.dapm_routes = audio_map,
-	.num_dapm_routes = ARRAY_SIZE(audio_map),
-};
-
-#ifdef CONFIG_PM
-static int taiko_suspend(struct device *dev)
-{
-	dev_dbg(dev, "%s: system suspend\n", __func__);
-	return 0;
-}
-
-static int taiko_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct taiko_priv *taiko = platform_get_drvdata(pdev);
-	dev_dbg(dev, "%s: system resume\n", __func__);
-	taiko->mbhc_last_resume = jiffies;
-	return 0;
-}
-
-static const struct dev_pm_ops taiko_pm_ops = {
-	.suspend	= taiko_suspend,
-	.resume		= taiko_resume,
-};
-#endif
-
-static int __devinit taiko_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_taiko,
-			taiko_dai, ARRAY_SIZE(taiko_dai));
-	else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_taiko,
-			taiko_i2s_dai, ARRAY_SIZE(taiko_i2s_dai));
-	return ret;
-}
-static int __devexit taiko_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-static struct platform_driver taiko_codec_driver = {
-	.probe = taiko_probe,
-	.remove = taiko_remove,
-	.driver = {
-		.name = "taiko_codec",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_PM
-		.pm = &taiko_pm_ops,
-#endif
-	},
-};
-
-static int __init taiko_codec_init(void)
-{
-	return platform_driver_register(&taiko_codec_driver);
-}
-
-static void __exit taiko_codec_exit(void)
-{
-	platform_driver_unregister(&taiko_codec_driver);
-}
-
-module_init(taiko_codec_init);
-module_exit(taiko_codec_exit);
-
-MODULE_DESCRIPTION("Taiko codec driver");
-MODULE_LICENSE("GPL v2");
diff -urN flo-ElementalX-5.00/sound/soc/imx/wm1133-ev1.c flo-ElementalX-5.00-patched/sound/soc/imx/wm1133-ev1.c
--- flo-ElementalX-5.00/sound/soc/imx/wm1133-ev1.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/sound/soc/imx/wm1133-ev1.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,304 +0,0 @@
-/*
- *  wm1133-ev1.c - Audio for WM1133-EV1 on i.MX31ADS
- *
- *  Copyright (c) 2010 Wolfson Microelectronics plc
- *  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- *  Based on an earlier driver for the same hardware by Liam Girdwood.
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- */
-
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/module.h>
-#include <sound/core.h>
-#include <sound/jack.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-
-#include "imx-ssi.h"
-#include "../codecs/wm8350.h"
-#include "imx-audmux.h"
-
-/* There is a silicon mic on the board optionally connected via a solder pad
- * SP1.  Define this to enable it.
- */
-#undef USE_SIMIC
-
-struct _wm8350_audio {
-	unsigned int channels;
-	snd_pcm_format_t format;
-	unsigned int rate;
-	unsigned int sysclk;
-	unsigned int bclkdiv;
-	unsigned int clkdiv;
-	unsigned int lr_rate;
-};
-
-/* in order of power consumption per rate (lowest first) */
-static const struct _wm8350_audio wm8350_audio[] = {
-	/* 16bit mono modes */
-	{1, SNDRV_PCM_FORMAT_S16_LE, 8000, 12288000 >> 1,
-	 WM8350_BCLK_DIV_48, WM8350_DACDIV_3, 16,},
-
-	/* 16 bit stereo modes */
-	{2, SNDRV_PCM_FORMAT_S16_LE, 8000, 12288000,
-	 WM8350_BCLK_DIV_48, WM8350_DACDIV_6, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 16000, 12288000,
-	 WM8350_BCLK_DIV_24, WM8350_DACDIV_3, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 32000, 12288000,
-	 WM8350_BCLK_DIV_12, WM8350_DACDIV_1_5, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 48000, 12288000,
-	 WM8350_BCLK_DIV_8, WM8350_DACDIV_1, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 96000, 24576000,
-	 WM8350_BCLK_DIV_8, WM8350_DACDIV_1, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 11025, 11289600,
-	 WM8350_BCLK_DIV_32, WM8350_DACDIV_4, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 22050, 11289600,
-	 WM8350_BCLK_DIV_16, WM8350_DACDIV_2, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 44100, 11289600,
-	 WM8350_BCLK_DIV_8, WM8350_DACDIV_1, 32,},
-	{2, SNDRV_PCM_FORMAT_S16_LE, 88200, 22579200,
-	 WM8350_BCLK_DIV_8, WM8350_DACDIV_1, 32,},
-
-	/* 24bit stereo modes */
-	{2, SNDRV_PCM_FORMAT_S24_LE, 48000, 12288000,
-	 WM8350_BCLK_DIV_4, WM8350_DACDIV_1, 64,},
-	{2, SNDRV_PCM_FORMAT_S24_LE, 96000, 24576000,
-	 WM8350_BCLK_DIV_4, WM8350_DACDIV_1, 64,},
-	{2, SNDRV_PCM_FORMAT_S24_LE, 44100, 11289600,
-	 WM8350_BCLK_DIV_4, WM8350_DACDIV_1, 64,},
-	{2, SNDRV_PCM_FORMAT_S24_LE, 88200, 22579200,
-	 WM8350_BCLK_DIV_4, WM8350_DACDIV_1, 64,},
-};
-
-static int wm1133_ev1_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int i, found = 0;
-	snd_pcm_format_t format = params_format(params);
-	unsigned int rate = params_rate(params);
-	unsigned int channels = params_channels(params);
-	u32 dai_format;
-
-	/* find the correct audio parameters */
-	for (i = 0; i < ARRAY_SIZE(wm8350_audio); i++) {
-		if (rate == wm8350_audio[i].rate &&
-		    format == wm8350_audio[i].format &&
-		    channels == wm8350_audio[i].channels) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found)
-		return -EINVAL;
-
-	/* codec FLL input is 14.75 MHz from MCLK */
-	snd_soc_dai_set_pll(codec_dai, 0, 0, 14750000, wm8350_audio[i].sysclk);
-
-	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-		SND_SOC_DAIFMT_CBM_CFM;
-
-	/* set codec DAI configuration */
-	snd_soc_dai_set_fmt(codec_dai, dai_format);
-
-	/* set cpu DAI configuration */
-	snd_soc_dai_set_fmt(cpu_dai, dai_format);
-
-	/* TODO: The SSI driver should figure this out for us */
-	switch (channels) {
-	case 2:
-		snd_soc_dai_set_tdm_slot(cpu_dai, 0xffffffc, 0xffffffc, 2, 0);
-		break;
-	case 1:
-		snd_soc_dai_set_tdm_slot(cpu_dai, 0xffffffe, 0xffffffe, 1, 0);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* set MCLK as the codec system clock for DAC and ADC */
-	snd_soc_dai_set_sysclk(codec_dai, WM8350_MCLK_SEL_PLL_MCLK,
-			       wm8350_audio[i].sysclk, SND_SOC_CLOCK_IN);
-
-	/* set codec BCLK division for sample rate */
-	snd_soc_dai_set_clkdiv(codec_dai, WM8350_BCLK_CLKDIV,
-			       wm8350_audio[i].bclkdiv);
-
-	/* DAI is synchronous and clocked with DAC LRCLK & ADC LRC */
-	snd_soc_dai_set_clkdiv(codec_dai,
-			       WM8350_DACLR_CLKDIV, wm8350_audio[i].lr_rate);
-	snd_soc_dai_set_clkdiv(codec_dai,
-			       WM8350_ADCLR_CLKDIV, wm8350_audio[i].lr_rate);
-
-	/* now configure DAC and ADC clocks */
-	snd_soc_dai_set_clkdiv(codec_dai,
-			       WM8350_DAC_CLKDIV, wm8350_audio[i].clkdiv);
-
-	snd_soc_dai_set_clkdiv(codec_dai,
-			       WM8350_ADC_CLKDIV, wm8350_audio[i].clkdiv);
-
-	return 0;
-}
-
-static struct snd_soc_ops wm1133_ev1_ops = {
-	.hw_params = wm1133_ev1_hw_params,
-};
-
-static const struct snd_soc_dapm_widget wm1133_ev1_widgets[] = {
-#ifdef USE_SIMIC
-	SND_SOC_DAPM_MIC("SiMIC", NULL),
-#endif
-	SND_SOC_DAPM_MIC("Mic1 Jack", NULL),
-	SND_SOC_DAPM_MIC("Mic2 Jack", NULL),
-	SND_SOC_DAPM_LINE("Line In Jack", NULL),
-	SND_SOC_DAPM_LINE("Line Out Jack", NULL),
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
-};
-
-/* imx32ads soc_card audio map */
-static const struct snd_soc_dapm_route wm1133_ev1_map[] = {
-
-#ifdef USE_SIMIC
-	/* SiMIC --> IN1LN (with automatic bias) via SP1 */
-	{ "IN1LN", NULL, "Mic Bias" },
-	{ "Mic Bias", NULL, "SiMIC" },
-#endif
-
-	/* Mic 1 Jack --> IN1LN and IN1LP (with automatic bias) */
-	{ "IN1LN", NULL, "Mic Bias" },
-	{ "IN1LP", NULL, "Mic1 Jack" },
-	{ "Mic Bias", NULL, "Mic1 Jack" },
-
-	/* Mic 2 Jack --> IN1RN and IN1RP (with automatic bias) */
-	{ "IN1RN", NULL, "Mic Bias" },
-	{ "IN1RP", NULL, "Mic2 Jack" },
-	{ "Mic Bias", NULL, "Mic2 Jack" },
-
-	/* Line in Jack --> AUX (L+R) */
-	{ "IN3R", NULL, "Line In Jack" },
-	{ "IN3L", NULL, "Line In Jack" },
-
-	/* Out1 --> Headphone Jack */
-	{ "Headphone Jack", NULL, "OUT1R" },
-	{ "Headphone Jack", NULL, "OUT1L" },
-
-	/* Out1 --> Line Out Jack */
-	{ "Line Out Jack", NULL, "OUT2R" },
-	{ "Line Out Jack", NULL, "OUT2L" },
-};
-
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-	{ .pin = "Headphone Jack", .mask = SND_JACK_HEADPHONE },
-};
-
-static struct snd_soc_jack mic_jack;
-
-static struct snd_soc_jack_pin mic_jack_pins[] = {
-	{ .pin = "Mic1 Jack", .mask = SND_JACK_MICROPHONE },
-	{ .pin = "Mic2 Jack", .mask = SND_JACK_MICROPHONE },
-};
-
-static int wm1133_ev1_init(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-
-	snd_soc_dapm_new_controls(dapm, wm1133_ev1_widgets,
-				  ARRAY_SIZE(wm1133_ev1_widgets));
-
-	snd_soc_dapm_add_routes(dapm, wm1133_ev1_map,
-				ARRAY_SIZE(wm1133_ev1_map));
-
-	/* Headphone jack detection */
-	snd_soc_jack_new(codec, "Headphone", SND_JACK_HEADPHONE, &hp_jack);
-	snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins),
-			      hp_jack_pins);
-	wm8350_hp_jack_detect(codec, WM8350_JDR, &hp_jack, SND_JACK_HEADPHONE);
-
-	/* Microphone jack detection */
-	snd_soc_jack_new(codec, "Microphone",
-			 SND_JACK_MICROPHONE | SND_JACK_BTN_0, &mic_jack);
-	snd_soc_jack_add_pins(&mic_jack, ARRAY_SIZE(mic_jack_pins),
-			      mic_jack_pins);
-	wm8350_mic_jack_detect(codec, &mic_jack, SND_JACK_MICROPHONE,
-			       SND_JACK_BTN_0);
-
-	snd_soc_dapm_force_enable_pin(dapm, "Mic Bias");
-
-	return 0;
-}
-
-
-static struct snd_soc_dai_link wm1133_ev1_dai = {
-	.name = "WM1133-EV1",
-	.stream_name = "Audio",
-	.cpu_dai_name = "imx-ssi.0",
-	.codec_dai_name = "wm8350-hifi",
-	.platform_name = "imx-fiq-pcm-audio.0",
-	.codec_name = "wm8350-codec.0-0x1a",
-	.init = wm1133_ev1_init,
-	.ops = &wm1133_ev1_ops,
-	.symmetric_rates = 1,
-};
-
-static struct snd_soc_card wm1133_ev1 = {
-	.name = "WM1133-EV1",
-	.owner = THIS_MODULE,
-	.dai_link = &wm1133_ev1_dai,
-	.num_links = 1,
-};
-
-static struct platform_device *wm1133_ev1_snd_device;
-
-static int __init wm1133_ev1_audio_init(void)
-{
-	int ret;
-	unsigned int ptcr, pdcr;
-
-	/* SSI0 mastered by port 5 */
-	ptcr = IMX_AUDMUX_V2_PTCR_SYN |
-		IMX_AUDMUX_V2_PTCR_TFSDIR |
-		IMX_AUDMUX_V2_PTCR_TFSEL(MX31_AUDMUX_PORT5_SSI_PINS_5) |
-		IMX_AUDMUX_V2_PTCR_TCLKDIR |
-		IMX_AUDMUX_V2_PTCR_TCSEL(MX31_AUDMUX_PORT5_SSI_PINS_5);
-	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(MX31_AUDMUX_PORT5_SSI_PINS_5);
-	imx_audmux_v2_configure_port(MX31_AUDMUX_PORT1_SSI0, ptcr, pdcr);
-
-	ptcr = IMX_AUDMUX_V2_PTCR_SYN;
-	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(MX31_AUDMUX_PORT1_SSI0);
-	imx_audmux_v2_configure_port(MX31_AUDMUX_PORT5_SSI_PINS_5, ptcr, pdcr);
-
-	wm1133_ev1_snd_device = platform_device_alloc("soc-audio", -1);
-	if (!wm1133_ev1_snd_device)
-		return -ENOMEM;
-
-	platform_set_drvdata(wm1133_ev1_snd_device, &wm1133_ev1);
-	ret = platform_device_add(wm1133_ev1_snd_device);
-
-	if (ret)
-		platform_device_put(wm1133_ev1_snd_device);
-
-	return ret;
-}
-module_init(wm1133_ev1_audio_init);
-
-static void __exit wm1133_ev1_audio_exit(void)
-{
-	platform_device_unregister(wm1133_ev1_snd_device);
-}
-module_exit(wm1133_ev1_audio_exit);
-
-MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
-MODULE_DESCRIPTION("Audio for WM1133-EV1 on i.MX31ADS");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/sound/soc/pxa/poodle.c flo-ElementalX-5.00-patched/sound/soc/pxa/poodle.c
--- flo-ElementalX-5.00/sound/soc/pxa/poodle.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/sound/soc/pxa/poodle.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,317 +0,0 @@
-/*
- * poodle.c  --  SoC audio for Poodle
- *
- * Copyright 2005 Wolfson Microelectronics PLC.
- * Copyright 2005 Openedhand Ltd.
- *
- * Authors: Liam Girdwood <lrg@slimlogic.co.uk>
- *          Richard Purdie <richard@openedhand.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/timer.h>
-#include <linux/i2c.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-
-#include <asm/mach-types.h>
-#include <asm/hardware/locomo.h>
-#include <mach/poodle.h>
-#include <mach/audio.h>
-
-#include "../codecs/wm8731.h"
-#include "pxa2xx-i2s.h"
-
-#define POODLE_HP        1
-#define POODLE_HP_OFF    0
-#define POODLE_SPK_ON    1
-#define POODLE_SPK_OFF   0
-
- /* audio clock in Hz - rounded from 12.235MHz */
-#define POODLE_AUDIO_CLOCK 12288000
-
-static int poodle_jack_func;
-static int poodle_spk_func;
-
-static void poodle_ext_control(struct snd_soc_dapm_context *dapm)
-{
-	/* set up jack connection */
-	if (poodle_jack_func == POODLE_HP) {
-		/* set = unmute headphone */
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_MUTE_L, 1);
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_MUTE_R, 1);
-		snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
-	} else {
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_MUTE_L, 0);
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_MUTE_R, 0);
-		snd_soc_dapm_disable_pin(dapm, "Headphone Jack");
-	}
-
-	/* set the enpoints to their new connetion states */
-	if (poodle_spk_func == POODLE_SPK_ON)
-		snd_soc_dapm_enable_pin(dapm, "Ext Spk");
-	else
-		snd_soc_dapm_disable_pin(dapm, "Ext Spk");
-
-	/* signal a DAPM event */
-	snd_soc_dapm_sync(dapm);
-}
-
-static int poodle_startup(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_codec *codec = rtd->codec;
-
-	mutex_lock(&codec->mutex);
-
-	/* check the jack status at stream startup */
-	poodle_ext_control(&codec->dapm);
-
-	mutex_unlock(&codec->mutex);
-
-	return 0;
-}
-
-/* we need to unmute the HP at shutdown as the mute burns power on poodle */
-static void poodle_shutdown(struct snd_pcm_substream *substream)
-{
-	/* set = unmute headphone */
-	locomo_gpio_write(&poodle_locomo_device.dev,
-		POODLE_LOCOMO_GPIO_MUTE_L, 1);
-	locomo_gpio_write(&poodle_locomo_device.dev,
-		POODLE_LOCOMO_GPIO_MUTE_R, 1);
-}
-
-static int poodle_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	unsigned int clk = 0;
-	int ret = 0;
-
-	switch (params_rate(params)) {
-	case 8000:
-	case 16000:
-	case 48000:
-	case 96000:
-		clk = 12288000;
-		break;
-	case 11025:
-	case 22050:
-	case 44100:
-		clk = 11289600;
-		break;
-	}
-
-	/* set the codec system clock for DAC and ADC */
-	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_XTAL, clk,
-		SND_SOC_CLOCK_IN);
-	if (ret < 0)
-		return ret;
-
-	/* set the I2S system clock as input (unused) */
-	ret = snd_soc_dai_set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,
-		SND_SOC_CLOCK_IN);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static struct snd_soc_ops poodle_ops = {
-	.startup = poodle_startup,
-	.hw_params = poodle_hw_params,
-	.shutdown = poodle_shutdown,
-};
-
-static int poodle_get_jack(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.integer.value[0] = poodle_jack_func;
-	return 0;
-}
-
-static int poodle_set_jack(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_card *card =  snd_kcontrol_chip(kcontrol);
-
-	if (poodle_jack_func == ucontrol->value.integer.value[0])
-		return 0;
-
-	poodle_jack_func = ucontrol->value.integer.value[0];
-	poodle_ext_control(&card->dapm);
-	return 1;
-}
-
-static int poodle_get_spk(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.integer.value[0] = poodle_spk_func;
-	return 0;
-}
-
-static int poodle_set_spk(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_card *card =  snd_kcontrol_chip(kcontrol);
-
-	if (poodle_spk_func == ucontrol->value.integer.value[0])
-		return 0;
-
-	poodle_spk_func = ucontrol->value.integer.value[0];
-	poodle_ext_control(&card->dapm);
-	return 1;
-}
-
-static int poodle_amp_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *k, int event)
-{
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_AMP_ON, 0);
-	else
-		locomo_gpio_write(&poodle_locomo_device.dev,
-			POODLE_LOCOMO_GPIO_AMP_ON, 1);
-
-	return 0;
-}
-
-/* poodle machine dapm widgets */
-static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
-SND_SOC_DAPM_HP("Headphone Jack", NULL),
-SND_SOC_DAPM_SPK("Ext Spk", poodle_amp_event),
-};
-
-/* Corgi machine connections to the codec pins */
-static const struct snd_soc_dapm_route poodle_audio_map[] = {
-
-	/* headphone connected to LHPOUT1, RHPOUT1 */
-	{"Headphone Jack", NULL, "LHPOUT"},
-	{"Headphone Jack", NULL, "RHPOUT"},
-
-	/* speaker connected to LOUT, ROUT */
-	{"Ext Spk", NULL, "ROUT"},
-	{"Ext Spk", NULL, "LOUT"},
-};
-
-static const char *jack_function[] = {"Off", "Headphone"};
-static const char *spk_function[] = {"Off", "On"};
-static const struct soc_enum poodle_enum[] = {
-	SOC_ENUM_SINGLE_EXT(2, jack_function),
-	SOC_ENUM_SINGLE_EXT(2, spk_function),
-};
-
-static const struct snd_kcontrol_new wm8731_poodle_controls[] = {
-	SOC_ENUM_EXT("Jack Function", poodle_enum[0], poodle_get_jack,
-		poodle_set_jack),
-	SOC_ENUM_EXT("Speaker Function", poodle_enum[1], poodle_get_spk,
-		poodle_set_spk),
-};
-
-/*
- * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
- */
-static int poodle_wm8731_init(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-
-	snd_soc_dapm_nc_pin(dapm, "LLINEIN");
-	snd_soc_dapm_nc_pin(dapm, "RLINEIN");
-	snd_soc_dapm_enable_pin(dapm, "MICIN");
-
-	return 0;
-}
-
-/* poodle digital audio interface glue - connects codec <--> CPU */
-static struct snd_soc_dai_link poodle_dai = {
-	.name = "WM8731",
-	.stream_name = "WM8731",
-	.cpu_dai_name = "pxa2xx-i2s",
-	.codec_dai_name = "wm8731-hifi",
-	.platform_name = "pxa-pcm-audio",
-	.codec_name = "wm8731.0-001b",
-	.init = poodle_wm8731_init,
-	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-		   SND_SOC_DAIFMT_CBS_CFS,
-	.ops = &poodle_ops,
-};
-
-/* poodle audio machine driver */
-static struct snd_soc_card poodle = {
-	.name = "Poodle",
-	.dai_link = &poodle_dai,
-	.num_links = 1,
-	.owner = THIS_MODULE,
-
-	.controls = wm8731_poodle_controls,
-	.num_controls = ARRAY_SIZE(wm8731_poodle_controls),
-	.dapm_widgets = wm8731_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(wm8731_dapm_widgets),
-	.dapm_routes = poodle_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(poodle_audio_map),
-};
-
-static int __devinit poodle_probe(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = &poodle;
-	int ret;
-
-	locomo_gpio_set_dir(&poodle_locomo_device.dev,
-		POODLE_LOCOMO_GPIO_AMP_ON, 0);
-	/* should we mute HP at startup - burning power ?*/
-	locomo_gpio_set_dir(&poodle_locomo_device.dev,
-		POODLE_LOCOMO_GPIO_MUTE_L, 0);
-	locomo_gpio_set_dir(&poodle_locomo_device.dev,
-		POODLE_LOCOMO_GPIO_MUTE_R, 0);
-
-	card->dev = &pdev->dev;
-
-	ret = snd_soc_register_card(card);
-	if (ret)
-		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
-			ret);
-	return ret;
-}
-
-static int __devexit poodle_remove(struct platform_device *pdev)
-{
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-
-	snd_soc_unregister_card(card);
-	return 0;
-}
-
-static struct platform_driver poodle_driver = {
-	.driver		= {
-		.name	= "poodle-audio",
-		.owner	= THIS_MODULE,
-	},
-	.probe		= poodle_probe,
-	.remove		= __devexit_p(poodle_remove),
-};
-
-module_platform_driver(poodle_driver);
-
-/* Module information */
-MODULE_AUTHOR("Richard Purdie");
-MODULE_DESCRIPTION("ALSA SoC Poodle");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:poodle-audio");
diff -urN flo-ElementalX-5.00/tools/perf/builtin-periodic.c flo-ElementalX-5.00-patched/tools/perf/builtin-periodic.c
--- flo-ElementalX-5.00/tools/perf/builtin-periodic.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/tools/perf/builtin-periodic.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,485 +0,0 @@
-/*
- * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-/*
- *	A very simple perf program to periodically print the performance
- *	counter reqested on the command line to standard out at the rate
- *	specified.
- *
- *	This is valuable for showing the output in a simple plot or
- *	exporting the counter data for post processing.  No attempt
- *	to process the data is made.
- *
- *	Scaling is not supported, use only as many counters as are
- *	provided by the hardware.
- *
- *	Math functions are support to combine counter results by using
- *	the -m flag.
- *
- *	The -r -w flags supports user signalling for input. This assumes
- *	that a pipe/fifo is needed so the -rw cmd line arg is a string
- *	that is the name of the named pipe to open for read/write.  User
- *	sends data on the read pipe to the process to collect a sample.
- *	Commands are also supported on the pipe.
- *
- */
-
-#include "perf.h"
-#include "builtin.h"
-#include "util/util.h"
-#include "util/parse-options.h"
-#include "util/parse-events.h"
-#include "util/event.h"
-#include "util/evsel.h"
-#include "util/evlist.h"
-#include "util/debug.h"
-#include "util/header.h"
-#include "util/cpumap.h"
-#include "util/thread.h"
-#include <signal.h>
-#include <sys/types.h>
-
-#define PERF_PERIODIC_ERROR -1
-
-/* number of pieces of data on each read. */
-#define DATA_SIZE 2
-
-#define DEFAULT_FIFO_NAME "xxbadFiFo"
-#define MAX_NAMELEN 50
-
-struct perf_evlist *evsel_list;
-
-/*
- * command line variables and settings
- * Default to current process, no_inherit, process
- */
-static pid_t target_pid = -1; /* all */
-static bool system_wide;
-static int cpumask = -1;  /* all */
-static int ncounts;
-static int ms_sleep = 1000;  /* 1 second */
-static char const *operations = "nnnnnnnnnnnnnnnn";  /* nop */
-static bool math_enabled;
-static bool calc_delta;
-static double old_accum, accum;
-static int math_op_index;
-static char const *wfifo_name = DEFAULT_FIFO_NAME;
-static char const *rfifo_name = DEFAULT_FIFO_NAME;
-static bool use_fifo;
-static bool is_ratio;
-static FILE *fd_in, *fd_out;
-
-static FILE *tReadFifo, *tWriteFifo;
-
-/*
- * Raw results from perf, we track the current value and
- * the old value.
- */
-struct perf_raw_results_s {
-	u64 values;
-	u64 old_value;
-};
-
-/*
- * Everything we need to support a perf counter across multiple
- * CPUs.  We need to support multiple file descriptors (perf_fd)
- * because perf requires a fd per counter, so 1 per core enabled.
- *
- * Raw results values are calculated across all the cores as they
- * are read.
- */
-struct perf_setup_s {
-	int event_index;
-	struct perf_event_attr *attr;
-	int perf_fd[MAX_NR_CPUS];
-	pid_t pid;
-	int cpu;
-	int flags;
-	int group;
-	struct perf_raw_results_s data;
-	struct perf_raw_results_s totals;
-	struct perf_raw_results_s output;
-};
-
-static void do_cleanup(void)
-{
-	if (fd_in) {
-		if (0 != fclose(fd_in))
-			error("Error closing fd_in\n");
-	}
-	if (fd_out) {
-		if (0 != fclose(fd_out))
-			error("Error closing fd_out\n");
-	}
-	if (use_fifo) {
-		if (0 != unlink(rfifo_name))
-			error("Error unlinking rfifo\n");
-		if (0 != unlink(wfifo_name))
-			error("Error unlinking wfifo\n");
-	}
-}
-
-/*
- * Unexpected signal for error indication, cleanup
- */
-static int sig_dummy;
-static void sig_do_cleanup(int sig)
-{
-	sig_dummy = sig;
-	do_cleanup();
-	exit(0);
-}
-
-#define PERIODIC_MAX_STRLEN 100
-/*
- * Delay for either a timed period or the wait on the read_fifo
- */
-static void delay(unsigned long milli)
-{
-	char tmp_stg[PERIODIC_MAX_STRLEN];
-	int done;
-	int ret;
-
-	if (use_fifo) {
-		do {
-			done = true;
-			ret = fscanf(tReadFifo, "%s", tmp_stg);
-			if (ret == 0)
-				return;
-			/*
-			 * Look for a command request, and if we get a command
-			 * Need to process and then wait again w/o sending data.
-			 */
-			if (strncmp(tmp_stg, "PID", strnlen(tmp_stg,
-				PERIODIC_MAX_STRLEN)) == 0) {
-				fprintf(fd_out, " %u\n", getpid());
-				fflush(fd_out);
-				done = false;
-			} else if (strncmp(tmp_stg, "EXIT",
-					strnlen(tmp_stg, PERIODIC_MAX_STRLEN))
-						== 0) {
-				do_cleanup();
-				exit(0);
-			}
-
-		} while (done != true);
-	} else
-		usleep(milli*1000);
-}
-
-/*
- * Create a perf counter event.
- * Some interesting behaviour that is not documented anywhere else:
- * the CPU will not work if out of range.
- * The CPU will only work for a single CPU, so to collect the counts
- * on the system in SMP based systems a counter needs to be created
- * for each CPU.
- */
-static int create_perf_counter(struct perf_setup_s *p)
-{
-	struct cpu_map *cpus;
-	int cpu;
-
-	cpus = cpu_map__new(NULL);
-	if (p == NULL)
-		return PERF_PERIODIC_ERROR;
-	for (cpu = 0; cpu < cpus->nr; cpu++) {
-		if (((1 << cpu) & cpumask) == 0)
-			continue;
-		p->perf_fd[cpu] = sys_perf_event_open(p->attr, target_pid, cpu,
-					-1, 0);
-		if (p->perf_fd[cpu] < 0)
-			return PERF_PERIODIC_ERROR;
-	}
-	return 0;
-}
-
-/*
- * Perf init setup
- */
-static int perf_setup_init(struct perf_setup_s *p)
-{
-	if (p == NULL)
-		return PERF_PERIODIC_ERROR;
-
-	bzero(p, sizeof(struct perf_setup_s));
-	p->group = -1;
-	p->flags = 0;
-
-	p->output.values = 0;
-	p->output.old_value = 0;
-	p->data.values = 0;
-	p->data.old_value = 0;
-	p->totals.old_value = 0;
-	p->totals.values = 0;
-
-	return 0;
-}
-
-/*
- * Read in ALL the performance counters configured for the CPU,
- * one performance monitor per core that was configured during
- * "all" mode
- */
-static int perf_setup_read(struct perf_setup_s *p)
-{
-	u64 data[DATA_SIZE];
-	int i, status;
-
-	p->totals.values = 0;
-	p->data.values = 0;
-	for (i = 0; i < MAX_NR_CPUS; i++) {
-		if (p->perf_fd[i] == 0)
-			continue;
-		status = read(p->perf_fd[i], &data, sizeof(data));
-		p->data.values += data[0];
-		p->totals.values += data[0];
-	}
-
-	/*
-	 * Normally we show totals, we want to support
-	 * showing deltas from the previous value so external apps do not have
-	 * to do this...
-	 */
-	if (calc_delta) {
-		p->output.values = p->data.values - p->data.old_value;
-		p->data.old_value = p->data.values;
-	} else
-		p->output.values = p->totals.values;
-	return 0;
-}
-
-static int perf_setup_show(struct perf_setup_s *p)
-{
-	if (p == NULL)
-		return PERF_PERIODIC_ERROR;
-	fprintf(fd_out, " %llu", p->output.values);
-	return 0;
-}
-
-
-static const char * const periodic_usage[] = {
-	"perf periodic [<options>]",
-	NULL
-};
-
-static const struct option options[] = {
-	OPT_CALLBACK('e', "event", &evsel_list, "event",
-	"event selector. use 'perf list' to list available events",
-	 parse_events_option),
-	OPT_STRING('m', "math-operations", &operations, "nnnnnn",
-	"math operation to perform on values collected asmd in order"),
-	OPT_STRING('r', "readpipe", &rfifo_name, "xxbadFiFo",
-	"wait for a user input fifo - will be created"),
-	OPT_STRING('w', "writepipe", &wfifo_name, "xxbadFifo",
-	"write data out on this pipe - pipe is created"),
-	OPT_INTEGER('i', "increment", &ncounts,
-	"number of times periods to count/iterate (default 0-forever)"),
-	OPT_INTEGER('p', "pid", &target_pid,
-	"stat events on existing process id"),
-	OPT_INTEGER('c', "cpumask", &cpumask,
-	"cpumask to enable counters, default all (-1)"),
-	OPT_INTEGER('s', "sleep", &ms_sleep,
-	"how long to sleep in ms between each sample (default 1000)"),
-	OPT_BOOLEAN('a', "all-cpus", &system_wide,
-	"system-wide collection from all CPUs overrides cpumask"),
-	OPT_BOOLEAN('d', "delta", &calc_delta,
-	"calculate and display the delta values math funcs will use delta"),
-	OPT_INCR('v', "verbose", &verbose,
-	"be more verbose (show counter open errors, etc)"),
-	OPT_END()
-};
-
-/*
- * After every period we reset any math that was performed.
- */
-static void reset_math(void)
-{
-	math_op_index = 0;
-	old_accum = accum;
-	accum = 0;
-}
-
-static void do_math_op(struct perf_setup_s *p)
-{
-	if (!math_enabled)
-		return;
-	switch (operations[math_op_index++]) {
-	case 'm':
-		accum *= (double)p->output.values; break;
-	case 'a':
-		accum += (double)p->output.values; break;
-	case 's':
-		accum -= (double)p->output.values; break;
-	case 'd':
-		accum /= (double)p->output.values; break;
-	case 'z':
-		accum =  0; break;
-	case 't':
-		accum =  (double)p->output.values; break; /*transfer*/
-	case 'T':
-		accum +=  old_accum; break; /*total*/
-	case 'i':	/* ignore */
-	default:
-		break;
-	}
-}
-
-int cmd_periodic(int argc, const char **argv, const char *prefix __used)
-{
-	int status = 0;
-	int c, i;
-	struct perf_setup_s *p[MAX_COUNTERS];
-	struct perf_evsel *counter;
-	FILE *fp;
-	int nr_counters = 0;
-
-	evsel_list = perf_evlist__new(NULL, NULL);
-	if (evsel_list == NULL)
-		return -ENOMEM;
-
-	argc = parse_options(argc, argv, options, periodic_usage,
-		PARSE_OPT_STOP_AT_NON_OPTION);
-
-	if (system_wide)
-		cpumask = -1;
-
-	/*
-	 * The r & w option redirects stdout to a newly created pipe and
-	 * waits for input on the read pipe before continuing
-	 */
-	fd_in = stdin;
-	fd_out = stdout;
-	if (strncmp(rfifo_name, DEFAULT_FIFO_NAME,
-				strnlen(rfifo_name, MAX_NAMELEN))) {
-		fp = fopen(rfifo_name, "r");
-		if (fp != NULL) {
-			fclose(fp);
-			remove(rfifo_name);
-		}
-		if (mkfifo(rfifo_name, 0777) == -1) {
-			error("Could not open read fifo\n");
-			do_cleanup();
-			return PERF_PERIODIC_ERROR;
-		}
-		tReadFifo = fopen(rfifo_name, "r+");
-		if (tReadFifo == 0) {
-			do_cleanup();
-			error("Could not open read fifo file\n");
-			return PERF_PERIODIC_ERROR;
-		}
-		use_fifo = true;
-	}
-	if (strncmp(wfifo_name, DEFAULT_FIFO_NAME,
-				strnlen(wfifo_name, MAX_NAMELEN)))  {
-		fp = fopen(wfifo_name, "r");
-		if (fp != NULL) {
-			fclose(fp);
-			remove(wfifo_name);
-		}
-		if (mkfifo(wfifo_name, 0777) == -1) {
-			do_cleanup();
-			error("Could not open write fifo\n");
-			return PERF_PERIODIC_ERROR;
-		}
-		fd_out = fopen(wfifo_name, "w+");
-		if (fd_out == 0) {
-			do_cleanup();
-			error("Could not open write fifo file\n");
-			return PERF_PERIODIC_ERROR;
-		}
-		tWriteFifo = fd_out;
-	}
-
-	math_enabled = (operations[0] != 'n');
-
-	/*
-	 * If we don't ignore SIG_PIPE then when the other side
-	 * of a pipe closes we shutdown too...
-	 */
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGINT, sig_do_cleanup);
-	signal(SIGQUIT, sig_do_cleanup);
-	signal(SIGKILL, sig_do_cleanup);
-	signal(SIGTERM, sig_do_cleanup);
-
-	i = 0;
-	list_for_each_entry(counter, &evsel_list->entries, node) {
-		p[i] = malloc(sizeof(struct perf_setup_s));
-		if (p[i] == NULL) {
-			error("Error allocating perf_setup_s\n");
-			do_cleanup();
-			return PERF_PERIODIC_ERROR;
-		}
-		bzero(p[i], sizeof(struct perf_setup_s));
-		perf_setup_init(p[i]);
-		p[i]->attr = &(counter->attr);
-		p[i]->event_index = counter->idx;
-		if (create_perf_counter(p[i]) < 0) {
-			do_cleanup();
-			die("Not all events could be opened.\n");
-			return PERF_PERIODIC_ERROR;
-		}
-		i++;
-		nr_counters++;
-	}
-	i = 0;
-	while (1) {
-
-		/*
-		 * Wait first otherwise single sample will print w/o signal
-		 * when using the -u (user signal) flag
-		 */
-		delay(ms_sleep);
-
-		/*
-		 * Do the collection, read and then perform any math operations
-		 */
-		for (c = 0; c < nr_counters; c++) {
-			status = perf_setup_read(p[c]);
-			do_math_op(p[c]);
-		}
-
-		/*
-		 * After all collection and math, we perform one last math
-		 * to allow totaling, if enabled etc, then either printout
-		 * a single float value when the math is enabled or ...
-		 */
-		if (math_enabled) {
-			do_math_op(p[c]);
-			if (is_ratio)
-				fprintf(fd_out, "%#f\n", accum*100);
-			else
-				fprintf(fd_out, "%#f\n", accum);
-		} else {
-			/*
-			 * ... print out one integer value for each counter
-			 */
-			for (c = 0; c < nr_counters; c++)
-				status = perf_setup_show(p[c]);
-			fprintf(fd_out, "\n");
-		}
-
-		/*
-		 * Did the user give us an iteration count?
-		 */
-		if ((ncounts != 0) && (++i >= ncounts))
-			break;
-		reset_math();
-		fflush(fd_out); /* make sure data is flushed out the pipe*/
-	}
-
-	do_cleanup();
-
-	return status;
-}
