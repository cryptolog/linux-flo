diff -urN flo-ElementalX-5.00/.config flo-ElementalX-5.00-patched/.config
--- flo-ElementalX-5.00/.config	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/.config	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,4130 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARM_TICKET_LOCKS=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_PHYS_OFFSET=0x80200000
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="-flo"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_TEST=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_FIOPS=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_ROW is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_SIO is not set
+# CONFIG_DEFAULT_FIOPS is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+CONFIG_ARCH_MSM=y
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# MSM SoC Type
+#
+# CONFIG_ARCH_MSM7X01A is not set
+# CONFIG_ARCH_MSM7X25 is not set
+# CONFIG_ARCH_MSM7X27 is not set
+# CONFIG_ARCH_MSM7X30 is not set
+# CONFIG_ARCH_QSD8X50 is not set
+# CONFIG_ARCH_MSM8X60 is not set
+CONFIG_ARCH_MSM8960=y
+CONFIG_ARCH_MSM8930=y
+CONFIG_ARCH_APQ8064=y
+# CONFIG_ARCH_MSM8974 is not set
+# CONFIG_ARCH_MPQ8092 is not set
+# CONFIG_ARCH_MSM8226 is not set
+# CONFIG_ARCH_FSM9XXX is not set
+# CONFIG_ARCH_MSM9615 is not set
+# CONFIG_ARCH_MSM8625 is not set
+# CONFIG_ARCH_MSM9625 is not set
+CONFIG_MSM_SOC_REV_NONE=y
+# CONFIG_MSM_SOC_REV_A is not set
+CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
+CONFIG_ARCH_MSM_KRAIT=y
+CONFIG_MSM_SMP=y
+CONFIG_ARCH_MSM_KRAITMP=y
+CONFIG_MSM_KRAIT_WFE_FIXUP=y
+CONFIG_MSM_RPM=y
+# CONFIG_MSM_RPM_SMD is not set
+CONFIG_MSM_MPM=y
+CONFIG_MSM_XO=y
+CONFIG_MSM_REMOTE_SPINLOCK_SFPB=y
+
+#
+# MSM Board Selection
+#
+# CONFIG_MACH_MSM8960_CDP is not set
+# CONFIG_MACH_MSM8960_MTP is not set
+# CONFIG_MACH_MSM8960_FLUID is not set
+# CONFIG_MACH_MSM8960_LIQUID is not set
+# CONFIG_MACH_MSM8930_CDP is not set
+# CONFIG_MACH_MSM8930_MTP is not set
+# CONFIG_MACH_MSM8930_FLUID is not set
+# CONFIG_MACH_MSM8627_CDP is not set
+# CONFIG_MACH_MSM8627_MTP is not set
+# CONFIG_MACH_APQ8064_CDP is not set
+# CONFIG_MACH_APQ8064_MTP is not set
+# CONFIG_MACH_APQ8064_LIQUID is not set
+# CONFIG_MACH_MPQ8064_CDP is not set
+# CONFIG_MACH_MPQ8064_HRD is not set
+# CONFIG_MACH_MPQ8064_DTV is not set
+# CONFIG_MACH_MSM_DUMMY is not set
+
+#
+# LGE Board Selection
+#
+CONFIG_BOARD_HEADER_FILE=""
+# CONFIG_MACH_APQ8064_MAKO is not set
+# CONFIG_MACH_LGE_DUMMY is not set
+
+#
+# LGE Specific Patches
+#
+CONFIG_UPDATE_LCDC_LUT=y
+# CONFIG_LGE_CRASH_HANDLER is not set
+CONFIG_MACH_ASUSTEK=y
+
+#
+# ASUSTek Board Selection
+#
+CONFIG_MACH_APQ8064_FLO=y
+CONFIG_MACH_APQ8064_DEB=y
+# CONFIG_MACH_ASUSTEK_DUMMY is not set
+
+#
+# ASUSTek Specific Feature
+#
+CONFIG_ASUSTEK_PCBID=y
+CONFIG_ASUSTEK_KEYPAD=y
+# CONFIG_MSM_STACKED_MEMORY is not set
+CONFIG_KERNEL_MSM_CONTIG_MEM_REGION=y
+CONFIG_MSM_AMSS_VERSION=6225
+# CONFIG_MSM_AMSS_VERSION_6210 is not set
+# CONFIG_MSM_AMSS_VERSION_6220 is not set
+CONFIG_MSM_AMSS_VERSION_6225=y
+CONFIG_MSM7X00A_USE_GP_TIMER=y
+# CONFIG_MSM7X00A_USE_DG_TIMER is not set
+CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
+# CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+# CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_SLEEP_MODE=0
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
+# CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
+CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
+CONFIG_MSM_IDLE_STATS=y
+CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
+CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
+CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
+CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_HTC_HEADSET is not set
+# CONFIG_HTC_PWRSINK is not set
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_SERIAL_DEBUGGER is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+# CONFIG_MSM_SMD_PKG3 is not set
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_PCIE=y
+CONFIG_MSM_SMD_DEBUG=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_N_WAY_SMD=y
+CONFIG_MSM_N_WAY_SMSM=y
+CONFIG_MSM_RESET_MODEM=y
+CONFIG_MSM_SMD_LOGGING=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_MSM_SMD_NMEA=y
+CONFIG_MSM_HSIC_TTY=y
+CONFIG_MSM_SMD_TTY=y
+CONFIG_MSM_SMD_QMI=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_MSM_DSPS=y
+# CONFIG_MSM_ONCRPCROUTER is not set
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_IPC_ROUTER_SECURITY=y
+# CONFIG_MSM_DALRPC is not set
+# CONFIG_MSM_CPU_FREQ_SET_MIN_MAX is not set
+CONFIG_MSM_SLEEPER=y
+CONFIG_CPU_VOLTAGE_TABLE=y
+CONFIG_MSM_AVS_HW=y
+# CONFIG_MSM_HW3D is not set
+CONFIG_AMSS_7X25_VERSION_2009=y
+# CONFIG_AMSS_7X25_VERSION_2008 is not set
+CONFIG_RTAC=y
+# CONFIG_MSM_VREG_SWITCH_INVERTED is not set
+CONFIG_MSM_DMA_TEST=y
+# CONFIG_WIFI_CONTROL_FUNC is not set
+CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE is not set
+CONFIG_MSM_PM_TIMEOUT_HALT=y
+# CONFIG_MSM_PM_TIMEOUT_RESET_MODEM is not set
+# CONFIG_MSM_PM_TIMEOUT_RESET_CHIP is not set
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
+CONFIG_MSM_RPM_REGULATOR=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL=y
+# CONFIG_MSM_PIL_MODEM is not set
+# CONFIG_MSM_PIL_QDSP6V3 is not set
+CONFIG_MSM_PIL_QDSP6V4=y
+# CONFIG_MSM_PIL_LPASS_QDSP6V5 is not set
+# CONFIG_MSM_PIL_MSS_QDSP6V5 is not set
+CONFIG_MSM_PIL_RIVA=y
+CONFIG_MSM_PIL_TZAPPS=y
+CONFIG_MSM_PIL_DSPS=y
+CONFIG_MSM_PIL_VIDC=y
+# CONFIG_MSM_PIL_VENUS is not set
+CONFIG_MSM_PIL_GSS=y
+# CONFIG_MSM_PIL_PRONTO is not set
+CONFIG_MSM_SCM=y
+CONFIG_MSM_MODEM_8960=y
+CONFIG_MSM_LPASS_8960=y
+CONFIG_MSM_WCNSS_SSR_8960=m
+CONFIG_MSM_GSS_SSR_8064=y
+CONFIG_MSM_BUSPM_DEV=y
+CONFIG_MSM_TZ_LOG=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_IOMMU_API=y
+CONFIG_MSM_GPIOMUX=y
+CONFIG_MSM_NATIVE_RESTART=y
+CONFIG_MSM_PM8X60=y
+CONFIG_MSM_EVENT_TIMER=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED=y
+CONFIG_MSM_WATCHDOG=y
+# CONFIG_MSM_WATCHDOG_V2 is not set
+# CONFIG_MSM_MEMORY_DUMP is not set
+CONFIG_MSM_DLOAD_MODE=y
+# CONFIG_MSM_JTAG is not set
+# CONFIG_MSM_JTAG_MM is not set
+# CONFIG_MSM_SLEEP_STATS_DEVICE is not set
+CONFIG_MSM_RUN_QUEUE_STATS=y
+# CONFIG_MSM_STANDALONE_POWER_COLLAPSE is not set
+# CONFIG_MSM_GSBI9_UART is not set
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+# CONFIG_MSM_FAKE_BATTERY is not set
+CONFIG_MSM_QDSP6_APR=y
+# CONFIG_MSM_QDSP6_APRV2 is not set
+CONFIG_MSM_QDSP6_CODECS=y
+# CONFIG_MSM_QDSP6V2_CODECS is not set
+CONFIG_MSM_AUDIO_QDSP6=y
+# CONFIG_MSM_AUDIO_QDSP6V2 is not set
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_ULTRASOUND=y
+# CONFIG_MSM_SPM_V1 is not set
+CONFIG_MSM_SPM_V2=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_MSM_MULTIMEDIA_USE_ION=y
+# CONFIG_MSM_OCMEM is not set
+# CONFIG_MSM_RTB is not set
+CONFIG_MSM_EBI_ERP=y
+CONFIG_MSM_CACHE_ERP=y
+CONFIG_MSM_L1_ERR_PANIC=y
+CONFIG_MSM_L1_ERR_LOG=y
+# CONFIG_MSM_L2_ERP_PRINT_ACCESS_ERRORS is not set
+# CONFIG_MSM_L2_ERP_1BIT_PANIC is not set
+CONFIG_MSM_L2_ERP_2BIT_PANIC=y
+CONFIG_MSM_DCVS=y
+# CONFIG_MSM_CPR is not set
+CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER=y
+CONFIG_MSM_CACHE_DUMP=y
+CONFIG_MSM_CACHE_DUMP_ON_PANIC=y
+CONFIG_MSM_HSIC_SYSMON=y
+# CONFIG_MSM_HSIC_SYSMON_TEST is not set
+CONFIG_MSM_CPU_PWRCTL=y
+# CONFIG_FORCE_FAST_CHARGE is not set
+CONFIG_LCD_KCAL=y
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_ARM_NR_BANKS=8
+# CONFIG_RESERVE_FIRST_PAGE is not set
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_KSAPI is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CLEANCACHE=y
+# CONFIG_ARCH_MEMORY_PROBE is not set
+# CONFIG_ARCH_MEMORY_REMOVE is not set
+# CONFIG_ENABLE_DMM is not set
+# CONFIG_FIX_MOVABLE_ZONE is not set
+CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0=y
+# CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG is not set
+# CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE is not set
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+CONFIG_CP_ACCESS=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+CONFIG_KEXEC_HARDBOOT=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=y
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_INTELLIDEMAND is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_FREQ_MSM=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_TCP_CONG_ILLINOIS=y
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_HYBLA is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_VENO is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_REJECT_SKERR is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=y
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+CONFIG_NET_SCH_PRIO=y
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+CONFIG_NET_CLS_FLOW=y
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_IRDA=y
+
+#
+# IrDA protocols
+#
+# CONFIG_IRLAN is not set
+# CONFIG_IRNET is not set
+# CONFIG_IRCOMM is not set
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=y
+
+#
+# Dongle support
+#
+CONFIG_DONGLE=y
+# CONFIG_ESI_DONGLE is not set
+# CONFIG_ACTISYS_DONGLE is not set
+# CONFIG_TEKRAM_DONGLE is not set
+# CONFIG_TOIM3232_DONGLE is not set
+# CONFIG_LITELINK_DONGLE is not set
+CONFIG_MA600_DONGLE=y
+# CONFIG_GIRBIL_DONGLE is not set
+# CONFIG_MCP2120_DONGLE is not set
+# CONFIG_OLD_BELKIN_DONGLE is not set
+# CONFIG_ACT200L_DONGLE is not set
+# CONFIG_KINGSUN_DONGLE is not set
+# CONFIG_KSDAZZLE_DONGLE is not set
+# CONFIG_KS959_DONGLE is not set
+
+#
+# FIR device drivers
+#
+CONFIG_USB_IRDA=y
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_VLSI_FIR is not set
+# CONFIG_MCS_FIR is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCISMD=y
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+CONFIG_BT_HCIUART_ATH3K=y
+# CONFIG_BT_HCIUART_LL is not set
+CONFIG_BT_HCIUART_IBS=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_MSM_SLEEP is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_MSM_BT_POWER=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+CONFIG_LIB80211=y
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_BCM2079X=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_GENLOCK=y
+CONFIG_GENLOCK_MISCDEVICE=y
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+# CONFIG_SW_SYNC_USER is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_TSIF is not set
+# CONFIG_TSPP is not set
+# CONFIG_HAPTIC_ISA1200 is not set
+CONFIG_PMIC8XXX_VIBRATOR=y
+# CONFIG_ANDROID_VIBRATOR is not set
+# CONFIG_TOUCHSENSE_VIBRATOR is not set
+# CONFIG_PMIC8XXX_NFC is not set
+# CONFIG_PMIC8XXX_UPL is not set
+CONFIG_QSEECOM=y
+# CONFIG_QFP_FUSE is not set
+CONFIG_USB_HSIC_SMSC_HUB=y
+# CONFIG_BU52031NVX is not set
+CONFIG_UID_CPUTIME=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=y
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_SLIMPORT_ANX7808=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+CONFIG_DUMMY=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_MSM_RMNET is not set
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_MSM_RMNET_SMUX=y
+# CONFIG_QFEC is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_NE2K_PCI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_SMC91X=y
+# CONFIG_EPIC100 is not set
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_SMSC911X_ARCH_HOOKS is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=y
+CONFIG_SLHC=y
+CONFIG_SLIP_COMPRESSED=y
+# CONFIG_SLIP_SMART is not set
+CONFIG_SLIP_MODE_SLIP6=y
+# CONFIG_TR is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=y
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_USB_SIERRA_NET=y
+# CONFIG_USB_VL600 is not set
+CONFIG_MSM_RMNET_USB=y
+CONFIG_WLAN=y
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_LIBRA_SDIOIF is not set
+# CONFIG_ATH6K_LEGACY_EXT is not set
+CONFIG_WCNSS_CORE=m
+# CONFIG_ATH_COMMON is not set
+# CONFIG_BCMDHD is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+CONFIG_INPUT_LID=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+CONFIG_KEYBOARD_MATRIX=y
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_PMIC8XXX is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_QCIKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_QCITP is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+# CONFIG_TOUCHDISC_VTD518_SHINETSU is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MAXTOUCH is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_MSM_LEGACY is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_CY8C_TS is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_I2C_QC is not set
+# CONFIG_TOUCHSCREEN_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_LGE_COMMON is not set
+# CONFIG_TOUCHSCREEN_LGE_SYNAPTICS is not set
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=y
+CONFIG_WAKE_TIMEOUT=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PM8XXX_VIBRATOR is not set
+# CONFIG_INPUT_PMIC8XXX_PWRKEY is not set
+# CONFIG_INPUT_MMA8450 is not set
+CONFIG_INPUT_MPU3050=y
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_ISA1200_FF_MEMLESS is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_BOSCH_BMA150 is not set
+CONFIG_STM_LIS3DH=y
+# CONFIG_BMP18X is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+CONFIG_N_SMUX=y
+CONFIG_N_SMUX_LOOPBACK=y
+CONFIG_SMUX_CTL=y
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_FRANDOM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MSM is not set
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+# CONFIG_SERIAL_BCM_BT_LPM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_MSM_SMD is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+
+#
+# Diag Support
+#
+CONFIG_DIAG_CHAR=y
+
+#
+# DIAG traffic over USB
+#
+CONFIG_DIAG_OVER_USB=y
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC/SMUX support for DIAG
+#
+CONFIG_DIAGFWD_BRIDGE_CODE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_MSM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_MSM_ROTATOR=y
+CONFIG_MSM_ADSPRPC=y
+# CONFIG_MMC_GENERIC_CSDIO is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_MSM is not set
+CONFIG_I2C_QUP=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_QUP=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+CONFIG_SLIMBUS=y
+CONFIG_SLIMBUS_MSM_CTRL=y
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_MSM_V1 is not set
+CONFIG_GPIO_MSM_V2=y
+# CONFIG_GPIO_MSM_V3 is not set
+# CONFIG_GPIO_FSM9XXX is not set
+# CONFIG_GPIO_VX855 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+CONFIG_GPIO_SX150X=y
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_GPIO_PM8XXX=y
+CONFIG_GPIO_PM8XXX_MPP=y
+# CONFIG_GPIO_PM8XXX_RPC is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+CONFIG_CHARGER_SMB345=y
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_BATTERY_MSM is not set
+# CONFIG_BATTERY_MSM8X60 is not set
+# CONFIG_SMB137B_CHARGER is not set
+# CONFIG_SMB349_CHARGER is not set
+# CONFIG_BATTERY_BQ27520 is not set
+# CONFIG_BATTERY_BQ27541 is not set
+# CONFIG_PM8921_CHARGER is not set
+# CONFIG_PM8XXX_CCADC is not set
+# CONFIG_LTC4088_CHARGER is not set
+# CONFIG_PM8921_BMS is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_WIRELESS_CHARGER is not set
+# CONFIG_BATTERY_TEMP_CONTROL is not set
+CONFIG_BATTERY_ASUS_BQ27541=y
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+CONFIG_SENSORS_PM8XXX_ADC=y
+CONFIG_SENSORS_EPM_ADC=y
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_SENSORS_CAP1106=y
+CONFIG_CAP_SENSOR_RMNET_CTL=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+# CONFIG_THERMAL_MSM_POPMEM is not set
+# CONFIG_THERMAL_TSENS is not set
+CONFIG_THERMAL_TSENS8960=y
+# CONFIG_THERMAL_TSENS8974 is not set
+CONFIG_THERMAL_PM8XXX=y
+CONFIG_THERMAL_MONITOR=y
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_PMIC8058 is not set
+# CONFIG_PMIC8901 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MFD_PM8XXX=y
+CONFIG_MFD_PM8921_CORE=y
+CONFIG_MFD_PM8821_CORE=y
+# CONFIG_MFD_PM8018_CORE is not set
+CONFIG_MFD_PM8038_CORE=y
+CONFIG_MFD_PM8XXX_IRQ=y
+CONFIG_MFD_PM8821_IRQ=y
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_MFD_PM8XXX_DEBUG=y
+CONFIG_MFD_PM8XXX_PWM=y
+CONFIG_MFD_PM8XXX_MISC=y
+CONFIG_MFD_PM8XXX_SPK=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+CONFIG_WCD9304_CODEC=y
+CONFIG_WCD9310_CODEC=y
+# CONFIG_WCD9320_CODEC is not set
+# CONFIG_MFD_RC5T583 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_REGULATOR_PM8XXX=y
+CONFIG_REGULATOR_MSM_GPIO=y
+# CONFIG_REGULATOR_STUB is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_USER_RC_INPUT=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+CONFIG_IR_GPIO_CIR=y
+
+#
+# Qualcomm MSM Camera And Video
+#
+# CONFIG_MSM_CAMERA is not set
+# CONFIG_MSMB_CAMERA is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_VIDEOBUF2_DMA_SG=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_MSM_VCAP=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_V4L_PCI_DRIVERS=y
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_ZORAN is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_MSM_WFD=y
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+CONFIG_RADIO_IRIS=y
+# CONFIG_RADIO_IRIS_TRANSPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_STUB_POULSBO is not set
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_MSM_KGSL=y
+# CONFIG_MSM_KGSL_CFF_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_NO_IB_DUMP is not set
+# CONFIG_MSM_KGSL_PSTMRTMDMP_RB_HEX is not set
+CONFIG_MSM_KGSL_2D=y
+CONFIG_MSM_KGSL_DRM=y
+CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
+# CONFIG_MSM_KGSL_MMU_PAGE_FAULT is not set
+# CONFIG_MSM_KGSL_DISABLE_SHADOW_WRITES is not set
+CONFIG_MSM_KGSL_SIMPLE_GOV=y
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+CONFIG_FB_VIRTUAL=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_MSM_VIDC=y
+CONFIG_MSM_VIDC_1080P=y
+CONFIG_MSM_VIDC_VENC=y
+CONFIG_MSM_VIDC_VDEC=y
+# CONFIG_MSM_VIDC_CONTENT_PROTECTION is not set
+CONFIG_FB_MSM=y
+CONFIG_FB_MSM_BACKLIGHT=y
+# CONFIG_FB_MSM_LOGO is not set
+CONFIG_FB_MSM_LCDC_HW=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_FB_MSM_MDP_HW=y
+# CONFIG_MDP_DEBUG_FS is not set
+# CONFIG_FB_MSM_MDP22 is not set
+# CONFIG_FB_MSM_MDP30 is not set
+# CONFIG_FB_MSM_MDP31 is not set
+CONFIG_FB_MSM_MDP40=y
+# CONFIG_FB_MSM_MDSS is not set
+# CONFIG_FB_MSM_MDP_NONE is not set
+# CONFIG_FB_MSM_EBI2 is not set
+# CONFIG_FB_MSM_MDDI is not set
+CONFIG_FB_MSM_MIPI_DSI=y
+# CONFIG_FB_MSM_LCDC is not set
+# CONFIG_FB_MSM_LVDS is not set
+CONFIG_FB_MSM_OVERLAY=y
+CONFIG_FB_MSM_DTV=y
+# CONFIG_FB_MSM_EXTMDDI is not set
+# CONFIG_FB_MSM_TVOUT is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON_VGA is not set
+# CONFIG_FB_MSM_MDDI_ORISE is not set
+# CONFIG_FB_MSM_MDDI_QUICKVX is not set
+# CONFIG_FB_MSM_MDDI_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_PANEL is not set
+# CONFIG_FB_MSM_MIPI_DSI_TOSHIBA is not set
+# CONFIG_FB_MSM_MIPI_DSI_LGIT is not set
+# CONFIG_FB_MSM_MIPI_DSI_RENESAS is not set
+# CONFIG_FB_MSM_MIPI_DSI_SIMULATOR is not set
+CONFIG_FB_MSM_MIPI_DSI_NOVATEK=y
+CONFIG_FB_MSM_MIPI_DSI_LG=y
+CONFIG_FB_MSM_MIPI_DSI_JDI=y
+# CONFIG_FB_MSM_MIPI_DSI_ORISE is not set
+# CONFIG_FB_MSM_LCDC_ST15_WXGA is not set
+# CONFIG_FB_MSM_LCDC_ST15_PANEL is not set
+# CONFIG_FB_MSM_LCDC_PRISM_WVGA is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA is not set
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA is not set
+# CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335 is not set
+# CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT is not set
+# CONFIG_FB_MSM_LCDC_NT35582_WVGA is not set
+# CONFIG_FB_MSM_LCDC_WXGA is not set
+# CONFIG_FB_MSM_MIPI_LGIT_VIDEO_WXGA_PT is not set
+# CONFIG_FB_MSM_LVDS_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT is not set
+CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT=y
+CONFIG_FB_MSM_MIPI_LG_1080_HD_PT=y
+CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT=y
+# CONFIG_FB_MSM_MIPI_ORISE_VIDEO_720P_PT is not set
+# CONFIG_FB_MSM_MIPI_ORISE_CMD_720P_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35510_CMD_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35516_VIDEO_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_NT35516_CMD_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA is not set
+# CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO is not set
+CONFIG_FB_MSM_NO_MDP_PIPE_CTRL=y
+CONFIG_FB_MSM_OVERLAY0_WRITEBACK=y
+CONFIG_FB_MSM_OVERLAY1_WRITEBACK=y
+# CONFIG_FB_MSM_WRITEBACK_MSM_PANEL is not set
+CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE=y
+CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE=y
+CONFIG_FB_MSM_MIPI_JDI_CMD_MODE=y
+CONFIG_FB_MSM_EXT_INTERFACE_COMMON=y
+CONFIG_FB_MSM_HDMI_COMMON=y
+CONFIG_FB_MSM_HDMI_3D=y
+# CONFIG_FB_MSM_HDMI_ADV7520_PANEL is not set
+CONFIG_FB_MSM_HDMI_MSM_PANEL=y
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_DVI_SUPPORT is not set
+# CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT is not set
+# CONFIG_FB_MSM_HDMI_MHL_9244 is not set
+# CONFIG_FB_MSM_HDMI_MHL_8334 is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_M is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_J is not set
+# CONFIG_FB_MSM_TVOUT_PAL_BDGHIN is not set
+# CONFIG_FB_MSM_TVOUT_PAL_M is not set
+# CONFIG_FB_MSM_TVOUT_PAL_N is not set
+CONFIG_FB_MSM_TVOUT_NONE=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGB565 is not set
+# CONFIG_FB_MSM_DEFAULT_DEPTH_ARGB8888 is not set
+CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888 is not set
+# CONFIG_FB_MSM_EBI2_EPSON_S1D_QVGA_PANEL is not set
+# CONFIG_FB_MSM_EBI2_PANEL_DETECT is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_LM3530 is not set
+# CONFIG_BACKLIGHT_LM3533 is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+
+#
+# MSM SoC Audio support
+#
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=y
+CONFIG_SND_SOC_MSM_QDSP6_INTF=y
+# CONFIG_SND_SOC_MSM_QDSP6V2_INTF is not set
+CONFIG_SND_SOC_VOICE=y
+CONFIG_SND_SOC_QDSP6=y
+# CONFIG_SND_SOC_QDSP6V2 is not set
+CONFIG_SND_SOC_MSM8960=y
+# CONFIG_SND_SOC_DUAL_AMIC is not set
+CONFIG_ASUSTEK_HEADSET=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WCD9304=y
+CONFIG_SND_SOC_WCD9310=y
+CONFIG_SND_SOC_CS8427=y
+CONFIG_SND_SOC_MSM_STUB=y
+# CONFIG_SND_SOC_TPA2028D is not set
+CONFIG_SOUND_CONTROL_HAX_GPL=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=y
+# CONFIG_HOLTEK_FF is not set
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+CONFIG_HID_PRIMAX=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+# CONFIG_HID_WIIMOTE is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_USB_EHCI_MSM_HOST4=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_PEHCI_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_CSVT=y
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_QCOM_DIAG_BRIDGE=y
+# CONFIG_USB_QCOM_DIAG_BRIDGE_TEST is not set
+CONFIG_USB_QCOM_MDM_BRIDGE=y
+CONFIG_USB_QCOM_KS_BRIDGE=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+CONFIG_USB_GADGET_DEBUG_FILES=y
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_CI13XXX_PCI is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_LANGWELL is not set
+# CONFIG_USB_EG20T is not set
+CONFIG_USB_CI13XXX_MSM=y
+# CONFIG_USB_CI13XXX_MSM_HSIC is not set
+# CONFIG_USB_DWC3_MSM is not set
+# CONFIG_USB_MSM_72K is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_GADGET_SUPERSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+CONFIG_USB_CSW_HACK=y
+# CONFIG_USB_MSC_PROFILING is not set
+CONFIG_MODEM_SUPPORT=y
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+# CONFIG_USB_ANDROID_CDC_ECM is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_MSM_OTG_72K is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_MSM_OTG=y
+# CONFIG_USB_MSM_ACA is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_SECDISCARD is not set
+CONFIG_MMC_BLOCK_MINORS=32
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_BLOCK_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_MSM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MMC_MSM_SDC1_SUPPORT=y
+CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT=y
+# CONFIG_MMC_MSM_SDC2_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC3_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC3_POLLING is not set
+# CONFIG_MMC_MSM_SDC4_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC5_SUPPORT is not set
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_MSM_PDM is not set
+# CONFIG_LEDS_PMIC_MPP is not set
+# CONFIG_LEDS_MSM_TRICOLOR is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_CPLD is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_PM8XXX=y
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_MSM_PMIC is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+# CONFIG_LEDS_TRIGGER_SLEEP is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_SWITCH_FSA8008 is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_MSM is not set
+# CONFIG_RTC_DRV_MSM7X00A is not set
+CONFIG_RTC_DRV_PM8XXX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_CIF is not set
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_AEC is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_UIO_PCI_GENERIC is not set
+# CONFIG_UIO_NETX is not set
+CONFIG_UIO_MSM_SHAREDMEM=y
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_ET131X is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS_PSTOR is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_IIO is not set
+CONFIG_QCACHE=y
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_PERSISTENT_RAM=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+# CONFIG_ANDROID_SWITCH is not set
+# CONFIG_PHONE is not set
+# CONFIG_USB_WPAN_HCD is not set
+
+#
+# Qualcomm Atheros Prima WLAN module
+#
+CONFIG_PRIMA_WLAN=m
+# CONFIG_PRIMA_WLAN_BTAMP is not set
+CONFIG_PRIMA_WLAN_LFR=y
+CONFIG_PRIMA_WLAN_OKC=y
+# CONFIG_PRIMA_WLAN_11AC_HIGH_TP is not set
+# CONFIG_QCOM_VOWIFI_11R is not set
+CONFIG_CPUPOWER=y
+
+#
+# Qualcomm MSM specific device drivers
+#
+CONFIG_MSM_SSBI=y
+CONFIG_SPS=y
+# CONFIG_USB_BAM is not set
+CONFIG_SPS_SUPPORT_BAMDMA=y
+# CONFIG_SPS_SUPPORT_NDP_BAM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_MSM_IOMMU=y
+CONFIG_MSM_IOMMU_GPU_SYNC=y
+CONFIG_IOMMU_PGTABLES_L2=y
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_MOBICORE_SUPPORT is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_ACL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_CPU_FREQ_SWITCH_PROFILER is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_ENCRYPTED_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_ARM=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_LZ4=y
+CONFIG_CRYPTO_LZ4HC=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_QCRYPTO is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_QCEDEV is not set
+# CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff -urN flo-ElementalX-5.00/.version flo-ElementalX-5.00-patched/.version
--- flo-ElementalX-5.00/.version	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/.version	2016-06-03 17:56:07.000000000 +0000
@@ -0,0 +1 @@
+37
-
-                          The Linux IPMI Driver
-			  ---------------------
-			      Corey Minyard
-			  <minyard@mvista.com>
-			    <minyard@acm.org>
-
-The Intelligent Platform Management Interface, or IPMI, is a
-standard for controlling intelligent devices that monitor a system.
-It provides for dynamic discovery of sensors in the system and the
-ability to monitor the sensors and be informed when the sensor's
-values change or go outside certain boundaries.  It also has a
-standardized database for field-replaceable units (FRUs) and a watchdog
-timer.
-
-To use this, you need an interface to an IPMI controller in your
-system (called a Baseboard Management Controller, or BMC) and
-management software that can use the IPMI system.
-
-This document describes how to use the IPMI driver for Linux.  If you
-are not familiar with IPMI itself, see the web site at
-http://www.intel.com/design/servers/ipmi/index.htm.  IPMI is a big
-subject and I can't cover it all here!
-
-Configuration
--------------
-
-The Linux IPMI driver is modular, which means you have to pick several
-things to have it work right depending on your hardware.  Most of
-these are available in the 'Character Devices' menu then the IPMI
-menu.
-
-No matter what, you must pick 'IPMI top-level message handler' to use
-IPMI.  What you do beyond that depends on your needs and hardware.
-
-The message handler does not provide any user-level interfaces.
-Kernel code (like the watchdog) can still use it.  If you need access
-from userland, you need to select 'Device interface for IPMI' if you
-want access through a device driver.
-
-The driver interface depends on your hardware.  If your system
-properly provides the SMBIOS info for IPMI, the driver will detect it
-and just work.  If you have a board with a standard interface (These
-will generally be either "KCS", "SMIC", or "BT", consult your hardware
-manual), choose the 'IPMI SI handler' option.  A driver also exists
-for direct I2C access to the IPMI management controller.  Some boards
-support this, but it is unknown if it will work on every board.  For
-this, choose 'IPMI SMBus handler', but be ready to try to do some
-figuring to see if it will work on your system if the SMBIOS/APCI
-information is wrong or not present.  It is fairly safe to have both
-these enabled and let the drivers auto-detect what is present.
-
-You should generally enable ACPI on your system, as systems with IPMI
-can have ACPI tables describing them.
-
-If you have a standard interface and the board manufacturer has done
-their job correctly, the IPMI controller should be automatically
-detected (via ACPI or SMBIOS tables) and should just work.  Sadly,
-many boards do not have this information.  The driver attempts
-standard defaults, but they may not work.  If you fall into this
-situation, you need to read the section below named 'The SI Driver' or
-"The SMBus Driver" on how to hand-configure your system.
-
-IPMI defines a standard watchdog timer.  You can enable this with the
-'IPMI Watchdog Timer' config option.  If you compile the driver into
-the kernel, then via a kernel command-line option you can have the
-watchdog timer start as soon as it initializes.  It also have a lot
-of other options, see the 'Watchdog' section below for more details.
-Note that you can also have the watchdog continue to run if it is
-closed (by default it is disabled on close).  Go into the 'Watchdog
-Cards' menu, enable 'Watchdog Timer Support', and enable the option
-'Disable watchdog shutdown on close'.
-
-IPMI systems can often be powered off using IPMI commands.  Select
-'IPMI Poweroff' to do this.  The driver will auto-detect if the system
-can be powered off by IPMI.  It is safe to enable this even if your
-system doesn't support this option.  This works on ATCA systems, the
-Radisys CPI1 card, and any IPMI system that supports standard chassis
-management commands.
-
-If you want the driver to put an event into the event log on a panic,
-enable the 'Generate a panic event to all BMCs on a panic' option.  If
-you want the whole panic string put into the event log using OEM
-events, enable the 'Generate OEM events containing the panic string'
-option.
-
-Basic Design
-------------
-
-The Linux IPMI driver is designed to be very modular and flexible, you
-only need to take the pieces you need and you can use it in many
-different ways.  Because of that, it's broken into many chunks of
-code.  These chunks (by module name) are:
-
-ipmi_msghandler - This is the central piece of software for the IPMI
-system.  It handles all messages, message timing, and responses.  The
-IPMI users tie into this, and the IPMI physical interfaces (called
-System Management Interfaces, or SMIs) also tie in here.  This
-provides the kernelland interface for IPMI, but does not provide an
-interface for use by application processes.
-
-ipmi_devintf - This provides a userland IOCTL interface for the IPMI
-driver, each open file for this device ties in to the message handler
-as an IPMI user.
-
-ipmi_si - A driver for various system interfaces.  This supports KCS,
-SMIC, and BT interfaces.  Unless you have an SMBus interface or your
-own custom interface, you probably need to use this.
-
-ipmi_smb - A driver for accessing BMCs on the SMBus. It uses the
-I2C kernel driver's SMBus interfaces to send and receive IPMI messages
-over the SMBus.
-
-ipmi_watchdog - IPMI requires systems to have a very capable watchdog
-timer.  This driver implements the standard Linux watchdog timer
-interface on top of the IPMI message handler.
-
-ipmi_poweroff - Some systems support the ability to be turned off via
-IPMI commands.
-
-These are all individually selectable via configuration options.
-
-Note that the KCS-only interface has been removed.  The af_ipmi driver
-is no longer supported and has been removed because it was impossible
-to do 32 bit emulation on 64-bit kernels with it.
-
-Much documentation for the interface is in the include files.  The
-IPMI include files are:
-
-net/af_ipmi.h - Contains the socket interface.
-
-linux/ipmi.h - Contains the user interface and IOCTL interface for IPMI.
-
-linux/ipmi_smi.h - Contains the interface for system management interfaces
-(things that interface to IPMI controllers) to use.
-
-linux/ipmi_msgdefs.h - General definitions for base IPMI messaging.
-
-
-Addressing
-----------
-
-The IPMI addressing works much like IP addresses, you have an overlay
-to handle the different address types.  The overlay is:
-
-  struct ipmi_addr
-  {
-	int   addr_type;
-	short channel;
-	char  data[IPMI_MAX_ADDR_SIZE];
-  };
-
-The addr_type determines what the address really is.  The driver
-currently understands two different types of addresses.
-
-"System Interface" addresses are defined as:
-
-  struct ipmi_system_interface_addr
-  {
-	int   addr_type;
-	short channel;
-  };
-
-and the type is IPMI_SYSTEM_INTERFACE_ADDR_TYPE.  This is used for talking
-straight to the BMC on the current card.  The channel must be
-IPMI_BMC_CHANNEL.
-
-Messages that are destined to go out on the IPMB bus use the
-IPMI_IPMB_ADDR_TYPE address type.  The format is
-
-  struct ipmi_ipmb_addr
-  {
-	int           addr_type;
-	short         channel;
-	unsigned char slave_addr;
-	unsigned char lun;
-  };
-
-The "channel" here is generally zero, but some devices support more
-than one channel, it corresponds to the channel as defined in the IPMI
-spec.
-
-
-Messages
---------
-
-Messages are defined as:
-
-struct ipmi_msg
-{
-	unsigned char netfn;
-	unsigned char lun;
-	unsigned char cmd;
-	unsigned char *data;
-	int           data_len;
-};
-
-The driver takes care of adding/stripping the header information.  The
-data portion is just the data to be send (do NOT put addressing info
-here) or the response.  Note that the completion code of a response is
-the first item in "data", it is not stripped out because that is how
-all the messages are defined in the spec (and thus makes counting the
-offsets a little easier :-).
-
-When using the IOCTL interface from userland, you must provide a block
-of data for "data", fill it, and set data_len to the length of the
-block of data, even when receiving messages.  Otherwise the driver
-will have no place to put the message.
-
-Messages coming up from the message handler in kernelland will come in
-as:
-
-  struct ipmi_recv_msg
-  {
-	struct list_head link;
-
-	/* The type of message as defined in the "Receive Types"
-           defines above. */
-	int         recv_type;
-
-	ipmi_user_t      *user;
-	struct ipmi_addr addr;
-	long             msgid;
-	struct ipmi_msg  msg;
-
-	/* Call this when done with the message.  It will presumably free
-	   the message and do any other necessary cleanup. */
-	void (*done)(struct ipmi_recv_msg *msg);
-
-	/* Place-holder for the data, don't make any assumptions about
-	   the size or existence of this, since it may change. */
-	unsigned char   msg_data[IPMI_MAX_MSG_LENGTH];
-  };
-
-You should look at the receive type and handle the message
-appropriately.
-
-
-The Upper Layer Interface (Message Handler)
--------------------------------------------
-
-The upper layer of the interface provides the users with a consistent
-view of the IPMI interfaces.  It allows multiple SMI interfaces to be
-addressed (because some boards actually have multiple BMCs on them)
-and the user should not have to care what type of SMI is below them.
-
-
-Creating the User
-
-To user the message handler, you must first create a user using
-ipmi_create_user.  The interface number specifies which SMI you want
-to connect to, and you must supply callback functions to be called
-when data comes in.  The callback function can run at interrupt level,
-so be careful using the callbacks.  This also allows to you pass in a
-piece of data, the handler_data, that will be passed back to you on
-all calls.
-
-Once you are done, call ipmi_destroy_user() to get rid of the user.
-
-From userland, opening the device automatically creates a user, and
-closing the device automatically destroys the user.
-
-
-Messaging
-
-To send a message from kernel-land, the ipmi_request() call does
-pretty much all message handling.  Most of the parameter are
-self-explanatory.  However, it takes a "msgid" parameter.  This is NOT
-the sequence number of messages.  It is simply a long value that is
-passed back when the response for the message is returned.  You may
-use it for anything you like.
-
-Responses come back in the function pointed to by the ipmi_recv_hndl
-field of the "handler" that you passed in to ipmi_create_user().
-Remember again, these may be running at interrupt level.  Remember to
-look at the receive type, too.
-
-From userland, you fill out an ipmi_req_t structure and use the
-IPMICTL_SEND_COMMAND ioctl.  For incoming stuff, you can use select()
-or poll() to wait for messages to come in.  However, you cannot use
-read() to get them, you must call the IPMICTL_RECEIVE_MSG with the
-ipmi_recv_t structure to actually get the message.  Remember that you
-must supply a pointer to a block of data in the msg.data field, and
-you must fill in the msg.data_len field with the size of the data.
-This gives the receiver a place to actually put the message.
-
-If the message cannot fit into the data you provide, you will get an
-EMSGSIZE error and the driver will leave the data in the receive
-queue.  If you want to get it and have it truncate the message, us
-the IPMICTL_RECEIVE_MSG_TRUNC ioctl.
-
-When you send a command (which is defined by the lowest-order bit of
-the netfn per the IPMI spec) on the IPMB bus, the driver will
-automatically assign the sequence number to the command and save the
-command.  If the response is not receive in the IPMI-specified 5
-seconds, it will generate a response automatically saying the command
-timed out.  If an unsolicited response comes in (if it was after 5
-seconds, for instance), that response will be ignored.
-
-In kernelland, after you receive a message and are done with it, you
-MUST call ipmi_free_recv_msg() on it, or you will leak messages.  Note
-that you should NEVER mess with the "done" field of a message, that is
-required to properly clean up the message.
-
-Note that when sending, there is an ipmi_request_supply_msgs() call
-that lets you supply the smi and receive message.  This is useful for
-pieces of code that need to work even if the system is out of buffers
-(the watchdog timer uses this, for instance).  You supply your own
-buffer and own free routines.  This is not recommended for normal use,
-though, since it is tricky to manage your own buffers.
-
-
-Events and Incoming Commands
-
-The driver takes care of polling for IPMI events and receiving
-commands (commands are messages that are not responses, they are
-commands that other things on the IPMB bus have sent you).  To receive
-these, you must register for them, they will not automatically be sent
-to you.
-
-To receive events, you must call ipmi_set_gets_events() and set the
-"val" to non-zero.  Any events that have been received by the driver
-since startup will immediately be delivered to the first user that
-registers for events.  After that, if multiple users are registered
-for events, they will all receive all events that come in.
-
-For receiving commands, you have to individually register commands you
-want to receive.  Call ipmi_register_for_cmd() and supply the netfn
-and command name for each command you want to receive.  You also
-specify a bitmask of the channels you want to receive the command from
-(or use IPMI_CHAN_ALL for all channels if you don't care).  Only one
-user may be registered for each netfn/cmd/channel, but different users
-may register for different commands, or the same command if the
-channel bitmasks do not overlap.
-
-From userland, equivalent IOCTLs are provided to do these functions.
-
-
-The Lower Layer (SMI) Interface
--------------------------------
-
-As mentioned before, multiple SMI interfaces may be registered to the
-message handler, each of these is assigned an interface number when
-they register with the message handler.  They are generally assigned
-in the order they register, although if an SMI unregisters and then
-another one registers, all bets are off.
-
-The ipmi_smi.h defines the interface for management interfaces, see
-that for more details.
-
-
-The SI Driver
--------------
-
-The SI driver allows up to 4 KCS or SMIC interfaces to be configured
-in the system.  By default, scan the ACPI tables for interfaces, and
-if it doesn't find any the driver will attempt to register one KCS
-interface at the spec-specified I/O port 0xca2 without interrupts.
-You can change this at module load time (for a module) with:
-
-  modprobe ipmi_si.o type=<type1>,<type2>....
-       ports=<port1>,<port2>... addrs=<addr1>,<addr2>...
-       irqs=<irq1>,<irq2>... trydefaults=[0|1]
-       regspacings=<sp1>,<sp2>,... regsizes=<size1>,<size2>,...
-       regshifts=<shift1>,<shift2>,...
-       slave_addrs=<addr1>,<addr2>,...
-       force_kipmid=<enable1>,<enable2>,...
-       kipmid_max_busy_us=<ustime1>,<ustime2>,...
-       unload_when_empty=[0|1]
-
-Each of these except si_trydefaults is a list, the first item for the
-first interface, second item for the second interface, etc.
-
-The si_type may be either "kcs", "smic", or "bt".  If you leave it blank, it
-defaults to "kcs".
-
-If you specify si_addrs as non-zero for an interface, the driver will
-use the memory address given as the address of the device.  This
-overrides si_ports.
-
-If you specify si_ports as non-zero for an interface, the driver will
-use the I/O port given as the device address.
-
-If you specify si_irqs as non-zero for an interface, the driver will
-attempt to use the given interrupt for the device.
-
-si_trydefaults sets whether the standard IPMI interface at 0xca2 and
-any interfaces specified by ACPE are tried.  By default, the driver
-tries it, set this value to zero to turn this off.
-
-The next three parameters have to do with register layout.  The
-registers used by the interfaces may not appear at successive
-locations and they may not be in 8-bit registers.  These parameters
-allow the layout of the data in the registers to be more precisely
-specified.
-
-The regspacings parameter give the number of bytes between successive
-register start addresses.  For instance, if the regspacing is set to 4
-and the start address is 0xca2, then the address for the second
-register would be 0xca6.  This defaults to 1.
-
-The regsizes parameter gives the size of a register, in bytes.  The
-data used by IPMI is 8-bits wide, but it may be inside a larger
-register.  This parameter allows the read and write type to specified.
-It may be 1, 2, 4, or 8.  The default is 1.
-
-Since the register size may be larger than 32 bits, the IPMI data may not
-be in the lower 8 bits.  The regshifts parameter give the amount to shift
-the data to get to the actual IPMI data.
-
-The slave_addrs specifies the IPMI address of the local BMC.  This is
-usually 0x20 and the driver defaults to that, but in case it's not, it
-can be specified when the driver starts up.
-
-The force_ipmid parameter forcefully enables (if set to 1) or disables
-(if set to 0) the kernel IPMI daemon.  Normally this is auto-detected
-by the driver, but systems with broken interrupts might need an enable,
-or users that don't want the daemon (don't need the performance, don't
-want the CPU hit) can disable it.
-
-If unload_when_empty is set to 1, the driver will be unloaded if it
-doesn't find any interfaces or all the interfaces fail to work.  The
-default is one.  Setting to 0 is useful with the hotmod, but is
-obviously only useful for modules.
-
-When compiled into the kernel, the parameters can be specified on the
-kernel command line as:
-
-  ipmi_si.type=<type1>,<type2>...
-       ipmi_si.ports=<port1>,<port2>... ipmi_si.addrs=<addr1>,<addr2>...
-       ipmi_si.irqs=<irq1>,<irq2>... ipmi_si.trydefaults=[0|1]
-       ipmi_si.regspacings=<sp1>,<sp2>,...
-       ipmi_si.regsizes=<size1>,<size2>,...
-       ipmi_si.regshifts=<shift1>,<shift2>,...
-       ipmi_si.slave_addrs=<addr1>,<addr2>,...
-       ipmi_si.force_kipmid=<enable1>,<enable2>,...
-       ipmi_si.kipmid_max_busy_us=<ustime1>,<ustime2>,...
-
-It works the same as the module parameters of the same names.
-
-By default, the driver will attempt to detect any device specified by
-ACPI, and if none of those then a KCS device at the spec-specified
-0xca2.  If you want to turn this off, set the "trydefaults" option to
-false.
-
-If your IPMI interface does not support interrupts and is a KCS or
-SMIC interface, the IPMI driver will start a kernel thread for the
-interface to help speed things up.  This is a low-priority kernel
-thread that constantly polls the IPMI driver while an IPMI operation
-is in progress.  The force_kipmid module parameter will all the user to
-force this thread on or off.  If you force it off and don't have
-interrupts, the driver will run VERY slowly.  Don't blame me,
-these interfaces suck.
-
-Unfortunately, this thread can use a lot of CPU depending on the
-interface's performance.  This can waste a lot of CPU and cause
-various issues with detecting idle CPU and using extra power.  To
-avoid this, the kipmid_max_busy_us sets the maximum amount of time, in
-microseconds, that kipmid will spin before sleeping for a tick.  This
-value sets a balance between performance and CPU waste and needs to be
-tuned to your needs.  Maybe, someday, auto-tuning will be added, but
-that's not a simple thing and even the auto-tuning would need to be
-tuned to the user's desired performance.
-
-The driver supports a hot add and remove of interfaces.  This way,
-interfaces can be added or removed after the kernel is up and running.
-This is done using /sys/modules/ipmi_si/parameters/hotmod, which is a
-write-only parameter.  You write a string to this interface.  The string
-has the format:
-   <op1>[:op2[:op3...]]
-The "op"s are:
-   add|remove,kcs|bt|smic,mem|i/o,<address>[,<opt1>[,<opt2>[,...]]]
-You can specify more than one interface on the line.  The "opt"s are:
-   rsp=<regspacing>
-   rsi=<regsize>
-   rsh=<regshift>
-   irq=<irq>
-   ipmb=<ipmb slave addr>
-and these have the same meanings as discussed above.  Note that you
-can also use this on the kernel command line for a more compact format
-for specifying an interface.  Note that when removing an interface,
-only the first three parameters (si type, address type, and address)
-are used for the comparison.  Any options are ignored for removing.
-
-The SMBus Driver
-----------------
-
-The SMBus driver allows up to 4 SMBus devices to be configured in the
-system.  By default, the driver will register any SMBus interfaces it finds
-in the I2C address range of 0x20 to 0x4f on any adapter.  You can change this
-at module load time (for a module) with:
-
-  modprobe ipmi_smb.o
-	addr=<adapter1>,<i2caddr1>[,<adapter2>,<i2caddr2>[,...]]
-	dbg=<flags1>,<flags2>...
-	[defaultprobe=1] [dbg_probe=1]
-
-The addresses are specified in pairs, the first is the adapter ID and the
-second is the I2C address on that adapter.
-
-The debug flags are bit flags for each BMC found, they are:
-IPMI messages: 1, driver state: 2, timing: 4, I2C probe: 8
-
-Setting smb_defaultprobe to zero disabled the default probing of SMBus
-interfaces at address range 0x20 to 0x4f.  This means that only the
-BMCs specified on the smb_addr line will be detected.
-
-Setting smb_dbg_probe to 1 will enable debugging of the probing and
-detection process for BMCs on the SMBusses.
-
-Discovering the IPMI compliant BMC on the SMBus can cause devices
-on the I2C bus to fail. The SMBus driver writes a "Get Device ID" IPMI
-message as a block write to the I2C bus and waits for a response.
-This action can be detrimental to some I2C devices. It is highly recommended
-that the known I2c address be given to the SMBus driver in the smb_addr
-parameter. The default address range will not be used when a smb_addr
-parameter is provided.
-
-When compiled into the kernel, the addresses can be specified on the
-kernel command line as:
-
-  ipmb_smb.addr=<adapter1>,<i2caddr1>[,<adapter2>,<i2caddr2>[,...]]
-	ipmi_smb.dbg=<flags1>,<flags2>...
-	ipmi_smb.defaultprobe=0 ipmi_smb.dbg_probe=1
-
-These are the same options as on the module command line.
-
-Note that you might need some I2C changes if CONFIG_IPMI_PANIC_EVENT
-is enabled along with this, so the I2C driver knows to run to
-completion during sending a panic event.
-
-
-Other Pieces
-------------
-
-Get the detailed info related with the IPMI device
---------------------------------------------------
-
-Some users need more detailed information about a device, like where
-the address came from or the raw base device for the IPMI interface.
-You can use the IPMI smi_watcher to catch the IPMI interfaces as they
-come or go, and to grab the information, you can use the function
-ipmi_get_smi_info(), which returns the following structure:
-
-struct ipmi_smi_info {
-	enum ipmi_addr_src addr_src;
-	struct device *dev;
-	union {
-		struct {
-			void *acpi_handle;
-		} acpi_info;
-	} addr_info;
-};
-
-Currently special info for only for SI_ACPI address sources is
-returned.  Others may be added as necessary.
-
-Note that the dev pointer is included in the above structure, and
-assuming ipmi_smi_get_info returns success, you must call put_device
-on the dev pointer.
-
-
-Watchdog
---------
-
-A watchdog timer is provided that implements the Linux-standard
-watchdog timer interface.  It has three module parameters that can be
-used to control it:
-
-  modprobe ipmi_watchdog timeout=<t> pretimeout=<t> action=<action type>
-      preaction=<preaction type> preop=<preop type> start_now=x
-      nowayout=x ifnum_to_use=n
-
-ifnum_to_use specifies which interface the watchdog timer should use.
-The default is -1, which means to pick the first one registered.
-
-The timeout is the number of seconds to the action, and the pretimeout
-is the amount of seconds before the reset that the pre-timeout panic will
-occur (if pretimeout is zero, then pretimeout will not be enabled).  Note
-that the pretimeout is the time before the final timeout.  So if the
-timeout is 50 seconds and the pretimeout is 10 seconds, then the pretimeout
-will occur in 40 second (10 seconds before the timeout).
-
-The action may be "reset", "power_cycle", or "power_off", and
-specifies what to do when the timer times out, and defaults to
-"reset".
-
-The preaction may be "pre_smi" for an indication through the SMI
-interface, "pre_int" for an indication through the SMI with an
-interrupts, and "pre_nmi" for a NMI on a preaction.  This is how
-the driver is informed of the pretimeout.
-
-The preop may be set to "preop_none" for no operation on a pretimeout,
-"preop_panic" to set the preoperation to panic, or "preop_give_data"
-to provide data to read from the watchdog device when the pretimeout
-occurs.  A "pre_nmi" setting CANNOT be used with "preop_give_data"
-because you can't do data operations from an NMI.
-
-When preop is set to "preop_give_data", one byte comes ready to read
-on the device when the pretimeout occurs.  Select and fasync work on
-the device, as well.
-
-If start_now is set to 1, the watchdog timer will start running as
-soon as the driver is loaded.
-
-If nowayout is set to 1, the watchdog timer will not stop when the
-watchdog device is closed.  The default value of nowayout is true
-if the CONFIG_WATCHDOG_NOWAYOUT option is enabled, or false if not.
-
-When compiled into the kernel, the kernel command line is available
-for configuring the watchdog:
-
-  ipmi_watchdog.timeout=<t> ipmi_watchdog.pretimeout=<t>
-	ipmi_watchdog.action=<action type>
-	ipmi_watchdog.preaction=<preaction type>
-	ipmi_watchdog.preop=<preop type>
-	ipmi_watchdog.start_now=x
-	ipmi_watchdog.nowayout=x
-
-The options are the same as the module parameter options.
-
-The watchdog will panic and start a 120 second reset timeout if it
-gets a pre-action.  During a panic or a reboot, the watchdog will
-start a 120 timer if it is running to make sure the reboot occurs.
-
-Note that if you use the NMI preaction for the watchdog, you MUST NOT
-use the nmi watchdog.  There is no reasonable way to tell if an NMI
-comes from the IPMI controller, so it must assume that if it gets an
-otherwise unhandled NMI, it must be from IPMI and it will panic
-immediately.
-
-Once you open the watchdog timer, you must write a 'V' character to the
-device to close it, or the timer will not stop.  This is a new semantic
-for the driver, but makes it consistent with the rest of the watchdog
-drivers in Linux.
-
-
-Panic Timeouts
---------------
-
-The OpenIPMI driver supports the ability to put semi-custom and custom
-events in the system event log if a panic occurs.  if you enable the
-'Generate a panic event to all BMCs on a panic' option, you will get
-one event on a panic in a standard IPMI event format.  If you enable
-the 'Generate OEM events containing the panic string' option, you will
-also get a bunch of OEM events holding the panic string.
-
-
-The field settings of the events are:
-* Generator ID: 0x21 (kernel)
-* EvM Rev: 0x03 (this event is formatting in IPMI 1.0 format)
-* Sensor Type: 0x20 (OS critical stop sensor)
-* Sensor #: The first byte of the panic string (0 if no panic string)
-* Event Dir | Event Type: 0x6f (Assertion, sensor-specific event info)
-* Event Data 1: 0xa1 (Runtime stop in OEM bytes 2 and 3)
-* Event data 2: second byte of panic string
-* Event data 3: third byte of panic string
-See the IPMI spec for the details of the event layout.  This event is
-always sent to the local management controller.  It will handle routing
-the message to the right place
-
-Other OEM events have the following format:
-Record ID (bytes 0-1): Set by the SEL.
-Record type (byte 2): 0xf0 (OEM non-timestamped)
-byte 3: The slave address of the card saving the panic
-byte 4: A sequence number (starting at zero)
-The rest of the bytes (11 bytes) are the panic string.  If the panic string
-is longer than 11 bytes, multiple messages will be sent with increasing
-sequence numbers.
-
-Because you cannot send OEM events using the standard interface, this
-function will attempt to find an SEL and add the events there.  It
-will first query the capabilities of the local management controller.
-If it has an SEL, then they will be stored in the SEL of the local
-management controller.  If not, and the local management controller is
-an event generator, the event receiver from the local management
-controller will be queried and the events sent to the SEL on that
-device.  Otherwise, the events go nowhere since there is nowhere to
-send them.
-
-
-Poweroff
---------
-
-If the poweroff capability is selected, the IPMI driver will install
-a shutdown function into the standard poweroff function pointer.  This
-is in the ipmi_poweroff module.  When the system requests a powerdown,
-it will send the proper IPMI commands to do this.  This is supported on
-several platforms.
-
-There is a module parameter named "poweroff_powercycle" that may
-either be zero (do a power down) or non-zero (do a power cycle, power
-the system off, then power it on in a few seconds).  Setting
-ipmi_poweroff.poweroff_control=x will do the same thing on the kernel
-command line.  The parameter is also available via the proc filesystem
-in /proc/sys/dev/ipmi/poweroff_powercycle.  Note that if the system
-does not support power cycling, it will always do the power off.
-
-The "ifnum_to_use" parameter specifies which interface the poweroff
-code should use.  The default is -1, which means to pick the first one
-registered.
-
-Note that if you have ACPI enabled, the system will prefer using ACPI to
-power off.
diff -urN flo-ElementalX-5.00/Documentation/firmware_class/README flo-ElementalX-5.00-patched/Documentation/firmware_class/README
--- flo-ElementalX-5.00/Documentation/firmware_class/README	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Documentation/firmware_class/README	2016-06-01 15:47:50.000000000 +0000
@@ -106,3 +106,10 @@
    on the setup, so I think that the choice on what firmware to make
    persistent should be left to userspace.
 
+ about firmware cache:
+ --------------------
+ After firmware cache mechanism is introduced during system sleep,
+ request_firmware can be called safely inside device's suspend and
+ resume callback, and callers need't cache the firmware by
+ themselves any more for dealing with firmware loss during system
+ resume.
diff -urN flo-ElementalX-5.00/Makefile flo-ElementalX-5.00-patched/Makefile
--- flo-ElementalX-5.00/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/Makefile	2016-06-01 15:49:10.000000000 +0000
@@ -245,7 +245,7 @@
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS   = -O2 -fomit-frame-pointer
 HOSTCXXFLAGS = -O2
 
 # Decide whether to build built-in, modular, or both.
@@ -351,10 +351,10 @@
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
 		  -Wbitwise -Wno-return-void $(CF)
-CFLAGS_MODULE   =
+CFLAGS_MODULE   = -fno-pic -fno-common
 AFLAGS_MODULE   =
 LDFLAGS_MODULE  =
-CFLAGS_KERNEL	= -munaligned-access -fgcse-lm -fgcse-sm -fsched-spec-load -ffast-math -fsingle-precision-constant -mtune=cortex-a15 -mtune=cortex-a15 -marm -mfpu=neon-vfpv4 -funroll-loops
+CFLAGS_KERNEL	= -fgcse-lm -fgcse-sm -fsched-spec-load -ffast-math -fsingle-precision-constant -mtune=cortex-a15 -mtune=cortex-a15 -marm -mfpu=neon-vfpv4 -funroll-loops
 AFLAGS_KERNEL	=
 CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
 
@@ -368,11 +368,7 @@
 
 KBUILD_CPPFLAGS := -D__KERNEL__
 
-KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-		   -fno-strict-aliasing -fno-common \
-		   -Werror-implicit-function-declaration \
-		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+KBUILD_CFLAGS   := -fno-strict-aliasing -fno-common -fno-delete-null-pointer-checks
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
+0x00000000	cfg80211_send_rx_assoc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_allocate_contiguous_memory_nomap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_invalidate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_page_cache_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_platform_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_put_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	FsMountVol	vmlinux	EXPORT_SYMBOL
+0x00000000	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	register_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_read	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_session_find_by_ifname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_of_parse_audio_routing	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	decode_rs8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_event_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drain_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_get_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_grab	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_write_bulk_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_validate_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x00000000	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	g_token_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_graft_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_fb_get_bpp_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	subsystem_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	put_ashmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_put_device	vmlinux	EXPORT_SYMBOL
+0x00000000	input_handler_for_each_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_videomode_to_var	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_clean	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	mount_subtree	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_put_enum_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_enum_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_keyring	vmlinux	EXPORT_SYMBOL
+0x00000000	_clear_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_handle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_keyup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_get_device_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_decode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_power_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reset_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_dma_free_bam_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_app_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bus_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_last	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_string	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_iommu_map_contig_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	memmove	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_d_lookup_sb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x00000000	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_crypto_ahash_setkey	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_add_pins	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_cdc_unbind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_subsystem_check_iova_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	return_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_codec_stream_event	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_map_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_find_ltk_by_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_put_meminfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fmem_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x00000000	register_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_fill_dv_preset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_gpio_request	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_quick_get_max	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_retry_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_lock_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	__krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	prof_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_fini	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_gadget_map_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_drop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_unprep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_map_attachment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_class	vmlinux	EXPORT_SYMBOL
+0x00000000	load_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x00000000	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_use_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_detach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_compress_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_open	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pppox_proto	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_set_autosuspend_delay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_group_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoull_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_init_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_new_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_remove_bad_delegation	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_load	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_set_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_rcv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	private_AES_set_decrypt_key	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l4proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dapm_mark_dirty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_deregister_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fill_in_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x00000000	task_handoff_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_tun_dev_create	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_route_child_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_stop_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_iter_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_try_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_buf_from_iov	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pre_hwaccess	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_default_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_new_subdev_board	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_read_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_notify_new_peer_candidate	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__ashrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__lshrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_states	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_rfree	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_map_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_long	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_usbmidi_create	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_takedown	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_msi_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_rs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsSyncVol	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pgprot_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_set_num_threads	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_parse_nat_setup_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_do_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wake_lock_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	walk_stackframe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_force_enable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial_copy_nocheck	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	register_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_test_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_interrupt_hpi	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	init_request_from_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_wait_for_buffer_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arpt_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_queryctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	free_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_get_by_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_sync_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_master_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_global_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_it_nexus_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_allocate_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	key_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_reserve_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_wifi_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_suspend_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	backlight_force_update	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_reset_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	mktime	vmlinux	EXPORT_SYMBOL
+0x00000000	system_state	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_ioctl_0	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_query_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_info	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mem_entry_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_diag_bc_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__qdisc_calculate_pkt_len	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_xfer_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_unmap_attachment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_power_restore_host	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_force_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_find_continuous	vmlinux	EXPORT_SYMBOL
+0x00000000	__next_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	keyring_search	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_remove_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_register_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_nowake_buffer_unlock_commit_regs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_calc_bclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_insert_addr_table_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_pptp_hook_expectfn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_wait_for_req	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_init_spi	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_init_i2c	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_lasr	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_llsr	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_next	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflate	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_get_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drain_output	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_set_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_request_send_background	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__ftrace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_delete_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_any	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_nrt_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_inq_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_conntrack_confirm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_dev_fop_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_use_dummy_regulator	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_register_core	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_enable_read_intr	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_end_reset_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_reinject	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_add_host	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_remote_mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_set_boot_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	__csum_ipv6_magic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_unregister_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_msglevel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_msglevel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_alloc_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_pages_exact_nid	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_create_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_prepare_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	rps_may_expire_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_unmap_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_unload_default_node	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_gss_principal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_unlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_discovery_request	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_set_pll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_in_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	module_refcount	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_destroy_cache_detail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_create_from_cmdline_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_store_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_edge_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pm_set_max_sleep_time	vmlinux	EXPORT_SYMBOL
+0x00000000	get_ashmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_threshold_set	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_new	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_match_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	strsep	vmlinux	EXPORT_SYMBOL
+0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cleancache_invalidate_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_add	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_get_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0x00000000	end_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_create	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_conflicting_framebuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__ablkcipher_walk_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_get_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_deferrable_timer_on_stack_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ipc_router_security_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_unregister_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_input_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_get_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	__kernel_param_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_invert_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_unsigned	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockd_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_default_writable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x00000000	migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_note_context_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_map_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_do_cache_op	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commit_release_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_new	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_assume_removable	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_thaw_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_dev_find	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_list	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_put_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_data_from_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_restore_msi_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_disable_read_intr	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_extract_all	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_info_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reserve_pmu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_get_by_OID	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_create	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_bulk_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_physpages	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_unregister_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_pipeline_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_get_ch_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_str	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_crtc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_vpd_find_info_keyword	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_mpp_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_symbols_seq_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_reason	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_update_classid	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lzo1x_1_compress	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_check_for_modem_crash	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_limit_volume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_read_arg_group	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_handle_create	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_cleanup_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_dmov_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_sched_scan_results	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_device_release	vmlinux	EXPORT_SYMBOL
+0x00000000	FsTruncateFile	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_rule_noresample	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_querymenu	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_pci_free	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_get_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_hdrlen_from_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_module_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_dealloc_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i2c_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	textsearch_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_contiguous_ebi_nomap	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_msbits	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register_subdev_nodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qseecom_send_command	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secmark_relabel_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pci_quirk_lookup_id	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_create	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_create_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_leave	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_put_decimal_ull	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_next_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_string_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_idlelock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_init	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rotator_imem_allocate	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msleep	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_open	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
+0x00000000	__audit_inode_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_reserve_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_h225_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_map_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_destroy_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_unthrottle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pppox_proto	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_set_mmutype	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_get_mmutype	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_activate_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_submit_read_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_sync_region	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_allow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_secure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_option	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_vpd_find_tag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_augment_erase_end	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_attach_encoder	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_apcs_set_phase	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_ablkcipher_request_free	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_size	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_activate	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_detachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	task_free_register	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_user_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	thread_notify_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_get_platform_device	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	irttp_data_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_data_request	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	list_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_wait_for_all_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup	vmlinux	EXPORT_SYMBOL
+0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_vpd_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_is_call_available	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	xc4000_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	xc5000_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	_kstrtol	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_cmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	sound_class	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_close_slim_sch_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_close_slim_sch_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_setsize	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	system_nrt_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svcauth_gss_flavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svcauth_gss_register_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_busy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_set_algo_params	vmlinux	EXPORT_SYMBOL
+0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_scope	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_nway_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pmem_file	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_comm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_bint	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	task_free_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_global_item_unref	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	would_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_usbmidi_input_start	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_get_name	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_max_seg_size	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_batch	vmlinux	EXPORT_SYMBOL
+0x00000000	d_path	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_free_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cmdbatch_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	igrab	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_set_runtime_hwparams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_open_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_secure_erase_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unmap_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_get_slaveport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3protos	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	sweep2wake_setdev	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_optimum_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_get_video_format_from_drv_data	vmlinux	EXPORT_SYMBOL
+0x00000000	__rcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_read_line	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_debugfs_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_slot_state	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_readl	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_queue_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_subdev_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_subdev_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	AES_decrypt	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_default_rule_pref	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_period_elapsed	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_av_sync_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_domain_xlate_twocell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_domain_xlate_onecell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_iommu_get_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_interface_reg_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_request_and_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_start	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_cluster	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sget	vmlinux	EXPORT_SYMBOL
+0x00000000	memset	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_send_sco	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_pkts_acked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_calc_frame_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_event_pending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sw_hweight8	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_event	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_setstate	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	d_set_d_op	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_integer_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_update_netprioidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_drain	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_erase_group_aligned	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_disable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_try_attach_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_logging_level	vmlinux	EXPORT_SYMBOL
+0x00000000	regcache_mark_dirty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in	vmlinux	EXPORT_SYMBOL
+0x00000000	hwrng_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_idle_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__css_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_need_gre	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_hs_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_mmc_packing_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_close	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_end_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_put_sb_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mac_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_cache_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	slimport_read_edid_block	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_put	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_restore_state	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_enable_xhci_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_unreg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_std	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_it_nexus_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_claim_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_register_net_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_control_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_video_std_frame_period	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_select_eld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_add_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_wake_pending_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_accept_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_unregister_action	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_wait_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_parse_opts_str	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_lcd_type	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_close	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_detach_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_prev	vmlinux	EXPORT_SYMBOL
+0x00000000	user_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key_async_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_unlink_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_handoff_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_print_regs32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_ramdump_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_ignore_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	leds_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_postmortem_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_tw_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_flags_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_sysrq	vmlinux	EXPORT_SYMBOL
+0x00000000	_kstrtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_weak_routes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_queue_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_gpuaddr_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_err	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_owner_or_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_confirm	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super_thawed	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_get_security_rule	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_tx_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_add_zones	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_param_first	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_select_bars	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_subsystem_map_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create_pooled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_vibrator_config	vmlinux	EXPORT_SYMBOL
+0x00000000	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_dai_substream	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_snd_pcm_lib_alloc_vmalloc_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_create_kernel_counter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_idle_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_invert_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_s_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_mode_to_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_set_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	FsLookupFile	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_delete_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dput	vmlinux	EXPORT_SYMBOL
+0x00000000	try_module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	is_container_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_set_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_delay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_bulk_write_raw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fill_inquiry_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_uidivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_free_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_pre_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_hdrlen	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_norm_to_name	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_valid_only_mem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irias_new_integer_value	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_enum_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_flush_dcache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_idlelock_take	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_vddrange_to_ocrmask	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_suspended	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	sha1_update_arm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_push	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_f0_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_run_queue_async	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
+0x00000000	free_task	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_del_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_min_io	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_disconnect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_disconnect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_release_host	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_put_task_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_set_cbits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_untracked_status_or	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_jack_set_key	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_common_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_phy_device	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mh_intrcallback	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight32	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight16	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight64	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_prealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_skip_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_user	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_exit_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_set_adcmap_ntcg_104ef_104fb	vmlinux	EXPORT_SYMBOL
+0x00000000	external_common_state_hpd_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_rpc_get_sym	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_start	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_getvaluebyclass_request	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_reg_access	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_clkdiv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_blink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memchr_inv	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_modify_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_preload_dVdd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_class_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_destroy_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_clone_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ion_secure_heap_2_0	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_tryget	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gtf_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_count_voltages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_find_any_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_event_reg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_attach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_detach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrstate_to_str	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	unload_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_set_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_rtp_rtcp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_repeat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_run_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	mhl_connect_api	vmlinux	EXPORT_SYMBOL
+0x00000000	bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memset_io	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_get_mapinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_register_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_process_call	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iput	vmlinux	EXPORT_SYMBOL
+0x00000000	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_complete_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_low	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_sync_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_open	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alter_reply	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_update_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_prime_destroy_file_private	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_firmware_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_change	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_blocks_per_page	vmlinux	EXPORT_SYMBOL
+0x00000000	iterate_supers_type	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_handle_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	genericbl_limit_intensity	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_unlink_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_change_features	vmlinux	EXPORT_SYMBOL
+0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_resize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_drvinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_msi	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_write_space	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_mode_is_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_get_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sb_set_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_params_to_frame_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_store_edge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	suspend_set_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pil_force_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timerqueue_iterate_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_iosched_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_put_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_audio_packet_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	in4_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfb_copyarea	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_unmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mh_start	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_to_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_write	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_next_chunk	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	do_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_handler_data	vmlinux	EXPORT_SYMBOL
+0x00000000	yield_to	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_channel_to_frequency	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_media	vmlinux	EXPORT_SYMBOL
+0x00000000	user_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	test_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	__udivsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_info_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus_parented	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_init_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_check_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_context_init	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_insert_node	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_term	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aes_expand_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_map	vmlinux	EXPORT_SYMBOL
+0x00000000	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_reg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l3proto_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_release_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_wait_for_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_round_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_encoder_name	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_taskset_cur_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cad_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	cacheid	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou8	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_component_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_ebimem_user	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pp_interrupt_out_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6t_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tuner_count	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsWriteFile	vmlinux	EXPORT_SYMBOL
+0x00000000	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_axi_porthalt	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_min_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_high	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_unique_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_mangle_udp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_get_pin_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_get_contig_userptr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_add_target_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	follow_down_one	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_init_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_iprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create_memless	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_unprep_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_get_monotonic_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_shift_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_options_rcv_srr	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_add_numbered_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_early_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tasklet_init	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_setup_info	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_rtd_stream_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_undo_access	vmlinux	EXPORT_SYMBOL
+0x00000000	stop_machine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_unlink_expect_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_register_pm_ops	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xt_unregister_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_watchdog_cancel	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_register_bam_device	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_remove_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_get_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_authenticate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_register_service	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_new	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_cdc_wdm_register	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	complete	vmlinux	EXPORT_SYMBOL
+0x00000000	downgrade_write	vmlinux	EXPORT_SYMBOL
+0x00000000	get_mem_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_check_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_mmap_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_response_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_lookup_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_xmit_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_new_stream	vmlinux	EXPORT_SYMBOL
+0x00000000	otg_state_string	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_update_name_case	vmlinux	EXPORT_SYMBOL
+0x00000000	high_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_call_function_many	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_l2_set_low_power_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_check_arch	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_free_gpios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_get_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	mc44s803_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_link	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_bh_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidinput_find_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_put_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clkdev_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_cvt_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_section	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig_info	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	show_class_attr_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	allow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_info_select	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_register	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_frame_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_set_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_connect_response	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_connect_response	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_delete_from_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_platform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_output_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_buf_subsegment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_err	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_put_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_idle_time_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_alt_setting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	key_type_encrypted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_pipe_buf_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_steal	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_find	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_printk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_put	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_reset_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0x00000000	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_put_vma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_port_get_xfer_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	div64_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_merge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	d_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_coincell_chg_config	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	mntget	vmlinux	EXPORT_SYMBOL
+0x00000000	mntput	vmlinux	EXPORT_SYMBOL
+0x00000000	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcookie_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_table_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_exts_dump_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_dump	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__request_module	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_deactivate	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_platform_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	avs_set_avsdscr	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_get_avsdscr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_spi_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_unlock_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_unregister_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__first_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_force_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_peek_r	vmlinux	EXPORT_SYMBOL
+0x00000000	print_ssid	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4hc_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsReadStat	vmlinux	EXPORT_SYMBOL
+0x00000000	__rpc_wait_for_completion_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_start	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dirty_info_property	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_free_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_regulator_set_ocr	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_mhl_get_supported_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	event_storage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_wrap_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	rename_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_usb_id_pullup	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_hsed_bias_control	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_inode_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_contiguous_ebi	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_set_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_tcp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_blink_set	vmlinux	EXPORT_SYMBOL
+0x00000000	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_check_and_unmask_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_remain_on_channel_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_change_link_key	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_ext_add	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_prot_clear_portaddr_nulls	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_find_nth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_unregister_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_volatile_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_cpuinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_async_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_ptpool_init	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_krait_need_wfe_fixup	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_get_fd_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	__readwrite_bug	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_register_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_io_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_link	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_alloc_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dynamic_pr_debug	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_policy_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_dump_one_icsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_report_raw_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tea5761_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_begin_cpu_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmclnt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fd_install	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_alloc_ahash	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	wcnss_reset_intr	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_nat_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_used_tuple	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_free	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_audio_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_put	vmlinux	EXPORT_SYMBOL
+0x00000000	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_put_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_irq_uninstall	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_set_clr_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sock_graft	vmlinux	EXPORT_SYMBOL
+0x00000000	key_reject_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_finish_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_recvmsg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsens_get_temp	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_master_put	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_check_send_permissions	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_device_free	vmlinux	EXPORT_SYMBOL
+0x00000000	regcache_cache_bypass	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_cpufreq_set_freq_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_ctrl_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlap_open	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_open	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlap_close	vmlinux	EXPORT_SYMBOL
+0x00000000	iriap_close	vmlinux	EXPORT_SYMBOL
+0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_step	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_unregister_entity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_busnum_to_ctrl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_hard_reset_config	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_framebuffer_init	vmlinux	EXPORT_SYMBOL
+0x00000000	register_early_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_find_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_pseudoflavor_to_service	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_pptp_hook_inbound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l4proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_grow	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_ion_status	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_simple_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfulnl_log_packet	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_find_device_by_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_commit_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__per_cpu_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_sig_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_virt_to_phys	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcg_get_weight	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	event_storage_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_plane_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0x00000000	d_clear_need_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read	vmlinux	EXPORT_SYMBOL
+0x00000000	km_report	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x00000000	d_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_close	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_mhl_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	path_is_under	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_hook_unlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_set_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_quick_get	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_underlying_device_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	smb345_charger_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_sample_rate_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_set	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_physical_width	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_platform_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_clock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_dcache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_querymenu	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_to_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_add_numbered_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	filter_current_check_discard	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_seq_adjust_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_hold_time_set	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_search_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_enable_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_change_overwrite	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_put_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	async_unwrap_char	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_pll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremapfree	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_install	vmlinux	EXPORT_SYMBOL
+0x00000000	__kunmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipefs_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_del_global	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add_global	vmlinux	EXPORT_SYMBOL
+0x00000000	videobuf2_pmem_contig_mmap_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_global_item_ref	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_framebuffer_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fifo_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mfd_cell_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_count_and_time	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_virt_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_proto_nlattr_to_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inetpeer_invalidate_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_powers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	qword_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_preallocate_pages_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_free_req	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_remove_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_remove_item	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_off	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_state_notfound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidinput_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	baswap	vmlinux	EXPORT_SYMBOL
+0x00000000	tun_get_socket	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_noflush_suspending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_hs_set_mctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_ltr_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	up_write	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_release	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_open	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_cpu_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_cpu_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_remember	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_put_block	vmlinux	EXPORT_SYMBOL
+0x00000000	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	fget	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_io_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_boolean_mono_info	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_log_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_apcs_set_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_info_free	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_of_parse_card_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_frequency_table_get_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_put_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	match_token	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_abort	vmlinux	EXPORT_SYMBOL
+0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x00000000	__ftrace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_write	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_change_intr_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_frequency_to_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_add_card_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_pages_to_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	key_type_logon	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_remove_expectations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_cache_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc16	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_on_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_power	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_tproxy_assign_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_unicast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_iova_to_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_hide_latency_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_get_last_vbltimestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_intx_mask_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bsearch	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_set_test_result	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x00000000	FsRemoveDir	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_throttle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_ebimem	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_in	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_free_for_all	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_flow_off	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_map_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_register_board_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_setbufsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbhid_set_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_purge_paused_rxq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	color_table	vmlinux	EXPORT_SYMBOL
+0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_find_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_cpu_rmap_add	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_split	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_invalidate_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_tiocmset_from_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_add_modes_noedid	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_ref_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_enqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_set_iommu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sitar_hs_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_mmap_pfn_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_target_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_peek	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_request_find_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	microtune_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_add_blkio_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_nr_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_duplicate	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_ahash_digest	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	drm_mm_get_block_range_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	vt_get_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	save_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_set_hashsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_qbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_usercopy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	free_contiguous_memory_by_paddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_socket_getpeersec_dgram	vmlinux	EXPORT_SYMBOL
+0x00000000	set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	set_timer_slack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_alloc_endpoint	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_diag_alloc_req	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_notifysecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_info_init	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_nat_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdio_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_common_supported_video_mode_lut	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_uart_gpio_mux_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	pwm_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_timer_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_unlock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_dma_seg_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_ethernet_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_resume_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_wake_up_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_tdkntcg_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_otg_id_pin_irq_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_init_64k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_64k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	FsReadFile	vmlinux	EXPORT_SYMBOL
+0x00000000	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	iw_handler_get_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_match	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_platform_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_var_to_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_stop_and_remove_behind_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_io_merged_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_module_init_notifier_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_find_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_stacked_transfer_operstate	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_set_id	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_start	vmlinux	EXPORT_SYMBOL
+0x00000000	key_set_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_bulk_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_encoder_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_get_memory_map	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x00000000	crc_ccitt	vmlinux	EXPORT_SYMBOL
+0x00000000	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
+0x00000000	set_l2_indirect_reg	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_is_intel_switchable_xhci	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_free	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_unexpect_related	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uuid_be_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_update_io_add_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_assign_unassigned_bridge_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_put_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratdens	vmlinux	EXPORT_SYMBOL
+0x00000000	release_and_free_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_tree_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_invert_cmaps	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_alloc_ablkcipher	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	nf_net_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_put_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__init_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readb_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_graph_walk_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reconfig_AICL	vmlinux	EXPORT_SYMBOL
+0x00000000	uncache_firmware	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_dealloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x00000000	strndup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_update_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_reinsert_req_sup	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_symbols_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	idle_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_get_status	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_received	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	uio_event_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_schedule_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_bytes_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	audit_log_task_context	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_write_then_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_cfg_slim_sch_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_cfg_slim_sch_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sb_clone_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x00000000	css_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_spurious_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_page_alloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_gpio_config	vmlinux	EXPORT_SYMBOL
+0x00000000	crc16_table	vmlinux	EXPORT_SYMBOL
+0x00000000	init_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_ts_and_drops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_subscribe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_just_insert_please	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_driver_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0x00000000	pil_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_find_region	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_has_full_constraints	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_export	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_set_expiry	vmlinux	EXPORT_SYMBOL
+0x00000000	use_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	nfsd_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_cancel_async	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_putpagetable	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_forbid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_disable_deferred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__twofish_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_put_decimal_ll	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_iommu_unmap_contig_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_ntop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_pton	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_clk_get	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	des_ekey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_raw_event_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_irq_install	vmlinux	EXPORT_SYMBOL
+0x00000000	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_completed	vmlinux	EXPORT_SYMBOL
+0x00000000	key_link	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_auth_and_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_scan_fixups	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_get_mem_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_page	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_dispatch_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	keyring_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_pc	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_service_to_auth_domain_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_resolution	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_wipe	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_set_var	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	strnstr	vmlinux	EXPORT_SYMBOL
+0x00000000	__css_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_sock_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_diag_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_elf_read_implies_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_phy2h	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	add_device_randomness	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_nearest_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_wlan_crypto_free_ahash	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	snd_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_file_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_phy_id	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_getsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memcpy_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_ratnum	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unmap_urb_setup_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_set_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	membank0_size	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_rmdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_blocklen	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5761_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_enqueue_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_hold_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_protocol_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_default_ttl	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_stay_on	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flex_array_get	vmlinux	EXPORT_SYMBOL
+0x00000000	key_task_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_protocol_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_find_vendor_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_recv_common	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hwdep_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_mmss	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_resource_n	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_request_done	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_get_ptname_from_ptbase	vmlinux	EXPORT_SYMBOL
+0x00000000	ewma_add	vmlinux	EXPORT_SYMBOL
+0x00000000	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_boolean_stereo_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_blk_init_packed_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writew	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_default_readable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_port_xfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_request_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_is_pkt_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_flow_on	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_custom	vmlinux	EXPORT_SYMBOL
+0x00000000	tda829x_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_amd_dev_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_pwrlevel_change	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_write	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_fpu	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_link_rwlock	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_is_hotpluggable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_read_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_exec_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	pingv6_prot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_reqbufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slimbus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	print_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_amanda_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_probe_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	check_permissions	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_create_bufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_assign_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_cluster_pm_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_num_counters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_get_serial_number	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_notify_peers	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
+0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_get_init_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
+0x00000000	console_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_pm_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_req	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_class_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_timer_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_qdss_ctrl_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ready_on_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_process_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_dai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda18271_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface_no_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_edid_to_eld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_remove_spawns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_empty_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_prevent_suspend	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	lib80211_unregister_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_replace_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_assign_laddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__percpu_counter_init	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_affinity_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_dispatch_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_pointer_emulation	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_transfer_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	set_cpus_allowed_ptr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_notif_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_plane_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_initialize_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cache_range_op	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_calc_vbltimestamp_from_scanoutpos	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_shash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_init_ahash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_timers_register_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_sock_update_bufs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_new_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_request_array	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkio_policy_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_turn_on_cpu_rail	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_net_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start_interrupts	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_master_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_free_array	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_unregister_inet_compat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_global_kobject	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_voltage_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_gifconf	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_sys	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_validate_clocks	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	gpiochip_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_inode_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_classify8021d	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_platform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_pipeline_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_register_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init_scan_with_range	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_xo_get	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_xo_put	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_have_object	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmalloc_caches	vmlinux	EXPORT_SYMBOL
+0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_malloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_release_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_pause_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache_range	vmlinux	EXPORT_SYMBOL
+0x00000000	put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_nowake_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecounter_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_lookup_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_classdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_reset_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_inode_setsecctx	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_interrupt_in_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_timer_release	vmlinux	EXPORT_SYMBOL
+0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nla_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_dai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_set_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	up	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_set_ds_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_get	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_is_primary_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuset_mem_spread_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pid_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hashbin_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_open	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_sock_fast	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_cards	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_create_of_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_dcvs_freq_sink_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	nat_q931_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mdiobus_free	vmlinux	EXPORT_SYMBOL
+0x00000000	qseecom_shutdown_app	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5767_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_dev_name	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_mode_cvt	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fput	vmlinux	EXPORT_SYMBOL
+0x00000000	_change_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_delete_value	vmlinux	EXPORT_SYMBOL
+0x00000000	clkdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_map_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_handler_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	get_restart_level	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_lookup_quirk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_scale_pmic_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_block_bio_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_pmem_contig_user_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_pmem_contig_user_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_handle_vblank	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	strnicmp	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	fbcon_set_bitops	drivers/video/console/bitblit	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_signed	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_find_item	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sock_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_hax_cache_read	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sw_sync_timeline_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_gem_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_fb_v4l2_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	user_instantiate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_icmp_reply_translation	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_attach_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_debugfs_create_files	vmlinux	EXPORT_SYMBOL
+0x00000000	crc_ccitt_table	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_proc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x00000000	phys_mem_access_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x00000000	unlink_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_add	vmlinux	EXPORT_SYMBOL
+0x00000000	__percpu_counter_sum	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_init	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_4k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_init_4k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_set_max_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsl	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_cdc_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	system_unbound_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_reconfigure_now	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_free	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_get_state	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elementalx_boost_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_unregister_compressor	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_add_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_edid_add_monspecs	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_active	vmlinux	EXPORT_SYMBOL
+0x00000000	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsCreateFile	vmlinux	EXPORT_SYMBOL
+0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_lut_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_free_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mdp_preset_lut_update_lcdc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_start	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_read_bulk_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_attachmode_crtc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_close	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0x00000000	net_cls_subsys_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_wakeup_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_build_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_new_index	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_msg_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_color_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_set_debounce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_get_tuplepr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_set_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_chmod	vmlinux	EXPORT_SYMBOL
+0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_idiv	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_service_to_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_endpoint	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_map_global	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracepoint_probe_update_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_clear_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_codec_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_define_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_read_mapping_page_gfp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcnss_flush_delayed_boot_votes	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hid_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_file_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_register_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_sk_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_link_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_decode_string_inplace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uuid_le_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_seq_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_register	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_cell_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_unsubscribe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_charge_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	external_common_state_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_verify_blk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_copyarea	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_attach_task_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__div0	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write_avail	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_priority_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_new_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dqbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0x00000000	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_skb_features	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_unregister_dais	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_pci_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_pci_init	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_add_unique_test_req	vmlinux	EXPORT_SYMBOL
+0x00000000	work_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_dev_probe2	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	lcd_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_pin_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_update_nr_prod	vmlinux	EXPORT_SYMBOL
+0x00000000	usleep_range	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_check	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_cqm_rssi_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_register_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcie_set_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_bus_configure_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	exportfs_encode_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
+0x00000000	rcutorture_record_progress	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_freq_sink_start	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_reserve_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_batt_scaler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_unplug_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_put	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_get	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_pipe_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_check_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_queue_rcv_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_connect_sink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_get_property	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_property	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x00000000	have_submounts	vmlinux	EXPORT_SYMBOL
+0x00000000	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_init_max_qos_capabilies	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_queue_err_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_add_device_sysfs_file	vmlinux	EXPORT_SYMBOL
+0x00000000	key_create_or_update	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_adjust_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irias_find_object	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_load	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_keydown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_add_page	vmlinux	EXPORT_SYMBOL
+0x00000000	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__memzero	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_buffer_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_bl_default_curve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpiomux_init	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_blanked	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_is_singular	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	allocate_contiguous_memory_nomap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_enter_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev32	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cleancache_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_speed_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_resume_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_connect_result	vmlinux	EXPORT_SYMBOL
+0x00000000	gss_mech_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9310_codec	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_start_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pm_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_set_features	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0x00000000	filter_match_preds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_change_state	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unlock_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_raw_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_sysfs_set_active_low	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_add_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_event	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_sysrq_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x00000000	_remote_mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_direct_output	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_resource_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	prandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_next	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_dirtied	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes_arch	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	asustek_get_tp_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_codec_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_check_gmii_support	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	__video_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_cpustat	vmlinux	EXPORT_SYMBOL
+0x00000000	ipc_log_context_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_roamed	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_add_octseq_attrib	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	get_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_mkdir_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	tag_pages_for_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_destroy_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_tsk_mgmt_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bread	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ssbi_write	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_s_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_g_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_udata_request	vmlinux	EXPORT_SYMBOL
+0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_register	vmlinux	EXPORT_SYMBOL
+0x00000000	cfb_imageblit	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_cpu_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_base	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_irc_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_ftp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_send	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_iff_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_getfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_framebuffer	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_remove_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_pt_create	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_suspend_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_set_scratch_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_suspend_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_deliver_cached_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_exts_change	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_release_substream	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_find_chipset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_table_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_master_send	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_tgt_free_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inc_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_new1	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_fdget	vmlinux	EXPORT_SYMBOL
+0x00000000	security_task_getsecid	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_uaddr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_local_reserved_ports	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_tiocmset	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_tiocmget	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__umodsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_max_syn_backlog	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_delay_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secid_to_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_mgmt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_read_status	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dithering_property	vmlinux	EXPORT_SYMBOL
+0x00000000	redraw_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reenable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_change	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0x00000000	memdup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	del_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_open	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcie_update_link_speed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_rcu_gp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_suspend_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_close	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memory_pool_node_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_named_open_on_edge	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_socket_put_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_nc_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_card_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_field_names	vmlinux	EXPORT_SYMBOL
+0x00000000	tda9887_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_encode_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_tlmm_set_hdrive	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_brk	vmlinux	EXPORT_SYMBOL
+0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_peeraddr2str	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_adc_scale_batt_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_pwm_config_period	vmlinux	EXPORT_SYMBOL
+0x00000000	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	subsystem_restart_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_vreg_set_frequency	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_channel_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_get_channel_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_irq_type	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drop_output	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_unregister_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	__lru_cache_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_execve	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_reset_function_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_read_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_restore_early	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_rs_non_canonical	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_event_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_sha1_update	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	system_long_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_common_get_supported_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_resume_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writesb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lzo1x_decompress_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_unmount	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_transform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	roccat_common_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_query_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_prime_add_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	random32	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_lock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_set_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_read_arg	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_handle_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_add_routes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs4_schedule_lease_recovery	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_max	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_resetkey_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_request_key	vmlinux	EXPORT_SYMBOL
+0x00000000	panic_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_tiocmset	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_tiocmget	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic3	vmlinux	EXPORT_SYMBOL
+0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	md5_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ibss_joined	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_count_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_destroy_pipe_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tea5767_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	putname	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_client_update_request	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter_release_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_remove_id	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_report_finger_count	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_disconnect_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pmem_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_num_of_clients	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0x00000000	sha_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	ksize	vmlinux	EXPORT_SYMBOL
+0x00000000	kstat	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_vreg_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_uidiv	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_security	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_del_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_stop_bus_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_truncate_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_iter_peek	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elf_platform	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_debugfs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_remote_source	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smb345_float_volt_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_unregister_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_pause	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_blink	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_register_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cfg_access_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__ring_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_use_client	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_redirty	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_normalize_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_expect_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_tx_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_free_64k	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	preempt_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_thaw_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_activate	vmlinux	EXPORT_SYMBOL
+0x00000000	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_brightness_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_tuner_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_get_ion_client	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	on_each_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_set_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock_live_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_pmu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ihold	vmlinux	EXPORT_SYMBOL
+0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qword_addhex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_create_card_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unmap_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_path_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x00000000	videobuf2_to_pmem_contig	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_put	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_add_videomode	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_open	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open	vmlinux	EXPORT_SYMBOL
+0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_check_condition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_request_card	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	register_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_tdls_oper_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockd_down	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_reserve_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_register_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_prio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	otg_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	hex2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsWriteStat	vmlinux	EXPORT_SYMBOL
+0x00000000	d_make_root	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_reinit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_update_bits_check	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_free	vmlinux	EXPORT_SYMBOL
+0x00000000	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_destroy_chain	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_register_patch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_region_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_64k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_64k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_read	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_register	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_single	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_get_intr_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_set_silence	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_dma_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_notify_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_timeline_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	register_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	io_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cfb_fillrect	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_roamed_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regmap_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_register_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__clocksource_updatefreq_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_rfkill_stop_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_netdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcutorture_record_test_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wireless_spy_update	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_destroy_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_present	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_spm_get_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_set_vdd	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_diag_write	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_features	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_release	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_accept_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	yield	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_napi_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_claim_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_destroy_modedb	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_init_replay	vmlinux	EXPORT_SYMBOL
+0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_try_assign_helper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_report	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_sb_list_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_init_always	vmlinux	EXPORT_SYMBOL
+0x00000000	d_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_task	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_int32_read	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_page	vmlinux	EXPORT_SYMBOL
+0x00000000	set_h245_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_print_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_class_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	monotonic_to_bootbased	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_queue_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_int32_write	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lz4_decompress	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_del_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
+0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_timeline_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_group_init_legacy_group	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_put	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	no_pci_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	init_rs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncmp	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_pageio_reset_read_mds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_anon_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_event_length	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_flow_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_little_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_access_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_le	vmlinux	EXPORT_SYMBOL
+0x00000000	lcm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	empty_aops	vmlinux	EXPORT_SYMBOL
+0x00000000	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_try_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_handle_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_alloc_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlm_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netdevice_notifiers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_usbmidi_input_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_nway_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_add_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_create_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_freezable	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_decode_array2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_reclassify_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_width	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_destroy_modelist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writeb_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_crtc_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	d_move	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_idivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_common_sendmsg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	data_bridge_unthrottle_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	request_key_async	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_set_wakeup_capable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_4k_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_4k_lle	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_configure_link	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_writable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_get_slave_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strstr	vmlinux	EXPORT_SYMBOL
+0x00000000	strchr	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_channel_index	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_new_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	usermodehelper_read_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memcpy_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_get_next	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_set_dongle	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_noop	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_get_io_base	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_hwcap	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_release_client	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_gain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_interface_reg_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	take_over_console	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_sanitize	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_do_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsw	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_export	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_mark_declared_memory_occupied	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_ioremap_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_buf_read_netobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_localaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_set_power_params	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_pptp_hook_exp_gre	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x00000000	FsMoveFile	vmlinux	EXPORT_SYMBOL
+0x00000000	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_global_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_free_clusters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_do_cache_op	vmlinux	EXPORT_SYMBOL
+0x00000000	scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_refresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_register_action	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_autosuspend_expiration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_add_request_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_enable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_debug	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_dreadlock	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_timeline_create	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	task_blkio_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_create_access	vmlinux	EXPORT_SYMBOL
+0x00000000	no_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_set_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_videomode_to_modelist	vmlinux	EXPORT_SYMBOL
+0x00000000	register_resetkey_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_trace_issueibcmds	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_finalize_current_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	capable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_can_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_tv_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	selinux_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_swevent_get_recursion_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_find_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_tuple_to_nlattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	give_up_console	vmlinux	EXPORT_SYMBOL
+0x00000000	getname	vmlinux	EXPORT_SYMBOL
+0x00000000	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_helper_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_platform_widget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_seq_root	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_find_dmt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_regset32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_raw_handler_register	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_compress	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_unexport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_response_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_session_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	batostr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_merge	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_policy_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_big_endian	vmlinux	EXPORT_SYMBOL
+0x00000000	in_lock_functions	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_cqm_pktloss_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_graph_walk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_init_panel_info	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_complete_wifi_ack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_to_bin	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_clock_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_platform_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_smsm_init_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	__muldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_create_data	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_string	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_cache_register_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ecards_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x00000000	FsUmountVol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_set_bond_master	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_request_clock_on	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_givcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pil_force_boot	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_tree_decrease_qlen	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bit_algo	vmlinux	EXPORT_SYMBOL
+0x00000000	input_scancode_to_scalar	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_get_next_queued_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rq_flush_dcache_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_streams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_get_irq_stat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regcache_cache_only	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_seek	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_host	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_alloc_ch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_show_logo	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_pan_display	vmlinux	EXPORT_SYMBOL
+0x00000000	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoll_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_new	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_pci_problems	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_get_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_do_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_alloc_size	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_bus_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_sched_scan_stopped	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_poweroff_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_release	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_add_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	printk	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_add_enum	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_lookup_credcache	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_switch_role	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_add	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commitdata_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracing_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_policy_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_get_pt_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iw_handler_get_thrspy	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_single_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtol_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_gtk_rekey_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_has_cap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_fb_v4l2_update	vmlinux	EXPORT_SYMBOL
+0x00000000	setattr_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_probe_status	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_get_line	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_auto_cluster	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_dequeue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	security_tun_dev_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_ulcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_cold_boot_done	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	dns_query	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_digital_mute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ipc_config_sec_rules	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_calc_rto	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_width	vmlinux	EXPORT_SYMBOL
+0x00000000	fg_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_find	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_read	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	local_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sunrpc_cache_unregister_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_resume_rx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ati_pcigart_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	__div64_32	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	rawv6_mh_filter_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_unregister_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_coherent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_dbg_commit_data	vmlinux	EXPORT_SYMBOL
+0x00000000	core_get_adsp_version	vmlinux	EXPORT_SYMBOL
+0x00000000	rawv6_mh_filter_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_register_event	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_update_completion_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_l3proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_l4proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_unused_desc_num	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_dummy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_ctrl_clk_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_sync_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_conn_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsv_pointer_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_smpl_control	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_put_gpuaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_release_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_tunnel_find_nth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_put	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_tuner_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_sys_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_long	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_report_no_dapm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_strdup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_free_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpm_regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_supply_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bsg_register_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_get_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	user_path_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_disconnect_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_port_softint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_property_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_lookup_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_set_low_power_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_wait_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fifo_set_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_pcm_runtime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_device_snapshot_init	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_recseq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ethtool_get_settings	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_resume_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_del_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_i2c_encoder_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	css_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_request_find_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_kill_unmapped_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_querybuf	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	device_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_handle_cts_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_handle_dcd_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x00000000	free_inode_nonrcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_pci_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_name	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_open	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_alloc_blkg_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_regulator_get_ocrmask	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_release_kernel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_default_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_decode_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_save_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_and_free_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsMapCluster	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x00000000	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	do_ramdump	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_hs_request_clock_off	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
+0x00000000	release_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_sleep_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_stream_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	bq27541_battery_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_resume_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_calculate_bitrate	vmlinux	EXPORT_SYMBOL
+0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_list_del	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create	vmlinux	EXPORT_SYMBOL
+0x00000000	get_option	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_to_blkio_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hidraw_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unbind_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read	vmlinux	EXPORT_SYMBOL
+0x00000000	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_subsys_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_free_vmalloc_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_transfer_one	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_free	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0x00000000	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_le_ltk_reply	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_dev_probe	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_storage_usb_ids	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_export_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	abort	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_unprot_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_drop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gf128mul_x_ble	vmlinux	EXPORT_SYMBOL
+0x00000000	FsSetAttr	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_forget	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_crypto_free_ablkcipher	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	cfg80211_get_mesh	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	qseecom_start_app	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_insert_addr_table	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_display	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_write_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_process_read_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_dio_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pil_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_card	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_get_logical_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_encoder_init	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	l2tp_udp_encap_recv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_find_ltk	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_check_keys_pressed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_bulk_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strtobool	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_private	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_trace_buf_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_core_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_queue_start_reset_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readsb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_set_device_power	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_used_features	vmlinux	EXPORT_SYMBOL
+0x00000000	auth_domain_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_plane_vaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	write_to_strongly_ordered_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_detect_change	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_debugfs_remove_files	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_timeslice_used	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_get_net	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_freq_attr_scaling_available_freqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_work_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_edid_header_is_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gtf_mode_complex	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__rcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	touch_softlockup_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_subscribe_event	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_input	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_alloc_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ecryptfs_fill_auth_tok	vmlinux	EXPORT_SYMBOL
+0x00000000	register_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_confirm_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_getsarea	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	system_freezing_cnt	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	hidraw_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eeprom_93cx6_multiread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_crtc_set_gamma_size	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addbufs_pci	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_get_exclusive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek_size	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_update_client	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_serial_generic_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mangle_path	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_domain_bus_and_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	slhc_toss	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_vm_close	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_conn_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_mkpipe_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda829x_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_axi_portunhalt	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_free_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x00000000	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_alloc_pages_fallback	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_reset_modem	vmlinux	EXPORT_SYMBOL
+0x00000000	membank1_start	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_change_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_ht_insert_item	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_fill_output_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_skb_read_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_putpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_h245_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_register_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_adapter_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_reset_comm	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rc_keydown_notimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rmnet_netdev_cmp	vmlinux	EXPORT_SYMBOL
+0x00000000	device_init_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	avenrun	vmlinux	EXPORT_SYMBOL
+0x00000000	system_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__arm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_extend_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_calc_max_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_type_names	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_sk_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_dma_get_reserved_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_output_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__do_div64	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_update_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_new	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_hsync	vmlinux	EXPORT_SYMBOL
+0x00000000	external_common_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_blank	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_path	vmlinux	EXPORT_SYMBOL
+0x00000000	open_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_find_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_write	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_unsecure_heap_2_0	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_state_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_irda	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_qdisc_flow_control	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_msix	vmlinux	EXPORT_SYMBOL
+0x00000000	div_s64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	put_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_copy_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_kill_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_is_pipe_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_qdss_free_req	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_unlink_rx_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_debugfs_tests_root	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_pending	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lg_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_set_noirq	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0x00000000	timed_output_dev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_get_rq_mapinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_set_adcmap_btm_threshold	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_release	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_transparent_scsi_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_order	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_write_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_iris_xo_mode	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_init_file_private	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_plane_init	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_deflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_create	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_recv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bt_sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_default_volatile_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create_enum	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_connector_name	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_tlmm_set_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_task	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_task_reset_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	video_devdata	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_resource_to_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_verify_client	vmlinux	EXPORT_SYMBOL
+0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_runtime_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x00000000	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	getboottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	revert_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_rmap_add	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	__stack_chk_fail	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_proc_new	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_fb_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_bus_dbg_client_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_init_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_can_beacon_sec_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_unregister_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	key_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_amsdu_to_8023s	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_search_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_path	vmlinux	EXPORT_SYMBOL
+0x00000000	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_cl_clear_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	g_verify_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_reset_pwr_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_init_table	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_new_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_info_multi_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_update_link	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic4_3	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_queue_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_scan_remove_block	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_domain_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_loaded	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_module_init_notifier_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_restart_call	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vidc_load_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_clear_master	vmlinux	EXPORT_SYMBOL
+0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_create	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	free_irq_cpu_rmap	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sysctl	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_status_read	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_deregister_bam_device	vmlinux	EXPORT_SYMBOL
+0x00000000	usbhid_submit_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	backlight_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_write	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read_from_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic2	vmlinux	EXPORT_SYMBOL
+0x00000000	slimport_is_connected	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_fixed_flag	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_stats_to_stats64	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_dma_sg_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_qdss_alloc_req	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_active_count_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_put_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_vm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_taskset_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_info_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_list_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_set_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__gpio_get_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_kmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	percpu_counter_compare	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_put_req	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesw	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesl	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesb	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_wait_for_app_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	msg_encode_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_rename_id	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qseecom_set_bandwidth	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_irq_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_private_object_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_alloc_new_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_iowait_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__raw_readsb	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_init_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_mc_rejoin_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_update_features	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_imageblit	vmlinux	EXPORT_SYMBOL
+0x00000000	smp_call_function	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_is_supported_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	llist_del_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	int_sqrt	vmlinux	EXPORT_SYMBOL
+0x00000000	dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	system_rev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_syn_flood_action	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_max	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	smb345_config_thermal_charging	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write_file	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ucmpdi2	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_conn_check_secure	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_codec_readable_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_check	vmlinux	EXPORT_SYMBOL
+0x00000000	video_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_minor	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_parselist_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_simple_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_del_blkio_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_register_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_map_urb_for_dma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_dispose_mapping	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	usermodehelper_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_usbmidi_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_continue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	kvfree	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_nlink	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_close	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_find_next_zero_area_off	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_inline_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_hw_revision	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_file_add	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irlmp_unregister_service	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_short	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_tftp_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_h225_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	menu_hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	strim	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_write	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_widgets	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_info_create_module_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ecryptfs_get_auth_tok_key	vmlinux	EXPORT_SYMBOL
+0x00000000	vfree	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_open_tsap	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_open_lsap	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_detect_card_removed	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_page_alloc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	exportfs_decode_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	g_make_token_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_release_rqst_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_match_id	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_run_wake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_alloc_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_action_dump_1	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_get_vmalloc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_lock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	textsearch_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_direct_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_setattr	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_tree_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	cred_to_ucred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_put	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	delayacct_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_clear_noirq	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dma_contig_init_ctx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	sscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsvc_unlock_all_by_ip	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nlmsvc_unlock_all_by_sb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__breadahead	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_bind_new_program	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pfifo_fast_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_integer	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_raw_read	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_register_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_gpio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_to_xdr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dpcm_can_be_free_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	bstr_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	___ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_nat_mangle_tcp_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_dma_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_dump_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_rpccred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpcauth_init_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_audit_state_replay_overflow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_hw_reset_check	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_create_mmap_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_dais	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_unregister_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_g_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_helper_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_request_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlock_put_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_sharedmem_page_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_buffer_requirements	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_get_buffer_requirements	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_start_test	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_init_security	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_lmul	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	global_cursor_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_socket_get4_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_socket_get6_sk	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_write	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_start_grace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_probe_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sched_get_nr_running_avg	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tuners	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_del_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sw_sync_timeline_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_writel	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_rename_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	write_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_entries_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_free_device	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_edge_to_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_set_retrans_timeout_rtt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_consume_args	vmlinux	EXPORT_SYMBOL
+0x00000000	pppox_unbind_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrscale_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__modsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__divsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sk_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out	vmlinux	EXPORT_SYMBOL
+0x00000000	get_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__stack_chk_guard	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_clone_cell	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x00000000	security_req_classify_flow	vmlinux	EXPORT_SYMBOL
+0x00000000	get_dcookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_event_raw_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast_filtered	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_cd_gpio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strspn	vmlinux	EXPORT_SYMBOL
+0x00000000	strlen	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_recv_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_configure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_pool_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_common_vm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_enable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_request_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_tp_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_int	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_setup_and_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcauth_generic_bind_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_kernel_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_v7_dcache_clean_area	vmlinux	EXPORT_SYMBOL
+0x00000000	bridge_tunnel_header	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_card_free_when_closed	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_get_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_edid_block_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_partial_copy_from_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_request_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in_r	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	verify_mem_not_deleted	vmlinux	EXPORT_SYMBOL
+0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pci_quirk_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_simple_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_info_free_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_prime_fd_to_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_get_config	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_set_config	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_cmdbatch_destroy_object	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_release	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nlattr_to_tuple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_unmap_iommu	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_list_concat	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_get_block_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_set_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_put_stab	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_cleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_find_best_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_printf	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setfns	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_free_host	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_validate_size	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_spm_l2_reinit	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_power_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_dev_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	cleancache_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_cookie_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_flush_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_lib_malloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_deflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_trylock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	pfn_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_key_construction	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_set_triggers	vmlinux	EXPORT_SYMBOL
+0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_hoplimit	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_sanitize	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_bus_cl_get_pdata	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_seconds	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_fillrect	vmlinux	EXPORT_SYMBOL
+0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_max_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_set_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsRemoveFile	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	irttp_close_tsap	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_remove_this	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_close_lsap	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_hash_search	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	unuse_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_batt_alarm_pwm_rate_set	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_affinity_hint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_handle_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_set_stacking_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inode_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clk_set_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_recv_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_global_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_choose_state	vmlinux	EXPORT_SYMBOL
+0x00000000	delete_from_page_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_assoc_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_insert_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree_call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_device_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_get_serial	vmlinux	EXPORT_SYMBOL
+0x00000000	map_page_strongly_ordered	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_close_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_awake	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_attach_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_next_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_change_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_from_user_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_attach_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_kcopyd_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_dcd_change	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_srb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_streams	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_mmu_init	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8821_get_irq_stat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_ptpool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_get_platform_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rotator_imem_free	vmlinux	EXPORT_SYMBOL
+0x00000000	update_region	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_get_route	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_em_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_can_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_g_keycode_from_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x00000000	kcrypto_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_vprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_add_global_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_scheduler_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_path_create	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_terminate_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_net_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_timer_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_scaling_mode_property	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_seq_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	audit_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_config_pwm_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_alloc_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_pid_to_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_broadcast_help	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	vzalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_detect_hdmi_monitor	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_fence_wait_async	vmlinux	EXPORT_SYMBOL
+0x00000000	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_register	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_get_first	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_add_dai_controls	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_read_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_last	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_pool_node_paddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_find_by_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_query_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_format_2string	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_msi_block	vmlinux	EXPORT_SYMBOL
+0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_op_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_register_entity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_acl_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_add_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unix_socket_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_dma_contig_cleanup_ctx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sw_sync_pt_create	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_print_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_extend_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_get_light	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open_size	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_end_cpu_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_signal_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_snapshot_close	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_share_dma_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_mkpipe_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_warn_nonwc	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_gpio_install_direct_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_queryctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_prime_lookup_imported_buf_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmclnt_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dio_end_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_check_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_log_status	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_ktime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_check_addressable	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_read_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__refrigerator	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_down	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_hw_rev	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_pointer_write	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_refcnt_read	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_init_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_parse_command_line_for_connector	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_buffer_read_object	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_alloc_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_set_value	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_property_get_value	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ns_type_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pwm_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_log_fault_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_addmap	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_set	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_tdm_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_pci_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	encode_rs8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	enable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	enable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_fd_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create	vmlinux	EXPORT_SYMBOL
+0x00000000	memchr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_hsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_request_add_commit_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_record_enable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_list_pseudoflavors	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_deflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	on_each_cpu_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_update_dst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_valid_rtt_meas	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dev_info_list_del_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoul_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	l2tp_tunnel_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cache_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_get_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_put_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_find_nearest_format	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_write_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_endpoints	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_read_dev_vendor_id	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_le_conn_update	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_kernel_range_noflush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_options_compile	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_alloc_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_bus_to_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	aio_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	unix_outq_len	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_read_bkops_status	vmlinux	EXPORT_SYMBOL
+0x00000000	slhc_free	vmlinux	EXPORT_SYMBOL
+0x00000000	device_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_add_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_recv_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_prepare_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_alloc_coherent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	allocate_contiguous_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_flush_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_clients_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pas_init_image	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_reservemsg_bw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	pp_process_remove_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_state_cb_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_auth_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_data_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_bound_align_image	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_autopm_get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_autopm_put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_cons	vmlinux	EXPORT_SYMBOL
+0x00000000	asustek_get_lcd_pwm_type	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_can_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_new_std_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_add_edid_modes	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_rmap_update	vmlinux	EXPORT_SYMBOL
+0x00000000	strncat	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcat	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_erase_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_set_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_delete_object	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_handle_break	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_scan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_object_change_attribute	vmlinux	EXPORT_SYMBOL
+0x00000000	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_start_head_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcf_em_tree_match	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_Bulk_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_gem_object_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	security_release_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_available_features	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	mdiobus_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timekeeping_inject_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	do_trace_rcu_torture_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_link_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commitdata_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_rpm_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	modem_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_unregister_thermal_mitigation	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_udp6	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_blk_get_packed_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stop_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	locate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfs_pageio_reset_write_mds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_device_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_memcpy_toio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_constraint_ratnums	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_process_events	vmlinux	EXPORT_SYMBOL
+0x00000000	strcspn	vmlinux	EXPORT_SYMBOL
+0x00000000	twofish_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_signal_events	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_extend	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_l4proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_l3proto_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_parse_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_write_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	pmem_cache_maint	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ut_debug_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_rmmap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_svc_to_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_find_xprt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_process	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_force_rebind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_set_ios	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_skb_return	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_killall_tasks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_iterate_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	buffer_migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_xprt_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_reg_read_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	external_common_state_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_domain_simple_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	armpmu_get_pmu_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_defrag_ipv6_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_defrag_ipv4_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_install	vmlinux	EXPORT_SYMBOL
+0x00000000	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0x00000000	default_red	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_edid_to_monspecs	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_free_hashtable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_power_save_host	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_timestamp_write	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_probed_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_complete_power_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_page_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_spi_new_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_handler_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_mute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	may_umount	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_detach_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_params_to_bclk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_hw_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_map_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_find	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_alloc_initial_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	rc_free_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_raw_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_bulk_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_ack_err	vmlinux	EXPORT_SYMBOL
+0x00000000	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_input_params	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0x00000000	net_prio_subsys_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bq27541_wireless_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_lock_is_held	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_pool_avail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
+0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_shift_arg	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_address	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcibios_fixup_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_probe_func_quick_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_create_bundle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	icq_get_changed	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_free	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_xprt_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_for_each_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_conn_check_link_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_set_block_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_event_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_conntrack_helper_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ppp_unit_number	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_input_error	vmlinux	EXPORT_SYMBOL
+0x00000000	vidc_get_ioaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_generic_pg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_init	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_generic_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_add_virt	vmlinux	EXPORT_SYMBOL
+0x00000000	user_describe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_unregister_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dai_set_fmt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_get_val_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_idle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_begin_ordered_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_trans_will_send_data_barrier	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_lookup_machine_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_init	vmlinux	EXPORT_SYMBOL
+0x00000000	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_super	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	__machine_arch_type	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_create_dvi_i_properties	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_ht_create	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_inherit_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_direction_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_disconnected	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_rx_auth	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x00000000	find_font	drivers/video/console/font	EXPORT_SYMBOL
+0x00000000	irda_notify_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_buf_kunmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_cpu_rmap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_port_nlattr_tuple_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_start	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_probed_add	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
+0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_hook_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genlmsg_put	vmlinux	EXPORT_SYMBOL
+0x00000000	radio_hci_send_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_anon_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rps_sock_flow_table	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_compress_new	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_watchdog_reset_control	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	request_any_context_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pgprot_user	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_table	vmlinux	EXPORT_SYMBOL
+0x00000000	tc_classify_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	uio_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkiocg_lookup_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_unmap_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_buffer_free	vmlinux	EXPORT_SYMBOL
+0x00000000	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_file_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_put	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_streamon	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_claim_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_read	vmlinux	EXPORT_SYMBOL
+0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	key_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_sleep_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_vegas_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_silence_64	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_connect_direct	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_connector_update_edid_property	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	address_space_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	ftrace_print_hex_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_replay	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tcf_action_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_register_codec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_height	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_mask_receive_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_unplug_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_walk_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_overruns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_load_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_pcm_hw_param_setempty	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_close	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_get_feat_version	vmlinux	EXPORT_SYMBOL
+0x00000000	scm_call_atomic1	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_clflush_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_commit_clear_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ft_event	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_clone_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irda_device_set_media_busy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_icvfail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_fold_field64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_get_led_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hid_resolv_usage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_f0_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_ratelimit_state	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_try_ext_ctrls	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_alloc_mgrports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_register_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_read	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_get_version	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_unprepare	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_l4proto_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_get_subsys_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_put_subsys_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_prune_invalid	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	private_AES_set_encrypt_key	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xc2028_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_default_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_set_ignore_round	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_monotonic_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_text_write_kernel_word	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_set_seq_adjust	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_open	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x00000000	ioc_lookup_icq	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_puts	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_ssr_boot_notify	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_last	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_shared_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_genocide	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_generic_entry_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_report_obss_beacon	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_value_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_vegas_cwnd_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_enum_info	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_batt_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crc32c_le	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	d_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	file_open_root	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ashldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmc_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_class	vmlinux	EXPORT_SYMBOL
+0x00000000	__bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_write	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_set_device_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kthread_worker_fn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iw_handler_set_spy	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_set_restart_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	reciprocal_value	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_get_sb_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_get_interface_no_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_common_get_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_init_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_txq	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_register_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cleancache_init_shared_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	set_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ipc_load_default_node	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_generic_walker	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_register_inet_compat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dst_set_noref	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	debug_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ablkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ablkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	videobuf2_queue_pmem_contig_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_chip_data	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_scan_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_set_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	registered_fb	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_io	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_fence_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	ecryptfs_get_versions	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getbyhwaddr_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_flow_dissect	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_pwm_lut_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dmov_enqueue_cmd_ext	vmlinux	EXPORT_SYMBOL
+0x00000000	wireless_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_release_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_put_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_alloc_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_g_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_subdev_s_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_wake_up_queued_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_diag_nlsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fauxsound_codec_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_driver_register	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_req_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_remove_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_reinsert_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_cluster_pm_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_completion_killable_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	tabla_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	need_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x00000000	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_param_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_to_user_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	switch_dev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_change_mtu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_count	vmlinux	EXPORT_SYMBOL
+0x00000000	tracepoint_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_init_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_set_host_pm_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_ctrl_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_add_wr_rd_test_req	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_streamoff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_share_dma_buf_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_pci_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_read_user_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	__dynamic_dev_dbg	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	down	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_add	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	xts_crypt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_llsl	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_dump_icsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_put	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x00000000	hsic_sysmon_open	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_proto_in_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_hash_rnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnl_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_set_avscsr	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_get_avscsr	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_unregister_pm_ops	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strnchr	vmlinux	EXPORT_SYMBOL
+0x00000000	dcookie_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_dma_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	strrchr	vmlinux	EXPORT_SYMBOL
+0x00000000	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pingv6_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_gre_keymap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	dapm_reg_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_hw_constraint_pow2	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_free_mmap_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kernel_param_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dynamic_netdev_dbg	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_batt_alarm_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0x00000000	memscan	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x00000000	write_bytes_to_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_wwan_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_handler_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0x00000000	security_inet_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtos8	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_proc_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_current_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	socinfo_get_msm_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_master_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kd_mksound	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_format	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cookie_generator	vmlinux	EXPORT_SYMBOL
+0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	loop_register_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	device_set_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnl_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_set_real_num_tx_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_set_real_num_rx_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_group	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_event	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_insert_node_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	rfc1042_header	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_get_host_pm_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_rpcb_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_stop_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_consume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_free_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_unload_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pci_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_print_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_rpcb_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpumask_next_and	vmlinux	EXPORT_SYMBOL
+0x00000000	set_ras_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_hook_slow	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_ident_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	diag_bridge_open	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_open	vmlinux	EXPORT_SYMBOL
+0x00000000	lz4_decompress_unknownoutputsize	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_limit_hw_rates	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_client_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_audit_state_notfound_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_detect_monitor_audio	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_range_tag_if_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	console_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_match	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pwrctrl_request_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_check_and_mask_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_domain_xlate_onetwocell	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_codec_set_cache_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vb2_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	genphy_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	subsys_system_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_aux_clk_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_expose_latency_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_net_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__trace_bprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_hash_check_insert	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	unix_peer_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_resume_host	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_spi_subdev_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_root_buses	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_syn_ack_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_alloc_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_pad_unaligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_xo_mode_vote	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_drain_input	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_register_device_for_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	input_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwrange	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_set_retrans_timeout_def	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_map	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	vzalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_resume_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	media_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_poweroff_late	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_timestamp_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_shutdown_client	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_gadget_udc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pppox_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_freezable_should_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_len_r	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_xprt_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_pm_cmpxchg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	div64_s64	vmlinux	EXPORT_SYMBOL
+0x00000000	memparse	vmlinux	EXPORT_SYMBOL
+0x00000000	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_pmksa_candidate_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_shutdown_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	fmem_get_info	vmlinux	EXPORT_SYMBOL
+0x00000000	cache_firmware	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nf_ct_ext_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_align_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpufreq_register_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_get_intf_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_byte_array_write	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_get_crypto_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x00000000	default_blu	vmlinux	EXPORT_SYMBOL
+0x00000000	dql_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
+0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	video_ioctl2	vmlinux	EXPORT_SYMBOL
+0x00000000	input_alloc_absinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_urgent_request	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_preempt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	each_symbol_section	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_query_menu_valid_items	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_spk_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_pt_free	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_client_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_msi_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_secctx	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irttp_connect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_connect_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_encode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_process	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_refresh_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_count_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_initiate_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	free_css_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	pwm_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol_no_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_clear_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_get_next	vmlinux	EXPORT_SYMBOL
+0x00000000	fail_migrate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regulator_suppress_info_printing	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skip_spaces	vmlinux	EXPORT_SYMBOL
+0x00000000	__delay	vmlinux	EXPORT_SYMBOL
+0x00000000	add_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_power_off	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_busnum_to_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_get_gpuaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	user_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdput	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_conntrack_untracked	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_table_get	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_usual_ignore_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrscale_policy_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_cancel_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos16	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_read_prepare_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcf_em_register	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cache_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_volsw_ext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_get_md	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_tgt_cmd_to_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm8xxx_smpl_set_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bad_xchg	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_start_delayed_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	lirc_dev_fop_close	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_debug_printmodeline	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_ablkcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dirty_writeback_interval	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gss_mech_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_enable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_runtime_no_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_root_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	on_each_cpu_cond	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_mgmt_tx_status	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_make_writable	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_major	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_vcalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0x00000000	__dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	__mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_free_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_abs_params	vmlinux	EXPORT_SYMBOL
+0x00000000	ppp_register_compressor	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_bus_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_edid_is_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_pause_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_le_start_enc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_cable_type_detect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_map_iommu	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_congested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_alloc2	vmlinux	EXPORT_SYMBOL
+0x00000000	freq_reg_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_put_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_get_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfsacl_encode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wake_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_scale_pa_therm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_secmark_refcount_dec	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secmark_refcount_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_bint	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_null	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_netdevice_many	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_mpp_config_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_platform_init	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_platform_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sunrpc_cache_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_add_ctrl	vmlinux	EXPORT_SYMBOL
+0x00000000	phy_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_cpu_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	processor_id	vmlinux	EXPORT_SYMBOL
+0x00000000	xdr_encode_opaque_fixed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_match	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_new_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	initialize_memory_pool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_get_event	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_regmap_init_spi	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_regmap_init_i2c	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_master_get	vmlinux	EXPORT_SYMBOL
+0x00000000	css_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_jack_add_gpios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lirc_dev_fop_read	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_add_event	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x00000000	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rfkill_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_conntrack_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nlmsg_put	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_disable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mmc_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_dump_table	vmlinux	EXPORT_SYMBOL
+0x00000000	gf128mul_bbe	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_refine	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_remove_node	vmlinux	EXPORT_SYMBOL
+0x00000000	rdev_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	test_iosched_mark_test_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_security_override	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nfnetlink_subsys_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_cow_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_raw_event_store_with_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	eeprom_93cx6_wren	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_core_reclaim_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_del	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsReleaseCache	vmlinux	EXPORT_SYMBOL
+0x00000000	kmalloc_order_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	smem_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nat_callforwarding_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_numid	vmlinux	EXPORT_SYMBOL
+0x00000000	tsens_get_sensor_temp	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_get_vma	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_vblank_offdelay	vmlinux	EXPORT_SYMBOL
+0x00000000	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_last_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_dio_done	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_current_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_ext_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	regmap_update_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	avs_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sort	vmlinux	EXPORT_SYMBOL
+0x00000000	security_unix_may_send	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_reset_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_work_run	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clockevents_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	req_riva_power_on_lock	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	hci_recv_stream_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_rawmidi_kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_dealloc_mgrports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ddebug_remove_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_tun_dev_post_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kern_path	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dai_set_tristate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_alloc_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	FsReadDir	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	__cleancache_init_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_int	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_suspend_finish	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	data_bridge_write	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_object_init	vmlinux	EXPORT_SYMBOL
+0x00000000	find_inode_number	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_short	vmlinux	EXPORT_SYMBOL
+0x00000000	tsv_byte_array_read	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_init_sw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	rpcb_getport_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hci_unregister_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_input_common	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_unmap_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slhc_uncompress	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	FsGetVolInfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_to_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	softnet_data	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	wcd9xxx_disconnect_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_fb_info	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_pm_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_rpm_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipefs_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_memcpy_fromio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_sharedmem_set	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_hotplug_event	vmlinux	EXPORT_SYMBOL
+0x00000000	lcd_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free_parts	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_auth_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_diag_save_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_info_register	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	free_contiguous_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_log_wait_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0x00000000	_snd_pcm_hw_params_any	vmlinux	EXPORT_SYMBOL
+0x00000000	user_path_at	vmlinux	EXPORT_SYMBOL
+0x00000000	module_put	vmlinux	EXPORT_SYMBOL
+0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mm_debug_table	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_new_object	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_helper_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_get_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	llist_add_batch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vbin_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_cd_gpio_request	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_gem_prime_handle_to_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_sysfs_connector_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_pipe_generic_upcall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_unregister_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_search_free_in_range	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dget_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_new	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_mmap_data	vmlinux	EXPORT_SYMBOL
+0x00000000	hid_dump_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_requeue_unmapped_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_ioctl_1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disable_autosuspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	iunique	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_cancel_events	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fb_phys_info	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs4_schedule_stateid_recovery	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_mpd_scm_set_algo_params	vmlinux	EXPORT_SYMBOL
+0x00000000	apr_get_q6_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	apr_set_q6_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_unregister_card	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_for_each_chunk	vmlinux	EXPORT_SYMBOL
+0x00000000	get_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_current_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_subsystem_unmap_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_bss_get_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_connector_attach_property	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_vblank_post_modeset	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_renumber_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_pm_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_locked_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usermodehelper_read_lock_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_stop_and_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgroup_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_lock_active	vmlinux	EXPORT_SYMBOL
+0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_tuple_taken	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	mfd_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	evict_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipc_log_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sunrpc_init_cache_detail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xdr_encode_word	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	auth_domain_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_phys	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_config_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_get_wlan_config	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	rpc_restart_call_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_ctl_find_id	vmlinux	EXPORT_SYMBOL
+0x00000000	__uio_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_end	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_run	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_free	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_err	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_suspend_host	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	add_deserialization_func	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_release_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_fh_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_snapshot_indexed_registers	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_release_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_rpm_register_notification	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	security_sb_copy_data	vmlinux	EXPORT_SYMBOL
+0x00000000	user_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_define_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	read_bytes_from_xdr_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	roccat_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ion_handle_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x00000000	blkio_root_cgroup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdev_del	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	soft_cursor	drivers/video/console/softcursor	EXPORT_SYMBOL
+0x00000000	tcp_seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_alloc_dma_chan	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_get	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	svc_addsock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipcomp_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ct_expect_related_report	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__pskb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_bulk_transfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_io	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x00000000	__clocksource_register_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timed_output_dev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_dev_present	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_cmd_blk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	security_old_inode_init_security	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tracepoint_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_record_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hashbin_lock_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_transmit	vmlinux	EXPORT_SYMBOL
+0x00000000	strcat	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_release	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	msg_encode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_log_status	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_kunmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_mmu_pt_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dm_kcopyd_prepare_callback	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_dma_contig_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0x00000000	__trace_printk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_video_std_construct	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_defer_kevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ewma_init	vmlinux	EXPORT_SYMBOL
+0x00000000	key_put	vmlinux	EXPORT_SYMBOL
+0x00000000	bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kmemdup	vmlinux	EXPORT_SYMBOL
+0x00000000	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_copy_from_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_dapm_disable_pin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slimport_get_link_bw	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_snapshot_get_object	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_vrefresh	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_mode_set_crtcinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda827x_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	media_entity_setup_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_fd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_set_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	clk_get_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_interval_list	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_align_data_size	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_connect_src	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	save_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_compress_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iommu_set_fault_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_buf_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_unregister_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_register_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_alloc_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_device_snapshot	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_timestamp_precision	vmlinux	EXPORT_SYMBOL
+0x00000000	rpm_regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_cnew	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x00000000	default_grn	vmlinux	EXPORT_SYMBOL
+0x00000000	ioc_cgroup_changed	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_update_bits_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_pcm_format_linear	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_property_create_range	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_get_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_dma_get_bam_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ablkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6t_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fget_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_unprot_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	backlight_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	rfkill_blocked	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_transceiver	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_flush_queueable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpm_regulator_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_riva_power_on_lock	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xdr_init_decode_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_ktime_to_tm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_pre_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_format_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	regmap_bulk_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_clock_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_default_font	drivers/video/console/font	EXPORT_SYMBOL
+0x00000000	wcnss_register_thermal_mitigation	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	regulator_bulk_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cpufreq_driver_getavg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_pm_wait_for_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msm_ion_secure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	nfnetlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sps_setup_bam2bam_fifo	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_frequency_table_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_pool_alloc_aligned	vmlinux	EXPORT_SYMBOL
+0x00000000	blkiocg_update_io_remove_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_suspend_all	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_unsecure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_request_change_val_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_parse_edid	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_write	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_adc_btm_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smb345_otg_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_data_to_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_accept_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wwan_startup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_protocol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_is_requested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_allocated_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_acl_equiv_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_scm_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_info_enum_double	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wcd9xxx_lock_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x00000000	pm8xxx_set_adcmap_pa_therm	vmlinux	EXPORT_SYMBOL
+0x00000000	percpu_counter_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	test_iosched_get_debugfs_utils_root	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	hidinput_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_get_cbits_tohost	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_call_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcg_socket_limit_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ion_client_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hdmi_mhl_supported_video_mode_lut	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_idle_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_hash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_pad_aligned_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	genlock_get_handle_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_new_soc_be	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_unsubscribe_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	smd_cur_packet_size	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_event_queue_fh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	slim_request_clear_inf_element	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_sys_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_prio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_find_cea_extension	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_request_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_set_online	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vprintk	vmlinux	EXPORT_SYMBOL
+0x00000000	__udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_ssbi_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vsprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	gspca_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	adreno_dump_fields	vmlinux	EXPORT_SYMBOL
+0x00000000	ddebug_add_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_key_type	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_notif_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_task_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_rawmidi_output_params	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_conntrack_htable_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vcd_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	audit_log_end	vmlinux	EXPORT_SYMBOL
+0x00000000	smsm_reset_modem_cont	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_dxe_tx_irq	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_dxe_rx_irq	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	need_ipv4_conntrack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mm_scan_add_block	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__timecompare_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_dma_in_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_dcvs_register_core	vmlinux	EXPORT_SYMBOL
+0x00000000	irias_insert_object	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_preallocate_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_generic_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_trace_regwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_pm_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x00000000	free_user_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	clkdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	strcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	lg_local_unlock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_sense_invalidCDB	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_get_buffer_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	key_payload_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pet_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_insert_dying_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fuse_abort_conn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	node_states	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_sched_force_quiescent_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_lookup_minor_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_pci_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_pm_qos_add_ancestor_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_auth_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	subsys_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x00000000	regulatory_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_start_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_mixer_update_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gspca_auto_gain_n_exposure	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x00000000	bt_sock_link	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_unsecure_heap	vmlinux	EXPORT_SYMBOL
+0x00000000	full_name_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	ping_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	framebuffer_release	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_free_iostats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_destroy_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_free_resource_list	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_apply_custom_regulatory	vmlinux	EXPORT_SYMBOL
+0x00000000	svcauth_unix_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dm_table_get_md	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_pwrctrl_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_getattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_lookup_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xprt_lookup_rqst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_check	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	pil_get	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_expect_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_unmerge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tracepoint_probe_unregister_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_put_minor	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_calc_timestamping_constants	vmlinux	EXPORT_SYMBOL
+0x00000000	security_secctx_to_secid	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_peer_xrlim_allow	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_global_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kgsl_active_count_put	vmlinux	EXPORT_SYMBOL
+0x00000000	vcd_decode_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_lib_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_connector_list_update	vmlinux	EXPORT_SYMBOL
+0x00000000	hdmi_msm_audio_get_sample_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	textsearch_register	vmlinux	EXPORT_SYMBOL
+0x00000000	tracing_is_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_max_cpus	vmlinux	EXPORT_SYMBOL
+0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	create_ctx_debugfs	vmlinux	EXPORT_SYMBOL
+0x00000000	irlmp_get_discoveries	vmlinux	EXPORT_SYMBOL
+0x00000000	__nf_ct_expect_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ctrl_bridge_close	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_generic_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_get_rxhash	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x00000000	media_entity_find_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	FsCreateDir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_map	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_dirty_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	hashbin_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_sg_table	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_core_ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_pil_register	vmlinux	EXPORT_SYMBOL
+0x00000000	_set_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_start_bkops	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_copy_cmap	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	freezing_slow_path	vmlinux	EXPORT_SYMBOL
+0x00000000	irda_qos_bits_to_value	vmlinux	EXPORT_SYMBOL
+0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	key_update	vmlinux	EXPORT_SYMBOL
+0x00000000	socinfo_get_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_dapm_mux_update_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_init_data	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_ctl_free_one	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_free_count	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_send_ext_csd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_set_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_commit_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ring_buffer_read_finish	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_fh_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ftrace_print_flags_seq	vmlinux	EXPORT_SYMBOL
+0x00000000	km_query	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ct_helper_expectfn_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rwsem_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	check_and_create_debugfs	vmlinux	EXPORT_SYMBOL
+0x00000000	xprt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_create	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kgsl_get_memory_usage	vmlinux	EXPORT_SYMBOL
+0x00000000	drm_connector_init	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoint	vmlinux	EXPORT_SYMBOL
+0x00000000	modem_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cpufreq_get_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_raw_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__tracepoint_rpm_return_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	svc_pool_stats_open	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_pid_info_as_cred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_rate_to_rate_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	cgroup_load_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_wlan_get_device	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	pci_lost_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_queue_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_dma_out_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_rx_unexpected_4addr_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	vb2_vmalloc_memops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	totalhigh_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	soc_dpcm_be_dai_trigger	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snd_soc_jack_get_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_standard_install	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_michael_mic_failure	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	led_classdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smem_get_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	wcnss_allow_suspend	drivers/net/wireless/wcnss/wcnsscore	EXPORT_SYMBOL
+0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_target	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_serial_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_object_find	vmlinux	EXPORT_SYMBOL
+0x00000000	nfs_request_remove_commit_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smd_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rpc_queue_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pptp_msg_name	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_soc_get_codec_widget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_event_states	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_get	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
+0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_pcm_hw_param_value	vmlinux	EXPORT_SYMBOL
+0x00000000	slim_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_asc	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_time_unix2fat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smsm_state_cb_register	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_nat_follow_master	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	fuse_dev_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ring_buffer_oldest_event_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_jack_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ion_import_dma_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	lib80211_crypt_delayed_deinit	vmlinux	EXPORT_SYMBOL
+0x00000000	rpc_peeraddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sirdev_put_instance	vmlinux	EXPORT_SYMBOL
+0x00000000	sirdev_get_instance	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_cacheline_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	sps_get_bam_debug_info	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_tlmm_config	vmlinux	EXPORT_SYMBOL
+0x00000000	crc32c	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_freewait	vmlinux	EXPORT_SYMBOL
+0x00000000	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_create_on_node	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_v7_set_pte_ext	vmlinux	EXPORT_SYMBOL
+0x00000000	snd_timer_pause	vmlinux	EXPORT_SYMBOL
+0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ref_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_nat_pptp_hook_outbound	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drm_mode_legacy_fb_format	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	regulator_bulk_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wakeup_notification	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_hits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nat_t120_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genphy_config_aneg	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
+0x00000000	hci_send_acl	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_irdadev	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sk_diag_fill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arpt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_direction_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x00000000	vmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmap_atomic_idx	vmlinux	EXPORT_SYMBOL
+0x00000000	msm_bus_scale_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	AES_encrypt	vmlinux	EXPORT_SYMBOL

-/*
- * arch/arm/mach-msm/lge/lge_panic_handler.c
- *
- * Copyright (C) 2010 LGE, Inc
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/reboot.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/persistent_ram.h>
-#include <asm/setup.h>
-#include <mach/board_lge.h>
-
-#include <mach/subsystem_restart.h>
-#ifdef CONFIG_CPU_CP15_MMU
-#include <linux/ptrace.h>
-#endif
-
-#define PANIC_HANDLER_NAME "panic-handler"
-#define PANIC_DUMP_CONSOLE 0
-#define PANIC_MAGIC_KEY    0x12345678
-#define NORMAL_MAGIC_KEY   0x4E4F524D
-#define CRASH_ARM9         0x87654321
-#define CRASH_REBOOT       0x618E1000
-
-struct crash_log_dump {
-	unsigned int magic_key;
-	unsigned int size;
-	unsigned char buffer[0];
-};
-
-static struct crash_log_dump *crash_dump_log;
-static unsigned int crash_buf_size = 0;
-static int crash_store_flag = 0;
-
-#ifdef CONFIG_CPU_CP15_MMU
-unsigned long *cpu_crash_ctx=NULL;
-#endif
-
-unsigned int msm_mmuctrl;
-unsigned int msm_mmudac;
-
-void store_ctrl(void)
-{
-	asm("mrc p15, 0, %0, c1, c0, 0\n"
-			: "=r" (msm_mmuctrl));
-}
-
-void store_dac(void)
-{
-	asm("mrc p15, 0, %0, c3, c0, 0\n"
-			: "=r" (msm_mmudac));
-}
-static DEFINE_SPINLOCK(panic_lock);
-
-static int dummy_arg;
-static int gen_bug(const char *val, struct kernel_param *kp)
-{
-	BUG();
-	return 0;
-}
-module_param_call(gen_bug, gen_bug, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_panic(const char *val, struct kernel_param *kp)
-{
-	panic("generate test-panic");
-	return 0;
-}
-module_param_call(gen_panic, gen_panic, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_mdm_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("external_modem");
-	return 0;
-}
-module_param_call(gen_mdm_ssr, gen_mdm_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_modem_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("modem");
-	return 0;
-}
-module_param_call(gen_modem_ssr, gen_modem_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_riva_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("riva");
-	return 0;
-}
-module_param_call(gen_riva_ssr, gen_riva_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_dsps_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("dsps");
-	return 0;
-}
-module_param_call(gen_dsps_ssr, gen_dsps_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_lpass_ssr(const char *val, struct kernel_param *kp)
-{
-	subsystem_restart("lpass");
-	return 0;
-}
-module_param_call(gen_lpass_ssr, gen_lpass_ssr, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-#define WDT0_RST        0x38
-#define WDT0_EN         0x40
-#define WDT0_BARK_TIME  0x4C
-#define WDT0_BITE_TIME  0x5C
-
-extern void __iomem *msm_timer_get_timer0_base(void);
-
-static int gen_wdt_bark(const char *val, struct kernel_param *kp)
-{
-	static void __iomem *msm_tmr0_base;
-	msm_tmr0_base = msm_timer_get_timer0_base();
-	__raw_writel(0, msm_tmr0_base + WDT0_EN);
-	__raw_writel(1, msm_tmr0_base + WDT0_RST);
-	__raw_writel(0x31F3, msm_tmr0_base + WDT0_BARK_TIME);
-	__raw_writel(5 * 0x31F3, msm_tmr0_base + WDT0_BITE_TIME);
-	__raw_writel(1, msm_tmr0_base + WDT0_EN);
-	return 0;
-}
-module_param_call(gen_wdt_bark, gen_wdt_bark, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-static int gen_hw_reset(const char *val, struct kernel_param *kp)
-{
-	static void __iomem *msm_tmr0_base;
-	msm_tmr0_base = msm_timer_get_timer0_base();
-	__raw_writel(0, msm_tmr0_base + WDT0_EN);
-	__raw_writel(1, msm_tmr0_base + WDT0_RST);
-	__raw_writel(5 * 0x31F3, msm_tmr0_base + WDT0_BARK_TIME);
-	__raw_writel(0x31F3, msm_tmr0_base + WDT0_BITE_TIME);
-	__raw_writel(1, msm_tmr0_base + WDT0_EN);
-	return 0;
-}
-module_param_call(gen_hw_reset, gen_hw_reset, param_get_bool,
-		&dummy_arg, S_IWUSR | S_IRUGO);
-
-void set_crash_store_enable(void)
-{
-	if (crash_dump_log->magic_key == NORMAL_MAGIC_KEY)
-		crash_store_flag = 1;
-	return;
-}
-
-void set_crash_store_disable(void)
-{
-	crash_store_flag = 0;
-	return;
-}
-
-void store_crash_log(char *p)
-{
-	if (!crash_dump_log)
-		return;
-
-	if (!crash_store_flag)
-		return;
-
-	if (crash_dump_log->size == crash_buf_size)
-		return;
-
-	for ( ; *p; p++) {
-		if (*p == '[') {
-			for ( ; *p != ']'; p++)
-				;
-			p++;
-			if (*p == ' ')
-				p++;
-		}
-		if (*p == '<') {
-			for ( ; *p != '>'; p++)
-				;
-			p++;
-		}
-
-		crash_dump_log->buffer[crash_dump_log->size++] = *p;
-
-		/* check the buffer size */
-		if (crash_dump_log->size == crash_buf_size)
-			break;
-	}
-	crash_dump_log->buffer[crash_dump_log->size] = 0;
-
-	return;
-}
-
-#ifdef CONFIG_CPU_CP15_MMU
-void lge_save_ctx(struct pt_regs* regs, unsigned int ctrl,
-		unsigned int transbase, unsigned int dac)
-{
-	/* save cpu register for simulation */
-	cpu_crash_ctx[0] = regs->ARM_r0;
-	cpu_crash_ctx[1] = regs->ARM_r1;
-	cpu_crash_ctx[2] = regs->ARM_r2;
-	cpu_crash_ctx[3] = regs->ARM_r3;
-	cpu_crash_ctx[4] = regs->ARM_r4;
-	cpu_crash_ctx[5] = regs->ARM_r5;
-	cpu_crash_ctx[6] = regs->ARM_r6;
-	cpu_crash_ctx[7] = regs->ARM_r7;
-	cpu_crash_ctx[8] = regs->ARM_r8;
-	cpu_crash_ctx[9] = regs->ARM_r9;
-	cpu_crash_ctx[10] = regs->ARM_r10;
-	cpu_crash_ctx[11] = regs->ARM_fp;
-	cpu_crash_ctx[12] = regs->ARM_ip;
-	cpu_crash_ctx[13] = regs->ARM_sp;
-	cpu_crash_ctx[14] = regs->ARM_lr;
-	cpu_crash_ctx[15] = regs->ARM_pc;
-	cpu_crash_ctx[16] = regs->ARM_cpsr;
-	/* save mmu register for simulation */
-	cpu_crash_ctx[17] = ctrl;
-	cpu_crash_ctx[18] = transbase;
-	cpu_crash_ctx[19] = dac;
-}
-#endif
-
-static int restore_crash_log(struct notifier_block *this,
-		unsigned long event, void *ptr)
-{
-	unsigned long flags;
-	crash_store_flag = 0;
-	spin_lock_irqsave(&panic_lock, flags);
-	crash_dump_log->magic_key = PANIC_MAGIC_KEY;
-	spin_unlock_irqrestore(&panic_lock, flags);
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block panic_handler_block = {
-	.notifier_call = restore_crash_log,
-};
-
-static int __init panic_handler_probe(struct platform_device *pdev)
-{
-	struct persistent_ram_zone *prz;
-	size_t buffer_size;
-	void *buffer;
-	int ret = 0;
-#ifdef CONFIG_CPU_CP15_MMU
-	void *ctx_buf;
-#endif
-
-	prz = persistent_ram_init_ringbuffer(&pdev->dev, false);
-	if (IS_ERR(prz))
-		return PTR_ERR(prz);
-
-	buffer_size = prz->buffer_size - SZ_1K;
-	buffer = (void *)prz->buffer;;
-
-	crash_dump_log = (struct crash_log_dump *)buffer;
-	memset(crash_dump_log, 0, buffer_size);
-	crash_dump_log->magic_key = NORMAL_MAGIC_KEY;
-	crash_dump_log->size = 0;
-	crash_buf_size =
-		buffer_size - offsetof(struct crash_log_dump, buffer) - 1;
-#ifdef CONFIG_CPU_CP15_MMU
-	ctx_buf = (void *)(buffer + buffer_size);
-	cpu_crash_ctx = (unsigned long *)ctx_buf;
-#endif
-	atomic_notifier_chain_register(&panic_notifier_list,
-			&panic_handler_block);
-	return ret;
-}
-
-static int __devexit panic_handler_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver panic_handler_driver __refdata = {
-	.probe = panic_handler_probe,
-	.remove = __devexit_p(panic_handler_remove),
-	.driver = {
-		.name = PANIC_HANDLER_NAME,
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init lge_panic_handler_init(void)
-{
-	return platform_driver_register(&panic_handler_driver);
-}
-
-static void __exit lge_panic_handler_exit(void)
-{
-	platform_driver_unregister(&panic_handler_driver);
-}
-
-module_init(lge_panic_handler_init);
-module_exit(lge_panic_handler_exit);
-
-MODULE_DESCRIPTION("LGE panic handler driver");
-MODULE_AUTHOR("SungEun Kim <cleaneye.kim@lge.com>");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/arch/arm/mach-msm/msm_watchdog.c flo-ElementalX-5.00-patched/arch/arm/mach-msm/msm_watchdog.c
--- flo-ElementalX-5.00/arch/arm/mach-msm/msm_watchdog.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-msm/msm_watchdog.c	2016-05-12 18:51:09.000000000 +0000
@@ -270,6 +270,8 @@
 		min_slack_ns = slack_ns;
 	last_pet = time_ns;
 }
+EXPORT_SYMBOL(pet_watchdog);
+
 
 static void pet_watchdog_work(struct work_struct *work)
 {
diff -urN flo-ElementalX-5.00/arch/arm/mach-msm/ramdump.c flo-ElementalX-5.00-patched/arch/arm/mach-msm/ramdump.c
--- flo-ElementalX-5.00/arch/arm/mach-msm/ramdump.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/arch/arm/mach-msm/ramdump.c	2016-05-12 18:52:04.000000000 +0000
@@ -247,6 +247,7 @@
 
 	return (void *)rd_dev;
 }
+EXPORT_SYMBOL(create_ramdump_device);
 
 void destroy_ramdump_device(void *dev)
 {
@@ -298,3 +299,4 @@
 	rd_dev->data_ready = 0;
 	return ret;
 }
+EXPORT_SYMBOL(do_ramdump);
\ No newline at end of file

-#ifndef __ASM_ARCH_REGS_AC97_H
-#define __ASM_ARCH_REGS_AC97_H
-
-#include <mach/hardware.h>
-
-/*
- * AC97 Controller registers
- */
-
-#define POCR		__REG(0x40500000)  /* PCM Out Control Register */
-#define POCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define POCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define PICR		__REG(0x40500004)  /* PCM In Control Register */
-#define PICR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define PICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MCCR		__REG(0x40500008)  /* Mic In Control Register */
-#define MCCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
-#define MCCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define GCR		__REG(0x4050000C)  /* Global Control Register */
-#ifdef CONFIG_PXA3xx
-#define GCR_CLKBPB	(1 << 31)	/* Internal clock enable */
-#endif
-#define GCR_nDMAEN	(1 << 24)	/* non DMA Enable */
-#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
-#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
-#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
-#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
-#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
-#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
-#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
-#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
-#define GCR_COLD_RST	(1 << 1)	/* AC'97 Cold Reset (0 = active) */
-#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
-
-#define POSR		__REG(0x40500010)  /* PCM Out Status Register */
-#define POSR_FIFOE	(1 << 4)	/* FIFO error */
-#define POSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define PISR		__REG(0x40500014)  /* PCM In Status Register */
-#define PISR_FIFOE	(1 << 4)	/* FIFO error */
-#define PISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define PISR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MCSR		__REG(0x40500018)  /* Mic In Status Register */
-#define MCSR_FIFOE	(1 << 4)	/* FIFO error */
-#define MCSR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define MCSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define GSR		__REG(0x4050001C)  /* Global Status Register */
-#define GSR_CDONE	(1 << 19)	/* Command Done */
-#define GSR_SDONE	(1 << 18)	/* Status Done */
-#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
-#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
-#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
-#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
-#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
-#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
-#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
-#define GSR_PCR		(1 << 8)	/*  Primary Codec Ready */
-#define GSR_MCINT	(1 << 7)	/* Mic In Interrupt */
-#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
-#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
-#define GSR_ACOFFD	(1 << 3)	/* AC-link Shut Off Done */
-#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
-#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
-#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
-
-#define CAR		__REG(0x40500020)  /* CODEC Access Register */
-#define CAR_CAIP	(1 << 0)	/* Codec Access In Progress */
-
-#define PCDR		__REG(0x40500040)  /* PCM FIFO Data Register */
-#define MCDR		__REG(0x40500060)  /* Mic-in FIFO Data Register */
-
-#define MOCR		__REG(0x40500100)  /* Modem Out Control Register */
-#define MOCR_FEIE	(1 << 3)	/* FIFO Error */
-#define MOCR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MICR		__REG(0x40500108)  /* Modem In Control Register */
-#define MICR_FEIE	(1 << 3)	/* FIFO Error */
-#define MICR_FSRIE	(1 << 1)	/* FIFO Service Request Interrupt Enable */
-
-#define MOSR		__REG(0x40500110)  /* Modem Out Status Register */
-#define MOSR_FIFOE	(1 << 4)	/* FIFO error */
-#define MOSR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MISR		__REG(0x40500118)  /* Modem In Status Register */
-#define MISR_FIFOE	(1 << 4)	/* FIFO error */
-#define MISR_EOC	(1 << 3)	/* DMA End-of-Chain (exclusive clear) */
-#define MISR_FSR	(1 << 2)	/* FIFO Service Request */
-
-#define MODR		__REG(0x40500140)  /* Modem FIFO Data Register */
-
-#define PAC_REG_BASE	__REG(0x40500200)  /* Primary Audio Codec */
-#define SAC_REG_BASE	__REG(0x40500300)  /* Secondary Audio Codec */
-#define PMC_REG_BASE	__REG(0x40500400)  /* Primary Modem Codec */
-#define SMC_REG_BASE	__REG(0x40500500)  /* Secondary Modem Codec */
-
-#endif /* __ASM_ARCH_REGS_AC97_H */

-config FADS
-	bool
-
-config CPM1
-	bool
-	select CPM
-
-choice
-	prompt "8xx Machine Type"
-	depends on PPC_8xx
-	depends on 8xx
-	default MPC885ADS
-
-config MPC8XXFADS
-	bool "FADS"
-	select FADS
-
-config MPC86XADS
-	bool "MPC86XADS"
-	select CPM1
-	help
-	  MPC86x Application Development System by Freescale Semiconductor.
-	  The MPC86xADS is meant to serve as a platform for s/w and h/w
-	  development around the MPC86X processor families.
-
-config MPC885ADS
-	bool "MPC885ADS"
-	select CPM1
-	select OF_DYNAMIC
-	help
-	  Freescale Semiconductor MPC885 Application Development System (ADS).
-	  Also known as DUET.
-	  The MPC885ADS is meant to serve as a platform for s/w and h/w
-	  development around the MPC885 processor family.
-
-config PPC_EP88XC
-	bool "Embedded Planet EP88xC (a.k.a. CWH-PPC-885XN-VE)"
-	select CPM1
-	help
-	  This enables support for the Embedded Planet EP88xC board.
-
-	  This board is also resold by Freescale as the QUICCStart
-	  MPC885 Evaluation System and/or the CWH-PPC-885XN-VE.
-
-config PPC_ADDER875
-	bool "Analogue & Micro Adder 875"
-	select CPM1
-	select REDBOOT
-	help
-	  This enables support for the Analogue & Micro Adder 875
-	  board.
-
-config TQM8XX
-	bool "TQM8XX"
-	select CPM1
-	help
-	  support for the mpc8xx based boards from TQM.
-
-endchoice
-
-menu "Freescale Ethernet driver platform-specific options"
-	depends on (FS_ENET && MPC885ADS)
-
-	config MPC8xx_SECOND_ETH
-	bool "Second Ethernet channel"
-	depends on MPC885ADS
-	default y
-	help
-	  This enables support for second Ethernet on MPC885ADS and MPC86xADS boards.
-	  The latter will use SCC1, for 885ADS you can select it below.
-
-	choice
-		prompt "Second Ethernet channel"
-		depends on MPC8xx_SECOND_ETH
-		default MPC8xx_SECOND_ETH_FEC2
-
-		config MPC8xx_SECOND_ETH_FEC2
-		bool "FEC2"
-		depends on MPC885ADS
-		help
-		  Enable FEC2 to serve as 2-nd Ethernet channel. Note that SMC2
-		  (often 2-nd UART) will not work if this is enabled.
-
-		config MPC8xx_SECOND_ETH_SCC3
-		bool "SCC3"
-		depends on MPC885ADS
-		help
-		  Enable SCC3 to serve as 2-nd Ethernet channel. Note that SMC1
-		  (often 1-nd UART) will not work if this is enabled.
-
-	endchoice
-
-endmenu
-
-#
-# MPC8xx Communication options
-#
-
-menu "MPC8xx CPM Options"
-	depends on 8xx
-
-# This doesn't really belong here, but it is convenient to ask
-# 8xx specific questions.
-comment "Generic MPC8xx Options"
-
-config 8xx_COPYBACK
-	bool "Copy-Back Data Cache (else Writethrough)"
-	help
-	  Saying Y here will cause the cache on an MPC8xx processor to be used
-	  in Copy-Back mode.  If you say N here, it is used in Writethrough
-	  mode.
-
-	  If in doubt, say Y here.
-
-config 8xx_GPIO
-	bool "GPIO API Support"
-	select GENERIC_GPIO
-	select ARCH_REQUIRE_GPIOLIB
-	help
-	  Saying Y here will cause the ports on an MPC8xx processor to be used
-	  with the GPIO API.  If you say N here, the kernel needs less memory.
-
-	  If in doubt, say Y here.
-
-config 8xx_CPU6
-	bool "CPU6 Silicon Errata (860 Pre Rev. C)"
-	help
-	  MPC860 CPUs, prior to Rev C have some bugs in the silicon, which
-	  require workarounds for Linux (and most other OSes to work).  If you
-	  get a BUG() very early in boot, this might fix the problem.  For
-	  more details read the document entitled "MPC860 Family Device Errata
-	  Reference" on Freescale's website.  This option also incurs a
-	  performance hit.
-
-	  If in doubt, say N here.
-
-config 8xx_CPU15
-	bool "CPU15 Silicon Errata"
-	default y
-	help
-	  This enables a workaround for erratum CPU15 on MPC8xx chips.
-	  This bug can cause incorrect code execution under certain
-	  circumstances.  This workaround adds some overhead (a TLB miss
-	  every time execution crosses a page boundary), and you may wish
-	  to disable it if you have worked around the bug in the compiler
-	  (by not placing conditional branches or branches to LR or CTR
-	  in the last word of a page, with a target of the last cache
-	  line in the next page), or if you have used some other
-	  workaround.
-
-	  If in doubt, say Y here.
-
-choice
-	prompt "Microcode patch selection"
-	default NO_UCODE_PATCH
-	help
-	  Help not implemented yet, coming soon.
-
-config NO_UCODE_PATCH
-	bool "None"
-
-config USB_SOF_UCODE_PATCH
-	bool "USB SOF patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_UCODE_PATCH
-	bool "I2C/SPI relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_SMC1_UCODE_PATCH
-	bool "I2C/SPI/SMC1 relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-endchoice
-
-config UCODE_PATCH
-	bool
-	default y
-	depends on !NO_UCODE_PATCH
-
-endmenu

-/*
- *  arch/s390/kernel/processor.c
- *
- *  Copyright IBM Corp. 2008
- *  Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
- */
-
-#define KMSG_COMPONENT "cpu"
-#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/seq_file.h>
-#include <linux/delay.h>
-#include <linux/cpu.h>
-#include <asm/elf.h>
-#include <asm/lowcore.h>
-#include <asm/param.h>
-
-static DEFINE_PER_CPU(struct cpuid, cpu_id);
-
-/*
- * cpu_init - initializes state that is per-CPU.
- */
-void __cpuinit cpu_init(void)
-{
-	struct cpuid *id = &per_cpu(cpu_id, smp_processor_id());
-
-	get_cpu_id(id);
-	atomic_inc(&init_mm.mm_count);
-	current->active_mm = &init_mm;
-	BUG_ON(current->mm);
-	enter_lazy_tlb(&init_mm, current);
-}
-
-/*
- * show_cpuinfo - Get information on one CPU for use by procfs.
- */
-static int show_cpuinfo(struct seq_file *m, void *v)
-{
-	static const char *hwcap_str[10] = {
-		"esan3", "zarch", "stfle", "msa", "ldisp", "eimm", "dfp",
-		"edat", "etf3eh", "highgprs"
-	};
-	unsigned long n = (unsigned long) v - 1;
-	int i;
-
-	if (!n) {
-		s390_adjust_jiffies();
-		seq_printf(m, "vendor_id       : IBM/S390\n"
-			   "# processors    : %i\n"
-			   "bogomips per cpu: %lu.%02lu\n",
-			   num_online_cpus(), loops_per_jiffy/(500000/HZ),
-			   (loops_per_jiffy/(5000/HZ))%100);
-		seq_puts(m, "features\t: ");
-		for (i = 0; i < 10; i++)
-			if (hwcap_str[i] && (elf_hwcap & (1UL << i)))
-				seq_printf(m, "%s ", hwcap_str[i]);
-		seq_puts(m, "\n");
-	}
-	get_online_cpus();
-	if (cpu_online(n)) {
-		struct cpuid *id = &per_cpu(cpu_id, n);
-		seq_printf(m, "processor %li: "
-			   "version = %02X,  "
-			   "identification = %06X,  "
-			   "machine = %04X\n",
-			   n, id->version, id->ident, id->machine);
-	}
-	put_online_cpus();
-	return 0;
-}
-
-static void *c_start(struct seq_file *m, loff_t *pos)
-{
-	return *pos < nr_cpu_ids ? (void *)((unsigned long) *pos + 1) : NULL;
-}
-
-static void *c_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return c_start(m, pos);
-}
-
-static void c_stop(struct seq_file *m, void *v)
-{
-}
-
-const struct seq_operations cpuinfo_op = {
-	.start	= c_start,
-	.next	= c_next,
-	.stop	= c_stop,
-	.show	= show_cpuinfo,
-};
-

-/* pci_common.c: PCI controller common support.
- *
- * Copyright (C) 1999, 2007 David S. Miller (davem@davemloft.net)
- */
-
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/device.h>
-#include <linux/of_device.h>
-
-#include <asm/prom.h>
-#include <asm/oplib.h>
-
-#include "pci_impl.h"
-#include "pci_sun4v.h"
-
-static int config_out_of_range(struct pci_pbm_info *pbm,
-			       unsigned long bus,
-			       unsigned long devfn,
-			       unsigned long reg)
-{
-	if (bus < pbm->pci_first_busno ||
-	    bus > pbm->pci_last_busno)
-		return 1;
-	return 0;
-}
-
-static void *sun4u_config_mkaddr(struct pci_pbm_info *pbm,
-				 unsigned long bus,
-				 unsigned long devfn,
-				 unsigned long reg)
-{
-	unsigned long rbits = pbm->config_space_reg_bits;
-
-	if (config_out_of_range(pbm, bus, devfn, reg))
-		return NULL;
-
-	reg = (reg & ((1 << rbits) - 1));
-	devfn <<= rbits;
-	bus <<= rbits + 8;
-
-	return (void *)	(pbm->config_space | bus | devfn | reg);
-}
-
-/* At least on Sabre, it is necessary to access all PCI host controller
- * registers at their natural size, otherwise zeros are returned.
- * Strange but true, and I see no language in the UltraSPARC-IIi
- * programmer's manual that mentions this even indirectly.
- */
-static int sun4u_read_pci_cfg_host(struct pci_pbm_info *pbm,
-				   unsigned char bus, unsigned int devfn,
-				   int where, int size, u32 *value)
-{
-	u32 tmp32, *addr;
-	u16 tmp16;
-	u8 tmp8;
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		if (where < 8) {
-			unsigned long align = (unsigned long) addr;
-
-			align &= ~1;
-			pci_config_read16((u16 *)align, &tmp16);
-			if (where & 1)
-				*value = tmp16 >> 8;
-			else
-				*value = tmp16 & 0xff;
-		} else {
-			pci_config_read8((u8 *)addr, &tmp8);
-			*value = (u32) tmp8;
-		}
-		break;
-
-	case 2:
-		if (where < 8) {
-			pci_config_read16((u16 *)addr, &tmp16);
-			*value = (u32) tmp16;
-		} else {
-			pci_config_read8((u8 *)addr, &tmp8);
-			*value = (u32) tmp8;
-			pci_config_read8(((u8 *)addr) + 1, &tmp8);
-			*value |= ((u32) tmp8) << 8;
-		}
-		break;
-
-	case 4:
-		tmp32 = 0xffffffff;
-		sun4u_read_pci_cfg_host(pbm, bus, devfn,
-					where, 2, &tmp32);
-		*value = tmp32;
-
-		tmp32 = 0xffffffff;
-		sun4u_read_pci_cfg_host(pbm, bus, devfn,
-					where + 2, 2, &tmp32);
-		*value |= tmp32 << 16;
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			      int where, int size, u32 *value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	unsigned char bus = bus_dev->number;
-	u32 *addr;
-	u16 tmp16;
-	u8 tmp8;
-
-	switch (size) {
-	case 1:
-		*value = 0xff;
-		break;
-	case 2:
-		*value = 0xffff;
-		break;
-	case 4:
-		*value = 0xffffffff;
-		break;
-	}
-
-	if (!bus_dev->number && !PCI_SLOT(devfn))
-		return sun4u_read_pci_cfg_host(pbm, bus, devfn, where,
-					       size, value);
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		pci_config_read8((u8 *)addr, &tmp8);
-		*value = (u32) tmp8;
-		break;
-
-	case 2:
-		if (where & 0x01) {
-			printk("pci_read_config_word: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_read16((u16 *)addr, &tmp16);
-		*value = (u32) tmp16;
-		break;
-
-	case 4:
-		if (where & 0x03) {
-			printk("pci_read_config_dword: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_read32(addr, value);
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_write_pci_cfg_host(struct pci_pbm_info *pbm,
-				    unsigned char bus, unsigned int devfn,
-				    int where, int size, u32 value)
-{
-	u32 *addr;
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		if (where < 8) {
-			unsigned long align = (unsigned long) addr;
-			u16 tmp16;
-
-			align &= ~1;
-			pci_config_read16((u16 *)align, &tmp16);
-			if (where & 1) {
-				tmp16 &= 0x00ff;
-				tmp16 |= value << 8;
-			} else {
-				tmp16 &= 0xff00;
-				tmp16 |= value;
-			}
-			pci_config_write16((u16 *)align, tmp16);
-		} else
-			pci_config_write8((u8 *)addr, value);
-		break;
-	case 2:
-		if (where < 8) {
-			pci_config_write16((u16 *)addr, value);
-		} else {
-			pci_config_write8((u8 *)addr, value & 0xff);
-			pci_config_write8(((u8 *)addr) + 1, value >> 8);
-		}
-		break;
-	case 4:
-		sun4u_write_pci_cfg_host(pbm, bus, devfn,
-					 where, 2, value & 0xffff);
-		sun4u_write_pci_cfg_host(pbm, bus, devfn,
-					 where + 2, 2, value >> 16);
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4u_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			       int where, int size, u32 value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	unsigned char bus = bus_dev->number;
-	u32 *addr;
-
-	if (!bus_dev->number && !PCI_SLOT(devfn))
-		return sun4u_write_pci_cfg_host(pbm, bus, devfn, where,
-						size, value);
-
-	addr = sun4u_config_mkaddr(pbm, bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_SUCCESSFUL;
-
-	switch (size) {
-	case 1:
-		pci_config_write8((u8 *)addr, value);
-		break;
-
-	case 2:
-		if (where & 0x01) {
-			printk("pci_write_config_word: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_write16((u16 *)addr, value);
-		break;
-
-	case 4:
-		if (where & 0x03) {
-			printk("pci_write_config_dword: misaligned reg [%x]\n",
-			       where);
-			return PCIBIOS_SUCCESSFUL;
-		}
-		pci_config_write32(addr, value);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops sun4u_pci_ops = {
-	.read =		sun4u_read_pci_cfg,
-	.write =	sun4u_write_pci_cfg,
-};
-
-static int sun4v_read_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			      int where, int size, u32 *value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	u32 devhandle = pbm->devhandle;
-	unsigned int bus = bus_dev->number;
-	unsigned int device = PCI_SLOT(devfn);
-	unsigned int func = PCI_FUNC(devfn);
-	unsigned long ret;
-
-	if (config_out_of_range(pbm, bus, devfn, where)) {
-		ret = ~0UL;
-	} else {
-		ret = pci_sun4v_config_get(devhandle,
-				HV_PCI_DEVICE_BUILD(bus, device, func),
-				where, size);
-	}
-	switch (size) {
-	case 1:
-		*value = ret & 0xff;
-		break;
-	case 2:
-		*value = ret & 0xffff;
-		break;
-	case 4:
-		*value = ret & 0xffffffff;
-		break;
-	}
-
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sun4v_write_pci_cfg(struct pci_bus *bus_dev, unsigned int devfn,
-			       int where, int size, u32 value)
-{
-	struct pci_pbm_info *pbm = bus_dev->sysdata;
-	u32 devhandle = pbm->devhandle;
-	unsigned int bus = bus_dev->number;
-	unsigned int device = PCI_SLOT(devfn);
-	unsigned int func = PCI_FUNC(devfn);
-
-	if (config_out_of_range(pbm, bus, devfn, where)) {
-		/* Do nothing. */
-	} else {
-		/* We don't check for hypervisor errors here, but perhaps
-		 * we should and influence our return value depending upon
-		 * what kind of error is thrown.
-		 */
-		pci_sun4v_config_put(devhandle,
-				     HV_PCI_DEVICE_BUILD(bus, device, func),
-				     where, size, value);
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops sun4v_pci_ops = {
-	.read =		sun4v_read_pci_cfg,
-	.write =	sun4v_write_pci_cfg,
-};
-
-void pci_get_pbm_props(struct pci_pbm_info *pbm)
-{
-	const u32 *val = of_get_property(pbm->op->dev.of_node, "bus-range", NULL);
-
-	pbm->pci_first_busno = val[0];
-	pbm->pci_last_busno = val[1];
-
-	val = of_get_property(pbm->op->dev.of_node, "ino-bitmap", NULL);
-	if (val) {
-		pbm->ino_bitmap = (((u64)val[1] << 32UL) |
-				   ((u64)val[0] <<  0UL));
-	}
-}
-
-static void pci_register_legacy_regions(struct resource *io_res,
-					struct resource *mem_res)
-{
-	struct resource *p;
-
-	/* VGA Video RAM. */
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "Video RAM area";
-	p->start = mem_res->start + 0xa0000UL;
-	p->end = p->start + 0x1ffffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "System ROM";
-	p->start = mem_res->start + 0xf0000UL;
-	p->end = p->start + 0xffffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return;
-
-	p->name = "Video ROM";
-	p->start = mem_res->start + 0xc0000UL;
-	p->end = p->start + 0x7fffUL;
-	p->flags = IORESOURCE_BUSY;
-	request_resource(mem_res, p);
-}
-
-static void pci_register_iommu_region(struct pci_pbm_info *pbm)
-{
-	const u32 *vdma = of_get_property(pbm->op->dev.of_node, "virtual-dma",
-					  NULL);
-
-	if (vdma) {
-		struct resource *rp = kzalloc(sizeof(*rp), GFP_KERNEL);
-
-		if (!rp) {
-			pr_info("%s: Cannot allocate IOMMU resource.\n",
-				pbm->name);
-			return;
-		}
-		rp->name = "IOMMU";
-		rp->start = pbm->mem_space.start + (unsigned long) vdma[0];
-		rp->end = rp->start + (unsigned long) vdma[1] - 1UL;
-		rp->flags = IORESOURCE_BUSY;
-		if (request_resource(&pbm->mem_space, rp)) {
-			pr_info("%s: Unable to request IOMMU resource.\n",
-				pbm->name);
-			kfree(rp);
-		}
-	}
-}
-
-void pci_determine_mem_io_space(struct pci_pbm_info *pbm)
-{
-	const struct linux_prom_pci_ranges *pbm_ranges;
-	int i, saw_mem, saw_io;
-	int num_pbm_ranges;
-
-	saw_mem = saw_io = 0;
-	pbm_ranges = of_get_property(pbm->op->dev.of_node, "ranges", &i);
-	if (!pbm_ranges) {
-		prom_printf("PCI: Fatal error, missing PBM ranges property "
-			    " for %s\n",
-			    pbm->name);
-		prom_halt();
-	}
-
-	num_pbm_ranges = i / sizeof(*pbm_ranges);
-
-	for (i = 0; i < num_pbm_ranges; i++) {
-		const struct linux_prom_pci_ranges *pr = &pbm_ranges[i];
-		unsigned long a, size;
-		u32 parent_phys_hi, parent_phys_lo;
-		u32 size_hi, size_lo;
-		int type;
-
-		parent_phys_hi = pr->parent_phys_hi;
-		parent_phys_lo = pr->parent_phys_lo;
-		if (tlb_type == hypervisor)
-			parent_phys_hi &= 0x0fffffff;
-
-		size_hi = pr->size_hi;
-		size_lo = pr->size_lo;
-
-		type = (pr->child_phys_hi >> 24) & 0x3;
-		a = (((unsigned long)parent_phys_hi << 32UL) |
-		     ((unsigned long)parent_phys_lo  <<  0UL));
-		size = (((unsigned long)size_hi << 32UL) |
-			((unsigned long)size_lo  <<  0UL));
-
-		switch (type) {
-		case 0:
-			/* PCI config space, 16MB */
-			pbm->config_space = a;
-			break;
-
-		case 1:
-			/* 16-bit IO space, 16MB */
-			pbm->io_space.start = a;
-			pbm->io_space.end = a + size - 1UL;
-			pbm->io_space.flags = IORESOURCE_IO;
-			saw_io = 1;
-			break;
-
-		case 2:
-			/* 32-bit MEM space, 2GB */
-			pbm->mem_space.start = a;
-			pbm->mem_space.end = a + size - 1UL;
-			pbm->mem_space.flags = IORESOURCE_MEM;
-			saw_mem = 1;
-			break;
-
-		case 3:
-			/* XXX 64-bit MEM handling XXX */
-
-		default:
-			break;
-		}
-	}
-
-	if (!saw_io || !saw_mem) {
-		prom_printf("%s: Fatal error, missing %s PBM range.\n",
-			    pbm->name,
-			    (!saw_io ? "IO" : "MEM"));
-		prom_halt();
-	}
-
-	printk("%s: PCI IO[%llx] MEM[%llx]\n",
-	       pbm->name,
-	       pbm->io_space.start,
-	       pbm->mem_space.start);
-
-	pbm->io_space.name = pbm->mem_space.name = pbm->name;
-
-	request_resource(&ioport_resource, &pbm->io_space);
-	request_resource(&iomem_resource, &pbm->mem_space);
-
-	pci_register_legacy_regions(&pbm->io_space,
-				    &pbm->mem_space);
-	pci_register_iommu_region(pbm);
-}
-
-/* Generic helper routines for PCI error reporting. */
-void pci_scan_for_target_abort(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_SIG_TARGET_ABORT |
-				   PCI_STATUS_REC_TARGET_ABORT));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s saw Target Abort [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_target_abort(pbm, bus);
-}
-
-void pci_scan_for_master_abort(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_REC_MASTER_ABORT));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s received Master Abort [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_master_abort(pbm, bus);
-}
-
-void pci_scan_for_parity_error(struct pci_pbm_info *pbm,
-			       struct pci_bus *pbus)
-{
-	struct pci_dev *pdev;
-	struct pci_bus *bus;
-
-	list_for_each_entry(pdev, &pbus->devices, bus_list) {
-		u16 status, error_bits;
-
-		pci_read_config_word(pdev, PCI_STATUS, &status);
-		error_bits =
-			(status & (PCI_STATUS_PARITY |
-				   PCI_STATUS_DETECTED_PARITY));
-		if (error_bits) {
-			pci_write_config_word(pdev, PCI_STATUS, error_bits);
-			printk("%s: Device %s saw Parity Error [%016x]\n",
-			       pbm->name, pci_name(pdev), status);
-		}
-	}
-
-	list_for_each_entry(bus, &pbus->children, node)
-		pci_scan_for_parity_error(pbm, bus);
-}
diff -urN flo-ElementalX-5.00/drivers/base/Kconfig flo-ElementalX-5.00-patched/drivers/base/Kconfig
--- flo-ElementalX-5.00/drivers/base/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/Kconfig	2016-06-01 15:47:50.000000000 +0000
@@ -145,6 +145,17 @@
 	  this option you can point it elsewhere, such as /lib/firmware/ or
 	  some other directory containing the firmware files.
 
+config FW_LOADER_USER_HELPER
+	bool "Fallback user-helper invocation for firmware loading"
+	depends on FW_LOADER
+	default y
+	help
+	  This option enables / disables the invocation of user-helper
+	  (e.g. udev) for loading firmware files as a fallback after the
+	  direct file loading in kernel fails.  The user-mode helper is
+	  no longer required unless you have a special firmware file that
+	  resides in a non-standard path.
+
 config DEBUG_DRIVER
 	bool "Driver Core verbose debug messages"
 	depends on DEBUG_KERNEL
diff -urN flo-ElementalX-5.00/drivers/base/core.c flo-ElementalX-5.00-patched/drivers/base/core.c
--- flo-ElementalX-5.00/drivers/base/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/core.c	2016-06-01 15:47:50.000000000 +0000
@@ -84,14 +84,13 @@
 }
 EXPORT_SYMBOL(dev_driver_string);
 
-#define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
 static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 			     char *buf)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->show)
@@ -107,7 +106,7 @@
 			      const char *buf, size_t count)
 {
 	struct device_attribute *dev_attr = to_dev_attr(attr);
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	ssize_t ret = -EIO;
 
 	if (dev_attr->store)
@@ -181,7 +180,7 @@
  */
 static void device_release(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct device_private *p = dev->p;
 
 	if (dev->release)
@@ -199,7 +198,7 @@
 
 static const void *device_namespace(struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	const void *ns = NULL;
 
 	if (dev->class && dev->class->ns_type)
@@ -220,7 +219,7 @@
 	struct kobj_type *ktype = get_ktype(kobj);
 
 	if (ktype == &device_ktype) {
-		struct device *dev = to_dev(kobj);
+		struct device *dev = kobj_to_dev(kobj);
 		if (dev->bus)
 			return 1;
 		if (dev->class)
@@ -231,7 +230,7 @@
 
 static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 
 	if (dev->bus)
 		return dev->bus->name;
@@ -243,7 +242,7 @@
 static int dev_uevent(struct kset *kset, struct kobject *kobj,
 		      struct kobj_uevent_env *env)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	int retval = 0;
 
 	/* add device node properties if present */
@@ -1131,7 +1130,7 @@
  */
 struct device *get_device(struct device *dev)
 {
-	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
+	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
 }
 
 /**
diff -urN flo-ElementalX-5.00/drivers/base/devres.c flo-ElementalX-5.00-patched/drivers/base/devres.c
--- flo-ElementalX-5.00/drivers/base/devres.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/devres.c	2016-06-01 15:47:50.000000000 +0000
@@ -144,6 +144,48 @@
 #endif
 
 /**
+ * devres_for_each_res - Resource iterator
+ * @dev: Device to iterate resource from
+ * @release: Look for resources associated with this release function
+ * @match: Match function (optional)
+ * @match_data: Data for the match function
+ * @fn: Function to be called for each matched resource.
+ * @data: Data for @fn, the 3rd parameter of @fn
+ *
+ * Call @fn for each devres of @dev which is associated with @release
+ * and for which @match returns 1.
+ *
+ * RETURNS:
+ * 	void
+ */
+void devres_for_each_res(struct device *dev, dr_release_t release,
+			dr_match_t match, void *match_data,
+			void (*fn)(struct device *, void *, void *),
+			void *data)
+{
+	struct devres_node *node;
+	struct devres_node *tmp;
+	unsigned long flags;
+
+	if (!fn)
+		return;
+
+	spin_lock_irqsave(&dev->devres_lock, flags);
+	list_for_each_entry_safe_reverse(node, tmp,
+			&dev->devres_head, entry) {
+		struct devres *dr = container_of(node, struct devres, node);
+
+		if (node->release != release)
+			continue;
+		if (match && !match(dev, dr->data, match_data))
+			continue;
+		fn(dev, dr->data, data);
+	}
+	spin_unlock_irqrestore(&dev->devres_lock, flags);
+}
+EXPORT_SYMBOL_GPL(devres_for_each_res);
+
+/**
  * devres_free - Free device resource data
  * @res: Pointer to devres data to free
  *
@@ -309,6 +351,10 @@
  * which @match returns 1.  If @match is NULL, it's considered to
  * match all.  If found, the resource is removed atomically and freed.
  *
+ * Note that the release function for the resource will not be called,
+ * only the devres-allocated data will be freed.  The caller becomes
+ * responsible for freeing any other data.
+ *
  * RETURNS:
  * 0 if devres is found and freed, -ENOENT if not found.
  */
@@ -326,6 +372,37 @@
 }
 EXPORT_SYMBOL_GPL(devres_destroy);
 
+
+/**
+ * devres_release - Find a device resource and destroy it, calling release
+ * @dev: Device to find resource from
+ * @release: Look for resources associated with this release function
+ * @match: Match function (optional)
+ * @match_data: Data for the match function
+ *
+ * Find the latest devres of @dev associated with @release and for
+ * which @match returns 1.  If @match is NULL, it's considered to
+ * match all.  If found, the resource is removed atomically, the
+ * release function called and the resource freed.
+ *
+ * RETURNS:
+ * 0 if devres is found and freed, -ENOENT if not found.
+ */
+int devres_release(struct device *dev, dr_release_t release,
+		   dr_match_t match, void *match_data)
+{
+	void *res;
+
+	res = devres_remove(dev, release, match, match_data);
+	if (unlikely(!res))
+		return -ENOENT;
+
+	(*release)(dev, res);
+	devres_free(res);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devres_release);
+
 static int remove_nodes(struct device *dev,
 			struct list_head *first, struct list_head *end,
 			struct list_head *todo)
diff -urN flo-ElementalX-5.00/drivers/base/firmware_class.c flo-ElementalX-5.00-patched/drivers/base/firmware_class.c
--- flo-ElementalX-5.00/drivers/base/firmware_class.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/firmware_class.c	2016-06-08 14:18:15.277000100 +0000
@@ -21,8 +21,16 @@
 #include <linux/firmware.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/list.h>
+#include <linux/async.h>
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
 
-#define to_dev(obj) container_of(obj, struct device, kobj)
+#include <generated/utsrelease.h>
+
+#include "base.h"
 
 MODULE_AUTHOR("Manuel Estrada Sainz");
 MODULE_DESCRIPTION("Multi purpose firmware loading support");
@@ -87,23 +95,354 @@
 	return loading_timeout > 0 ? loading_timeout * HZ : MAX_SCHEDULE_TIMEOUT;
 }
 
-/* fw_lock could be moved to 'struct firmware_priv' but since it is just
- * guarding for corner cases a global lock should be OK */
-static DEFINE_MUTEX(fw_lock);
+struct firmware_cache {
+	/* firmware_buf instance will be added into the below list */
+	spinlock_t lock;
+	struct list_head head;
+	int state;
+
+#ifdef CONFIG_PM_SLEEP
+	/*
+	 * Names of firmware images which have been cached successfully
+	 * will be added into the below list so that device uncache
+	 * helper can trace which firmware images have been cached
+	 * before.
+	 */
+	spinlock_t name_lock;
+	struct list_head fw_names;
+
+	wait_queue_head_t wait_queue;
+	int cnt;
+	struct delayed_work work;
 
-struct firmware_priv {
+	struct notifier_block   pm_notify;
+#endif
+};
+
+struct firmware_buf {
+	struct kref ref;
+	struct list_head list;
 	struct completion completion;
-	struct firmware *fw;
+	struct firmware_cache *fwc;
 	unsigned long status;
+	void *data;
+	size_t size;
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	bool is_paged_buf;
 	struct page **pages;
 	int nr_pages;
 	int page_array_size;
-	struct timer_list timeout;
-	struct device dev;
-	bool nowait;
+#endif
 	char fw_id[];
 };
 
+struct fw_cache_entry {
+	struct list_head list;
+	char name[];
+};
+
+struct fw_name_devm {
+	unsigned long magic;
+	char name[];
+};
+
+#define to_fwbuf(d) container_of(d, struct firmware_buf, ref)
+
+#define	FW_LOADER_NO_CACHE	0
+#define	FW_LOADER_START_CACHE	1
+
+static int fw_cache_piggyback_on_request(const char *name);
+
+/* fw_lock could be moved to 'struct firmware_priv' but since it is just
+ * guarding for corner cases a global lock should be OK */
+static DEFINE_MUTEX(fw_lock);
+
+static struct firmware_cache fw_cache;
+
+static struct firmware_buf *__allocate_fw_buf(const char *fw_name,
+					      struct firmware_cache *fwc)
+{
+	struct firmware_buf *buf;
+
+	buf = kzalloc(sizeof(*buf) + strlen(fw_name) + 1 , GFP_ATOMIC);
+
+	if (!buf)
+		return buf;
+
+	kref_init(&buf->ref);
+	strcpy(buf->fw_id, fw_name);
+	buf->fwc = fwc;
+	init_completion(&buf->completion);
+
+	pr_debug("%s: fw-%s buf=%p\n", __func__, fw_name, buf);
+
+	return buf;
+}
+
+static struct firmware_buf *__fw_lookup_buf(const char *fw_name)
+{
+	struct firmware_buf *tmp;
+	struct firmware_cache *fwc = &fw_cache;
+
+	list_for_each_entry(tmp, &fwc->head, list)
+		if (!strcmp(tmp->fw_id, fw_name))
+			return tmp;
+	return NULL;
+}
+
+static int fw_lookup_and_allocate_buf(const char *fw_name,
+				      struct firmware_cache *fwc,
+				      struct firmware_buf **buf)
+{
+	struct firmware_buf *tmp;
+
+	spin_lock(&fwc->lock);
+	tmp = __fw_lookup_buf(fw_name);
+	if (tmp) {
+		kref_get(&tmp->ref);
+		spin_unlock(&fwc->lock);
+		*buf = tmp;
+		return 1;
+	}
+	tmp = __allocate_fw_buf(fw_name, fwc);
+	if (tmp)
+		list_add(&tmp->list, &fwc->head);
+	spin_unlock(&fwc->lock);
+
+	*buf = tmp;
+
+	return tmp ? 0 : -ENOMEM;
+}
+
+static struct firmware_buf *fw_lookup_buf(const char *fw_name)
+{
+	struct firmware_buf *tmp;
+	struct firmware_cache *fwc = &fw_cache;
+
+	spin_lock(&fwc->lock);
+	tmp = __fw_lookup_buf(fw_name);
+	spin_unlock(&fwc->lock);
+
+	return tmp;
+}
+
+static void __fw_free_buf(struct kref *ref)
+{
+	struct firmware_buf *buf = to_fwbuf(ref);
+	struct firmware_cache *fwc = buf->fwc;
+
+	pr_debug("%s: fw-%s buf=%p data=%p size=%u\n",
+		 __func__, buf->fw_id, buf, buf->data,
+		 (unsigned int)buf->size);
+
+	list_del(&buf->list);
+	spin_unlock(&fwc->lock);
+
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	if (buf->is_paged_buf) {
+		int i;
+		vunmap(buf->data);
+		for (i = 0; i < buf->nr_pages; i++)
+			__free_page(buf->pages[i]);
+		kfree(buf->pages);
+	} else
+#endif
+		vfree(buf->data);
+	kfree(buf);
+}
+
+static void fw_free_buf(struct firmware_buf *buf)
+{
+	struct firmware_cache *fwc = buf->fwc;
+	spin_lock(&fwc->lock);
+	if (!kref_put(&buf->ref, __fw_free_buf))
+		spin_unlock(&fwc->lock);
+}
+
+/* direct firmware loading support */
+static char fw_path_para[256];
+static const char * const fw_path[] = {
+	fw_path_para,
+	"/lib/firmware/updates/" UTS_RELEASE,
+	"/lib/firmware/updates",
+	"/lib/firmware/" UTS_RELEASE,
+	"/lib/firmware"
+};
+
+/*
+ * Typical usage is that passing 'firmware_class.path=$CUSTOMIZED_PATH'
+ * from kernel command line because firmware_class is generally built in
+ * kernel instead of module.
+ */
+module_param_string(path, fw_path_para, sizeof(fw_path_para), 0644);
+MODULE_PARM_DESC(path, "customized firmware image search path with a higher priority than default path");
+
+/* Don't inline this: 'struct kstat' is biggish */
+static noinline_for_stack long fw_file_size(struct file *file)
+{
+	struct kstat st;
+	if (vfs_getattr(file->f_path.mnt, file->f_path.dentry, &st))
+		return -1;
+	if (!S_ISREG(st.mode))
+		return -1;
+	if (st.size != (long)st.size)
+		return -1;
+	return st.size;
+}
+
+static bool fw_read_file_contents(struct file *file, struct firmware_buf *fw_buf)
+{
+	long size;
+	char *buf;
+
+	size = fw_file_size(file);
+	if (size <= 0)
+		return false;
+	buf = vmalloc(size);
+	if (!buf)
+		return false;
+	if (kernel_read(file, 0, buf, size) != size) {
+		vfree(buf);
+		return false;
+	}
+	fw_buf->data = buf;
+	fw_buf->size = size;
+	return true;
+}
+
+static bool fw_get_filesystem_firmware(struct device *device,
+				       struct firmware_buf *buf)
+{
+	int i;
+	bool success = false;
+	char *path = __getname();
+
+	for (i = 0; i < ARRAY_SIZE(fw_path); i++) {
+		struct file *file;
+
+		/* skip the unset customized path */
+		if (!fw_path[i][0])
+			continue;
+
+		snprintf(path, PATH_MAX, "%s/%s", fw_path[i], buf->fw_id);
+
+		file = filp_open(path, O_RDONLY, 0);
+		if (IS_ERR(file))
+			continue;
+		success = fw_read_file_contents(file, buf);
+		fput(file);
+		if (success)
+			break;
+	}
+	__putname(path);
+
+	if (success) {
+		dev_dbg(device, "firmware: direct-loading firmware %s\n",
+			buf->fw_id);
+		mutex_lock(&fw_lock);
+		set_bit(FW_STATUS_DONE, &buf->status);
+		complete_all(&buf->completion);
+		mutex_unlock(&fw_lock);
+	}
+
+	return success;
+}
+
+/* firmware holds the ownership of pages */
+static void firmware_free_data(const struct firmware *fw)
+{
+	/* Loaded directly? */
+	if (!fw->priv) {
+		vfree(fw->data);
+		return;
+	}
+	fw_free_buf(fw->priv);
+}
+
+/* store the pages buffer info firmware from buf */
+static void fw_set_page_data(struct firmware_buf *buf, struct firmware *fw)
+{
+	fw->priv = buf;
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+	fw->pages = buf->pages;
+#endif
+	fw->size = buf->size;
+	fw->data = buf->data;
+
+	pr_debug("%s: fw-%s buf=%p data=%p size=%u\n",
+		 __func__, buf->fw_id, buf, buf->data,
+		 (unsigned int)buf->size);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void fw_name_devm_release(struct device *dev, void *res)
+{
+	struct fw_name_devm *fwn = res;
+
+	if (fwn->magic == (unsigned long)&fw_cache)
+		pr_debug("%s: fw_name-%s devm-%p released\n",
+				__func__, fwn->name, res);
+}
+
+static int fw_devm_match(struct device *dev, void *res,
+		void *match_data)
+{
+	struct fw_name_devm *fwn = res;
+
+	return (fwn->magic == (unsigned long)&fw_cache) &&
+		!strcmp(fwn->name, match_data);
+}
+
+static struct fw_name_devm *fw_find_devm_name(struct device *dev,
+		const char *name)
+{
+	struct fw_name_devm *fwn;
+
+	fwn = devres_find(dev, fw_name_devm_release,
+			  fw_devm_match, (void *)name);
+	return fwn;
+}
+
+/* add firmware name into devres list */
+static int fw_add_devm_name(struct device *dev, const char *name)
+{
+	struct fw_name_devm *fwn;
+
+	fwn = fw_find_devm_name(dev, name);
+	if (fwn)
+		return 1;
+
+	fwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm) +
+			   strlen(name) + 1, GFP_KERNEL);
+	if (!fwn)
+		return -ENOMEM;
+
+	fwn->magic = (unsigned long)&fw_cache;
+	strcpy(fwn->name, name);
+	devres_add(dev, fwn);
+
+	return 0;
+}
+#else
+static int fw_add_devm_name(struct device *dev, const char *name)
+{
+	return 0;
+}
+#endif
+
+
+/*
+ * user-mode helper code
+ */
+#ifdef CONFIG_FW_LOADER_USER_HELPER
+struct firmware_priv {
+	struct delayed_work timeout_work;
+	bool nowait;
+	struct device dev;
+	struct firmware_buf *buf;
+	struct firmware *fw;
+};
+
 static struct firmware_priv *to_firmware_priv(struct device *dev)
 {
 	return container_of(dev, struct firmware_priv, dev);
@@ -111,11 +450,15 @@
 
 static void fw_load_abort(struct firmware_priv *fw_priv)
 {
-	set_bit(FW_STATUS_ABORT, &fw_priv->status);
-	wmb();
-	complete(&fw_priv->completion);
+	struct firmware_buf *buf = fw_priv->buf;
+
+	set_bit(FW_STATUS_ABORT, &buf->status);
+	complete_all(&buf->completion);
 }
 
+#define is_fw_load_aborted(buf)	\
+	test_bit(FW_STATUS_ABORT, &(buf)->status)
+
 static ssize_t firmware_timeout_show(struct class *class,
 				     struct class_attribute *attr,
 				     char *buf)
@@ -156,11 +499,7 @@
 static void fw_dev_release(struct device *dev)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	int i;
 
-	for (i = 0; i < fw_priv->nr_pages; i++)
-		__free_page(fw_priv->pages[i]);
-	kfree(fw_priv->pages);
 	kfree(fw_priv);
 
 	module_put(THIS_MODULE);
@@ -170,7 +509,7 @@
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
 
-	if (add_uevent_var(env, "FIRMWARE=%s", fw_priv->fw_id))
+	if (add_uevent_var(env, "FIRMWARE=%s", fw_priv->buf->fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, "TIMEOUT=%i", loading_timeout))
 		return -ENOMEM;
@@ -191,26 +530,30 @@
 				     struct device_attribute *attr, char *buf)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	int loading = test_bit(FW_STATUS_LOADING, &fw_priv->status);
+	int loading = test_bit(FW_STATUS_LOADING, &fw_priv->buf->status);
 
 	return sprintf(buf, "%d\n", loading);
 }
 
-static void firmware_free_data(const struct firmware *fw)
-{
-	int i;
-	vunmap(fw->data);
-	if (fw->pages) {
-		for (i = 0; i < PFN_UP(fw->size); i++)
-			__free_page(fw->pages[i]);
-		kfree(fw->pages);
-	}
-}
-
 /* Some architectures don't have PAGE_KERNEL_RO */
 #ifndef PAGE_KERNEL_RO
 #define PAGE_KERNEL_RO PAGE_KERNEL
 #endif
+
+/* one pages buffer should be mapped/unmapped only once */
+static int fw_map_pages_buf(struct firmware_buf *buf)
+{
+	if (!buf->is_paged_buf)
+		return 0;
+
+	if (buf->data)
+		vunmap(buf->data);
+	buf->data = vmap(buf->pages, buf->nr_pages, 0, PAGE_KERNEL_RO);
+	if (!buf->data)
+		return -ENOMEM;
+	return 0;
+}
+
 /**
  * firmware_loading_store - set value in the 'loading' control file
  * @dev: device pointer
@@ -229,45 +572,41 @@
 				      const char *buf, size_t count)
 {
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
+	struct firmware_buf *fw_buf = fw_priv->buf;
 	int loading = simple_strtol(buf, NULL, 10);
 	int i;
 
 	mutex_lock(&fw_lock);
 
-	if (!fw_priv->fw)
+	if (!fw_buf)
 		goto out;
 
 	switch (loading) {
 	case 1:
-		firmware_free_data(fw_priv->fw);
-		memset(fw_priv->fw, 0, sizeof(struct firmware));
-		/* If the pages are not owned by 'struct firmware' */
-		for (i = 0; i < fw_priv->nr_pages; i++)
-			__free_page(fw_priv->pages[i]);
-		kfree(fw_priv->pages);
-		fw_priv->pages = NULL;
-		fw_priv->page_array_size = 0;
-		fw_priv->nr_pages = 0;
-		set_bit(FW_STATUS_LOADING, &fw_priv->status);
+		/* discarding any previous partial load */
+		if (!test_bit(FW_STATUS_DONE, &fw_buf->status)) {
+			for (i = 0; i < fw_buf->nr_pages; i++)
+				__free_page(fw_buf->pages[i]);
+			kfree(fw_buf->pages);
+			fw_buf->pages = NULL;
+			fw_buf->page_array_size = 0;
+			fw_buf->nr_pages = 0;
+			set_bit(FW_STATUS_LOADING, &fw_buf->status);
+		}
 		break;
 	case 0:
-		if (test_bit(FW_STATUS_LOADING, &fw_priv->status)) {
-			vunmap(fw_priv->fw->data);
-			fw_priv->fw->data = vmap(fw_priv->pages,
-						 fw_priv->nr_pages,
-						 0, PAGE_KERNEL_RO);
-			if (!fw_priv->fw->data) {
-				dev_err(dev, "%s: vmap() failed\n", __func__);
-				goto err;
-			}
-			/* Pages are now owned by 'struct firmware' */
-			fw_priv->fw->pages = fw_priv->pages;
-			fw_priv->pages = NULL;
-
-			fw_priv->page_array_size = 0;
-			fw_priv->nr_pages = 0;
-			complete(&fw_priv->completion);
-			clear_bit(FW_STATUS_LOADING, &fw_priv->status);
+		if (test_bit(FW_STATUS_LOADING, &fw_buf->status)) {
+			set_bit(FW_STATUS_DONE, &fw_buf->status);
+			clear_bit(FW_STATUS_LOADING, &fw_buf->status);
+
+			/*
+			 * Several loading requests may be pending on
+			 * one same firmware buf, so let all requests
+			 * see the mapped 'buf->data' once the loading
+			 * is completed.
+			 * */
+			fw_map_pages_buf(fw_buf);
+			complete_all(&fw_buf->completion);
 			break;
 		}
 		/* fallthrough */
@@ -275,7 +614,6 @@
 		dev_err(dev, "%s: unexpected value (%d)\n", __func__, loading);
 		/* fallthrough */
 	case -1:
-	err:
 		fw_load_abort(fw_priv);
 		break;
 	}
@@ -290,23 +628,23 @@
 				  struct bin_attribute *bin_attr,
 				  char *buffer, loff_t offset, size_t count)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	struct firmware *fw;
+	struct firmware_buf *buf;
 	ssize_t ret_count;
 
 	mutex_lock(&fw_lock);
-	fw = fw_priv->fw;
-	if (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {
+	buf = fw_priv->buf;
+	if (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {
 		ret_count = -ENODEV;
 		goto out;
 	}
-	if (offset > fw->size) {
+	if (offset > buf->size) {
 		ret_count = 0;
 		goto out;
 	}
-	if (count > fw->size - offset)
-		count = fw->size - offset;
+	if (count > buf->size - offset)
+		count = buf->size - offset;
 
 	ret_count = count;
 
@@ -316,11 +654,11 @@
 		int page_ofs = offset & (PAGE_SIZE-1);
 		int page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);
 
-		page_data = kmap(fw_priv->pages[page_nr]);
+		page_data = kmap(buf->pages[page_nr]);
 
 		memcpy(buffer, page_data + page_ofs, page_cnt);
 
-		kunmap(fw_priv->pages[page_nr]);
+		kunmap(buf->pages[page_nr]);
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
@@ -332,12 +670,13 @@
 
 static int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)
 {
+	struct firmware_buf *buf = fw_priv->buf;
 	int pages_needed = ALIGN(min_size, PAGE_SIZE) >> PAGE_SHIFT;
 
 	/* If the array of pages is too small, grow it... */
-	if (fw_priv->page_array_size < pages_needed) {
+	if (buf->page_array_size < pages_needed) {
 		int new_array_size = max(pages_needed,
-					 fw_priv->page_array_size * 2);
+					 buf->page_array_size * 2);
 		struct page **new_pages;
 
 		new_pages = kmalloc(new_array_size * sizeof(void *),
@@ -346,24 +685,24 @@
 			fw_load_abort(fw_priv);
 			return -ENOMEM;
 		}
-		memcpy(new_pages, fw_priv->pages,
-		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
-		       (new_array_size - fw_priv->page_array_size));
-		kfree(fw_priv->pages);
-		fw_priv->pages = new_pages;
-		fw_priv->page_array_size = new_array_size;
+		memcpy(new_pages, buf->pages,
+		       buf->page_array_size * sizeof(void *));
+		memset(&new_pages[buf->page_array_size], 0, sizeof(void *) *
+		       (new_array_size - buf->page_array_size));
+		kfree(buf->pages);
+		buf->pages = new_pages;
+		buf->page_array_size = new_array_size;
 	}
 
-	while (fw_priv->nr_pages < pages_needed) {
-		fw_priv->pages[fw_priv->nr_pages] =
+	while (buf->nr_pages < pages_needed) {
+		buf->pages[buf->nr_pages] =
 			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
 
-		if (!fw_priv->pages[fw_priv->nr_pages]) {
+		if (!buf->pages[buf->nr_pages]) {
 			fw_load_abort(fw_priv);
 			return -ENOMEM;
 		}
-		fw_priv->nr_pages++;
+		buf->nr_pages++;
 	}
 	return 0;
 }
@@ -384,20 +723,21 @@
 				   struct bin_attribute *bin_attr,
 				   char *buffer, loff_t offset, size_t count)
 {
-	struct device *dev = to_dev(kobj);
+	struct device *dev = kobj_to_dev(kobj);
 	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-	struct firmware *fw;
+	struct firmware_buf *buf;
 	ssize_t retval;
 
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
 	mutex_lock(&fw_lock);
-	fw = fw_priv->fw;
-	if (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {
+	buf = fw_priv->buf;
+	if (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {
 		retval = -ENODEV;
 		goto out;
 	}
+
 	retval = fw_realloc_buffer(fw_priv, offset + count);
 	if (retval)
 		goto out;
@@ -410,17 +750,17 @@
 		int page_ofs = offset & (PAGE_SIZE - 1);
 		int page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);
 
-		page_data = kmap(fw_priv->pages[page_nr]);
+		page_data = kmap(buf->pages[page_nr]);
 
 		memcpy(page_data + page_ofs, buffer, page_cnt);
 
-		kunmap(fw_priv->pages[page_nr]);
+		kunmap(buf->pages[page_nr]);
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
 	}
 
-	fw->size = max_t(size_t, offset, fw->size);
+	buf->size = max_t(size_t, offset, buf->size);
 out:
 	mutex_unlock(&fw_lock);
 	return retval;
@@ -433,11 +773,18 @@
 	.write = firmware_data_write,
 };
 
-static void firmware_class_timeout(u_long data)
+static void firmware_class_timeout_work(struct work_struct *work)
 {
-	struct firmware_priv *fw_priv = (struct firmware_priv *) data;
+	struct firmware_priv *fw_priv = container_of(work,
+			struct firmware_priv, timeout_work.work);
 
+	mutex_lock(&fw_lock);
+	if (test_bit(FW_STATUS_DONE, &(fw_priv->buf->status))) {
+		mutex_unlock(&fw_lock);
+		return;
+	}
 	fw_load_abort(fw_priv);
+	mutex_unlock(&fw_lock);
 }
 
 static struct firmware_priv *
@@ -447,70 +794,38 @@
 	struct firmware_priv *fw_priv;
 	struct device *f_dev;
 
-	fw_priv = kzalloc(sizeof(*fw_priv) + strlen(fw_name) + 1 , GFP_KERNEL);
+	fw_priv = kzalloc(sizeof(*fw_priv), GFP_KERNEL);
 	if (!fw_priv) {
 		dev_err(device, "%s: kmalloc failed\n", __func__);
-		return ERR_PTR(-ENOMEM);
+		fw_priv = ERR_PTR(-ENOMEM);
+		goto exit;
 	}
 
-	fw_priv->fw = firmware;
 	fw_priv->nowait = nowait;
-	strcpy(fw_priv->fw_id, fw_name);
-	init_completion(&fw_priv->completion);
-	setup_timer(&fw_priv->timeout,
-		    firmware_class_timeout, (u_long) fw_priv);
+	fw_priv->fw = firmware;
+	INIT_DELAYED_WORK(&fw_priv->timeout_work,
+		firmware_class_timeout_work);
 
 	f_dev = &fw_priv->dev;
 
 	device_initialize(f_dev);
-	dev_set_name(f_dev, "%s", dev_name(device));
+	dev_set_name(f_dev, "%s", fw_name);
 	f_dev->parent = device;
 	f_dev->class = &firmware_class;
-
-	return fw_priv;
-}
-
-static struct firmware_priv *
-_request_firmware_prepare(const struct firmware **firmware_p, const char *name,
-			  struct device *device, bool uevent, bool nowait)
-{
-	struct firmware *firmware;
-	struct firmware_priv *fw_priv;
-
-	if (!firmware_p)
-		return ERR_PTR(-EINVAL);
-
-	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
-	if (!firmware) {
-		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
-			__func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	if (fw_get_builtin_firmware(firmware, name)) {
-		dev_dbg(device, "firmware: using built-in firmware %s\n", name);
-		return NULL;
-	}
-
-	fw_priv = fw_create_instance(firmware, name, device, uevent, nowait);
-	if (IS_ERR(fw_priv)) {
-		release_firmware(firmware);
-		*firmware_p = NULL;
-	}
+exit:
 	return fw_priv;
 }
 
-static void _request_firmware_cleanup(const struct firmware **firmware_p)
-{
-	release_firmware(*firmware_p);
-	*firmware_p = NULL;
-}
-
+/* load a firmware via user helper */
 static int _request_firmware_load(struct firmware_priv *fw_priv, bool uevent,
 				  long timeout)
 {
 	int retval = 0;
 	struct device *f_dev = &fw_priv->dev;
+	struct firmware_buf *buf = fw_priv->buf;
+
+	/* fall back on userspace loading */
+	buf->is_paged_buf = true;
 
 	dev_set_uevent_suppress(f_dev, true);
 
@@ -537,24 +852,18 @@
 
 	if (uevent) {
 		dev_set_uevent_suppress(f_dev, false);
-		dev_dbg(f_dev, "firmware: requesting %s\n", fw_priv->fw_id);
+		dev_dbg(f_dev, "firmware: requesting %s\n", buf->fw_id);
 		if (timeout != MAX_SCHEDULE_TIMEOUT)
-			mod_timer(&fw_priv->timeout,
-				  round_jiffies_up(jiffies + timeout));
+			schedule_delayed_work(&fw_priv->timeout_work, timeout);
 
 		kobject_uevent(&fw_priv->dev.kobj, KOBJ_ADD);
 	}
 
-	wait_for_completion(&fw_priv->completion);
+	wait_for_completion(&buf->completion);
 
-	set_bit(FW_STATUS_DONE, &fw_priv->status);
-	del_timer_sync(&fw_priv->timeout);
+	cancel_delayed_work_sync(&fw_priv->timeout_work);
 
-	mutex_lock(&fw_lock);
-	if (!fw_priv->fw->size || test_bit(FW_STATUS_ABORT, &fw_priv->status))
-		retval = -ENOENT;
-	fw_priv->fw = NULL;
-	mutex_unlock(&fw_lock);
+	fw_priv->buf = NULL;
 
 	device_remove_file(f_dev, &dev_attr_loading);
 err_del_bin_attr:
@@ -566,6 +875,186 @@
 	return retval;
 }
 
+static int fw_load_from_user_helper(struct firmware *firmware,
+				    const char *name, struct device *device,
+				    bool uevent, bool nowait, long timeout)
+{
+	struct firmware_priv *fw_priv;
+
+	fw_priv = fw_create_instance(firmware, name, device, uevent, nowait);
+	if (IS_ERR(fw_priv))
+		return PTR_ERR(fw_priv);
+
+	fw_priv->buf = firmware->priv;
+	return _request_firmware_load(fw_priv, uevent, timeout);
+}
+#else /* CONFIG_FW_LOADER_USER_HELPER */
+static inline int
+fw_load_from_user_helper(struct firmware *firmware, const char *name,
+			 struct device *device, bool uevent, bool nowait,
+			 long timeout)
+{
+	return -ENOENT;
+}
+
+/* No abort during direct loading */
+#define is_fw_load_aborted(buf) false
+
+#endif /* CONFIG_FW_LOADER_USER_HELPER */
+
+
+/* wait until the shared firmware_buf becomes ready (or error) */
+static int sync_cached_firmware_buf(struct firmware_buf *buf)
+{
+	int ret = 0;
+
+	mutex_lock(&fw_lock);
+	while (!test_bit(FW_STATUS_DONE, &buf->status)) {
+		if (is_fw_load_aborted(buf)) {
+			ret = -ENOENT;
+			break;
+		}
+		mutex_unlock(&fw_lock);
+		wait_for_completion(&buf->completion);
+		mutex_lock(&fw_lock);
+	}
+	mutex_unlock(&fw_lock);
+	return ret;
+}
+
+/* prepare firmware and firmware_buf structs;
+ * return 0 if a firmware is already assigned, 1 if need to load one,
+ * or a negative error code
+ */
+static int
+_request_firmware_prepare(struct firmware **firmware_p, const char *name,
+			  struct device *device)
+{
+	struct firmware *firmware;
+	struct firmware_buf *buf;
+	int ret;
+
+	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
+	if (!firmware) {
+		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	if (fw_get_builtin_firmware(firmware, name)) {
+		dev_dbg(device, "firmware: using built-in firmware %s\n", name);
+		return 0; /* assigned */
+	}
+
+	ret = fw_lookup_and_allocate_buf(name, &fw_cache, &buf);
+
+	/*
+	 * bind with 'buf' now to avoid warning in failure path
+	 * of requesting firmware.
+	 */
+	firmware->priv = buf;
+
+	if (ret > 0) {
+		ret = sync_cached_firmware_buf(buf);
+		if (!ret) {
+			fw_set_page_data(buf, firmware);
+			return 0; /* assigned */
+		}
+	}
+
+	if (ret < 0)
+		return ret;
+	return 1; /* need to load */
+}
+
+static int assign_firmware_buf(struct firmware *fw, struct device *device)
+{
+	struct firmware_buf *buf = fw->priv;
+
+	mutex_lock(&fw_lock);
+	if (!buf->size || is_fw_load_aborted(buf)) {
+		mutex_unlock(&fw_lock);
+		return -ENOENT;
+	}
+
+	/*
+	 * add firmware name into devres list so that we can auto cache
+	 * and uncache firmware for device.
+	 *
+	 * device may has been deleted already, but the problem
+	 * should be fixed in devres or driver core.
+	 */
+	if (device)
+		fw_add_devm_name(device, buf->fw_id);
+
+	/*
+	 * After caching firmware image is started, let it piggyback
+	 * on request firmware.
+	 */
+	if (buf->fwc->state == FW_LOADER_START_CACHE) {
+		if (fw_cache_piggyback_on_request(buf->fw_id))
+			kref_get(&buf->ref);
+	}
+
+	/* pass the pages buffer to driver at the last minute */
+	fw_set_page_data(buf, fw);
+	mutex_unlock(&fw_lock);
+	return 0;
+}
+
+/* called from request_firmware() and request_firmware_work_func() */
+static int
+_request_firmware(const struct firmware **firmware_p, const char *name,
+		  struct device *device, bool uevent, bool nowait)
+{
+	struct firmware *fw;
+	long timeout;
+	int ret;
+
+	if (!firmware_p)
+		return -EINVAL;
+
+	ret = _request_firmware_prepare(&fw, name, device);
+	if (ret <= 0) /* error or already assigned */
+		goto out;
+
+	ret = 0;
+	timeout = firmware_loading_timeout();
+	if (nowait) {
+		timeout = usermodehelper_read_lock_wait(timeout);
+		if (!timeout) {
+			dev_dbg(device, "firmware: %s loading timed out\n",
+				name);
+			ret = -EBUSY;
+			goto out;
+		}
+	} else {
+		ret = usermodehelper_read_trylock();
+		if (WARN_ON(ret)) {
+			dev_err(device, "firmware: %s will not be loaded\n",
+				name);
+			goto out;
+		}
+	}
+
+	if (!fw_get_filesystem_firmware(device, fw->priv))
+		ret = fw_load_from_user_helper(fw, name, device,
+					       uevent, nowait, timeout);
+	if (!ret)
+		ret = assign_firmware_buf(fw, device);
+
+	usermodehelper_read_unlock();
+
+ out:
+	if (ret < 0) {
+		release_firmware(fw);
+		fw = NULL;
+	}
+
+	*firmware_p = fw;
+	return ret;
+}
+
 /**
  * request_firmware: - send firmware request and wait for it
  * @firmware_p: pointer to firmware image
@@ -580,31 +1069,17 @@
  *      @name will be used as $FIRMWARE in the uevent environment and
  *      should be distinctive enough not to be confused with any other
  *      firmware image for this or any other device.
+ *
+ *	Caller must hold the reference count of @device.
+ *
+ *	The function can be called safely inside device's suspend and
+ *	resume callback.
  **/
 int
 request_firmware(const struct firmware **firmware_p, const char *name,
                  struct device *device)
 {
-	struct firmware_priv *fw_priv;
-	int ret;
-
-	fw_priv = _request_firmware_prepare(firmware_p, name, device, true,
-					    false);
-	if (IS_ERR_OR_NULL(fw_priv))
-		return PTR_RET(fw_priv);
-
-	ret = usermodehelper_read_trylock();
-	if (WARN_ON(ret)) {
-		dev_err(device, "firmware: %s will not be loaded\n", name);
-	} else {
-		ret = _request_firmware_load(fw_priv, true,
-					firmware_loading_timeout());
-		usermodehelper_read_unlock();
-	}
-	if (ret)
-		_request_firmware_cleanup(firmware_p);
-
-	return ret;
+	return _request_firmware(firmware_p, name, device, true, false);
 }
 
 /**
@@ -635,32 +1110,13 @@
 {
 	struct firmware_work *fw_work;
 	const struct firmware *fw;
-	struct firmware_priv *fw_priv;
-	long timeout;
-	int ret;
 
 	fw_work = container_of(work, struct firmware_work, work);
-	fw_priv = _request_firmware_prepare(&fw, fw_work->name, fw_work->device,
-			fw_work->uevent, true);
-	if (IS_ERR_OR_NULL(fw_priv)) {
-		ret = PTR_RET(fw_priv);
-		goto out;
-	}
-
-	timeout = usermodehelper_read_lock_wait(firmware_loading_timeout());
-	if (timeout) {
-		ret = _request_firmware_load(fw_priv, fw_work->uevent, timeout);
-		usermodehelper_read_unlock();
-	} else {
-		dev_dbg(fw_work->device, "firmware: %s loading timed out\n",
-			fw_work->name);
-		ret = -EAGAIN;
-	}
-	if (ret)
-		_request_firmware_cleanup(&fw);
 
- out:
+	_request_firmware(&fw, fw_work->name, fw_work->device,
+			  fw_work->uevent, true);
 	fw_work->cont(fw, fw_work->context);
+	put_device(fw_work->device); /* taken in request_firmware_nowait() */
 
 	module_put(fw_work->module);
 	kfree(fw_work);
@@ -679,9 +1135,15 @@
  * @cont: function will be called asynchronously when the firmware
  *	request is over.
  *
- *	Asynchronous variant of request_firmware() for user contexts where
- *	it is not possible to sleep for long time. It can't be called
- *	in atomic contexts.
+ *	Caller must hold the reference count of @device.
+ *
+ *	Asynchronous variant of request_firmware() for user contexts:
+ *		- sleep for as small periods as possible since it may
+ *		increase kernel boot time of built-in device drivers
+ *		requesting firmware in their ->probe() methods, if
+ *		@gfp is GFP_KERNEL.
+ *
+ *		- can't sleep at all if @gfp is GFP_ATOMIC.
  **/
 int
 request_firmware_nowait(
@@ -707,19 +1169,391 @@
 		return -EFAULT;
 	}
 
+	get_device(fw_work->device);
 	INIT_WORK(&fw_work->work, request_firmware_work_func);
 	schedule_work(&fw_work->work);
 	return 0;
 }
 
+/**
+ * cache_firmware - cache one firmware image in kernel memory space
+ * @fw_name: the firmware image name
+ *
+ * Cache firmware in kernel memory so that drivers can use it when
+ * system isn't ready for them to request firmware image from userspace.
+ * Once it returns successfully, driver can use request_firmware or its
+ * nowait version to get the cached firmware without any interacting
+ * with userspace
+ *
+ * Return 0 if the firmware image has been cached successfully
+ * Return !0 otherwise
+ *
+ */
+int cache_firmware(const char *fw_name)
+{
+	int ret;
+	const struct firmware *fw;
+
+	pr_debug("%s: %s\n", __func__, fw_name);
+
+	ret = request_firmware(&fw, fw_name, NULL);
+	if (!ret)
+		kfree(fw);
+
+	pr_debug("%s: %s ret=%d\n", __func__, fw_name, ret);
+
+	return ret;
+}
+
+/**
+ * uncache_firmware - remove one cached firmware image
+ * @fw_name: the firmware image name
+ *
+ * Uncache one firmware image which has been cached successfully
+ * before.
+ *
+ * Return 0 if the firmware cache has been removed successfully
+ * Return !0 otherwise
+ *
+ */
+int uncache_firmware(const char *fw_name)
+{
+	struct firmware_buf *buf;
+	struct firmware fw;
+
+	pr_debug("%s: %s\n", __func__, fw_name);
+
+	if (fw_get_builtin_firmware(&fw, fw_name))
+		return 0;
+
+	buf = fw_lookup_buf(fw_name);
+	if (buf) {
+		fw_free_buf(buf);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static struct fw_cache_entry *alloc_fw_cache_entry(const char *name)
+{
+	struct fw_cache_entry *fce;
+
+	fce = kzalloc(sizeof(*fce) + strlen(name) + 1, GFP_ATOMIC);
+	if (!fce)
+		goto exit;
+
+	strcpy(fce->name, name);
+exit:
+	return fce;
+}
+
+static int __fw_entry_found(const char *name)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+
+	list_for_each_entry(fce, &fwc->fw_names, list) {
+		if (!strcmp(fce->name, name))
+			return 1;
+	}
+	return 0;
+}
+
+static int fw_cache_piggyback_on_request(const char *name)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+	int ret = 0;
+
+	spin_lock(&fwc->name_lock);
+	if (__fw_entry_found(name))
+		goto found;
+
+	fce = alloc_fw_cache_entry(name);
+	if (fce) {
+		ret = 1;
+		list_add(&fce->list, &fwc->fw_names);
+		pr_debug("%s: fw: %s\n", __func__, name);
+	}
+found:
+	spin_unlock(&fwc->name_lock);
+	return ret;
+}
+
+static void free_fw_cache_entry(struct fw_cache_entry *fce)
+{
+	kfree(fce);
+}
+
+static void __async_dev_cache_fw_image(void *fw_entry,
+				       async_cookie_t cookie)
+{
+	struct fw_cache_entry *fce = fw_entry;
+	struct firmware_cache *fwc = &fw_cache;
+	int ret;
+
+	ret = cache_firmware(fce->name);
+	if (ret) {
+		spin_lock(&fwc->name_lock);
+		list_del(&fce->list);
+		spin_unlock(&fwc->name_lock);
+
+		free_fw_cache_entry(fce);
+	}
+
+	spin_lock(&fwc->name_lock);
+	fwc->cnt--;
+	spin_unlock(&fwc->name_lock);
+
+	wake_up(&fwc->wait_queue);
+}
+
+/* called with dev->devres_lock held */
+static void dev_create_fw_entry(struct device *dev, void *res,
+				void *data)
+{
+	struct fw_name_devm *fwn = res;
+	const char *fw_name = fwn->name;
+	struct list_head *head = data;
+	struct fw_cache_entry *fce;
+
+	fce = alloc_fw_cache_entry(fw_name);
+	if (fce)
+		list_add(&fce->list, head);
+}
+
+static int devm_name_match(struct device *dev, void *res,
+			   void *match_data)
+{
+	struct fw_name_devm *fwn = res;
+	return (fwn->magic == (unsigned long)match_data);
+}
+
+static void dev_cache_fw_image(struct device *dev, void *data)
+{
+	LIST_HEAD(todo);
+	struct fw_cache_entry *fce;
+	struct fw_cache_entry *fce_next;
+	struct firmware_cache *fwc = &fw_cache;
+
+	devres_for_each_res(dev, fw_name_devm_release,
+			    devm_name_match, &fw_cache,
+			    dev_create_fw_entry, &todo);
+
+	list_for_each_entry_safe(fce, fce_next, &todo, list) {
+		list_del(&fce->list);
+
+		spin_lock(&fwc->name_lock);
+		/* only one cache entry for one firmware */
+		if (!__fw_entry_found(fce->name)) {
+			fwc->cnt++;
+			list_add(&fce->list, &fwc->fw_names);
+		} else {
+			free_fw_cache_entry(fce);
+			fce = NULL;
+		}
+		spin_unlock(&fwc->name_lock);
+
+		if (fce)
+			async_schedule(__async_dev_cache_fw_image,
+				       (void *)fce);
+	}
+}
+
+static void __device_uncache_fw_images(void)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	struct fw_cache_entry *fce;
+
+	spin_lock(&fwc->name_lock);
+	while (!list_empty(&fwc->fw_names)) {
+		fce = list_entry(fwc->fw_names.next,
+				struct fw_cache_entry, list);
+		list_del(&fce->list);
+		spin_unlock(&fwc->name_lock);
+
+		uncache_firmware(fce->name);
+		free_fw_cache_entry(fce);
+
+		spin_lock(&fwc->name_lock);
+	}
+	spin_unlock(&fwc->name_lock);
+}
+
+/**
+ * device_cache_fw_images - cache devices' firmware
+ *
+ * If one device called request_firmware or its nowait version
+ * successfully before, the firmware names are recored into the
+ * device's devres link list, so device_cache_fw_images can call
+ * cache_firmware() to cache these firmwares for the device,
+ * then the device driver can load its firmwares easily at
+ * time when system is not ready to complete loading firmware.
+ */
+static void device_cache_fw_images(void)
+{
+	struct firmware_cache *fwc = &fw_cache;
+	int old_timeout;
+	DEFINE_WAIT(wait);
+
+	pr_debug("%s\n", __func__);
+
+	/* cancel uncache work */
+	cancel_delayed_work_sync(&fwc->work);
+
+	/*
+	 * use small loading timeout for caching devices' firmware
+	 * because all these firmware images have been loaded
+	 * successfully at lease once, also system is ready for
+	 * completing firmware loading now. The maximum size of
+	 * firmware in current distributions is about 2M bytes,
+	 * so 10 secs should be enough.
+	 */
+	old_timeout = loading_timeout;
+	loading_timeout = 10;
+
+	mutex_lock(&fw_lock);
+	fwc->state = FW_LOADER_START_CACHE;
+	dpm_for_each_dev(NULL, dev_cache_fw_image);
+	mutex_unlock(&fw_lock);
+
+	/* wait for completion of caching firmware for all devices */
+	spin_lock(&fwc->name_lock);
+	for (;;) {
+		prepare_to_wait(&fwc->wait_queue, &wait,
+				TASK_UNINTERRUPTIBLE);
+		if (!fwc->cnt)
+			break;
+
+		spin_unlock(&fwc->name_lock);
+
+		schedule();
+
+		spin_lock(&fwc->name_lock);
+	}
+	spin_unlock(&fwc->name_lock);
+	finish_wait(&fwc->wait_queue, &wait);
+
+	loading_timeout = old_timeout;
+}
+
+/**
+ * device_uncache_fw_images - uncache devices' firmware
+ *
+ * uncache all firmwares which have been cached successfully
+ * by device_uncache_fw_images earlier
+ */
+static void device_uncache_fw_images(void)
+{
+	pr_debug("%s\n", __func__);
+	__device_uncache_fw_images();
+}
+
+static void device_uncache_fw_images_work(struct work_struct *work)
+{
+	device_uncache_fw_images();
+}
+
+/**
+ * device_uncache_fw_images_delay - uncache devices firmwares
+ * @delay: number of milliseconds to delay uncache device firmwares
+ *
+ * uncache all devices's firmwares which has been cached successfully
+ * by device_cache_fw_images after @delay milliseconds.
+ */
+static void device_uncache_fw_images_delay(unsigned long delay)
+{
+	schedule_delayed_work(&fw_cache.work,
+			msecs_to_jiffies(delay));
+}
+
+static int fw_pm_notify(struct notifier_block *notify_block,
+			unsigned long mode, void *unused)
+{
+	switch (mode) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		device_cache_fw_images();
+		break;
+
+	case PM_POST_SUSPEND:
+	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
+		/*
+		 * In case that system sleep failed and syscore_suspend is
+		 * not called.
+		 */
+		mutex_lock(&fw_lock);
+		fw_cache.state = FW_LOADER_NO_CACHE;
+		mutex_unlock(&fw_lock);
+
+		device_uncache_fw_images_delay(10 * MSEC_PER_SEC);
+		break;
+	}
+
+	return 0;
+}
+
+/* stop caching firmware once syscore_suspend is reached */
+static int fw_suspend(void)
+{
+	fw_cache.state = FW_LOADER_NO_CACHE;
+	return 0;
+}
+
+static struct syscore_ops fw_syscore_ops = {
+	.suspend = fw_suspend,
+};
+#else
+static int fw_cache_piggyback_on_request(const char *name)
+{
+	return 0;
+}
+#endif
+
+static void __init fw_cache_init(void)
+{
+	spin_lock_init(&fw_cache.lock);
+	INIT_LIST_HEAD(&fw_cache.head);
+	fw_cache.state = FW_LOADER_NO_CACHE;
+
+#ifdef CONFIG_PM_SLEEP
+	spin_lock_init(&fw_cache.name_lock);
+	INIT_LIST_HEAD(&fw_cache.fw_names);
+	fw_cache.cnt = 0;
+
+	init_waitqueue_head(&fw_cache.wait_queue);
+	INIT_DELAYED_WORK(&fw_cache.work,
+			  device_uncache_fw_images_work);
+
+	fw_cache.pm_notify.notifier_call = fw_pm_notify;
+	register_pm_notifier(&fw_cache.pm_notify);
+
+	register_syscore_ops(&fw_syscore_ops);
+#endif
+}
+
 static int __init firmware_class_init(void)
 {
+	fw_cache_init();
+#ifdef CONFIG_FW_LOADER_USER_HELPER
 	return class_register(&firmware_class);
+#else
+	return 0;
+#endif
 }
 
 static void __exit firmware_class_exit(void)
 {
+#ifdef CONFIG_PM_SLEEP
+	unregister_syscore_ops(&fw_syscore_ops);
+	unregister_pm_notifier(&fw_cache.pm_notify);
+#endif
+#ifdef CONFIG_FW_LOADER_USER_HELPER
 	class_unregister(&firmware_class);
+#endif
 }
 
 fs_initcall(firmware_class_init);
@@ -728,3 +1562,5 @@
 EXPORT_SYMBOL(release_firmware);
 EXPORT_SYMBOL(request_firmware);
 EXPORT_SYMBOL(request_firmware_nowait);
+EXPORT_SYMBOL_GPL(cache_firmware);
+EXPORT_SYMBOL_GPL(uncache_firmware);
diff -urN flo-ElementalX-5.00/drivers/base/genlock.c flo-ElementalX-5.00-patched/drivers/base/genlock.c
--- flo-ElementalX-5.00/drivers/base/genlock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/genlock.c	2016-06-03 17:13:57.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -712,6 +712,50 @@
 }
 EXPORT_SYMBOL(genlock_get_handle_fd);
 
+/*
+ * Get a file descriptor reference to a lock suitable for sharing with
+ * other processes
+ */
+
+int genlock_get_fd_handle(struct genlock_handle *handle)
+{
+	int ret;
+	struct genlock *lock;
+
+	if (IS_ERR_OR_NULL(handle))
+		return -EINVAL;
+
+	lock = handle->lock;
+
+	if (IS_ERR(lock))
+		return PTR_ERR(lock);
+
+	if (!lock->file) {
+		GENLOCK_LOG_ERR("No file attached to the lock\n");
+		return -EINVAL;
+	}
+
+	ret = get_unused_fd_flags(0);
+
+	if (ret < 0)
+		return ret;
+
+	fd_install(ret, lock->file);
+
+	/*
+	 * Taking a reference for lock file.
+	 * This is required as now we have two file descriptor
+	 * pointing to same file. If one FD is closed, lock file
+	 * will be closed. Taking this reference will make sure
+	 * that file doesn't get close. This refrence will go
+	 * when client will call close on this FD.
+	 */
+	fget(ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(genlock_get_fd_handle);
+
 #ifdef CONFIG_GENLOCK_MISCDEVICE
 
 static long genlock_dev_ioctl(struct file *filep, unsigned int cmd,
diff -urN flo-ElementalX-5.00/drivers/base/power/main.c flo-ElementalX-5.00-patched/drivers/base/power/main.c
--- flo-ElementalX-5.00/drivers/base/power/main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/base/power/main.c	2016-06-01 15:47:50.000000000 +0000
@@ -1370,3 +1370,25 @@
 	return async_error;
 }
 EXPORT_SYMBOL_GPL(device_pm_wait_for_dev);
+
+/**
+ * dpm_for_each_dev - device iterator.
+ * @data: data for the callback.
+ * @fn: function to be called for each device.
+ *
+ * Iterate over devices in dpm_list, and call @fn for each device,
+ * passing it @data.
+ */
+void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))
+{
+	struct device *dev;
+
+	if (!fn)
+		return;
+
+	device_pm_lock();
+	list_for_each_entry(dev, &dpm_list, power.entry)
+		fn(dev, data);
+	device_pm_unlock();
+}
+EXPORT_SYMBOL_GPL(dpm_for_each_dev);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/ath3k.c flo-ElementalX-5.00-patched/drivers/bluetooth/ath3k.c
--- flo-ElementalX-5.00/drivers/bluetooth/ath3k.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/ath3k.c	2016-06-02 00:28:55.000000000 +0000
@@ -30,6 +30,7 @@
 #include <net/bluetooth/bluetooth.h>
 
 #define VERSION "1.0"
+#define ATH3K_FIRMWARE	"ath3k-1.fw"
 
 #define ATH3K_DNLOAD				0x01
 #define ATH3K_GETSTATE				0x05
@@ -62,12 +63,23 @@
 
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0CF3, 0x3002) },
+	{ USB_DEVICE(0x13d3, 0x3304) },
+	{ USB_DEVICE(0x0930, 0x0215) },
+	{ USB_DEVICE(0x0489, 0xE03D) },
+	{ USB_DEVICE(0x0489, 0xE027) },
 
 	/* Atheros AR9285 Malbec with sflash firmware */
 	{ USB_DEVICE(0x03F0, 0x311D) },
 
 	/* Atheros AR3012 with sflash firmware*/
+	{ USB_DEVICE(0x0CF3, 0x0036) },
 	{ USB_DEVICE(0x0CF3, 0x3004) },
+	{ USB_DEVICE(0x0CF3, 0x311D) },
+	{ USB_DEVICE(0x0CF3, 0x817a) },
+	{ USB_DEVICE(0x13d3, 0x3375) },
+	{ USB_DEVICE(0x04CA, 0x3005) },
+	{ USB_DEVICE(0x13d3, 0x3362) },
+	{ USB_DEVICE(0x0CF3, 0xE004) },
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
@@ -83,7 +95,14 @@
 static struct usb_device_id ath3k_blist_tbl[] = {
 
 	/* Atheros AR3012 with sflash firmware*/
+	{ USB_DEVICE(0x0CF3, 0x0036), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311D), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0CF3, 0x817a), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 
 	{ }	/* Terminating entry */
 };
@@ -103,7 +122,7 @@
 
 	pipe = usb_sndctrlpipe(udev, 0);
 
-	send_buf = kmalloc(BULK_SIZE, GFP_ATOMIC);
+	send_buf = kmalloc(BULK_SIZE, GFP_KERNEL);
 	if (!send_buf) {
 		BT_ERR("Can't allocate memory chunk for firmware");
 		return -ENOMEM;
@@ -174,7 +193,7 @@
 
 	count = firmware->size;
 
-	send_buf = kmalloc(BULK_SIZE, GFP_ATOMIC);
+	send_buf = kmalloc(BULK_SIZE, GFP_KERNEL);
 	if (!send_buf) {
 		BT_ERR("Can't allocate memory chunk for firmware");
 		return -ENOMEM;
@@ -398,9 +417,15 @@
 		return 0;
 	}
 
-	if (request_firmware(&firmware, "ath3k-1.fw", &udev->dev) < 0) {
-		BT_ERR("Error loading firmware");
-		return -EIO;
+	ret = request_firmware(&firmware, ATH3K_FIRMWARE, &udev->dev);
+	if (ret < 0) {
+		if (ret == -ENOENT)
+			BT_ERR("Firmware file \"%s\" not found",
+							ATH3K_FIRMWARE);
+		else
+			BT_ERR("Firmware file \"%s\" request failed (err=%d)",
+							ATH3K_FIRMWARE, ret);
+		return ret;
 	}
 
 	ret = ath3k_load_firmware(udev, firmware);
@@ -421,22 +446,10 @@
 	.id_table	= ath3k_table,
 };
 
-static int __init ath3k_init(void)
-{
-	BT_INFO("Atheros AR30xx firmware driver ver %s", VERSION);
-	return usb_register(&ath3k_driver);
-}
-
-static void __exit ath3k_exit(void)
-{
-	usb_deregister(&ath3k_driver);
-}
-
-module_init(ath3k_init);
-module_exit(ath3k_exit);
+module_usb_driver(ath3k_driver);
 
 MODULE_AUTHOR("Atheros Communications");
 MODULE_DESCRIPTION("Atheros AR30xx firmware driver");
 MODULE_VERSION(VERSION);
 MODULE_LICENSE("GPL");
-MODULE_FIRMWARE("ath3k-1.fw");
+MODULE_FIRMWARE(ATH3K_FIRMWARE);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bcm203x.c flo-ElementalX-5.00-patched/drivers/bluetooth/bcm203x.c
--- flo-ElementalX-5.00/drivers/bluetooth/bcm203x.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bcm203x.c	2016-06-02 00:28:55.000000000 +0000
@@ -24,6 +24,7 @@
 
 #include <linux/module.h>
 
+#include <linux/atomic.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -65,6 +66,7 @@
 	unsigned long		state;
 
 	struct work_struct	work;
+	atomic_t		shutdown;
 
 	struct urb		*urb;
 	unsigned char		*buffer;
@@ -97,6 +99,7 @@
 
 		data->state = BCM203X_SELECT_MEMORY;
 
+		/* use workqueue to have a small delay */
 		schedule_work(&data->work);
 		break;
 
@@ -155,7 +158,10 @@
 	struct bcm203x_data *data =
 		container_of(work, struct bcm203x_data, work);
 
-	if (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)
+	if (atomic_read(&data->shutdown))
+		return;
+
+	if (usb_submit_urb(data->urb, GFP_KERNEL) < 0)
 		BT_ERR("Can't submit URB");
 }
 
@@ -243,6 +249,7 @@
 
 	usb_set_intfdata(intf, data);
 
+	/* use workqueue to have a small delay */
 	schedule_work(&data->work);
 
 	return 0;
@@ -254,6 +261,9 @@
 
 	BT_DBG("intf %p", intf);
 
+	atomic_inc(&data->shutdown);
+	cancel_work_sync(&data->work);
+
 	usb_kill_urb(data->urb);
 
 	usb_set_intfdata(intf, NULL);
@@ -271,26 +281,7 @@
 	.id_table	= bcm203x_table,
 };
 
-static int __init bcm203x_init(void)
-{
-	int err;
-
-	BT_INFO("Broadcom Blutonium firmware driver ver %s", VERSION);
-
-	err = usb_register(&bcm203x_driver);
-	if (err < 0)
-		BT_ERR("Failed to register USB driver");
-
-	return err;
-}
-
-static void __exit bcm203x_exit(void)
-{
-	usb_deregister(&bcm203x_driver);
-}
-
-module_init(bcm203x_init);
-module_exit(bcm203x_exit);
+module_usb_driver(bcm203x_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Broadcom Blutonium firmware driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bfusb.c flo-ElementalX-5.00-patched/drivers/bluetooth/bfusb.c
--- flo-ElementalX-5.00/drivers/bluetooth/bfusb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bfusb.c	2016-06-02 00:28:55.000000000 +0000
@@ -411,7 +411,7 @@
 
 static int bfusb_open(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 	unsigned long flags;
 	int i, err;
 
@@ -437,7 +437,7 @@
 
 static int bfusb_flush(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("hdev %p bfusb %p", hdev, data);
 
@@ -448,7 +448,7 @@
 
 static int bfusb_close(struct hci_dev *hdev)
 {
-	struct bfusb_data *data = hdev->driver_data;
+	struct bfusb_data *data = hci_get_drvdata(hdev);
 	unsigned long flags;
 
 	BT_DBG("hdev %p bfusb %p", hdev, data);
@@ -483,7 +483,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	data = hdev->driver_data;
+	data = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -544,15 +544,6 @@
 	return 0;
 }
 
-static void bfusb_destruct(struct hci_dev *hdev)
-{
-	struct bfusb_data *data = hdev->driver_data;
-
-	BT_DBG("hdev %p bfusb %p", hdev, data);
-
-	kfree(data);
-}
-
 static int bfusb_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -568,22 +559,23 @@
 
 	BT_INFO("BlueFRITZ! USB loading firmware");
 
+	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_KERNEL);
+	if (!buf) {
+		BT_ERR("Can't allocate memory chunk for firmware");
+		return -ENOMEM;
+	}
+
 	pipe = usb_sndctrlpipe(data->udev, 0);
 
 	if (usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,
 				0, 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT) < 0) {
 		BT_ERR("Can't change to loading configuration");
+		kfree(buf);
 		return -EBUSY;
 	}
 
 	data->udev->toggle[0] = data->udev->toggle[1] = 0;
 
-	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_ATOMIC);
-	if (!buf) {
-		BT_ERR("Can't allocate memory chunk for firmware");
-		return -ENOMEM;
-	}
-
 	pipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);
 
 	while (count) {
@@ -704,18 +696,15 @@
 	data->hdev = hdev;
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 	SET_HCIDEV_DEV(hdev, &intf->dev);
 
 	hdev->open     = bfusb_open;
 	hdev->close    = bfusb_close;
 	hdev->flush    = bfusb_flush;
 	hdev->send     = bfusb_send_frame;
-	hdev->destruct = bfusb_destruct;
 	hdev->ioctl    = bfusb_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
@@ -750,10 +739,9 @@
 
 	bfusb_close(hdev);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 static struct usb_driver bfusb_driver = {
@@ -763,26 +751,7 @@
 	.id_table	= bfusb_table,
 };
 
-static int __init bfusb_init(void)
-{
-	int err;
-
-	BT_INFO("BlueFRITZ! USB driver ver %s", VERSION);
-
-	err = usb_register(&bfusb_driver);
-	if (err < 0)
-		BT_ERR("Failed to register BlueFRITZ! USB driver");
-
-	return err;
-}
-
-static void __exit bfusb_exit(void)
-{
-	usb_deregister(&bfusb_driver);
-}
-
-module_init(bfusb_init);
-module_exit(bfusb_exit);
+module_usb_driver(bfusb_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("BlueFRITZ! USB driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bluecard_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/bluecard_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/bluecard_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bluecard_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -561,7 +561,7 @@
 
 static int bluecard_hci_set_baud_rate(struct hci_dev *hdev, int baud)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	struct sk_buff *skb;
 
 	/* Ericsson baud rate command */
@@ -609,7 +609,7 @@
 
 static int bluecard_hci_flush(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -620,7 +620,7 @@
 
 static int bluecard_hci_open(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	unsigned int iobase = info->p_dev->resource[0]->start;
 
 	if (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))
@@ -640,7 +640,7 @@
 
 static int bluecard_hci_close(struct hci_dev *hdev)
 {
-	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
+	bluecard_info_t *info = hci_get_drvdata(hdev);
 	unsigned int iobase = info->p_dev->resource[0]->start;
 
 	if (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))
@@ -667,7 +667,7 @@
 		return -ENODEV;
 	}
 
-	info = (bluecard_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -691,11 +691,6 @@
 }
 
 
-static void bluecard_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int bluecard_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -734,18 +729,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = bluecard_hci_open;
 	hdev->close    = bluecard_hci_close;
 	hdev->flush    = bluecard_hci_flush;
 	hdev->send     = bluecard_hci_send_frame;
-	hdev->destruct = bluecard_hci_destruct;
 	hdev->ioctl    = bluecard_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	id = inb(iobase + 0x30);
 
 	if ((id & 0x0f) == 0x02)
@@ -844,9 +836,7 @@
 	/* Turn FPGA off */
 	outb(0x80, iobase + 0x30);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -930,7 +920,7 @@
 	pcmcia_disable_device(link);
 }
 
-static struct pcmcia_device_id bluecard_ids[] = {
+static const struct pcmcia_device_id bluecard_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("BlueCard", "LSE041", 0xbaf16fbf, 0x657cc15e),
 	PCMCIA_DEVICE_PROD_ID12("BTCFCARD", "LSE139", 0xe3987764, 0x2524b59c),
 	PCMCIA_DEVICE_PROD_ID12("WSS", "LSE039", 0x0a0736ec, 0x24e6dfab),
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bluesleep.c flo-ElementalX-5.00-patched/drivers/bluetooth/bluesleep.c
--- flo-ElementalX-5.00/drivers/bluetooth/bluesleep.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bluesleep.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,757 +0,0 @@
-/*
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 as
-   published by the Free Software Foundation.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-   This program is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-
-   Copyright (C) 2006-2007 - Motorola
-   Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
-
-   Date         Author           Comment
-   -----------  --------------   --------------------------------
-   2006-Apr-28	Motorola	 The kernel module for running the Bluetooth(R)
-				 Sleep-Mode Protocol from the Host side
-   2006-Sep-08  Motorola         Added workqueue for handling sleep work.
-   2007-Jan-24  Motorola         Added mbm_handle_ioi() call to ISR.
-
-*/
-
-#include <linux/module.h>	/* kernel module definitions */
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/notifier.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-#include <linux/uaccess.h>
-#include <linux/version.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-
-#include <linux/irq.h>
-#include <linux/param.h>
-#include <linux/bitops.h>
-#include <linux/termios.h>
-#include <mach/gpio.h>
-#include <mach/msm_serial_hs.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h> /* event notifications */
-#include "hci_uart.h"
-
-#define BT_SLEEP_DBG
-#ifndef BT_SLEEP_DBG
-#define BT_DBG(fmt, arg...)
-#endif
-/*
- * Defines
- */
-
-#define VERSION		"1.1"
-#define PROC_DIR	"bluetooth/sleep"
-
-struct bluesleep_info {
-	unsigned host_wake;
-	unsigned ext_wake;
-	unsigned host_wake_irq;
-	struct uart_port *uport;
-};
-
-/* work function */
-static void bluesleep_sleep_work(struct work_struct *work);
-
-/* work queue */
-DECLARE_DELAYED_WORK(sleep_workqueue, bluesleep_sleep_work);
-
-/* Macros for handling sleep work */
-#define bluesleep_rx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_tx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_rx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
-#define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
-
-/* 1 second timeout */
-#define TX_TIMER_INTERVAL	1
-
-/* state variable names and bit positions */
-#define BT_PROTO	0x01
-#define BT_TXDATA	0x02
-#define BT_ASLEEP	0x04
-
-/* global pointer to a single hci device. */
-static struct hci_dev *bluesleep_hdev;
-
-static struct bluesleep_info *bsi;
-
-/* module usage */
-static atomic_t open_count = ATOMIC_INIT(1);
-
-/*
- * Local function prototypes
- */
-
-static int bluesleep_hci_event(struct notifier_block *this,
-			    unsigned long event, void *data);
-
-/*
- * Global variables
- */
-
-/** Global state flags */
-static unsigned long flags;
-
-/** Tasklet to respond to change in hostwake line */
-static struct tasklet_struct hostwake_task;
-
-/** Transmission timer */
-static struct timer_list tx_timer;
-
-/** Lock for state transitions */
-static spinlock_t rw_lock;
-
-/** Notifier block for HCI events */
-struct notifier_block hci_event_nblock = {
-	.notifier_call = bluesleep_hci_event,
-};
-
-struct proc_dir_entry *bluetooth_dir, *sleep_dir;
-
-/*
- * Local functions
- */
-
-static void hsuart_power(int on)
-{
-	if (on) {
-		msm_hs_request_clock_on(bsi->uport);
-		msm_hs_set_mctrl(bsi->uport, TIOCM_RTS);
-	} else {
-		msm_hs_set_mctrl(bsi->uport, 0);
-		msm_hs_request_clock_off(bsi->uport);
-	}
-}
-
-
-/**
- * @return 1 if the Host can go to sleep, 0 otherwise.
- */
-static inline int bluesleep_can_sleep(void)
-{
-	/* check if MSM_WAKE_BT_GPIO and BT_WAKE_MSM_GPIO are both deasserted */
-	return gpio_get_value(bsi->ext_wake) &&
-		gpio_get_value(bsi->host_wake) &&
-		(bsi->uport != NULL);
-}
-
-void bluesleep_sleep_wakeup(void)
-{
-	if (test_bit(BT_ASLEEP, &flags)) {
-		BT_DBG("waking up...");
-		/* Start the timer */
-		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-		gpio_set_value(bsi->ext_wake, 0);
-		clear_bit(BT_ASLEEP, &flags);
-		/*Activating UART */
-		hsuart_power(1);
-	}
-}
-
-/**
- * @brief@  main sleep work handling function which update the flags
- * and activate and deactivate UART ,check FIFO.
- */
-static void bluesleep_sleep_work(struct work_struct *work)
-{
-	if (bluesleep_can_sleep()) {
-		/* already asleep, this is an error case */
-		if (test_bit(BT_ASLEEP, &flags)) {
-			BT_DBG("already asleep");
-			return;
-		}
-
-		if (msm_hs_tx_empty(bsi->uport)) {
-			BT_DBG("going to sleep...");
-			set_bit(BT_ASLEEP, &flags);
-			/*Deactivating UART */
-			hsuart_power(0);
-		} else {
-
-		  mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-			return;
-		}
-	} else {
-		bluesleep_sleep_wakeup();
-	}
-}
-
-/**
- * A tasklet function that runs in tasklet context and reads the value
- * of the HOST_WAKE GPIO pin and further defer the work.
- * @param data Not used.
- */
-static void bluesleep_hostwake_task(unsigned long data)
-{
-	BT_DBG("hostwake line change");
-
-	spin_lock(&rw_lock);
-
-	if (gpio_get_value(bsi->host_wake))
-		bluesleep_rx_busy();
-	else
-		bluesleep_rx_idle();
-
-	spin_unlock(&rw_lock);
-}
-
-/**
- * Handles proper timer action when outgoing data is delivered to the
- * HCI line discipline. Sets BT_TXDATA.
- */
-static void bluesleep_outgoing_data(void)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	/* log data passing by */
-	set_bit(BT_TXDATA, &flags);
-
-	/* if the tx side is sleeping... */
-	if (gpio_get_value(bsi->ext_wake)) {
-
-		BT_DBG("tx was sleeping");
-		bluesleep_sleep_wakeup();
-	}
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-}
-
-/**
- * Handles HCI device events.
- * @param this Not used.
- * @param event The event that occurred.
- * @param data The HCI device associated with the event.
- * @return <code>NOTIFY_DONE</code>.
- */
-static int bluesleep_hci_event(struct notifier_block *this,
-				unsigned long event, void *data)
-{
-	struct hci_dev *hdev = (struct hci_dev *) data;
-	struct hci_uart *hu;
-	struct uart_state *state;
-
-	if (!hdev)
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case HCI_DEV_REG:
-		if (!bluesleep_hdev) {
-			bluesleep_hdev = hdev;
-			hu  = (struct hci_uart *) hdev->driver_data;
-			state = (struct uart_state *) hu->tty->driver_data;
-			bsi->uport = state->uart_port;
-		}
-		break;
-	case HCI_DEV_UNREG:
-		bluesleep_hdev = NULL;
-		bsi->uport = NULL;
-		break;
-	case HCI_DEV_WRITE:
-		bluesleep_outgoing_data();
-		break;
-	}
-
-	return NOTIFY_DONE;
-}
-
-/**
- * Handles transmission timer expiration.
- * @param data Not used.
- */
-static void bluesleep_tx_timer_expire(unsigned long data)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	BT_DBG("Tx timer expired");
-
-	/* were we silent during the last timeout? */
-	if (!test_bit(BT_TXDATA, &flags)) {
-		BT_DBG("Tx has been idle");
-		gpio_set_value(bsi->ext_wake, 1);
-		bluesleep_tx_idle();
-	} else {
-		BT_DBG("Tx data during last period");
-		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
-	}
-
-	/* clear the incoming data flag */
-	clear_bit(BT_TXDATA, &flags);
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-}
-
-/**
- * Schedules a tasklet to run when receiving an interrupt on the
- * <code>HOST_WAKE</code> GPIO pin.
- * @param irq Not used.
- * @param dev_id Not used.
- */
-static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
-{
-	/* schedule a tasklet to handle the change in the host wake line */
-	tasklet_schedule(&hostwake_task);
-	return IRQ_HANDLED;
-}
-
-/**
- * Starts the Sleep-Mode Protocol on the Host.
- * @return On success, 0. On error, -1, and <code>errno</code> is set
- * appropriately.
- */
-static int bluesleep_start(void)
-{
-	int retval;
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	if (test_bit(BT_PROTO, &flags)) {
-		spin_unlock_irqrestore(&rw_lock, irq_flags);
-		return 0;
-	}
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-
-	if (!atomic_dec_and_test(&open_count)) {
-		atomic_inc(&open_count);
-		return -EBUSY;
-	}
-
-	/* start the timer */
-
-	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
-
-	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
-	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-				"bluetooth hostwake", NULL);
-	if (retval  < 0) {
-		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
-		goto fail;
-	}
-
-	retval = enable_irq_wake(bsi->host_wake_irq);
-	if (retval < 0) {
-		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
-		free_irq(bsi->host_wake_irq, NULL);
-		goto fail;
-	}
-
-	set_bit(BT_PROTO, &flags);
-	return 0;
-fail:
-	del_timer(&tx_timer);
-	atomic_inc(&open_count);
-
-	return retval;
-}
-
-/**
- * Stops the Sleep-Mode Protocol on the Host.
- */
-static void bluesleep_stop(void)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&rw_lock, irq_flags);
-
-	if (!test_bit(BT_PROTO, &flags)) {
-		spin_unlock_irqrestore(&rw_lock, irq_flags);
-		return;
-	}
-
-	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
-	del_timer(&tx_timer);
-	clear_bit(BT_PROTO, &flags);
-
-	if (test_bit(BT_ASLEEP, &flags)) {
-		clear_bit(BT_ASLEEP, &flags);
-		hsuart_power(1);
-	}
-
-	atomic_inc(&open_count);
-
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-	if (disable_irq_wake(bsi->host_wake_irq))
-		BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-	free_irq(bsi->host_wake_irq, NULL);
-}
-/**
- * Read the <code>BT_WAKE</code> GPIO pin value via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the
- * pin is high, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	*eof = 1;
-	return sprintf(page, "btwake:%u\n", gpio_get_value(bsi->ext_wake));
-}
-
-/**
- * Write the <code>BT_WAKE</code> GPIO pin value via the proc interface.
- * @param file Not used.
- * @param buffer The buffer to read from.
- * @param count The number of bytes to be written.
- * @param data Not used.
- * @return On success, the number of bytes written. On error, -1, and
- * <code>errno</code> is set appropriately.
- */
-static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
-					unsigned long count, void *data)
-{
-	char *buf;
-
-	if (count < 1)
-		return -EINVAL;
-
-	buf = kmalloc(count, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (copy_from_user(buf, buffer, count)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-
-	if (buf[0] == '0') {
-		gpio_set_value(bsi->ext_wake, 0);
-	} else if (buf[0] == '1') {
-		gpio_set_value(bsi->ext_wake, 1);
-	} else {
-		kfree(buf);
-		return -EINVAL;
-	}
-
-	kfree(buf);
-	return count;
-}
-
-/**
- * Read the <code>BT_HOST_WAKE</code> GPIO pin value via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the pin
- * is high, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluepower_read_proc_hostwake(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	*eof = 1;
-	return sprintf(page, "hostwake: %u \n", gpio_get_value(bsi->host_wake));
-}
-
-
-/**
- * Read the low-power status of the Host via the proc interface.
- * When this function returns, <code>page</code> contains a 1 if the Host
- * is asleep, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluesleep_read_proc_asleep(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	unsigned int asleep;
-
-	asleep = test_bit(BT_ASLEEP, &flags) ? 1 : 0;
-	*eof = 1;
-	return sprintf(page, "asleep: %u\n", asleep);
-}
-
-/**
- * Read the low-power protocol being used by the Host via the proc interface.
- * When this function returns, <code>page</code> will contain a 1 if the Host
- * is using the Sleep Mode Protocol, 0 otherwise.
- * @param page Buffer for writing data.
- * @param start Not used.
- * @param offset Not used.
- * @param count Not used.
- * @param eof Whether or not there is more data to be read.
- * @param data Not used.
- * @return The number of bytes written.
- */
-static int bluesleep_read_proc_proto(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	unsigned int proto;
-
-	proto = test_bit(BT_PROTO, &flags) ? 1 : 0;
-	*eof = 1;
-	return sprintf(page, "proto: %u\n", proto);
-}
-
-/**
- * Modify the low-power protocol used by the Host via the proc interface.
- * @param file Not used.
- * @param buffer The buffer to read from.
- * @param count The number of bytes to be written.
- * @param data Not used.
- * @return On success, the number of bytes written. On error, -1, and
- * <code>errno</code> is set appropriately.
- */
-static int bluesleep_write_proc_proto(struct file *file, const char *buffer,
-					unsigned long count, void *data)
-{
-	char proto;
-
-	if (count < 1)
-		return -EINVAL;
-
-	if (copy_from_user(&proto, buffer, 1))
-		return -EFAULT;
-
-	if (proto == '0')
-		bluesleep_stop();
-	else
-		bluesleep_start();
-
-	/* claim that we wrote everything */
-	return count;
-}
-
-static int __init bluesleep_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-
-	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
-	if (!bsi)
-		return -ENOMEM;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-				"gpio_host_wake");
-	if (!res) {
-		BT_ERR("couldn't find host_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->host_wake = res->start;
-
-	ret = gpio_request(bsi->host_wake, "bt_host_wake");
-	if (ret)
-		goto free_bsi;
-	ret = gpio_direction_input(bsi->host_wake);
-	if (ret)
-		goto free_bt_host_wake;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-				"gpio_ext_wake");
-	if (!res) {
-		BT_ERR("couldn't find ext_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bt_host_wake;
-	}
-	bsi->ext_wake = res->start;
-
-	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
-	if (ret)
-		goto free_bt_host_wake;
-	/* assert bt wake */
-	ret = gpio_direction_output(bsi->ext_wake, 0);
-	if (ret)
-		goto free_bt_ext_wake;
-
-	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
-	if (bsi->host_wake_irq < 0) {
-		BT_ERR("couldn't find host_wake irq\n");
-		ret = -ENODEV;
-		goto free_bt_ext_wake;
-	}
-
-
-	return 0;
-
-free_bt_ext_wake:
-	gpio_free(bsi->ext_wake);
-free_bt_host_wake:
-	gpio_free(bsi->host_wake);
-free_bsi:
-	kfree(bsi);
-	return ret;
-}
-
-static int bluesleep_remove(struct platform_device *pdev)
-{
-	/* assert bt wake */
-	gpio_set_value(bsi->ext_wake, 0);
-	if (test_bit(BT_PROTO, &flags)) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode \n");
-		free_irq(bsi->host_wake_irq, NULL);
-		del_timer(&tx_timer);
-		if (test_bit(BT_ASLEEP, &flags))
-			hsuart_power(1);
-	}
-
-	gpio_free(bsi->host_wake);
-	gpio_free(bsi->ext_wake);
-	kfree(bsi);
-	return 0;
-}
-
-static struct platform_driver bluesleep_driver = {
-	.remove = bluesleep_remove,
-	.driver = {
-		.name = "bluesleep",
-		.owner = THIS_MODULE,
-	},
-};
-/**
- * Initializes the module.
- * @return On success, 0. On error, -1, and <code>errno</code> is set
- * appropriately.
- */
-static int __init bluesleep_init(void)
-{
-	int retval;
-	struct proc_dir_entry *ent;
-
-	BT_INFO("MSM Sleep Mode Driver Ver %s", VERSION);
-
-	retval = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
-	if (retval)
-		return retval;
-
-	bluesleep_hdev = NULL;
-
-	bluetooth_dir = proc_mkdir("bluetooth", NULL);
-	if (bluetooth_dir == NULL) {
-		BT_ERR("Unable to create /proc/bluetooth directory");
-		return -ENOMEM;
-	}
-
-	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
-	if (sleep_dir == NULL) {
-		BT_ERR("Unable to create /proc/%s directory", PROC_DIR);
-		return -ENOMEM;
-	}
-
-	/* Creating read/write "btwake" entry */
-	ent = create_proc_entry("btwake", 0, sleep_dir);
-	if (ent == NULL) {
-		BT_ERR("Unable to create /proc/%s/btwake entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-	ent->read_proc = bluepower_read_proc_btwake;
-	ent->write_proc = bluepower_write_proc_btwake;
-
-	/* read only proc entries */
-	if (create_proc_read_entry("hostwake", 0, sleep_dir,
-				bluepower_read_proc_hostwake, NULL) == NULL) {
-		BT_ERR("Unable to create /proc/%s/hostwake entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-
-	/* read/write proc entries */
-	ent = create_proc_entry("proto", 0, sleep_dir);
-	if (ent == NULL) {
-		BT_ERR("Unable to create /proc/%s/proto entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-	ent->read_proc = bluesleep_read_proc_proto;
-	ent->write_proc = bluesleep_write_proc_proto;
-
-	/* read only proc entries */
-	if (create_proc_read_entry("asleep", 0,
-			sleep_dir, bluesleep_read_proc_asleep, NULL) == NULL) {
-		BT_ERR("Unable to create /proc/%s/asleep entry", PROC_DIR);
-		retval = -ENOMEM;
-		goto fail;
-	}
-
-	flags = 0; /* clear all status bits */
-
-	/* Initialize spinlock. */
-	spin_lock_init(&rw_lock);
-
-	/* Initialize timer */
-	init_timer(&tx_timer);
-	tx_timer.function = bluesleep_tx_timer_expire;
-	tx_timer.data = 0;
-
-	/* initialize host wake tasklet */
-	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
-
-	hci_register_notifier(&hci_event_nblock);
-
-	return 0;
-
-fail:
-	remove_proc_entry("asleep", sleep_dir);
-	remove_proc_entry("proto", sleep_dir);
-	remove_proc_entry("hostwake", sleep_dir);
-	remove_proc_entry("btwake", sleep_dir);
-	remove_proc_entry("sleep", bluetooth_dir);
-	remove_proc_entry("bluetooth", 0);
-	return retval;
-}
-
-/**
- * Cleans up the module.
- */
-static void __exit bluesleep_exit(void)
-{
-	hci_unregister_notifier(&hci_event_nblock);
-	platform_driver_unregister(&bluesleep_driver);
-
-	remove_proc_entry("asleep", sleep_dir);
-	remove_proc_entry("proto", sleep_dir);
-	remove_proc_entry("hostwake", sleep_dir);
-	remove_proc_entry("btwake", sleep_dir);
-	remove_proc_entry("sleep", bluetooth_dir);
-	remove_proc_entry("bluetooth", 0);
-}
-
-module_init(bluesleep_init);
-module_exit(bluesleep_exit);
-
-MODULE_DESCRIPTION("Bluetooth Sleep Mode Driver ver %s " VERSION);
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("GPL");
-#endif
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bpa10x.c flo-ElementalX-5.00-patched/drivers/bluetooth/bpa10x.c
--- flo-ElementalX-5.00/drivers/bluetooth/bpa10x.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bpa10x.c	2016-06-02 00:28:55.000000000 +0000
@@ -66,7 +66,7 @@
 
 static int bpa10x_recv(struct hci_dev *hdev, int queue, void *buf, int count)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s queue %d buffer %p count %d", hdev->name,
 							queue, buf, count);
@@ -189,7 +189,7 @@
 static void bpa10x_rx_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -219,7 +219,7 @@
 
 static inline int bpa10x_submit_intr_urb(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -260,7 +260,7 @@
 
 static inline int bpa10x_submit_bulk_urb(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -301,7 +301,7 @@
 
 static int bpa10x_open(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -329,7 +329,7 @@
 
 static int bpa10x_close(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -343,7 +343,7 @@
 
 static int bpa10x_flush(struct hci_dev *hdev)
 {
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -355,7 +355,7 @@
 static int bpa10x_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct bpa10x_data *data = hdev->driver_data;
+	struct bpa10x_data *data = hci_get_drvdata(hdev);
 	struct usb_ctrlrequest *dr;
 	struct urb *urb;
 	unsigned int pipe;
@@ -432,17 +432,6 @@
 	return 0;
 }
 
-static void bpa10x_destruct(struct hci_dev *hdev)
-{
-	struct bpa10x_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree_skb(data->rx_skb[0]);
-	kfree_skb(data->rx_skb[1]);
-	kfree(data);
-}
-
 static int bpa10x_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct bpa10x_data *data;
@@ -470,7 +459,7 @@
 	}
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	data->hdev = hdev;
 
@@ -480,9 +469,6 @@
 	hdev->close    = bpa10x_close;
 	hdev->flush    = bpa10x_flush;
 	hdev->send     = bpa10x_send_frame;
-	hdev->destruct = bpa10x_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	set_bit(HCI_QUIRK_NO_RESET, &hdev->quirks);
 
@@ -512,6 +498,9 @@
 	hci_unregister_dev(data->hdev);
 
 	hci_free_dev(data->hdev);
+	kfree_skb(data->rx_skb[0]);
+	kfree_skb(data->rx_skb[1]);
+	kfree(data);
 }
 
 static struct usb_driver bpa10x_driver = {
@@ -521,20 +510,7 @@
 	.id_table	= bpa10x_table,
 };
 
-static int __init bpa10x_init(void)
-{
-	BT_INFO("Digianswer Bluetooth USB driver ver %s", VERSION);
-
-	return usb_register(&bpa10x_driver);
-}
-
-static void __exit bpa10x_exit(void)
-{
-	usb_deregister(&bpa10x_driver);
-}
-
-module_init(bpa10x_init);
-module_exit(bpa10x_exit);
+module_usb_driver(bpa10x_driver);
 
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Digianswer Bluetooth USB driver ver " VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/bt3c_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/bt3c_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/bt3c_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/bt3c_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -39,7 +39,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <linux/device.h>
@@ -389,7 +388,7 @@
 
 static int bt3c_hci_flush(struct hci_dev *hdev)
 {
-	bt3c_info_t *info = (bt3c_info_t *)(hdev->driver_data);
+	bt3c_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -428,7 +427,7 @@
 		return -ENODEV;
 	}
 
-	info = (bt3c_info_t *) (hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -456,11 +455,6 @@
 }
 
 
-static void bt3c_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int bt3c_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -580,18 +574,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = bt3c_hci_open;
 	hdev->close    = bt3c_hci_close;
 	hdev->flush    = bt3c_hci_flush;
 	hdev->send     = bt3c_hci_send_frame;
-	hdev->destruct = bt3c_hci_destruct;
 	hdev->ioctl    = bt3c_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	/* Load firmware */
 	err = request_firmware(&firmware, "BT3CPCC.bin", &info->p_dev->dev);
 	if (err < 0) {
@@ -636,9 +627,7 @@
 
 	bt3c_hci_close(hdev);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -761,7 +750,7 @@
 }
 
 
-static struct pcmcia_device_id bt3c_ids[] = {
+static const struct pcmcia_device_id bt3c_ids[] = {
 	PCMCIA_DEVICE_PROD_ID13("3COM", "Bluetooth PC Card", 0xefce0a31, 0xd4ce9b02),
 	PCMCIA_DEVICE_NULL
 };
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_debugfs.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_debugfs.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_debugfs.c	2016-06-02 00:28:55.000000000 +0000
@@ -45,12 +45,6 @@
 	struct dentry *txdnldready;
 };
 
-static int btmrvl_open_generic(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
 static ssize_t btmrvl_hscfgcmd_write(struct file *file,
 			const char __user *ubuf, size_t count, loff_t *ppos)
 {
@@ -64,6 +58,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hscfgcmd = result;
 
@@ -91,7 +87,7 @@
 static const struct file_operations btmrvl_hscfgcmd_fops = {
 	.read	= btmrvl_hscfgcmd_read,
 	.write	= btmrvl_hscfgcmd_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -108,6 +104,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.psmode = result;
 
@@ -130,7 +128,7 @@
 static const struct file_operations btmrvl_psmode_fops = {
 	.read	= btmrvl_psmode_read,
 	.write	= btmrvl_psmode_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -147,6 +145,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.pscmd = result;
 
@@ -174,7 +174,7 @@
 static const struct file_operations btmrvl_pscmd_fops = {
 	.read = btmrvl_pscmd_read,
 	.write = btmrvl_pscmd_write,
-	.open = btmrvl_open_generic,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -191,6 +191,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 16, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.gpio_gap = result;
 
@@ -213,7 +215,7 @@
 static const struct file_operations btmrvl_gpiogap_fops = {
 	.read	= btmrvl_gpiogap_read,
 	.write	= btmrvl_gpiogap_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -230,6 +232,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hscmd = result;
 	if (priv->btmrvl_dev.hscmd) {
@@ -255,7 +259,7 @@
 static const struct file_operations btmrvl_hscmd_fops = {
 	.read	= btmrvl_hscmd_read,
 	.write	= btmrvl_hscmd_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -272,6 +276,8 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
+	if (ret)
+		return ret;
 
 	priv->btmrvl_dev.hsmode = result;
 
@@ -293,7 +299,7 @@
 static const struct file_operations btmrvl_hsmode_fops = {
 	.read	= btmrvl_hsmode_read,
 	.write	= btmrvl_hsmode_write,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -311,7 +317,7 @@
 
 static const struct file_operations btmrvl_curpsmode_fops = {
 	.read	= btmrvl_curpsmode_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -329,7 +335,7 @@
 
 static const struct file_operations btmrvl_psstate_fops = {
 	.read	= btmrvl_psstate_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -347,7 +353,7 @@
 
 static const struct file_operations btmrvl_hsstate_fops = {
 	.read	= btmrvl_hsstate_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
@@ -366,13 +372,13 @@
 
 static const struct file_operations btmrvl_txdnldready_fops = {
 	.read	= btmrvl_txdnldready_read,
-	.open	= btmrvl_open_generic,
+	.open	= simple_open,
 	.llseek = default_llseek,
 };
 
 void btmrvl_debugfs_init(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 	struct btmrvl_debugfs_data *dbg;
 
 	if (!hdev->debugfs)
@@ -389,36 +395,34 @@
 	dbg->config_dir = debugfs_create_dir("config", hdev->debugfs);
 
 	dbg->psmode = debugfs_create_file("psmode", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_psmode_fops);
+					  priv, &btmrvl_psmode_fops);
 	dbg->pscmd = debugfs_create_file("pscmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_pscmd_fops);
+					 priv, &btmrvl_pscmd_fops);
 	dbg->gpiogap = debugfs_create_file("gpiogap", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_gpiogap_fops);
+					   priv, &btmrvl_gpiogap_fops);
 	dbg->hsmode =  debugfs_create_file("hsmode", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hsmode_fops);
+					   priv, &btmrvl_hsmode_fops);
 	dbg->hscmd = debugfs_create_file("hscmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hscmd_fops);
+					 priv, &btmrvl_hscmd_fops);
 	dbg->hscfgcmd = debugfs_create_file("hscfgcmd", 0644, dbg->config_dir,
-				hdev->driver_data, &btmrvl_hscfgcmd_fops);
+					    priv, &btmrvl_hscfgcmd_fops);
 
 	dbg->status_dir = debugfs_create_dir("status", hdev->debugfs);
 	dbg->curpsmode = debugfs_create_file("curpsmode", 0444,
-						dbg->status_dir,
-						hdev->driver_data,
-						&btmrvl_curpsmode_fops);
+					     dbg->status_dir, priv,
+					     &btmrvl_curpsmode_fops);
 	dbg->psstate = debugfs_create_file("psstate", 0444, dbg->status_dir,
-				hdev->driver_data, &btmrvl_psstate_fops);
+					   priv, &btmrvl_psstate_fops);
 	dbg->hsstate = debugfs_create_file("hsstate", 0444, dbg->status_dir,
-				hdev->driver_data, &btmrvl_hsstate_fops);
+					   priv, &btmrvl_hsstate_fops);
 	dbg->txdnldready = debugfs_create_file("txdnldready", 0444,
-						dbg->status_dir,
-						hdev->driver_data,
-						&btmrvl_txdnldready_fops);
+					       dbg->status_dir, priv,
+					       &btmrvl_txdnldready_fops);
 }
 
 void btmrvl_debugfs_remove(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 	struct btmrvl_debugfs_data *dbg = priv->debugfs_data;
 
 	if (!dbg)
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_main.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_main.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_main.c	2016-06-02 00:28:55.000000000 +0000
@@ -18,6 +18,8 @@
  * this warranty disclaimer.
  **/
 
+#include <linux/module.h>
+
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
@@ -385,10 +387,6 @@
 	return -ENOIOCTLCMD;
 }
 
-static void btmrvl_destruct(struct hci_dev *hdev)
-{
-}
-
 static int btmrvl_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
@@ -396,12 +394,13 @@
 
 	BT_DBG("type=%d, len=%d", skb->pkt_type, skb->len);
 
-	if (!hdev || !hdev->driver_data) {
+	if (!hdev) {
 		BT_ERR("Frame for unknown HCI device");
 		return -ENODEV;
 	}
 
-	priv = (struct btmrvl_private *) hdev->driver_data;
+	priv = hci_get_drvdata(hdev);
+
 	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
 		BT_ERR("Failed testing HCI_RUNING, flags=%lx", hdev->flags);
 		print_hex_dump_bytes("data: ", DUMP_PREFIX_OFFSET,
@@ -432,7 +431,7 @@
 
 static int btmrvl_flush(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 
 	skb_queue_purge(&priv->adapter->tx_queue);
 
@@ -441,7 +440,7 @@
 
 static int btmrvl_close(struct hci_dev *hdev)
 {
-	struct btmrvl_private *priv = hdev->driver_data;
+	struct btmrvl_private *priv = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
@@ -473,8 +472,6 @@
 
 	init_waitqueue_entry(&wait, current);
 
-	current->flags |= PF_NOFREEZE;
-
 	for (;;) {
 		add_wait_queue(&thread->wait_q, &wait);
 
@@ -546,16 +543,14 @@
 	}
 
 	priv->btmrvl_dev.hcidev = hdev;
-	hdev->driver_data = priv;
+	hci_set_drvdata(hdev, priv);
 
 	hdev->bus = HCI_SDIO;
 	hdev->open = btmrvl_open;
 	hdev->close = btmrvl_close;
 	hdev->flush = btmrvl_flush;
 	hdev->send = btmrvl_send_frame;
-	hdev->destruct = btmrvl_destruct;
 	hdev->ioctl = btmrvl_ioctl;
-	hdev->owner = THIS_MODULE;
 
 	btmrvl_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btmrvl_sdio.c flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_sdio.c
--- flo-ElementalX-5.00/drivers/bluetooth/btmrvl_sdio.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btmrvl_sdio.c	2016-06-02 00:28:55.000000000 +0000
@@ -23,6 +23,7 @@
 
 #include <linux/mmc/sdio_ids.h>
 #include <linux/mmc/sdio_func.h>
+#include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -64,7 +65,7 @@
 	.io_port_1 = 0x01,
 	.io_port_2 = 0x02,
 };
-static const struct btmrvl_sdio_card_reg btmrvl_reg_8787 = {
+static const struct btmrvl_sdio_card_reg btmrvl_reg_87xx = {
 	.cfg = 0x00,
 	.host_int_mask = 0x02,
 	.host_intstatus = 0x03,
@@ -81,7 +82,7 @@
 	.io_port_2 = 0x7a,
 };
 
-static const struct btmrvl_sdio_device btmrvl_sdio_sd6888 = {
+static const struct btmrvl_sdio_device btmrvl_sdio_sd8688 = {
 	.helper		= "sd8688_helper.bin",
 	.firmware	= "sd8688.bin",
 	.reg		= &btmrvl_reg_8688,
@@ -91,17 +92,27 @@
 static const struct btmrvl_sdio_device btmrvl_sdio_sd8787 = {
 	.helper		= NULL,
 	.firmware	= "mrvl/sd8787_uapsta.bin",
-	.reg		= &btmrvl_reg_8787,
+	.reg		= &btmrvl_reg_87xx,
+	.sd_blksz_fw_dl	= 256,
+};
+
+static const struct btmrvl_sdio_device btmrvl_sdio_sd8797 = {
+	.helper		= NULL,
+	.firmware	= "mrvl/sd8797_uapsta.bin",
+	.reg		= &btmrvl_reg_87xx,
 	.sd_blksz_fw_dl	= 256,
 };
 
 static const struct sdio_device_id btmrvl_sdio_ids[] = {
 	/* Marvell SD8688 Bluetooth device */
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x9105),
-			.driver_data = (unsigned long) &btmrvl_sdio_sd6888 },
+			.driver_data = (unsigned long) &btmrvl_sdio_sd8688 },
 	/* Marvell SD8787 Bluetooth device */
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x911A),
 			.driver_data = (unsigned long) &btmrvl_sdio_sd8787 },
+	/* Marvell SD8797 Bluetooth device */
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, 0x912A),
+			.driver_data = (unsigned long) &btmrvl_sdio_sd8797 },
 
 	{ }	/* Terminating entry */
 };
@@ -1075,3 +1086,4 @@
 MODULE_FIRMWARE("sd8688_helper.bin");
 MODULE_FIRMWARE("sd8688.bin");
 MODULE_FIRMWARE("mrvl/sd8787_uapsta.bin");
+MODULE_FIRMWARE("mrvl/sd8797_uapsta.bin");
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btsdio.c flo-ElementalX-5.00-patched/drivers/bluetooth/btsdio.c
--- flo-ElementalX-5.00/drivers/bluetooth/btsdio.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btsdio.c	2016-06-02 00:28:55.000000000 +0000
@@ -189,7 +189,7 @@
 
 static int btsdio_open(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -225,7 +225,7 @@
 
 static int btsdio_close(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -246,7 +246,7 @@
 
 static int btsdio_flush(struct hci_dev *hdev)
 {
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -258,7 +258,7 @@
 static int btsdio_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btsdio_data *data = hdev->driver_data;
+	struct btsdio_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -289,15 +289,6 @@
 	return 0;
 }
 
-static void btsdio_destruct(struct hci_dev *hdev)
-{
-	struct btsdio_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree(data);
-}
-
 static int btsdio_probe(struct sdio_func *func,
 				const struct sdio_device_id *id)
 {
@@ -330,7 +321,7 @@
 	}
 
 	hdev->bus = HCI_SDIO;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	if (id->class == SDIO_CLASS_BT_AMP)
 		hdev->dev_type = HCI_AMP;
@@ -345,9 +336,6 @@
 	hdev->close    = btsdio_close;
 	hdev->flush    = btsdio_flush;
 	hdev->send     = btsdio_send_frame;
-	hdev->destruct = btsdio_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	err = hci_register_dev(hdev);
 	if (err < 0) {
@@ -378,6 +366,7 @@
 	hci_unregister_dev(hdev);
 
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 static struct sdio_driver btsdio_driver = {
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btuart_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/btuart_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/btuart_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btuart_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -38,7 +38,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <pcmcia/cistpl.h>
@@ -397,7 +396,7 @@
 
 static int btuart_hci_flush(struct hci_dev *hdev)
 {
-	btuart_info_t *info = (btuart_info_t *)(hdev->driver_data);
+	btuart_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -435,7 +434,7 @@
 		return -ENODEV;
 	}
 
-	info = (btuart_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -459,11 +458,6 @@
 }
 
 
-static void btuart_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int btuart_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -498,18 +492,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = btuart_hci_open;
 	hdev->close    = btuart_hci_close;
 	hdev->flush    = btuart_hci_flush;
 	hdev->send     = btuart_hci_send_frame;
-	hdev->destruct = btuart_hci_destruct;
 	hdev->ioctl    = btuart_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -565,9 +556,7 @@
 
 	spin_unlock_irqrestore(&(info->lock), flags);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -689,7 +678,7 @@
 	pcmcia_disable_device(link);
 }
 
-static struct pcmcia_device_id btuart_ids[] = {
+static const struct pcmcia_device_id btuart_ids[] = {
 	/* don't use this driver. Use serial_cs + hci_uart instead */
 	PCMCIA_DEVICE_NULL
 };
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btusb.c flo-ElementalX-5.00-patched/drivers/bluetooth/btusb.c
--- flo-ElementalX-5.00/drivers/bluetooth/btusb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btusb.c	2016-06-02 00:28:55.000000000 +0000
@@ -37,13 +37,13 @@
 
 #define VERSION "0.6"
 
-static int ignore_dga;
-static int ignore_csr;
-static int ignore_sniffer;
-static int disable_scofix;
-static int force_scofix;
+static bool ignore_dga;
+static bool ignore_csr;
+static bool ignore_sniffer;
+static bool disable_scofix;
+static bool force_scofix;
 
-static int reset = 1;
+static bool reset = 1;
 
 static struct usb_driver btusb_driver;
 
@@ -60,8 +60,11 @@
 	/* Generic Bluetooth USB device */
 	{ USB_DEVICE_INFO(0xe0, 0x01, 0x01) },
 
+	/* Apple-specific (Broadcom) devices */
+	{ USB_VENDOR_AND_INTERFACE_INFO(0x05ac, 0xff, 0x01, 0x01) },
+
 	/* Broadcom SoftSailing reporting vendor specific */
-	{ USB_DEVICE(0x05ac, 0x21e1) },
+	{ USB_DEVICE(0x0a5c, 0x21e1) },
 
 	/* Apple MacBookPro 7,1 */
 	{ USB_DEVICE(0x05ac, 0x8213) },
@@ -100,6 +103,16 @@
 	/* Canyon CN-BTU1 with HID interfaces */
 	{ USB_DEVICE(0x0c10, 0x0000) },
 
+	/* Broadcom BCM20702A0 */
+	{ USB_DEVICE(0x0489, 0xe042) },
+	{ USB_DEVICE(0x413c, 0x8197) },
+
+	/* Foxconn - Hon Hai */
+	{ USB_DEVICE(0x0489, 0xe033) },
+
+	/*Broadcom devices with vendor specific id */
+	{ USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01) },
+
 	{ }	/* Terminating entry */
 };
 
@@ -114,12 +127,23 @@
 
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x13d3, 0x3304), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
+	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 
 	/* Atheros AR9285 Malbec with sflash firmware */
 	{ USB_DEVICE(0x03f0, 0x311d), .driver_info = BTUSB_IGNORE },
 
 	/* Atheros 3012 with sflash firmware */
+	{ USB_DEVICE(0x0cf3, 0x0036), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311d), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x817a), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
@@ -236,7 +260,7 @@
 static void btusb_intr_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -264,7 +288,9 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
@@ -273,7 +299,7 @@
 
 static int btusb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -308,7 +334,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -321,7 +348,7 @@
 static void btusb_bulk_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -349,7 +376,9 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
@@ -358,7 +387,7 @@
 
 static int btusb_submit_bulk_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -391,7 +420,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -404,7 +434,7 @@
 static void btusb_isoc_complete(struct urb *urb)
 {
 	struct hci_dev *hdev = urb->context;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int i, err;
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
@@ -439,14 +469,16 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		if (err != -EPERM)
+		/* -EPERM: urb is being killed;
+		 * -ENODEV: device got disconnected */
+		if (err != -EPERM && err != -ENODEV)
 			BT_ERR("%s urb %p failed to resubmit (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
 }
 
-static void inline __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
+static inline void __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
 {
 	int i, offset = 0;
 
@@ -469,7 +501,7 @@
 
 static int btusb_submit_isoc_urb(struct hci_dev *hdev, gfp_t mem_flags)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct urb *urb;
 	unsigned char *buf;
 	unsigned int pipe;
@@ -495,15 +527,10 @@
 
 	pipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);
 
-	urb->dev      = data->udev;
-	urb->pipe     = pipe;
-	urb->context  = hdev;
-	urb->complete = btusb_isoc_complete;
-	urb->interval = data->isoc_rx_ep->bInterval;
+	usb_fill_int_urb(urb, data->udev, pipe, buf, size, btusb_isoc_complete,
+				hdev, data->isoc_rx_ep->bInterval);
 
 	urb->transfer_flags  = URB_FREE_BUFFER | URB_ISO_ASAP;
-	urb->transfer_buffer = buf;
-	urb->transfer_buffer_length = size;
 
 	__fill_isoc_descriptor(urb, size,
 			le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));
@@ -512,7 +539,8 @@
 
 	err = usb_submit_urb(urb, mem_flags);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed (%d)",
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
 						hdev->name, urb, -err);
 		usb_unanchor_urb(urb);
 	}
@@ -526,7 +554,7 @@
 {
 	struct sk_buff *skb = urb->context;
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s urb %p status %d count %d", hdev->name,
 					urb, urb->status, urb->actual_length);
@@ -573,7 +601,7 @@
 
 static int btusb_open(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -623,7 +651,7 @@
 
 static int btusb_close(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -653,7 +681,7 @@
 
 static int btusb_flush(struct hci_dev *hdev)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s", hdev->name);
 
@@ -665,7 +693,7 @@
 static int btusb_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct usb_ctrlrequest *dr;
 	struct urb *urb;
 	unsigned int pipe;
@@ -759,31 +787,23 @@
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		BT_ERR("%s urb %p submission failed", hdev->name, urb);
+		if (err != -EPERM && err != -ENODEV)
+			BT_ERR("%s urb %p submission failed (%d)",
+						hdev->name, urb, -err);
 		kfree(urb->setup_packet);
 		usb_unanchor_urb(urb);
 	} else {
 		usb_mark_last_busy(data->udev);
 	}
 
-	usb_free_urb(urb);
-
 done:
+	usb_free_urb(urb);
 	return err;
 }
 
-static void btusb_destruct(struct hci_dev *hdev)
-{
-	struct btusb_data *data = hdev->driver_data;
-
-	BT_DBG("%s", hdev->name);
-
-	kfree(data);
-}
-
 static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 
 	BT_DBG("%s evt %d", hdev->name, evt);
 
@@ -793,9 +813,9 @@
 	}
 }
 
-static int inline __set_isoc_interface(struct hci_dev *hdev, int altsetting)
+static inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)
 {
-	struct btusb_data *data = hdev->driver_data;
+	struct btusb_data *data = hci_get_drvdata(hdev);
 	struct usb_interface *intf = data->isoc;
 	struct usb_endpoint_descriptor *ep_desc;
 	int i, err;
@@ -983,7 +1003,7 @@
 	}
 
 	hdev->bus = HCI_USB;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
 
 	data->hdev = hdev;
 
@@ -993,11 +1013,8 @@
 	hdev->close    = btusb_close;
 	hdev->flush    = btusb_flush;
 	hdev->send     = btusb_send_frame;
-	hdev->destruct = btusb_destruct;
 	hdev->notify   = btusb_notify;
 
-	hdev->owner = THIS_MODULE;
-
 	/* Interface numbers are hardcoded in the specification */
 	data->isoc = usb_ifnum_to_if(data->udev, 1);
 
@@ -1079,9 +1096,6 @@
 		return;
 
 	hdev = data->hdev;
-
-	__hci_dev_hold(hdev);
-
 	usb_set_intfdata(data->intf, NULL);
 
 	if (data->isoc)
@@ -1094,9 +1108,8 @@
 	else if (data->isoc)
 		usb_driver_release_interface(&btusb_driver, data->isoc);
 
-	__hci_dev_put(hdev);
-
 	hci_free_dev(hdev);
+	kfree(data);
 }
 
 #ifdef CONFIG_PM
@@ -1110,7 +1123,7 @@
 		return 0;
 
 	spin_lock_irq(&data->txlock);
-	if (!((message.event & PM_EVENT_AUTO) && data->tx_in_flight)) {
+	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
 		spin_unlock_irq(&data->txlock);
 	} else {
@@ -1212,20 +1225,7 @@
 	.supports_autosuspend = 1,
 };
 
-static int __init btusb_init(void)
-{
-	BT_INFO("Generic Bluetooth USB driver ver %s", VERSION);
-
-	return usb_register(&btusb_driver);
-}
-
-static void __exit btusb_exit(void)
-{
-	usb_deregister(&btusb_driver);
-}
-
-module_init(btusb_init);
-module_exit(btusb_exit);
+module_usb_driver(btusb_driver);
 
 module_param(ignore_dga, bool, 0644);
 MODULE_PARM_DESC(ignore_dga, "Ignore devices with id 08fd:0001");
diff -urN flo-ElementalX-5.00/drivers/bluetooth/btwilink.c flo-ElementalX-5.00-patched/drivers/bluetooth/btwilink.c
--- flo-ElementalX-5.00/drivers/bluetooth/btwilink.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/btwilink.c	2016-06-02 00:28:55.000000000 +0000
@@ -29,6 +29,7 @@
 #include <net/bluetooth/hci.h>
 
 #include <linux/ti_wilink_st.h>
+#include <linux/module.h>
 
 /* Bluetooth Driver Version */
 #define VERSION               "1.0"
@@ -125,6 +126,13 @@
 /* protocol structure registered with shared transport */
 static struct st_proto_s ti_st_proto[MAX_BT_CHNL_IDS] = {
 	{
+		.chnl_id = HCI_EVENT_PKT, /* HCI Events */
+		.hdr_len = sizeof(struct hci_event_hdr),
+		.offset_len_in_hdr = offsetof(struct hci_event_hdr, plen),
+		.len_size = 1, /* sizeof(plen) in struct hci_event_hdr */
+		.reserve = 8,
+	},
+	{
 		.chnl_id = HCI_ACLDATA_PKT, /* ACL */
 		.hdr_len = sizeof(struct hci_acl_hdr),
 		.offset_len_in_hdr = offsetof(struct hci_acl_hdr, dlen),
@@ -138,13 +146,6 @@
 		.len_size = 1, /* sizeof(dlen) in struct hci_sco_hdr */
 		.reserve = 8,
 	},
-	{
-		.chnl_id = HCI_EVENT_PKT, /* HCI Events */
-		.hdr_len = sizeof(struct hci_event_hdr),
-		.offset_len_in_hdr = offsetof(struct hci_event_hdr, plen),
-		.len_size = 1, /* sizeof(plen) in struct hci_event_hdr */
-		.reserve = 8,
-	},
 };
 
 /* Called from HCI core to initialize the device */
@@ -160,7 +161,7 @@
 		return -EBUSY;
 
 	/* provide contexts for callbacks from ST */
-	hst = hdev->driver_data;
+	hst = hci_get_drvdata(hdev);
 
 	for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
 		ti_st_proto[i].priv_data = hst;
@@ -235,12 +236,12 @@
 static int ti_st_close(struct hci_dev *hdev)
 {
 	int err, i;
-	struct ti_st *hst = hdev->driver_data;
+	struct ti_st *hst = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
 
-	for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
+	for (i = MAX_BT_CHNL_IDS-1; i >= 0; i--) {
 		err = st_unregister(&ti_st_proto[i]);
 		if (err)
 			BT_ERR("st_unregister(%d) failed with error %d",
@@ -263,7 +264,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	hst = hdev->driver_data;
+	hst = hci_get_drvdata(hdev);
 
 	/* Prepend skb with frame type */
 	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
@@ -290,14 +291,6 @@
 	return 0;
 }
 
-static void ti_st_destruct(struct hci_dev *hdev)
-{
-	BT_DBG("%s", hdev->name);
-	/* do nothing here, since platform remove
-	 * would free the hdev->driver_data
-	 */
-}
-
 static int bt_ti_probe(struct platform_device *pdev)
 {
 	static struct ti_st *hst;
@@ -319,13 +312,11 @@
 
 	hst->hdev = hdev;
 	hdev->bus = HCI_UART;
-	hdev->driver_data = hst;
+	hci_set_drvdata(hdev, hst);
 	hdev->open = ti_st_open;
 	hdev->close = ti_st_close;
 	hdev->flush = NULL;
 	hdev->send = ti_st_send_frame;
-	hdev->destruct = ti_st_destruct;
-	hdev->owner = THIS_MODULE;
 
 	err = hci_register_dev(hdev);
 	if (err < 0) {
diff -urN flo-ElementalX-5.00/drivers/bluetooth/dtl1_cs.c flo-ElementalX-5.00-patched/drivers/bluetooth/dtl1_cs.c
--- flo-ElementalX-5.00/drivers/bluetooth/dtl1_cs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/dtl1_cs.c	2016-06-02 00:28:55.000000000 +0000
@@ -38,7 +38,6 @@
 #include <linux/serial.h>
 #include <linux/serial_reg.h>
 #include <linux/bitops.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <pcmcia/cistpl.h>
@@ -83,9 +82,6 @@
 
 
 static int dtl1_config(struct pcmcia_device *link);
-static void dtl1_release(struct pcmcia_device *link);
-
-static void dtl1_detach(struct pcmcia_device *p_dev);
 
 
 /* Transmit states  */
@@ -367,7 +363,7 @@
 
 static int dtl1_hci_flush(struct hci_dev *hdev)
 {
-	dtl1_info_t *info = (dtl1_info_t *)(hdev->driver_data);
+	dtl1_info_t *info = hci_get_drvdata(hdev);
 
 	/* Drop TX queue */
 	skb_queue_purge(&(info->txq));
@@ -399,7 +395,7 @@
 		return -ENODEV;
 	}
 
-	info = (dtl1_info_t *)(hdev->driver_data);
+	info = hci_get_drvdata(hdev);
 
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
@@ -442,11 +438,6 @@
 }
 
 
-static void dtl1_hci_destruct(struct hci_dev *hdev)
-{
-}
-
-
 static int dtl1_hci_ioctl(struct hci_dev *hdev, unsigned int cmd,  unsigned long arg)
 {
 	return -ENOIOCTLCMD;
@@ -483,18 +474,15 @@
 	info->hdev = hdev;
 
 	hdev->bus = HCI_PCCARD;
-	hdev->driver_data = info;
+	hci_set_drvdata(hdev, info);
 	SET_HCIDEV_DEV(hdev, &info->p_dev->dev);
 
 	hdev->open     = dtl1_hci_open;
 	hdev->close    = dtl1_hci_close;
 	hdev->flush    = dtl1_hci_flush;
 	hdev->send     = dtl1_hci_send_frame;
-	hdev->destruct = dtl1_hci_destruct;
 	hdev->ioctl    = dtl1_hci_ioctl;
 
-	hdev->owner = THIS_MODULE;
-
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -551,9 +539,7 @@
 
 	spin_unlock_irqrestore(&(info->lock), flags);
 
-	if (hci_unregister_dev(hdev) < 0)
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	return 0;
@@ -581,8 +567,8 @@
 {
 	dtl1_info_t *info = link->priv;
 
-	dtl1_release(link);
-
+	dtl1_close(info);
+	pcmcia_disable_device(link);
 	kfree(info);
 }
 
@@ -621,22 +607,11 @@
 	return 0;
 
 failed:
-	dtl1_release(link);
+	dtl1_detach(link);
 	return -ENODEV;
 }
 
-
-static void dtl1_release(struct pcmcia_device *link)
-{
-	dtl1_info_t *info = link->priv;
-
-	dtl1_close(info);
-
-	pcmcia_disable_device(link);
-}
-
-
-static struct pcmcia_device_id dtl1_ids[] = {
+static const struct pcmcia_device_id dtl1_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-1", 0xe1bfdd64, 0xe168480d),
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-4", 0xe1bfdd64, 0x9102bc82),
 	PCMCIA_DEVICE_PROD_ID12("Socket", "CF", 0xb38bcc2e, 0x44ebf863),
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ath.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ath.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ath.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ath.c	2016-06-02 00:28:55.000000000 +0000
@@ -5,7 +5,6 @@
  *  power management protocol extension to H4 to support AR300x Bluetooth Chip.
  *
  *  Copyright (c) 2009-2010 Atheros Communications Inc.
- *  Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  *  Acknowledgements:
  *  This file is based on hci_h4.c, which was written
@@ -36,53 +35,12 @@
 #include <linux/errno.h>
 #include <linux/ioctl.h>
 #include <linux/skbuff.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
 #include "hci_uart.h"
 
-unsigned int enableuartsleep = 1;
-module_param(enableuartsleep, uint, 0644);
-/*
- * Global variables
- */
-/** Global state flags */
-static unsigned long flags;
-
-/** Tasklet to respond to change in hostwake line */
-static struct tasklet_struct hostwake_task;
-
-/** Transmission timer */
-static void bluesleep_tx_timer_expire(unsigned long data);
-static DEFINE_TIMER(tx_timer, bluesleep_tx_timer_expire, 0, 0);
-
-/** Lock for state transitions */
-static spinlock_t rw_lock;
-
-#define POLARITY_LOW 0
-#define POLARITY_HIGH 1
-
-struct bluesleep_info {
-	unsigned host_wake;			/* wake up host */
-	unsigned ext_wake;			/* wake up device */
-	unsigned host_wake_irq;
-	int irq_polarity;
-};
-
-/* 1 second timeout */
-#define TX_TIMER_INTERVAL  1
-
-/* state variable names and bit positions */
-#define BT_TXEXPIRED    0x01
-#define BT_SLEEPENABLE  0x02
-#define BT_SLEEPCMD	0x03
-
-/* global pointer to a single hci device. */
-static struct bluesleep_info *bsi;
-
 struct ath_struct {
 	struct hci_uart *hu;
 	unsigned int cur_sleep;
@@ -91,30 +49,35 @@
 	struct work_struct ctxtsw;
 };
 
-static void hostwake_interrupt(unsigned long data)
+static int ath_wakeup_ar3k(struct tty_struct *tty)
 {
-	BT_INFO(" wakeup host\n");
-}
+	struct ktermios ktermios;
+	int status = tty->driver->ops->tiocmget(tty);
 
-static void modify_timer_task(void)
-{
-	spin_lock(&rw_lock);
-	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-	clear_bit(BT_TXEXPIRED, &flags);
-	spin_unlock(&rw_lock);
+	if (status & TIOCM_CTS)
+		return status;
 
-}
+	/* Disable Automatic RTSCTS */
+	memcpy(&ktermios, tty->termios, sizeof(ktermios));
+	ktermios.c_cflag &= ~CRTSCTS;
+	tty_set_termios(tty, &ktermios);
+
+	/* Clear RTS first */
+	status = tty->driver->ops->tiocmget(tty);
+	tty->driver->ops->tiocmset(tty, 0x00, TIOCM_RTS);
+	mdelay(20);
+
+	/* Set RTS, wake up board */
+	status = tty->driver->ops->tiocmget(tty);
+	tty->driver->ops->tiocmset(tty, TIOCM_RTS, 0x00);
+	mdelay(20);
+
+	status = tty->driver->ops->tiocmget(tty);
+
+	/* Disable Automatic RTSCTS */
+	ktermios.c_cflag |= CRTSCTS;
+	status = tty_set_termios(tty, &ktermios);
 
-static int ath_wakeup_ar3k(struct tty_struct *tty)
-{
-	int status = 0;
-	if (test_bit(BT_TXEXPIRED, &flags)) {
-		BT_INFO("wakeup device\n");
-		gpio_set_value(bsi->ext_wake, 0);
-		msleep(20);
-		gpio_set_value(bsi->ext_wake, 1);
-	}
-	modify_timer_task();
 	return status;
 }
 
@@ -131,123 +94,25 @@
 	tty = hu->tty;
 
 	/* verify and wake up controller */
-	if (test_bit(BT_SLEEPENABLE, &flags))
+	if (ath->cur_sleep) {
 		status = ath_wakeup_ar3k(tty);
+		if (!(status & TIOCM_CTS))
+			return;
+	}
+
 	/* Ready to send Data */
 	clear_bit(HCI_UART_SENDING, &hu->tx_state);
 	hci_uart_tx_wakeup(hu);
 }
 
-static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
-{
-	/* schedule a tasklet to handle the change in the host wake line */
-	tasklet_schedule(&hostwake_task);
-	return IRQ_HANDLED;
-}
-
-static int ath_bluesleep_gpio_config(int on)
-{
-	int ret = 0;
-
-	BT_INFO("%s config: %d", __func__, on);
-	if (!on) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-		goto free_host_wake_irq;
-	}
-
-	ret = gpio_request(bsi->host_wake, "bt_host_wake");
-	if (ret < 0) {
-		BT_ERR("failed to request gpio pin %d, error %d\n",
-			bsi->host_wake, ret);
-		goto gpio_config_failed;
-	}
-
-	/* configure host_wake as input */
-	ret = gpio_direction_input(bsi->host_wake);
-	if (ret < 0) {
-		BT_ERR("failed to config GPIO %d as input pin, err %d\n",
-			bsi->host_wake, ret);
-		goto gpio_host_wake;
-	}
-
-	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
-	if (ret < 0) {
-		BT_ERR("failed to request gpio pin %d, error %d\n",
-			bsi->ext_wake, ret);
-		goto gpio_host_wake;
-	}
-
-	ret = gpio_direction_output(bsi->ext_wake, 1);
-	if (ret < 0) {
-		BT_ERR("failed to config GPIO %d as output pin, err %d\n",
-			bsi->ext_wake, ret);
-		goto gpio_ext_wake;
-	}
-
-	gpio_set_value(bsi->ext_wake, 1);
-
-	/* Initialize spinlock. */
-	spin_lock_init(&rw_lock);
-
-	/* Initialize timer */
-	init_timer(&tx_timer);
-	tx_timer.function = bluesleep_tx_timer_expire;
-	tx_timer.data = 0;
-
-	/* initialize host wake tasklet */
-	tasklet_init(&hostwake_task, hostwake_interrupt, 0);
-
-	if (bsi->irq_polarity == POLARITY_LOW) {
-		ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-				"bluetooth hostwake", NULL);
-	} else  {
-		ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_RISING,
-				"bluetooth hostwake", NULL);
-	}
-	if (ret  < 0) {
-		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
-		goto delete_timer;
-	}
-
-	ret = enable_irq_wake(bsi->host_wake_irq);
-	if (ret < 0) {
-		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
-		goto free_host_wake_irq;
-	}
-
-	return 0;
-
-free_host_wake_irq:
-	free_irq(bsi->host_wake_irq, NULL);
-delete_timer:
-	del_timer(&tx_timer);
-gpio_ext_wake:
-	gpio_free(bsi->ext_wake);
-gpio_host_wake:
-	gpio_free(bsi->host_wake);
-gpio_config_failed:
-	return ret;
-}
-
 /* Initialize protocol */
 static int ath_open(struct hci_uart *hu)
 {
 	struct ath_struct *ath;
 
-	BT_DBG("hu %p, bsi %p", hu, bsi);
-
-	if (!bsi)
-		return -EIO;
-
-	if (ath_bluesleep_gpio_config(1) < 0) {
-		BT_ERR("HCIATH3K GPIO Config failed");
-		return -EIO;
-	}
+	BT_DBG("hu %p", hu);
 
-	ath = kzalloc(sizeof(*ath), GFP_ATOMIC);
+	ath = kzalloc(sizeof(*ath), GFP_KERNEL);
 	if (!ath)
 		return -ENOMEM;
 
@@ -256,11 +121,6 @@
 	hu->priv = ath;
 	ath->hu = hu;
 
-	ath->cur_sleep = enableuartsleep;
-	if (ath->cur_sleep == 1) {
-		set_bit(BT_SLEEPENABLE, &flags);
-		modify_timer_task();
-	}
 	INIT_WORK(&ath->ctxtsw, ath_hci_uart_work);
 
 	return 0;
@@ -292,9 +152,6 @@
 	hu->priv = NULL;
 	kfree(ath);
 
-	if (bsi)
-		ath_bluesleep_gpio_config(0);
-
 	return 0;
 }
 
@@ -305,8 +162,6 @@
 {
 	struct ath_struct *ath = hu->priv;
 
-	BT_DBG("");
-
 	if (bt_cb(skb)->pkt_type == HCI_SCODATA_PKT) {
 		kfree_skb(skb);
 		return 0;
@@ -318,10 +173,9 @@
 	 */
 	if (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {
 		struct hci_command_hdr *hdr = (void *)skb->data;
-		if (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP) {
-			set_bit(BT_SLEEPCMD, &flags);
+
+		if (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP)
 			ath->cur_sleep = skb->data[HCI_COMMAND_HDR_SIZE];
-		}
 	}
 
 	BT_DBG("hu %p skb %p", hu, skb);
@@ -347,47 +201,15 @@
 /* Recv data */
 static int ath_recv(struct hci_uart *hu, void *data, int count)
 {
-	struct ath_struct *ath = hu->priv;
-	unsigned int type;
-
-	BT_DBG("");
+	int ret;
 
-	if (hci_recv_stream_fragment(hu->hdev, data, count) < 0)
+	ret = hci_recv_stream_fragment(hu->hdev, data, count);
+	if (ret < 0) {
 		BT_ERR("Frame Reassembly Failed");
-
-	if (count & test_bit(BT_SLEEPCMD, &flags)) {
-		struct sk_buff *skb = hu->hdev->reassembly[0];
-
-		if (!skb) {
-			struct { char type; } *pkt;
-
-			/* Start of the frame */
-			pkt = data;
-			type = pkt->type;
-		} else
-			type = bt_cb(skb)->pkt_type;
-
-		if (type == HCI_EVENT_PKT) {
-			clear_bit(BT_SLEEPCMD, &flags);
-			BT_INFO("cur_sleep:%d\n", ath->cur_sleep);
-			if (ath->cur_sleep == 1)
-				set_bit(BT_SLEEPENABLE, &flags);
-			else
-				clear_bit(BT_SLEEPENABLE, &flags);
-		}
-		if (test_bit(BT_SLEEPENABLE, &flags))
-			modify_timer_task();
+		return ret;
 	}
-	return count;
-}
 
-static void bluesleep_tx_timer_expire(unsigned long data)
-{
-	if (!test_bit(BT_SLEEPENABLE, &flags))
-		return;
-	BT_INFO("Tx timer expired\n");
-
-	set_bit(BT_TXEXPIRED, &flags);
+	return count;
 }
 
 static struct hci_uart_proto athp = {
@@ -400,89 +222,19 @@
 	.flush = ath_flush,
 };
 
-static int __init bluesleep_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-
-	BT_DBG("");
-
-	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
-	if (!bsi) {
-		ret = -ENOMEM;
-		goto failed;
-	}
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-						"gpio_host_wake");
-	if (!res) {
-		BT_ERR("couldn't find host_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->host_wake = res->start;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
-						"gpio_ext_wake");
-	if (!res) {
-		BT_ERR("couldn't find ext_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-	bsi->ext_wake = res->start;
-
-	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
-	if (bsi->host_wake_irq < 0) {
-		BT_ERR("couldn't find host_wake irq\n");
-		ret = -ENODEV;
-		goto free_bsi;
-	}
-
-	bsi->irq_polarity = POLARITY_LOW;	/* low edge (falling edge) */
-
-	return 0;
-
-free_bsi:
-	kfree(bsi);
-	bsi = NULL;
-failed:
-	return ret;
-}
-
-static int bluesleep_remove(struct platform_device *pdev)
-{
-	kfree(bsi);
-	return 0;
-}
-
-static struct platform_driver bluesleep_driver = {
-	.remove = bluesleep_remove,
-	.driver = {
-		.name = "bluesleep",
-		.owner = THIS_MODULE,
-	},
-};
-
 int __init ath_init(void)
 {
-	int ret;
+	int err = hci_uart_register_proto(&athp);
 
-	ret = hci_uart_register_proto(&athp);
-
-	if (!ret)
+	if (!err)
 		BT_INFO("HCIATH3K protocol initialized");
-	else {
+	else
 		BT_ERR("HCIATH3K protocol registration failed");
-		return ret;
-	}
-	ret = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
-	if (ret)
-		return ret;
-	return 0;
+
+	return err;
 }
 
 int __exit ath_deinit(void)
 {
-	platform_driver_unregister(&bluesleep_driver);
 	return hci_uart_unregister_proto(&athp);
 }
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_bcsp.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_bcsp.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_bcsp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_bcsp.c	2016-06-02 00:28:55.000000000 +0000
@@ -49,8 +49,8 @@
 
 #define VERSION "0.3"
 
-static int txcrc = 1;
-static int hciextn = 1;
+static bool txcrc = 1;
+static bool hciextn = 1;
 
 #define BCSP_TXWINSIZE	4
 
@@ -692,7 +692,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	bcsp = kzalloc(sizeof(*bcsp), GFP_ATOMIC);
+	bcsp = kzalloc(sizeof(*bcsp), GFP_KERNEL);
 	if (!bcsp)
 		return -ENOMEM;
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_h4.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_h4.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_h4.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_h4.c	2016-06-02 00:28:55.000000000 +0000
@@ -69,7 +69,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	h4 = kzalloc(sizeof(*h4), GFP_ATOMIC);
+	h4 = kzalloc(sizeof(*h4), GFP_KERNEL);
 	if (!h4)
 		return -ENOMEM;
 
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ldisc.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ldisc.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ldisc.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ldisc.c	2016-06-02 00:28:55.000000000 +0000
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
- *  Copyright (c) 2000-2001, 2010-2012, The Linux Foundation. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -48,10 +48,7 @@
 
 #define VERSION "2.2"
 
-static bool reset = 0;
-
 static struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];
-static void hci_uart_tty_wakeup_action(unsigned long data);
 
 int hci_uart_register_proto(struct hci_uart_proto *p)
 {
@@ -175,7 +172,7 @@
 /* Reset device */
 static int hci_uart_flush(struct hci_dev *hdev)
 {
-	struct hci_uart *hu  = (struct hci_uart *) hdev->driver_data;
+	struct hci_uart *hu  = hci_get_drvdata(hdev);
 	struct tty_struct *tty = hu->tty;
 
 	BT_DBG("hdev %p tty %p", hdev, tty);
@@ -221,7 +218,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	hu = (struct hci_uart *) hdev->driver_data;
+	hu = hci_get_drvdata(hdev);
 
 	BT_DBG("%s: type %d len %d", hdev->name, bt_cb(skb)->pkt_type, skb->len);
 
@@ -232,15 +229,6 @@
 	return 0;
 }
 
-static void hci_uart_destruct(struct hci_dev *hdev)
-{
-	if (!hdev)
-		return;
-
-	BT_DBG("%s", hdev->name);
-	kfree(hdev->driver_data);
-}
-
 /* ------ LDISC part ------ */
 /* hci_uart_tty_open
  * 
@@ -277,8 +265,6 @@
 	tty->receive_room = 65536;
 
 	spin_lock_init(&hu->rx_lock);
-	tasklet_init(&hu->tty_wakeup_task, hci_uart_tty_wakeup_action,
-			 (unsigned long)hu);
 
 	/* Flush any pending characters in the driver and line discipline. */
 
@@ -312,15 +298,15 @@
 		if (hdev)
 			hci_uart_close(hdev);
 
-		tasklet_kill(&hu->tty_wakeup_task);
-
 		if (test_and_clear_bit(HCI_UART_PROTO_SET, &hu->flags)) {
-			hu->proto->close(hu);
 			if (hdev) {
 				hci_unregister_dev(hdev);
 				hci_free_dev(hdev);
 			}
+			hu->proto->close(hu);
 		}
+
+		kfree(hu);
 	}
 }
 
@@ -328,8 +314,6 @@
  *
  *    Callback for transmit wakeup. Called when low level
  *    device driver can accept more send data.
- *    This callback gets called from the isr context so
- *    schedule the send data operation to tasklet.
  *
  * Arguments:        tty    pointer to associated tty instance data
  * Return Value:    None
@@ -337,26 +321,12 @@
 static void hci_uart_tty_wakeup(struct tty_struct *tty)
 {
 	struct hci_uart *hu = (void *)tty->disc_data;
-	tasklet_schedule(&hu->tty_wakeup_task);
-}
-
-/* hci_uart_tty_wakeup_action()
- *
- * Scheduled action to transmit data when low level device
- * driver can accept more data.
- */
-static void hci_uart_tty_wakeup_action(unsigned long data)
-{
-	struct hci_uart *hu = (struct hci_uart *)data;
-	struct tty_struct *tty;
 
 	BT_DBG("");
 
 	if (!hu)
 		return;
 
-	tty = hu->tty;
-
 	clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
 
 	if (tty != hu->tty)
@@ -380,7 +350,6 @@
  */
 static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *flags, int count)
 {
-	int ret;
 	struct hci_uart *hu = (void *)tty->disc_data;
 
 	if (!hu || tty != hu->tty)
@@ -390,9 +359,8 @@
 		return;
 
 	spin_lock(&hu->rx_lock);
-	ret = hu->proto->recv(hu, (void *) data, count);
-	if (ret > 0)
-		hu->hdev->stat.byte_rx += count;
+	hu->proto->recv(hu, (void *) data, count);
+	hu->hdev->stat.byte_rx += count;
 	spin_unlock(&hu->rx_lock);
 
 	tty_unthrottle(tty);
@@ -414,22 +382,24 @@
 	hu->hdev = hdev;
 
 	hdev->bus = HCI_UART;
-	hdev->driver_data = hu;
+	hci_set_drvdata(hdev, hu);
 
 	hdev->open  = hci_uart_open;
 	hdev->close = hci_uart_close;
 	hdev->flush = hci_uart_flush;
 	hdev->send  = hci_uart_send_frame;
-	hdev->destruct = hci_uart_destruct;
 	hdev->parent = hu->tty->dev;
 
-	hdev->owner = THIS_MODULE;
+	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
+		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
 
-	if (!reset)
+	if (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))
 		set_bit(HCI_QUIRK_NO_RESET, &hdev->quirks);
 
-	if (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))
-		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
+	if (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))
+		hdev->dev_type = HCI_AMP;
+	else
+		hdev->dev_type = HCI_BREDR;
 
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
@@ -491,18 +461,11 @@
 
 	switch (cmd) {
 	case HCIUARTSETPROTO:
-		if (!test_and_set_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-			&hu->flags) && !test_bit(HCI_UART_PROTO_SET,
-				&hu->flags)) {
+		if (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {
 			err = hci_uart_set_proto(hu, arg);
 			if (err) {
-				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-						&hu->flags);
+				clear_bit(HCI_UART_PROTO_SET, &hu->flags);
 				return err;
-			} else {
-				set_bit(HCI_UART_PROTO_SET, &hu->flags);
-				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
-						&hu->flags);
 			}
 		} else
 			return -EBUSY;
@@ -595,9 +558,6 @@
 #ifdef CONFIG_BT_HCIUART_ATH3K
 	ath_init();
 #endif
-#ifdef CONFIG_BT_HCIUART_IBS
-	ibs_init();
-#endif
 
 	return 0;
 }
@@ -618,9 +578,6 @@
 #ifdef CONFIG_BT_HCIUART_ATH3K
 	ath_deinit();
 #endif
-#ifdef CONFIG_BT_HCIUART_IBS
-	ibs_deinit();
-#endif
 
 	/* Release tty registration of line discipline */
 	if ((err = tty_unregister_ldisc(N_HCI)))
@@ -630,9 +587,6 @@
 module_init(hci_uart_init);
 module_exit(hci_uart_exit);
 
-module_param(reset, bool, 0644);
-MODULE_PARM_DESC(reset, "Send HCI reset command on initialization");
-
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Bluetooth HCI UART driver ver " VERSION);
 MODULE_VERSION(VERSION);
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_ll.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ll.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_ll.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_ll.c	2016-06-02 00:28:55.000000000 +0000
@@ -125,7 +125,7 @@
 
 	BT_DBG("hu %p", hu);
 
-	ll = kzalloc(sizeof(*ll), GFP_ATOMIC);
+	ll = kzalloc(sizeof(*ll), GFP_KERNEL);
 	if (!ll)
 		return -ENOMEM;
 
@@ -207,7 +207,7 @@
 		/*
 		 * This state means that both the host and the BRF chip
 		 * have simultaneously sent a wake-up-indication packet.
-		 * Traditionaly, in this case, receiving a wake-up-indication
+		 * Traditionally, in this case, receiving a wake-up-indication
 		 * was enough and an additional wake-up-ack wasn't needed.
 		 * This has changed with the BRF6350, which does require an
 		 * explicit wake-up-ack. Other BRF versions, which do not
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_smd.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_smd.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_smd.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_smd.c	2016-06-02 00:28:55.000000000 +0000
@@ -148,12 +148,6 @@
 }
 
 
-static void hci_smd_destruct(struct hci_dev *hdev)
-{
-	if (NULL != hdev->driver_data)
-		kfree(hdev->driver_data);
-}
-
 static void hci_smd_recv_data(void)
 {
 	int len = 0;
@@ -486,12 +480,9 @@
 
 	hsmd->hdev = hdev;
 	hdev->bus = HCI_SMD;
-	hdev->driver_data = NULL;
 	hdev->open  = hci_smd_open;
 	hdev->close = hci_smd_close;
 	hdev->send  = hci_smd_send_frame;
-	hdev->destruct = hci_smd_destruct;
-	hdev->owner = THIS_MODULE;
 
 
 	tasklet_init(&hsmd->rx_task,
@@ -545,9 +536,7 @@
 		BT_INFO("HCI device un-registration going on");
 
 		if (hsmd->hdev) {
-			if (hci_unregister_dev(hsmd->hdev) < 0)
-				BT_ERR("Can't unregister HCI device %s",
-					hsmd->hdev->name);
+			hci_unregister_dev(hsmd->hdev);
 
 			hci_free_dev(hsmd->hdev);
 			hsmd->hdev = NULL;
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_uart.h flo-ElementalX-5.00-patched/drivers/bluetooth/hci_uart.h
--- flo-ElementalX-5.00/drivers/bluetooth/hci_uart.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_uart.h	2016-06-02 00:28:55.000000000 +0000
@@ -2,9 +2,9 @@
  *
  *  Bluetooth HCI UART driver
  *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
  *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
  *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
- *  Copyright (c) 2000-2001, 2010, 2012 The Linux Foundation. All rights reserved.
  *
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -42,10 +42,12 @@
 #define HCI_UART_3WIRE	2
 #define HCI_UART_H4DS	3
 #define HCI_UART_LL	4
-#define HCI_UART_IBS	5
-#define HCI_UART_ATH3K	6
+#define HCI_UART_ATH3K	5
+#define HCI_UART_IBS   6
 
 #define HCI_UART_RAW_DEVICE	0
+#define HCI_UART_RESET_ON_INIT	1
+#define HCI_UART_CREATE_AMP	2
 
 struct hci_uart;
 
@@ -66,7 +68,6 @@
 	unsigned long		hdev_flags;
 
 	struct hci_uart_proto	*proto;
-	struct tasklet_struct	tty_wakeup_task;
 	void			*priv;
 
 	struct sk_buff		*tx_skb;
@@ -75,8 +76,7 @@
 };
 
 /* HCI_UART proto flag bits */
-#define HCI_UART_PROTO_SET			0
-#define HCI_UART_PROTO_SET_IN_PROGRESS		1
+#define HCI_UART_PROTO_SET	0
 
 /* TX states  */
 #define HCI_UART_SENDING	1
@@ -105,8 +105,3 @@
 int ath_init(void);
 int ath_deinit(void);
 #endif
-
-#ifdef CONFIG_BT_HCIUART_IBS
-int ibs_init(void);
-int ibs_deinit(void);
-#endif
diff -urN flo-ElementalX-5.00/drivers/bluetooth/hci_vhci.c flo-ElementalX-5.00-patched/drivers/bluetooth/hci_vhci.c
--- flo-ElementalX-5.00/drivers/bluetooth/hci_vhci.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/bluetooth/hci_vhci.c	2016-06-02 00:28:55.000000000 +0000
@@ -41,6 +41,8 @@
 
 #define VERSION "1.3"
 
+static bool amp;
+
 struct vhci_data {
 	struct hci_dev *hdev;
 
@@ -59,7 +61,7 @@
 
 static int vhci_close_dev(struct hci_dev *hdev)
 {
-	struct vhci_data *data = hdev->driver_data;
+	struct vhci_data *data = hci_get_drvdata(hdev);
 
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
@@ -71,7 +73,7 @@
 
 static int vhci_flush(struct hci_dev *hdev)
 {
-	struct vhci_data *data = hdev->driver_data;
+	struct vhci_data *data = hci_get_drvdata(hdev);
 
 	skb_queue_purge(&data->readq);
 
@@ -91,7 +93,7 @@
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
-	data = hdev->driver_data;
+	data = hci_get_drvdata(hdev);
 
 	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
 	skb_queue_tail(&data->readq, skb);
@@ -101,11 +103,6 @@
 	return 0;
 }
 
-static void vhci_destruct(struct hci_dev *hdev)
-{
-	kfree(hdev->driver_data);
-}
-
 static inline ssize_t vhci_get_user(struct vhci_data *data,
 					const char __user *buf, size_t count)
 {
@@ -237,15 +234,15 @@
 	data->hdev = hdev;
 
 	hdev->bus = HCI_VIRTUAL;
-	hdev->driver_data = data;
+	hci_set_drvdata(hdev, data);
+
+	if (amp)
+		hdev->dev_type = HCI_AMP;
 
 	hdev->open     = vhci_open_dev;
 	hdev->close    = vhci_close_dev;
 	hdev->flush    = vhci_flush;
 	hdev->send     = vhci_send_frame;
-	hdev->destruct = vhci_destruct;
-
-	hdev->owner = THIS_MODULE;
 
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
@@ -264,13 +261,11 @@
 	struct vhci_data *data = file->private_data;
 	struct hci_dev *hdev = data->hdev;
 
-	if (hci_unregister_dev(hdev) < 0) {
-		BT_ERR("Can't unregister HCI device %s", hdev->name);
-	}
-
+	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
 	file->private_data = NULL;
+	kfree(data);
 
 	return 0;
 }
@@ -306,6 +301,9 @@
 module_init(vhci_init);
 module_exit(vhci_exit);
 
+module_param(amp, bool, 0644);
+MODULE_PARM_DESC(amp, "Create AMP controller device");
+
 MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Bluetooth virtual HCI driver ver " VERSION);
 MODULE_VERSION(VERSION);
diff -urN flo-ElementalX-5.00/drivers/char/msm_rotator.c flo-ElementalX-5.00-patched/drivers/char/msm_rotator.c
--- flo-ElementalX-5.00/drivers/char/msm_rotator.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/char/msm_rotator.c	2014-12-03 11:07:31.000000000 +0000
@@ -319,7 +319,7 @@
 		rc = 1;
 #endif
 	if (rc == 1) {
-		cancel_delayed_work_sync(&msm_rotator_dev->imem_clk_work);
+		cancel_delayed_work(&msm_rotator_dev->imem_clk_work);
 		if (msm_rotator_dev->imem_clk_state != CLK_EN
 			&& msm_rotator_dev->imem_clk) {
 			clk_prepare_enable(msm_rotator_dev->imem_clk);
@@ -735,7 +735,6 @@
 uint32_t fast_yuv_invalid_size_checker(unsigned char rot_mode,
 						uint32_t src_width,
 						uint32_t dst_width,
-						uint32_t src_height,
 						uint32_t dst_height,
 						uint32_t dstp0_ystride,
 						uint32_t is_planar420)
@@ -750,9 +749,6 @@
 
 	if (rot_mode & MDP_ROT_90) {
 
-		if ((src_height % 128) == 8)
-			return -EINVAL;
-
 		/* if rotation 90 degree on fast yuv
 		 * rotator image input width has to be multiple of 8
 		 * rotator image input height has to be multiple of 8
@@ -805,9 +801,9 @@
 	} else {
 		/* if NOT applying rotation 90 degree on fast yuv,
 		 * rotator image input width has to be multiple of 8
-		 * rotator image input height has to be multiple of 8
+		 * rotator image input height has to be multiple of 2
 		*/
-		if (((dst_width % 8) != 0) || ((dst_height % 8) != 0))
+		if (((dst_width % 8) != 0) || ((dst_height % 2) != 0))
 			return -EINVAL;
 	}
 
@@ -1560,7 +1556,7 @@
 	msm_rotator_wait_for_fence(commit_info->acq_fen);
 	commit_info->acq_fen = NULL;
 
-	cancel_delayed_work_sync(&msm_rotator_dev->rot_clk_work);
+	cancel_delayed_work(&msm_rotator_dev->rot_clk_work);
 	if (msm_rotator_dev->rot_clk_state != CLK_EN) {
 		enable_rot_clks();
 		msm_rotator_dev->rot_clk_state = CLK_EN;
@@ -1658,8 +1654,10 @@
 
 	msm_rotator_dev->processing = 1;
 	iowrite32(0x1, MSM_ROTATOR_START);
+	mutex_unlock(&msm_rotator_dev->rotator_lock);
 	wait_event(msm_rotator_dev->wq,
 		   (msm_rotator_dev->processing == 0));
+	mutex_lock(&msm_rotator_dev->rotator_lock);
 	status = (unsigned char)ioread32(MSM_ROTATOR_INTR_STATUS);
 	if ((status & 0x03) != 0x01) {
 		pr_err("%s(): AXI Bus Error, issuing SW_RESET\n", __func__);
@@ -1959,7 +1957,6 @@
 			fast_yuv_en = !fast_yuv_invalid_size_checker(
 						info.rotations,
 						info.src.width,
-						info.src.height,
 						dst_w,
 						dst_h,
 						dst_w,
@@ -2104,7 +2101,6 @@
 	if (copy_from_user(&session_id, (void __user *)arg, sizeof(s)))
 		return -EFAULT;
 
-	rot_wait_for_commit_queue(true);
 	mutex_lock(&msm_rotator_dev->rotator_lock);
 	for (s = 0; s < MAX_SESSIONS; s++) {
 		if ((msm_rotator_dev->rot_session[s] != NULL) &&
diff -urN flo-ElementalX-5.00/drivers/cpufreq/cpufreq_elementalx.c flo-ElementalX-5.00-patched/drivers/cpufreq/cpufreq_elementalx.c
--- flo-ElementalX-5.00/drivers/cpufreq/cpufreq_elementalx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/cpufreq/cpufreq_elementalx.c	2016-06-03 17:55:17.000000000 +0000
@@ -35,7 +35,7 @@
 #include <mach/kgsl.h>
 static int old_up_threshold;
 static int g_count = 0;
-
+int graphics_boost = 0;
 #define DEF_SAMPLING_RATE			(30000)
 #define DEF_FREQUENCY_DOWN_DIFFERENTIAL		(10)
 #define DEF_FREQUENCY_UP_THRESHOLD		(90)
diff -urN flo-ElementalX-5.00/drivers/gpu/ion/ion.c flo-ElementalX-5.00-patched/drivers/gpu/ion/ion.c
--- flo-ElementalX-5.00/drivers/gpu/ion/ion.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/ion/ion.c	2016-06-03 17:04:41.000000000 +0000
@@ -1248,19 +1248,19 @@
 }
 
 
-int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle)
+struct dma_buf *ion_share_dma_buf(struct ion_client *client,
+						struct ion_handle *handle)
 {
 	struct ion_buffer *buffer;
 	struct dma_buf *dmabuf;
 	bool valid_handle;
-	int fd;
 
 	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
 	mutex_unlock(&client->lock);
 	if (!valid_handle) {
 		WARN(1, "%s: invalid handle passed to share.\n", __func__);
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
 	buffer = handle->buffer;
@@ -1268,15 +1268,29 @@
 	dmabuf = dma_buf_export(buffer, &dma_buf_ops, buffer->size, O_RDWR);
 	if (IS_ERR(dmabuf)) {
 		ion_buffer_put(buffer);
-		return PTR_ERR(dmabuf);
+		return dmabuf;
 	}
+
+	return dmabuf;
+}
+EXPORT_SYMBOL(ion_share_dma_buf);
+
+int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle)
+{
+	struct dma_buf *dmabuf;
+	int fd;
+
+	dmabuf = ion_share_dma_buf(client, handle);
+	if (IS_ERR(dmabuf))
+		return PTR_ERR(dmabuf);
+
 	fd = dma_buf_fd(dmabuf, O_CLOEXEC);
 	if (fd < 0)
 		dma_buf_put(dmabuf);
 
 	return fd;
 }
-EXPORT_SYMBOL(ion_share_dma_buf);
+EXPORT_SYMBOL(ion_share_dma_buf_fd);
 
 struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd)
 {
@@ -1366,7 +1380,7 @@
 		if (ret)
 			return ret;
 
-		data.fd = ion_share_dma_buf(client, data.handle);
+		data.fd = ion_share_dma_buf_fd(client, data.handle);
 		if (copy_to_user((void __user *)arg, &data, sizeof(data)))
 			return -EFAULT;
 		if (data.fd < 0)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/Kconfig flo-ElementalX-5.00-patched/drivers/gpu/msm/Kconfig
--- flo-ElementalX-5.00/drivers/gpu/msm/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/Kconfig	2014-09-21 01:02:11.000000000 +0000
@@ -96,11 +96,3 @@
 	bool "Disable register shadow writes for context switches"
 	default n
 	depends on MSM_KGSL
-
-config MSM_KGSL_SIMPLE_GOV
-	bool "Simple KGSL GPU govenor for Qualcomm Adreno xxx devices"
-	default n
-	depends on MSM_KGSL
-	---help---
-	  A simple KGSL GPU govenor for Qualcom Adreno XXX devices
-
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/Makefile flo-ElementalX-5.00-patched/drivers/gpu/msm/Makefile
--- flo-ElementalX-5.00/drivers/gpu/msm/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/Makefile	2014-09-21 01:02:11.000000000 +0000
@@ -25,8 +25,8 @@
 	adreno_dispatch.o \
 	adreno_postmortem.o \
 	adreno_snapshot.o \
-	adreno_coresight.o \
 	adreno_trace.o \
+	adreno_coresight.o \
 	adreno_a2xx.o \
 	adreno_a2xx_trace.o \
 	adreno_a2xx_snapshot.o \
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a2xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a2xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a2xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a2xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -252,15 +252,7 @@
 #define REG_CP_CSQ_IB1_STAT              0x01FE
 #define REG_CP_CSQ_IB2_STAT              0x01FF
 #define REG_CP_CSQ_RB_STAT               0x01FD
-
 #define REG_CP_DEBUG                     0x01FC
-/*
- * CP DEBUG settings for a3xx and a2xx cores:
- * DYNAMIC_CLK_DISABLE [27] - turn off the dynamic clock control
- * MIU_128BIT_WRITE_ENABLE [25] - Allow 128 bit writes to the VBIF
- */
-#define A2XX_CP_DEBUG_DEFAULT ((1 << 27) | (1 << 25))
-
 #define REG_CP_IB1_BASE                  0x0458
 #define REG_CP_IB1_BUFSZ                 0x0459
 #define REG_CP_IB2_BASE                  0x045A
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a3xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a3xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a3xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a3xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -487,11 +487,6 @@
 #define A3XX_VBIF_PERF_PWR_CNT2_LO 0x307b
 #define A3XX_VBIF_PERF_PWR_CNT2_HI 0x307c
 
-#define A3XX_VBIF_XIN_HALT_CTRL0 0x3080
-#define A3XX_VBIF_XIN_HALT_CTRL0_MASK 0x3F
-#define A3XX_VBIF_XIN_HALT_CTRL1 0x3081
-
-
 /* Bit flags for RBBM_CTL */
 #define RBBM_RBBM_CTL_RESET_PWR_CTR0  BIT(0)
 #define RBBM_RBBM_CTL_RESET_PWR_CTR1  BIT(1)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/a4xx_reg.h flo-ElementalX-5.00-patched/drivers/gpu/msm/a4xx_reg.h
--- flo-ElementalX-5.00/drivers/gpu/msm/a4xx_reg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/a4xx_reg.h	2014-09-21 01:02:11.000000000 +0000
@@ -24,201 +24,17 @@
 #define A4XX_RBBM_AHB_CTL1		0x24
 #define A4XX_RBBM_WAIT_IDLE_CLOCKS_CTL	0x2b
 #define A4XX_RBBM_INTERFACE_HANG_INT_CTL	0x2f
+#define A4XX_RBBM_AHB_ERROR_STATUS	0x18f
+#define A4XX_RBBM_STATUS		0x191
 #define A4XX_RBBM_INT_CLEAR_CMD		0x36
 #define A4XX_RBBM_INT_0_MASK		0x37
-
-#define A4XX_RBBM_PERFCTR_CP_0_LO		0x9c
-#define A4XX_RBBM_PERFCTR_CP_0_HI		0x9d
-#define A4XX_RBBM_PERFCTR_CP_1_LO		0x9e
-#define A4XX_RBBM_PERFCTR_CP_1_HI		0x9f
-#define A4XX_RBBM_PERFCTR_RBBM_0_LO		0xac
-#define A4XX_RBBM_PERFCTR_RBBM_0_HI		0xad
-#define A4XX_RBBM_PERFCTR_RBBM_1_LO		0xae
-#define A4XX_RBBM_PERFCTR_RBBM_1_HI		0xaf
-#define A4XX_RBBM_PERFCTR_RBBM_2_LO		0xb0
-#define A4XX_RBBM_PERFCTR_RBBM_2_HI		0xb1
-#define A4XX_RBBM_PERFCTR_RBBM_3_LO		0xb2
-#define A4XX_RBBM_PERFCTR_RBBM_3_HI		0xb3
-#define A4XX_RBBM_PERFCTR_PC_0_LO		0xb4
-#define A4XX_RBBM_PERFCTR_PC_0_HI		0xb5
-#define A4XX_RBBM_PERFCTR_PC_1_LO		0xb6
-#define A4XX_RBBM_PERFCTR_PC_1_HI		0xb7
-#define A4XX_RBBM_PERFCTR_PC_2_LO		0xb8
-#define A4XX_RBBM_PERFCTR_PC_2_HI		0xb9
-#define A4XX_RBBM_PERFCTR_PC_3_LO		0xba
-#define A4XX_RBBM_PERFCTR_PC_3_HI		0xbb
-#define A4XX_RBBM_PERFCTR_PC_4_LO		0xbc
-#define A4XX_RBBM_PERFCTR_PC_4_HI		0xbd
-#define A4XX_RBBM_PERFCTR_PC_5_LO		0xbe
-#define A4XX_RBBM_PERFCTR_PC_5_HI		0xbf
-#define A4XX_RBBM_PERFCTR_PC_6_LO		0xc0
-#define A4XX_RBBM_PERFCTR_PC_6_HI		0xc1
-#define A4XX_RBBM_PERFCTR_PC_7_LO		0xc2
-#define A4XX_RBBM_PERFCTR_PC_7_HI		0xc3
-#define A4XX_RBBM_PERFCTR_VFD_0_LO		0xc4
-#define A4XX_RBBM_PERFCTR_VFD_0_HI		0xc5
-#define A4XX_RBBM_PERFCTR_VFD_1_LO		0xc6
-#define A4XX_RBBM_PERFCTR_VFD_1_HI		0xc7
-#define A4XX_RBBM_PERFCTR_VFD_2_LO		0xc8
-#define A4XX_RBBM_PERFCTR_VFD_2_HI		0xc9
-#define A4XX_RBBM_PERFCTR_VFD_3_LO		0xca
-#define A4XX_RBBM_PERFCTR_VFD_3_HI		0xcb
-#define A4XX_RBBM_PERFCTR_VFD_4_LO		0xcc
-#define A4XX_RBBM_PERFCTR_VFD_4_HI		0xcd
-#define A4XX_RBBM_PERFCTR_VFD_5_LO		0xce
-#define A4XX_RBBM_PERFCTR_VFD_5_HI		0xcf
-#define A4XX_RBBM_PERFCTR_VFD_6_LO		0xd0
-#define A4XX_RBBM_PERFCTR_VFD_6_HI		0xd1
-#define A4XX_RBBM_PERFCTR_VFD_7_LO		0xd2
-#define A4XX_RBBM_PERFCTR_VFD_7_HI		0xd3
-#define A4XX_RBBM_PERFCTR_HLSQ_0_LO		0xd4
-#define A4XX_RBBM_PERFCTR_HLSQ_0_HI		0xd5
-#define A4XX_RBBM_PERFCTR_HLSQ_1_LO		0xd6
-#define A4XX_RBBM_PERFCTR_HLSQ_1_HI		0xd7
-#define A4XX_RBBM_PERFCTR_HLSQ_2_LO		0xd8
-#define A4XX_RBBM_PERFCTR_HLSQ_2_HI		0xd9
-#define A4XX_RBBM_PERFCTR_HLSQ_3_LO		0xda
-#define A4XX_RBBM_PERFCTR_HLSQ_3_HI		0xdb
-#define A4XX_RBBM_PERFCTR_HLSQ_4_LO		0xdc
-#define A4XX_RBBM_PERFCTR_HLSQ_4_HI		0xdd
-#define A4XX_RBBM_PERFCTR_HLSQ_5_LO		0xde
-#define A4XX_RBBM_PERFCTR_HLSQ_5_HI		0xdf
-#define A4XX_RBBM_PERFCTR_HLSQ_6_LO		0xe0
-#define A4XX_RBBM_PERFCTR_HLSQ_6_HI		0xe1
-#define A4XX_RBBM_PERFCTR_HLSQ_7_LO		0xe2
-#define A4XX_RBBM_PERFCTR_HLSQ_7_HI		0xe3
-#define A4XX_RBBM_PERFCTR_VPC_0_LO		0xe4
-#define A4XX_RBBM_PERFCTR_VPC_0_HI		0xe5
-#define A4XX_RBBM_PERFCTR_VPC_1_LO		0xe6
-#define A4XX_RBBM_PERFCTR_VPC_1_HI		0xe7
-#define A4XX_RBBM_PERFCTR_VPC_2_LO		0xe8
-#define A4XX_RBBM_PERFCTR_VPC_2_HI		0xe9
-#define A4XX_RBBM_PERFCTR_VPC_3_LO		0xea
-#define A4XX_RBBM_PERFCTR_VPC_3_HI		0xeb
-#define A4XX_RBBM_PERFCTR_CCU_0_LO		0xec
-#define A4XX_RBBM_PERFCTR_CCU_0_HI		0xed
-#define A4XX_RBBM_PERFCTR_CCU_1_LO		0xee
-#define A4XX_RBBM_PERFCTR_CCU_1_HI		0xef
-#define A4XX_RBBM_PERFCTR_CCU_2_LO		0xf0
-#define A4XX_RBBM_PERFCTR_CCU_2_HI		0xf1
-#define A4XX_RBBM_PERFCTR_CCU_3_LO		0xf2
-#define A4XX_RBBM_PERFCTR_CCU_3_HI		0xf3
-#define A4XX_RBBM_PERFCTR_TSE_0_LO		0xf4
-#define A4XX_RBBM_PERFCTR_TSE_0_HI		0xf5
-#define A4XX_RBBM_PERFCTR_TSE_1_LO		0xf6
-#define A4XX_RBBM_PERFCTR_TSE_1_HI		0xf7
-#define A4XX_RBBM_PERFCTR_TSE_2_LO		0xf8
-#define A4XX_RBBM_PERFCTR_TSE_2_HI		0xf9
-#define A4XX_RBBM_PERFCTR_TSE_3_LO		0xfa
-#define A4XX_RBBM_PERFCTR_TSE_3_HI		0xfb
-#define A4XX_RBBM_PERFCTR_RAS_0_LO		0xfc
-#define A4XX_RBBM_PERFCTR_RAS_0_HI		0xfd
-#define A4XX_RBBM_PERFCTR_RAS_1_LO		0xfe
-#define A4XX_RBBM_PERFCTR_RAS_1_HI		0xff
-#define A4XX_RBBM_PERFCTR_RAS_2_LO		0x100
-#define A4XX_RBBM_PERFCTR_RAS_2_HI		0x101
-#define A4XX_RBBM_PERFCTR_RAS_3_LO		0x102
-#define A4XX_RBBM_PERFCTR_RAS_3_HI		0x103
-#define A4XX_RBBM_PERFCTR_UCHE_0_LO		0x104
-#define A4XX_RBBM_PERFCTR_UCHE_0_HI		0x105
-#define A4XX_RBBM_PERFCTR_UCHE_1_LO		0x106
-#define A4XX_RBBM_PERFCTR_UCHE_1_HI		0x107
-#define A4XX_RBBM_PERFCTR_UCHE_2_LO		0x108
-#define A4XX_RBBM_PERFCTR_UCHE_2_HI		0x109
-#define A4XX_RBBM_PERFCTR_UCHE_3_LO		0x10a
-#define A4XX_RBBM_PERFCTR_UCHE_3_HI		0x10b
-#define A4XX_RBBM_PERFCTR_UCHE_4_LO		0x10c
-#define A4XX_RBBM_PERFCTR_UCHE_4_HI		0x10d
-#define A4XX_RBBM_PERFCTR_UCHE_5_LO		0x10e
-#define A4XX_RBBM_PERFCTR_UCHE_5_HI		0x10f
-#define A4XX_RBBM_PERFCTR_UCHE_6_LO		0x110
-#define A4XX_RBBM_PERFCTR_UCHE_6_HI		0x111
-#define A4XX_RBBM_PERFCTR_UCHE_7_LO		0x112
-#define A4XX_RBBM_PERFCTR_UCHE_7_HI		0x113
-#define A4XX_RBBM_PERFCTR_TP_0_LO		0x114
-#define A4XX_RBBM_PERFCTR_TP_0_HI		0x115
-#define A4XX_RBBM_PERFCTR_TP_1_LO		0x116
-#define A4XX_RBBM_PERFCTR_TP_1_HI		0x117
-#define A4XX_RBBM_PERFCTR_TP_2_LO		0x118
-#define A4XX_RBBM_PERFCTR_TP_2_HI		0x119
-#define A4XX_RBBM_PERFCTR_TP_3_LO		0x11a
-#define A4XX_RBBM_PERFCTR_TP_3_HI		0x11b
-#define A4XX_RBBM_PERFCTR_TP_4_LO		0x11c
-#define A4XX_RBBM_PERFCTR_TP_4_HI		0x11d
-#define A4XX_RBBM_PERFCTR_TP_5_LO		0x11e
-#define A4XX_RBBM_PERFCTR_TP_5_HI		0x11f
-#define A4XX_RBBM_PERFCTR_TP_6_LO		0x120
-#define A4XX_RBBM_PERFCTR_TP_6_HI		0x121
-#define A4XX_RBBM_PERFCTR_TP_7_LO		0x122
-#define A4XX_RBBM_PERFCTR_TP_7_HI		0x123
-#define A4XX_RBBM_PERFCTR_SP_0_LO		0x124
-#define A4XX_RBBM_PERFCTR_SP_0_HI		0x125
-#define A4XX_RBBM_PERFCTR_SP_1_LO		0x126
-#define A4XX_RBBM_PERFCTR_SP_1_HI		0x127
-#define A4XX_RBBM_PERFCTR_SP_2_LO		0x128
-#define A4XX_RBBM_PERFCTR_SP_2_HI		0x129
-#define A4XX_RBBM_PERFCTR_SP_3_LO		0x12a
-#define A4XX_RBBM_PERFCTR_SP_3_HI		0x12b
-#define A4XX_RBBM_PERFCTR_SP_4_LO		0x12c
-#define A4XX_RBBM_PERFCTR_SP_4_HI		0x12d
-#define A4XX_RBBM_PERFCTR_SP_5_LO		0x12e
-#define A4XX_RBBM_PERFCTR_SP_5_HI		0x12f
-#define A4XX_RBBM_PERFCTR_SP_6_LO		0x130
-#define A4XX_RBBM_PERFCTR_SP_6_HI		0x131
-#define A4XX_RBBM_PERFCTR_SP_7_LO		0x132
-#define A4XX_RBBM_PERFCTR_SP_7_HI		0x133
-#define A4XX_RBBM_PERFCTR_SP_8_LO		0x134
-#define A4XX_RBBM_PERFCTR_SP_8_HI		0x135
-#define A4XX_RBBM_PERFCTR_SP_9_LO		0x136
-#define A4XX_RBBM_PERFCTR_SP_9_HI		0x137
-#define A4XX_RBBM_PERFCTR_SP_10_LO		0x138
-#define A4XX_RBBM_PERFCTR_SP_10_HI		0x139
-#define A4XX_RBBM_PERFCTR_SP_11_LO		0x13a
-#define A4XX_RBBM_PERFCTR_SP_11_HI		0x13b
-#define A4XX_RBBM_PERFCTR_RB_0_LO		0x13c
-#define A4XX_RBBM_PERFCTR_RB_0_HI		0x13d
-#define A4XX_RBBM_PERFCTR_RB_1_LO		0x13e
-#define A4XX_RBBM_PERFCTR_RB_1_HI		0x13f
-#define A4XX_RBBM_PERFCTR_RB_2_LO		0x140
-#define A4XX_RBBM_PERFCTR_RB_2_HI		0x141
-#define A4XX_RBBM_PERFCTR_RB_3_LO		0x142
-#define A4XX_RBBM_PERFCTR_RB_3_HI		0x143
-#define A4XX_RBBM_PERFCTR_RB_4_LO		0x144
-#define A4XX_RBBM_PERFCTR_RB_4_HI		0x145
-#define A4XX_RBBM_PERFCTR_RB_5_LO		0x146
-#define A4XX_RBBM_PERFCTR_RB_5_HI		0x147
-#define A4XX_RBBM_PERFCTR_RB_6_LO		0x148
-#define A4XX_RBBM_PERFCTR_RB_6_HI		0x149
-#define A4XX_RBBM_PERFCTR_RB_7_LO		0x14a
-#define A4XX_RBBM_PERFCTR_RB_7_HI		0x14b
-#define A4XX_RBBM_PERFCTR_VSC_0_LO		0x14c
-#define A4XX_RBBM_PERFCTR_VSC_0_HI		0x14d
-#define A4XX_RBBM_PERFCTR_VSC_1_LO		0x14e
-#define A4XX_RBBM_PERFCTR_VSC_1_HI		0x14f
-#define A4XX_RBBM_PERFCTR_PWR_0_LO		0x166
-#define A4XX_RBBM_PERFCTR_PWR_0_HI		0x167
-#define A4XX_RBBM_PERFCTR_PWR_1_LO		0x168
-#define A4XX_RBBM_PERFCTR_PWR_1_HI		0x169
-#define A4XX_RBBM_PERFCTR_CTL			0x170
-#define A4XX_RBBM_PERFCTR_LOAD_CMD0		0x171
-#define A4XX_RBBM_PERFCTR_LOAD_CMD1		0x172
-#define A4XX_RBBM_PERFCTR_LOAD_CMD2		0x173
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_0		0x176
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_1		0x177
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_2		0x178
-#define A4XX_RBBM_PERFCTR_RBBM_SEL_3		0x179
-#define A4XX_RBBM_GPU_BUSY_MASKED		0x17a
-#define A4XX_RBBM_INT_0_STATUS			0x17d
-#define A4XX_RBBM_AHB_ERROR_STATUS		0x18f
-#define A4XX_RBBM_STATUS			0x191
-#define A4XX_RBBM_CFG_COUNTER0			0x1a2
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF0		0x1a9
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF1		0x1aa
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF2		0x1ab
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF3		0x1ac
-#define A4XX_RBBM_CFG_DEBBUS_TRACE_BUF4		0x1ad
-#define A4XX_RBBM_CFG_DEBBUS_MISR0		0x1ae
-#define A4XX_RBBM_CFG_DEBBUS_MISR1		0x1af
+#define A4XX_RBBM_INT_0_STATUS		0x17d
+#define A4XX_RBBM_PERFCTR_CTL		0x170
+#define A4XX_RBBM_PERFCTR_LOAD_CMD0	0x171
+#define A4XX_RBBM_PERFCTR_LOAD_CMD1	0x172
+#define A4XX_RBBM_PERFCTR_LOAD_CMD2	0x173
+#define A4XX_RBBM_GPU_BUSY_MASKED	0x17a
+#define A4XX_RBBM_PERFCTR_PWR_1_LO	0x168
 
 /* CP registers */
 #define A4XX_CP_SCRATCH_REG0		0x578
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.c	2014-09-21 01:02:11.000000000 +0000
@@ -17,6 +17,7 @@
 #include <linux/sched.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/msm_kgsl.h>
 #include <linux/delay.h>
 #include <linux/of_coresight.h>
 
@@ -161,12 +162,6 @@
 	unsigned int pfp_jt_idx;
 	/* PFP jump table load addr */
 	unsigned int pfp_jt_addr;
-	/* PM4 bootstrap loader size */
-	unsigned int pm4_bstrp_size;
-	/* PFP bootstrap loader size */
-	unsigned int pfp_bstrp_size;
-	/* PFP bootstrap loader supported version */
-	unsigned int pfp_bstrp_ver;
 
 } adreno_gpulist[] = {
 	{ ADRENO_REV_A200, 0, 2, ANY_ID, ANY_ID,
@@ -204,8 +199,7 @@
 		512, 0, 2, SZ_512K, 0x3FF037, 0x3FF016 },
 	{ ADRENO_REV_A330, 3, 3, 0, ANY_ID,
 		"a330_pm4.fw", "a330_pfp.fw", &adreno_a3xx_gpudev,
-		512, 0, 2, SZ_1M, NO_VER, NO_VER, 0x8AD, 0x2E4, 0x201, 0x200,
-		0x6, 0x20, 0x330020 },
+		512, 0, 2, SZ_1M, NO_VER, NO_VER, 0x8AD, 0x2E4, 0x201, 0x200 },
 	{ ADRENO_REV_A305B, 3, 0, 5, 0x10,
 		"a330_pm4.fw", "a330_pfp.fw", &adreno_a3xx_gpudev,
 		512, 0, 2, SZ_128K, NO_VER, NO_VER, 0x8AD, 0x2E4,
@@ -425,29 +419,12 @@
 	return 0;
 }
 
-static inline void refcount_group(struct adreno_perfcount_group *group,
-	unsigned int reg, unsigned int flags,
-	unsigned int *lo, unsigned int *hi)
-{
-	if (flags & PERFCOUNTER_FLAG_KERNEL)
-		group->regs[reg].kernelcount++;
-	else
-		group->regs[reg].usercount++;
-
-	if (lo)
-		*lo = group->regs[reg].offset;
-
-	if (hi)
-		*hi = group->regs[reg].offset_hi;
-}
-
 /**
  * adreno_perfcounter_get: Try to put a countable in an available counter
  * @adreno_dev: Adreno device to configure
  * @groupid: Desired performance counter group
  * @countable: Countable desired to be in a counter
- * @offset: Return offset of the LO counter assigned
- * @offset_hi: Return offset of the HI counter assigned
+ * @offset: Return offset of the countable
  * @flags: Used to setup kernel perf counters
  *
  * Try to place a countable in an available counter.  If the countable is
@@ -457,7 +434,7 @@
 
 int adreno_perfcounter_get(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int *offset,
-	unsigned int *offset_hi, unsigned int flags)
+	unsigned int flags)
 {
 	struct adreno_perfcounters *counters = adreno_dev->gpudev->perfcounters;
 	struct adreno_perfcount_group *group;
@@ -467,8 +444,6 @@
 	/* always clear return variables */
 	if (offset)
 		*offset = 0;
-	if (offset_hi)
-		*offset_hi = 0;
 
 	if (NULL == counters)
 		return -EINVAL;
@@ -480,16 +455,22 @@
 
 	/*
 	 * Check if the countable is already associated with a counter.
-	 * Refcount and return the offset, otherwise, try and find an
-	 * empty counter and assign the countable to it.
+	 * Refcount and return the offset, otherwise, try and find an empty
+	 * counter and assign the countable to it.
 	 */
-
 	for (i = 0; i < group->reg_count; i++) {
 		if (group->regs[i].countable == countable) {
-			refcount_group(group, i, flags, offset, offset_hi);
+			/* Countable already associated with counter */
+			if (flags & PERFCOUNTER_FLAG_KERNEL)
+				group->regs[i].kernelcount++;
+			else
+				group->regs[i].usercount++;
+
+			if (offset)
+				*offset = group->regs[i].offset;
 			return 0;
 		} else if (group->regs[i].countable ==
-					KGSL_PERFCOUNTER_NOT_USED) {
+			KGSL_PERFCOUNTER_NOT_USED) {
 			/* keep track of unused counter */
 			empty = i;
 		}
@@ -518,8 +499,6 @@
 
 	if (offset)
 		*offset = group->regs[empty].offset;
-	if (offset_hi)
-		*offset_hi = group->regs[empty].offset_hi;
 
 	return ret;
 }
@@ -595,6 +574,8 @@
 
 	kgsl_mmu_unmap(pagetable, &rb->buffer_desc);
 
+	kgsl_mmu_unmap(pagetable, &rb->memptrs_desc);
+
 	kgsl_mmu_unmap(pagetable, &device->memstore);
 
 	kgsl_mmu_unmap(pagetable, &adreno_dev->pwron_fixup);
@@ -611,11 +592,8 @@
 
 	result = kgsl_mmu_map_global(pagetable, &rb->buffer_desc);
 
-	/*
-	 * ALERT: Order of these mapping is important to
-	 * Keep the most used entries like memstore
-	 * and mmu setstate memory by TLB prefetcher.
-	 */
+	if (!result)
+		result = kgsl_mmu_map_global(pagetable, &rb->memptrs_desc);
 
 	if (!result)
 		result = kgsl_mmu_map_global(pagetable, &device->memstore);
@@ -884,7 +862,9 @@
 					uint32_t flags)
 {
 	phys_addr_t pt_val;
-	unsigned int *link, *cmds;
+	unsigned int link[230];
+	unsigned int *cmds = &link[0];
+	int sizedwords = 0;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int num_iommu_units;
 	struct kgsl_context *context;
@@ -899,18 +879,17 @@
 	num_iommu_units = kgsl_mmu_get_num_iommu_units(&device->mmu);
 
 	context = kgsl_context_get(device, context_id);
-	if (context)
-		adreno_ctx = ADRENO_CONTEXT(context);
-
-	link = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (link == NULL) {
-		result = -ENOMEM;
-		goto done;
+	if (context == NULL) {
+		kgsl_mmu_device_setstate(&device->mmu, KGSL_CONTEXT_INVALID);
+		return -EINVAL;
 	}
 
-	cmds = link;
+	adreno_ctx = ADRENO_CONTEXT(context);
 
-	kgsl_mmu_enable_clk(&device->mmu, KGSL_IOMMU_MAX_UNITS);
+	result = kgsl_mmu_enable_clk(&device->mmu,
+				KGSL_IOMMU_CONTEXT_USER);
+	if (result)
+		goto done;
 
 	pt_val = kgsl_mmu_get_pt_base_addr(&device->mmu,
 				device->mmu.hwpagetable);
@@ -927,11 +906,17 @@
 		cmds += _adreno_iommu_setstate_v1(device, cmds, pt_val,
 						num_iommu_units, flags);
 
+	sizedwords += (cmds - &link[0]);
+	if (sizedwords == 0) {
+		KGSL_DRV_ERR(device, "no commands generated\n");
+		BUG();
+	}
 	/* invalidate all base pointers */
 	*cmds++ = cp_type3_packet(CP_INVALIDATE_STATE, 1);
 	*cmds++ = 0x7fff;
+	sizedwords += 2;
 
-	if ((unsigned int) (cmds - link) > (PAGE_SIZE / sizeof(unsigned int))) {
+	if (sizedwords > (sizeof(link)/sizeof(unsigned int))) {
 		KGSL_DRV_ERR(device, "Temp command buffer overflow\n");
 		BUG();
 	}
@@ -939,22 +924,13 @@
 	 * This returns the per context timestamp but we need to
 	 * use the global timestamp for iommu clock disablement
 	 */
-	result = adreno_ringbuffer_issuecmds(device, adreno_ctx,
-			KGSL_CMD_FLAGS_PMODE, link,
-			(unsigned int)(cmds - link));
+	adreno_ringbuffer_issuecmds(device, adreno_ctx, KGSL_CMD_FLAGS_PMODE,
+			&link[0], sizedwords);
 
-	/*
-	 * On error disable the IOMMU clock right away otherwise turn it off
-	 * after the command has been retired
-	 */
-	if (result)
-		kgsl_mmu_disable_clk(&device->mmu, KGSL_IOMMU_MAX_UNITS);
-	else
-		kgsl_mmu_disable_clk_on_ts(&device->mmu, rb->global_ts,
-						KGSL_IOMMU_MAX_UNITS);
+	kgsl_mmu_disable_clk_on_ts(&device->mmu,
+		rb->global_ts, true);
 
 done:
-	kfree(link);
 	kgsl_context_put(context);
 	return result;
 }
@@ -988,7 +964,6 @@
 		context = kgsl_context_get(device, context_id);
 		if (context == NULL)
 			return -EINVAL;
-
 		adreno_ctx = ADRENO_CONTEXT(context);
 
 		if (flags & KGSL_MMUFLAGS_PTUPDATE) {
@@ -1204,11 +1179,8 @@
 	adreno_dev->gmem_size = adreno_gpulist[i].gmem_size;
 	adreno_dev->pm4_jt_idx = adreno_gpulist[i].pm4_jt_idx;
 	adreno_dev->pm4_jt_addr = adreno_gpulist[i].pm4_jt_addr;
-	adreno_dev->pm4_bstrp_size = adreno_gpulist[i].pm4_bstrp_size;
 	adreno_dev->pfp_jt_idx = adreno_gpulist[i].pfp_jt_idx;
 	adreno_dev->pfp_jt_addr = adreno_gpulist[i].pfp_jt_addr;
-	adreno_dev->pfp_bstrp_size = adreno_gpulist[i].pfp_bstrp_size;
-	adreno_dev->pfp_bstrp_ver = adreno_gpulist[i].pfp_bstrp_ver;
 	adreno_dev->gpulist_index = i;
 	/*
 	 * Initialize uninitialzed gpu registers, only needs to be done once
@@ -1617,6 +1589,7 @@
 static int adreno_init(struct kgsl_device *device)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	struct adreno_ringbuffer *rb = &adreno_dev->ringbuffer;
 	int i;
 	int ret;
 
@@ -1664,6 +1637,8 @@
 		adreno_gpulist[adreno_dev->gpulist_index].sync_lock_pfp_ver))
 		device->mmu.flags |= KGSL_MMU_FLAGS_IOMMU_SYNC;
 
+	rb->global_ts = 0;
+
 	/* Initialize ft detection register offsets */
 	ft_detect_regs[0] = adreno_getreg(adreno_dev,
 						ADRENO_REG_RBBM_STATUS);
@@ -1692,6 +1667,7 @@
 	if (adreno_is_a330v2(adreno_dev))
 		adreno_a3xx_pwron_fixup_init(adreno_dev);
 
+	set_bit(ADRENO_DEVICE_INITIALIZED, &adreno_dev->priv);
 done:
 	return ret;
 }
@@ -1703,9 +1679,6 @@
 	unsigned int state = device->state;
 	unsigned int regulator_left_on = 0;
 
-	if (test_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv))
-		return 0;
-
 	kgsl_cffdump_open(device);
 
 	kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
@@ -1715,7 +1688,7 @@
 				regulator_is_enabled(device->pwrctrl.gpu_cx)));
 
 	/* Clear any GPU faults that might have been left over */
-	adreno_clear_gpu_fault(adreno_dev);
+	adreno_set_gpu_fault(adreno_dev, 0);
 
 	/* Power up the device */
 	kgsl_pwrctrl_enable(device);
@@ -1761,21 +1734,23 @@
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
 
-	adreno_perfcounter_start(adreno_dev);
-
-	status = adreno_ringbuffer_cold_start(&adreno_dev->ringbuffer);
+	status = adreno_ringbuffer_start(&adreno_dev->ringbuffer);
 	if (status)
 		goto error_irq_off;
 
+	status = adreno_perfcounter_start(adreno_dev);
+	if (status)
+		goto error_rb_stop;
+
 	/* Start the dispatcher */
 	adreno_dispatcher_start(device);
 
 	device->reset_counter++;
 
-	set_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
 	return 0;
 
+error_rb_stop:
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
 error_irq_off:
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
 
@@ -1790,44 +1765,19 @@
 	return status;
 }
 
-/**
- * adreno_vbif_clear_pending_transactions() - Clear transactions in VBIF pipe
- * @device: Pointer to the device whose VBIF pipe is to be cleared
- */
-static void adreno_vbif_clear_pending_transactions(struct kgsl_device *device)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int mask = A3XX_VBIF_XIN_HALT_CTRL0_MASK;
-	unsigned int val;
-	unsigned long wait_for_vbif;
-
-	adreno_writereg(adreno_dev, ADRENO_REG_VBIF_XIN_HALT_CTRL0, mask);
-	/* wait for the transactions to clear */
-	wait_for_vbif = jiffies + msecs_to_jiffies(100);
-	while (1) {
-		adreno_readreg(adreno_dev,
-			ADRENO_REG_VBIF_XIN_HALT_CTRL1, &val);
-		if ((val & mask) == mask)
-			break;
-		if (time_after(jiffies, wait_for_vbif))
-			break;
-	}
-	adreno_writereg(adreno_dev, ADRENO_REG_VBIF_XIN_HALT_CTRL0, 0);
-}
-
-
 static int adreno_stop(struct kgsl_device *device)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	if (!test_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv))
-		return 0;
-
-	kgsl_pwrctrl_enable(device);
+	if (adreno_dev->drawctxt_active)
+		kgsl_context_put(&adreno_dev->drawctxt_active->base);
 
 	adreno_dev->drawctxt_active = NULL;
 
 	adreno_dispatcher_stop(adreno_dev);
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
+
+	kgsl_mmu_stop(&device->mmu);
 
 	device->ftbl->irqctrl(device, 0);
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
@@ -1835,15 +1785,11 @@
 
 	adreno_ocmem_gmem_free(adreno_dev);
 
-	kgsl_mmu_stop(&device->mmu);
-
 	/* Power down the device */
 	kgsl_pwrctrl_disable(device);
 
 	kgsl_cffdump_close(device);
 
-	clear_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
 	return 0;
 }
 
@@ -1851,20 +1797,20 @@
  * adreno_reset() - Helper function to reset the GPU
  * @device: Pointer to the KGSL device structure for the GPU
  *
- * Try to reset the GPU to recover from a fault.  First, try to do a low latency
- * soft reset.  If the soft reset fails for some reason, then bring out the big
- * guns and toggle the footswitch.
+ * Helper function to reset the GPU hardware by toggling the footswitch
  */
 int adreno_reset(struct kgsl_device *device)
 {
 	int ret = -EINVAL;
+	struct kgsl_mmu *mmu = &device->mmu;
 	int i = 0;
 
-	/* clear pending vbif transactions before reset */
-	adreno_vbif_clear_pending_transactions(device);
-
-	/* Try soft reset first */
-	ret = adreno_soft_reset(device);
+	/* Try soft reset first, for non mmu fault case only */
+	if (!atomic_read(&mmu->fault)) {
+		ret = adreno_soft_reset(device);
+		if (ret)
+			KGSL_DEV_ERR_ONCE(device, "Device soft reset failed\n");
+	}
 	if (ret) {
 		/* If soft reset failed/skipped, then pull the power */
 		adreno_stop(device);
@@ -2255,70 +2201,12 @@
 	return status;
 }
 
-static int adreno_set_constraint(struct kgsl_device *device,
-				struct kgsl_context *context,
-				struct kgsl_device_constraint *constraint)
-{
-	int status = 0;
-
-	switch (constraint->type) {
-	case KGSL_CONSTRAINT_PWRLEVEL: {
-		struct kgsl_device_constraint_pwrlevel pwr;
-
-		if (constraint->size != sizeof(pwr)) {
-			status = -EINVAL;
-			break;
-		}
-
-		if (copy_from_user(&pwr,
-				(void __user *)constraint->data,
-				sizeof(pwr))) {
-			status = -EFAULT;
-			break;
-		}
-		if (pwr.level >= KGSL_CONSTRAINT_PWR_MAXLEVELS) {
-			status = -EINVAL;
-			break;
-		}
-
-		context->pwr_constraint.type =
-				KGSL_CONSTRAINT_PWRLEVEL;
-		context->pwr_constraint.sub_type = pwr.level;
-		trace_kgsl_user_pwrlevel_constraint(device,
-			context->id,
-			context->pwr_constraint.type,
-			context->pwr_constraint.sub_type);
-		}
-		break;
-	case KGSL_CONSTRAINT_NONE:
-		if (context->pwr_constraint.type == KGSL_CONSTRAINT_PWRLEVEL)
-			trace_kgsl_user_pwrlevel_constraint(device,
-				context->id,
-				KGSL_CONSTRAINT_NONE,
-				context->pwr_constraint.sub_type);
-		context->pwr_constraint.type = KGSL_CONSTRAINT_NONE;
-		break;
-
-	default:
-		status = -EINVAL;
-		break;
-	}
-
-	/* If a new constraint has been set for a context, cancel the old one */
-	if ((status == 0) &&
-		(context->id == device->pwrctrl.constraint.owner_id))
-		device->pwrctrl.constraint.type = KGSL_CONSTRAINT_NONE;
-
-	return status;
-}
-
-static int adreno_setproperty(struct kgsl_device_private *dev_priv,
+static int adreno_setproperty(struct kgsl_device *device,
 				enum kgsl_property_type type,
 				void *value,
 				unsigned int sizebytes)
 {
 	int status = -EINVAL;
-	struct kgsl_device *device = dev_priv->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	switch (type) {
@@ -2335,7 +2223,6 @@
 			}
 
 			if (enable) {
-				device->pwrctrl.ctrl_flags = 0;
 				adreno_dev->fast_hang_detect = 1;
 				kgsl_pwrscale_enable(device);
 			} else {
@@ -2348,28 +2235,6 @@
 			status = 0;
 		}
 		break;
-	case KGSL_PROP_PWR_CONSTRAINT: {
-			struct kgsl_device_constraint constraint;
-			struct kgsl_context *context;
-
-			if (sizebytes != sizeof(constraint))
-				break;
-
-			if (copy_from_user(&constraint, value,
-				sizeof(constraint))) {
-				status = -EFAULT;
-				break;
-			}
-
-			context = kgsl_context_get_owner(dev_priv,
-							constraint.context_id);
-			if (context == NULL)
-				break;
-			status = adreno_set_constraint(device, context,
-								&constraint);
-			kgsl_context_put(context);
-		}
-		break;
 	default:
 		break;
 	}
@@ -2393,6 +2258,7 @@
 	if (adreno_dev->gpudev->irq_pending(adreno_dev))
 		return false;
 
+	/* Read the correct RBBM status for the GPU type */
 	adreno_readreg(adreno_dev, ADRENO_REG_RBBM_STATUS,
 		&reg_rbbm_status);
 
@@ -2425,19 +2291,17 @@
 		return -EINVAL;
 	}
 
-	clear_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-
-	if (adreno_dev->drawctxt_active)
-		kgsl_context_put(&adreno_dev->drawctxt_active->base);
-
 	adreno_dev->drawctxt_active = NULL;
 
+	/* Stop the ringbuffer */
+	adreno_ringbuffer_stop(&adreno_dev->ringbuffer);
+
 	if (kgsl_pwrctrl_isenabled(device))
 		device->ftbl->irqctrl(device, 0);
 
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_OFF);
 
-	adreno_clear_gpu_fault(adreno_dev);
+	adreno_set_gpu_fault(adreno_dev, 0);
 
 	/* Delete the idle timer */
 	del_timer_sync(&device->idle_timer);
@@ -2463,20 +2327,17 @@
 	if (adreno_dev->pm4_jt_idx)
 		ret = adreno_ringbuffer_warm_start(&adreno_dev->ringbuffer);
 	else
-		ret = adreno_ringbuffer_cold_start(&adreno_dev->ringbuffer);
+		ret = adreno_ringbuffer_start(&adreno_dev->ringbuffer);
 
 	if (ret)
 		return ret;
-	else {
-		device->reset_counter++;
-		set_bit(ADRENO_DEVICE_STARTED, &adreno_dev->priv);
-	}
 
+	device->reset_counter++;
 
 	return 0;
 }
 
-/*
+/**
  * adreno_isidle() - return true if the GPU hardware is idle
  * @device: Pointer to the KGSL device structure for the GPU
  *
@@ -2488,7 +2349,8 @@
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	unsigned int rptr;
 
-	if (!kgsl_pwrctrl_isenabled(device))
+	/* If the device isn't active, don't force it on. */
+	if (device->state != KGSL_STATE_ACTIVE)
 		return true;
 
 	rptr = adreno_get_rptr(&adreno_dev->ringbuffer);
@@ -2521,7 +2383,7 @@
 	if (adreno_is_a3xx(adreno_dev) || adreno_is_a4xx(adreno_dev))
 		kgsl_cffdump_regpoll(device,
 			adreno_getreg(adreno_dev, ADRENO_REG_RBBM_STATUS) << 2,
-			0x00000000, 0x80000000);
+		        0x00000000, 0x80000000);
 	else
 		kgsl_cffdump_regpoll(device,
 			adreno_getreg(adreno_dev, ADRENO_REG_RBBM_STATUS) << 2,
@@ -2637,6 +2499,9 @@
 	if (kgsl_gpuaddr_in_memdesc(&ringbuffer->buffer_desc, gpuaddr, size))
 		return &ringbuffer->buffer_desc;
 
+	if (kgsl_gpuaddr_in_memdesc(&ringbuffer->memptrs_desc, gpuaddr, size))
+		return &ringbuffer->memptrs_desc;
+
 	if (kgsl_gpuaddr_in_memdesc(&device->memstore, gpuaddr, size))
 		return &device->memstore;
 
@@ -2753,6 +2618,143 @@
 	__raw_writel(value, reg);
 }
 
+
+static unsigned int _get_context_id(struct kgsl_context *k_ctxt)
+{
+	unsigned int context_id = KGSL_MEMSTORE_GLOBAL;
+
+	if (k_ctxt != NULL) {
+		struct adreno_context *a_ctxt = ADRENO_CONTEXT(k_ctxt);
+		if (kgsl_context_detached(k_ctxt))
+			context_id = KGSL_CONTEXT_INVALID;
+		else if (a_ctxt->flags & CTXT_FLAGS_PER_CONTEXT_TS)
+			context_id = k_ctxt->id;
+	}
+
+	return context_id;
+}
+static unsigned int adreno_check_hw_ts(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	int status = 0;
+	unsigned int ref_ts, enableflag;
+	unsigned int context_id = _get_context_id(context);
+
+	/*
+	 * If the context ID is invalid, we are in a race with
+	 * the context being destroyed by userspace so bail.
+	 */
+	if (context_id == KGSL_CONTEXT_INVALID) {
+		KGSL_DRV_WARN(device, "context was detached");
+		return -EINVAL;
+	}
+
+	status = kgsl_check_timestamp(device, context, timestamp);
+	if (status)
+		return status;
+
+	kgsl_sharedmem_readl(&device->memstore, &enableflag,
+			KGSL_MEMSTORE_OFFSET(context_id, ts_cmp_enable));
+	/*
+	 * Barrier is needed here to make sure the read from memstore
+	 * has posted
+	 */
+
+	mb();
+
+	if (enableflag) {
+		kgsl_sharedmem_readl(&device->memstore, &ref_ts,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ref_wait_ts));
+
+		/* Make sure the memstore read has posted */
+		mb();
+		if (timestamp_cmp(ref_ts, timestamp) >= 0) {
+			kgsl_sharedmem_writel(device, &device->memstore,
+					KGSL_MEMSTORE_OFFSET(context_id,
+						ref_wait_ts), timestamp);
+			/* Make sure the memstore write is posted */
+			wmb();
+		}
+	} else {
+		kgsl_sharedmem_writel(device, &device->memstore,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ref_wait_ts), timestamp);
+		enableflag = 1;
+		kgsl_sharedmem_writel(device, &device->memstore,
+				KGSL_MEMSTORE_OFFSET(context_id,
+					ts_cmp_enable), enableflag);
+
+		/* Make sure the memstore write gets posted */
+		wmb();
+
+		/*
+		 * submit a dummy packet so that even if all
+		 * commands upto timestamp get executed we will still
+		 * get an interrupt
+		 */
+
+		if (context && device->state != KGSL_STATE_SLUMBER) {
+			adreno_ringbuffer_issuecmds(device,
+					ADRENO_CONTEXT(context),
+					KGSL_CMD_FLAGS_GET_INT, NULL, 0);
+		}
+	}
+
+	return 0;
+}
+static int _check_pending_timestamp(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	unsigned int context_id = _get_context_id(context);
+	unsigned int ts_issued;
+
+	if (context_id == KGSL_CONTEXT_INVALID)
+		return -EINVAL;
+
+	ts_issued = adreno_dev->ringbuffer.timestamp[context_id];
+
+	if (timestamp_cmp(timestamp, ts_issued) <= 0)
+		return 0;
+
+	if (context && !context->wait_on_invalid_ts) {
+		KGSL_DRV_ERR(device, "Cannot wait for invalid ts <%d:0x%x>, last issued ts <%d:0x%x>\n",
+			context_id, timestamp, context_id, ts_issued);
+
+			/* Only print this message once */
+			context->wait_on_invalid_ts = true;
+	}
+
+	return -EINVAL;
+}
+
+/*
+ wait_event_interruptible_timeout checks for the exit condition before
+ placing a process in wait q. For conditional interrupts we expect the
+ process to already be in its wait q when its exit condition checking
+ function is called.
+*/
+#define kgsl_wait_event_interruptible_timeout(wq, condition, timeout, io)\
+({									\
+	long __ret = timeout;						\
+	if (io)						\
+		__wait_io_event_interruptible_timeout(wq, condition, __ret);\
+	else						\
+		__wait_event_interruptible_timeout(wq, condition, __ret);\
+	__ret;								\
+})
+static int adreno_check_interrupt_timestamp(struct kgsl_device *device,
+		struct kgsl_context *context, unsigned int timestamp)
+{
+	int status;
+
+	mutex_lock(&device->mutex);
+	status = adreno_check_hw_ts(device, context, timestamp);
+	mutex_unlock(&device->mutex);
+
+	return status;
+}
 /**
  * adreno_waittimestamp - sleep while waiting for the specified timestamp
  * @device - pointer to a KGSL device structure
@@ -2767,37 +2769,137 @@
 		unsigned int timestamp,
 		unsigned int msecs)
 {
-	int ret;
-	struct adreno_context *drawctxt;
+    
+	static unsigned int io_cnt;
+	struct adreno_context *adreno_ctx = context ? ADRENO_CONTEXT(context) :
+		NULL;
+	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
+	unsigned int context_id = _get_context_id(context);
+	unsigned int time_elapsed = 0;
+	unsigned int wait;
+	int ts_compare = 1;
+	int io, ret = -ETIMEDOUT;
 
-	if (context == NULL) {
-		/* If they are doing then complain once */
-		dev_WARN_ONCE(device->dev, 1,
-			"IOCTL_KGSL_DEVICE_WAITTIMESTAMP is deprecated\n");
-		return -ENOTTY;
-	}
+	/* Get out early if the context has already been destroyed */
 
-	/* Return -EINVAL if the context has been detached */
-	if (kgsl_context_detached(context))
+	if (context_id == KGSL_CONTEXT_INVALID) {
+		KGSL_DRV_WARN(device, "context was detached");
 		return -EINVAL;
+	}
 
-	ret = adreno_drawctxt_wait(ADRENO_DEVICE(device), context,
-		timestamp, msecs);
+	/*
+	 * Check to see if the requested timestamp is "newer" then the last
+	 * timestamp issued. If it is complain once and return error.  Only
+	 * print the message once per context so that badly behaving
+	 * applications don't spam the logs
+	 */
 
-	/* If the context got invalidated then return a specific error */
-	drawctxt = ADRENO_CONTEXT(context);
+	/* this is sort of crack.. it would be racy to check the ts and the
+	 * wait on it, and this check is pointless.. so just get rid of it:
+	if (adreno_ctx && !(adreno_ctx->flags & CTXT_FLAGS_USER_GENERATED_TS)) {
+		if (_check_pending_timestamp(device, context, timestamp))
+			return -EINVAL;
 
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID)
-		ret = -EDEADLK;
+		context->wait_on_invalid_ts = false;
+	}
+	 */
 
 	/*
-	 * Return -EPROTO if the device has faulted since the last time we
-	 * checked.  Userspace uses this as a marker for performing post
-	 * fault activities
+	 * On the first time through the loop only wait 100ms.
+	 * this gives enough time for the engine to start moving and oddly
+	 * provides better hang detection results than just going the full
+	 * KGSL_TIMEOUT_PART right off the bat. The exception to this rule
+	 * is if msecs happens to be < 100ms then just use the full timeout
 	 */
 
-	if (!ret && test_and_clear_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv))
-		ret = -EPROTO;
+	wait = 100;
+
+	do {
+		long status;
+
+		/*
+		 * if the timestamp happens while we're not
+		 * waiting, there's a chance that an interrupt
+		 * will not be generated and thus the timestamp
+		 * work needs to be queued.
+		 */
+
+		if (kgsl_check_timestamp(device, context, timestamp)) {
+			queue_work(device->work_queue, &device->ts_expired_ws);
+			ret = 0;
+			break;
+		}
+
+		/*
+		 * For proper power accounting sometimes we need to call
+		 * io_wait_interruptible_timeout and sometimes we need to call
+		 * plain old wait_interruptible_timeout. We call the regular
+		 * timeout N times out of 100, where N is a number specified by
+		 * the current power level
+		 */
+
+		io_cnt = (io_cnt + 1) % 100;
+		io = (io_cnt < pwr->pwrlevels[pwr->active_pwrlevel].io_fraction)
+			? 0 : 1;
+
+		mutex_unlock(&device->mutex);
+
+		/* Wait for a timestamp event */
+		status = kgsl_wait_event_interruptible_timeout(
+			device->wait_queue,
+			adreno_check_interrupt_timestamp(device, context,
+				timestamp), msecs_to_jiffies(wait), io);
+
+		mutex_lock(&device->mutex);
+
+		/*
+		 * If status is non zero then either the condition was satisfied
+		 * or there was an error.  In either event, this is the end of
+		 * the line for us
+		 */
+
+		if (status != 0) {
+			ret = (status > 0) ? 0 : (int) status;
+			break;
+		}
+		time_elapsed += wait;
+
+		/* If user specified timestamps are being used, wait at least
+		 * KGSL_SYNCOBJ_SERVER_TIMEOUT msecs for the user driver to
+		 * issue a IB for a timestamp before checking to see if the
+		 * current timestamp we are waiting for is valid or not
+		 */
+
+		if (ts_compare && (adreno_ctx &&
+			(adreno_ctx->flags & CTXT_FLAGS_USER_GENERATED_TS))) {
+			if (time_elapsed > KGSL_SYNCOBJ_SERVER_TIMEOUT) {
+				ret = _check_pending_timestamp(device, context,
+					timestamp);
+				if (ret)
+					break;
+
+				/* Don't do this check again */
+				ts_compare = 0;
+
+				/*
+				 * Reset the invalid timestamp flag on a valid
+				 * wait
+				 */
+				context->wait_on_invalid_ts = false;
+			}
+		}
+
+		/*
+		 * We want to wait the floor of KGSL_TIMEOUT_PART
+		 * and (msecs - time_elapsed).
+		 */
+
+		if (KGSL_TIMEOUT_PART < (msecs - time_elapsed))
+			wait = KGSL_TIMEOUT_PART;
+		else
+			wait = (msecs - time_elapsed);
+
+	} while (!msecs || time_elapsed < msecs);
 
 	return ret;
 }
@@ -2872,8 +2974,7 @@
 		if (result)
 			break;
 		result = adreno_perfcounter_get(adreno_dev, get->groupid,
-			get->countable, &get->offset, &get->offset_hi,
-			PERFCOUNTER_FLAG_NONE);
+			get->countable, &get->offset, PERFCOUNTER_FLAG_NONE);
 		kgsl_active_count_put(device);
 		break;
 	}
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,8 +19,6 @@
 #include "kgsl_iommu.h"
 #include <mach/ocmem.h>
 
-#include "a3xx_reg.h"
-
 #define DEVICE_3D_NAME "kgsl-3d"
 #define DEVICE_3D0_NAME "kgsl-3d0"
 
@@ -41,6 +39,7 @@
 #define KGSL_CMD_FLAGS_INTERNAL_ISSUE   BIT(1)
 #define KGSL_CMD_FLAGS_WFI              BIT(2)
 #define KGSL_CMD_FLAGS_PWRON_FIXUP      BIT(3)
+#define KGSL_CMD_FLAGS_GET_INT          BIT(4)
 
 /* Command identifiers */
 #define KGSL_CONTEXT_TO_MEM_IDENTIFIER	0x2EADBEEF
@@ -60,6 +59,7 @@
 #define ADRENO_DEFAULT_PWRSCALE_POLICY  NULL
 #endif
 
+void adreno_debugfs_init(struct kgsl_device *device);
 
 #define ADRENO_ISTORE_START 0x5000 /* Istore offset */
 
@@ -169,11 +169,8 @@
 	unsigned int wait_timeout;
 	unsigned int pm4_jt_idx;
 	unsigned int pm4_jt_addr;
-	unsigned int pm4_bstrp_size;
 	unsigned int pfp_jt_idx;
 	unsigned int pfp_jt_addr;
-	unsigned int pfp_bstrp_size;
-	unsigned int pfp_bstrp_ver;
 	unsigned int istore_size;
 	unsigned int pix_shader_start;
 	unsigned int instruction_size;
@@ -203,7 +200,6 @@
 	ADRENO_DEVICE_PWRON = 0,
 	ADRENO_DEVICE_PWRON_FIXUP = 1,
 	ADRENO_DEVICE_INITIALIZED = 2,
-	ADRENO_DEVICE_STARTED = 3,
 };
 
 #define PERFCOUNTER_FLAG_NONE 0x0
@@ -225,7 +221,6 @@
 	unsigned int kernelcount;
 	unsigned int usercount;
 	unsigned int offset;
-	unsigned int offset_hi;
 	int load_bit;
 	unsigned int select;
 };
@@ -313,9 +308,6 @@
 	ADRENO_REG_TC_CNTL_STATUS,
 	ADRENO_REG_TP0_CHICKEN,
 	ADRENO_REG_RBBM_RBBM_CTL,
-	ADRENO_REG_UCHE_INVALIDATE0,
-	ADRENO_REG_VBIF_XIN_HALT_CTRL0,
-	ADRENO_REG_VBIF_XIN_HALT_CTRL1,
 	ADRENO_REG_REGISTER_MAX,
 };
 
@@ -385,8 +377,8 @@
 	void (*coresight_disable) (struct kgsl_device *device);
 	void (*coresight_config_debug_reg) (struct kgsl_device *device,
 			int debug_reg, unsigned int val);
-	void (*soft_reset)(struct adreno_device *device);
 	void (*postmortem_dump)(struct adreno_device *adreno_dev);
+	void (*soft_reset)(struct adreno_device *device);
 };
 
 #define FT_DETECT_REGS_COUNT 12
@@ -403,9 +395,7 @@
 #define  KGSL_FT_SKIPFRAME                3
 #define  KGSL_FT_DISABLE                  4
 #define  KGSL_FT_TEMP_DISABLE             5
-#define  KGSL_FT_THROTTLE                 6
-#define  KGSL_FT_DEFAULT_POLICY (BIT(KGSL_FT_REPLAY) + BIT(KGSL_FT_SKIPIB) \
-				+ BIT(KGSL_FT_THROTTLE))
+#define  KGSL_FT_DEFAULT_POLICY (BIT(KGSL_FT_REPLAY) + BIT(KGSL_FT_SKIPIB))
 
 /* This internal bit is used to skip the PM dump on replayed command batches */
 #define  KGSL_FT_SKIP_PMDUMP              31
@@ -423,8 +413,15 @@
 	{ BIT(KGSL_FT_SKIPIB), "skipib" }, \
 	{ BIT(KGSL_FT_SKIPFRAME), "skipframe" }, \
 	{ BIT(KGSL_FT_DISABLE), "disable" }, \
-	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }, \
-	{ BIT(KGSL_FT_THROTTLE), "throttle"}
+	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }
+
+#define ADRENO_FT_TYPES \
+	{ BIT(KGSL_FT_OFF), "off" }, \
+	{ BIT(KGSL_FT_REPLAY), "replay" }, \
+	{ BIT(KGSL_FT_SKIPIB), "skipib" }, \
+	{ BIT(KGSL_FT_SKIPFRAME), "skipframe" }, \
+	{ BIT(KGSL_FT_DISABLE), "disable" }, \
+	{ BIT(KGSL_FT_TEMP_DISABLE), "temp" }
 
 extern struct adreno_gpudev adreno_a2xx_gpudev;
 extern struct adreno_gpudev adreno_a3xx_gpudev;
@@ -512,7 +509,7 @@
 
 int adreno_perfcounter_get(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int *offset,
-	unsigned int *offset_hi, unsigned int flags);
+	unsigned int flags);
 
 int adreno_perfcounter_put(struct adreno_device *adreno_dev,
 	unsigned int groupid, unsigned int countable, unsigned int flags);
@@ -717,11 +714,6 @@
 	*cmds++ = val;
 	*cmds++ = 0xFFFFFFFF;
 	*cmds++ = 0xFFFFFFFF;
-
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += __adreno_add_idle_indirect_cmds(cmds, nop_gpuaddr);
 	return cmds - start;
 }
@@ -737,13 +729,13 @@
 	unsigned int *start = cmds;
 
 	*cmds++ = cp_type3_packet(CP_WAIT_FOR_IDLE, 1);
-	*cmds++ = 0;
+	*cmds++ = 0x00000000;
 
 	if ((adreno_dev->gpurev == ADRENO_REV_A305) ||
 		(adreno_dev->gpurev == ADRENO_REV_A305C) ||
 		(adreno_dev->gpurev == ADRENO_REV_A320)) {
 		*cmds++ = cp_type3_packet(CP_WAIT_FOR_ME, 1);
-		*cmds++ = 0;
+		*cmds++ = 0x00000000;
 	}
 
 	return cmds - start;
@@ -860,19 +852,6 @@
 	smp_wmb();
 }
 
-/**
- * adreno_clear_gpu_fault() - Clear the GPU fault register
- * @adreno_dev: A pointer to an adreno_device structure
- *
- * Clear the GPU fault status for the adreno device
- */
-
-static inline void adreno_clear_gpu_fault(struct adreno_device *adreno_dev)
-{
-	atomic_set(&adreno_dev->dispatcher.fault, 0);
-	smp_wmb();
-}
-
 /*
  * adreno_vbif_start() - Program VBIF registers, called in device start
  * @device: Pointer to device whose vbif data is to be programmed
@@ -901,75 +880,4 @@
 	}
 }
 
-#ifdef CONFIG_DEBUG_FS
-void adreno_debugfs_init(struct kgsl_device *device);
-#else
-static inline void adreno_debugfs_init(struct kgsl_device *device) { }
-#endif
-
-/*
- * adreno_bootstrap_ucode() - Checks if Ucode bootstrapping is supported
- * @adreno_dev:		Pointer to the the adreno device
- */
-static inline int adreno_bootstrap_ucode(struct adreno_device *adreno_dev)
-{
-	if ((adreno_dev->pfp_bstrp_size) && (adreno_dev->pm4_bstrp_size)
-		&& (adreno_dev->pfp_fw_version >= adreno_dev->pfp_bstrp_ver))
-		return 1;
-	else
-		return 0;
-}
-
-/**
- * adreno_get_rptr() - Get the current ringbuffer read pointer
- * @rb: Pointer the ringbuffer to query
- *
- * Get the current read pointer from the GPU register.
- */
-static inline unsigned int
-adreno_get_rptr(struct adreno_ringbuffer *rb)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
-	unsigned int result;
-	adreno_readreg(adreno_dev, ADRENO_REG_CP_RB_RPTR, &result);
-	return result;
-}
-/**
- * adreno_set_protected_registers() - Protect the specified range of registers
- * from being accessed by the GPU
- * @device: pointer to the KGSL device
- * @index: Pointer to the index of the protect mode register to write to
- * @reg: Starting dword register to write
- * @mask_len: Size of the mask to protect (# of registers = 2 ** mask_len)
- *
- * Add the range of registers to the list of protected mode registers that will
- * cause an exception if the GPU accesses them.  There are 16 available
- * protected mode registers.  Index is used to specify which register to write
- * to - the intent is to call this function multiple times with the same index
- * pointer for each range and the registers will be magically programmed in
- * incremental fashion
- */
-static inline void adreno_set_protected_registers(struct kgsl_device *device,
-	unsigned int *index, unsigned int reg, int mask_len)
-{
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int val;
-
-	/* This function is only for adreno A3XX and beyond */
-	BUG_ON(adreno_is_a2xx(adreno_dev));
-
-	/* There are only 16 registers available */
-	BUG_ON(*index >= 16);
-
-	val = 0x60000000 | ((mask_len & 0x1F) << 24) | ((reg << 2) & 0x1FFFF);
-
-	/*
-	 * Write the protection range to the next available protection
-	 * register
-	 */
-
-	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_0 + *index, val);
-	*index = *index + 1;
-}
-
 #endif /*__ADRENO_H */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a2xx.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a2xx.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a2xx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a2xx.c	2014-09-21 01:02:11.000000000 +0000
@@ -655,7 +655,7 @@
 	unsigned int addr = shadow->gmemshadow.gpuaddr;
 	unsigned int offset = (addr - (addr & 0xfffff000)) / bytesperpixel;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Store TP0_CHICKEN register */
 		*cmds++ = cp_type3_packet(CP_REG_TO_MEM, 2);
 		*cmds++ = REG_TP0_CHICKEN;
@@ -864,7 +864,7 @@
 	unsigned int *cmds = shadow->gmem_restore_commands;
 	unsigned int *start = cmds;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Store TP0_CHICKEN register */
 		*cmds++ = cp_type3_packet(CP_REG_TO_MEM, 2);
 		*cmds++ = REG_TP0_CHICKEN;
@@ -1334,6 +1334,8 @@
 static int a2xx_create_gpustate_shadow(struct adreno_device *adreno_dev,
 			struct adreno_context *drawctxt)
 {
+	drawctxt->flags |= CTXT_FLAGS_STATE_SHADOW;
+
 	/* build indirect command buffers to save & restore regs/constants */
 	build_regrestore_cmds(adreno_dev, drawctxt);
 	build_regsave_cmds(adreno_dev, drawctxt);
@@ -1352,14 +1354,16 @@
 	calc_gmemsize(&drawctxt->context_gmem_shadow, adreno_dev->gmem_size);
 	tmp_ctx.gmem_base = adreno_dev->gmem_base;
 
-	result = kgsl_allocate(&(adreno_dev->dev),
-		&drawctxt->context_gmem_shadow.gmemshadow,
+	result = kgsl_allocate(&drawctxt->context_gmem_shadow.gmemshadow,
 		drawctxt->base.proc_priv->pagetable,
 		drawctxt->context_gmem_shadow.size);
 
 	if (result)
 		return result;
 
+	/* set the gmem shadow flag for the context */
+	drawctxt->flags |= CTXT_FLAGS_GMEM_SHADOW;
+
 	/* blank out gmem shadow. */
 	kgsl_sharedmem_set(drawctxt->base.device,
 			&drawctxt->context_gmem_shadow.gmemshadow, 0, 0,
@@ -1370,7 +1374,7 @@
 		&tmp_ctx.cmd);
 
 	/* build TP0_CHICKEN register restore command buffer */
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE))
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE))
 		tmp_ctx.cmd = build_chicken_restore_cmds(drawctxt);
 
 	/* build indirect command buffers to save & restore gmem */
@@ -1433,8 +1437,8 @@
 {
 	int ret;
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE
-	   && drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC) {
+	if (drawctxt->flags & CTXT_FLAGS_PREAMBLE
+	   && drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC) {
 		drawctxt->ops = (adreno_is_a225(adreno_dev))
 			?  &a225_preamble_ctx_ops : &adreno_preamble_ctx_ops;
 
@@ -1451,7 +1455,7 @@
 	 * and texture and vertex buffer storage too
 	 */
 
-	ret = kgsl_allocate(&(adreno_dev->dev), &drawctxt->gpustate,
+	ret = kgsl_allocate(&drawctxt->gpustate,
 		drawctxt->base.proc_priv->pagetable, _context_size(adreno_dev));
 
 	if (ret)
@@ -1463,14 +1467,15 @@
 	tmp_ctx.cmd = tmp_ctx.start
 	    = (unsigned int *)((char *)drawctxt->gpustate.hostptr + CMD_OFFSET);
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = a2xx_create_gpustate_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
 
+		drawctxt->flags |= CTXT_FLAGS_SHADER_SAVE;
 	}
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC)) {
 		ret = a2xx_create_gmem_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
@@ -1550,7 +1555,7 @@
 	struct kgsl_device *device = &adreno_dev->dev;
 	int ret;
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->reg_save[1],
 			context->reg_save[2] << 2, true);
@@ -1562,7 +1567,7 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_SAVE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_SAVE) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_save[1],
@@ -1572,8 +1577,6 @@
 				KGSL_CMD_FLAGS_PMODE,
 				context->shader_save, 3);
 
-			if (ret)
-				return ret;
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_fixup[1],
@@ -1589,11 +1592,12 @@
 			if (ret)
 				return ret;
 
-			set_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv);
+			context->flags |= CTXT_FLAGS_SHADER_RESTORE;
 		}
 	}
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_SAVE, &context->priv)) {
+	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
+	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->context_gmem_shadow.gmem_save[1],
 			context->context_gmem_shadow.gmem_save[2] << 2, true);
@@ -1606,13 +1610,12 @@
 
 		if (ret)
 			return ret;
-
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->chicken_restore[1],
 			context->chicken_restore[2] << 2, true);
 
 		/* Restore TP0_CHICKEN */
-		if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->chicken_restore, 3);
@@ -1622,7 +1625,7 @@
 		}
 		adreno_dev->gpudev->ctx_switches_since_last_draw = 0;
 
-		set_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags |= CTXT_FLAGS_GMEM_RESTORE;
 	} else if (adreno_is_a2xx(adreno_dev))
 		return a2xx_drawctxt_draw_workaround(adreno_dev, context);
 
@@ -1643,7 +1646,7 @@
 	 *  restore gmem.
 	 *  (note: changes shader. shader must not already be restored.)
 	 */
-	if (test_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv)) {
+	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->context_gmem_shadow.gmem_restore[1],
 			context->context_gmem_shadow.gmem_restore[2] << 2,
@@ -1655,7 +1658,7 @@
 		if (ret)
 			return ret;
 
-		if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+		if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->chicken_restore[1],
@@ -1668,10 +1671,11 @@
 			if (ret)
 				return ret;
 		}
-		clear_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+
+		context->flags &= ~CTXT_FLAGS_GMEM_RESTORE;
 	}
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		kgsl_cffdump_syncmem(context->base.device, &context->gpustate,
 			context->reg_restore[1],
 			context->reg_restore[2] << 2, true);
@@ -1683,7 +1687,7 @@
 			return ret;
 
 		/* restore shader instructions & partitioning. */
-		if (test_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_RESTORE) {
 			kgsl_cffdump_syncmem(context->base.device,
 				&context->gpustate,
 				context->shader_restore[1],
@@ -2089,8 +2093,6 @@
 	kgsl_regwrite(device, REG_SQ_INT_CNTL, 0);
 
 	a2xx_gmeminit(adreno_dev);
-
-	kgsl_regwrite(device, REG_CP_DEBUG, A2XX_CP_DEBUG_DEFAULT);
 }
 
 static void a2xx_postmortem_dump(struct adreno_device *adreno_dev)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx.c	2014-09-21 01:02:11.000000000 +0000
@@ -2297,6 +2297,8 @@
 static int a3xx_create_gpustate_shadow(struct adreno_device *adreno_dev,
 				     struct adreno_context *drawctxt)
 {
+	drawctxt->flags |= CTXT_FLAGS_STATE_SHADOW;
+
 	build_regrestore_cmds(adreno_dev, drawctxt);
 	build_constantrestore_cmds(adreno_dev, drawctxt);
 	build_hlsqcontrol_restore_cmds(adreno_dev, drawctxt);
@@ -2318,8 +2320,7 @@
 	calc_gmemsize(&drawctxt->context_gmem_shadow, adreno_dev->gmem_size);
 	tmp_ctx.gmem_base = adreno_dev->gmem_base;
 
-	result = kgsl_allocate(&(adreno_dev->dev),
-		&drawctxt->context_gmem_shadow.gmemshadow,
+	result = kgsl_allocate(&drawctxt->context_gmem_shadow.gmemshadow,
 		drawctxt->base.proc_priv->pagetable,
 		drawctxt->context_gmem_shadow.size);
 
@@ -2337,6 +2338,8 @@
 	kgsl_cache_range_op(&drawctxt->context_gmem_shadow.gmemshadow,
 		KGSL_CACHE_OP_FLUSH);
 
+	drawctxt->flags |= CTXT_FLAGS_GMEM_SHADOW;
+
 	return 0;
 }
 
@@ -2368,14 +2371,14 @@
 	 * Nothing to do here if the context is using preambles and doesn't need
 	 * GMEM save/restore
 	 */
-	if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) &&
-		(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC)) {
+	if ((drawctxt->flags & CTXT_FLAGS_PREAMBLE) &&
+		(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC)) {
 		drawctxt->ops = &adreno_preamble_ctx_ops;
 		return 0;
 	}
 	drawctxt->ops = &a3xx_legacy_ctx_ops;
 
-	ret = kgsl_allocate(&(adreno_dev->dev), &drawctxt->gpustate,
+	ret = kgsl_allocate(&drawctxt->gpustate,
 		drawctxt->base.proc_priv->pagetable, CONTEXT_SIZE);
 
 	if (ret)
@@ -2385,15 +2388,15 @@
 			CONTEXT_SIZE);
 	tmp_ctx.cmd = drawctxt->gpustate.hostptr + CMD_OFFSET;
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(drawctxt->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = a3xx_create_gpustate_shadow(adreno_dev, drawctxt);
 		if (ret)
 			goto done;
 
-		set_bit(ADRENO_CONTEXT_SHADER_SAVE, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_SHADER_SAVE;
 	}
 
-	if (!(drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC))
+	if (!(drawctxt->flags & CTXT_FLAGS_NOGMEMALLOC))
 		ret = a3xx_create_gmem_shadow(adreno_dev, drawctxt);
 
 done:
@@ -2412,7 +2415,7 @@
 	if (context->state == ADRENO_CONTEXT_STATE_INVALID)
 		return 0;
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		/* Fixup self modifying IBs for save operations */
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE, context->save_fixup, 3);
@@ -2426,17 +2429,19 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_SAVE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_SAVE) {
 			/* Save shader instructions */
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_PMODE, context->shader_save, 3);
 			if (ret)
 				return ret;
-			set_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv);
+
+			context->flags |= CTXT_FLAGS_SHADER_RESTORE;
 		}
 	}
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_SAVE, &context->priv)) {
+	if ((context->flags & CTXT_FLAGS_GMEM_SAVE) &&
+	    (context->flags & CTXT_FLAGS_GMEM_SHADOW)) {
 		/*
 		 * Save GMEM (note: changes shader. shader must
 		 * already be saved.)
@@ -2454,7 +2459,7 @@
 		if (ret)
 			return ret;
 
-		set_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags |= CTXT_FLAGS_GMEM_RESTORE;
 	}
 
 	return 0;
@@ -2476,7 +2481,7 @@
 	 * Shader must not already be restored.)
 	 */
 
-	if (test_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv)) {
+	if (context->flags & CTXT_FLAGS_GMEM_RESTORE) {
 		kgsl_cffdump_syncmem(context->base.device,
 			&context->gpustate,
 			context->context_gmem_shadow.gmem_restore[1],
@@ -2489,10 +2494,10 @@
 					    gmem_restore, 3);
 		if (ret)
 			return ret;
-		clear_bit(ADRENO_CONTEXT_GMEM_RESTORE, &context->priv);
+		context->flags &= ~CTXT_FLAGS_GMEM_RESTORE;
 	}
 
-	if (!(context->base.flags & KGSL_CONTEXT_PREAMBLE)) {
+	if (!(context->flags & CTXT_FLAGS_PREAMBLE)) {
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE, context->reg_restore, 3);
 		if (ret)
@@ -2511,13 +2516,12 @@
 		if (ret)
 			return ret;
 
-		if (test_bit(ADRENO_CONTEXT_SHADER_RESTORE, &context->priv)) {
+		if (context->flags & CTXT_FLAGS_SHADER_RESTORE)
 			ret = adreno_ringbuffer_issuecmds(device, context,
 				KGSL_CMD_FLAGS_NONE,
 				context->shader_restore, 3);
 			if (ret)
 				return ret;
-		}
 		/* Restore HLSQ_CONTROL_0 register */
 		ret = adreno_ringbuffer_issuecmds(device, context,
 			KGSL_CMD_FLAGS_NONE,
@@ -3033,10 +3037,8 @@
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000001);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
-
-	/* Enable protected mode registers for A3XX */
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x20000000);
-
+	/* Protected mode control - turned off for A3XX/A4XX */
+	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, 0x00000000);
 
@@ -3098,16 +3100,9 @@
 	case A3XX_INT_CP_HW_FAULT:
 		err = "ringbuffer hardware fault";
 		break;
-	case A3XX_INT_CP_REG_PROTECT_FAULT: {
-		unsigned int reg;
-		kgsl_regread(device, A3XX_CP_PROTECT_STATUS, &reg);
-
-		KGSL_DRV_CRIT(device,
-			"CP | Protected mode error| %s | addr=%x\n",
-			reg & (1 << 24) ? "WRITE" : "READ",
-			(reg & 0x1FFFF) >> 2);
-		goto done;
-	}
+	case A3XX_INT_CP_REG_PROTECT_FAULT:
+		err = "ringbuffer protected mode error interrupt";
+		break;
 	case A3XX_INT_CP_AHB_ERROR_HALT:
 		err = "ringbuffer AHB error interrupt";
 		break;
@@ -3142,6 +3137,7 @@
 
 	device->pwrctrl.irq_last = 1;
 	queue_work(device->work_queue, &device->ts_expired_ws);
+
 	adreno_dispatcher_schedule(device);
 }
 
@@ -3431,7 +3427,7 @@
 static struct {
 	void (*func)(struct adreno_device *, int);
 } a3xx_irq_funcs[] = {
-	A3XX_IRQ_CALLBACK(NULL), /* 0 - RBBM_GPU_IDLE */
+	A3XX_IRQ_CALLBACK(NULL),               /* 0 - RBBM_GPU_IDLE */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 1 - RBBM_AHB_ERROR */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 2 - RBBM_REG_TIMEOUT */
 	A3XX_IRQ_CALLBACK(a3xx_err_callback),  /* 3 - RBBM_ME_MS_TIMEOUT */
@@ -3683,158 +3679,141 @@
 
 static struct adreno_perfcount_register a3xx_perfcounters_cp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_CP_0_LO,
-		A3XX_RBBM_PERFCTR_CP_0_HI, 0, A3XX_CP_PERFCOUNTER_SELECT },
+		0, A3XX_CP_PERFCOUNTER_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_rbbm[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RBBM_0_LO,
-		A3XX_RBBM_PERFCTR_RBBM_0_HI, 1, A3XX_RBBM_PERFCOUNTER0_SELECT },
+		1, A3XX_RBBM_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RBBM_1_LO,
-		A3XX_RBBM_PERFCTR_RBBM_1_HI, 2, A3XX_RBBM_PERFCOUNTER1_SELECT },
+		2, A3XX_RBBM_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_pc[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_0_LO,
-		A3XX_RBBM_PERFCTR_PC_0_HI, 3, A3XX_PC_PERFCOUNTER0_SELECT },
+		3, A3XX_PC_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_1_LO,
-		A3XX_RBBM_PERFCTR_PC_1_HI, 4, A3XX_PC_PERFCOUNTER1_SELECT },
+		4, A3XX_PC_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_2_LO,
-		A3XX_RBBM_PERFCTR_PC_2_HI, 5, A3XX_PC_PERFCOUNTER2_SELECT },
+		5, A3XX_PC_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PC_3_LO,
-		A3XX_RBBM_PERFCTR_PC_3_HI, 6, A3XX_PC_PERFCOUNTER3_SELECT },
+		6, A3XX_PC_PERFCOUNTER3_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vfd[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VFD_0_LO,
-		A3XX_RBBM_PERFCTR_VFD_0_HI, 7, A3XX_VFD_PERFCOUNTER0_SELECT },
+		7, A3XX_VFD_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VFD_1_LO,
-		A3XX_RBBM_PERFCTR_VFD_1_HI, 8, A3XX_VFD_PERFCOUNTER1_SELECT },
+		8, A3XX_VFD_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_hlsq[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_0_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_0_HI, 9,
-		A3XX_HLSQ_PERFCOUNTER0_SELECT },
+		9, A3XX_HLSQ_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_1_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_1_HI, 10,
-		A3XX_HLSQ_PERFCOUNTER1_SELECT },
+		10, A3XX_HLSQ_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_2_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_2_HI, 11,
-		A3XX_HLSQ_PERFCOUNTER2_SELECT },
+		11, A3XX_HLSQ_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_3_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_3_HI, 12,
-		A3XX_HLSQ_PERFCOUNTER3_SELECT },
+		12, A3XX_HLSQ_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_4_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_4_HI, 13,
-		A3XX_HLSQ_PERFCOUNTER4_SELECT },
+		13, A3XX_HLSQ_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_HLSQ_5_LO,
-		A3XX_RBBM_PERFCTR_HLSQ_5_HI, 14,
-		A3XX_HLSQ_PERFCOUNTER5_SELECT },
+		14, A3XX_HLSQ_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vpc[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VPC_0_LO,
-		A3XX_RBBM_PERFCTR_VPC_0_HI, 15, A3XX_VPC_PERFCOUNTER0_SELECT },
+		15, A3XX_VPC_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_VPC_1_LO,
-		A3XX_RBBM_PERFCTR_VPC_1_HI, 16, A3XX_VPC_PERFCOUNTER1_SELECT },
+		16, A3XX_VPC_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_tse[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TSE_0_LO,
-		A3XX_RBBM_PERFCTR_TSE_0_HI, 17, A3XX_GRAS_PERFCOUNTER0_SELECT },
+		17, A3XX_GRAS_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TSE_1_LO,
-		A3XX_RBBM_PERFCTR_TSE_1_HI, 18, A3XX_GRAS_PERFCOUNTER1_SELECT },
+		18, A3XX_GRAS_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_ras[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RAS_0_LO,
-		A3XX_RBBM_PERFCTR_RAS_0_HI, 19, A3XX_GRAS_PERFCOUNTER2_SELECT },
+		19, A3XX_GRAS_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RAS_1_LO,
-		A3XX_RBBM_PERFCTR_RAS_1_HI, 20, A3XX_GRAS_PERFCOUNTER3_SELECT },
+		20, A3XX_GRAS_PERFCOUNTER3_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_uche[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_0_LO,
-		A3XX_RBBM_PERFCTR_UCHE_0_HI, 21,
-		A3XX_UCHE_PERFCOUNTER0_SELECT },
+		21, A3XX_UCHE_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_1_LO,
-		A3XX_RBBM_PERFCTR_UCHE_1_HI, 22,
-		A3XX_UCHE_PERFCOUNTER1_SELECT },
+		22, A3XX_UCHE_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_2_LO,
-		A3XX_RBBM_PERFCTR_UCHE_2_HI, 23,
-		A3XX_UCHE_PERFCOUNTER2_SELECT },
+		23, A3XX_UCHE_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_3_LO,
-		A3XX_RBBM_PERFCTR_UCHE_3_HI, 24,
-		A3XX_UCHE_PERFCOUNTER3_SELECT },
+		24, A3XX_UCHE_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_4_LO,
-		A3XX_RBBM_PERFCTR_UCHE_4_HI, 25,
-		A3XX_UCHE_PERFCOUNTER4_SELECT },
+		25, A3XX_UCHE_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_UCHE_5_LO,
-		A3XX_RBBM_PERFCTR_UCHE_5_HI, 26,
-		A3XX_UCHE_PERFCOUNTER5_SELECT },
+		26, A3XX_UCHE_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_tp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_0_LO,
-		A3XX_RBBM_PERFCTR_TP_0_HI, 27, A3XX_TP_PERFCOUNTER0_SELECT },
+		27, A3XX_TP_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_1_LO,
-		A3XX_RBBM_PERFCTR_TP_1_HI, 28, A3XX_TP_PERFCOUNTER1_SELECT },
+		28, A3XX_TP_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_2_LO,
-		A3XX_RBBM_PERFCTR_TP_2_HI, 29, A3XX_TP_PERFCOUNTER2_SELECT },
+		29, A3XX_TP_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_3_LO,
-		A3XX_RBBM_PERFCTR_TP_3_HI, 30, A3XX_TP_PERFCOUNTER3_SELECT },
+		30, A3XX_TP_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_4_LO,
-		A3XX_RBBM_PERFCTR_TP_4_HI, 31, A3XX_TP_PERFCOUNTER4_SELECT },
+		31, A3XX_TP_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_TP_5_LO,
-		A3XX_RBBM_PERFCTR_TP_5_HI, 32, A3XX_TP_PERFCOUNTER5_SELECT },
+		32, A3XX_TP_PERFCOUNTER5_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_sp[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_0_LO,
-		A3XX_RBBM_PERFCTR_SP_0_HI, 33, A3XX_SP_PERFCOUNTER0_SELECT },
+		33, A3XX_SP_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_1_LO,
-		A3XX_RBBM_PERFCTR_SP_1_HI, 34, A3XX_SP_PERFCOUNTER1_SELECT },
+		34, A3XX_SP_PERFCOUNTER1_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_2_LO,
-		A3XX_RBBM_PERFCTR_SP_2_HI, 35, A3XX_SP_PERFCOUNTER2_SELECT },
+		35, A3XX_SP_PERFCOUNTER2_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_3_LO,
-		A3XX_RBBM_PERFCTR_SP_3_HI, 36, A3XX_SP_PERFCOUNTER3_SELECT },
+		36, A3XX_SP_PERFCOUNTER3_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_4_LO,
-		A3XX_RBBM_PERFCTR_SP_4_HI, 37, A3XX_SP_PERFCOUNTER4_SELECT },
+		37, A3XX_SP_PERFCOUNTER4_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_5_LO,
-		A3XX_RBBM_PERFCTR_SP_5_HI, 38, A3XX_SP_PERFCOUNTER5_SELECT },
+		38, A3XX_SP_PERFCOUNTER5_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_6_LO,
-		A3XX_RBBM_PERFCTR_SP_6_HI, 39, A3XX_SP_PERFCOUNTER6_SELECT },
+		39, A3XX_SP_PERFCOUNTER6_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_SP_7_LO,
-		A3XX_RBBM_PERFCTR_SP_7_HI, 40, A3XX_SP_PERFCOUNTER7_SELECT },
+		40, A3XX_SP_PERFCOUNTER7_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_rb[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RB_0_LO,
-		A3XX_RBBM_PERFCTR_RB_0_HI, 41, A3XX_RB_PERFCOUNTER0_SELECT },
+		41, A3XX_RB_PERFCOUNTER0_SELECT },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_RB_1_LO,
-		A3XX_RBBM_PERFCTR_RB_1_HI, 42, A3XX_RB_PERFCOUNTER1_SELECT },
+		42, A3XX_RB_PERFCOUNTER1_SELECT },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_pwr[] = {
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PWR_0_LO,
-		A3XX_RBBM_PERFCTR_PWR_0_HI, -1, 0 },
+		-1, 0 },
 	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_RBBM_PERFCTR_PWR_1_LO,
-		A3XX_RBBM_PERFCTR_PWR_1_HI, -1, 0 },
+		-1, 0 },
 };
 
 static struct adreno_perfcount_register a3xx_perfcounters_vbif[] = {
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT0_LO,
-		A3XX_VBIF_PERF_CNT0_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT1_LO,
-		A3XX_VBIF_PERF_CNT1_HI, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT0_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_CNT1_LO, -1, 0 },
 };
 static struct adreno_perfcount_register a3xx_perfcounters_vbif_pwr[] = {
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT0_LO,
-		A3XX_VBIF_PERF_PWR_CNT0_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT1_LO,
-		A3XX_VBIF_PERF_PWR_CNT1_HI, -1, 0 },
-	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT2_LO,
-		A3XX_VBIF_PERF_PWR_CNT2_HI, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT0_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT1_LO, -1, 0 },
+	{ KGSL_PERFCOUNTER_NOT_USED, 0, 0, A3XX_VBIF_PERF_PWR_CNT2_LO, -1, 0 },
 };
 
 static struct adreno_perfcount_group a3xx_perfcounter_groups[] = {
@@ -3900,43 +3879,35 @@
 	if (adreno_dev->fast_hang_detect) {
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP_ALU_ACTIVE_CYCLES,
-			&ft_detect_regs[6], &ft_detect_regs[7],
+			SP_ALU_ACTIVE_CYCLES, &ft_detect_regs[6],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[7] = ft_detect_regs[6] + 1;
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP0_ICL1_MISSES,
-			&ft_detect_regs[8], &ft_detect_regs[9],
+			SP0_ICL1_MISSES, &ft_detect_regs[8],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[9] = ft_detect_regs[8] + 1;
 		ret = adreno_perfcounter_get(adreno_dev,
 			KGSL_PERFCOUNTER_GROUP_SP,
-			SP_FS_CFLOW_INSTRUCTIONS,
-			&ft_detect_regs[10], &ft_detect_regs[11],
+			SP_FS_CFLOW_INSTRUCTIONS, &ft_detect_regs[10],
 			PERFCOUNTER_FLAG_KERNEL);
 		if (ret)
 			goto err;
+		ft_detect_regs[11] = ft_detect_regs[10] + 1;
 	}
 
 	ret = adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_SP,
-		SP_FS_FULL_ALU_INSTRUCTIONS, NULL, NULL,
-		PERFCOUNTER_FLAG_KERNEL);
+		SP_FS_FULL_ALU_INSTRUCTIONS, NULL, PERFCOUNTER_FLAG_KERNEL);
 	if (ret)
 		goto err;
 
 	/* Reserve and start countable 1 in the PWR perfcounter group */
 	ret = adreno_perfcounter_get(adreno_dev, KGSL_PERFCOUNTER_GROUP_PWR, 1,
-			NULL, NULL, PERFCOUNTER_FLAG_KERNEL);
-	if (ret)
-		goto err;
-
-	/* VBIF waiting for RAM */
-	ret = adreno_perfcounter_get(adreno_dev,
-				KGSL_PERFCOUNTER_GROUP_VBIF_PWR, 0,
-				NULL, NULL, PERFCOUNTER_FLAG_KERNEL);
+			NULL, PERFCOUNTER_FLAG_KERNEL);
 	if (ret)
 		goto err;
 
@@ -3955,36 +3926,29 @@
  */
 static void a3xx_protect_init(struct kgsl_device *device)
 {
-	int index = 0;
-
 	/* enable access protection to privileged registers */
 	kgsl_regwrite(device, A3XX_CP_PROTECT_CTRL, 0x00000007);
 
 	/* RBBM registers */
-	adreno_set_protected_registers(device, &index, 0x18, 0);
-	adreno_set_protected_registers(device, &index, 0x20, 2);
-	adreno_set_protected_registers(device, &index, 0x33, 0);
-	adreno_set_protected_registers(device, &index, 0x42, 0);
-	adreno_set_protected_registers(device, &index, 0x50, 4);
-	adreno_set_protected_registers(device, &index, 0x63, 0);
-	adreno_set_protected_registers(device, &index, 0x100, 4);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_0, 0x63000040);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_1, 0x62000080);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_2, 0x600000CC);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_3, 0x60000108);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_4, 0x64000140);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_5, 0x66000400);
 
 	/* CP registers */
-	adreno_set_protected_registers(device, &index, 0x1C0, 5);
-	adreno_set_protected_registers(device, &index, 0x1EC, 1);
-	adreno_set_protected_registers(device, &index, 0x1F6, 1);
-	adreno_set_protected_registers(device, &index, 0x1F8, 2);
-	adreno_set_protected_registers(device, &index, 0x45E, 2);
-	adreno_set_protected_registers(device, &index, 0x460, 4);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_6, 0x65000700);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_7, 0x610007D8);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_8, 0x620007E0);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_9, 0x61001178);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_A, 0x64001180);
 
 	/* RB registers */
-	adreno_set_protected_registers(device, &index, 0xCC0, 0);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_B, 0x60003300);
 
 	/* VBIF registers */
-	adreno_set_protected_registers(device, &index, 0x3000, 6);
-
-	/* SMMU registers */
-	adreno_set_protected_registers(device, &index, 0x4000, 14);
+	kgsl_regwrite(device, A3XX_CP_PROTECT_REG_C, 0x6B00C000);
 }
 
 static void a3xx_start(struct adreno_device *adreno_dev)
@@ -4047,9 +4011,6 @@
 	/* Turn on the GPU busy counter and let it run free */
 
 	adreno_dev->gpu_cycles = 0;
-
-	/* the CP_DEBUG register offset and value are same as A2XX */
-	kgsl_regwrite(device, REG_CP_DEBUG, A2XX_CP_DEBUG_DEFAULT);
 }
 
 /**
@@ -4405,12 +4366,6 @@
 	ADRENO_REG_DEFINE(ADRENO_REG_TC_CNTL_STATUS, REG_TC_CNTL_STATUS),
 	ADRENO_REG_DEFINE(ADRENO_REG_TP0_CHICKEN, REG_TP0_CHICKEN),
 	ADRENO_REG_DEFINE(ADRENO_REG_RBBM_RBBM_CTL, A3XX_RBBM_RBBM_CTL),
-	ADRENO_REG_DEFINE(ADRENO_REG_UCHE_INVALIDATE0,
-			A3XX_UCHE_CACHE_INVALIDATE0_REG),
-	ADRENO_REG_DEFINE(ADRENO_REG_VBIF_XIN_HALT_CTRL0,
-				A3XX_VBIF_XIN_HALT_CTRL0),
-	ADRENO_REG_DEFINE(ADRENO_REG_VBIF_XIN_HALT_CTRL1,
-				A3XX_VBIF_XIN_HALT_CTRL1),
 };
 
 const struct adreno_reg_offsets a3xx_reg_offsets = {
@@ -4437,6 +4392,6 @@
 	.coresight_enable = a3xx_coresight_enable,
 	.coresight_disable = a3xx_coresight_disable,
 	.coresight_config_debug_reg = a3xx_coresight_config_debug_reg,
-	.soft_reset = a3xx_soft_reset,
 	.postmortem_dump = a3xx_postmortem_dump,
+	.soft_reset = a3xx_soft_reset,
 };
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_snapshot.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_snapshot.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_snapshot.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_snapshot.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -277,6 +277,7 @@
 
 	struct kgsl_snapshot_debugbus *header = snapshot;
 	struct debugbus_block *block = priv;
+	unsigned int val;
 	int i;
 	unsigned int *data = snapshot + sizeof(*header);
 	unsigned int dwords;
@@ -299,6 +300,8 @@
 		return 0;
 	}
 
+	val = (block->block_id << 8) | (1 << 16);
+
 	header->id = block->block_id;
 	header->count = dwords;
 
@@ -492,22 +495,6 @@
 	/* Reading these will hang the GPU if it isn't already hung */
 
 	if (hang) {
-		unsigned int reg;
-
-		/*
-		 * Reading the microcode while the CP will is running will
-		 * basically basically move the CP instruction pointer to
-		 * whatever address we read. Big badaboom ensues. Stop the CP
-		 * (if it isn't already stopped) to ensure that we are safe.
-		 * We do this here and not earlier to avoid corrupting the RBBM
-		 * status and CP registers - by the time we get here we don't
-		 * care about the contents of the CP anymore.
-		 */
-
-		adreno_readreg(adreno_dev, ADRENO_REG_CP_ME_CNTL, &reg);
-		reg |= (1 << 27) | (1 << 28);
-		adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, reg);
-
 		snapshot = kgsl_snapshot_add_section(device,
 			KGSL_SNAPSHOT_SECTION_DEBUG, snapshot, remain,
 			a3xx_snapshot_cp_pfp_ram, NULL);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_a3xx_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_a3xx_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -48,7 +48,7 @@
 		"d_name=%s status=%s",
 		__get_str(device_name),
 		__entry->status ? __print_flags(__entry->status, "|",
-			{ 1 << A3XX_INT_RBBM_GPU_IDLE, "RBBM_GPU_IDLE" },
+			{ 1 << A3XX_INT_RBBM_AHB_ERROR, "RBBM_GPU_IDLE" },
 			{ 1 << A3XX_INT_RBBM_AHB_ERROR, "RBBM_AHB_ERR" },
 			{ 1 << A3XX_INT_RBBM_REG_TIMEOUT, "RBBM_REG_TIMEOUT" },
 			{ 1 << A3XX_INT_RBBM_ME_MS_TIMEOUT,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_debugfs.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_debugfs.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_debugfs.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,6 +23,8 @@
 
 #include "a2xx_reg.h"
 
+unsigned int kgsl_cff_dump_enable;
+
 DEFINE_SIMPLE_ATTRIBUTE(kgsl_cff_dump_enable_fops, kgsl_cff_dump_enable_get,
 			kgsl_cff_dump_enable_set, "%llu\n");
 
@@ -54,6 +56,41 @@
 		&adreno_dev->wait_timeout);
 	debugfs_create_u32("ib_check", 0644, device->d_debugfs,
 			   &adreno_dev->ib_check_level);
+	/* By Default enable fast hang detection */
+	adreno_dev->fast_hang_detect = 1;
+	debugfs_create_u32("fast_hang_detect", 0644, device->d_debugfs,
+			   &adreno_dev->fast_hang_detect);
+	/*
+	 * FT policy can be set to any of the options below.
+	 * KGSL_FT_OFF -> BIT(0) Set to turn off FT
+	 * KGSL_FT_REPLAY  -> BIT(1) Set to enable replay
+	 * KGSL_FT_SKIPIB  -> BIT(2) Set to skip IB
+	 * KGSL_FT_SKIPFRAME -> BIT(3) Set to skip frame
+	 * KGSL_FT_DISABLE -> BIT(4) Set to disable FT for faulting context
+	 * by default set FT policy to KGSL_FT_DEFAULT_POLICY
+	 */
+	adreno_dev->ft_policy = KGSL_FT_DEFAULT_POLICY;
+	debugfs_create_u32("ft_policy", 0644, device->d_debugfs,
+			   &adreno_dev->ft_policy);
+	/* By default enable long IB detection */
+	adreno_dev->long_ib_detect = 1;
+	debugfs_create_u32("long_ib_detect", 0644, device->d_debugfs,
+			   &adreno_dev->long_ib_detect);
+
+	/*
+	 * FT pagefault policy can be set to any of the options below.
+	 * KGSL_FT_PAGEFAULT_INT_ENABLE -> BIT(0) set to enable pagefault INT
+	 * KGSL_FT_PAGEFAULT_GPUHALT_ENABLE  -> BIT(1) Set to enable GPU HALT on
+	 * pagefaults. This stalls the GPU on a pagefault on IOMMU v1 HW.
+	 * KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE  -> BIT(2) Set to log only one
+	 * pagefault per page.
+	 * KGSL_FT_PAGEFAULT_LOG_ONE_PER_INT -> BIT(3) Set to log only one
+	 * pagefault per INT.
+	 */
+	 adreno_dev->ft_pf_policy = KGSL_FT_PAGEFAULT_DEFAULT_POLICY;
+	 debugfs_create_u32("ft_pagefault_policy", 0644, device->d_debugfs,
+			&adreno_dev->ft_pf_policy);
+
 	debugfs_create_file("active_cnt", 0444, device->d_debugfs, device,
 			    &_active_count_fops);
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_dispatch.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_dispatch.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_dispatch.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_dispatch.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -33,15 +33,6 @@
 /* Number of command batches sent at a time from a single context */
 static unsigned int _context_cmdbatch_burst = 5;
 
-/*
- * GFT throttle parameters. If GFT recovered more than
- * X times in Y ms invalidate the context and do not attempt recovery.
- * X -> _fault_throttle_burst
- * Y -> _fault_throttle_time
- */
-static unsigned int _fault_throttle_time = 3000;
-static unsigned int _fault_throttle_burst = 3;
-
 /* Number of command batches inflight in the ringbuffer at any time */
 static unsigned int _dispatcher_inflight = 15;
 
@@ -195,9 +186,10 @@
 		return -EINVAL;
 	}
 
-	prev = drawctxt->cmdqueue_head == 0 ?
-		(ADRENO_CONTEXT_CMDQUEUE_SIZE - 1) :
-		(drawctxt->cmdqueue_head - 1);
+	prev = drawctxt->cmdqueue_head - 1;
+
+	if (prev < 0)
+		prev = ADRENO_CONTEXT_CMDQUEUE_SIZE - 1;
 
 	/*
 	 * The maximum queue size always needs to be one less then the size of
@@ -233,6 +225,7 @@
 
 	spin_lock(&dispatcher->plist_lock);
 
+
 	if (plist_node_empty(&drawctxt->pending)) {
 		/* Get a reference to the context while it sits on the list */
 		if (_kgsl_context_get(&drawctxt->base)) {
@@ -357,6 +350,9 @@
 
 		cmdbatch = adreno_dispatcher_get_cmdbatch(drawctxt);
 
+		if (cmdbatch == NULL)
+			break;
+
 		/*
 		 * adreno_context_get_cmdbatch returns -EAGAIN if the current
 		 * cmdbatch has pending sync points so no more to do here.
@@ -364,9 +360,8 @@
 		 * reqeueued
 		 */
 
-		if (IS_ERR_OR_NULL(cmdbatch)) {
-			if (IS_ERR(cmdbatch) && PTR_ERR(cmdbatch) == -EAGAIN)
-				requeued = 1;
+		if (IS_ERR(cmdbatch) && PTR_ERR(cmdbatch) == -EAGAIN) {
+			requeued = 1;
 			break;
 		}
 
@@ -407,7 +402,7 @@
 	 */
 
 	if (count)
-		wake_up_all(&drawctxt->wq);
+		wake_up_interruptible_all(&drawctxt->wq);
 
 	/*
 	 * Return positive if the context submitted commands or if we figured
@@ -568,7 +563,7 @@
 		return 0;
 	}
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_USER_GENERATED_TS) {
+	if (drawctxt->flags & CTXT_FLAGS_USER_GENERATED_TS) {
 		/*
 		 * User specified timestamps need to be greater than the last
 		 * issued timestamp in the context
@@ -585,7 +580,7 @@
 }
 
 /**
- * adreno_dispactcher_queue_cmd() - Queue a new command in the context
+ * adreno_dispatcher_queue_cmd() - Queue a new command in the context
  * @adreno_dev: Pointer to the adreno device struct
  * @drawctxt: Pointer to the adreno draw context
  * @cmdbatch: Pointer to the command batch being submitted
@@ -612,8 +607,10 @@
 	 * to run (if it exists) regardless of the context state.
 	 */
 
-	if (test_and_clear_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv))
+	if (drawctxt->flags & CTXT_FLAGS_FORCE_PREAMBLE) {
 		set_bit(CMDBATCH_FLAG_FORCE_PREAMBLE, &cmdbatch->priv);
+		drawctxt->flags &= ~CTXT_FLAGS_FORCE_PREAMBLE;
+	}
 
 	/*
 	 * If we are waiting for the end of frame and it hasn't appeared yet,
@@ -621,7 +618,7 @@
 	 * through the pipeline but it won't actually send any commands
 	 */
 
-	if (test_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv)) {
+	if (drawctxt->flags & CTXT_FLAGS_SKIP_EOF) {
 		set_bit(CMDBATCH_FLAG_SKIP, &cmdbatch->priv);
 
 		/*
@@ -630,13 +627,14 @@
 		 */
 
 		if (cmdbatch->flags & KGSL_CONTEXT_END_OF_FRAME) {
-			clear_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv);
+			drawctxt->flags &= ~CTXT_FLAGS_SKIP_EOF;
 
 			/*
 			 * Force the preamble on the next command to ensure that
 			 * the state is correct
 			 */
-			set_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv);
+
+			drawctxt->flags |= CTXT_FLAGS_FORCE_PREAMBLE;
 		}
 	}
 
@@ -682,10 +680,10 @@
 
 	/*
 	 * Set the fault tolerance policy for the command batch - assuming the
-	 * context hasn't disabled FT use the current device policy
+	 * context hsn't disabled FT use the current device policy
 	 */
 
-	if (drawctxt->base.flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+	if (drawctxt->flags & CTXT_FLAGS_NO_FAULT_TOLERANCE)
 		set_bit(KGSL_FT_DISABLE, &cmdbatch->fault_policy);
 	else
 		cmdbatch->fault_policy = adreno_dev->ft_policy;
@@ -719,44 +717,6 @@
 	return 0;
 }
 
-static int _mark_context(int id, void *ptr, void *data)
-{
-	unsigned int guilty = *((unsigned int *) data);
-	struct kgsl_context *context = ptr;
-
-	/*
-	 * If the context is guilty mark it as such.  Otherwise mark it as
-	 * innocent if it had not already been marked as guilty.  If id is
-	 * passed as 0 then mark EVERYBODY guilty (recovery failed)
-	 */
-
-	if (guilty == 0 || guilty == context->id)
-		context->reset_status =
-			KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT;
-	else if (context->reset_status !=
-		KGSL_CTX_STAT_GUILTY_CONTEXT_RESET_EXT)
-		context->reset_status =
-			KGSL_CTX_STAT_INNOCENT_CONTEXT_RESET_EXT;
-
-	return 0;
-}
-
-/**
- * mark_guilty_context() - Mark the given context as guilty (failed recovery)
- * @device: Pointer to a KGSL device structure
- * @id: Context ID of the guilty context (or 0 to mark all as guilty)
- *
- * Mark the given (or all) context(s) as guilty (failed recovery)
- */
-static void mark_guilty_context(struct kgsl_device *device, unsigned int id)
-{
-	/* Mark the status for all the contexts in the device */
-
-	read_lock(&device->context_lock);
-	idr_for_each(&device->context_idr, _mark_context, &id);
-	read_unlock(&device->context_lock);
-}
-
 /*
  * If an IB inside of the command batch has a gpuaddr that matches the base
  * passed in then zero the size which effectively skips it when it is submitted
@@ -815,7 +775,7 @@
 	 */
 
 	if (skip && drawctxt)
-		set_bit(ADRENO_CONTEXT_SKIP_EOF, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_SKIP_EOF;
 
 	/*
 	 * If we did see the EOF flag then force the preamble on for the
@@ -823,7 +783,7 @@
 	 */
 
 	if (!skip && drawctxt)
-		set_bit(ADRENO_CONTEXT_FORCE_PREAMBLE, &drawctxt->priv);
+		drawctxt->flags |= CTXT_FLAGS_FORCE_PREAMBLE;
 }
 
 static void remove_invalidated_cmdbatches(struct kgsl_device *device,
@@ -965,8 +925,6 @@
 		/* Skip the PM dump for a timeout because it confuses people */
 		set_bit(KGSL_FT_SKIP_PMDUMP, &cmdbatch->fault_policy);
 	}
-	/* Set pagefault if it occurred */
-	kgsl_mmu_set_pagefault(&device->mmu);
 
 	adreno_readreg(adreno_dev, ADRENO_REG_CP_IB1_BASE, &base);
 
@@ -992,9 +950,6 @@
 	if (replay == NULL) {
 		unsigned int ptr = dispatcher->head;
 
-		/* Recovery failed - mark everybody guilty */
-		mark_guilty_context(device, 0);
-
 		while (ptr != dispatcher->tail) {
 			struct kgsl_context *context =
 				dispatcher->cmdqueue[ptr]->context;
@@ -1030,35 +985,6 @@
 	cmdbatch = replay[0];
 
 	/*
-	 * If GFT recovered more than X times in Y ms invalidate the context
-	 * and do not attempt recovery.
-	 * Example: X==3 and Y==3000 ms, GPU hung at 500ms, 1700ms, 25000ms and
-	 * 3000ms for the same context, we will not try FT and invalidate the
-	 * context @3000ms because context triggered GFT more than 3 times in
-	 * last 3 seconds. If a context caused recoverable GPU hangs
-	 * where 1st and 4th gpu hang are more than 3 seconds apart we
-	 * won't disable GFT and invalidate the context.
-	 */
-	if (test_bit(KGSL_FT_THROTTLE, &cmdbatch->fault_policy)) {
-		if (time_after(jiffies, (cmdbatch->context->fault_time
-				+ msecs_to_jiffies(_fault_throttle_time)))) {
-			cmdbatch->context->fault_time = jiffies;
-			cmdbatch->context->fault_count = 1;
-		} else {
-			cmdbatch->context->fault_count++;
-			if (cmdbatch->context->fault_count >
-					_fault_throttle_burst) {
-				set_bit(KGSL_FT_DISABLE,
-						&cmdbatch->fault_policy);
-				pr_fault(device, cmdbatch,
-					 "gpu fault threshold exceeded %d faults in %d msecs\n",
-					 _fault_throttle_burst,
-					 _fault_throttle_time);
-			}
-		}
-	}
-
-	/*
 	 * If FT is disabled for this cmdbatch invalidate immediately
 	 */
 
@@ -1067,7 +993,6 @@
 		pr_fault(device, cmdbatch, "gpu skipped ctx %d ts %d\n",
 			cmdbatch->context->id, cmdbatch->timestamp);
 
-		mark_guilty_context(device, cmdbatch->context->id);
 		adreno_drawctxt_invalidate(device, cmdbatch->context);
 	}
 
@@ -1163,9 +1088,6 @@
 	pr_fault(device, cmdbatch, "gpu failed ctx %d ts %d\n",
 		cmdbatch->context->id, cmdbatch->timestamp);
 
-	/* Mark the context as failed */
-	mark_guilty_context(device, cmdbatch->context->id);
-
 	/* Invalidate the context */
 	adreno_drawctxt_invalidate(device, cmdbatch->context);
 
@@ -1226,9 +1148,6 @@
 				"gpu reset failed ctx %d ts %d\n",
 				replay[i]->context->id, replay[i]->timestamp);
 
-			/* Mark this context as guilty (failed recovery) */
-			mark_guilty_context(device, replay[i]->context->id);
-
 			adreno_drawctxt_invalidate(device, replay[i]->context);
 			remove_invalidated_cmdbatches(device, &replay[i],
 				count - i);
@@ -1285,7 +1204,6 @@
 		container_of(dispatcher, struct adreno_device, dispatcher);
 	struct kgsl_device *device = &adreno_dev->dev;
 	int count = 0;
-	int last_context = KGSL_CONTEXT_INVALID;
 	int fault_handled = 0;
 
 	mutex_lock(&dispatcher->mutex);
@@ -1317,22 +1235,12 @@
 			 * successful completion to the world
 			 */
 
-			if (cmdbatch->fault_recovery != 0) {
-				struct adreno_context *drawctxt =
-					ADRENO_CONTEXT(cmdbatch->context);
-
-				/* Mark the context as faulted and recovered */
-				set_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv);
-
+			if (cmdbatch->fault_recovery != 0)
 				_print_recovery(device, cmdbatch);
-			}
 
 			trace_adreno_cmdbatch_retired(cmdbatch,
 				dispatcher->inflight - 1);
 
-			/* Remember the last context that got retired */
-			last_context = cmdbatch->context->id;
-
 			/* Reduce the number of inflight command batches */
 			dispatcher->inflight--;
 
@@ -1381,7 +1289,7 @@
 		 */
 
 		if (!adreno_dev->long_ib_detect ||
-			drawctxt->base.flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+			drawctxt->flags & CTXT_FLAGS_NO_FAULT_TOLERANCE)
 			break;
 
 		/*
@@ -1437,18 +1345,6 @@
 		/* Update the timeout timer for the next command batch */
 		mod_timer(&dispatcher->timer, cmdbatch->expires);
 
-		/*
-		 * if the context for the next pending cmdbatch is different
-		 * than the last one we retired, then trace it as a GPU switch
-		 */
-
-		if (cmdbatch->context->id != last_context) {
-			u64 now = ktime_to_ns(ktime_get());
-			kgsl_trace_gpu_sched_switch(device->name, now,
-				cmdbatch->context->id, cmdbatch->priority,
-				cmdbatch->timestamp);
-		}
-
 		/* There are still things in flight - update the idle counts */
 		mutex_lock(&device->mutex);
 		kgsl_pwrscale_idle(device);
@@ -1567,6 +1463,7 @@
  * adreno_dispatcher_start() - activate the dispatcher
  * @adreno_dev: pointer to the adreno device structure
  *
+ * Set the disaptcher active and start the loop once to get things going
  */
 void adreno_dispatcher_start(struct kgsl_device *device)
 {
@@ -1680,10 +1577,6 @@
 static DISPATCHER_UINT_ATTR(context_queue_wait, 0644, 0, _context_queue_wait);
 static DISPATCHER_UINT_ATTR(fault_detect_interval, 0644, 0,
 	_fault_timer_interval);
-static DISPATCHER_UINT_ATTR(fault_throttle_time, 0644, 0,
-	_fault_throttle_time);
-static DISPATCHER_UINT_ATTR(fault_throttle_burst, 0644, 0,
-	_fault_throttle_burst);
 
 static struct attribute *dispatcher_attrs[] = {
 	&dispatcher_attr_inflight.attr,
@@ -1692,8 +1585,6 @@
 	&dispatcher_attr_cmdbatch_timeout.attr,
 	&dispatcher_attr_context_queue_wait.attr,
 	&dispatcher_attr_fault_detect_interval.attr,
-	&dispatcher_attr_fault_throttle_time.attr,
-	&dispatcher_attr_fault_throttle_burst.attr,
 	NULL,
 };
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -138,7 +138,7 @@
 		u32 timestamp, u32 type)
 {
 	struct adreno_context *drawctxt = priv;
-	wake_up_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->waiting);
 }
 
 #define adreno_wait_event_interruptible_timeout(wq, condition, timeout, io)   \
@@ -266,18 +266,20 @@
 {
 	struct adreno_context *drawctxt = priv;
 
-	wake_up_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->waiting);
 	kgsl_context_put(&drawctxt->base);
 }
 
 static int _check_global_timestamp(struct kgsl_device *device,
-		struct adreno_context *drawctxt, unsigned int timestamp)
+		unsigned int timestamp)
 {
-	/* Stop waiting if the context is invalidated */
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID)
-		return 1;
+	int ret;
 
-	return kgsl_check_timestamp(device, NULL, timestamp);
+	mutex_lock(&device->mutex);
+	ret = kgsl_check_timestamp(device, NULL, timestamp);
+	mutex_unlock(&device->mutex);
+
+	return ret;
 }
 
 int adreno_drawctxt_wait_global(struct adreno_device *adreno_dev,
@@ -286,7 +288,7 @@
 {
 	struct kgsl_device *device = &adreno_dev->dev;
 	struct adreno_context *drawctxt = ADRENO_CONTEXT(context);
-	int ret = 0;
+	int ret;
 
 	/* Needs to hold the device mutex */
 	BUG_ON(!mutex_is_locked(&device->mutex));
@@ -296,15 +298,6 @@
 		goto done;
 	}
 
-	/*
-	 * If the context is invalid then return immediately - we may end up
-	 * waiting for a timestamp that will never come
-	 */
-	if (drawctxt->state == ADRENO_CONTEXT_STATE_INVALID) {
-		kgsl_context_put(context);
-		goto done;
-	}
-
 	trace_adreno_drawctxt_wait_start(KGSL_MEMSTORE_GLOBAL, timestamp);
 
 	ret = kgsl_add_event(device, KGSL_MEMSTORE_GLOBAL, timestamp,
@@ -318,7 +311,7 @@
 
 	if (timeout) {
 		ret = (int) wait_event_timeout(drawctxt->waiting,
-			_check_global_timestamp(device, drawctxt, timestamp),
+			_check_global_timestamp(device, timestamp),
 			msecs_to_jiffies(timeout));
 
 		if (ret == 0)
@@ -327,7 +320,7 @@
 			ret = 0;
 	} else {
 		wait_event(drawctxt->waiting,
-			_check_global_timestamp(device, drawctxt, timestamp));
+			_check_global_timestamp(device, timestamp));
 	}
 
 	mutex_lock(&device->mutex);
@@ -391,8 +384,8 @@
 	mutex_unlock(&drawctxt->mutex);
 
 	/* Give the bad news to everybody waiting around */
-	wake_up_all(&drawctxt->waiting);
-	wake_up_all(&drawctxt->wq);
+	wake_up_interruptible_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->wq);
 }
 
 /**
@@ -412,7 +405,6 @@
 	int ret;
 
 	drawctxt = kzalloc(sizeof(struct adreno_context), GFP_KERNEL);
-
 	if (drawctxt == NULL)
 		return ERR_PTR(-ENOMEM);
 
@@ -425,16 +417,25 @@
 	drawctxt->bin_base_offset = 0;
 	drawctxt->timestamp = 0;
 
-	drawctxt->base.flags = *flags & (KGSL_CONTEXT_PREAMBLE |
+	*flags &= (KGSL_CONTEXT_PREAMBLE |
 		KGSL_CONTEXT_NO_GMEM_ALLOC |
 		KGSL_CONTEXT_PER_CONTEXT_TS |
 		KGSL_CONTEXT_USER_GENERATED_TS |
 		KGSL_CONTEXT_NO_FAULT_TOLERANCE |
-		KGSL_CONTEXT_TYPE_MASK |
-		KGSL_CONTEXT_PWR_CONSTRAINT);
+		KGSL_CONTEXT_TYPE_MASK);
 
 	/* Always enable per-context timestamps */
-	drawctxt->base.flags |= KGSL_CONTEXT_PER_CONTEXT_TS;
+	*flags |= KGSL_CONTEXT_PER_CONTEXT_TS;
+	drawctxt->flags |= CTXT_FLAGS_PER_CONTEXT_TS;
+
+	if (*flags & KGSL_CONTEXT_PREAMBLE)
+		drawctxt->flags |= CTXT_FLAGS_PREAMBLE;
+
+	if (*flags & KGSL_CONTEXT_NO_GMEM_ALLOC)
+		drawctxt->flags |= CTXT_FLAGS_NOGMEMALLOC;
+
+	if (*flags & KGSL_CONTEXT_USER_GENERATED_TS)
+		drawctxt->flags |= CTXT_FLAGS_USER_GENERATED_TS;
 
 	mutex_init(&drawctxt->mutex);
 	init_waitqueue_head(&drawctxt->wq);
@@ -448,12 +449,18 @@
 
 	plist_node_init(&drawctxt->pending, ADRENO_CONTEXT_DEFAULT_PRIORITY);
 
+	if (*flags & KGSL_CONTEXT_NO_FAULT_TOLERANCE)
+		drawctxt->flags |= CTXT_FLAGS_NO_FAULT_TOLERANCE;
+
+	drawctxt->type =
+		(*flags & KGSL_CONTEXT_TYPE_MASK) >> KGSL_CONTEXT_TYPE_SHIFT;
+
 	if (adreno_dev->gpudev->ctxt_create) {
 		ret = adreno_dev->gpudev->ctxt_create(adreno_dev, drawctxt);
 		if (ret)
 			goto err;
-	} else if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) == 0 ||
-		  (drawctxt->base.flags & KGSL_CONTEXT_NO_GMEM_ALLOC) == 0) {
+	} else if ((*flags & KGSL_CONTEXT_PREAMBLE) == 0 ||
+		  (*flags & KGSL_CONTEXT_NO_GMEM_ALLOC) == 0) {
 		KGSL_DEV_ERR_ONCE(device,
 				"legacy context switch not supported\n");
 		ret = -EINVAL;
@@ -469,8 +476,7 @@
 	kgsl_sharedmem_writel(device, &device->memstore,
 			KGSL_MEMSTORE_OFFSET(drawctxt->base.id, eoptimestamp),
 			0);
-	/* copy back whatever flags we dediced were valid */
-	*flags = drawctxt->base.flags;
+
 	return &drawctxt->base;
 err:
 	kgsl_context_detach(&drawctxt->base);
@@ -545,22 +551,9 @@
 	 */
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
-	/* Wait for the last global timestamp to pass before continuing.
-	 * The maxumum wait time is 30s, some large IB's can take longer
-	 * than 10s and if hang happens then the time for the context's
-	 * commands to retire will be greater than 10s. 30s should be sufficient
-	 * time to wait for the commands even if a hang happens.
-	 */
+	/* Wait for the last global timestamp to pass before continuing */
 	ret = adreno_drawctxt_wait_global(adreno_dev, context,
-		drawctxt->internal_timestamp, 30 * 1000);
-
-	/*
-	 * If the wait for global fails then nothing after this point is likely
-	 * to work very well - BUG_ON() so we can take advantage of the debug
-	 * tools to figure out what the h - e - double hockey sticks happened
-	 */
-
-	BUG_ON(ret);
+		drawctxt->internal_timestamp, 10 * 1000);
 
 	kgsl_sharedmem_writel(device, &device->memstore,
 			KGSL_MEMSTORE_OFFSET(context->id, soptimestamp),
@@ -577,8 +570,8 @@
 		drawctxt->ops->detach(drawctxt);
 
 	/* wake threads waiting to submit commands from this context */
-	wake_up_all(&drawctxt->waiting);
-	wake_up_all(&drawctxt->wq);
+	wake_up_interruptible_all(&drawctxt->waiting);
+	wake_up_interruptible_all(&drawctxt->wq);
 
 	return ret;
 }
@@ -609,14 +602,14 @@
 int adreno_context_restore(struct adreno_device *adreno_dev,
 				  struct adreno_context *context)
 {
+	int ret;
 	struct kgsl_device *device;
-	unsigned int cmds[8];
+	unsigned int cmds[5];
 
 	if (adreno_dev == NULL || context == NULL)
 		return -EINVAL;
 
 	device = &adreno_dev->dev;
-
 	/* write the context identifier to the ringbuffer */
 	cmds[0] = cp_nop_packet(1);
 	cmds[1] = KGSL_CONTEXT_TO_MEM_IDENTIFIER;
@@ -624,13 +617,14 @@
 	cmds[3] = device->memstore.gpuaddr +
 		KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL, current_context);
 	cmds[4] = context->base.id;
-	/* Flush the UCHE for new context */
-	cmds[5] = cp_type0_packet(
-		adreno_getreg(adreno_dev, ADRENO_REG_UCHE_INVALIDATE0), 2);
-	cmds[6] = 0;
-	cmds[7] = 0x90000000;
-	return adreno_ringbuffer_issuecmds(device, context,
-				KGSL_CMD_FLAGS_NONE, cmds, 8);
+	ret = adreno_ringbuffer_issuecmds(device, context, KGSL_CMD_FLAGS_NONE,
+					cmds, 5);
+	if (ret)
+		return ret;
+
+	return kgsl_mmu_setstate(&device->mmu,
+			context->base.proc_priv->pagetable,
+			context->base.id);
 }
 
 
@@ -703,10 +697,10 @@
 		if (flags & KGSL_CONTEXT_SAVE_GMEM)
 			/* Set the flag in context so that the save is done
 			* when this context is switched out. */
-			set_bit(ADRENO_CONTEXT_GMEM_SAVE, &drawctxt->priv);
+			drawctxt->flags |= CTXT_FLAGS_GMEM_SAVE;
 		else
 			/* Remove GMEM saving flag from the context */
-			clear_bit(ADRENO_CONTEXT_GMEM_SAVE, &drawctxt->priv);
+			drawctxt->flags &= ~CTXT_FLAGS_GMEM_SAVE;
 	}
 
 	/* already current? */
@@ -720,16 +714,25 @@
 	trace_adreno_drawctxt_switch(adreno_dev->drawctxt_active,
 		drawctxt, flags);
 
+	if (adreno_dev->drawctxt_active) {
+		ret = context_save(adreno_dev, adreno_dev->drawctxt_active);
+		if (ret) {
+			KGSL_DRV_ERR(device,
+				"Error in GPU context %d save: %d\n",
+				adreno_dev->drawctxt_active->base.id, ret);
+			return ret;
+		}
+
+		/* Put the old instance of the active drawctxt */
+		kgsl_context_put(&adreno_dev->drawctxt_active->base);
+		adreno_dev->drawctxt_active = NULL;
+	}
+
 	/* Get a refcount to the new instance */
 	if (drawctxt) {
 		if (!_kgsl_context_get(&drawctxt->base))
 			return -EINVAL;
 
-		ret = kgsl_mmu_setstate(&device->mmu,
-			drawctxt->base.proc_priv->pagetable,
-			adreno_dev->drawctxt_active ?
-			adreno_dev->drawctxt_active->base.id :
-			KGSL_CONTEXT_INVALID);
 		/* Set the new context */
 		ret = drawctxt->ops->restore(adreno_dev, drawctxt);
 		if (ret) {
@@ -747,11 +750,9 @@
 		 */
 		ret = kgsl_mmu_setstate(&device->mmu,
 					 device->mmu.defaultpagetable,
-					adreno_dev->drawctxt_active->base.id);
+					 KGSL_CONTEXT_INVALID);
 	}
-	/* Put the old instance of the active drawctxt */
-	if (adreno_dev->drawctxt_active)
-		kgsl_context_put(&adreno_dev->drawctxt_active->base);
+
 	adreno_dev->drawctxt_active = drawctxt;
 	return 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_drawctxt.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_drawctxt.h	2014-09-21 01:02:11.000000000 +0000
@@ -16,6 +16,44 @@
 #include "adreno_pm4types.h"
 #include "a2xx_reg.h"
 
+/* Flags */
+
+#define CTXT_FLAGS_NOT_IN_USE		0x00000000
+#define CTXT_FLAGS_IN_USE		BIT(0)
+
+/* state shadow memory allocated */
+#define CTXT_FLAGS_STATE_SHADOW		BIT(1)
+
+/* gmem shadow memory allocated */
+#define CTXT_FLAGS_GMEM_SHADOW		BIT(2)
+/* gmem must be copied to shadow */
+#define CTXT_FLAGS_GMEM_SAVE		BIT(3)
+/* gmem can be restored from shadow */
+#define CTXT_FLAGS_GMEM_RESTORE		BIT(4)
+/* preamble packed in cmdbuffer for context switching */
+#define CTXT_FLAGS_PREAMBLE		BIT(5)
+/* shader must be copied to shadow */
+#define CTXT_FLAGS_SHADER_SAVE		BIT(6)
+/* shader can be restored from shadow */
+#define CTXT_FLAGS_SHADER_RESTORE	BIT(7)
+/* Context has caused a GPU hang */
+#define CTXT_FLAGS_GPU_HANG		BIT(8)
+/* Specifies there is no need to save GMEM */
+#define CTXT_FLAGS_NOGMEMALLOC          BIT(9)
+/* Trash state for context */
+#define CTXT_FLAGS_TRASHSTATE		BIT(10)
+/* per context timestamps enabled */
+#define CTXT_FLAGS_PER_CONTEXT_TS	BIT(11)
+/* Context has caused a GPU hang and fault tolerance successful */
+#define CTXT_FLAGS_GPU_HANG_FT	BIT(12)
+/* User mode generated timestamps enabled */
+#define CTXT_FLAGS_USER_GENERATED_TS    BIT(14)
+/* Context skip till EOF */
+#define CTXT_FLAGS_SKIP_EOF             BIT(15)
+/* Context no fault tolerance */
+#define CTXT_FLAGS_NO_FAULT_TOLERANCE  BIT(16)
+/* Force the preamble for the next submission */
+#define CTXT_FLAGS_FORCE_PREAMBLE      BIT(17)
 
 /* Symbolic table for the adreno draw context type */
 #define ADRENO_DRAWCTXT_TYPES \
@@ -92,7 +130,7 @@
  * @internal_timestamp: Global timestamp of the last issued command
  *			NOTE: guarded by device->mutex, not drawctxt->mutex!
  * @state: Current state of the context
- * @priv: Internal flags
+ * @flags: Bitfield controlling behavior of the context
  * @type: Context type (GL, CL, RS)
  * @mutex: Mutex to protect the cmdqueue
  * @pagetable: Pointer to the GPU pagetable for the context
@@ -131,7 +169,7 @@
 	unsigned int timestamp;
 	unsigned int internal_timestamp;
 	int state;
-	unsigned long priv;
+	uint32_t flags;
 	unsigned int type;
 	struct mutex mutex;
 	struct kgsl_memdesc gpustate;
@@ -162,8 +200,8 @@
 
 	/* Dispatcher */
 	struct kgsl_cmdbatch *cmdqueue[ADRENO_CONTEXT_CMDQUEUE_SIZE];
-	unsigned int cmdqueue_head;
-	unsigned int cmdqueue_tail;
+	int cmdqueue_head;
+	int cmdqueue_tail;
 
 	struct plist_node pending;
 	wait_queue_head_t wq;
@@ -174,31 +212,6 @@
 	const struct adreno_context_ops *ops;
 };
 
-/**
- * enum adreno_context_priv - Private flags for an adreno draw context
- * @ADRENO_CONTEXT_FAULT - set if the context has faulted (and recovered)
- * @ADRENO_CONTEXT_GMEM_SAVE - gmem must be copied to shadow
- * @ADRENO_CONTEXT_GMEM_RESTORE - gmem can be restored from shadow
- * @ADRENO_CONTEXT_SHADER_SAVE - shader must be copied to shadow
- * @ADRENO_CONTEXT_SHADER_RESTORE - shader can be restored from shadow
- * @ADRENO_CONTEXT_GPU_HANG - Context has caused a GPU hang
- * @ADRENO_CONTEXT_GPU_HANG_FT - Context has caused a GPU hang
- *      and fault tolerance was successful
- * @ADRENO_CONTEXT_SKIP_EOF - Context skip IBs until the next end of frame
- *      marker.
- * @ADRENO_CONTEXT_FORCE_PREAMBLE - Force the preamble for the next submission.
- */
-enum adreno_context_priv {
-	ADRENO_CONTEXT_FAULT = 0,
-	ADRENO_CONTEXT_GMEM_SAVE,
-	ADRENO_CONTEXT_GMEM_RESTORE,
-	ADRENO_CONTEXT_SHADER_SAVE,
-	ADRENO_CONTEXT_SHADER_RESTORE,
-	ADRENO_CONTEXT_GPU_HANG,
-	ADRENO_CONTEXT_GPU_HANG_FT,
-	ADRENO_CONTEXT_SKIP_EOF,
-	ADRENO_CONTEXT_FORCE_PREAMBLE,
-};
 
 struct kgsl_context *adreno_drawctxt_create(struct kgsl_device_private *,
 			uint32_t *flags);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_pm4types.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_pm4types.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_pm4types.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_pm4types.h	2014-09-21 01:02:11.000000000 +0000
@@ -143,10 +143,10 @@
 #define CP_IM_STORE            0x2c
 
 /* test 2 memory locations to dword values specified */
-#define CP_TEST_TWO_MEMS	0x71
+#define CP_TEST_TWO_MEMS    0x71
 
 /* PFP waits until the FIFO between the PFP and the ME is empty */
-#define CP_WAIT_FOR_ME		0x13
+#define CP_WAIT_FOR_ME      0x13
 
 /*
  * for a20x
@@ -164,8 +164,6 @@
 
 #define CP_SET_PROTECTED_MODE  0x5f /* sets the register protection mode */
 
-#define CP_BOOTSTRAP_UCODE  0x6f /* bootstraps microcode */
-
 /*
  * for a3xx
  */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_postmortem.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_postmortem.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_postmortem.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_postmortem.c	2014-09-21 01:02:11.000000000 +0000
@@ -12,7 +12,6 @@
  */
 
 #include <linux/vmalloc.h>
-#include <mach/board.h>
 
 #include "kgsl.h"
 #include "kgsl_sharedmem.h"
@@ -52,7 +51,6 @@
 	{CP_DRAW_INDX,			"DRW_NDX_"},
 	{CP_DRAW_INDX_BIN,		"DRW_NDXB"},
 	{CP_EVENT_WRITE,		"EVENT_WT"},
-	{CP_MEM_WRITE,			"MEM_WRIT"},
 	{CP_IM_LOAD,			"IN__LOAD"},
 	{CP_IM_LOAD_IMMEDIATE,		"IM_LOADI"},
 	{CP_IM_STORE,			"IM_STORE"},
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.c flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.c
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,7 +20,6 @@
 #include "kgsl.h"
 #include "kgsl_sharedmem.h"
 #include "kgsl_cffdump.h"
-#include "kgsl_trace.h"
 
 #include "adreno.h"
 #include "adreno_pm4types.h"
@@ -31,6 +30,14 @@
 
 #define GSL_RB_NOP_SIZEDWORDS				2
 
+/*
+ * CP DEBUG settings for all cores:
+ * DYNAMIC_CLK_DISABLE [27] - turn off the dynamic clock control
+ * PROG_END_PTR_ENABLE [25] - Allow 128 bit writes to the VBIF
+ */
+
+#define CP_DEBUG_DEFAULT ((1 << 27) | (1 << 25))
+
 void adreno_ringbuffer_submit(struct adreno_ringbuffer *rb)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
@@ -208,19 +215,28 @@
  * adreno_ringbuffer_load_pm4_ucode() - Load pm4 ucode
  * @device: Pointer to a KGSL device
  * @start: Starting index in pm4 ucode to load
- * @end: Ending index of pm4 ucode to load
  * @addr: Address to load the pm4 ucode
  *
  * Load the pm4 ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
-			unsigned int start, unsigned int end, unsigned int addr)
+int adreno_ringbuffer_load_pm4_ucode(struct kgsl_device *device,
+					unsigned int start, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int i;
 
+	if (adreno_dev->pm4_fw == NULL) {
+		int ret = adreno_ringbuffer_read_pm4_ucode(device);
+		if (ret)
+			return ret;
+	}
+
+	KGSL_DRV_INFO(device, "loading pm4 ucode version: %d\n",
+		adreno_dev->pm4_fw_version);
+
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_DEBUG, CP_DEBUG_DEFAULT);
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_RAM_WADDR, addr);
-	for (i = start; i < end; i++)
+	for (i = 1; i < adreno_dev->pm4_fw_size; i++)
 		adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_RAM_DATA,
 					adreno_dev->pm4_fw[i]);
 
@@ -262,19 +278,27 @@
  * adreno_ringbuffer_load_pfp_ucode() - Load pfp ucode
  * @device: Pointer to a KGSL device
  * @start: Starting index in pfp ucode to load
- * @end: Ending index of pfp ucode to load
  * @addr: Address to load the pfp ucode
  *
  * Load the pfp ucode from @start at @addr.
  */
-inline int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
-			unsigned int start, unsigned int end, unsigned int addr)
+int adreno_ringbuffer_load_pfp_ucode(struct kgsl_device *device,
+					unsigned int start, unsigned int addr)
 {
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 	int i;
 
+	if (adreno_dev->pfp_fw == NULL) {
+		int ret = adreno_ringbuffer_read_pfp_ucode(device);
+		if (ret)
+			return ret;
+	}
+
+	KGSL_DRV_INFO(device, "loading pfp ucode version: %d\n",
+			adreno_dev->pfp_fw_version);
+
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_ADDR, addr);
-	for (i = start; i < end; i++)
+	for (i = 1; i < adreno_dev->pfp_fw_size; i++)
 		adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_DATA,
 						adreno_dev->pfp_fw[i]);
 
@@ -282,113 +306,72 @@
 }
 
 /**
- * _ringbuffer_bootstrap_ucode() - Bootstrap GPU Ucode
+ * _ringbuffer_start_common() - Ringbuffer start
  * @rb: Pointer to adreno ringbuffer
- * @load_jt: If non zero only load Jump tables
- *
- * Bootstrap ucode for GPU
- * load_jt == 0, bootstrap full microcode
- * load_jt == 1, bootstrap jump tables of microcode
  *
- * For example a bootstrap packet would like below
- * Setup a type3 bootstrap packet
- * PFP size to bootstrap
- * PFP addr to write the PFP data
- * PM4 size to bootstrap
- * PM4 addr to write the PM4 data
- * PFP dwords from microcode to bootstrap
- * PM4 size dwords from microcode to bootstrap
+ * Setup ringbuffer for GPU.
  */
-static int _ringbuffer_bootstrap_ucode(struct adreno_ringbuffer *rb,
-					unsigned int load_jt)
+int _ringbuffer_start_common(struct adreno_ringbuffer *rb)
 {
-	unsigned int *cmds, cmds_gpu, bootstrap_size;
-	int i = 0;
+	int status;
+	union reg_cp_rb_cntl cp_rb_cntl;
+	unsigned int rb_cntl;
 	struct kgsl_device *device = rb->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
-	unsigned int pm4_size, pm4_idx, pm4_addr, pfp_size, pfp_idx, pfp_addr;
 
-	/* Only bootstrap jump tables of ucode */
-	if (load_jt) {
-		pm4_idx = adreno_dev->pm4_jt_idx;
-		pm4_addr = adreno_dev->pm4_jt_addr;
-		pfp_idx = adreno_dev->pfp_jt_idx;
-		pfp_addr = adreno_dev->pfp_jt_addr;
-	} else {
-		/* Bootstrap full ucode */
-		pm4_idx = 1;
-		pm4_addr = 0;
-		pfp_idx = 1;
-		pfp_addr = 0;
-	}
+	if (rb->flags & KGSL_FLAGS_STARTED)
+		return 0;
 
-	pm4_size = (adreno_dev->pm4_fw_size - pm4_idx);
-	pfp_size = (adreno_dev->pfp_fw_size - pfp_idx);
-
-	/*
-	 * Below set of commands register with PFP that 6f is the
-	 * opcode for bootstrapping
-	 */
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_ADDR, 0x200);
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_PFP_UCODE_DATA, 0x6f0005);
-
-	/* clear ME_HALT to start micro engine */
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, 0);
-
-	bootstrap_size = (pm4_size + pfp_size + 5);
-
-	cmds = adreno_ringbuffer_allocspace(rb, NULL, bootstrap_size);
-	if (cmds == NULL)
-			return -ENOMEM;
-
-	cmds_gpu = rb->buffer_desc.gpuaddr +
-			sizeof(uint) * (rb->wptr - bootstrap_size);
-	/* Construct the packet that bootsraps the ucode */
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu,
-			cp_type3_packet(CP_BOOTSTRAP_UCODE,
-			(bootstrap_size - 1)));
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pfp_size);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pfp_addr);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pm4_size);
-	GSL_RB_WRITE(rb->device, cmds, cmds_gpu, pm4_addr);
-	for (i = pfp_idx; i < adreno_dev->pfp_fw_size; i++)
-		GSL_RB_WRITE(rb->device, cmds, cmds_gpu, adreno_dev->pfp_fw[i]);
-	for (i = pm4_idx; i < adreno_dev->pm4_fw_size; i++)
-		GSL_RB_WRITE(rb->device, cmds, cmds_gpu, adreno_dev->pm4_fw[i]);
-
-	adreno_ringbuffer_submit(rb);
-	/* idle device to validate bootstrap */
-	return adreno_idle(device);
-}
-
-/**
- * _ringbuffer_setup_common() - Ringbuffer start
- * @rb: Pointer to adreno ringbuffer
- *
- * Setup ringbuffer for GPU.
- */
-void _ringbuffer_setup_common(struct adreno_ringbuffer *rb)
-{
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
+	kgsl_sharedmem_set(rb->device, &rb->memptrs_desc, 0, 0,
+			   sizeof(struct kgsl_rbmemptrs));
 
 	kgsl_sharedmem_set(rb->device, &rb->buffer_desc, 0, 0xAA,
 			   (rb->sizedwords << 2));
 
+	if (adreno_is_a2xx(adreno_dev)) {
+		kgsl_regwrite(device, REG_CP_RB_WPTR_BASE,
+			(rb->memptrs_desc.gpuaddr
+			+ GSL_RB_MEMPTRS_WPTRPOLL_OFFSET));
+
+		/* setup WPTR delay */
+		kgsl_regwrite(device, REG_CP_RB_WPTR_DELAY,
+			0 /*0x70000010 */);
+	}
+
+	/*setup REG_CP_RB_CNTL */
+	adreno_readreg(adreno_dev, ADRENO_REG_CP_RB_CNTL, &rb_cntl);
+	cp_rb_cntl.val = rb_cntl;
+
 	/*
 	 * The size of the ringbuffer in the hardware is the log2
-	 * representation of the size in quadwords (sizedwords / 2).
-	 * Also disable the host RPTR shadow register as it might be unreliable
-	 * in certain circumstances.
+	 * representation of the size in quadwords (sizedwords / 2)
 	 */
+	cp_rb_cntl.f.rb_bufsz = ilog2(rb->sizedwords >> 1);
 
-	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_CNTL,
-		(ilog2(rb->sizedwords >> 1) & 0x3F) |
-		(1 << 27));
+	/*
+	 * Specify the quadwords to read before updating mem RPTR.
+	 * Like above, pass the log2 representation of the blocksize
+	 * in quadwords.
+	*/
+	cp_rb_cntl.f.rb_blksz = ilog2(KGSL_RB_BLKSIZE >> 3);
+
+	if (adreno_is_a2xx(adreno_dev)) {
+		/* WPTR polling */
+		cp_rb_cntl.f.rb_poll_en = GSL_RB_CNTL_POLL_EN;
+	}
+
+	/* mem RPTR writebacks */
+	cp_rb_cntl.f.rb_no_update =  GSL_RB_CNTL_NO_UPDATE;
+
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_CNTL, cp_rb_cntl.val);
 
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_BASE,
 					rb->buffer_desc.gpuaddr);
 
+	adreno_writereg(adreno_dev, ADRENO_REG_CP_RB_RPTR_ADDR,
+				rb->memptrs_desc.gpuaddr +
+				GSL_RB_MEMPTRS_RPTR_OFFSET);
+
 	if (adreno_is_a2xx(adreno_dev)) {
 		/* explicitly clear all cp interrupts */
 		kgsl_regwrite(device, REG_CP_INT_ACK, 0xFFFFFFFF);
@@ -411,19 +394,6 @@
 		kgsl_regwrite(device, REG_CP_QUEUE_THRESHOLDS, 0x003E2008);
 
 	rb->wptr = 0;
-}
-
-/**
- * _ringbuffer_start_common() - Ringbuffer start
- * @rb: Pointer to adreno ringbuffer
- *
- * Start ringbuffer for GPU.
- */
-int _ringbuffer_start_common(struct adreno_ringbuffer *rb)
-{
-	int status;
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	/* clear ME_HALT to start micro engine */
 	adreno_writereg(adreno_dev, ADRENO_REG_CP_ME_CNTL, 0);
@@ -436,6 +406,9 @@
 	/* idle device to validate ME INIT */
 	status = adreno_idle(device);
 
+	if (status == 0)
+		rb->flags |= KGSL_FLAGS_STARTED;
+
 	return status;
 }
 
@@ -452,94 +425,52 @@
 	struct kgsl_device *device = rb->device;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	_ringbuffer_setup_common(rb);
-
-	/* If bootstrapping if supported to load jump tables */
-	if (adreno_bootstrap_ucode(adreno_dev)) {
-		status = _ringbuffer_bootstrap_ucode(rb, 1);
-		if (status != 0)
-			return status;
-
-	} else {
-		/* load the CP jump tables using AHB writes */
-		status = adreno_ringbuffer_load_pm4_ucode(device,
-			adreno_dev->pm4_jt_idx, adreno_dev->pm4_fw_size,
-			adreno_dev->pm4_jt_addr);
-		if (status != 0)
-			return status;
-
-		/* load the prefetch parser jump tables using AHB writes */
-		status = adreno_ringbuffer_load_pfp_ucode(device,
-			adreno_dev->pfp_jt_idx, adreno_dev->pfp_fw_size,
-			adreno_dev->pfp_jt_addr);
-		if (status != 0)
-			return status;
-	}
+	/* load the CP ucode */
+	status = adreno_ringbuffer_load_pm4_ucode(device,
+			adreno_dev->pm4_jt_idx, adreno_dev->pm4_jt_addr);
+	if (status != 0)
+		return status;
 
-	status = _ringbuffer_start_common(rb);
+	/* load the prefetch parser ucode */
+	status = adreno_ringbuffer_load_pfp_ucode(device,
+			adreno_dev->pfp_jt_idx, adreno_dev->pfp_jt_addr);
+	if (status != 0)
+		return status;
 
-	return status;
+	return _ringbuffer_start_common(rb);
 }
 
-/**
- * adreno_ringbuffer_cold_start() - Ringbuffer cold start
- * @rb: Pointer to adreno ringbuffer
- *
- * Start the ringbuffer from power collapse.
- */
-int adreno_ringbuffer_cold_start(struct adreno_ringbuffer *rb)
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb)
 {
 	int status;
-	struct kgsl_device *device = rb->device;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
+	if (rb->flags & KGSL_FLAGS_STARTED)
+		return 0;
 
-	_ringbuffer_setup_common(rb);
-
-	/* If bootstrapping if supported to load ucode */
-	if (adreno_bootstrap_ucode(adreno_dev)) {
+	/* load the CP ucode */
+	status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1, 0);
+	if (status != 0)
+		return status;
 
-		/*
-		 * load first adreno_dev->pm4_bstrp_size +
-		 * adreno_dev->pfp_bstrp_size microcode dwords using AHB write,
-		 * this small microcode has dispatcher + booter, this initial
-		 * microcode enables CP to understand CP_BOOTSTRAP_UCODE packet
-		 * in function _ringbuffer_bootstrap_ucode. CP_BOOTSTRAP_UCODE
-		 * packet loads rest of the microcode.
-		 */
+	/* load the prefetch parser ucode */
+	status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1, 0);
+	if (status != 0)
+		return status;
 
-		status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1,
-					adreno_dev->pm4_bstrp_size+1, 0);
-		if (status != 0)
-			return status;
-
-		status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1,
-					adreno_dev->pfp_bstrp_size+1, 0);
-		if (status != 0)
-			return status;
-
-		/* Bootstrap rest of the ucode here */
-		status = _ringbuffer_bootstrap_ucode(rb, 0);
-		if (status != 0)
-			return status;
+	return _ringbuffer_start_common(rb);
+}
 
-	} else {
-		/* load the CP ucode using AHB writes */
-		status = adreno_ringbuffer_load_pm4_ucode(rb->device, 1,
-					adreno_dev->pm4_fw_size, 0);
-		if (status != 0)
-			return status;
-
-		/* load the prefetch parser ucode using AHB writes */
-		status = adreno_ringbuffer_load_pfp_ucode(rb->device, 1,
-					adreno_dev->pfp_fw_size, 0);
-		if (status != 0)
-			return status;
-	}
+void adreno_ringbuffer_stop(struct adreno_ringbuffer *rb)
+{
+	struct kgsl_device *device = rb->device;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
-	status = _ringbuffer_start_common(rb);
+	if (rb->flags & KGSL_FLAGS_STARTED) {
+		if (adreno_is_a200(adreno_dev))
+			kgsl_regwrite(rb->device, REG_CP_ME_CNTL, 0x10000000);
 
-	return status;
+		rb->flags &= ~KGSL_FLAGS_STARTED;
+	}
 }
 
 int adreno_ringbuffer_init(struct kgsl_device *device)
@@ -566,6 +497,20 @@
 		return status;
 	}
 
+	/* allocate memory for polling and timestamps */
+	/* This really can be at 4 byte alignment boundry but for using MMU
+	 * we need to make it at page boundary */
+	status = kgsl_allocate_contiguous(&rb->memptrs_desc,
+		sizeof(struct kgsl_rbmemptrs));
+
+	if (status != 0) {
+		adreno_ringbuffer_close(rb);
+		return status;
+	}
+
+	/* overlay structure on memptrs memory */
+	rb->memptrs = (struct kgsl_rbmemptrs *) rb->memptrs_desc.hostptr;
+
 	rb->global_ts = 0;
 
 	return 0;
@@ -576,6 +521,7 @@
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(rb->device);
 
 	kgsl_sharedmem_free(&rb->buffer_desc);
+	kgsl_sharedmem_free(&rb->memptrs_desc);
 
 	kfree(adreno_dev->pfp_fw);
 	kfree(adreno_dev->pm4_fw);
@@ -632,8 +578,7 @@
 	total_sizedwords += (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE) ? 2 : 0;
 
 	/* Add two dwords for the CP_INTERRUPT */
-	total_sizedwords +=
-		(drawctxt || (flags & KGSL_CMD_FLAGS_INTERNAL_ISSUE)) ?  2 : 0;
+	total_sizedwords += drawctxt ? 2 : 0;
 
 	/* context rollover */
 	if (adreno_is_a3xx(adreno_dev))
@@ -649,9 +594,6 @@
 	total_sizedwords += 3; /* sop timestamp */
 	total_sizedwords += 4; /* eop timestamp */
 
-	if (adreno_is_a20x(adreno_dev))
-		total_sizedwords += 2; /* CACHE_FLUSH */
-
 	if (drawctxt) {
 		total_sizedwords += 3; /* global timestamp without cache
 					* flush for non-zero context */
@@ -665,7 +607,7 @@
 
 	/* Add space for the power on shader fixup if we need it */
 	if (flags & KGSL_CMD_FLAGS_PWRON_FIXUP)
-		total_sizedwords += 9;
+		total_sizedwords += 5;
 
 	ringcmds = adreno_ringbuffer_allocspace(rb, drawctxt, total_sizedwords);
 
@@ -687,11 +629,6 @@
 	}
 
 	if (flags & KGSL_CMD_FLAGS_PWRON_FIXUP) {
-		/* Disable protected mode for the fixup */
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_SET_PROTECTED_MODE, 1));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, 0);
-
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, cp_nop_packet(1));
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
 				KGSL_PWRON_FIXUP_IDENTIFIER);
@@ -701,11 +638,6 @@
 			adreno_dev->pwron_fixup.gpuaddr);
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
 			adreno_dev->pwron_fixup_dwords);
-
-		/* Re-enable protected mode */
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			cp_type3_packet(CP_SET_PROTECTED_MODE, 1));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, 1);
 	}
 
 	/* start-of-pipeline timestamp */
@@ -777,8 +709,7 @@
 		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, (gpuaddr +
 			KGSL_MEMSTORE_OFFSET(KGSL_MEMSTORE_GLOBAL,
 				eoptimestamp)));
-		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu,
-			rb->global_ts);
+		GSL_RB_WRITE(rb->device, ringcmds, rcmd_gpu, rb->global_ts);
 	}
 
 	if (adreno_is_a20x(adreno_dev)) {
@@ -1083,7 +1014,7 @@
 		timestamp);
 
 	if (ret)
-		KGSL_DRV_ERR(device, "adreno_context_queue_cmd returned %d\n",
+		KGSL_DRV_ERR(device, "adreno_dispatcher_queue_cmd returned %d\n",
 				ret);
 	else {
 		/*
@@ -1102,89 +1033,9 @@
 		}
 	}
 
-	/*
-	 * Return -EPROTO if the device has faulted since the last time we
-	 * checked - userspace uses this to perform post-fault activities
-	 */
-	if (!ret && test_and_clear_bit(ADRENO_CONTEXT_FAULT, &drawctxt->priv))
-		ret = -EPROTO;
-
 	return ret;
 }
 
-unsigned int adreno_ringbuffer_get_constraint(struct kgsl_device *device,
-				struct kgsl_context *context)
-{
-	unsigned int pwrlevel = device->pwrctrl.active_pwrlevel;
-
-	switch (context->pwr_constraint.type) {
-	case KGSL_CONSTRAINT_PWRLEVEL: {
-		switch (context->pwr_constraint.sub_type) {
-		case KGSL_CONSTRAINT_PWR_MAX:
-			pwrlevel = device->pwrctrl.max_pwrlevel;
-			break;
-		case KGSL_CONSTRAINT_PWR_MIN:
-			pwrlevel = device->pwrctrl.min_pwrlevel;
-			break;
-		default:
-			break;
-		}
-	}
-	break;
-
-	}
-
-	return pwrlevel;
-}
-
-void adreno_ringbuffer_set_constraint(struct kgsl_device *device,
-			struct kgsl_cmdbatch *cmdbatch)
-{
-	unsigned int constraint;
-	struct kgsl_context *context = cmdbatch->context;
-	/*
-	 * Check if the context has a constraint and constraint flags are
-	 * set.
-	 */
-	if (context->pwr_constraint.type &&
-		((context->flags & KGSL_CONTEXT_PWR_CONSTRAINT) ||
-			(cmdbatch->flags & KGSL_CONTEXT_PWR_CONSTRAINT))) {
-
-		constraint = adreno_ringbuffer_get_constraint(device, context);
-
-		/*
-		 * If a constraint is already set, set a new constraint only
-		 * if it is faster.  If the requested constraint is the same
-		 * as the current one, update ownership and timestamp.
-		 */
-		if ((device->pwrctrl.constraint.type ==
-			KGSL_CONSTRAINT_NONE) || (constraint <
-			device->pwrctrl.constraint.hint.pwrlevel.level)) {
-
-			kgsl_pwrctrl_pwrlevel_change(device, constraint);
-			device->pwrctrl.constraint.type =
-					context->pwr_constraint.type;
-			device->pwrctrl.constraint.hint.
-					pwrlevel.level = constraint;
-			device->pwrctrl.constraint.owner_id = context->id;
-			device->pwrctrl.constraint.expires = jiffies +
-					device->pwrctrl.interval_timeout;
-			/* Trace the constraint being set by the driver */
-			trace_kgsl_constraint(device,
-					device->pwrctrl.constraint.type,
-					constraint, 1);
-		} else if ((device->pwrctrl.constraint.type ==
-				context->pwr_constraint.type) &&
-			(device->pwrctrl.constraint.hint.pwrlevel.level ==
-				constraint)) {
-			device->pwrctrl.constraint.owner_id = context->id;
-			device->pwrctrl.constraint.expires = jiffies +
-					device->pwrctrl.interval_timeout;
-		}
-	}
-
-}
-
 /* adreno_rindbuffer_submitcmd - submit userspace IBs to the GPU */
 int adreno_ringbuffer_submitcmd(struct adreno_device *adreno_dev,
 		struct kgsl_cmdbatch *cmdbatch)
@@ -1211,7 +1062,7 @@
 	commands are stored in the first node of the IB chain. We can skip that
 	if a context switch hasn't occured */
 
-	if ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) &&
+	if ((drawctxt->flags & CTXT_FLAGS_PREAMBLE) &&
 		!test_bit(CMDBATCH_FLAG_FORCE_PREAMBLE, &cmdbatch->priv) &&
 		(adreno_dev->drawctxt_active == drawctxt))
 		start_index = 1;
@@ -1292,9 +1143,6 @@
 		test_bit(ADRENO_DEVICE_PWRON_FIXUP, &adreno_dev->priv))
 		flags |= KGSL_CMD_FLAGS_PWRON_FIXUP;
 
-	/* Set the constraints before adding to ringbuffer */
-	adreno_ringbuffer_set_constraint(device, cmdbatch);
-
 	ret = adreno_ringbuffer_addcmds(&adreno_dev->ringbuffer,
 					drawctxt,
 					flags,
@@ -1316,7 +1164,7 @@
 	device->pwrctrl.irq_last = 0;
 	kgsl_trace_issueibcmds(device, context->id, cmdbatch,
 		cmdbatch->timestamp, cmdbatch->flags, ret,
-		drawctxt->type);
+		drawctxt ? drawctxt->type : 0);
 
 	kfree(link);
 	return ret;
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_ringbuffer.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_ringbuffer.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,6 +19,7 @@
  */
 
 #define KGSL_RB_SIZE (32 * 1024)
+#define KGSL_RB_BLKSIZE 16
 
 /* CP timestamp register */
 #define	REG_CP_TIMESTAMP		 REG_SCRATCH_REG0
@@ -27,18 +28,35 @@
 struct kgsl_device;
 struct kgsl_device_private;
 
+#define GSL_RB_MEMPTRS_SCRATCH_COUNT	 8
+struct kgsl_rbmemptrs {
+	int  rptr;
+	int  wptr_poll;
+};
+
+#define GSL_RB_MEMPTRS_RPTR_OFFSET \
+	(offsetof(struct kgsl_rbmemptrs, rptr))
+
+#define GSL_RB_MEMPTRS_WPTRPOLL_OFFSET \
+	(offsetof(struct kgsl_rbmemptrs, wptr_poll))
+
 struct adreno_ringbuffer {
 	struct kgsl_device *device;
 	uint32_t flags;
 
 	struct kgsl_memdesc buffer_desc;
 
+	struct kgsl_memdesc memptrs_desc;
+	struct kgsl_rbmemptrs *memptrs;
+
 	/*ringbuffer size */
 	unsigned int sizedwords;
 
 	unsigned int wptr; /* write pointer offset in dwords from baseaddr */
 
 	unsigned int global_ts;
+
+    unsigned int timestamp[KGSL_MEMSTORE_MAX];
 };
 
 
@@ -54,6 +72,25 @@
 /* enable timestamp (...scratch0) memory shadowing */
 #define GSL_RB_MEMPTRS_SCRATCH_MASK 0x1
 
+/* mem rptr */
+#define GSL_RB_CNTL_NO_UPDATE 0x0 /* enable */
+
+/**
+ * adreno_get_rptr - Get the current ringbuffer read pointer
+ * @rb -  the ringbuffer
+ *
+ * Get the current read pointer, which is written by the GPU.
+ */
+static inline unsigned int
+adreno_get_rptr(struct adreno_ringbuffer *rb)
+{
+	unsigned int result = rb->memptrs->rptr;
+	rmb();
+	return result;
+}
+
+#define GSL_RB_CNTL_POLL_EN 0x0 /* disable */
+
 /*
  * protected mode error checking below register address 0x800
  * note: if CP_INTERRUPT packet is used then checking needs
@@ -73,7 +110,9 @@
 
 int adreno_ringbuffer_warm_start(struct adreno_ringbuffer *rb);
 
-int adreno_ringbuffer_cold_start(struct adreno_ringbuffer *rb);
+int adreno_ringbuffer_start(struct adreno_ringbuffer *rb);
+
+void adreno_ringbuffer_stop(struct adreno_ringbuffer *rb);
 
 void adreno_ringbuffer_close(struct adreno_ringbuffer *rb);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/adreno_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/adreno_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/adreno_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -21,7 +21,6 @@
 #define TRACE_INCLUDE_FILE adreno_trace
 
 #include <linux/tracepoint.h>
-#include "kgsl_device.h"
 
 TRACE_EVENT(adreno_cmdbatch_queued,
 	TP_PROTO(struct kgsl_cmdbatch *cmdbatch, unsigned int queued),
@@ -265,36 +264,6 @@
 		__entry->ib2base, __entry->ib2size)
 );
 
-TRACE_EVENT(kgsl_user_pwrlevel_constraint,
-
-	TP_PROTO(struct kgsl_device *device, unsigned int id, unsigned int type,
-		unsigned int sub_type),
-
-	TP_ARGS(device, id, type, sub_type),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(unsigned int, id)
-		__field(unsigned int, type)
-		__field(unsigned int, sub_type)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->id = id;
-		__entry->type = type;
-		__entry->sub_type = sub_type;
-	),
-
-	TP_printk(
-		"d_name=%s ctx=%u constraint_type=%s constraint_subtype=%s",
-		__get_str(device_name), __entry->id,
-		__print_symbolic(__entry->type, KGSL_CONSTRAINT_TYPES),
-		__print_symbolic(__entry->sub_type,
-		KGSL_CONSTRAINT_PWRLEVEL_SUBTYPES)
-	)
-);
-
 #endif /* _ADRENO_TRACE_H */
 
 /* This part must be outside protection */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.c	2014-09-21 01:02:11.000000000 +0000
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/workqueue.h>
 #include <linux/dma-buf.h>
+
 #include <linux/vmalloc.h>
 #include <linux/pm_runtime.h>
 #include <linux/genlock.h>
@@ -40,7 +41,6 @@
 #include "kgsl_device.h"
 #include "kgsl_trace.h"
 #include "kgsl_sync.h"
-#include "adreno.h"
 
 #undef MODULE_PARAM_PREFIX
 #define MODULE_PARAM_PREFIX "kgsl."
@@ -62,6 +62,9 @@
 
 static void kgsl_mem_entry_detach_process(struct kgsl_mem_entry *entry);
 
+static void
+kgsl_put_process_private(struct kgsl_device *device,
+			 struct kgsl_process_private *private);
 /**
  * kgsl_trace_issueibcmds() - Call trace_issueibcmds by proxy
  * device: KGSL device
@@ -341,33 +344,27 @@
  */
 static int
 kgsl_mem_entry_attach_process(struct kgsl_mem_entry *entry,
-				   struct kgsl_device_private *dev_priv)
+				   struct kgsl_process_private *process)
 {
 	int ret;
-	struct kgsl_process_private *process = dev_priv->process_priv;
-
-	ret = kgsl_process_private_get(process);
-	if (!ret)
-		return -EBADF;
 
 	while (1) {
 		if (idr_pre_get(&process->mem_idr, GFP_KERNEL) == 0) {
 			ret = -ENOMEM;
-			goto err_put_proc_priv;
+			goto err;
 		}
 
 		spin_lock(&process->mem_lock);
 		ret = idr_get_new_above(&process->mem_idr, entry, 1,
 					&entry->id);
 		spin_unlock(&process->mem_lock);
+
 		if (ret == 0)
 			break;
 		else if (ret != -EAGAIN)
-			goto err_put_proc_priv;
+			goto err;
 	}
-
 	entry->priv = process;
-	entry->dev_priv = dev_priv;
 
 	spin_lock(&process->mem_lock);
 	ret = kgsl_mem_entry_track_gpuaddr(process, entry);
@@ -375,17 +372,14 @@
 		idr_remove(&process->mem_idr, entry->id);
 	spin_unlock(&process->mem_lock);
 	if (ret)
-		goto err_put_proc_priv;
+		goto err;
 	/* map the memory after unlocking if gpuaddr has been assigned */
 	if (entry->memdesc.gpuaddr) {
 		ret = kgsl_mmu_map(process->pagetable, &entry->memdesc);
 		if (ret)
 			kgsl_mem_entry_detach_process(entry);
 	}
-	return ret;
-
-err_put_proc_priv:
-	kgsl_process_private_put(process);
+err:
 	return ret;
 }
 
@@ -408,7 +402,6 @@
 
 	entry->priv->stats[entry->memtype].cur -= entry->memdesc.size;
 	spin_unlock(&entry->priv->mem_lock);
-	kgsl_process_private_put(entry->priv);
 
 	entry->priv = NULL;
 }
@@ -466,7 +459,7 @@
 	 * the context is destroyed. This will also prevent the pagetable
 	 * from being destroyed
 	 */
-	if (!kgsl_process_private_get(dev_priv->process_priv))
+	if (!kref_get_unless_zero(&dev_priv->process_priv->refcount))
 		goto fail_free_id;
 	context->device = dev_priv->device;
 	context->dev_priv = dev_priv;
@@ -513,29 +506,31 @@
  */
 int kgsl_context_detach(struct kgsl_context *context)
 {
+	struct kgsl_device *device;
 	int ret;
 
-	if (context == NULL)
+	if (context == NULL || kgsl_context_detached(context))
 		return -EINVAL;
 
+	device = context->device;
+
+	trace_kgsl_context_detach(device, context);
+
 	/*
 	 * Mark the context as detached to keep others from using
-	 * the context before it gets fully removed, and to make sure
-	 * we don't try to detach twice.
+	 * the context before it gets fully removed
 	 */
-	if (test_and_set_bit(KGSL_CONTEXT_DETACHED, &context->priv))
-		return -EINVAL;
-
-	trace_kgsl_context_detach(context->device, context);
+	set_bit(KGSL_CONTEXT_DETACHED, &context->priv);
 
-	ret = context->device->ftbl->drawctxt_detach(context);
+	ret = device->ftbl->drawctxt_detach(context);
 
 	/*
 	 * Cancel events after the device-specific context is
 	 * detached, to avoid possibly freeing memory while
 	 * it is still in use by the GPU.
 	 */
-	kgsl_context_cancel_events(context->device, context);
+
+	kgsl_context_cancel_events(device, context);
 
 	kgsl_context_put(context);
 
@@ -555,28 +550,13 @@
 
 	write_lock(&device->context_lock);
 	if (context->id != KGSL_CONTEXT_INVALID) {
-
-		/* Clear the timestamps in the memstore during destroy */
-		kgsl_sharedmem_writel(device, &device->memstore,
-			KGSL_MEMSTORE_OFFSET(context->id, soptimestamp), 0);
-		kgsl_sharedmem_writel(device, &device->memstore,
-			KGSL_MEMSTORE_OFFSET(context->id, eoptimestamp), 0);
-
-		/* clear device power constraint */
-		if (context->id == device->pwrctrl.constraint.owner_id) {
-			trace_kgsl_constraint(device,
-				device->pwrctrl.constraint.type,
-				device->pwrctrl.active_pwrlevel,
-				0);
-			device->pwrctrl.constraint.type = KGSL_CONSTRAINT_NONE;
-		}
-
 		idr_remove(&device->context_idr, context->id);
 		context->id = KGSL_CONTEXT_INVALID;
 	}
 	write_unlock(&device->context_lock);
 	kgsl_sync_timeline_destroy(context);
-	kgsl_process_private_put(context->proc_priv);
+	kgsl_put_process_private(device,
+				context->proc_priv);
 
 	device->ftbl->drawctxt_destroy(context);
 }
@@ -841,8 +821,9 @@
 	return;
 }
 
-void
-kgsl_process_private_put(struct kgsl_process_private *private)
+static void
+kgsl_put_process_private(struct kgsl_device *device,
+			 struct kgsl_process_private *private)
 {
 	mutex_lock(&kgsl_driver.process_mutex);
 
@@ -856,7 +837,7 @@
 	return;
 }
 
-/**
+/*
  * find_process_private() - Helper function to search for process private
  * @cur_dev_priv: Pointer to device private structure which contains pointers
  * to device and process_private structs.
@@ -871,8 +852,7 @@
 	mutex_lock(&kgsl_driver.process_mutex);
 	list_for_each_entry(private, &kgsl_driver.process_list, list) {
 		if (private->pid == task_tgid_nr(current)) {
-			if (!kgsl_process_private_get(private))
-				private = NULL;
+			kref_get(&private->refcount);
 			goto done;
 		}
 	}
@@ -897,7 +877,7 @@
 	return private;
 }
 
-/**
+/*
  * kgsl_get_process_private() - Used to find the process private structure
  * @cur_dev_priv: Current device pointer
  * Finds or creates a new porcess private structire and initializes its members
@@ -911,12 +891,13 @@
 
 	private = kgsl_find_process_private(cur_dev_priv);
 
-	if (!private)
-		return NULL;
-
 	mutex_lock(&private->process_private_mutex);
 
-	if (test_bit(KGSL_PROCESS_INIT, &private->priv))
+	/*
+	 * If debug root initialized then it means the rest of the fields
+	 * are also initialized
+	 */
+	if (private->debug_root)
 		goto done;
 
 	private->mem_rb = RB_ROOT;
@@ -937,15 +918,13 @@
 	if (kgsl_process_init_debugfs(private))
 		goto error;
 
-	set_bit(KGSL_PROCESS_INIT, &private->priv);
-
 done:
 	mutex_unlock(&private->process_private_mutex);
 	return private;
 
 error:
 	mutex_unlock(&private->process_private_mutex);
-	kgsl_process_private_put(private);
+	kgsl_put_process_private(cur_dev_priv->device, private);
 	return NULL;
 }
 
@@ -961,6 +940,8 @@
 		/* Fail if the wait times out */
 		BUG_ON(atomic_read(&device->active_cnt) > 0);
 
+		/* Force power on to do the stop */
+		kgsl_pwrctrl_enable(device);
 		result = device->ftbl->stop(device);
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
 	}
@@ -976,7 +957,6 @@
 	struct kgsl_process_private *private = dev_priv->process_priv;
 	struct kgsl_device *device = dev_priv->device;
 	struct kgsl_context *context;
-	struct kgsl_mem_entry *entry;
 	int next = 0;
 
 	filep->private_data = NULL;
@@ -1005,31 +985,6 @@
 
 		next = next + 1;
 	}
-
-	next = 0;
-	while (1) {
-		spin_lock(&private->mem_lock);
-		entry = idr_get_next(&private->mem_idr, &next);
-		if (entry == NULL) {
-			spin_unlock(&private->mem_lock);
-			break;
-		}
-		/*
-		 * If the free pending flag is not set it means that user space
-		 * did not free it's reference to this entry, in that case
-		 * free a reference to this entry, other references are from
-		 * within kgsl so they will be freed eventually by kgsl
-		 */
-		if (entry->dev_priv == dev_priv && !entry->pending_free) {
-			entry->pending_free = 1;
-			spin_unlock(&private->mem_lock);
-			trace_kgsl_mem_free(entry);
-			kgsl_mem_entry_put(entry);
-		} else {
-			spin_unlock(&private->mem_lock);
-		}
-		next = next + 1;
-	}
 	/*
 	 * Clean up any to-be-freed entries that belong to this
 	 * process and this device. This is done after the context
@@ -1040,10 +995,9 @@
 
 	result = kgsl_close_device(device);
 	mutex_unlock(&device->mutex);
-
 	kfree(dev_priv);
 
-	kgsl_process_private_put(private);
+	kgsl_put_process_private(device, private);
 
 	pm_runtime_put(device->parentdev);
 	return result;
@@ -1151,7 +1105,7 @@
 	if (device->open_count == 0) {
 		/* make sure power is on to stop the device */
 		kgsl_pwrctrl_enable(device);
-		device->ftbl->stop(device);
+		result = device->ftbl->stop(device);
 		kgsl_pwrctrl_set_state(device, KGSL_STATE_INIT);
 		atomic_dec(&device->active_cnt);
 	}
@@ -1319,12 +1273,10 @@
 static inline bool kgsl_mem_entry_set_pend(struct kgsl_mem_entry *entry)
 {
 	bool ret = false;
-
-	if (entry == NULL)
-		return false;
-
 	spin_lock(&entry->priv->mem_lock);
-	if (!entry->pending_free) {
+	if (entry && entry->pending_free) {
+		ret = false;
+	} else if (entry) {
 		entry->pending_free = 1;
 		ret = true;
 	}
@@ -1379,7 +1331,6 @@
 			result = -EINVAL;
 			break;
 		}
-
 		/*
 		 * Copy the reset status to value which also serves as
 		 * the out parameter
@@ -1414,8 +1365,8 @@
 
 	if (dev_priv->device->ftbl->setproperty)
 		result = dev_priv->device->ftbl->setproperty(
-			dev_priv, param->type, param->value,
-			param->sizebytes);
+			dev_priv->device, param->type,
+			param->value, param->sizebytes);
 
 	return result;
 }
@@ -1948,8 +1899,7 @@
 
 /**
  * _kgsl_cmdbatch_verify() - Perform a quick sanity check on a command batch
- * @device: Pointer to a KGSL instance that owns the command batch
- * @pagetable: Pointer to the pagetable for the current process
+ * @device: Pointer to a KGSL device that owns the command batch
  * @cmdbatch: Number of indirect buffers to make room for in the cmdbatch
  *
  * Do a quick sanity test on the list of indirect buffers in a command batch
@@ -1959,6 +1909,7 @@
 	struct kgsl_cmdbatch *cmdbatch)
 {
 	int i;
+
 	struct kgsl_process_private *private = dev_priv->process_priv;
 
 	for (i = 0; i < cmdbatch->ibcount; i++) {
@@ -2123,11 +2074,7 @@
 		cmdbatch, &param->timestamp);
 
 free_cmdbatch:
-	/*
-	 * -EPROTO is a "success" error - it just tells the user that the
-	 * context had previously faulted
-	 */
-	if (result && result != -EPROTO)
+	if (result)
 		kgsl_cmdbatch_destroy(cmdbatch);
 
 done:
@@ -2175,11 +2122,7 @@
 		cmdbatch, &param->timestamp);
 
 free_cmdbatch:
-	/*
-	 * -EPROTO is a "success" error - it just tells the user that the
-	 * context had previously faulted
-	 */
-	if (result && result != -EPROTO)
+	if (result)
 		kgsl_cmdbatch_destroy(cmdbatch);
 
 done:
@@ -2388,11 +2331,6 @@
 
 	trace_kgsl_mem_free(entry);
 
-	kgsl_memfree_hist_set_event(entry->priv->pid,
-				    entry->memdesc.gpuaddr,
-				    entry->memdesc.size,
-				    entry->memdesc.flags);
-
 	/*
 	 * First kgsl_mem_entry_put is for the reference that we took in
 	 * this function when calling kgsl_sharedmem_find_id, second one is
@@ -2475,8 +2413,10 @@
 
 	ret = -ERANGE;
 
-	if (phys == 0)
+	if (phys == 0) {
+		KGSL_CORE_ERR("kgsl_get_phys_file returned phys=0\n");
 		goto err;
+	}
 
 	/* Make sure the length of the region, the offset and the desired
 	 * size are all page aligned or bail
@@ -2484,13 +2424,19 @@
 	if ((len & ~PAGE_MASK) ||
 		(offset & ~PAGE_MASK) ||
 		(size & ~PAGE_MASK)) {
-		KGSL_CORE_ERR("length offset or size is not page aligned\n");
+		KGSL_CORE_ERR("length %lu, offset %u or size %u "
+				"is not page aligned\n",
+				len, offset, size);
 		goto err;
 	}
 
 	/* The size or offset can never be greater than the PMEM length */
-	if (offset >= len || size > len)
+	if (offset >= len || size > len) {
+		KGSL_CORE_ERR("offset %u or size %u "
+				"exceeds pmem length %lu\n",
+				offset, size, len);
 		goto err;
+	}
 
 	/* If size is 0, then adjust it to default to the size of the region
 	 * minus the offset.  If size isn't zero, then make sure that it will
@@ -2807,7 +2753,7 @@
 			| KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	entry->memdesc.flags = param->flags;
-	if (!kgsl_mmu_use_cpu_map(&dev_priv->device->mmu))
+	if (!kgsl_mmu_use_cpu_map(private->pagetable->mmu))
 		entry->memdesc.flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
@@ -2880,7 +2826,7 @@
 	/* echo back flags */
 	param->flags = entry->memdesc.flags;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result)
 		goto error_attach;
 
@@ -2910,9 +2856,6 @@
 		break;
 	}
 error:
-	/* Clear gpuaddr here so userspace doesn't get any wrong ideas */
-	param->gpuaddr = 0;
-
 	kfree(entry);
 	return result;
 }
@@ -3007,7 +2950,7 @@
 	bool full_flush = false;
 
 	if (param->id_list == NULL || param->count == 0
-			|| param->count > (PAGE_SIZE / sizeof(unsigned int)))
+			|| param->count > (UINT_MAX/sizeof(unsigned int)))
 		return -EINVAL;
 
 	id_list = kzalloc(param->count * sizeof(unsigned int), GFP_KERNEL);
@@ -3129,8 +3072,7 @@
 
 	align = (flags & KGSL_MEMALIGN_MASK) >> KGSL_MEMALIGN_SHIFT;
 	if (align >= 32) {
-		KGSL_CORE_ERR("Alignment too big, restricting to 2^31\n");
-
+		KGSL_CORE_ERR("Alignment too big, restricting to 2^32\n");
 		flags &= ~KGSL_MEMALIGN_MASK;
 		flags |= (31 << KGSL_MEMALIGN_SHIFT) & KGSL_MEMALIGN_MASK;
 	}
@@ -3142,8 +3084,8 @@
 	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_IOMMU)
 		entry->memdesc.priv |= KGSL_MEMDESC_GUARD_PAGE;
 
-	result = kgsl_allocate_user(dev_priv->device, &entry->memdesc,
-				private->pagetable, size, flags);
+	result = kgsl_allocate_user(&entry->memdesc, private->pagetable, size,
+				    flags);
 	if (result != 0)
 		goto err;
 
@@ -3171,7 +3113,7 @@
 	if (result)
 		return result;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result != 0)
 		goto err;
 
@@ -3193,19 +3135,18 @@
 			unsigned int cmd, void *data)
 {
 	struct kgsl_process_private *private = dev_priv->process_priv;
-	struct kgsl_device *device = dev_priv->device;
 	struct kgsl_gpumem_alloc_id *param = data;
 	struct kgsl_mem_entry *entry = NULL;
 	int result;
 
-	if (!kgsl_mmu_use_cpu_map(&device->mmu))
+	if (!kgsl_mmu_use_cpu_map(private->pagetable->mmu))
 		param->flags &= ~KGSL_MEMFLAGS_USE_CPU_MAP;
 
 	result = _gpumem_alloc(dev_priv, &entry, param->size, param->flags);
 	if (result != 0)
 		goto err;
 
-	result = kgsl_mem_entry_attach_process(entry, dev_priv);
+	result = kgsl_mem_entry_attach_process(entry, private);
 	if (result != 0)
 		goto err;
 
@@ -3302,12 +3243,11 @@
 };
 
 /**
- * kgsl_genlock_event_cb() - Event callback for a genlock timestamp event
- * @device: The KGSL device that expired the timestamp
- * @priv: private data for the event
- * @context_id: the context id that goes with the timestamp
- * @timestamp: the timestamp that triggered the event
- * @type: Type of event that signaled the callback
+ * kgsl_genlock_event_cb - Event callback for a genlock timestamp event
+ * @device - The KGSL device that expired the timestamp
+ * @priv - private data for the event
+ * @context_id - the context id that goes with the timestamp
+ * @timestamp - the timestamp that triggered the event
  *
  * Release a genlock lock following the expiration of a timestamp
  */
@@ -3428,7 +3368,7 @@
 static const struct {
 	unsigned int cmd;
 	kgsl_ioctl_func_t func;
-	unsigned int flags;
+	int flags;
 } kgsl_ioctl_funcs[] = {
 	KGSL_IOCTL_FUNC(IOCTL_KGSL_DEVICE_GETPROPERTY,
 			kgsl_ioctl_device_getproperty,
@@ -3707,7 +3647,7 @@
 static inline bool
 mmap_range_valid(unsigned long addr, unsigned long len)
 {
-	return ((ULONG_MAX - addr) > len) && ((addr + len) < TASK_SIZE);
+	return (addr + len) > addr && (addr + len) < TASK_SIZE;
 }
 
 static unsigned long
@@ -3864,7 +3804,7 @@
 	if (ret)
 		return ret;
 
-	vma->vm_flags |= entry->memdesc.ops->vmflags;
+	vma->vm_flags |= entry->memdesc.ops->vmflags(&entry->memdesc);
 
 	vma->vm_private_data = entry;
 
@@ -4191,7 +4131,7 @@
 			pwr->power_flags, pwr->active_pwrlevel);
 
 		KGSL_LOG_DUMP(device, "POWER: INTERVAL TIMEOUT = %08X ",
-				pwr->interval_timeout);
+				  pwr->interval_timeout);
 
 	}
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl.h	2014-09-21 01:02:11.000000000 +0000
@@ -146,7 +146,7 @@
 struct kgsl_cmdbatch;
 
 struct kgsl_memdesc_ops {
-	unsigned int vmflags;
+	int (*vmflags)(struct kgsl_memdesc *);
 	int (*vmfault)(struct kgsl_memdesc *, struct vm_area_struct *,
 		       struct vm_fault *);
 	void (*free)(struct kgsl_memdesc *memdesc);
@@ -178,7 +178,6 @@
 	unsigned int sglen_alloc;  /* Allocated entries in the sglist */
 	struct kgsl_memdesc_ops *ops;
 	unsigned int flags; /* Flags set from userspace */
-	struct device *dev;
 };
 
 /* List of different memory entry types */
@@ -203,7 +202,6 @@
 	struct kgsl_process_private *priv;
 	/* Initialized to 0, set to 1 when entry is marked for freeing */
 	int pending_free;
-	struct kgsl_device_private *dev_priv;
 };
 
 #ifdef CONFIG_MSM_KGSL_MMU_PAGE_FAULT
@@ -273,7 +271,7 @@
 		size = 1;
 
 	/* don't overflow */
-	if (size > UINT_MAX - gpuaddr)
+	if ((gpuaddr + size) < gpuaddr)
 		return 0;
 
 	if (gpuaddr >= memdesc->gpuaddr &&
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.c	2014-09-21 01:02:11.000000000 +0000
@@ -247,7 +247,7 @@
 
 static void print_mem_entry(struct seq_file *s, struct kgsl_mem_entry *entry)
 {
-	char flags[7];
+	char flags[6];
 	char usage[16];
 	struct kgsl_memdesc *m = &entry->memdesc;
 
@@ -256,16 +256,13 @@
 	flags[2] = get_alignflag(m);
 	flags[3] = get_cacheflag(m);
 	flags[4] = kgsl_memdesc_use_cpu_map(m) ? 'p' : '-';
-	flags[5] = (m->useraddr) ? 'Y' : 'N';
-	flags[6] = '\0';
+	flags[5] = '\0';
 
 	kgsl_get_memory_usage(usage, sizeof(usage), m->flags);
 
-	seq_printf(s, "%pK %pK %8zd %5d %6s %10s %16s %5d\n",
-			   (unsigned long *)(uintptr_t) m->gpuaddr,
-			   (unsigned long *) m->useraddr,
-				m->size, entry->id, flags,
-				memtype_str(entry->memtype), usage, m->sglen);
+	seq_printf(s, "%08x %08lx %8d %5d %5s %10s %16s %5d\n",
+			m->gpuaddr, m->useraddr, m->size, entry->id, flags,
+			memtype_str(entry->memtype), usage, m->sglen);
 }
 
 static int process_mem_print(struct seq_file *s, void *unused)
@@ -275,7 +272,7 @@
 	struct kgsl_process_private *private = s->private;
 	int next = 0;
 
-	seq_printf(s, "%8s %8s %8s %5s %6s %10s %16s %5s\n",
+	seq_printf(s, "%8s %8s %8s %5s %5s %10s %16s %5s\n",
 		   "gpuaddr", "useraddr", "size", "id", "flags", "type",
 		   "usage", "sglen");
 
@@ -304,36 +301,14 @@
 
 static int process_mem_open(struct inode *inode, struct file *file)
 {
-	struct kgsl_process_private *private = inode->i_private;
-
-	/*
-	 * Hold a reference count on the process while open
-	 * in case the process tries to die in the meantime.
-	 * If the process is already dying we cannot get a
-	 * refcount, print nothing.
-	 */
-
-	if (!private || !kgsl_process_private_get(private))
-		return -ENODEV;
-
-	return single_open(file, process_mem_print, private);
-}
-
-static int process_mem_release(struct inode *inode, struct file *file)
-{
-	struct kgsl_process_private *private = inode->i_private;
-
-	if (private)
-		kgsl_process_private_put(private);
-
-	return single_release(inode, file);
+	return single_open(file, process_mem_print, inode->i_private);
 }
 
 static const struct file_operations process_mem_fops = {
 	.open = process_mem_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = process_mem_release,
+	.release = single_release,
 };
 
 
@@ -375,7 +350,7 @@
 	 * So if debugfs is disabled in kernel, return as
 	 * success.
 	 */
-	dentry = debugfs_create_file("mem", 0444, private->debug_root, private,
+	dentry = debugfs_create_file("mem", 0400, private->debug_root, private,
 			    &process_mem_fops);
 
 	if (IS_ERR(dentry)) {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_debugfs.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_debugfs.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2011,2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,7 +35,7 @@
 static inline void kgsl_device_debugfs_init(struct kgsl_device *device) { }
 static inline void kgsl_core_debugfs_close(void) { }
 static inline struct dentry *kgsl_get_debugfs_dir(void) { return NULL; }
-static inline int kgsl_process_init_debugfs(struct kgsl_process_private *priv)
+static inline int kgsl_process_init_debugfs(struct kgsl_process_private *)
 {
 	return 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_device.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_device.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_device.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_device.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -127,8 +127,8 @@
 	void (*drawctxt_destroy) (struct kgsl_context *context);
 	long (*ioctl) (struct kgsl_device_private *dev_priv,
 		unsigned int cmd, void *data);
-	int (*setproperty) (struct kgsl_device_private *dev_priv,
-		enum kgsl_property_type type, void __user *value,
+	int (*setproperty) (struct kgsl_device *device,
+		enum kgsl_property_type type, void *value,
 		unsigned int sizebytes);
 	int (*postmortem_dump) (struct kgsl_device *device, int manual);
 	void (*drawctxt_sched)(struct kgsl_device *device,
@@ -311,6 +311,7 @@
 };
 
 void kgsl_process_events(struct work_struct *work);
+void kgsl_check_fences(struct work_struct *work);
 
 #define KGSL_DEVICE_COMMON_INIT(_dev) \
 	.hwaccess_gate = COMPLETION_INITIALIZER((_dev).hwaccess_gate),\
@@ -358,10 +359,6 @@
  * @pagefault: flag set if this context caused a pagefault.
  * @pagefault_ts: global timestamp of the pagefault, if KGSL_CONTEXT_PAGEFAULT
  * is set.
- * @flags: flags from userspace controlling the behavior of this context
- * @fault_count: number of times gpu hanged in last _context_throttle_time ms
- * @fault_time: time of the first gpu hang in last _context_throttle_time ms
- * @pwr_constraint: power constraint from userspace for this context
  */
 struct kgsl_context {
 	struct kref refcount;
@@ -377,29 +374,10 @@
 	struct list_head events;
 	struct list_head events_list;
 	unsigned int pagefault_ts;
-	unsigned int flags;
-	unsigned int fault_count;
-	unsigned long fault_time;
-	struct kgsl_pwr_constraint pwr_constraint;
 };
 
-/**
- * struct kgsl_process_private -  Private structure for a KGSL process (across
- * all devices)
- * @priv: Internal flags, use KGSL_PROCESS_* values
- * @pid: ID for the task owner of the process
- * @mem_lock: Spinlock to protect the process memory lists
- * @refcount: kref object for reference counting the process
- * @process_private_mutex: Mutex to synchronize access to the process struct
- * @mem_rb: RB tree node for the memory owned by this process
- * @idr: Iterator for assigning IDs to memory allocations
- * @pagetable: Pointer to the pagetable owned by this process
- * @kobj: Pointer to a kobj for the sysfs directory for this process
- * @debug_root: Pointer to the debugfs root for this process
- * @stats: Memory allocation statistics for this process
- */
 struct kgsl_process_private {
-	unsigned long priv;
+	unsigned int refcnt;
 	pid_t pid;
 	spinlock_t mem_lock;
 
@@ -421,14 +399,6 @@
 	} stats[KGSL_MEM_ENTRY_MAX];
 };
 
-/**
- * enum kgsl_process_priv_flags - Private flags for kgsl_process_private
- * @KGSL_PROCESS_INIT: Set if the process structure has been set up
- */
-enum kgsl_process_priv_flags {
-	KGSL_PROCESS_INIT = 0,
-};
-
 struct kgsl_device_private {
 	struct kgsl_device *device;
 	struct kgsl_process_private *process_priv;
@@ -661,7 +631,7 @@
  * Find the context associated with the given ID number, increase the reference
  * count on it and return it.  The caller must make sure that this call is
  * paired with a kgsl_context_put. This function validates that the context id
- * given is owned by the dev_priv instancet that is passed in.  See
+ * given is owned by the dev_priv instancet that is passed in.  see
  * kgsl_context_get for the internal version that doesn't do the check
  */
 static inline struct kgsl_context *kgsl_context_get_owner(
@@ -712,24 +682,6 @@
 void kgsl_cmdbatch_destroy_object(struct kref *kref);
 
 /**
-* kgsl_process_private_get() - increment the refcount on a kgsl_process_private
-*   struct
-* @process: Pointer to the KGSL process_private
-*
-* Returns 0 if the structure is invalid and a reference count could not be
-* obtained, nonzero otherwise.
-*/
-static inline int kgsl_process_private_get(struct kgsl_process_private *process)
-{
-	int ret = 0;
-	if (process != NULL)
-		ret = kref_get_unless_zero(&process->refcount);
-	return ret;
-}
-
-void kgsl_process_private_put(struct kgsl_process_private *private);
-
-/**
  * kgsl_cmdbatch_put() - Decrement the refcount for a command batch object
  * @cmdbatch: Pointer to the command batch object
  */
@@ -748,16 +700,7 @@
  */
 static inline int kgsl_cmdbatch_sync_pending(struct kgsl_cmdbatch *cmdbatch)
 {
-	int ret;
-
-	if (cmdbatch == NULL)
-		return 0;
-
-	spin_lock(&cmdbatch->lock);
-	ret = list_empty(&cmdbatch->synclist) ? 0 : 1;
-	spin_unlock(&cmdbatch->lock);
-
-	return ret;
+	return list_empty(&cmdbatch->synclist) ? 0 : 1;
 }
 
 #if defined(CONFIG_GPU_TRACEPOINTS)
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_drm.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_drm.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_drm.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_drm.c	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -16,9 +16,7 @@
  */
 #include "drmP.h"
 #include "drm.h"
-
-#include <linux/msm_ion.h>
-#include <linux/genlock.h>
+#include <linux/android_pmem.h>
 
 #include "kgsl.h"
 #include "kgsl_device.h"
@@ -29,7 +27,7 @@
 #define DRIVER_AUTHOR           "Qualcomm"
 #define DRIVER_NAME             "kgsl"
 #define DRIVER_DESC             "KGSL DRM"
-#define DRIVER_DATE             "20121107"
+#define DRIVER_DATE             "20100127"
 
 #define DRIVER_MAJOR            2
 #define DRIVER_MINOR            1
@@ -108,7 +106,6 @@
 	uint32_t type;
 	struct kgsl_memdesc memdesc;
 	struct kgsl_pagetable *pagetable;
-	struct ion_handle *ion_handle;
 	uint64_t mmap_offset;
 	int bufcount;
 	int flags;
@@ -120,8 +117,6 @@
 		uint32_t gpuaddr;
 	} bufs[DRM_KGSL_GEM_MAX_BUFFERS];
 
-	struct genlock_handle *glock_handle[DRM_KGSL_GEM_MAX_BUFFERS];
-
 	int bound;
 	int lockpid;
 	/* Put these here to avoid allocing all the time */
@@ -134,18 +129,86 @@
 	struct list_head wait_list;
 };
 
-static struct ion_client *kgsl_drm_ion_client;
-
 static int kgsl_drm_inited = DRM_KGSL_NOT_INITED;
 
 /* This is a global list of all the memory currently mapped in the MMU */
 static struct list_head kgsl_mem_list;
 
+static void kgsl_gem_mem_flush(struct kgsl_memdesc *memdesc, int type, int op)
+{
+	int cacheop = 0;
+
+	switch (op) {
+	case DRM_KGSL_GEM_CACHE_OP_TO_DEV:
+		if (type & (DRM_KGSL_GEM_CACHE_WBACK |
+			    DRM_KGSL_GEM_CACHE_WBACKWA))
+			cacheop = KGSL_CACHE_OP_CLEAN;
+
+		break;
+
+	case DRM_KGSL_GEM_CACHE_OP_FROM_DEV:
+		if (type & (DRM_KGSL_GEM_CACHE_WBACK |
+			    DRM_KGSL_GEM_CACHE_WBACKWA |
+			    DRM_KGSL_GEM_CACHE_WTHROUGH))
+			cacheop = KGSL_CACHE_OP_INV;
+	}
+
+	kgsl_cache_range_op(memdesc, cacheop);
+}
+
+/* TODO:
+ * Add vsync wait */
+
+static int kgsl_drm_load(struct drm_device *dev, unsigned long flags)
+{
+	return 0;
+}
+
+static int kgsl_drm_unload(struct drm_device *dev)
+{
+	return 0;
+}
+
 struct kgsl_drm_device_priv {
 	struct kgsl_device *device[KGSL_DEVICE_MAX];
 	struct kgsl_device_private *devpriv[KGSL_DEVICE_MAX];
 };
 
+void kgsl_drm_preclose(struct drm_device *dev, struct drm_file *file_priv)
+{
+}
+
+static int kgsl_drm_suspend(struct drm_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int kgsl_drm_resume(struct drm_device *dev)
+{
+	return 0;
+}
+
+static void
+kgsl_gem_free_mmap_offset(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_kgsl_gem_object *priv = obj->driver_private;
+	struct drm_map_list *list;
+
+	list = &obj->map_list;
+	drm_ht_remove_item(&mm->offset_hash, &list->hash);
+	if (list->file_offset_node) {
+		drm_mm_put_block(list->file_offset_node);
+		list->file_offset_node = NULL;
+	}
+
+	kfree(list->map);
+	list->map = NULL;
+
+	priv->mmap_offset = 0;
+}
+
 static int
 kgsl_gem_memory_allocated(struct drm_gem_object *obj)
 {
@@ -156,10 +219,8 @@
 static int
 kgsl_gem_alloc_memory(struct drm_gem_object *obj)
 {
+    struct kgsl_mmu *mmu;
 	struct drm_kgsl_gem_object *priv = obj->driver_private;
-	struct kgsl_mmu *mmu;
-	struct sg_table *sg_table;
-	struct scatterlist *s;
 	int index;
 	int result = 0;
 
@@ -167,19 +228,11 @@
 
 	if (kgsl_gem_memory_allocated(obj) || TYPE_IS_FD(priv->type))
 		return 0;
-
-	if (priv->pagetable == NULL) {
-		/* Hard coded to use A2X device for MSM7X27 and MSM8625
-		 * Others to use A3X device
-		 */
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM8625)
-		mmu = &kgsl_get_device(KGSL_DEVICE_2D0)->mmu;
-#else
-		mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
-#endif
-
-		priv->pagetable = kgsl_mmu_getpagetable(mmu,
-					KGSL_MMU_GLOBAL_PT);
+    
+    mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
+	
+    if (priv->pagetable == NULL) {
+		priv->pagetable = kgsl_mmu_getpagetable(mmu, KGSL_MMU_GLOBAL_PT);
 
 		if (priv->pagetable == NULL) {
 			DRM_ERROR("Unable to get the GPU MMU pagetable\n");
@@ -190,62 +243,15 @@
 	if (TYPE_IS_PMEM(priv->type)) {
 		if (priv->type == DRM_KGSL_GEM_TYPE_EBI ||
 		    priv->type & DRM_KGSL_GEM_PMEM_EBI) {
-			priv->ion_handle = ion_alloc(kgsl_drm_ion_client,
-				obj->size * priv->bufcount, PAGE_SIZE,
-				ION_HEAP(ION_SF_HEAP_ID), 0);
-			if (IS_ERR_OR_NULL(priv->ion_handle)) {
-				DRM_ERROR(
-				"Unable to allocate ION Phys memory handle\n");
-				return -ENOMEM;
-			}
-
-			priv->memdesc.pagetable = priv->pagetable;
-
-			result = ion_phys(kgsl_drm_ion_client,
-				priv->ion_handle, (ion_phys_addr_t *)
-				&priv->memdesc.physaddr, &priv->memdesc.size);
-			if (result) {
-				DRM_ERROR(
-				"Unable to get ION Physical memory address\n");
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-
-			result = memdesc_sg_phys(&priv->memdesc,
-				priv->memdesc.physaddr, priv->memdesc.size);
-			if (result) {
-				DRM_ERROR(
-				"Unable to get sg list\n");
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-
-			result = kgsl_mmu_get_gpuaddr(priv->pagetable,
-							&priv->memdesc);
-			if (result) {
-				DRM_ERROR(
-				"kgsl_mmu_get_gpuaddr failed. result = %d\n",
-				result);
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
-			result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-			if (result) {
-				DRM_ERROR(
-				"kgsl_mmu_map failed.  result = %d\n", result);
-				kgsl_mmu_put_gpuaddr(priv->pagetable,
-							&priv->memdesc);
-				ion_free(kgsl_drm_ion_client,
-					priv->ion_handle);
-				priv->ion_handle = NULL;
-				return result;
-			}
+				result = kgsl_sharedmem_ebimem_user(
+						&priv->memdesc,
+						priv->pagetable,
+						obj->size * priv->bufcount);
+				if (result) {
+					DRM_ERROR(
+					"Unable to allocate PMEM memory\n");
+					return result;
+				}
 		}
 		else
 			return -EINVAL;
@@ -256,53 +262,33 @@
 			priv->type & DRM_KGSL_GEM_CACHE_MASK)
 				list_add(&priv->list, &kgsl_mem_list);
 
-		priv->memdesc.pagetable = priv->pagetable;
-
-		priv->ion_handle = ion_alloc(kgsl_drm_ion_client,
-				obj->size * priv->bufcount, PAGE_SIZE,
-				ION_HEAP(ION_IOMMU_HEAP_ID), 0);
-		if (IS_ERR_OR_NULL(priv->ion_handle)) {
-			DRM_ERROR(
-				"Unable to allocate ION IOMMU memory handle\n");
-				return -ENOMEM;
-		}
-
-		sg_table = ion_sg_table(kgsl_drm_ion_client,
-				priv->ion_handle);
-		if (IS_ERR_OR_NULL(priv->ion_handle)) {
-			DRM_ERROR(
-			"Unable to get ION sg table\n");
-			goto memerr;
-		}
-
-		priv->memdesc.sg = sg_table->sgl;
-
-		/* Calculate the size of the memdesc from the sglist */
-
-		priv->memdesc.sglen = 0;
-
-		for (s = priv->memdesc.sg; s != NULL; s = sg_next(s)) {
-			priv->memdesc.size += s->length;
-			priv->memdesc.sglen++;
-		}
+		result = kgsl_sharedmem_page_alloc_user(&priv->memdesc,
+					priv->pagetable,
+					obj->size * priv->bufcount);
 
-		result = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
-		if (result) {
-			DRM_ERROR(
-			"kgsl_mmu_get_gpuaddr failed.  result = %d\n", result);
-			goto memerr;
-		}
-		result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-		if (result) {
-			DRM_ERROR(
-			"kgsl_mmu_map failed.  result = %d\n", result);
-			kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
-			goto memerr;
+		if (result != 0) {
+				DRM_ERROR(
+				"Unable to allocate Vmalloc user memory\n");
+				return result;
 		}
-
 	} else
 		return -EINVAL;
 
+	/* TODO would be good to cleanup in the error paths, but right now I
+	 * just need it to work enough to run some simple tests..
+	 */
+	result = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
+	if (result) {
+		DRM_ERROR("kgsl_mmu_get_gpuaddr failed.  result = %d\n", result);
+		return result;
+	}
+	result = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
+	if (result) {
+		DRM_ERROR("kgsl_mmu_map failed.  result = %d\n", result);
+		kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
+		return result;
+	}
+
 	for (index = 0; index < priv->bufcount; index++) {
 		priv->bufs[index].offset = index * obj->size;
 		priv->bufs[index].gpuaddr =
@@ -311,46 +297,21 @@
 	}
 	priv->flags |= DRM_KGSL_GEM_FLAG_MAPPED;
 
-
 	return 0;
-
-memerr:
-	ion_free(kgsl_drm_ion_client,
-		priv->ion_handle);
-	priv->ion_handle = NULL;
-	return -ENOMEM;
-
 }
 
 static void
 kgsl_gem_free_memory(struct drm_gem_object *obj)
 {
 	struct drm_kgsl_gem_object *priv = obj->driver_private;
-	int index;
 
 	if (!kgsl_gem_memory_allocated(obj) || TYPE_IS_FD(priv->type))
 		return;
 
-	if (priv->memdesc.gpuaddr) {
-		kgsl_mmu_unmap(priv->memdesc.pagetable, &priv->memdesc);
-		kgsl_mmu_put_gpuaddr(priv->memdesc.pagetable, &priv->memdesc);
-	}
-
-	/* ION will take care of freeing the sg table. */
-	priv->memdesc.sg = NULL;
-	priv->memdesc.sglen = 0;
-
-	if (priv->ion_handle)
-		ion_free(kgsl_drm_ion_client, priv->ion_handle);
-
-	priv->ion_handle = NULL;
-
-	memset(&priv->memdesc, 0, sizeof(priv->memdesc));
+	kgsl_gem_mem_flush(&priv->memdesc,  priv->type,
+			   DRM_KGSL_GEM_CACHE_OP_FROM_DEV);
 
-	for (index = 0; index < priv->bufcount; index++) {
-		if (priv->glock_handle[index])
-			genlock_put_handle(priv->glock_handle[index]);
-	}
+	kgsl_sharedmem_free(&priv->memdesc);
 
 	kgsl_mmu_putpagetable(priv->pagetable);
 	priv->pagetable = NULL;
@@ -383,10 +344,66 @@
 kgsl_gem_free_object(struct drm_gem_object *obj)
 {
 	kgsl_gem_free_memory(obj);
+	kgsl_gem_free_mmap_offset(obj);
 	drm_gem_object_release(obj);
 	kfree(obj->driver_private);
 }
 
+static int
+kgsl_gem_create_mmap_offset(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_kgsl_gem_object *priv = obj->driver_private;
+	struct drm_map_list *list;
+	int msize;
+
+	list = &obj->map_list;
+	list->map = kzalloc(sizeof(struct drm_map_list), GFP_KERNEL);
+	if (list->map == NULL) {
+		DRM_ERROR("Unable to allocate drm_map_list\n");
+		return -ENOMEM;
+	}
+
+	msize = obj->size * priv->bufcount;
+
+	list->map->type = _DRM_GEM;
+	list->map->size = msize;
+	list->map->handle = obj;
+
+	/* Allocate a mmap offset */
+	list->file_offset_node = drm_mm_search_free(&mm->offset_manager,
+						    msize / PAGE_SIZE,
+						    0, 0);
+
+	if (!list->file_offset_node) {
+		DRM_ERROR("Failed to allocate offset for %d\n", obj->name);
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	list->file_offset_node = drm_mm_get_block(list->file_offset_node,
+						  msize / PAGE_SIZE, 0);
+
+	if (!list->file_offset_node) {
+		DRM_ERROR("Unable to create the file_offset_node\n");
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	list->hash.key = list->file_offset_node->start;
+	if (drm_ht_insert_item(&mm->offset_hash, &list->hash)) {
+		DRM_ERROR("Failed to add to map hash\n");
+		drm_mm_put_block(list->file_offset_node);
+		kfree(list->map);
+		return -ENOMEM;
+	}
+
+	priv->mmap_offset = ((uint64_t) list->hash.key) << PAGE_SHIFT;
+
+	return 0;
+}
+
 int
 kgsl_gem_obj_addr(int drm_fd, int handle, unsigned long *start,
 			unsigned long *len)
@@ -433,6 +450,9 @@
 			priv->bufs[priv->active].offset;
 
 		*len = priv->memdesc.size;
+
+		kgsl_gem_mem_flush(&priv->memdesc,
+				   priv->type, DRM_KGSL_GEM_CACHE_OP_TO_DEV);
 	} else {
 		*start = 0;
 		*len = 0;
@@ -463,7 +483,10 @@
 	priv->active = 0;
 	priv->bound = 0;
 
-	priv->type = DRM_KGSL_GEM_TYPE_KMEM;
+	/* To preserve backwards compatability, the default memory source
+	   is EBI */
+
+	priv->type = DRM_KGSL_GEM_TYPE_PMEM | DRM_KGSL_GEM_PMEM_EBI;
 
 	ret = drm_gem_handle_create(file_priv, obj, handle);
 
@@ -505,11 +528,8 @@
 	}
 
 	ret = kgsl_gem_init_obj(dev, file_priv, obj, &handle);
-	if (ret) {
-		drm_gem_object_release(obj);
-		DRM_ERROR("Unable to initialize GEM object ret = %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	create->handle = handle;
 	return 0;
@@ -582,167 +602,6 @@
 }
 
 int
-kgsl_gem_create_from_ion_ioctl(struct drm_device *dev, void *data,
-		      struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_create_from_ion *args = data;
-	struct drm_gem_object *obj;
-	struct ion_handle *ion_handle;
-	struct drm_kgsl_gem_object *priv;
-	struct sg_table *sg_table;
-	struct scatterlist *s;
-	int ret, handle;
-	unsigned long size;
-	struct kgsl_mmu *mmu;
-
-	ion_handle = ion_import_dma_buf(kgsl_drm_ion_client, args->ion_fd);
-	if (IS_ERR_OR_NULL(ion_handle)) {
-		DRM_ERROR("Unable to import dmabuf.  Error number = %d\n",
-			(int)PTR_ERR(ion_handle));
-		return -EINVAL;
-	}
-
-	ion_handle_get_size(kgsl_drm_ion_client, ion_handle, &size);
-
-	if (size == 0) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		DRM_ERROR(
-		"cannot create GEM object from zero size ION buffer\n");
-		return -EINVAL;
-	}
-
-	obj = drm_gem_object_alloc(dev, size);
-
-	if (obj == NULL) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		DRM_ERROR("Unable to allocate the GEM object\n");
-		return -ENOMEM;
-	}
-
-	ret = kgsl_gem_init_obj(dev, file_priv, obj, &handle);
-	if (ret) {
-		ion_free(kgsl_drm_ion_client, ion_handle);
-		drm_gem_object_release(obj);
-		DRM_ERROR("Unable to initialize GEM object ret = %d\n", ret);
-		return ret;
-	}
-
-	priv = obj->driver_private;
-	priv->ion_handle = ion_handle;
-
-	priv->type = DRM_KGSL_GEM_TYPE_KMEM;
-	list_add(&priv->list, &kgsl_mem_list);
-
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM8625)
-	mmu = &kgsl_get_device(KGSL_DEVICE_2D0)->mmu;
-#else
-	mmu = &kgsl_get_device(KGSL_DEVICE_3D0)->mmu;
-#endif
-
-	priv->pagetable = kgsl_mmu_getpagetable(mmu, KGSL_MMU_GLOBAL_PT);
-
-	priv->memdesc.pagetable = priv->pagetable;
-
-	sg_table = ion_sg_table(kgsl_drm_ion_client,
-		priv->ion_handle);
-	if (IS_ERR_OR_NULL(priv->ion_handle)) {
-		DRM_ERROR("Unable to get ION sg table\n");
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-
-	priv->memdesc.sg = sg_table->sgl;
-
-	/* Calculate the size of the memdesc from the sglist */
-
-	priv->memdesc.sglen = 0;
-
-	for (s = priv->memdesc.sg; s != NULL; s = sg_next(s)) {
-		priv->memdesc.size += s->length;
-		priv->memdesc.sglen++;
-	}
-
-	ret = kgsl_mmu_get_gpuaddr(priv->pagetable, &priv->memdesc);
-	if (ret) {
-		DRM_ERROR("kgsl_mmu_get_gpuaddr failed.  ret = %d\n", ret);
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-	ret = kgsl_mmu_map(priv->pagetable, &priv->memdesc);
-	if (ret) {
-		DRM_ERROR("kgsl_mmu_map failed.  ret = %d\n", ret);
-		kgsl_mmu_put_gpuaddr(priv->pagetable, &priv->memdesc);
-		ion_free(kgsl_drm_ion_client,
-			priv->ion_handle);
-		priv->ion_handle = NULL;
-		kgsl_mmu_putpagetable(priv->pagetable);
-		drm_gem_object_release(obj);
-		kfree(priv);
-		return -ENOMEM;
-	}
-
-	priv->bufs[0].offset = 0;
-	priv->bufs[0].gpuaddr = priv->memdesc.gpuaddr;
-	priv->flags |= DRM_KGSL_GEM_FLAG_MAPPED;
-
-	args->handle = handle;
-	return 0;
-}
-
-int
-kgsl_gem_get_ion_fd_ioctl(struct drm_device *dev, void *data,
-			struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_get_ion_fd *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int ret = 0;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	if (TYPE_IS_FD(priv->type))
-		ret = -EINVAL;
-	else if (TYPE_IS_PMEM(priv->type) || TYPE_IS_MEM(priv->type)) {
-		if (priv->ion_handle) {
-			args->ion_fd = ion_share_dma_buf_fd(
-				kgsl_drm_ion_client, priv->ion_handle);
-			if (args->ion_fd < 0) {
-				DRM_ERROR(
-				"Could not share ion buffer. Error = %d\n",
-					args->ion_fd);
-				ret = -EINVAL;
-			}
-		} else {
-			DRM_ERROR("GEM object has no ion memory allocated.\n");
-			ret = -EINVAL;
-		}
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return ret;
-}
-
-int
 kgsl_gem_setmemtype_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv)
 {
@@ -841,9 +700,13 @@
 
 	if (ret) {
 		DRM_ERROR("Unable to allocate object memory\n");
+	} else if (!priv->mmap_offset) {
+		ret = kgsl_gem_create_mmap_offset(obj);
+		if (ret)
+			DRM_ERROR("Unable to create a mmap offset\n");
 	}
 
-	args->offset = 0;
+	args->offset = priv->mmap_offset;
 
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
@@ -855,7 +718,33 @@
 kgsl_gem_mmap_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv)
 {
-	/* Ion is used for mmap at this time */
+	struct drm_kgsl_gem_mmap *args = data;
+	struct drm_gem_object *obj;
+	unsigned long addr;
+
+	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
+
+	if (obj == NULL) {
+		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
+		return -EBADF;
+	}
+
+	down_write(&current->mm->mmap_sem);
+
+	addr = do_mmap(obj->filp, 0, args->size,
+		       PROT_READ | PROT_WRITE, MAP_SHARED,
+		       args->offset);
+
+	up_write(&current->mm->mmap_sem);
+
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+
+	if (IS_ERR((void *) addr))
+		return addr;
+
+	args->hostptr = (uint32_t) addr;
 	return 0;
 }
 
@@ -888,6 +777,18 @@
 		return ret;
 	}
 
+	if (priv->mmap_offset == 0) {
+		ret = kgsl_gem_create_mmap_offset(obj);
+		if (ret) {
+			drm_gem_object_unreference(obj);
+			mutex_unlock(&dev->struct_mutex);
+			return ret;
+		}
+	}
+
+	args->offset = priv->mmap_offset;
+	args->phys = priv->memdesc.physaddr;
+
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
@@ -914,11 +815,6 @@
 	mutex_lock(&dev->struct_mutex);
 	priv = obj->driver_private;
 
-	if (!kgsl_gem_memory_allocated(obj)) {
-		DRM_ERROR("Memory not allocated for this object\n");
-		goto out;
-	}
-
 	for (index = 0; index < priv->bufcount; index++) {
 		args->offset[index] = priv->bufs[index].offset;
 		args->gpuaddr[index] = priv->bufs[index].gpuaddr;
@@ -929,75 +825,12 @@
 
 	ret = 0;
 
-out:
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
 	return ret;
 }
 
-/* Get the genlock handles base off the GEM handle
- */
-
-int
-kgsl_gem_get_glock_handles_ioctl(struct drm_device *dev, void *data,
-					struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_glockinfo *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int index;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	for (index = 0; index < priv->bufcount; index++) {
-		args->glockhandle[index] = genlock_get_fd_handle(
-						priv->glock_handle[index]);
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-	return 0;
-}
-
-int
-kgsl_gem_set_glock_handles_ioctl(struct drm_device *dev, void *data,
-					struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_glockinfo *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-	int index;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	for (index = 0; index < priv->bufcount; index++) {
-		priv->glock_handle[index] = genlock_get_handle_fd(
-						args->glockhandle[index]);
-	}
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return 0;
-}
-
 int
 kgsl_gem_set_bufcount_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
@@ -1040,32 +873,6 @@
 }
 
 int
-kgsl_gem_get_bufcount_ioctl(struct drm_device *dev, void *data,
-			  struct drm_file *file_priv)
-{
-	struct drm_kgsl_gem_bufcount *args = data;
-	struct drm_gem_object *obj;
-	struct drm_kgsl_gem_object *priv;
-
-	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-
-	if (obj == NULL) {
-		DRM_ERROR("Invalid GEM handle %x\n", args->handle);
-		return -EBADF;
-	}
-
-	mutex_lock(&dev->struct_mutex);
-	priv = obj->driver_private;
-
-	args->bufcount =  priv->bufcount;
-
-	drm_gem_object_unreference(obj);
-	mutex_unlock(&dev->struct_mutex);
-
-	return 0;
-}
-
-int
 kgsl_gem_set_active_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
@@ -1084,15 +891,9 @@
 	mutex_lock(&dev->struct_mutex);
 	priv = obj->driver_private;
 
-	if (args->active < 0 || args->active >= priv->bufcount) {
-		DRM_ERROR("Invalid active buffer %d\n", args->active);
-		goto out;
-	}
-
 	priv->active = args->active;
 	ret = 0;
 
-out:
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
 
@@ -1159,6 +960,122 @@
 	}
 }
 
+static struct vm_operations_struct kgsl_gem_kmem_vm_ops = {
+	.fault = kgsl_gem_kmem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static struct vm_operations_struct kgsl_gem_phys_vm_ops = {
+	.fault = kgsl_gem_phys_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+/* This is a clone of the standard drm_gem_mmap function modified to allow
+   us to properly map KMEM regions as well as the PMEM regions */
+
+int msm_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->minor->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_local_map *map = NULL;
+	struct drm_gem_object *obj;
+	struct drm_hash_item *hash;
+	struct drm_kgsl_gem_object *gpriv;
+	int ret = 0;
+
+	mutex_lock(&dev->struct_mutex);
+
+	if (drm_ht_find_item(&mm->offset_hash, vma->vm_pgoff, &hash)) {
+		mutex_unlock(&dev->struct_mutex);
+		return drm_mmap(filp, vma);
+	}
+
+	map = drm_hash_entry(hash, struct drm_map_list, hash)->map;
+	if (!map ||
+	    ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN))) {
+		ret =  -EPERM;
+		goto out_unlock;
+	}
+
+	/* Check for valid size. */
+	if (map->size < vma->vm_end - vma->vm_start) {
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	obj = map->handle;
+
+	gpriv = obj->driver_private;
+
+	/* VM_PFNMAP is only for memory that doesn't use struct page
+	 * in other words, not "normal" memory.  If you try to use it
+	 * with "normal" memory then the mappings don't get flushed. */
+
+	if (TYPE_IS_MEM(gpriv->type)) {
+		vma->vm_flags |= VM_RESERVED | VM_DONTEXPAND;
+		vma->vm_ops = &kgsl_gem_kmem_vm_ops;
+	} else {
+		vma->vm_flags |= VM_RESERVED | VM_IO | VM_PFNMAP |
+			VM_DONTEXPAND;
+		vma->vm_ops = &kgsl_gem_phys_vm_ops;
+	}
+
+	vma->vm_private_data = map->handle;
+
+
+	/* Take care of requested caching policy */
+	if (gpriv->type == DRM_KGSL_GEM_TYPE_KMEM ||
+	    gpriv->type & DRM_KGSL_GEM_CACHE_MASK) {
+		if (gpriv->type & DRM_KGSL_GEM_CACHE_WBACKWA)
+			vma->vm_page_prot =
+			pgprot_writebackwacache(vma->vm_page_prot);
+		else if (gpriv->type & DRM_KGSL_GEM_CACHE_WBACK)
+				vma->vm_page_prot =
+				pgprot_writebackcache(vma->vm_page_prot);
+		else if (gpriv->type & DRM_KGSL_GEM_CACHE_WTHROUGH)
+				vma->vm_page_prot =
+				pgprot_writethroughcache(vma->vm_page_prot);
+		else
+			vma->vm_page_prot =
+			pgprot_writecombine(vma->vm_page_prot);
+	} else {
+		if (gpriv->type == DRM_KGSL_GEM_TYPE_KMEM_NOCACHE)
+			vma->vm_page_prot =
+			pgprot_noncached(vma->vm_page_prot);
+		else
+			/* default pmem is WC */
+			vma->vm_page_prot =
+			pgprot_writecombine(vma->vm_page_prot);
+	}
+
+	/* flush out existing KMEM cached mappings if new ones are
+	 * of uncached type */
+	if (IS_MEM_UNCACHED(gpriv->type))
+		kgsl_cache_range_op(&gpriv->memdesc,
+				    KGSL_CACHE_OP_FLUSH);
+
+	/* Add the other memory types here */
+
+	/* Take a ref for this mapping of the object, so that the fault
+	 * handler can dereference the mmap offset's pointer to the object.
+	 * This reference is cleaned up by the corresponding vm_close
+	 * (which should happen whether the vma was created by this call, or
+	 * by a vm_open due to mremap or partial unmap or whatever).
+	 */
+	drm_gem_object_reference(obj);
+
+	vma->vm_file = filp;	/* Needed for drm_vm_open() */
+	drm_vm_open_locked(vma);
+
+out_unlock:
+	mutex_unlock(&dev->struct_mutex);
+
+	return ret;
+}
+
 void
 cleanup_fence(struct drm_kgsl_gem_object_fence *fence, int check_waiting)
 {
@@ -1520,17 +1437,8 @@
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_ALLOC, kgsl_gem_alloc_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_MMAP, kgsl_gem_mmap_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_BUFINFO, kgsl_gem_get_bufinfo_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_ION_FD, kgsl_gem_get_ion_fd_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_CREATE_FROM_ION,
-				kgsl_gem_create_from_ion_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_BUFCOUNT,
-				kgsl_gem_set_bufcount_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_BUFCOUNT,
-				kgsl_gem_get_bufcount_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_GLOCK_HANDLES_INFO,
-				kgsl_gem_set_glock_handles_ioctl, 0),
-	DRM_IOCTL_DEF_DRV(KGSL_GEM_GET_GLOCK_HANDLES_INFO,
-				kgsl_gem_get_glock_handles_ioctl, 0),
+		      kgsl_gem_set_bufcount_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_SET_ACTIVE, kgsl_gem_set_active_ioctl, 0),
 	DRM_IOCTL_DEF_DRV(KGSL_GEM_LOCK_HANDLE,
 				  kgsl_gem_lock_handle_ioctl, 0),
@@ -1542,22 +1450,30 @@
 		      DRM_MASTER),
 };
 
-static const struct file_operations kgsl_drm_driver_fops = {
-	.owner = THIS_MODULE,
-	.open = drm_open,
-	.release = drm_release,
-	.unlocked_ioctl = drm_ioctl,
-	.mmap = drm_gem_mmap,
-	.poll = drm_poll,
-	.fasync = drm_fasync,
+static const const struct file_operations fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.unlocked_ioctl = drm_ioctl,
+		.mmap = msm_drm_gem_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
 };
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_GEM,
+	.load = kgsl_drm_load,
+	.unload = kgsl_drm_unload,
+	.preclose = kgsl_drm_preclose,
+	.suspend = kgsl_drm_suspend,
+	.resume = kgsl_drm_resume,
+	.reclaim_buffers = drm_core_reclaim_buffers,
 	.gem_init_object = kgsl_gem_init_object,
 	.gem_free_object = kgsl_gem_free_object,
 	.ioctls = kgsl_drm_ioctls,
-	.fops = &kgsl_drm_driver_fops,
+
+	.fops = &fops,
+
 	.name = DRIVER_NAME,
 	.desc = DRIVER_DESC,
 	.date = DRIVER_DATE,
@@ -1586,24 +1502,11 @@
 		gem_buf_fence[i].fence_id = ENTRY_EMPTY;
 	}
 
-	/* Create ION Client */
-	kgsl_drm_ion_client = msm_ion_client_create(
-			0xffffffff, "kgsl_drm");
-	if (!kgsl_drm_ion_client) {
-		DRM_ERROR("Unable to create ION client\n");
-		return -ENOMEM;
-	}
-
 	return drm_platform_init(&driver, dev);
 }
 
 void kgsl_drm_exit(void)
 {
 	kgsl_drm_inited = DRM_KGSL_NOT_INITED;
-
-	if (kgsl_drm_ion_client)
-		ion_client_destroy(kgsl_drm_ion_client);
-	kgsl_drm_ion_client = NULL;
-
 	drm_platform_exit(&driver, driver.kdriver.platform_device);
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_events.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_events.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_events.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_events.c	2014-09-21 01:02:11.000000000 +0000
@@ -211,8 +211,10 @@
 	kgsl_event_func func, void *priv, void *owner)
 {
 	struct kgsl_event *event;
-	unsigned int queued = 0, cur_ts;
+	unsigned int cur_ts;
 	struct kgsl_context *context = NULL;
+	struct adreno_context *drawctxt;
+	struct adreno_device *adreno_dev = ADRENO_DEVICE(device);
 
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
@@ -223,23 +225,16 @@
 		context = kgsl_context_get(device, id);
 		if (context == NULL)
 			return -EINVAL;
-	}
-	/*
-	 * If the caller is creating their own timestamps, let them schedule
-	 * events in the future. Otherwise only allow timestamps that have been
-	 * queued.
-	 */
-	if (context == NULL ||
-		((context->flags & KGSL_CONTEXT_USER_GENERATED_TS) == 0)) {
-		queued = kgsl_readtimestamp(device, context,
-			KGSL_TIMESTAMP_QUEUED);
-
-		if (timestamp_cmp(ts, queued) > 0) {
+		/* Do not allow registering of event with invalid timestamp */
+		drawctxt = ADRENO_CONTEXT(context);
+		if (timestamp_cmp(ts, drawctxt->timestamp) > 0) {
 			kgsl_context_put(context);
 			return -EINVAL;
 		}
+	} else {
+		if (timestamp_cmp(ts, adreno_dev->ringbuffer.global_ts) > 0)
+			return -EINVAL;
 	}
-
 	cur_ts = kgsl_readtimestamp(device, context, KGSL_TIMESTAMP_RETIRED);
 
 	/*
@@ -338,11 +333,7 @@
 		void *priv)
 {
 	struct kgsl_event *event;
-	struct list_head *head;
-
-	BUG_ON(!mutex_is_locked(&device->mutex));
-
-	head = _get_list_head(device, context);
+	struct list_head *head = _get_list_head(device, context);
 
 	event = _find_event(device, head, timestamp, func, priv);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_gpummu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_gpummu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_gpummu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_gpummu.c	2014-09-21 01:02:11.000000000 +0000
@@ -23,7 +23,6 @@
 #include "kgsl_device.h"
 #include "kgsl_sharedmem.h"
 #include "kgsl_trace.h"
-#include "adreno.h"
 
 #define KGSL_PAGETABLE_SIZE \
 	ALIGN(KGSL_PAGETABLE_ENTRIES(CONFIG_MSM_KGSL_PAGE_TABLE_SIZE) * \
@@ -404,22 +403,11 @@
 {
 	unsigned int reg;
 	unsigned int ptbase;
-	struct kgsl_device *device;
-	struct adreno_device *adreno_dev;
-	unsigned int no_page_fault_log = 0;
 
-	device = mmu->device;
-	adreno_dev = ADRENO_DEVICE(device);
+	kgsl_regread(mmu->device, MH_MMU_PAGE_FAULT, &reg);
+	kgsl_regread(mmu->device, MH_MMU_PT_BASE, &ptbase);
 
-	kgsl_regread(device, MH_MMU_PAGE_FAULT, &reg);
-	kgsl_regread(device, MH_MMU_PT_BASE, &ptbase);
-
-
-	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_LOG_ONE_PER_PAGE)
-		no_page_fault_log = kgsl_mmu_log_fault_addr(mmu, ptbase, reg);
-
-	if (!no_page_fault_log)
-		KGSL_MEM_CRIT(mmu->device,
+	KGSL_MEM_CRIT(mmu->device,
 			"mmu page fault: page=0x%lx pt=%d op=%s axi=%d\n",
 			reg & ~(PAGE_SIZE - 1),
 			kgsl_mmu_get_ptname_from_ptbase(mmu, ptbase),
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.c	2014-09-21 01:02:11.000000000 +0000
@@ -42,13 +42,12 @@
 	{ 0x10, 1 },			/* TTBR0 */
 	{ 0x14, 1 },			/* TTBR1 */
 	{ 0x20, 1 },			/* FSR */
-	{ 0x28, 1 },			/* FAR */
 	{ 0x800, 1 },			/* TLBIALL */
 	{ 0x820, 1 },			/* RESUME */
 	{ 0x03C, 1 },			/* TLBLKCR */
 	{ 0x818, 1 },			/* V2PUR */
 	{ 0x2C, 1 },			/* FSYNR0 */
-	{ 0x30, 1 },			/* FSYNR1 */
+	{ 0x30, 1 },			/* FSYNR0 */
 	{ 0, 0 },			/* TLBSYNC, not in v0 */
 	{ 0, 0 },			/* TLBSTATUS, not in v0 */
 	{ 0, 0 }			/* IMPLDEF_MICRO_MMU_CRTL, not in v0 */
@@ -60,7 +59,6 @@
 	{ 0x20, 1 },			/* TTBR0 */
 	{ 0x28, 1 },			/* TTBR1 */
 	{ 0x58, 1 },			/* FSR */
-	{ 0x60, 1 },			/* FAR_0 */
 	{ 0x618, 1 },			/* TLBIALL */
 	{ 0x008, 1 },			/* RESUME */
 	{ 0, 0 },			/* TLBLKCR not in V1 */
@@ -73,21 +71,14 @@
 };
 
 /* naming mismatch with iommu things */
-static int kgsl_iommu_default_setstate(struct kgsl_mmu *mmu,
-		uint32_t flags);
-static phys_addr_t
-kgsl_iommu_get_current_ptbase(struct kgsl_mmu *mmu);
-
 static void _iommu_lock(void)
 {
-	msm_iommu_lock();
 	return;
 }
 
 /* naming mismatch with iommu things */
 static void _iommu_unlock(void)
 {
-	msm_iommu_unlock();
 	return;
 }
 
@@ -326,13 +317,13 @@
 	struct kgsl_iommu_unit *iommu_unit;
 	struct kgsl_iommu_device *iommu_dev;
 	unsigned int ptbase, fsr;
-	unsigned int pid;
-	struct _mem_entry prev, next;
-	unsigned int fsynr0, fsynr1;
-	int write;
 	struct kgsl_device *device;
 	struct adreno_device *adreno_dev;
 	unsigned int no_page_fault_log = 0;
+	unsigned int pid;
+	unsigned int fsynr0, fsynr1;
+	int write;
+	struct _mem_entry prev, next;
 	unsigned int curr_context_id = 0;
 	unsigned int curr_global_ts = 0;
 	struct kgsl_context *context;
@@ -343,13 +334,11 @@
 
 	device = mmu->device;
 	adreno_dev = ADRENO_DEVICE(device);
-	/*
-	 * If mmu fault not set then set it and continue else
-	 * exit this function since another thread has already set
-	 * it and will execute rest of this function for the fault.
-	 */
-	if (1 == atomic_cmpxchg(&mmu->fault, 0, 1))
+	if (atomic_read(&mmu->fault)) {
+		if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
+			ret = -EBUSY;
 		goto done;
+	}
 
 	iommu_dev = get_iommu_device(iommu_unit, dev);
 	if (!iommu_dev) {
@@ -359,16 +348,6 @@
 	}
 	iommu = mmu->priv;
 
-	fsr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
-		iommu_dev->ctx_id, FSR);
-	/*
-	 * If fsr is not set then it means that we cleared the fault while the
-	 * bottom half called from IOMMU driver is running
-	 */
-	if (!fsr) {
-		atomic_set(&mmu->fault, 0);
-		goto done;
-	}
 	/*
 	 * set the fault bits and stuff before any printks so that if fault
 	 * handler runs then it will know it's dealing with a pagefault
@@ -391,6 +370,7 @@
 		context = NULL;
 	}
 
+	atomic_set(&mmu->fault, 1);
 	iommu_dev->fault = 1;
 
 	if (adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE) {
@@ -400,15 +380,17 @@
 		adreno_dispatcher_schedule(device);
 	}
 
-	ptbase = KGSL_IOMMU_GET_CTX_REG_LL(iommu, iommu_unit,
+	ptbase = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 					iommu_dev->ctx_id, TTBR0);
 
+	fsr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
+		iommu_dev->ctx_id, FSR);
 	fsynr0 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 		iommu_dev->ctx_id, FSYNR0);
 	fsynr1 = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 		iommu_dev->ctx_id, FSYNR1);
 
-	if (msm_soc_version_supports_iommu_v1())
+	if (!msm_soc_version_supports_iommu_v1())
 		write = ((fsynr1 & (KGSL_IOMMU_FSYNR1_AWRITE_MASK <<
 			KGSL_IOMMU_FSYNR1_AWRITE_SHIFT)) ? 1 : 0);
 	else
@@ -445,7 +427,6 @@
 			_print_entry(iommu_dev->kgsldev, &next);
 		else
 			KGSL_LOG_DUMP(iommu_dev->kgsldev, "*EMPTY*\n");
-
 	}
 
 	trace_kgsl_mmu_pagefault(iommu_dev->kgsldev, addr,
@@ -467,29 +448,30 @@
 /*
  * kgsl_iommu_disable_clk - Disable iommu clocks
  * @mmu - Pointer to mmu structure
- * @unit - Iommu unit
  *
- * Disables iommu clocks for an iommu unit
+ * Disables iommu clocks
  * Return - void
  */
-static void kgsl_iommu_disable_clk(struct kgsl_mmu *mmu, int unit)
+static void kgsl_iommu_disable_clk(struct kgsl_mmu *mmu)
 {
 	struct kgsl_iommu *iommu = mmu->priv;
+	struct msm_iommu_drvdata *iommu_drvdata;
 	int i, j;
 
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-
-		/* Turn off the clks for IOMMU unit requested */
-		if ((unit != i) && (unit != KGSL_IOMMU_MAX_UNITS))
-			continue;
-
-		atomic_dec(&iommu_unit->clk_enable_count);
-		BUG_ON(atomic_read(&iommu_unit->clk_enable_count) < 0);
-
-		for (j = (KGSL_IOMMU_MAX_CLKS - 1); j >= 0; j--)
-			if (iommu_unit->clks[j])
-				clk_disable_unprepare(iommu_unit->clks[j]);
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			if (!iommu_unit->dev[j].clk_enabled)
+				continue;
+			iommu_drvdata = dev_get_drvdata(
+					iommu_unit->dev[j].dev->parent);
+			if (iommu_drvdata->aclk)
+				clk_disable_unprepare(iommu_drvdata->aclk);
+			if (iommu_drvdata->clk)
+				clk_disable_unprepare(iommu_drvdata->clk);
+			clk_disable_unprepare(iommu_drvdata->pclk);
+			iommu_unit->dev[j].clk_enabled = false;
+		}
 	}
 }
 
@@ -509,12 +491,32 @@
 					unsigned int id, unsigned int ts,
 					u32 type)
 {
-	struct kgsl_iommu_disable_clk_param *param = data;
+	struct kgsl_mmu *mmu = data;
+	struct kgsl_iommu *iommu = mmu->priv;
 
-	kgsl_iommu_disable_clk(param->mmu, param->unit);
+	if (!iommu->clk_event_queued) {
+		if (0 > timestamp_cmp(ts, iommu->iommu_last_cmd_ts))
+			KGSL_DRV_ERR(device,
+			"IOMMU disable clock event being cancelled, "
+			"iommu_last_cmd_ts: %x, retired ts: %x\n",
+			iommu->iommu_last_cmd_ts, ts);
+		return;
+	}
 
-	/* Free param we are done using it */
-	kfree(param);
+	if (0 <= timestamp_cmp(ts, iommu->iommu_last_cmd_ts)) {
+		kgsl_iommu_disable_clk(mmu);
+		iommu->clk_event_queued = false;
+	} else {
+		/* add new event to fire when ts is reached, this can happen
+		 * if we queued an event and someone requested the clocks to
+		 * be disbaled on a later timestamp */
+		if (kgsl_add_event(device, id, iommu->iommu_last_cmd_ts,
+			kgsl_iommu_clk_disable_event, mmu, mmu)) {
+				KGSL_DRV_ERR(device,
+				"Failed to add IOMMU disable clk event\n");
+				iommu->clk_event_queued = false;
+		}
+	}
 }
 
 /*
@@ -524,7 +526,6 @@
  * @ts_valid - Indicates whether ts parameter is valid, if this parameter
  * is false then it means that the calling function wants to disable the
  * IOMMU clocks immediately without waiting for any timestamp
- * @unit: IOMMU unit for which clocks are to be turned off
  *
  * Creates an event to disable the IOMMU clocks on timestamp and if event
  * already exists then updates the timestamp of disabling the IOMMU clocks
@@ -533,88 +534,84 @@
  * Return - void
  */
 static void
-kgsl_iommu_disable_clk_on_ts(struct kgsl_mmu *mmu,
-				unsigned int ts, int unit)
-{
-	struct kgsl_iommu_disable_clk_param *param;
-
-	param = kzalloc(sizeof(*param), GFP_KERNEL);
-	if (!param) {
-		KGSL_CORE_ERR("kzalloc(%d) failed\n", sizeof(*param));
-		return;
-	}
-	param->mmu = mmu;
-	param->unit = unit;
-	param->ts = ts;
-
-	if (kgsl_add_event(mmu->device, KGSL_MEMSTORE_GLOBAL,
-			ts, kgsl_iommu_clk_disable_event, param, mmu)) {
-		KGSL_DRV_ERR(mmu->device,
-			"Failed to add IOMMU disable clk event\n");
-		kfree(param);
-	}
-}
-
-/*
- * kgsl_iommu_enable_clk_prepare_enable - Enable iommu clock
- * @clk - clock to enable
- *
- * Prepare enables clock. Retries 3 times on enable failure, on 4th failure
- * returns an error.
- * Return: 0 on success else 1 on error
- */
-
-static int kgsl_iommu_clk_prepare_enable(struct clk *clk)
+kgsl_iommu_disable_clk_on_ts(struct kgsl_mmu *mmu, unsigned int ts,
+				bool ts_valid)
 {
-	int num_retries = 4;
+	struct kgsl_iommu *iommu = mmu->priv;
 
-	while (num_retries--) {
-		if (!clk_prepare_enable(clk))
-			return 0;
+	if (iommu->clk_event_queued) {
+		if (ts_valid && (0 <
+			timestamp_cmp(ts, iommu->iommu_last_cmd_ts)))
+			iommu->iommu_last_cmd_ts = ts;
+	} else {
+		if (ts_valid) {
+			iommu->iommu_last_cmd_ts = ts;
+			iommu->clk_event_queued = true;
+			if (kgsl_add_event(mmu->device, KGSL_MEMSTORE_GLOBAL,
+				ts, kgsl_iommu_clk_disable_event, mmu, mmu)) {
+				KGSL_DRV_ERR(mmu->device,
+				"Failed to add IOMMU disable clk event\n");
+				iommu->clk_event_queued = false;
+			}
+		} else {
+			kgsl_iommu_disable_clk(mmu);
+		}
 	}
-
-	return 1;
 }
 
 /*
  * kgsl_iommu_enable_clk - Enable iommu clocks
  * @mmu - Pointer to mmu structure
- * @unit - The iommu unit whose clocks are to be turned on
+ * @ctx_id - The context bank whose clocks are to be turned on
  *
- * Enables iommu clocks of a given iommu unit
+ * Enables iommu clocks of a given context
  * Return: 0 on success else error code
  */
-static void kgsl_iommu_enable_clk(struct kgsl_mmu *mmu,
-				int unit)
+static int kgsl_iommu_enable_clk(struct kgsl_mmu *mmu,
+				int ctx_id)
 {
+	int ret = 0;
 	int i, j;
 	struct kgsl_iommu *iommu = mmu->priv;
+	struct msm_iommu_drvdata *iommu_drvdata;
 
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-
-		/* Turn on the clks for IOMMU unit requested */
-		if ((unit != i) && (unit != KGSL_IOMMU_MAX_UNITS))
-			continue;
-
-		for (j = 0; j < KGSL_IOMMU_MAX_CLKS; j++) {
-			if (iommu_unit->clks[j])
-				if (kgsl_iommu_clk_prepare_enable(
-						iommu_unit->clks[j]))
-						goto done;
+		for (j = 0; j < iommu_unit->dev_count; j++) {
+			if (iommu_unit->dev[j].clk_enabled ||
+				ctx_id != iommu_unit->dev[j].ctx_id)
+				continue;
+			iommu_drvdata =
+			dev_get_drvdata(iommu_unit->dev[j].dev->parent);
+			ret = clk_prepare_enable(iommu_drvdata->pclk);
+			if (ret)
+				goto done;
+			if (iommu_drvdata->clk) {
+				ret = clk_prepare_enable(iommu_drvdata->clk);
+				if (ret) {
+					clk_disable_unprepare(
+						iommu_drvdata->pclk);
+					goto done;
+				}
+			}
+			if (iommu_drvdata->aclk) {
+				ret = clk_prepare_enable(iommu_drvdata->aclk);
+				if (ret) {
+					if (iommu_drvdata->clk)
+						clk_disable_unprepare(
+							iommu_drvdata->clk);
+					clk_disable_unprepare(
+							iommu_drvdata->pclk);
+					goto done;
+				}
+			}
+			iommu_unit->dev[j].clk_enabled = true;
 		}
-		atomic_inc(&iommu_unit->clk_enable_count);
 	}
-	return;
 done:
-	/*
-	 * Any Clock enable failure should be fatal,
-	 * System usually crashes when enabling clock fails
-	 * BUG_ON here to catch the system in bad state for
-	 * further debug
-	 */
-	KGSL_CORE_ERR("IOMMU clk enable failed\n");
-	BUG();
+	if (ret)
+		kgsl_iommu_disable_clk(mmu);
+	return ret;
 }
 
 /*
@@ -769,7 +766,6 @@
 {
 	struct kgsl_iommu_pt *iommu_pt;
 	struct kgsl_iommu *iommu = mmu->priv;
-	struct msm_iommu_drvdata *drvdata = 0;
 	int i, j, ret = 0;
 
 	/*
@@ -784,12 +780,9 @@
 			 * If there is a 2nd default pagetable then priv domain
 			 * is attached to this pagetable
 			 */
-			if (KGSL_IOMMU_CONTEXT_PRIV == j) {
-				if (mmu->priv_bank_table)
-					iommu_pt = mmu->priv_bank_table->priv;
-				else
-					continue;
-			}
+			if (mmu->priv_bank_table &&
+				(KGSL_IOMMU_CONTEXT_PRIV == j))
+				iommu_pt = mmu->priv_bank_table->priv;
 			if (!iommu_unit->dev[j].attached) {
 				ret = iommu_attach_device(iommu_pt->domain,
 							iommu_unit->dev[j].dev);
@@ -804,14 +797,6 @@
 				"iommu pt %p attached to dev %p, ctx_id %d\n",
 				iommu_pt->domain, iommu_unit->dev[j].dev,
 				iommu_unit->dev[j].ctx_id);
-				/* Init IOMMU unit clks here */
-				if (!drvdata) {
-					drvdata = dev_get_drvdata(
-					iommu_unit->dev[j].dev->parent);
-					iommu_unit->clks[0] = drvdata->pclk;
-					iommu_unit->clks[1] = drvdata->clk;
-					iommu_unit->clks[2] = drvdata->aclk;
-				}
 			}
 		}
 	}
@@ -837,7 +822,6 @@
 	struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[unit_id];
 	int i, j;
 	int found_ctx;
-	int ret = 0;
 
 	for (j = 0; j < KGSL_IOMMU_MAX_DEVS_PER_UNIT; j++) {
 		found_ctx = 0;
@@ -851,22 +835,16 @@
 			break;
 		if (!data->iommu_ctxs[i].iommu_ctx_name) {
 			KGSL_CORE_ERR("Context name invalid\n");
-			ret = -EINVAL;
-			goto done;
+			return -EINVAL;
 		}
-		atomic_set(&(iommu_unit->clk_enable_count), 0);
 
 		iommu_unit->dev[iommu_unit->dev_count].dev =
 			msm_iommu_get_ctx(data->iommu_ctxs[i].iommu_ctx_name);
-		if (NULL == iommu_unit->dev[iommu_unit->dev_count].dev)
-			ret = -EINVAL;
-		if (IS_ERR(iommu_unit->dev[iommu_unit->dev_count].dev)) {
-			ret = PTR_ERR(
-				iommu_unit->dev[iommu_unit->dev_count].dev);
-			iommu_unit->dev[iommu_unit->dev_count].dev = NULL;
+		if (iommu_unit->dev[iommu_unit->dev_count].dev == NULL) {
+			KGSL_CORE_ERR("Failed to get iommu dev handle for "
+			"device %s\n", data->iommu_ctxs[i].iommu_ctx_name);
+			return -EINVAL;
 		}
-		if (ret)
-			goto done;
 		iommu_unit->dev[iommu_unit->dev_count].ctx_id =
 						data->iommu_ctxs[i].ctx_id;
 		iommu_unit->dev[iommu_unit->dev_count].kgsldev = mmu->device;
@@ -878,23 +856,12 @@
 
 		iommu_unit->dev_count++;
 	}
-done:
-	if (!iommu_unit->dev_count && !ret)
-		ret = -EINVAL;
-	if (ret) {
-		/*
-		 * If at least the first context is initialized on v1
-		 * then we can continue
-		 */
-		if (!msm_soc_version_supports_iommu_v1() &&
-			iommu_unit->dev_count)
-			ret = 0;
-		else
-			KGSL_CORE_ERR(
-			"Failed to initialize iommu contexts, err: %d\n", ret);
+	if (!j) {
+		KGSL_CORE_ERR("No ctxts initialized, user ctxt absent\n ");
+		return -EINVAL;
 	}
 
-	return ret;
+	return 0;
 }
 
 /*
@@ -957,17 +924,6 @@
 		!kgsl_mmu_is_perprocess(mmu))
 		return status;
 
-	/*
-	 * For 2D devices cpu side sync lock is required. For 3D device,
-	 * since we only have a single 3D core and we always ensure that
-	 * 3D core is idle while writing to IOMMU register using CPU this
-	 * lock is not required
-	 */
-	if (KGSL_DEVICE_2D0 == mmu->device->id ||
-		KGSL_DEVICE_2D1 == mmu->device->id) {
-		return status;
-	}
-
 	/* Return if already initialized */
 	if (iommu->sync_lock_initialized)
 		return status;
@@ -1037,10 +993,6 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	*cmds++ = cp_type3_packet(CP_MEM_WRITE, 2);
 	*cmds++ = lock_vars->turn;
 	*cmds++ = 0;
@@ -1055,19 +1007,11 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	*cmds++ = cp_type3_packet(CP_TEST_TWO_MEMS, 3);
 	*cmds++ = lock_vars->flag[PROC_APPS];
 	*cmds++ = lock_vars->turn;
 	*cmds++ = 0;
 
-	/* TEST_TWO_MEMS turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += adreno_add_idle_cmds(adreno_dev, cmds);
 
 	return cmds - start;
@@ -1105,10 +1049,6 @@
 	*cmds++ = 0x1;
 	*cmds++ = 0x1;
 
-	/* WAIT_REG_MEM turns back on protected mode - push it off */
-	*cmds++ = cp_type3_packet(CP_SET_PROTECTED_MODE, 1);
-	*cmds++ = 0;
-
 	cmds += adreno_add_idle_cmds(adreno_dev, cmds);
 
 	return cmds - start;
@@ -1256,17 +1196,19 @@
 {
 	int ret = 0;
 
-	/* page table not current, then setup mmu to use new
-	 *  specified page table
-	 */
-	if (mmu->hwpagetable != pagetable) {
-		unsigned int flags = 0;
-		mmu->hwpagetable = pagetable;
-		flags |= kgsl_mmu_pt_get_flags(mmu->hwpagetable,
-						mmu->device->id) |
-						KGSL_MMUFLAGS_TLBFLUSH;
-		ret = kgsl_setstate(mmu, context_id,
-			KGSL_MMUFLAGS_PTUPDATE | flags);
+	if (mmu->flags & KGSL_FLAGS_STARTED) {
+		/* page table not current, then setup mmu to use new
+		 *  specified page table
+		 */
+		if (mmu->hwpagetable != pagetable) {
+			unsigned int flags = 0;
+			mmu->hwpagetable = pagetable;
+			flags |= kgsl_mmu_pt_get_flags(mmu->hwpagetable,
+							mmu->device->id) |
+							KGSL_MMUFLAGS_TLBFLUSH;
+			ret = kgsl_setstate(mmu, context_id,
+				KGSL_MMUFLAGS_PTUPDATE | flags);
+		}
 	}
 
 	return ret;
@@ -1567,8 +1509,6 @@
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			tlblkcr = 0;
 			if (cpu_is_msm8960())
 				tlblkcr |= ((num_tlb_entries &
@@ -1594,8 +1534,6 @@
 					TLBLKCR, tlblkcr);
 		}
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			/* skip locking entries for private bank on 8960 */
 			if (cpu_is_msm8960() &&  KGSL_IOMMU_CONTEXT_PRIV == j)
 				continue;
@@ -1635,8 +1573,6 @@
 			}
 		}
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
 			tlblkcr = KGSL_IOMMU_GET_CTX_REG(iommu, iommu_unit,
 						iommu_unit->dev[j].ctx_id,
 						TLBLKCR);
@@ -1652,16 +1588,25 @@
 
 static int kgsl_iommu_start(struct kgsl_mmu *mmu)
 {
+	struct kgsl_device *device = mmu->device;
 	int status;
 	struct kgsl_iommu *iommu = mmu->priv;
 	int i, j;
 	int sctlr_val = 0;
 	struct adreno_device *adreno_dev = ADRENO_DEVICE(mmu->device);
 
+	if (mmu->flags & KGSL_FLAGS_STARTED)
+		return 0;
+
 	if (mmu->defaultpagetable == NULL) {
 		status = kgsl_iommu_setup_defaultpagetable(mmu);
 		if (status)
 			return -ENOMEM;
+
+		/* Initialize the sync lock between GPU and CPU */
+		if (msm_soc_version_supports_iommu_v1() &&
+			(device->id == KGSL_DEVICE_3D0))
+				kgsl_iommu_init_sync_lock(mmu);
 	}
 	status = kgsl_iommu_start_sync_lock(mmu);
 	if (status)
@@ -1686,20 +1631,26 @@
 		mmu->hwpagetable = NULL;
 		goto done;
 	}
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
+	status = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+	if (status) {
+		KGSL_CORE_ERR("clk enable failed\n");
+		goto done;
+	}
+	status = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_PRIV);
+	if (status) {
+		KGSL_CORE_ERR("clk enable failed\n");
+		goto done;
+	}
 	/* Get the lsb value of pagetables set in the IOMMU ttbr0 register as
 	 * that value should not change when we change pagetables, so while
 	 * changing pagetables we can use this lsb value of the pagetable w/o
 	 * having to read it again
 	 */
-	_iommu_lock();
+	msm_iommu_lock();
 	for (i = 0; i < iommu->unit_count; i++) {
 		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
 		for (j = 0; j < iommu_unit->dev_count; j++) {
-			if (!iommu_unit->dev[j].attached)
-				continue;
+
 			/*
 			 * For IOMMU V1 do not halt IOMMU on pagefault if
 			 * FT pagefault policy is set accordingly
@@ -1718,25 +1669,37 @@
 						iommu_unit->dev[j].ctx_id,
 						SCTLR, sctlr_val);
 			}
-
-			iommu_unit->dev[j].default_ttbr0 =
-				KGSL_IOMMU_GET_CTX_REG_LL(iommu,
+			if (sizeof(phys_addr_t) > sizeof(unsigned long)) {
+				iommu_unit->dev[j].default_ttbr0 =
+						KGSL_IOMMU_GET_CTX_REG_LL(iommu,
 						iommu_unit,
 						iommu_unit->dev[j].ctx_id,
 						TTBR0);
+			} else {
+				iommu_unit->dev[j].default_ttbr0 =
+						KGSL_IOMMU_GET_CTX_REG(iommu,
+						iommu_unit,
+						iommu_unit->dev[j].ctx_id,
+						TTBR0);
+			}
 		}
 	}
 	kgsl_iommu_lock_rb_in_tlb(mmu);
-	_iommu_unlock();
+	msm_iommu_unlock();
 
 	/* For complete CFF */
 	kgsl_cffdump_setmem(mmu->device, mmu->setstate_memory.gpuaddr +
 				KGSL_IOMMU_SETSTATE_NOP_OFFSET,
 				cp_nop_packet(1), sizeof(unsigned int));
 
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
+	mmu->flags |= KGSL_FLAGS_STARTED;
 
 done:
+	if (status) {
+		kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
+		kgsl_detach_pagetable_iommu_domain(mmu);
+	}
 	return status;
 }
 
@@ -1745,11 +1708,9 @@
 		struct kgsl_memdesc *memdesc,
 		unsigned int *tlb_flags)
 {
-	int ret = 0, lock_taken = 0;
+	int ret;
 	unsigned int range = memdesc->size;
 	struct kgsl_iommu_pt *iommu_pt = pt->priv;
-	struct kgsl_device *device = pt->mmu->device;
-	struct kgsl_iommu *iommu = pt->mmu->priv;
 
 	/* All GPU addresses as assigned are page aligned, but some
 	   functions purturb the gpuaddr with an offset, so apply the
@@ -1764,38 +1725,18 @@
 		range += PAGE_SIZE;
 
 	ret = iommu_unmap_range(iommu_pt->domain, gpuaddr, range);
-	if (ret) {
+	if (ret)
 		KGSL_CORE_ERR("iommu_unmap_range(%p, %x, %d) failed "
 			"with err: %d\n", iommu_pt->domain, gpuaddr,
 			range, ret);
-		return ret;
-	}
-
-	/*
-	 * Check to see if the current thread already holds the device mutex.
-	 * If it does not, then take the device mutex which is required for
-	 * flushing the tlb
-	 */
-	if (!mutex_is_locked(&device->mutex) ||
-		device->mutex.owner != current) {
-		mutex_lock(&device->mutex);
-		lock_taken = 1;
-	}
 
 	/*
-	 * Flush the tlb only if the iommu device is attached and the pagetable
-	 * hasn't been switched yet
+	 * Flushing only required if per process pagetables are used. With
+	 * global case, flushing will happen inside iommu_map function
 	 */
-	if (kgsl_mmu_is_perprocess(pt->mmu) &&
-		iommu->iommu_units[0].dev[KGSL_IOMMU_CONTEXT_USER].attached &&
-		kgsl_iommu_pt_equal(pt->mmu, pt,
-		kgsl_iommu_get_current_ptbase(pt->mmu)))
-		kgsl_iommu_default_setstate(pt->mmu, KGSL_MMUFLAGS_TLBFLUSH);
-
-	if (lock_taken)
-		mutex_unlock(&device->mutex);
-
-	return ret;
+	if (!ret && kgsl_mmu_is_perprocess(pt->mmu))
+		*tlb_flags = UINT_MAX;
+	return 0;
 }
 
 static int
@@ -1845,14 +1786,12 @@
 	int i, j;
 
 	if (atomic_read(&mmu->fault)) {
-		kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
 		for (i = 0; i < iommu->unit_count; i++) {
 			struct kgsl_iommu_unit *iommu_unit =
 						&iommu->iommu_units[i];
 			for (j = 0; j < iommu_unit->dev_count; j++) {
-				if (!iommu_unit->dev[j].attached)
-					continue;
 				if (iommu_unit->dev[j].fault) {
+					kgsl_iommu_enable_clk(mmu, j);
 					_iommu_lock();
 					KGSL_IOMMU_SET_CTX_REG(iommu,
 						iommu_unit,
@@ -1867,25 +1806,32 @@
 				}
 			}
 		}
-		kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
 		atomic_set(&mmu->fault, 0);
 	}
 }
 
+
 static void kgsl_iommu_stop(struct kgsl_mmu *mmu)
 {
+	struct kgsl_iommu *iommu = mmu->priv;
 	/*
 	 *  stop device mmu
 	 *
 	 *  call this with the global lock held
-	 *  detach iommu attachment
 	 */
-	kgsl_detach_pagetable_iommu_domain(mmu);
-	mmu->hwpagetable = NULL;
+	if (mmu->flags & KGSL_FLAGS_STARTED) {
+		/* detach iommu attachment */
+		kgsl_detach_pagetable_iommu_domain(mmu);
+		mmu->hwpagetable = NULL;
 
-	kgsl_iommu_pagefault_resume(mmu);
+		mmu->flags &= ~KGSL_FLAGS_STARTED;
+
+		kgsl_iommu_pagefault_resume(mmu);
+	}
 	/* switch off MMU clocks and cancel any events it has queued */
+	iommu->clk_event_queued = false;
 	kgsl_cancel_events(mmu->device, mmu);
+	kgsl_iommu_disable_clk(mmu);
 }
 
 static int kgsl_iommu_close(struct kgsl_mmu *mmu)
@@ -1934,11 +1880,11 @@
 	if (in_interrupt())
 		return 0;
 	/* Return the current pt base by reading IOMMU pt_base register */
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	pt_base = KGSL_IOMMU_GET_CTX_REG_LL(iommu, (&iommu->iommu_units[0]),
+	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+	pt_base = KGSL_IOMMU_GET_CTX_REG(iommu, (&iommu->iommu_units[0]),
 					KGSL_IOMMU_CONTEXT_USER,
 					TTBR0);
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
 	return pt_base & KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 }
 
@@ -1961,11 +1907,16 @@
 	int temp;
 	int i;
 	int ret = 0;
-	phys_addr_t pt_base = kgsl_iommu_get_pt_base_addr(mmu,
+	unsigned int pt_base = kgsl_iommu_get_pt_base_addr(mmu,
 						mmu->hwpagetable);
 	phys_addr_t pt_val;
 
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
+	ret = kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_CONTEXT_USER);
+
+	if (ret) {
+		KGSL_DRV_ERR(mmu->device, "Failed to enable iommu clocks\n");
+		return ret;
+	}
 
 	/* For v0 SMMU GPU needs to be idle for tlb invalidate as well */
 	/* naming mismatch for iommu */
@@ -1976,7 +1927,7 @@
 	}
 
 	/* Acquire GPU-CPU sync Lock here */
-	_iommu_lock();
+	msm_iommu_lock();
 
 	if (flags & KGSL_MMUFLAGS_PTUPDATE) {
 	/* naming mismatch for iommu */
@@ -1994,12 +1945,18 @@
 			pt_base &= KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 			pt_val &= ~KGSL_IOMMU_CTX_TTBR0_ADDR_MASK;
 			pt_val |= pt_base;
-			KGSL_IOMMU_SET_CTX_REG_LL(iommu,
+			if (sizeof(phys_addr_t) > sizeof(unsigned long)) {
+				KGSL_IOMMU_SET_CTX_REG_LL(iommu,
+					(&iommu->iommu_units[i]),
+					KGSL_IOMMU_CONTEXT_USER, TTBR0, pt_val);
+			} else {
+				KGSL_IOMMU_SET_CTX_REG(iommu,
 					(&iommu->iommu_units[i]),
 					KGSL_IOMMU_CONTEXT_USER, TTBR0, pt_val);
+			}
 
 			mb();
-			temp = KGSL_IOMMU_GET_CTX_REG_LL(iommu,
+			temp = KGSL_IOMMU_GET_CTX_REG(iommu,
 				(&iommu->iommu_units[i]),
 				KGSL_IOMMU_CONTEXT_USER, TTBR0);
 		}
@@ -2043,11 +2000,10 @@
 unlock:
 
 	/* Release GPU-CPU sync Lock here */
-	_iommu_unlock();
+	msm_iommu_unlock();
 
 	/* Disable smmu clock */
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
+	kgsl_iommu_disable_clk_on_ts(mmu, 0, false);
 	return ret;
 }
 
@@ -2094,103 +2050,6 @@
 	return iommu->unit_count;
 }
 
-/*
- * kgsl_iommu_set_pf_policy() - Set the pagefault policy for IOMMU
- * @mmu: Pointer to mmu structure
- * @pf_policy: The pagefault polict to set
- *
- * Check if the new policy indicated by pf_policy is same as current
- * policy, if same then return else set the policy
- */
-static int kgsl_iommu_set_pf_policy(struct kgsl_mmu *mmu,
-				unsigned int pf_policy)
-{
-	int i, j;
-	struct kgsl_iommu *iommu = mmu->priv;
-	struct adreno_device *adreno_dev = ADRENO_DEVICE(mmu->device);
-	int ret = 0;
-	unsigned int sctlr_val;
-
-	if ((adreno_dev->ft_pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE) ==
-		(pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE))
-		return ret;
-	if (!msm_soc_version_supports_iommu_v1())
-		return ret;
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-
-	/* Need to idle device before changing options */
-	ret = mmu->device->ftbl->idle(mmu->device);
-	if (ret) {
-		kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-		return ret;
-	}
-
-	for (i = 0; i < iommu->unit_count; i++) {
-		struct kgsl_iommu_unit *iommu_unit = &iommu->iommu_units[i];
-		for (j = 0; j < iommu_unit->dev_count; j++) {
-			sctlr_val = KGSL_IOMMU_GET_CTX_REG(iommu,
-					iommu_unit,
-					iommu_unit->dev[j].ctx_id,
-					SCTLR);
-			if (pf_policy & KGSL_FT_PAGEFAULT_GPUHALT_ENABLE)
-				sctlr_val &= ~(0x1 <<
-					KGSL_IOMMU_SCTLR_HUPCF_SHIFT);
-			else
-				sctlr_val |= (0x1 <<
-					KGSL_IOMMU_SCTLR_HUPCF_SHIFT);
-			KGSL_IOMMU_SET_CTX_REG(iommu,
-					iommu_unit,
-					iommu_unit->dev[j].ctx_id,
-					SCTLR, sctlr_val);
-		}
-	}
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	return ret;
-}
-
-/**
- * kgsl_iommu_set_pagefault() - Checks if a IOMMU device has faulted
- * @mmu: MMU pointer of the device
- *
- * This function is called to set the pagefault bits for the device so
- * that recovery can run with pagefault in consideration
- */
-static void kgsl_iommu_set_pagefault(struct kgsl_mmu *mmu)
-{
-	int i, j;
-	struct kgsl_iommu *iommu = mmu->priv;
-	unsigned int fsr;
-
-	/* fault already detected then return early */
-	if (atomic_read(&mmu->fault))
-		return;
-
-	kgsl_iommu_enable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-	/* Loop through all IOMMU devices to check for fault */
-	for (i = 0; i < iommu->unit_count; i++) {
-		for (j = 0; j < iommu->iommu_units[i].dev_count; j++) {
-			if (!iommu->iommu_units[i].dev[j].attached)
-				continue;
-			fsr = KGSL_IOMMU_GET_CTX_REG(iommu,
-				(&(iommu->iommu_units[i])),
-				iommu->iommu_units[i].dev[j].ctx_id, FSR);
-			if (fsr) {
-				uint64_t far =
-					KGSL_IOMMU_GET_CTX_REG_LL(iommu,
-					(&(iommu->iommu_units[i])),
-					iommu->iommu_units[i].dev[j].ctx_id,
-					FAR);
-				kgsl_iommu_fault_handler(NULL,
-				iommu->iommu_units[i].dev[j].dev, far, 0, NULL);
-				break;
-			}
-		}
-	}
-
-	kgsl_iommu_disable_clk(mmu, KGSL_IOMMU_MAX_UNITS);
-}
-
 struct kgsl_mmu_ops iommu_ops = {
 	.mmu_init = kgsl_iommu_init,
 	.mmu_close = kgsl_iommu_close,
@@ -2216,8 +2075,6 @@
 	.mmu_cleanup_pt = NULL,
 	.mmu_sync_lock = kgsl_iommu_sync_lock,
 	.mmu_sync_unlock = kgsl_iommu_sync_unlock,
-	.mmu_set_pf_policy = kgsl_iommu_set_pf_policy,
-	.mmu_set_pagefault = kgsl_iommu_set_pagefault
 };
 
 struct kgsl_mmu_pt_ops iommu_pt_ops = {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_iommu.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_iommu.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -70,7 +70,6 @@
 	KGSL_IOMMU_CTX_TTBR0,
 	KGSL_IOMMU_CTX_TTBR1,
 	KGSL_IOMMU_CTX_FSR,
-	KGSL_IOMMU_CTX_FAR,
 	KGSL_IOMMU_CTX_TLBIALL,
 	KGSL_IOMMU_CTX_RESUME,
 	KGSL_IOMMU_CTX_TLBLKCR,
@@ -92,16 +91,10 @@
  * Max number of iommu units that the gpu core can have
  * On APQ8064, KGSL can control a maximum of 2 IOMMU units.
  */
-enum kgsl_iommu_units {
-	KGSL_IOMMU_UNIT_0 = 0,
-	KGSL_IOMMU_UNIT_1 = 1,
-	KGSL_IOMMU_MAX_UNITS = 2,
-};
+#define KGSL_IOMMU_MAX_UNITS 2
 
 /* Max number of iommu contexts per IOMMU unit */
 #define KGSL_IOMMU_MAX_DEVS_PER_UNIT 2
-/* Max number of iommu clks per IOMMU unit */
-#define KGSL_IOMMU_MAX_CLKS 3
 
 /* Macros to read/write IOMMU registers */
 #define KGSL_IOMMU_SET_CTX_REG_LL(iommu, iommu_unit, ctx, REG, val)	\
@@ -112,7 +105,7 @@
 		iommu->ctx_offset)
 
 #define KGSL_IOMMU_GET_CTX_REG_LL(iommu, iommu_unit, ctx, REG)		\
-		readll_relaxed(						\
+		readl_relaxed(						\
 		iommu_unit->reg_map.hostptr +				\
 		iommu->iommu_reg_list[KGSL_IOMMU_CTX_##REG].reg_offset +\
 		(ctx << KGSL_IOMMU_CTX_SHIFT) +				\
@@ -174,8 +167,6 @@
  * @iommu_halt_enable: Valid only on IOMMU-v1, when set indicates that the iommu
  * unit supports halting of the IOMMU, which can be enabled while programming
  * the IOMMU registers for synchronization
- * @clk_enable_count: The ref count of clock enable calls
- * @clks: iommu unit clks
  */
 struct kgsl_iommu_unit {
 	struct kgsl_iommu_device dev[KGSL_IOMMU_MAX_DEVS_PER_UNIT];
@@ -183,8 +174,6 @@
 	struct kgsl_memdesc reg_map;
 	unsigned int ahb_base;
 	int iommu_halt_enable;
-	atomic_t clk_enable_count;
-	struct clk *clks[KGSL_IOMMU_MAX_CLKS];
 };
 
 /*
@@ -193,6 +182,10 @@
  * iommu contexts owned by graphics cores
  * @unit_count: Number of IOMMU units that are available for this
  * instance of the IOMMU driver
+ * @iommu_last_cmd_ts: The timestamp of last command submitted that
+ * aceeses iommu registers
+ * @clk_event_queued: Indicates whether an event to disable clocks
+ * is already queued or not
  * @device: Pointer to kgsl device
  * @ctx_offset: The context offset to be added to base address when
  * accessing IOMMU registers
@@ -208,6 +201,8 @@
 struct kgsl_iommu {
 	struct kgsl_iommu_unit iommu_units[KGSL_IOMMU_MAX_UNITS];
 	unsigned int unit_count;
+	unsigned int iommu_last_cmd_ts;
+	bool clk_event_queued;
 	struct kgsl_device *device;
 	unsigned int ctx_offset;
 	struct kgsl_iommu_register_list *iommu_reg_list;
@@ -227,18 +222,4 @@
 	struct kgsl_iommu *iommu;
 };
 
-/*
- * struct kgsl_iommu_disable_clk_param - Parameter struct for disble clk event
- * @mmu: The mmu pointer
- * @rb_level: the rb level in which the timestamp of the event belongs to
- * @unit: The IOMMU unit whose clock is to be turned off
- * @ts: Timestamp on which clock is to be disabled
- */
-struct kgsl_iommu_disable_clk_param {
-	struct kgsl_mmu *mmu;
-	int rb_level;
-	int unit;
-	unsigned int ts;
-};
-
 #endif
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_log.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_log.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_log.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_log.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2008-2011,2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2008-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,6 +13,8 @@
 #ifndef __KGSL_LOG_H
 #define __KGSL_LOG_H
 
+extern unsigned int kgsl_cff_dump_enable;
+
 #define KGSL_LOG_INFO(dev, lvl, fmt, args...) \
 	do { \
 		if ((lvl) >= 6)  \
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.c	2014-09-21 01:02:11.000000000 +0000
@@ -20,7 +20,6 @@
 #include <linux/iommu.h>
 #include <mach/iommu.h>
 #include <mach/socinfo.h>
-#include <linux/types.h>
 
 #include "kgsl.h"
 #include "kgsl_mmu.h"
@@ -349,7 +348,7 @@
 	unsigned int ret = 0;
 
 	if (!mmu->mmu_ops || !mmu->mmu_ops->mmu_pt_equal)
-		return 0;
+		return KGSL_MMU_GLOBAL_PT;
 	spin_lock(&kgsl_driver.ptlock);
 	list_for_each_entry(pt, &kgsl_driver.pagetable_list, list) {
 		if (kref_get_unless_zero(&pt->refcount)) {
@@ -386,18 +385,12 @@
 	status = kgsl_allocate_contiguous(&mmu->setstate_memory, PAGE_SIZE);
 	if (status)
 		return status;
-
-	/* Mark the setstate memory as read only */
-	mmu->setstate_memory.flags |= KGSL_MEMFLAGS_GPUREADONLY;
-
 	kgsl_sharedmem_set(device, &mmu->setstate_memory, 0, 0,
 				mmu->setstate_memory.size);
 
 	if (KGSL_MMU_TYPE_NONE == kgsl_mmu_type) {
 		dev_info(device->dev, "|%s| MMU type set for device is "
 				"NOMMU\n", __func__);
-		status = dma_set_coherent_mask(device->dev->parent,
-					DMA_BIT_MASK(sizeof(dma_addr_t)*8));
 		goto done;
 	} else if (KGSL_MMU_TYPE_GPU == kgsl_mmu_type)
 		mmu->mmu_ops = &gpummu_ops;
@@ -737,10 +730,6 @@
 	if (!kgsl_memdesc_is_global(memdesc) &&
 		(KGSL_MEMDESC_MAPPED & memdesc->priv))
 		return -EINVAL;
-
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
-		return 0;
-
 	/* Add space for the guard page when allocating the mmu VA. */
 	size = memdesc->size;
 	if (kgsl_memdesc_has_guard_page(memdesc))
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_mmu.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_mmu.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2002,2007-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2002,2007-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -148,12 +148,11 @@
 	void (*mmu_pagefault_resume)
 			(struct kgsl_mmu *mmu);
 	void (*mmu_disable_clk_on_ts)
-		(struct kgsl_mmu *mmu,
-		uint32_t ts, int unit);
-	void (*mmu_enable_clk)
-		(struct kgsl_mmu *mmu, int unit);
+		(struct kgsl_mmu *mmu, uint32_t ts, bool ts_valid);
+	int (*mmu_enable_clk)
+		(struct kgsl_mmu *mmu, int ctx_id);
 	void (*mmu_disable_clk)
-		(struct kgsl_mmu *mmu, int unit);
+		(struct kgsl_mmu *mmu);
 	phys_addr_t (*mmu_get_default_ttbr0)(struct kgsl_mmu *mmu,
 				unsigned int unit_id,
 				enum kgsl_iommu_context_id ctx_id);
@@ -178,8 +177,6 @@
 	unsigned int (*mmu_sync_unlock)
 			(struct kgsl_mmu *mmu, unsigned int *cmds);
 	int (*mmu_hw_halt_supported)(struct kgsl_mmu *mmu, int iommu_unit_num);
-	int (*mmu_set_pf_policy)(struct kgsl_mmu *mmu, unsigned int pf_policy);
-	void (*mmu_set_pagefault)(struct kgsl_mmu *mmu);
 };
 
 struct kgsl_mmu_pt_ops {
@@ -324,25 +321,26 @@
 		return 0;
 }
 
-static inline void kgsl_mmu_enable_clk(struct kgsl_mmu *mmu, int unit)
+static inline int kgsl_mmu_enable_clk(struct kgsl_mmu *mmu,
+					int ctx_id)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_enable_clk)
-		mmu->mmu_ops->mmu_enable_clk(mmu, unit);
+		return mmu->mmu_ops->mmu_enable_clk(mmu, ctx_id);
 	else
-		return;
+		return 0;
 }
 
-static inline void kgsl_mmu_disable_clk(struct kgsl_mmu *mmu, int unit)
+static inline void kgsl_mmu_disable_clk(struct kgsl_mmu *mmu)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_disable_clk)
-		mmu->mmu_ops->mmu_disable_clk(mmu, unit);
+		mmu->mmu_ops->mmu_disable_clk(mmu);
 }
 
 static inline void kgsl_mmu_disable_clk_on_ts(struct kgsl_mmu *mmu,
-						unsigned int ts, int unit)
+						unsigned int ts, bool ts_valid)
 {
 	if (mmu->mmu_ops && mmu->mmu_ops->mmu_disable_clk_on_ts)
-		mmu->mmu_ops->mmu_disable_clk_on_ts(mmu, ts, unit);
+		mmu->mmu_ops->mmu_disable_clk_on_ts(mmu, ts, ts_valid);
 }
 
 static inline unsigned int kgsl_mmu_get_int_mask(void)
@@ -483,19 +481,4 @@
 		return 0;
 }
 
-static inline int kgsl_mmu_set_pagefault_policy(struct kgsl_mmu *mmu,
-						unsigned int pf_policy)
-{
-	if (mmu->mmu_ops && mmu->mmu_ops->mmu_set_pf_policy)
-		return mmu->mmu_ops->mmu_set_pf_policy(mmu, pf_policy);
-	else
-		return 0;
-}
-
-static inline void kgsl_mmu_set_pagefault(struct kgsl_mmu *mmu)
-{
-	if (mmu->mmu_ops && mmu->mmu_ops->mmu_set_pagefault)
-		return mmu->mmu_ops->mmu_set_pagefault(mmu);
-}
-
 #endif /* __KGSL_MMU_H */
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.c	2014-09-21 01:02:11.000000000 +0000
@@ -26,8 +26,6 @@
 #include "kgsl_trace.h"
 #include "kgsl_sharedmem.h"
 
-#include <mach/kgsl.h>
-
 #define KGSL_PWRFLAGS_POWER_ON 0
 #define KGSL_PWRFLAGS_CLK_ON   1
 #define KGSL_PWRFLAGS_AXI_ON   2
@@ -46,12 +44,6 @@
 #define INIT_UDELAY		200
 #define MAX_UDELAY		2000
 
-unsigned long internal_max = 450000000;
-
-#ifdef CONFIG_CPU_FREQ_GOV_ELEMENTALX
-int graphics_boost = 2;
-#endif
-
 struct clk_pair {
 	const char *name;
 	uint map;
@@ -196,10 +188,6 @@
 
 
 	trace_kgsl_pwrlevel(device, pwr->active_pwrlevel, pwrlevel->gpu_freq);
-
-#ifdef CONFIG_CPU_FREQ_GOV_ELEMENTALX
-        graphics_boost = pwr->active_pwrlevel;
-#endif
 }
 
 EXPORT_SYMBOL(kgsl_pwrctrl_pwrlevel_change);
@@ -403,8 +391,6 @@
 	return -ERANGE;
 }
 
-extern void SetGPUpll_config(u32 loc, unsigned long freq);
-
 static int kgsl_pwrctrl_max_gpuclk_store(struct device *dev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
@@ -423,34 +409,6 @@
 	if (ret != 1)
 		return count;
 
-	if (max_gpu) {
-
-		if (val == 450000000) {
-			SetGPUpll_config(0x21, val);
-		}
-		else if (val == 477000000) {
-			SetGPUpll_config(0x23, val);
-		}
-		else if (val == 490500000) {
-			SetGPUpll_config(0x24, val);
-		}
-		else if (val == 504000000) {
-			SetGPUpll_config(0x25, val);
-		}
-		else if (val == 531000000) {
-			SetGPUpll_config(0x27, val);
-		}
-		else if (val == 558000000) {
-			SetGPUpll_config(0x29, val);
-		}
-		else if (val == 585000000) {
-			SetGPUpll_config(0x2B, val);
-		}
-	
-		internal_max = val;
-
-	}
-	
 	mutex_lock(&device->mutex);
 	level = _get_nearest_pwrlevel(pwr, val);
 	if (level < 0)
@@ -481,13 +439,8 @@
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-
-	if (max_gpu)
-		return snprintf(buf, PAGE_SIZE, "%ld\n",
-				internal_max);
-	else
-		return snprintf(buf, PAGE_SIZE, "%d\n",
-				pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
 }
 
 static int kgsl_pwrctrl_gpuclk_store(struct device *dev,
@@ -526,12 +479,8 @@
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-	if (pwr->active_pwrlevel != 0 || !max_gpu)
-		return snprintf(buf, PAGE_SIZE, "%d\n",
+	return snprintf(buf, PAGE_SIZE, "%d\n",
 			pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq);
-	else
-		return snprintf(buf, PAGE_SIZE, "%ld\n",
-			internal_max);
 }
 
 static int kgsl_pwrctrl_idle_timer_store(struct device *dev,
@@ -677,19 +626,8 @@
 		return 0;
 	pwr = &device->pwrctrl;
 	for (index = 0; index < pwr->num_pwrlevels - 1; index++)
-
-		if (index == 0 && max_gpu)
-		{
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",585000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",558000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",531000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",504000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",490500000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",477000000);
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",450000000);
-		}
-		else
-			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",pwr->pwrlevels[index].gpu_freq);
+		num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",
+		pwr->pwrlevels[index].gpu_freq);
 	buf[num_chars++] = '\n';
 	return num_chars;
 }
@@ -828,12 +766,12 @@
 DEVICE_ATTR(num_pwrlevels, 0444,
 	kgsl_pwrctrl_num_pwrlevels_show,
 	NULL);
-DEVICE_ATTR(pmqos_latency, 0644,
-	kgsl_pwrctrl_pmqos_latency_show,
-	kgsl_pwrctrl_pmqos_latency_store);
 DEVICE_ATTR(reset_count, 0444,
 	kgsl_pwrctrl_reset_count_show,
 	NULL);
+DEVICE_ATTR(pmqos_latency, 0644,
+	kgsl_pwrctrl_pmqos_latency_show,
+	kgsl_pwrctrl_pmqos_latency_store);
 DEVICE_ATTR(force_clk_on, 0644,
 	kgsl_pwrctrl_force_clk_on_show,
 	kgsl_pwrctrl_force_clk_on_store);
@@ -855,8 +793,8 @@
 	&dev_attr_min_pwrlevel,
 	&dev_attr_thermal_pwrlevel,
 	&dev_attr_num_pwrlevels,
-	&dev_attr_pmqos_latency,
 	&dev_attr_reset_count,
+	&dev_attr_pmqos_latency,
 	&dev_attr_force_clk_on,
 	&dev_attr_force_bus_on,
 	&dev_attr_force_rail_on,
@@ -1394,6 +1332,8 @@
 		break;
 	}
 
+	kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
+
 	return 0;
 }
 
@@ -1443,6 +1383,7 @@
 		break;
 	case KGSL_STATE_SLEEP:
 		status = _sleep(device);
+		kgsl_mmu_disable_clk_on_ts(&device->mmu, 0, false);
 		break;
 	case KGSL_STATE_SLUMBER:
 		status = _slumber(device);
@@ -1493,7 +1434,6 @@
 			kgsl_pwrstate_to_str(state),
 			context ? context->id : -1, ts_processed);
 		kgsl_context_put(context);
-
 		/* fall through */
 	case KGSL_STATE_NAP:
 		/* Turn on the core clocks */
@@ -1524,10 +1464,7 @@
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
 	/* Order pwrrail/clk sequence based upon platform */
 	kgsl_pwrctrl_pwrrail(device, KGSL_PWRFLAGS_ON);
-
-	if (pwr->constraint.type == KGSL_CONSTRAINT_NONE)
-		kgsl_pwrctrl_pwrlevel_change(device, pwr->default_pwrlevel);
-
+	kgsl_pwrctrl_pwrlevel_change(device, pwr->default_pwrlevel);
 	kgsl_pwrctrl_clk(device, KGSL_PWRFLAGS_ON, KGSL_STATE_ACTIVE);
 	kgsl_pwrctrl_axi(device, KGSL_PWRFLAGS_ON);
 }
@@ -1600,11 +1537,13 @@
 	int ret = 0;
 	BUG_ON(!mutex_is_locked(&device->mutex));
 
-	if ((atomic_read(&device->active_cnt) == 0) &&
-		(device->state != KGSL_STATE_ACTIVE)) {
-		mutex_unlock(&device->mutex);
-		wait_for_completion(&device->hwaccess_gate);
-		mutex_lock(&device->mutex);
+	if (atomic_read(&device->active_cnt) == 0) {
+		if (device->requested_state == KGSL_STATE_SUSPEND ||
+				device->state == KGSL_STATE_SUSPEND) {
+			mutex_unlock(&device->mutex);
+			wait_for_completion(&device->hwaccess_gate);
+			mutex_lock(&device->mutex);
+		}
 
 		ret = kgsl_pwrctrl_wake(device);
 	}
@@ -1657,9 +1596,12 @@
 
 	if (atomic_dec_and_test(&device->active_cnt)) {
 		if (device->state == KGSL_STATE_ACTIVE &&
-			device->requested_state == KGSL_STATE_NONE) {
+				 device->requested_state == KGSL_STATE_NONE) {
 			kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
-			queue_work(device->work_queue, &device->idle_check_ws);
+			if (kgsl_pwrctrl_sleep(device)) {
+				kgsl_pwrctrl_request_state(device, KGSL_STATE_NAP);
+				queue_work(device->work_queue, &device->idle_check_ws);
+			}
 		}
 
 		mod_timer(&device->idle_timer,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrctrl.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrctrl.h	2014-09-21 01:02:11.000000000 +0000
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -27,18 +27,6 @@
 
 #define KGSL_MAX_CLKS 6
 
-/* Only two supported levels, min & max */
-#define KGSL_CONSTRAINT_PWR_MAXLEVELS 2
-
-/* Symbolic table for the constraint type */
-#define KGSL_CONSTRAINT_TYPES \
-	{ KGSL_CONSTRAINT_NONE, "None" }, \
-	{ KGSL_CONSTRAINT_PWRLEVEL, "Pwrlevel" }
-/* Symbolic table for the constraint sub type */
-#define KGSL_CONSTRAINT_PWRLEVEL_SUBTYPES \
-	{ KGSL_CONSTRAINT_PWR_MIN, "Min" }, \
-	{ KGSL_CONSTRAINT_PWR_MAX, "Max" }
-
 struct platform_device;
 
 struct kgsl_clk_stats {
@@ -52,18 +40,6 @@
 	unsigned int elapsed_old;
 };
 
-struct kgsl_pwr_constraint {
-	unsigned int type;
-	unsigned int sub_type;
-	union {
-		struct {
-			unsigned int level;
-		} pwrlevel;
-	} hint;
-	unsigned long expires;
-	uint32_t owner_id;
-};
-
 /**
  * struct kgsl_pwrctrl - Power control settings for a KGSL device
  * @interrupt_num - The interrupt number for the device
@@ -89,7 +65,6 @@
  * @pm_qos_req_dma - the power management quality of service structure
  * @pm_qos_latency - allowed CPU latency in microseconds
  * @step_mul - multiplier for moving between power levels
- * @constraint - currently active power constraint
  */
 
 struct kgsl_pwrctrl {
@@ -119,7 +94,6 @@
 	unsigned int pm_qos_latency;
 	unsigned int step_mul;
 	unsigned int irq_last;
-	struct kgsl_pwr_constraint constraint;
 };
 
 void kgsl_pwrctrl_irq(struct kgsl_device *device, int state);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrscale_trustzone.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_pwrscale_trustzone.c	2014-09-21 01:02:11.000000000 +0000
@@ -22,17 +22,9 @@
 #include "kgsl.h"
 #include "kgsl_pwrscale.h"
 #include "kgsl_device.h"
-#include "kgsl_trace.h"
-
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-#include <linux/module.h>
-#endif
 
 #define TZ_GOVERNOR_PERFORMANCE 0
 #define TZ_GOVERNOR_ONDEMAND    1
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-#define TZ_GOVERNOR_SIMPLE	2
-#endif
 
 struct tz_priv {
 	int governor;
@@ -87,10 +79,6 @@
 
 	if (priv->governor == TZ_GOVERNOR_ONDEMAND)
 		ret = snprintf(buf, 10, "ondemand\n");
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-	else if (priv->governor == TZ_GOVERNOR_SIMPLE)
-		ret = snprintf(buf, 8, "simple\n");
-#endif
 	else
 		ret = snprintf(buf, 13, "performance\n");
 
@@ -114,10 +102,6 @@
 
 	if (!strncmp(str, "ondemand", 8))
 		priv->governor = TZ_GOVERNOR_ONDEMAND;
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-	else if (!strncmp(str, "simple", 6))
-		priv->governor = TZ_GOVERNOR_SIMPLE;
-#endif
 	else if (!strncmp(str, "performance", 11))
 		priv->governor = TZ_GOVERNOR_PERFORMANCE;
 
@@ -147,60 +131,11 @@
 {
 	struct tz_priv *priv = pwrscale->priv;
 	if (device->state != KGSL_STATE_NAP &&
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-		(priv->governor == TZ_GOVERNOR_ONDEMAND ||
-		 priv->governor == TZ_GOVERNOR_SIMPLE))
-#else
 		priv->governor == TZ_GOVERNOR_ONDEMAND)
-#endif
-		if (device->pwrctrl.constraint.type == KGSL_CONSTRAINT_NONE)
-			kgsl_pwrctrl_pwrlevel_change(device,
+		kgsl_pwrctrl_pwrlevel_change(device,
 					device->pwrctrl.default_pwrlevel);
 }
 
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-/* KGSL Simple GPU Governor */
-/* Copyright (c) 2011-2013, Paul Reioux (Faux123). All rights reserved. */
-static int default_laziness = 5;
-module_param_named(simple_laziness, default_laziness, int, 0664);
-
-static int ramp_up_threshold = 6000;
-module_param_named(simple_ramp_threshold, ramp_up_threshold, int, 0664);
-
-static int laziness;
-
-static int simple_governor(struct kgsl_device *device, int idle_stat)
-{
-	int val = 0;
-	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-
-	/* it's currently busy */
-	if (idle_stat < ramp_up_threshold) {
-		if (pwr->active_pwrlevel == 0)
-			val = 0; /* already maxed, so do nothing */
-		else if ((pwr->active_pwrlevel > 0) &&
-			(pwr->active_pwrlevel <= (pwr->num_pwrlevels - 1)))
-			val = -1; /* bump up to next pwrlevel */
-	/* idle case */
-	} else {
-		if ((pwr->active_pwrlevel >= 0) &&
-			(pwr->active_pwrlevel < (pwr->num_pwrlevels - 1)))
-			if (laziness > 0) {
-				/* hold off for a while */
-				laziness--;
-				val = 0; /* don't change anything yet */
-			} else {
-				val = 1; /* above min, lower it */
-				/* reset laziness count */
-				laziness = default_laziness;
-			}
-		else if (pwr->active_pwrlevel == (pwr->num_pwrlevels - 1))
-			val = 0; /* already @ min, so do nothing */
-	}
-	return val;
-}
-#endif
-
 static void tz_idle(struct kgsl_device *device, struct kgsl_pwrscale *pwrscale)
 {
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
@@ -224,13 +159,11 @@
 		(priv->bin.total_time < FLOOR))
 		return;
 
-	/* If there is an extended block of busy processing, set
-	 * frequency to turbo.  Otherwise run the normal algorithm.
+	/* If there is an extended block of busy processing,
+	 * increase frequency.  Otherwise run the normal algorithm.
 	 */
 	if (priv->bin.busy_time > CEILING) {
-		val = 0;
-		kgsl_pwrctrl_pwrlevel_change(device,
-				KGSL_PWRLEVEL_TURBO);
+		val = -1;
 	} else if (priv->idle_dcvs) {
 		idle = priv->bin.total_time - priv->bin.busy_time;
 		idle = (idle > 0) ? idle : 0;
@@ -241,22 +174,9 @@
 				(pwr->active_pwrlevel + 1)/2,
 				priv->bin.total_time, priv->bin.busy_time);
 		else
-#ifdef CONFIG_MSM_KGSL_SIMPLE_GOV
-			{
-			idle = priv->bin.total_time - priv->bin.busy_time;
-			idle = (idle > 0) ? idle : 0;
-			if (priv->governor == TZ_GOVERNOR_SIMPLE)
-				val = simple_governor(device, idle);
-			else
-				val = __secure_tz_entry3(TZ_UPDATE_ID,
-				pwr->active_pwrlevel,
-				priv->bin.total_time, priv->bin.busy_time);
-			}
-#else
 			val = __secure_tz_entry3(TZ_UPDATE_ID,
 				pwr->active_pwrlevel,
 				priv->bin.total_time, priv->bin.busy_time);
-#endif
 	}
 
 	priv->bin.total_time = 0;
@@ -267,21 +187,9 @@
 	 */
 	if (val > 0)
 		val *= pwr->step_mul;
-
-	if ((pwr->constraint.type == KGSL_CONSTRAINT_NONE) ||
-			(time_after(jiffies, pwr->constraint.expires))) {
-
+	if (val)
 		kgsl_pwrctrl_pwrlevel_change(device,
 					     pwr->active_pwrlevel + val);
-		if (pwr->constraint.type != KGSL_CONSTRAINT_NONE) {
-			/* Trace the constraint being un-set by the driver */
-			trace_kgsl_constraint(device,
-				pwr->constraint.type,
-				pwr->active_pwrlevel, 0);
-			/*Invalidate the constraint set */
-			pwr->constraint.type = KGSL_CONSTRAINT_NONE;
-		}
-	}
 }
 
 static void tz_busy(struct kgsl_device *device,
@@ -295,7 +203,7 @@
 {
 	struct tz_priv *priv = pwrscale->priv;
 
-	kgsl_pwrctrl_pwrlevel_change(device, 3);
+	__secure_tz_entry2(TZ_RESET_ID, 0, 0);
 	priv->bin.total_time = 0;
 	priv->bin.busy_time = 0;
 }
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.c	2014-09-21 01:02:11.000000000 +0000
@@ -390,6 +390,16 @@
 	return VM_FAULT_SIGBUS;
 }
 
+static int kgsl_page_alloc_vmflags(struct kgsl_memdesc *memdesc)
+{
+	return VM_RESERVED | VM_DONTEXPAND;
+}
+
+static int kgsl_contiguous_vmflags(struct kgsl_memdesc *memdesc)
+{
+	return VM_RESERVED | VM_IO | VM_PFNMAP | VM_DONTEXPAND;
+}
+
 /*
  * kgsl_page_alloc_unmap_kernel() - Unmap the memory in memdesc
  *
@@ -508,37 +518,76 @@
 	return VM_FAULT_NOPAGE;
 }
 
-static void kgsl_coherent_free(struct kgsl_memdesc *memdesc)
+static void kgsl_ebimem_unmap_kernel(struct kgsl_memdesc *memdesc)
+{
+	mutex_lock(&kernel_map_global_lock);
+	if (!memdesc->hostptr) {
+		BUG_ON(memdesc->hostptr_count);
+		goto done;
+	}
+	memdesc->hostptr_count--;
+	if (memdesc->hostptr_count)
+		goto done;
+
+	iounmap(memdesc->hostptr);
+	memdesc->hostptr = NULL;
+done:
+	mutex_unlock(&kernel_map_global_lock);
+}
+
+static void kgsl_ebimem_free(struct kgsl_memdesc *memdesc)
+
 {
 	kgsl_driver.stats.coherent -= memdesc->size;
-	dma_free_coherent(NULL, memdesc->size,
-			  memdesc->hostptr, memdesc->physaddr);
+	kgsl_ebimem_unmap_kernel(memdesc);
+	/* we certainly do not expect the hostptr to still be mapped */
+	BUG_ON(memdesc->hostptr);
+
+	free_contiguous_memory_by_paddr(memdesc->physaddr);
 }
 
-static void kgsl_cma_coherent_free(struct kgsl_memdesc *memdesc)
+static int kgsl_ebimem_map_kernel(struct kgsl_memdesc *memdesc)
 {
-	if (memdesc->hostptr) {
-		kgsl_driver.stats.coherent -= memdesc->size;
-		dma_free_coherent(memdesc->dev, memdesc->size,
-				memdesc->hostptr, memdesc->physaddr);
+	int ret = 0;
+	mutex_lock(&kernel_map_global_lock);
+	if (!memdesc->hostptr) {
+		memdesc->hostptr = ioremap(memdesc->physaddr, memdesc->size);
+		if (!memdesc->hostptr) {
+			KGSL_CORE_ERR("ioremap failed, addr:0x%p, size:0x%x\n",
+				memdesc->hostptr, memdesc->size);
+			ret = -ENOMEM;
+			goto done;
+		}
 	}
+	memdesc->hostptr_count++;
+done:
+	mutex_unlock(&kernel_map_global_lock);
+	return ret;
+}
+
+static void kgsl_coherent_free(struct kgsl_memdesc *memdesc)
+{
+	kgsl_driver.stats.coherent -= memdesc->size;
+	dma_free_coherent(NULL, memdesc->size,
+			  memdesc->hostptr, memdesc->physaddr);
 }
 
 /* Global - also used by kgsl_drm.c */
 struct kgsl_memdesc_ops kgsl_page_alloc_ops = {
 	.free = kgsl_page_alloc_free,
-	.vmflags = VM_NODUMP | VM_DONTEXPAND | VM_DONTCOPY,
+	.vmflags = kgsl_page_alloc_vmflags,
 	.vmfault = kgsl_page_alloc_vmfault,
 	.map_kernel = kgsl_page_alloc_map_kernel,
 	.unmap_kernel = kgsl_page_alloc_unmap_kernel,
 };
 EXPORT_SYMBOL(kgsl_page_alloc_ops);
 
-/* CMA ops - used during NOMMU mode */
-static struct kgsl_memdesc_ops kgsl_cma_ops = {
-	.free = kgsl_cma_coherent_free,
-	.vmflags = VM_NODUMP | VM_PFNMAP | VM_DONTEXPAND | VM_DONTCOPY,
+static struct kgsl_memdesc_ops kgsl_ebimem_ops = {
+	.free = kgsl_ebimem_free,
+	.vmflags = kgsl_contiguous_vmflags,
 	.vmfault = kgsl_contiguous_vmfault,
+	.map_kernel = kgsl_ebimem_map_kernel,
+	.unmap_kernel = kgsl_ebimem_unmap_kernel,
 };
 
 static struct kgsl_memdesc_ops kgsl_coherent_ops = {
@@ -579,15 +628,13 @@
 			struct kgsl_pagetable *pagetable,
 			size_t size)
 {
-	int order, ret = 0;
-	int page_size, sglen_alloc, sglen = 0;
+	int pcount = 0, order, ret = 0;
+	int j, len, page_size, sglen_alloc, sglen = 0;
+	struct page **pages = NULL;
+	pgprot_t page_prot = pgprot_writecombine(PAGE_KERNEL);
 	void *ptr;
-	size_t len;
 	unsigned int align;
-
-	size = PAGE_ALIGN(size);
-	if (size == 0 || size > UINT_MAX)
-		return -EINVAL;
+	int step = ((VMALLOC_END - VMALLOC_START)/8) >> PAGE_SHIFT;
 
 	align = (memdesc->flags & KGSL_MEMALIGN_MASK) >> KGSL_MEMALIGN_SHIFT;
 
@@ -604,6 +651,7 @@
 
 	sglen_alloc = PAGE_ALIGN(size) >> PAGE_SHIFT;
 
+	memdesc->size = size;
 	memdesc->pagetable = pagetable;
 	memdesc->ops = &kgsl_page_alloc_ops;
 
@@ -615,6 +663,24 @@
 		goto done;
 	}
 
+	/*
+	 * Allocate space to store the list of pages to send to vmap.
+	 * This is an array of pointers so we can t rack 1024 pages per page
+	 * of allocation.  Since allocations can be as large as the user dares,
+	 * we have to use the kmalloc/vmalloc trick here to make sure we can
+	 * get the memory we need.
+	 */
+
+	if ((memdesc->sglen_alloc * sizeof(struct page *)) > PAGE_SIZE)
+		pages = vmalloc(memdesc->sglen_alloc * sizeof(struct page *));
+	else
+		pages = kmalloc(PAGE_SIZE, GFP_KERNEL);
+
+	if (pages == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
 	kmemleak_not_leak(memdesc->sg);
 
 	sg_init_table(memdesc->sg, memdesc->sglen_alloc);
@@ -640,8 +706,6 @@
 		else
 			gfp_mask |= GFP_KERNEL;
 
-		gfp_mask |= __GFP_ZERO;
-
 		page = alloc_pages(gfp_mask, get_order(page_size));
 
 		if (page == NULL) {
@@ -650,14 +714,6 @@
 				continue;
 			}
 
-			/*
-			 * Update sglen and memdesc size,as requested allocation
-			 * not served fully. So that they can be correctly freed
-			 * in kgsl_sharedmem_free().
-			 */
-			memdesc->sglen = sglen;
-			memdesc->size = (size - len);
-
 			KGSL_CORE_ERR(
 				"Out of memory: only allocated %dKB of %dKB requested\n",
 				(size - len) >> 10, size >> 10);
@@ -666,31 +722,73 @@
 			goto done;
 		}
 
-		for (j = 0; j < page_size >> PAGE_SHIFT; j++) {
-			struct page *p = nth_page(page, j);
-			ptr = kmap_atomic(p);
-			dmac_flush_range(ptr, ptr + PAGE_SIZE);
-			kunmap_atomic(ptr);
-		}
+		for (j = 0; j < page_size >> PAGE_SHIFT; j++)
+			pages[pcount++] = nth_page(page, j);
 
 		sg_set_page(&memdesc->sg[sglen++], page, page_size, 0);
 		len -= page_size;
 	}
 
 	memdesc->sglen = sglen;
-	memdesc->size = size;
+
+	/*
+	 * All memory that goes to the user has to be zeroed out before it gets
+	 * exposed to userspace. This means that the memory has to be mapped in
+	 * the kernel, zeroed (memset) and then unmapped.  This also means that
+	 * the dcache has to be flushed to ensure coherency between the kernel
+	 * and user pages. We used to pass __GFP_ZERO to alloc_page which mapped
+	 * zeroed and unmaped each individual page, and then we had to turn
+	 * around and call flush_dcache_page() on that page to clear the caches.
+	 * This was killing us for performance. Instead, we found it is much
+	 * faster to allocate the pages without GFP_ZERO, map a chunk of the
+	 * range ('step' pages), memset it, flush it and then unmap
+	 * - this results in a factor of 4 improvement for speed for large
+	 * buffers. There is a small decrease in speed for small buffers,
+	 * but only on the order of a few microseconds at best. The 'step'
+	 * size is based on a guess at the amount of free vmalloc space, but
+	 * will scale down if there's not enough free space.
+	 */
+	for (j = 0; j < pcount; j += step) {
+		step = min(step, pcount - j);
+
+		ptr = vmap(&pages[j], step, VM_IOREMAP, page_prot);
+
+		if (ptr != NULL) {
+			memset(ptr, 0, step * PAGE_SIZE);
+			dmac_flush_range(ptr, ptr + step * PAGE_SIZE);
+			vunmap(ptr);
+		} else {
+			int k;
+			/* Very, very, very slow path */
+
+			for (k = j; k < j + step; k++) {
+				ptr = kmap_atomic(pages[k]);
+				memset(ptr, 0, PAGE_SIZE);
+				dmac_flush_range(ptr, ptr + PAGE_SIZE);
+				kunmap_atomic(ptr);
+			}
+			/* scale down the step size to avoid this path */
+			if (step > 1)
+				step >>= 1;
+		}
+	}
 
 	outer_cache_range_op_sg(memdesc->sg, memdesc->sglen,
 				KGSL_CACHE_OP_FLUSH);
 
+	KGSL_STATS_ADD(size, kgsl_driver.stats.page_alloc,
+		kgsl_driver.stats.page_alloc_max);
+
 	order = get_order(size);
 
 	if (order < 16)
 		kgsl_driver.stats.histogram[order]++;
 
 done:
-	KGSL_STATS_ADD(memdesc->size, kgsl_driver.stats.page_alloc,
-		kgsl_driver.stats.page_alloc_max);
+	if ((memdesc->sglen_alloc * sizeof(struct page *)) > PAGE_SIZE)
+		vfree(pages);
+	else
+		kfree(pages);
 
 	if (ret)
 		kgsl_sharedmem_free(memdesc);
@@ -787,6 +885,77 @@
 }
 EXPORT_SYMBOL(kgsl_sharedmem_free);
 
+static int
+_kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable, size_t size)
+{
+	int result = 0;
+
+	memdesc->size = size;
+	memdesc->pagetable = pagetable;
+	memdesc->ops = &kgsl_ebimem_ops;
+	memdesc->physaddr = allocate_contiguous_ebi_nomap(size, SZ_8K);
+
+	if (memdesc->physaddr == 0) {
+		KGSL_CORE_ERR("allocate_contiguous_ebi_nomap(%d) failed\n",
+			size);
+		return -ENOMEM;
+	}
+
+	result = memdesc_sg_phys(memdesc, memdesc->physaddr, size);
+
+	if (result)
+		goto err;
+
+	KGSL_STATS_ADD(size, kgsl_driver.stats.coherent,
+		kgsl_driver.stats.coherent_max);
+
+err:
+	if (result)
+		kgsl_sharedmem_free(memdesc);
+
+	return result;
+}
+
+int
+kgsl_sharedmem_ebimem_user(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable,
+			size_t size)
+{
+	size = ALIGN(size, PAGE_SIZE);
+	if (size == 0)
+		return -EINVAL;
+
+	return _kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+}
+EXPORT_SYMBOL(kgsl_sharedmem_ebimem_user);
+
+int
+kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+		struct kgsl_pagetable *pagetable, size_t size)
+{
+	int result;
+	size = ALIGN(size, 8192);
+	if (size == 0)
+		return -EINVAL;
+
+	result = _kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+
+	if (result)
+		return result;
+
+	result = kgsl_ebimem_map_kernel(memdesc);
+
+	if (result) {
+		KGSL_CORE_ERR("hostptr mapping failed\n");
+		kgsl_sharedmem_free(memdesc);
+		return result;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(kgsl_sharedmem_ebimem);
+
 int
 kgsl_sharedmem_readl(const struct kgsl_memdesc *memdesc,
 			uint32_t *dst,
@@ -915,42 +1084,3 @@
 		snprintf(name, name_size, "unknown(%3d)", type);
 }
 EXPORT_SYMBOL(kgsl_get_memory_usage);
-
-int kgsl_cma_alloc_coherent(struct kgsl_device *device,
-			struct kgsl_memdesc *memdesc,
-			struct kgsl_pagetable *pagetable, size_t size)
-{
-	int result = 0;
-
-	if (size == 0)
-		return -EINVAL;
-
-	memdesc->size = size;
-	memdesc->pagetable = pagetable;
-	memdesc->ops = &kgsl_cma_ops;
-	memdesc->dev = device->dev->parent;
-
-	memdesc->hostptr = dma_alloc_coherent(memdesc->dev, size,
-					&memdesc->physaddr, GFP_KERNEL);
-
-	if (memdesc->hostptr == NULL) {
-		result = -ENOMEM;
-		goto err;
-	}
-
-	result = memdesc_sg_phys(memdesc, memdesc->physaddr, size);
-	if (result)
-		goto err;
-
-	/* Record statistics */
-
-	KGSL_STATS_ADD(size, kgsl_driver.stats.coherent,
-		       kgsl_driver.stats.coherent_max);
-
-err:
-	if (result)
-		kgsl_sharedmem_free(memdesc);
-
-	return result;
-}
-EXPORT_SYMBOL(kgsl_cma_alloc_coherent);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sharedmem.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sharedmem.h	2014-09-21 01:02:11.000000000 +0000
@@ -41,9 +41,13 @@
 
 int kgsl_sharedmem_alloc_coherent(struct kgsl_memdesc *memdesc, size_t size);
 
-int kgsl_cma_alloc_coherent(struct kgsl_device *device,
-			struct kgsl_memdesc *memdesc,
-			struct kgsl_pagetable *pagetable, size_t size);
+int kgsl_sharedmem_ebimem_user(struct kgsl_memdesc *memdesc,
+			     struct kgsl_pagetable *pagetable,
+			     size_t size);
+
+int kgsl_sharedmem_ebimem(struct kgsl_memdesc *memdesc,
+			struct kgsl_pagetable *pagetable,
+			size_t size);
 
 void kgsl_sharedmem_free(struct kgsl_memdesc *memdesc);
 
@@ -137,13 +141,15 @@
 
 static inline void *kgsl_sg_alloc(unsigned int sglen)
 {
-	if ((sglen == 0) || (sglen >= ULONG_MAX / sizeof(struct scatterlist)))
-		return NULL;
-
 	if ((sglen * sizeof(struct scatterlist)) <  PAGE_SIZE)
 		return kzalloc(sglen * sizeof(struct scatterlist), GFP_KERNEL);
-	else
-		return vmalloc(sglen * sizeof(struct scatterlist));
+	else {
+		void *ptr = vmalloc(sglen * sizeof(struct scatterlist));
+		if (ptr)
+			memset(ptr, 0, sglen * sizeof(struct scatterlist));
+
+		return ptr;
+	}
 }
 
 static inline void kgsl_sg_free(void *ptr, unsigned int sglen)
@@ -159,7 +165,7 @@
 		phys_addr_t physaddr, unsigned int size)
 {
 	memdesc->sg = kgsl_sg_alloc(1);
-	if (memdesc->sg == NULL)
+	if (!memdesc->sg)
 		return -ENOMEM;
 
 	kmemleak_not_leak(memdesc->sg);
@@ -249,16 +255,14 @@
 }
 
 static inline int
-kgsl_allocate(struct kgsl_device *device, struct kgsl_memdesc *memdesc,
+kgsl_allocate(struct kgsl_memdesc *memdesc,
 		struct kgsl_pagetable *pagetable, size_t size)
 {
 	int ret;
 	memdesc->priv |= (KGSL_MEMTYPE_KERNEL << KGSL_MEMTYPE_SHIFT);
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE) {
-		size = ALIGN(size, PAGE_SIZE * 2);
-		return kgsl_cma_alloc_coherent(device, memdesc, pagetable,
-						size);
-	}
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
+		return kgsl_sharedmem_ebimem(memdesc, pagetable, size);
+
 	ret = kgsl_sharedmem_page_alloc(memdesc, pagetable, size);
 	if (ret)
 		return ret;
@@ -274,8 +278,7 @@
 }
 
 static inline int
-kgsl_allocate_user(struct kgsl_device *device,
-		struct kgsl_memdesc *memdesc,
+kgsl_allocate_user(struct kgsl_memdesc *memdesc,
 		struct kgsl_pagetable *pagetable,
 		size_t size, unsigned int flags)
 {
@@ -286,10 +289,8 @@
 
 	memdesc->flags = flags;
 
-	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE) {
-		size = ALIGN(size, PAGE_SIZE);
-		ret = kgsl_cma_alloc_coherent(device, memdesc, pagetable, size);
-	}
+	if (kgsl_mmu_get_mmutype() == KGSL_MMU_TYPE_NONE)
+		ret = kgsl_sharedmem_ebimem_user(memdesc, pagetable, size);
 	else
 		ret = kgsl_sharedmem_page_alloc_user(memdesc, pagetable, size);
 
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_snapshot.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_snapshot.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_snapshot.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_snapshot.c	2014-09-21 01:02:11.000000000 +0000
@@ -210,8 +210,10 @@
 	header->ctxtcount = ctxtcount;
 
 	_ctxtptr = snapshot + sizeof(*header);
+
 	/* append information for the global context */
 	snapshot_context_info(KGSL_MEMSTORE_GLOBAL, NULL, device);
+
 	/* append information for each context */
 
 	read_lock(&device->context_lock);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.c flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.c
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.c	2014-09-21 01:02:11.000000000 +0000
@@ -13,9 +13,12 @@
 
 #include <linux/err.h>
 #include <linux/file.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
+#include <asm/current.h>
+
 #include "kgsl_sync.h"
 
 struct sync_pt *kgsl_sync_pt_create(struct sync_timeline *timeline,
@@ -87,7 +90,9 @@
 	void *priv, u32 context_id, u32 timestamp, u32 type)
 {
 	struct kgsl_fence_event_priv *ev = priv;
-	kgsl_sync_timeline_signal(ev->context->timeline, ev->timestamp);
+
+	/* Signal time timeline for every event type */
+	kgsl_sync_timeline_signal(ev->context->timeline, timestamp);
 	kgsl_context_put(ev->context);
 	kfree(ev);
 }
@@ -125,8 +130,10 @@
 
 	context = kgsl_context_get_owner(owner, context_id);
 
-	if (context == NULL)
-		goto fail_pt;
+	if (context == NULL) {
+		kfree(event);
+		return -EINVAL;
+	}
 
 	event->context = context;
 	event->timestamp = timestamp;
@@ -185,6 +192,35 @@
 	return ret;
 }
 
+static unsigned int kgsl_sync_get_timestamp(
+	struct kgsl_sync_timeline *ktimeline, enum kgsl_timestamp_type type)
+{
+	struct kgsl_context *context = idr_find(&ktimeline->device->context_idr,
+						ktimeline->context_id);
+	if (context == NULL)
+		return 0;
+
+	return kgsl_readtimestamp(ktimeline->device, context, type);
+}
+
+static void kgsl_sync_timeline_value_str(struct sync_timeline *sync_timeline,
+					 char *str, int size)
+{
+	struct kgsl_sync_timeline *ktimeline =
+		(struct kgsl_sync_timeline *) sync_timeline;
+	unsigned int timestamp_retired = kgsl_sync_get_timestamp(ktimeline,
+		KGSL_TIMESTAMP_RETIRED);
+	snprintf(str, size, "%u retired:%u", ktimeline->last_timestamp,
+		timestamp_retired);
+}
+
+static void kgsl_sync_pt_value_str(struct sync_pt *sync_pt,
+				   char *str, int size)
+{
+	struct kgsl_sync_pt *kpt = (struct kgsl_sync_pt *) sync_pt;
+	snprintf(str, size, "%u", kpt->timestamp);
+}
+
 static void kgsl_sync_timeline_release_obj(struct sync_timeline *sync_timeline)
 {
 	/*
@@ -199,6 +235,8 @@
 	.dup = kgsl_sync_pt_dup,
 	.has_signaled = kgsl_sync_pt_has_signaled,
 	.compare = kgsl_sync_pt_compare,
+	.timeline_value_str = kgsl_sync_timeline_value_str,
+	.pt_value_str = kgsl_sync_pt_value_str,
 	.release_obj = kgsl_sync_timeline_release_obj,
 };
 
@@ -206,13 +244,25 @@
 {
 	struct kgsl_sync_timeline *ktimeline;
 
+	/* Generate a name which includes the thread name, thread id, process
+	 * name, process id, and context id. This makes it possible to
+	 * identify the context of a timeline in the sync dump. */
+	char ktimeline_name[sizeof(context->timeline->name)] = {};
+	snprintf(ktimeline_name, sizeof(ktimeline_name),
+		"%s_%.15s(%d)-%.15s(%d)-%d",
+		context->device->name,
+		current->group_leader->comm, current->group_leader->pid,
+		current->comm, current->pid, context->id);
+
 	context->timeline = sync_timeline_create(&kgsl_sync_timeline_ops,
-		(int) sizeof(struct kgsl_sync_timeline), "kgsl-timeline");
+		(int) sizeof(struct kgsl_sync_timeline), ktimeline_name);
 	if (context->timeline == NULL)
 		return -EINVAL;
 
 	ktimeline = (struct kgsl_sync_timeline *) context->timeline;
 	ktimeline->last_timestamp = 0;
+	ktimeline->device = context->dev_priv->device;
+	ktimeline->context_id = context->id;
 
 	return 0;
 }
@@ -255,7 +305,7 @@
 		return ERR_PTR(-EINVAL);
 
 	/* create the waiter */
-	kwaiter = kzalloc(sizeof(*kwaiter), GFP_ATOMIC);
+	kwaiter = kzalloc(sizeof(*kwaiter), GFP_KERNEL);
 	if (kwaiter == NULL) {
 		sync_fence_put(fence);
 		return ERR_PTR(-ENOMEM);
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_sync.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_sync.h	2014-09-21 01:02:11.000000000 +0000
@@ -19,6 +19,8 @@
 struct kgsl_sync_timeline {
 	struct sync_timeline timeline;
 	unsigned int last_timestamp;
+	struct kgsl_device *device;
+	u32 context_id;
 };
 
 struct kgsl_sync_pt {
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/kgsl_trace.h flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_trace.h
--- flo-ElementalX-5.00/drivers/gpu/msm/kgsl_trace.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/kgsl_trace.h	2014-09-21 01:02:11.000000000 +0000
@@ -676,36 +676,6 @@
 	)
 );
 
-TRACE_EVENT(kgsl_constraint,
-
-	TP_PROTO(struct kgsl_device *device, unsigned int type,
-		unsigned int value, unsigned int on),
-
-	TP_ARGS(device, type, value, on),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(unsigned int, type)
-		__field(unsigned int, value)
-		__field(unsigned int, on)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->type = type;
-		__entry->value = value;
-		__entry->on = on;
-	),
-
-	TP_printk(
-		"d_name=%s constraint_type=%s constraint_value=%u status=%s",
-		__get_str(device_name),
-		__print_symbolic(__entry->type, KGSL_CONSTRAINT_TYPES),
-		__entry->value,
-		__entry->on ? "ON" : "OFF"
-	)
-);
-
 TRACE_EVENT(kgsl_mmu_pagefault,
 
 	TP_PROTO(struct kgsl_device *device, unsigned int page,
diff -urN flo-ElementalX-5.00/drivers/gpu/msm/z180.c flo-ElementalX-5.00-patched/drivers/gpu/msm/z180.c
--- flo-ElementalX-5.00/drivers/gpu/msm/z180.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/gpu/msm/z180.c	2014-09-21 01:02:11.000000000 +0000
@@ -514,7 +514,7 @@
 	z180_cmdwindow_write(device, ADDR_VGV3_CONTROL, 0);
 error:
 	kgsl_trace_issueibcmds(device, context->id, cmdbatch,
-		*timestamp, cmdbatch ? cmdbatch->flags : 0, result, 0);
+		*timestamp, cmdbatch->flags, result, 0);
 
 	kgsl_active_count_put(device);
 error_active_count:
@@ -614,6 +614,7 @@
 
 	z180_cmdstream_start(device);
 
+	mod_timer(&device->idle_timer, jiffies + FIRST_TIMEOUT);
 	kgsl_pwrctrl_irq(device, KGSL_PWRFLAGS_ON);
 	device->ftbl->irqctrl(device, 1);
 
diff -urN flo-ElementalX-5.00/drivers/hid/hid-multitouch.c flo-ElementalX-5.00-patched/drivers/hid/hid-multitouch.c
--- flo-ElementalX-5.00/drivers/hid/hid-multitouch.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/hid/hid-multitouch.c	2016-06-01 16:27:31.000000000 +0000
@@ -278,9 +278,8 @@
 static void set_last_slot_field(struct hid_usage *usage, struct mt_device *td,
 		struct hid_input *hi)
 {
-	if ((BIT_WORD(usage->hid)) < (sizeof(hi->input->absbit) / sizeof(int)))
-		if (!test_bit(usage->hid, hi->input->absbit))
-			td->last_slot_field = usage->hid;
+	if (!test_bit(usage->hid, hi->input->absbit))
+		td->last_slot_field = usage->hid;
 }
 
 static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,

-/*
- * Driver for the i2c controller on the Marvell line of host bridges
- * (e.g, gt642[46]0, mv643[46]0, mv644[46]0, and Orion SoC family).
- *
- * Author: Mark A. Greer <mgreer@mvista.com>
- *
- * 2005 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/i2c.h>
-#include <linux/interrupt.h>
-#include <linux/mv643xx_i2c.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-
-/* Register defines */
-#define	MV64XXX_I2C_REG_SLAVE_ADDR			0x00
-#define	MV64XXX_I2C_REG_DATA				0x04
-#define	MV64XXX_I2C_REG_CONTROL				0x08
-#define	MV64XXX_I2C_REG_STATUS				0x0c
-#define	MV64XXX_I2C_REG_BAUD				0x0c
-#define	MV64XXX_I2C_REG_EXT_SLAVE_ADDR			0x10
-#define	MV64XXX_I2C_REG_SOFT_RESET			0x1c
-
-#define	MV64XXX_I2C_REG_CONTROL_ACK			0x00000004
-#define	MV64XXX_I2C_REG_CONTROL_IFLG			0x00000008
-#define	MV64XXX_I2C_REG_CONTROL_STOP			0x00000010
-#define	MV64XXX_I2C_REG_CONTROL_START			0x00000020
-#define	MV64XXX_I2C_REG_CONTROL_TWSIEN			0x00000040
-#define	MV64XXX_I2C_REG_CONTROL_INTEN			0x00000080
-
-/* Ctlr status values */
-#define	MV64XXX_I2C_STATUS_BUS_ERR			0x00
-#define	MV64XXX_I2C_STATUS_MAST_START			0x08
-#define	MV64XXX_I2C_STATUS_MAST_REPEAT_START		0x10
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK		0x18
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK		0x20
-#define	MV64XXX_I2C_STATUS_MAST_WR_ACK			0x28
-#define	MV64XXX_I2C_STATUS_MAST_WR_NO_ACK		0x30
-#define	MV64XXX_I2C_STATUS_MAST_LOST_ARB		0x38
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK		0x40
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK		0x48
-#define	MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK		0x50
-#define	MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK		0x58
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK		0xd0
-#define	MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_NO_ACK	0xd8
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK		0xe0
-#define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_NO_ACK	0xe8
-#define	MV64XXX_I2C_STATUS_NO_STATUS			0xf8
-
-/* Driver states */
-enum {
-	MV64XXX_I2C_STATE_INVALID,
-	MV64XXX_I2C_STATE_IDLE,
-	MV64XXX_I2C_STATE_WAITING_FOR_START_COND,
-	MV64XXX_I2C_STATE_WAITING_FOR_RESTART,
-	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK,
-	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA,
-};
-
-/* Driver actions */
-enum {
-	MV64XXX_I2C_ACTION_INVALID,
-	MV64XXX_I2C_ACTION_CONTINUE,
-	MV64XXX_I2C_ACTION_SEND_START,
-	MV64XXX_I2C_ACTION_SEND_RESTART,
-	MV64XXX_I2C_ACTION_SEND_ADDR_1,
-	MV64XXX_I2C_ACTION_SEND_ADDR_2,
-	MV64XXX_I2C_ACTION_SEND_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA_STOP,
-	MV64XXX_I2C_ACTION_SEND_STOP,
-};
-
-struct mv64xxx_i2c_data {
-	int			irq;
-	u32			state;
-	u32			action;
-	u32			aborting;
-	u32			cntl_bits;
-	void __iomem		*reg_base;
-	u32			reg_base_p;
-	u32			reg_size;
-	u32			addr1;
-	u32			addr2;
-	u32			bytes_left;
-	u32			byte_posn;
-	u32			send_stop;
-	u32			block;
-	int			rc;
-	u32			freq_m;
-	u32			freq_n;
-	wait_queue_head_t	waitq;
-	spinlock_t		lock;
-	struct i2c_msg		*msg;
-	struct i2c_adapter	adapter;
-};
-
-/*
- *****************************************************************************
- *
- *	Finite State Machine & Interrupt Routines
- *
- *****************************************************************************
- */
-
-/* Reset hardware and initialize FSM */
-static void
-mv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)
-{
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SOFT_RESET);
-	writel((((drv_data->freq_m & 0xf) << 3) | (drv_data->freq_n & 0x7)),
-		drv_data->reg_base + MV64XXX_I2C_REG_BAUD);
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SLAVE_ADDR);
-	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_EXT_SLAVE_ADDR);
-	writel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,
-		drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-	drv_data->state = MV64XXX_I2C_STATE_IDLE;
-}
-
-static void
-mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
-{
-	/*
-	 * If state is idle, then this is likely the remnants of an old
-	 * operation that driver has given up on or the user has killed.
-	 * If so, issue the stop condition and go to idle.
-	 */
-	if (drv_data->state == MV64XXX_I2C_STATE_IDLE) {
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		return;
-	}
-
-	/* The status from the ctlr [mostly] tells us what to do next */
-	switch (status) {
-	/* Start condition interrupt */
-	case MV64XXX_I2C_STATUS_MAST_START: /* 0x08 */
-	case MV64XXX_I2C_STATUS_MAST_REPEAT_START: /* 0x10 */
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;
-		drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;
-		break;
-
-	/* Performing a write */
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK: /* 0x18 */
-		if (drv_data->msg->flags & I2C_M_TEN) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK: /* 0xd0 */
-	case MV64XXX_I2C_STATUS_MAST_WR_ACK: /* 0x28 */
-		if ((drv_data->bytes_left == 0)
-				|| (drv_data->aborting
-					&& (drv_data->byte_posn != 0))) {
-			if (drv_data->send_stop) {
-				drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-				drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			} else {
-				drv_data->action =
-					MV64XXX_I2C_ACTION_SEND_RESTART;
-				drv_data->state =
-					MV64XXX_I2C_STATE_WAITING_FOR_RESTART;
-			}
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;
-			drv_data->bytes_left--;
-		}
-		break;
-
-	/* Performing a read */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK: /* 40 */
-		if (drv_data->msg->flags & I2C_M_TEN) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK: /* 0xe0 */
-		if (drv_data->bytes_left == 0) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-			drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			break;
-		}
-		/* FALLTHRU */
-	case MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK: /* 0x50 */
-		if (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)
-			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
-		else {
-			drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;
-			drv_data->bytes_left--;
-		}
-		drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;
-
-		if ((drv_data->bytes_left == 1) || drv_data->aborting)
-			drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;
-		break;
-
-	case MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK: /* 0x58 */
-		drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;
-		drv_data->state = MV64XXX_I2C_STATE_IDLE;
-		break;
-
-	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK: /* 0x20 */
-	case MV64XXX_I2C_STATUS_MAST_WR_NO_ACK: /* 30 */
-	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK: /* 48 */
-		/* Doesn't seem to be a device at other end */
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		drv_data->state = MV64XXX_I2C_STATE_IDLE;
-		drv_data->rc = -ENODEV;
-		break;
-
-	default:
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, "
-			"status: 0x%x, addr: 0x%x, flags: 0x%x\n",
-			 drv_data->state, status, drv_data->msg->addr,
-			 drv_data->msg->flags);
-		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-		mv64xxx_i2c_hw_init(drv_data);
-		drv_data->rc = -EIO;
-	}
-}
-
-static void
-mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
-{
-	switch(drv_data->action) {
-	case MV64XXX_I2C_ACTION_SEND_RESTART:
-		drv_data->cntl_bits |= MV64XXX_I2C_REG_CONTROL_START;
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-
-	case MV64XXX_I2C_ACTION_CONTINUE:
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_START:
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_ADDR_1:
-		writel(drv_data->addr1,
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_ADDR_2:
-		writel(drv_data->addr2,
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_SEND_DATA:
-		writel(drv_data->msg->buf[drv_data->byte_posn++],
-			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_RCV_DATA:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		break;
-
-	case MV64XXX_I2C_ACTION_RCV_DATA_STOP:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-
-	case MV64XXX_I2C_ACTION_INVALID:
-	default:
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx_i2c_do_action: Invalid action: %d\n",
-			drv_data->action);
-		drv_data->rc = -EIO;
-		/* FALLTHRU */
-	case MV64XXX_I2C_ACTION_SEND_STOP:
-		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
-		drv_data->block = 0;
-		wake_up_interruptible(&drv_data->waitq);
-		break;
-	}
-}
-
-static irqreturn_t
-mv64xxx_i2c_intr(int irq, void *dev_id)
-{
-	struct mv64xxx_i2c_data	*drv_data = dev_id;
-	unsigned long	flags;
-	u32		status;
-	irqreturn_t	rc = IRQ_NONE;
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
-						MV64XXX_I2C_REG_CONTROL_IFLG) {
-		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
-		mv64xxx_i2c_fsm(drv_data, status);
-		mv64xxx_i2c_do_action(drv_data);
-		rc = IRQ_HANDLED;
-	}
-	spin_unlock_irqrestore(&drv_data->lock, flags);
-
-	return rc;
-}
-
-/*
- *****************************************************************************
- *
- *	I2C Msg Execution Routines
- *
- *****************************************************************************
- */
-static void
-mv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,
-	struct i2c_msg *msg)
-{
-	u32	dir = 0;
-
-	drv_data->msg = msg;
-	drv_data->byte_posn = 0;
-	drv_data->bytes_left = msg->len;
-	drv_data->aborting = 0;
-	drv_data->rc = 0;
-	drv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |
-		MV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;
-
-	if (msg->flags & I2C_M_RD)
-		dir = 1;
-
-	if (msg->flags & I2C_M_TEN) {
-		drv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;
-		drv_data->addr2 = (u32)msg->addr & 0xff;
-	} else {
-		drv_data->addr1 = ((u32)msg->addr & 0x7f) << 1 | dir;
-		drv_data->addr2 = 0;
-	}
-}
-
-static void
-mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
-{
-	long		time_left;
-	unsigned long	flags;
-	char		abort = 0;
-
-	time_left = wait_event_interruptible_timeout(drv_data->waitq,
-		!drv_data->block, drv_data->adapter.timeout);
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	if (!time_left) { /* Timed out */
-		drv_data->rc = -ETIMEDOUT;
-		abort = 1;
-	} else if (time_left < 0) { /* Interrupted/Error */
-		drv_data->rc = time_left; /* errno value */
-		abort = 1;
-	}
-
-	if (abort && drv_data->block) {
-		drv_data->aborting = 1;
-		spin_unlock_irqrestore(&drv_data->lock, flags);
-
-		time_left = wait_event_timeout(drv_data->waitq,
-			!drv_data->block, drv_data->adapter.timeout);
-
-		if ((time_left <= 0) && drv_data->block) {
-			drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			dev_err(&drv_data->adapter.dev,
-				"mv64xxx: I2C bus locked, block: %d, "
-				"time_left: %d\n", drv_data->block,
-				(int)time_left);
-			mv64xxx_i2c_hw_init(drv_data);
-		}
-	} else
-		spin_unlock_irqrestore(&drv_data->lock, flags);
-}
-
-static int
-mv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,
-				int is_first, int is_last)
-{
-	unsigned long	flags;
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-	mv64xxx_i2c_prepare_for_io(drv_data, msg);
-
-	if (unlikely(msg->flags & I2C_M_NOSTART)) { /* Skip start/addr phases */
-		if (drv_data->msg->flags & I2C_M_RD) {
-			/* No action to do, wait for slave to send a byte */
-			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;
-			drv_data->bytes_left--;
-		}
-	} else {
-		if (is_first) {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_START;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_START_COND;
-		} else {
-			drv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;
-			drv_data->state =
-				MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;
-		}
-	}
-
-	drv_data->send_stop = is_last;
-	drv_data->block = 1;
-	mv64xxx_i2c_do_action(drv_data);
-	spin_unlock_irqrestore(&drv_data->lock, flags);
-
-	mv64xxx_i2c_wait_for_completion(drv_data);
-	return drv_data->rc;
-}
-
-/*
- *****************************************************************************
- *
- *	I2C Core Support Routines (Interface to higher level I2C code)
- *
- *****************************************************************************
- */
-static u32
-mv64xxx_i2c_functionality(struct i2c_adapter *adap)
-{
-	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
-}
-
-static int
-mv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-	int	i, rc;
-
-	for (i = 0; i < num; i++) {
-		rc = mv64xxx_i2c_execute_msg(drv_data, &msgs[i],
-						i == 0, i + 1 == num);
-		if (rc < 0)
-			return rc;
-	}
-
-	return num;
-}
-
-static const struct i2c_algorithm mv64xxx_i2c_algo = {
-	.master_xfer = mv64xxx_i2c_xfer,
-	.functionality = mv64xxx_i2c_functionality,
-};
-
-/*
- *****************************************************************************
- *
- *	Driver Interface & Early Init Routines
- *
- *****************************************************************************
- */
-static int __devinit
-mv64xxx_i2c_map_regs(struct platform_device *pd,
-	struct mv64xxx_i2c_data *drv_data)
-{
-	int size;
-	struct resource	*r = platform_get_resource(pd, IORESOURCE_MEM, 0);
-
-	if (!r)
-		return -ENODEV;
-
-	size = resource_size(r);
-
-	if (!request_mem_region(r->start, size, drv_data->adapter.name))
-		return -EBUSY;
-
-	drv_data->reg_base = ioremap(r->start, size);
-	drv_data->reg_base_p = r->start;
-	drv_data->reg_size = size;
-
-	return 0;
-}
-
-static void
-mv64xxx_i2c_unmap_regs(struct mv64xxx_i2c_data *drv_data)
-{
-	if (drv_data->reg_base) {
-		iounmap(drv_data->reg_base);
-		release_mem_region(drv_data->reg_base_p, drv_data->reg_size);
-	}
-
-	drv_data->reg_base = NULL;
-	drv_data->reg_base_p = 0;
-}
-
-static int __devinit
-mv64xxx_i2c_probe(struct platform_device *pd)
-{
-	struct mv64xxx_i2c_data		*drv_data;
-	struct mv64xxx_i2c_pdata	*pdata = pd->dev.platform_data;
-	int	rc;
-
-	if ((pd->id != 0) || !pdata)
-		return -ENODEV;
-
-	drv_data = kzalloc(sizeof(struct mv64xxx_i2c_data), GFP_KERNEL);
-	if (!drv_data)
-		return -ENOMEM;
-
-	if (mv64xxx_i2c_map_regs(pd, drv_data)) {
-		rc = -ENODEV;
-		goto exit_kfree;
-	}
-
-	strlcpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME " adapter",
-		sizeof(drv_data->adapter.name));
-
-	init_waitqueue_head(&drv_data->waitq);
-	spin_lock_init(&drv_data->lock);
-
-	drv_data->freq_m = pdata->freq_m;
-	drv_data->freq_n = pdata->freq_n;
-	drv_data->irq = platform_get_irq(pd, 0);
-	if (drv_data->irq < 0) {
-		rc = -ENXIO;
-		goto exit_unmap_regs;
-	}
-	drv_data->adapter.dev.parent = &pd->dev;
-	drv_data->adapter.algo = &mv64xxx_i2c_algo;
-	drv_data->adapter.owner = THIS_MODULE;
-	drv_data->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
-	drv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);
-	drv_data->adapter.nr = pd->id;
-	platform_set_drvdata(pd, drv_data);
-	i2c_set_adapdata(&drv_data->adapter, drv_data);
-
-	mv64xxx_i2c_hw_init(drv_data);
-
-	if (request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,
-			MV64XXX_I2C_CTLR_NAME, drv_data)) {
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx: Can't register intr handler irq: %d\n",
-			drv_data->irq);
-		rc = -EINVAL;
-		goto exit_unmap_regs;
-	} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {
-		dev_err(&drv_data->adapter.dev,
-			"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);
-		goto exit_free_irq;
-	}
-
-	return 0;
-
-	exit_free_irq:
-		free_irq(drv_data->irq, drv_data);
-	exit_unmap_regs:
-		mv64xxx_i2c_unmap_regs(drv_data);
-	exit_kfree:
-		kfree(drv_data);
-	return rc;
-}
-
-static int __devexit
-mv64xxx_i2c_remove(struct platform_device *dev)
-{
-	struct mv64xxx_i2c_data		*drv_data = platform_get_drvdata(dev);
-	int	rc;
-
-	rc = i2c_del_adapter(&drv_data->adapter);
-	free_irq(drv_data->irq, drv_data);
-	mv64xxx_i2c_unmap_regs(drv_data);
-	kfree(drv_data);
-
-	return rc;
-}
-
-static struct platform_driver mv64xxx_i2c_driver = {
-	.probe	= mv64xxx_i2c_probe,
-	.remove	= __devexit_p(mv64xxx_i2c_remove),
-	.driver	= {
-		.owner	= THIS_MODULE,
-		.name	= MV64XXX_I2C_CTLR_NAME,
-	},
-};
-
-module_platform_driver(mv64xxx_i2c_driver);
-
-MODULE_AUTHOR("Mark A. Greer <mgreer@mvista.com>");
-MODULE_DESCRIPTION("Marvell mv64xxx host bridge i2c ctlr driver");
-MODULE_LICENSE("GPL");
diff -urN flo-ElementalX-5.00/drivers/input/touchscreen/ektf3k.c flo-ElementalX-5.00-patched/drivers/input/touchscreen/ektf3k.c
--- flo-ElementalX-5.00/drivers/input/touchscreen/ektf3k.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/input/touchscreen/ektf3k.c	2016-06-01 15:49:14.000000000 +0000
@@ -1658,7 +1658,7 @@
               fbits = fbits >> 1;
               idx += 3;
 	    }
-
+	  input_mt_report_pointer_emulation(ts->input_dev, true);
           input_sync(idev);
 	} // checksum
 	else {
@@ -1718,6 +1718,7 @@
 			fbits = fbits >> 1;
 			idx += 3;
 		}
+		input_mt_report_pointer_emulation(ts->input_dev, true);
 		input_sync(idev);
 	} // checksum
 
@@ -2254,10 +2255,15 @@
 	ts->input_dev->name = "elan-touchscreen";  
 
 	//set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
 	ts->abs_x_max =  pdata->abs_x_max;
 	ts->abs_y_max = pdata->abs_y_max;
 	touch_debug(DEBUG_INFO, "[Elan] Max X=%d, Max Y=%d\n", ts->abs_x_max, ts->abs_y_max);
 
+	input_set_abs_params(ts->input_dev, ABS_X, pdata->abs_y_min, pdata->abs_y_max, 0, 0); // for 800 * 1280 
+	input_set_abs_params(ts->input_dev, ABS_Y, pdata->abs_x_min, pdata->abs_x_max, 0, 0); // for 800 * 1280 
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, MAX_FINGER_PRESSURE, 0, 0);
+
 	input_mt_init_slots(ts->input_dev, FINGER_NUM);
 	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, pdata->abs_y_min,  pdata->abs_y_max, 0, 0); // for 800 * 1280 
 	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, pdata->abs_x_min,  pdata->abs_x_max, 0, 0);// for 800 * 1280 

-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <media/saa7146_vv.h>
-#include <media/v4l2-chip-ident.h>
-#include <linux/module.h>
-
-static int max_memory = 32;
-
-module_param(max_memory, int, 0644);
-MODULE_PARM_DESC(max_memory, "maximum memory usage for capture buffers (default: 32Mb)");
-
-#define IS_CAPTURE_ACTIVE(fh) \
-	(((vv->video_status & STATUS_CAPTURE) != 0) && (vv->video_fh == fh))
-
-#define IS_OVERLAY_ACTIVE(fh) \
-	(((vv->video_status & STATUS_OVERLAY) != 0) && (vv->video_fh == fh))
-
-/* format descriptions for capture and preview */
-static struct saa7146_format formats[] = {
-	{
-		.name		= "RGB-8 (3-3-2)",
-		.pixelformat	= V4L2_PIX_FMT_RGB332,
-		.trans		= RGB08_COMPOSED,
-		.depth		= 8,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-16 (5/B-6/G-5/R)",
-		.pixelformat	= V4L2_PIX_FMT_RGB565,
-		.trans		= RGB16_COMPOSED,
-		.depth		= 16,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-24 (B-G-R)",
-		.pixelformat	= V4L2_PIX_FMT_BGR24,
-		.trans		= RGB24_COMPOSED,
-		.depth		= 24,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-32 (B-G-R)",
-		.pixelformat	= V4L2_PIX_FMT_BGR32,
-		.trans		= RGB32_COMPOSED,
-		.depth		= 32,
-		.flags		= 0,
-	}, {
-		.name		= "RGB-32 (R-G-B)",
-		.pixelformat	= V4L2_PIX_FMT_RGB32,
-		.trans		= RGB32_COMPOSED,
-		.depth		= 32,
-		.flags		= 0,
-		.swap		= 0x2,
-	}, {
-		.name		= "Greyscale-8",
-		.pixelformat	= V4L2_PIX_FMT_GREY,
-		.trans		= Y8,
-		.depth		= 8,
-		.flags		= 0,
-	}, {
-		.name		= "YUV 4:2:2 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YUV422P,
-		.trans		= YUV422_DECOMPOSED,
-		.depth		= 16,
-		.flags		= FORMAT_BYTE_SWAP|FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YVU 4:2:0 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YVU420,
-		.trans		= YUV420_DECOMPOSED,
-		.depth		= 12,
-		.flags		= FORMAT_BYTE_SWAP|FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YUV 4:2:0 planar (Y-Cb-Cr)",
-		.pixelformat	= V4L2_PIX_FMT_YUV420,
-		.trans		= YUV420_DECOMPOSED,
-		.depth		= 12,
-		.flags		= FORMAT_IS_PLANAR,
-	}, {
-		.name		= "YUV 4:2:2 (U-Y-V-Y)",
-		.pixelformat	= V4L2_PIX_FMT_UYVY,
-		.trans		= YUV422_COMPOSED,
-		.depth		= 16,
-		.flags		= 0,
-	}
-};
-
-/* unfortunately, the saa7146 contains a bug which prevents it from doing on-the-fly byte swaps.
-   due to this, it's impossible to provide additional *packed* formats, which are simply byte swapped
-   (like V4L2_PIX_FMT_YUYV) ... 8-( */
-
-static int NUM_FORMATS = sizeof(formats)/sizeof(struct saa7146_format);
-
-struct saa7146_format* saa7146_format_by_fourcc(struct saa7146_dev *dev, int fourcc)
-{
-	int i, j = NUM_FORMATS;
-
-	for (i = 0; i < j; i++) {
-		if (formats[i].pixelformat == fourcc) {
-			return formats+i;
-		}
-	}
-
-	DEB_D("unknown pixelformat:'%4.4s'\n", (char *)&fourcc);
-	return NULL;
-}
-
-static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f);
-
-int saa7146_start_preview(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct v4l2_format fmt;
-	int ret = 0, err = 0;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	/* check if we have overlay informations */
-	if( NULL == fh->ov.fh ) {
-		DEB_D("no overlay data available. try S_FMT first.\n");
-		return -EAGAIN;
-	}
-
-	/* check if streaming capture is running */
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_D("streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	/* check if overlay is running */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		if (vv->video_fh == fh) {
-			DEB_D("overlay is already active\n");
-			return 0;
-		}
-		DEB_D("overlay is already active in another open\n");
-		return -EBUSY;
-	}
-
-	if (0 == saa7146_res_get(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP)) {
-		DEB_D("cannot get necessary overlay resources\n");
-		return -EBUSY;
-	}
-
-	fmt.fmt.win = fh->ov.win;
-	err = vidioc_try_fmt_vid_overlay(NULL, fh, &fmt);
-	if (0 != err) {
-		saa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-		return -EBUSY;
-	}
-	fh->ov.win = fmt.fmt.win;
-	vv->ov_data = &fh->ov;
-
-	DEB_D("%dx%d+%d+%d %s field=%s\n",
-	      fh->ov.win.w.width, fh->ov.win.w.height,
-	      fh->ov.win.w.left, fh->ov.win.w.top,
-	      vv->ov_fmt->name, v4l2_field_names[fh->ov.win.field]);
-
-	if (0 != (ret = saa7146_enable_overlay(fh))) {
-		DEB_D("enabling overlay failed: %d\n", ret);
-		saa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-		return ret;
-	}
-
-	vv->video_status = STATUS_OVERLAY;
-	vv->video_fh = fh;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(saa7146_start_preview);
-
-int saa7146_stop_preview(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	/* check if streaming capture is running */
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_D("streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	/* check if overlay is running at all */
-	if ((vv->video_status & STATUS_OVERLAY) == 0) {
-		DEB_D("no active overlay\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_D("overlay is active, but in another open\n");
-		return -EBUSY;
-	}
-
-	vv->video_status = 0;
-	vv->video_fh = NULL;
-
-	saa7146_disable_overlay(fh);
-
-	saa7146_res_free(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(saa7146_stop_preview);
-
-/********************************************************************************/
-/* device controls */
-
-static struct v4l2_queryctrl controls[] = {
-	{
-		.id		= V4L2_CID_BRIGHTNESS,
-		.name		= "Brightness",
-		.minimum	= 0,
-		.maximum	= 255,
-		.step		= 1,
-		.default_value	= 128,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_CONTRAST,
-		.name		= "Contrast",
-		.minimum	= 0,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 64,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_SATURATION,
-		.name		= "Saturation",
-		.minimum	= 0,
-		.maximum	= 127,
-		.step		= 1,
-		.default_value	= 64,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.flags 		= V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_VFLIP,
-		.name		= "Vertical Flip",
-		.minimum	= 0,
-		.maximum	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	},{
-		.id		= V4L2_CID_HFLIP,
-		.name		= "Horizontal Flip",
-		.minimum	= 0,
-		.maximum	= 1,
-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
-	},
-};
-static int NUM_CONTROLS = sizeof(controls)/sizeof(struct v4l2_queryctrl);
-
-#define V4L2_CID_PRIVATE_LASTP1      (V4L2_CID_PRIVATE_BASE + 0)
-
-static struct v4l2_queryctrl* ctrl_by_id(int id)
-{
-	int i;
-
-	for (i = 0; i < NUM_CONTROLS; i++)
-		if (controls[i].id == id)
-			return controls+i;
-	return NULL;
-}
-
-/********************************************************************************/
-/* common pagetable functions */
-
-static int saa7146_pgtable_build(struct saa7146_dev *dev, struct saa7146_buf *buf)
-{
-	struct pci_dev *pci = dev->pci;
-	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);
-	struct scatterlist *list = dma->sglist;
-	int length = dma->sglen;
-	struct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);
-
-	DEB_EE("dev:%p, buf:%p, sg_len:%d\n", dev, buf, length);
-
-	if( 0 != IS_PLANAR(sfmt->trans)) {
-		struct saa7146_pgtable *pt1 = &buf->pt[0];
-		struct saa7146_pgtable *pt2 = &buf->pt[1];
-		struct saa7146_pgtable *pt3 = &buf->pt[2];
-		__le32  *ptr1, *ptr2, *ptr3;
-		__le32 fill;
-
-		int size = buf->fmt->width*buf->fmt->height;
-		int i,p,m1,m2,m3,o1,o2;
-
-		switch( sfmt->depth ) {
-			case 12: {
-				/* create some offsets inside the page table */
-				m1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;
-				m2 = ((size+(size/4)+PAGE_SIZE)/PAGE_SIZE)-1;
-				m3 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;
-				o1 = size%PAGE_SIZE;
-				o2 = (size+(size/4))%PAGE_SIZE;
-				DEB_CAP("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",
-					size, m1, m2, m3, o1, o2);
-				break;
-			}
-			case 16: {
-				/* create some offsets inside the page table */
-				m1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;
-				m2 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;
-				m3 = ((2*size+PAGE_SIZE)/PAGE_SIZE)-1;
-				o1 = size%PAGE_SIZE;
-				o2 = (size+(size/2))%PAGE_SIZE;
-				DEB_CAP("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",
-					size, m1, m2, m3, o1, o2);
-				break;
-			}
-			default: {
-				return -1;
-			}
-		}
-
-		ptr1 = pt1->cpu;
-		ptr2 = pt2->cpu;
-		ptr3 = pt3->cpu;
-
-		/* walk all pages, copy all page addresses to ptr1 */
-		for (i = 0; i < length; i++, list++) {
-			for (p = 0; p * 4096 < list->length; p++, ptr1++) {
-				*ptr1 = cpu_to_le32(sg_dma_address(list) - list->offset);
-			}
-		}
-/*
-		ptr1 = pt1->cpu;
-		for(j=0;j<40;j++) {
-			printk("ptr1 %d: 0x%08x\n",j,ptr1[j]);
-		}
-*/
-
-		/* if we have a user buffer, the first page may not be
-		   aligned to a page boundary. */
-		pt1->offset = dma->sglist->offset;
-		pt2->offset = pt1->offset+o1;
-		pt3->offset = pt1->offset+o2;
-
-		/* create video-dma2 page table */
-		ptr1 = pt1->cpu;
-		for(i = m1; i <= m2 ; i++, ptr2++) {
-			*ptr2 = ptr1[i];
-		}
-		fill = *(ptr2-1);
-		for(;i<1024;i++,ptr2++) {
-			*ptr2 = fill;
-		}
-		/* create video-dma3 page table */
-		ptr1 = pt1->cpu;
-		for(i = m2; i <= m3; i++,ptr3++) {
-			*ptr3 = ptr1[i];
-		}
-		fill = *(ptr3-1);
-		for(;i<1024;i++,ptr3++) {
-			*ptr3 = fill;
-		}
-		/* finally: finish up video-dma1 page table */
-		ptr1 = pt1->cpu+m1;
-		fill = pt1->cpu[m1];
-		for(i=m1;i<1024;i++,ptr1++) {
-			*ptr1 = fill;
-		}
-/*
-		ptr1 = pt1->cpu;
-		ptr2 = pt2->cpu;
-		ptr3 = pt3->cpu;
-		for(j=0;j<40;j++) {
-			printk("ptr1 %d: 0x%08x\n",j,ptr1[j]);
-		}
-		for(j=0;j<40;j++) {
-			printk("ptr2 %d: 0x%08x\n",j,ptr2[j]);
-		}
-		for(j=0;j<40;j++) {
-			printk("ptr3 %d: 0x%08x\n",j,ptr3[j]);
-		}
-*/
-	} else {
-		struct saa7146_pgtable *pt = &buf->pt[0];
-		return saa7146_pgtable_build_single(pci, pt, list, length);
-	}
-
-	return 0;
-}
-
-
-/********************************************************************************/
-/* file operations */
-
-static int video_begin(struct saa7146_fh *fh)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt = NULL;
-	unsigned int resource;
-	int ret = 0, err = 0;
-
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	if ((vv->video_status & STATUS_CAPTURE) != 0) {
-		if (vv->video_fh == fh) {
-			DEB_S("already capturing\n");
-			return 0;
-		}
-		DEB_S("already capturing in another open\n");
-		return -EBUSY;
-	}
-
-	if ((vv->video_status & STATUS_OVERLAY) != 0) {
-		DEB_S("warning: suspending overlay video for streaming capture\n");
-		vv->ov_suspend = vv->video_fh;
-		err = saa7146_stop_preview(vv->video_fh); /* side effect: video_status is now 0, video_fh is NULL */
-		if (0 != err) {
-			DEB_D("suspending video failed. aborting\n");
-			return err;
-		}
-	}
-
-	fmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	/* we need to have a valid format set here */
-	BUG_ON(NULL == fmt);
-
-	if (0 != (fmt->flags & FORMAT_IS_PLANAR)) {
-		resource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;
-	} else {
-		resource = RESOURCE_DMA1_HPS;
-	}
-
-	ret = saa7146_res_get(fh, resource);
-	if (0 == ret) {
-		DEB_S("cannot get capture resource %d\n", resource);
-		if (vv->ov_suspend != NULL) {
-			saa7146_start_preview(vv->ov_suspend);
-			vv->ov_suspend = NULL;
-		}
-		return -EBUSY;
-	}
-
-	/* clear out beginning of streaming bit (rps register 0)*/
-	saa7146_write(dev, MC2, MASK_27 );
-
-	/* enable rps0 irqs */
-	SAA7146_IER_ENABLE(dev, MASK_27);
-
-	vv->video_fh = fh;
-	vv->video_status = STATUS_CAPTURE;
-
-	return 0;
-}
-
-static int video_end(struct saa7146_fh *fh, struct file *file)
-{
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt = NULL;
-	unsigned long flags;
-	unsigned int resource;
-	u32 dmas = 0;
-	DEB_EE("dev:%p, fh:%p\n", dev, fh);
-
-	if ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {
-		DEB_S("not capturing\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_S("capturing, but in another open\n");
-		return -EBUSY;
-	}
-
-	fmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	/* we need to have a valid format set here */
-	BUG_ON(NULL == fmt);
-
-	if (0 != (fmt->flags & FORMAT_IS_PLANAR)) {
-		resource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;
-		dmas = MASK_22 | MASK_21 | MASK_20;
-	} else {
-		resource = RESOURCE_DMA1_HPS;
-		dmas = MASK_22;
-	}
-	spin_lock_irqsave(&dev->slock,flags);
-
-	/* disable rps0  */
-	saa7146_write(dev, MC1, MASK_28);
-
-	/* disable rps0 irqs */
-	SAA7146_IER_DISABLE(dev, MASK_27);
-
-	/* shut down all used video dma transfers */
-	saa7146_write(dev, MC1, dmas);
-
-	spin_unlock_irqrestore(&dev->slock, flags);
-
-	vv->video_fh = NULL;
-	vv->video_status = 0;
-
-	saa7146_res_free(fh, resource);
-
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	return 0;
-}
-
-static int vidioc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-
-	strcpy((char *)cap->driver, "saa7146 v4l2");
-	strlcpy((char *)cap->card, dev->ext->name, sizeof(cap->card));
-	sprintf((char *)cap->bus_info, "PCI:%s", pci_name(dev->pci));
-	cap->version = SAA7146_VERSION_CODE;
-	cap->capabilities =
-		V4L2_CAP_VIDEO_CAPTURE |
-		V4L2_CAP_VIDEO_OVERLAY |
-		V4L2_CAP_READWRITE |
-		V4L2_CAP_STREAMING;
-	cap->capabilities |= dev->ext_vv_data->capabilities;
-	return 0;
-}
-
-static int vidioc_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	*fb = vv->ov_fb;
-	fb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;
-	return 0;
-}
-
-static int vidioc_s_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt;
-
-	DEB_EE("VIDIOC_S_FBUF\n");
-
-	if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))
-		return -EPERM;
-
-	/* check args */
-	fmt = saa7146_format_by_fourcc(dev, fb->fmt.pixelformat);
-	if (NULL == fmt)
-		return -EINVAL;
-
-	/* planar formats are not allowed for overlay video, clipping and video dma would clash */
-	if (fmt->flags & FORMAT_IS_PLANAR)
-		DEB_S("planar pixelformat '%4.4s' not allowed for overlay\n",
-		      (char *)&fmt->pixelformat);
-
-	/* check if overlay is running */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		if (vv->video_fh != fh) {
-			DEB_D("refusing to change framebuffer informations while overlay is active in another open\n");
-			return -EBUSY;
-		}
-	}
-
-	/* ok, accept it */
-	vv->ov_fb = *fb;
-	vv->ov_fmt = fmt;
-
-	if (vv->ov_fb.fmt.bytesperline < vv->ov_fb.fmt.width) {
-		vv->ov_fb.fmt.bytesperline = vv->ov_fb.fmt.width * fmt->depth / 8;
-		DEB_D("setting bytesperline to %d\n", vv->ov_fb.fmt.bytesperline);
-	}
-	return 0;
-}
-
-static int vidioc_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)
-{
-	if (f->index >= NUM_FORMATS)
-		return -EINVAL;
-	strlcpy((char *)f->description, formats[f->index].name,
-			sizeof(f->description));
-	f->pixelformat = formats[f->index].pixelformat;
-	return 0;
-}
-
-static int vidioc_queryctrl(struct file *file, void *fh, struct v4l2_queryctrl *c)
-{
-	const struct v4l2_queryctrl *ctrl;
-
-	if ((c->id <  V4L2_CID_BASE ||
-	     c->id >= V4L2_CID_LASTP1) &&
-	    (c->id <  V4L2_CID_PRIVATE_BASE ||
-	     c->id >= V4L2_CID_PRIVATE_LASTP1))
-		return -EINVAL;
-
-	ctrl = ctrl_by_id(c->id);
-	if (ctrl == NULL)
-		return -EINVAL;
-
-	DEB_EE("VIDIOC_QUERYCTRL: id:%d\n", c->id);
-	*c = *ctrl;
-	return 0;
-}
-
-static int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	const struct v4l2_queryctrl *ctrl;
-	u32 value = 0;
-
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl)
-		return -EINVAL;
-	switch (c->id) {
-	case V4L2_CID_BRIGHTNESS:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0xff & (value >> 24);
-		DEB_D("V4L2_CID_BRIGHTNESS: %d\n", c->value);
-		break;
-	case V4L2_CID_CONTRAST:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0x7f & (value >> 16);
-		DEB_D("V4L2_CID_CONTRAST: %d\n", c->value);
-		break;
-	case V4L2_CID_SATURATION:
-		value = saa7146_read(dev, BCS_CTRL);
-		c->value = 0x7f & (value >> 0);
-		DEB_D("V4L2_CID_SATURATION: %d\n", c->value);
-		break;
-	case V4L2_CID_VFLIP:
-		c->value = vv->vflip;
-		DEB_D("V4L2_CID_VFLIP: %d\n", c->value);
-		break;
-	case V4L2_CID_HFLIP:
-		c->value = vv->hflip;
-		DEB_D("V4L2_CID_HFLIP: %d\n", c->value);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	const struct v4l2_queryctrl *ctrl;
-
-	ctrl = ctrl_by_id(c->id);
-	if (NULL == ctrl) {
-		DEB_D("unknown control %d\n", c->id);
-		return -EINVAL;
-	}
-
-	switch (ctrl->type) {
-	case V4L2_CTRL_TYPE_BOOLEAN:
-	case V4L2_CTRL_TYPE_MENU:
-	case V4L2_CTRL_TYPE_INTEGER:
-		if (c->value < ctrl->minimum)
-			c->value = ctrl->minimum;
-		if (c->value > ctrl->maximum)
-			c->value = ctrl->maximum;
-		break;
-	default:
-		/* nothing */;
-	}
-
-	switch (c->id) {
-	case V4L2_CID_BRIGHTNESS: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0x00ffffff;
-		value |= (c->value << 24);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_CONTRAST: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0xff00ffff;
-		value |= (c->value << 16);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_SATURATION: {
-		u32 value = saa7146_read(dev, BCS_CTRL);
-		value &= 0xffffff00;
-		value |= (c->value << 0);
-		saa7146_write(dev, BCS_CTRL, value);
-		saa7146_write(dev, MC2, MASK_22 | MASK_06);
-		break;
-	}
-	case V4L2_CID_HFLIP:
-		/* fixme: we can support changing VFLIP and HFLIP here... */
-		if (IS_CAPTURE_ACTIVE(fh) != 0) {
-			DEB_D("V4L2_CID_HFLIP while active capture\n");
-			return -EBUSY;
-		}
-		vv->hflip = c->value;
-		break;
-	case V4L2_CID_VFLIP:
-		if (IS_CAPTURE_ACTIVE(fh) != 0) {
-			DEB_D("V4L2_CID_VFLIP while active capture\n");
-			return -EBUSY;
-		}
-		vv->vflip = c->value;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		saa7146_stop_preview(fh);
-		saa7146_start_preview(fh);
-	}
-	return 0;
-}
-
-static int vidioc_g_parm(struct file *file, void *fh,
-		struct v4l2_streamparm *parm)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	parm->parm.capture.readbuffers = 1;
-	v4l2_video_std_frame_period(vv->standard->id,
-				    &parm->parm.capture.timeperframe);
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.pix = ((struct saa7146_fh *)fh)->video_fmt;
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.win = ((struct saa7146_fh *)fh)->ov.win;
-	return 0;
-}
-
-static int vidioc_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	f->fmt.vbi = ((struct saa7146_fh *)fh)->vbi_fmt;
-	return 0;
-}
-
-static int vidioc_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_format *fmt;
-	enum v4l2_field field;
-	int maxw, maxh;
-	int calc_bpl;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh);
-
-	fmt = saa7146_format_by_fourcc(dev, f->fmt.pix.pixelformat);
-	if (NULL == fmt)
-		return -EINVAL;
-
-	field = f->fmt.pix.field;
-	maxw  = vv->standard->h_max_out;
-	maxh  = vv->standard->v_max_out;
-
-	if (V4L2_FIELD_ANY == field) {
-		field = (f->fmt.pix.height > maxh / 2)
-			? V4L2_FIELD_INTERLACED
-			: V4L2_FIELD_BOTTOM;
-	}
-	switch (field) {
-	case V4L2_FIELD_ALTERNATE:
-		vv->last_field = V4L2_FIELD_TOP;
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_TOP:
-	case V4L2_FIELD_BOTTOM:
-		vv->last_field = V4L2_FIELD_INTERLACED;
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_INTERLACED:
-		vv->last_field = V4L2_FIELD_INTERLACED;
-		break;
-	default:
-		DEB_D("no known field mode '%d'\n", field);
-		return -EINVAL;
-	}
-
-	f->fmt.pix.field = field;
-	if (f->fmt.pix.width > maxw)
-		f->fmt.pix.width = maxw;
-	if (f->fmt.pix.height > maxh)
-		f->fmt.pix.height = maxh;
-
-	calc_bpl = (f->fmt.pix.width * fmt->depth) / 8;
-
-	if (f->fmt.pix.bytesperline < calc_bpl)
-		f->fmt.pix.bytesperline = calc_bpl;
-
-	if (f->fmt.pix.bytesperline > (2 * PAGE_SIZE * fmt->depth) / 8) /* arbitrary constraint */
-		f->fmt.pix.bytesperline = calc_bpl;
-
-	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;
-	DEB_D("w:%d, h:%d, bytesperline:%d, sizeimage:%d\n",
-	      f->fmt.pix.width, f->fmt.pix.height,
-	      f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);
-
-	return 0;
-}
-
-
-static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct v4l2_window *win = &f->fmt.win;
-	enum v4l2_field field;
-	int maxw, maxh;
-
-	DEB_EE("dev:%p\n", dev);
-
-	if (NULL == vv->ov_fb.base) {
-		DEB_D("no fb base set\n");
-		return -EINVAL;
-	}
-	if (NULL == vv->ov_fmt) {
-		DEB_D("no fb fmt set\n");
-		return -EINVAL;
-	}
-	if (win->w.width < 48 || win->w.height < 32) {
-		DEB_D("min width/height. (%d,%d)\n",
-		      win->w.width, win->w.height);
-		return -EINVAL;
-	}
-	if (win->clipcount > 16) {
-		DEB_D("clipcount too big\n");
-		return -EINVAL;
-	}
-
-	field = win->field;
-	maxw  = vv->standard->h_max_out;
-	maxh  = vv->standard->v_max_out;
-
-	if (V4L2_FIELD_ANY == field) {
-		field = (win->w.height > maxh / 2)
-			? V4L2_FIELD_INTERLACED
-			: V4L2_FIELD_TOP;
-		}
-	switch (field) {
-	case V4L2_FIELD_TOP:
-	case V4L2_FIELD_BOTTOM:
-	case V4L2_FIELD_ALTERNATE:
-		maxh = maxh / 2;
-		break;
-	case V4L2_FIELD_INTERLACED:
-		break;
-	default:
-		DEB_D("no known field mode '%d'\n", field);
-		return -EINVAL;
-	}
-
-	win->field = field;
-	if (win->w.width > maxw)
-		win->w.width = maxw;
-	if (win->w.height > maxh)
-		win->w.height = maxh;
-
-	return 0;
-}
-
-static int vidioc_s_fmt_vid_cap(struct file *file, void *__fh, struct v4l2_format *f)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh);
-	if (IS_CAPTURE_ACTIVE(fh) != 0) {
-		DEB_EE("streaming capture is active\n");
-		return -EBUSY;
-	}
-	err = vidioc_try_fmt_vid_cap(file, fh, f);
-	if (0 != err)
-		return err;
-	fh->video_fmt = f->fmt.pix;
-	DEB_EE("set to pixelformat '%4.4s'\n",
-	       (char *)&fh->video_fmt.pixelformat);
-	return 0;
-}
-
-static int vidioc_s_fmt_vid_overlay(struct file *file, void *__fh, struct v4l2_format *f)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_EE("V4L2_BUF_TYPE_VIDEO_OVERLAY: dev:%p, fh:%p\n", dev, fh);
-	err = vidioc_try_fmt_vid_overlay(file, fh, f);
-	if (0 != err)
-		return err;
-	fh->ov.win    = f->fmt.win;
-	fh->ov.nclips = f->fmt.win.clipcount;
-	if (fh->ov.nclips > 16)
-		fh->ov.nclips = 16;
-	if (copy_from_user(fh->ov.clips, f->fmt.win.clips,
-				sizeof(struct v4l2_clip) * fh->ov.nclips)) {
-		return -EFAULT;
-	}
-
-	/* fh->ov.fh is used to indicate that we have valid overlay informations, too */
-	fh->ov.fh = fh;
-
-	/* check if our current overlay is active */
-	if (IS_OVERLAY_ACTIVE(fh) != 0) {
-		saa7146_stop_preview(fh);
-		saa7146_start_preview(fh);
-	}
-	return 0;
-}
-
-static int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-
-	*norm = vv->standard->id;
-	return 0;
-}
-
-	/* the saa7146 supfhrts (used in conjunction with the saa7111a for example)
-	   PAL / NTSC / SECAM. if your hardware does not (or does more)
-	   -- override this function in your extension */
-/*
-	case VIDIOC_ENUMSTD:
-	{
-		struct v4l2_standard *e = arg;
-		if (e->index < 0 )
-			return -EINVAL;
-		if( e->index < dev->ext_vv_data->num_stds ) {
-			DEB_EE("VIDIOC_ENUMSTD: index:%d\n", e->index);
-			v4l2_video_std_construct(e, dev->ext_vv_data->stds[e->index].id, dev->ext_vv_data->stds[e->index].name);
-			return 0;
-		}
-		return -EINVAL;
-	}
-	*/
-
-static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *id)
-{
-	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int found = 0;
-	int err, i;
-
-	DEB_EE("VIDIOC_S_STD\n");
-
-	if ((vv->video_status & STATUS_CAPTURE) == STATUS_CAPTURE) {
-		DEB_D("cannot change video standard while streaming capture is active\n");
-		return -EBUSY;
-	}
-
-	if ((vv->video_status & STATUS_OVERLAY) != 0) {
-		vv->ov_suspend = vv->video_fh;
-		err = saa7146_stop_preview(vv->video_fh); /* side effect: video_status is now 0, video_fh is NULL */
-		if (0 != err) {
-			DEB_D("suspending video failed. aborting\n");
-			return err;
-		}
-	}
-
-	for (i = 0; i < dev->ext_vv_data->num_stds; i++)
-		if (*id & dev->ext_vv_data->stds[i].id)
-			break;
-	if (i != dev->ext_vv_data->num_stds) {
-		vv->standard = &dev->ext_vv_data->stds[i];
-		if (NULL != dev->ext_vv_data->std_callback)
-			dev->ext_vv_data->std_callback(dev, vv->standard);
-		found = 1;
-	}
-
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	if (!found) {
-		DEB_EE("VIDIOC_S_STD: standard not found\n");
-		return -EINVAL;
-	}
-
-	DEB_EE("VIDIOC_S_STD: set to standard to '%s'\n", vv->standard->name);
-	return 0;
-}
-
-static int vidioc_overlay(struct file *file, void *fh, unsigned int on)
-{
-	int err;
-
-	DEB_D("VIDIOC_OVERLAY on:%d\n", on);
-	if (on)
-		err = saa7146_start_preview(fh);
-	else
-		err = saa7146_stop_preview(fh);
-	return err;
-}
-
-static int vidioc_reqbufs(struct file *file, void *__fh, struct v4l2_requestbuffers *b)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_reqbufs(&fh->video_q, b);
-	if (b->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_reqbufs(&fh->vbi_q, b);
-	return -EINVAL;
-}
-
-static int vidioc_querybuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_querybuf(&fh->video_q, buf);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_querybuf(&fh->vbi_q, buf);
-	return -EINVAL;
-}
-
-static int vidioc_qbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_qbuf(&fh->video_q, buf);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_qbuf(&fh->vbi_q, buf);
-	return -EINVAL;
-}
-
-static int vidioc_dqbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)
-{
-	struct saa7146_fh *fh = __fh;
-
-	if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_dqbuf(&fh->video_q, buf, file->f_flags & O_NONBLOCK);
-	if (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_dqbuf(&fh->vbi_q, buf, file->f_flags & O_NONBLOCK);
-	return -EINVAL;
-}
-
-static int vidioc_streamon(struct file *file, void *__fh, enum v4l2_buf_type type)
-{
-	struct saa7146_fh *fh = __fh;
-	int err;
-
-	DEB_D("VIDIOC_STREAMON, type:%d\n", type);
-
-	err = video_begin(fh);
-	if (err)
-		return err;
-	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return videobuf_streamon(&fh->video_q);
-	if (type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		return videobuf_streamon(&fh->vbi_q);
-	return -EINVAL;
-}
-
-static int vidioc_streamoff(struct file *file, void *__fh, enum v4l2_buf_type type)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	int err;
-
-	DEB_D("VIDIOC_STREAMOFF, type:%d\n", type);
-
-	/* ugly: we need to copy some checks from video_end(),
-	   because videobuf_streamoff() relies on the capture running.
-	   check and fix this */
-	if ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {
-		DEB_S("not capturing\n");
-		return 0;
-	}
-
-	if (vv->video_fh != fh) {
-		DEB_S("capturing, but in another open\n");
-		return -EBUSY;
-	}
-
-	err = -EINVAL;
-	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		err = videobuf_streamoff(&fh->video_q);
-	else if (type == V4L2_BUF_TYPE_VBI_CAPTURE)
-		err = videobuf_streamoff(&fh->vbi_q);
-	if (0 != err) {
-		DEB_D("warning: videobuf_streamoff() failed\n");
-		video_end(fh, file);
-	} else {
-		err = video_end(fh, file);
-	}
-	return err;
-}
-
-static int vidioc_g_chip_ident(struct file *file, void *__fh,
-		struct v4l2_dbg_chip_ident *chip)
-{
-	struct saa7146_fh *fh = __fh;
-	struct saa7146_dev *dev = fh->dev;
-
-	chip->ident = V4L2_IDENT_NONE;
-	chip->revision = 0;
-	if (chip->match.type == V4L2_CHIP_MATCH_HOST && !chip->match.addr) {
-		chip->ident = V4L2_IDENT_SAA7146;
-		return 0;
-	}
-	return v4l2_device_call_until_err(&dev->v4l2_dev, 0,
-			core, g_chip_ident, chip);
-}
-
-const struct v4l2_ioctl_ops saa7146_video_ioctl_ops = {
-	.vidioc_querycap             = vidioc_querycap,
-	.vidioc_enum_fmt_vid_cap     = vidioc_enum_fmt_vid_cap,
-	.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_cap,
-	.vidioc_g_fmt_vid_cap        = vidioc_g_fmt_vid_cap,
-	.vidioc_try_fmt_vid_cap      = vidioc_try_fmt_vid_cap,
-	.vidioc_s_fmt_vid_cap        = vidioc_s_fmt_vid_cap,
-	.vidioc_g_fmt_vid_overlay    = vidioc_g_fmt_vid_overlay,
-	.vidioc_try_fmt_vid_overlay  = vidioc_try_fmt_vid_overlay,
-	.vidioc_s_fmt_vid_overlay    = vidioc_s_fmt_vid_overlay,
-	.vidioc_g_fmt_vbi_cap        = vidioc_g_fmt_vbi_cap,
-	.vidioc_g_chip_ident         = vidioc_g_chip_ident,
-
-	.vidioc_overlay 	     = vidioc_overlay,
-	.vidioc_g_fbuf  	     = vidioc_g_fbuf,
-	.vidioc_s_fbuf  	     = vidioc_s_fbuf,
-	.vidioc_reqbufs              = vidioc_reqbufs,
-	.vidioc_querybuf             = vidioc_querybuf,
-	.vidioc_qbuf                 = vidioc_qbuf,
-	.vidioc_dqbuf                = vidioc_dqbuf,
-	.vidioc_g_std                = vidioc_g_std,
-	.vidioc_s_std                = vidioc_s_std,
-	.vidioc_queryctrl            = vidioc_queryctrl,
-	.vidioc_g_ctrl               = vidioc_g_ctrl,
-	.vidioc_s_ctrl               = vidioc_s_ctrl,
-	.vidioc_streamon             = vidioc_streamon,
-	.vidioc_streamoff            = vidioc_streamoff,
-	.vidioc_g_parm 		     = vidioc_g_parm,
-};
-
-/*********************************************************************************/
-/* buffer handling functions                                                  */
-
-static int buffer_activate (struct saa7146_dev *dev,
-		     struct saa7146_buf *buf,
-		     struct saa7146_buf *next)
-{
-	struct saa7146_vv *vv = dev->vv_data;
-
-	buf->vb.state = VIDEOBUF_ACTIVE;
-	saa7146_set_capture(dev,buf,next);
-
-	mod_timer(&vv->video_q.timeout, jiffies+BUFFER_TIMEOUT);
-	return 0;
-}
-
-static void release_all_pagetables(struct saa7146_dev *dev, struct saa7146_buf *buf)
-{
-	saa7146_pgtable_free(dev->pci, &buf->pt[0]);
-	saa7146_pgtable_free(dev->pci, &buf->pt[1]);
-	saa7146_pgtable_free(dev->pci, &buf->pt[2]);
-}
-
-static int buffer_prepare(struct videobuf_queue *q,
-			  struct videobuf_buffer *vb, enum v4l2_field field)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-	int size,err = 0;
-
-	DEB_CAP("vbuf:%p\n", vb);
-
-	/* sanity checks */
-	if (fh->video_fmt.width  < 48 ||
-	    fh->video_fmt.height < 32 ||
-	    fh->video_fmt.width  > vv->standard->h_max_out ||
-	    fh->video_fmt.height > vv->standard->v_max_out) {
-		DEB_D("w (%d) / h (%d) out of bounds\n",
-		      fh->video_fmt.width, fh->video_fmt.height);
-		return -EINVAL;
-	}
-
-	size = fh->video_fmt.sizeimage;
-	if (0 != buf->vb.baddr && buf->vb.bsize < size) {
-		DEB_D("size mismatch\n");
-		return -EINVAL;
-	}
-
-	DEB_CAP("buffer_prepare [size=%dx%d,bytes=%d,fields=%s]\n",
-		fh->video_fmt.width, fh->video_fmt.height,
-		size, v4l2_field_names[fh->video_fmt.field]);
-	if (buf->vb.width  != fh->video_fmt.width  ||
-	    buf->vb.bytesperline != fh->video_fmt.bytesperline ||
-	    buf->vb.height != fh->video_fmt.height ||
-	    buf->vb.size   != size ||
-	    buf->vb.field  != field      ||
-	    buf->vb.field  != fh->video_fmt.field  ||
-	    buf->fmt       != &fh->video_fmt) {
-		saa7146_dma_free(dev,q,buf);
-	}
-
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		struct saa7146_format *sfmt;
-
-		buf->vb.bytesperline  = fh->video_fmt.bytesperline;
-		buf->vb.width  = fh->video_fmt.width;
-		buf->vb.height = fh->video_fmt.height;
-		buf->vb.size   = size;
-		buf->vb.field  = field;
-		buf->fmt       = &fh->video_fmt;
-		buf->vb.field  = fh->video_fmt.field;
-
-		sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);
-
-		release_all_pagetables(dev, buf);
-		if( 0 != IS_PLANAR(sfmt->trans)) {
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[0]);
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[1]);
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[2]);
-		} else {
-			saa7146_pgtable_alloc(dev->pci, &buf->pt[0]);
-		}
-
-		err = videobuf_iolock(q,&buf->vb, &vv->ov_fb);
-		if (err)
-			goto oops;
-		err = saa7146_pgtable_build(dev,buf);
-		if (err)
-			goto oops;
-	}
-	buf->vb.state = VIDEOBUF_PREPARED;
-	buf->activate = buffer_activate;
-
-	return 0;
-
- oops:
-	DEB_D("error out\n");
-	saa7146_dma_free(dev,q,buf);
-
-	return err;
-}
-
-static int buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-
-	if (0 == *count || *count > MAX_SAA7146_CAPTURE_BUFFERS)
-		*count = MAX_SAA7146_CAPTURE_BUFFERS;
-
-	*size = fh->video_fmt.sizeimage;
-
-	/* check if we exceed the "max_memory" parameter */
-	if( (*count * *size) > (max_memory*1048576) ) {
-		*count = (max_memory*1048576) / *size;
-	}
-
-	DEB_CAP("%d buffers, %d bytes each\n", *count, *size);
-
-	return 0;
-}
-
-static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-
-	DEB_CAP("vbuf:%p\n", vb);
-	saa7146_buffer_queue(fh->dev,&vv->video_q,buf);
-}
-
-static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	struct file *file = q->priv_data;
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_buf *buf = (struct saa7146_buf *)vb;
-
-	DEB_CAP("vbuf:%p\n", vb);
-
-	saa7146_dma_free(dev,q,buf);
-
-	release_all_pagetables(dev, buf);
-}
-
-static struct videobuf_queue_ops video_qops = {
-	.buf_setup    = buffer_setup,
-	.buf_prepare  = buffer_prepare,
-	.buf_queue    = buffer_queue,
-	.buf_release  = buffer_release,
-};
-
-/********************************************************************************/
-/* file operations */
-
-static void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)
-{
-	INIT_LIST_HEAD(&vv->video_q.queue);
-
-	init_timer(&vv->video_q.timeout);
-	vv->video_q.timeout.function = saa7146_buffer_timeout;
-	vv->video_q.timeout.data     = (unsigned long)(&vv->video_q);
-	vv->video_q.dev              = dev;
-
-	/* set some default values */
-	vv->standard = &dev->ext_vv_data->stds[0];
-
-	/* FIXME: what's this? */
-	vv->current_hps_source = SAA7146_HPS_SOURCE_PORT_A;
-	vv->current_hps_sync = SAA7146_HPS_SYNC_PORT_A;
-}
-
-
-static int video_open(struct saa7146_dev *dev, struct file *file)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_format *sfmt;
-
-	fh->video_fmt.width = 384;
-	fh->video_fmt.height = 288;
-	fh->video_fmt.pixelformat = V4L2_PIX_FMT_BGR24;
-	fh->video_fmt.bytesperline = 0;
-	fh->video_fmt.field = V4L2_FIELD_ANY;
-	sfmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);
-	fh->video_fmt.sizeimage = (fh->video_fmt.width * fh->video_fmt.height * sfmt->depth)/8;
-
-	videobuf_queue_sg_init(&fh->video_q, &video_qops,
-			    &dev->pci->dev, &dev->slock,
-			    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-			    V4L2_FIELD_INTERLACED,
-			    sizeof(struct saa7146_buf),
-			    file, &dev->v4l2_lock);
-
-	return 0;
-}
-
-
-static void video_close(struct saa7146_dev *dev, struct file *file)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_vv *vv = dev->vv_data;
-	struct videobuf_queue *q = &fh->video_q;
-
-	if (IS_CAPTURE_ACTIVE(fh) != 0)
-		video_end(fh, file);
-	else if (IS_OVERLAY_ACTIVE(fh) != 0)
-		saa7146_stop_preview(fh);
-
-	videobuf_stop(q);
-	/* hmm, why is this function declared void? */
-}
-
-
-static void video_irq_done(struct saa7146_dev *dev, unsigned long st)
-{
-	struct saa7146_vv *vv = dev->vv_data;
-	struct saa7146_dmaqueue *q = &vv->video_q;
-
-	spin_lock(&dev->slock);
-	DEB_CAP("called\n");
-
-	/* only finish the buffer if we have one... */
-	if( NULL != q->curr ) {
-		saa7146_buffer_finish(dev,q,VIDEOBUF_DONE);
-	}
-	saa7146_buffer_next(dev,q,0);
-
-	spin_unlock(&dev->slock);
-}
-
-static ssize_t video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
-{
-	struct saa7146_fh *fh = file->private_data;
-	struct saa7146_dev *dev = fh->dev;
-	struct saa7146_vv *vv = dev->vv_data;
-	ssize_t ret = 0;
-
-	DEB_EE("called\n");
-
-	if ((vv->video_status & STATUS_CAPTURE) != 0) {
-		/* fixme: should we allow read() captures while streaming capture? */
-		if (vv->video_fh == fh) {
-			DEB_S("already capturing\n");
-			return -EBUSY;
-		}
-		DEB_S("already capturing in another open\n");
-		return -EBUSY;
-	}
-
-	ret = video_begin(fh);
-	if( 0 != ret) {
-		goto out;
-	}
-
-	ret = videobuf_read_one(&fh->video_q , data, count, ppos,
-				file->f_flags & O_NONBLOCK);
-	if (ret != 0) {
-		video_end(fh, file);
-	} else {
-		ret = video_end(fh, file);
-	}
-out:
-	/* restart overlay if it was active before */
-	if (vv->ov_suspend != NULL) {
-		saa7146_start_preview(vv->ov_suspend);
-		vv->ov_suspend = NULL;
-	}
-
-	return ret;
-}
-
-struct saa7146_use_ops saa7146_video_uops = {
-	.init = video_init,
-	.open = video_open,
-	.release = video_close,
-	.irq_done = video_irq_done,
-	.read = video_read,
-};

-/* DVB USB framework compliant Linux driver for the HanfTek UMT-010 USB2.0
- * DVB-T receiver.
- *
- * Copyright (C) 2004-5 Patrick Boettcher (patrick.boettcher@desy.de)
- *
- *	This program is free software; you can redistribute it and/or modify it
- *	under the terms of the GNU General Public License as published by the Free
- *	Software Foundation, version 2.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#include "dibusb.h"
-
-#include "mt352.h"
-
-DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
-
-static int umt_mt352_demod_init(struct dvb_frontend *fe)
-{
-	static u8 mt352_clock_config[] = { 0x89, 0xb8, 0x2d };
-	static u8 mt352_reset[] = { 0x50, 0x80 };
-	static u8 mt352_mclk_ratio[] = { 0x8b, 0x00 };
-	static u8 mt352_adc_ctl_1_cfg[] = { 0x8E, 0x40 };
-	static u8 mt352_agc_cfg[] = { 0x67, 0x10, 0xa0 };
-
-	static u8 mt352_sec_agc_cfg1[] = { 0x6a, 0xff };
-	static u8 mt352_sec_agc_cfg2[] = { 0x6d, 0xff };
-	static u8 mt352_sec_agc_cfg3[] = { 0x70, 0x40 };
-	static u8 mt352_sec_agc_cfg4[] = { 0x7b, 0x03 };
-	static u8 mt352_sec_agc_cfg5[] = { 0x7d, 0x0f };
-
-	static u8 mt352_acq_ctl[] = { 0x53, 0x50 };
-	static u8 mt352_input_freq_1[] = { 0x56, 0x31, 0x06 };
-
-	mt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));
-	udelay(2000);
-	mt352_write(fe, mt352_reset, sizeof(mt352_reset));
-	mt352_write(fe, mt352_mclk_ratio, sizeof(mt352_mclk_ratio));
-
-	mt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));
-	mt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));
-
-	mt352_write(fe, mt352_sec_agc_cfg1, sizeof(mt352_sec_agc_cfg1));
-	mt352_write(fe, mt352_sec_agc_cfg2, sizeof(mt352_sec_agc_cfg2));
-	mt352_write(fe, mt352_sec_agc_cfg3, sizeof(mt352_sec_agc_cfg3));
-	mt352_write(fe, mt352_sec_agc_cfg4, sizeof(mt352_sec_agc_cfg4));
-	mt352_write(fe, mt352_sec_agc_cfg5, sizeof(mt352_sec_agc_cfg5));
-
-	mt352_write(fe, mt352_acq_ctl, sizeof(mt352_acq_ctl));
-	mt352_write(fe, mt352_input_freq_1, sizeof(mt352_input_freq_1));
-
-	return 0;
-}
-
-static int umt_mt352_frontend_attach(struct dvb_usb_adapter *adap)
-{
-	struct mt352_config umt_config;
-
-	memset(&umt_config,0,sizeof(struct mt352_config));
-	umt_config.demod_init = umt_mt352_demod_init;
-	umt_config.demod_address = 0xf;
-
-	adap->fe_adap[0].fe = dvb_attach(mt352_attach, &umt_config, &adap->dev->i2c_adap);
-
-	return 0;
-}
-
-static int umt_tuner_attach (struct dvb_usb_adapter *adap)
-{
-	dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x61, NULL, DVB_PLL_TUA6034);
-	return 0;
-}
-
-/* USB Driver stuff */
-static struct dvb_usb_device_properties umt_properties;
-
-static int umt_probe(struct usb_interface *intf,
-		const struct usb_device_id *id)
-{
-	if (0 == dvb_usb_device_init(intf, &umt_properties,
-				     THIS_MODULE, NULL, adapter_nr))
-		return 0;
-	return -EINVAL;
-}
-
-/* do not change the order of the ID table */
-static struct usb_device_id umt_table [] = {
-/* 00 */	{ USB_DEVICE(USB_VID_HANFTEK, USB_PID_HANFTEK_UMT_010_COLD) },
-/* 01 */	{ USB_DEVICE(USB_VID_HANFTEK, USB_PID_HANFTEK_UMT_010_WARM) },
-			{ }		/* Terminating entry */
-};
-MODULE_DEVICE_TABLE (usb, umt_table);
-
-static struct dvb_usb_device_properties umt_properties = {
-	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
-
-	.usb_ctrl = CYPRESS_FX2,
-	.firmware = "dvb-usb-umt-010-02.fw",
-
-	.num_adapters = 1,
-	.adapter = {
-		{
-		.num_frontends = 1,
-		.fe = {{
-			.streaming_ctrl   = dibusb2_0_streaming_ctrl,
-			.frontend_attach  = umt_mt352_frontend_attach,
-			.tuner_attach     = umt_tuner_attach,
-
-			/* parameter for the MPEG2-data transfer */
-			.stream = {
-				.type = USB_BULK,
-				.count = MAX_NO_URBS_FOR_DATA_STREAM,
-				.endpoint = 0x06,
-				.u = {
-					.bulk = {
-						.buffersize = 512,
-					}
-				}
-			},
-		}},
-			.size_of_priv     = sizeof(struct dibusb_state),
-		}
-	},
-	.power_ctrl       = dibusb_power_ctrl,
-
-	.i2c_algo         = &dibusb_i2c_algo,
-
-	.generic_bulk_ctrl_endpoint = 0x01,
-
-	.num_device_descs = 1,
-	.devices = {
-		{	"Hanftek UMT-010 DVB-T USB2.0",
-			{ &umt_table[0], NULL },
-			{ &umt_table[1], NULL },
-		},
-	}
-};
-
-static struct usb_driver umt_driver = {
-	.name		= "dvb_usb_umt_010",
-	.probe		= umt_probe,
-	.disconnect = dvb_usb_device_exit,
-	.id_table	= umt_table,
-};
-
-module_usb_driver(umt_driver);
-
-MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
-MODULE_DESCRIPTION("Driver for HanfTek UMT 010 USB2.0 DVB-T device");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL");
-/* -----------------------------------------------------------------------------
- * Copyright (c) 2011 Ozmo Inc
- * Released under the GNU General Public License Version 2 (GPLv2).
- *
- * This file implements the protocol specific parts of the USB service for a PD.
- * -----------------------------------------------------------------------------
- */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/sched.h>
-#include <linux/netdevice.h>
-#include <linux/errno.h>
-#include <linux/input.h>
-#include <asm/unaligned.h>
-#include "ozconfig.h"
-#include "ozprotocol.h"
-#include "ozeltbuf.h"
-#include "ozpd.h"
-#include "ozproto.h"
-#include "ozusbif.h"
-#include "ozhcd.h"
-#include "oztrace.h"
-#include "ozusbsvc.h"
-#include "ozevent.h"
-/*------------------------------------------------------------------------------
- */
-#define MAX_ISOC_FIXED_DATA	(253-sizeof(struct oz_isoc_fixed))
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-static int oz_usb_submit_elt(struct oz_elt_buf *eb, struct oz_elt_info *ei,
-	struct oz_usb_ctx *usb_ctx, u8 strid, u8 isoc)
-{
-	int ret;
-	struct oz_elt *elt = (struct oz_elt *)ei->data;
-	struct oz_app_hdr *app_hdr = (struct oz_app_hdr *)(elt+1);
-	elt->type = OZ_ELT_APP_DATA;
-	ei->app_id = OZ_APPID_USB;
-	ei->length = elt->length + sizeof(struct oz_elt);
-	app_hdr->app_id = OZ_APPID_USB;
-	spin_lock_bh(&eb->lock);
-	if (isoc == 0) {
-		app_hdr->elt_seq_num = usb_ctx->tx_seq_num++;
-		if (usb_ctx->tx_seq_num == 0)
-			usb_ctx->tx_seq_num = 1;
-	}
-	ret = oz_queue_elt_info(eb, isoc, strid, ei);
-	if (ret)
-		oz_elt_info_free(eb, ei);
-	spin_unlock_bh(&eb->lock);
-	return ret;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-int oz_usb_get_desc_req(void *hpd, u8 req_id, u8 req_type, u8 desc_type,
-	u8 index, u16 windex, int offset, int len)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_get_desc_req *body;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	oz_trace("    req_type = 0x%x\n", req_type);
-	oz_trace("    desc_type = 0x%x\n", desc_type);
-	oz_trace("    index = 0x%x\n", index);
-	oz_trace("    windex = 0x%x\n", windex);
-	oz_trace("    offset = 0x%x\n", offset);
-	oz_trace("    len = 0x%x\n", len);
-	if (len > 200)
-		len = 200;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_get_desc_req);
-	body = (struct oz_get_desc_req *)(elt+1);
-	body->type = OZ_GET_DESC_REQ;
-	body->req_id = req_id;
-	put_unaligned(cpu_to_le16(offset), &body->offset);
-	put_unaligned(cpu_to_le16(len), &body->size);
-	body->req_type = req_type;
-	body->desc_type = desc_type;
-	body->w_index = windex;
-	body->index = index;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_config_req(void *hpd, u8 req_id, u8 index)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_set_config_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_set_config_req);
-	body = (struct oz_set_config_req *)(elt+1);
-	body->type = OZ_SET_CONFIG_REQ;
-	body->req_id = req_id;
-	body->index = index;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_interface_req(void *hpd, u8 req_id, u8 index, u8 alt)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_set_interface_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_set_interface_req);
-	body = (struct oz_set_interface_req *)(elt+1);
-	body->type = OZ_SET_INTERFACE_REQ;
-	body->req_id = req_id;
-	body->index = index;
-	body->alternative = alt;
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_set_clear_feature_req(void *hpd, u8 req_id, u8 type,
-			u8 recipient, u8 index, __le16 feature)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_feature_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_feature_req);
-	body = (struct oz_feature_req *)(elt+1);
-	body->type = type;
-	body->req_id = req_id;
-	body->recipient = recipient;
-	body->index = index;
-	put_unaligned(feature, &body->feature);
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-static int oz_usb_vendor_class_req(void *hpd, u8 req_id, u8 req_type,
-	u8 request, __le16 value, __le16 index, u8 *data, int data_len)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt *elt;
-	struct oz_elt_buf *eb = &pd->elt_buff;
-	struct oz_elt_info *ei = oz_elt_info_alloc(&pd->elt_buff);
-	struct oz_vendor_class_req *body;
-	if (ei == 0)
-		return -1;
-	elt = (struct oz_elt *)ei->data;
-	elt->length = sizeof(struct oz_vendor_class_req) - 1 + data_len;
-	body = (struct oz_vendor_class_req *)(elt+1);
-	body->type = OZ_VENDOR_CLASS_REQ;
-	body->req_id = req_id;
-	body->req_type = req_type;
-	body->request = request;
-	put_unaligned(value, &body->value);
-	put_unaligned(index, &body->index);
-	if (data_len)
-		memcpy(body->data, data, data_len);
-	return oz_usb_submit_elt(eb, ei, usb_ctx, 0, 0);
-}
-/*------------------------------------------------------------------------------
- * Context: tasklet
- */
-int oz_usb_control_req(void *hpd, u8 req_id, struct usb_ctrlrequest *setup,
-			u8 *data, int data_len)
-{
-	unsigned wvalue = le16_to_cpu(setup->wValue);
-	unsigned windex = le16_to_cpu(setup->wIndex);
-	unsigned wlength = le16_to_cpu(setup->wLength);
-	int rc = 0;
-	oz_event_log(OZ_EVT_CTRL_REQ, setup->bRequest, req_id,
-		(void *)(((unsigned long)(setup->wValue))<<16 |
-			((unsigned long)setup->wIndex)),
-		setup->bRequestType);
-	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		switch (setup->bRequest) {
-		case USB_REQ_GET_DESCRIPTOR:
-			rc = oz_usb_get_desc_req(hpd, req_id,
-				setup->bRequestType, (u8)(wvalue>>8),
-				(u8)wvalue, setup->wIndex, 0, wlength);
-			break;
-		case USB_REQ_SET_CONFIGURATION:
-			rc = oz_usb_set_config_req(hpd, req_id, (u8)wvalue);
-			break;
-		case USB_REQ_SET_INTERFACE: {
-				u8 if_num = (u8)windex;
-				u8 alt = (u8)wvalue;
-				rc = oz_usb_set_interface_req(hpd, req_id,
-					if_num, alt);
-			}
-			break;
-		case USB_REQ_SET_FEATURE:
-			rc = oz_usb_set_clear_feature_req(hpd, req_id,
-				OZ_SET_FEATURE_REQ,
-				setup->bRequestType & 0xf, (u8)windex,
-				setup->wValue);
-			break;
-		case USB_REQ_CLEAR_FEATURE:
-			rc = oz_usb_set_clear_feature_req(hpd, req_id,
-				OZ_CLEAR_FEATURE_REQ,
-				setup->bRequestType & 0xf,
-				(u8)windex, setup->wValue);
-			break;
-		}
-	} else {
-		rc = oz_usb_vendor_class_req(hpd, req_id, setup->bRequestType,
-			setup->bRequest, setup->wValue, setup->wIndex,
-			data, data_len);
-	}
-	return rc;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq
- */
-int oz_usb_send_isoc(void *hpd, u8 ep_num, struct urb *urb)
-{
-	struct oz_usb_ctx *usb_ctx = (struct oz_usb_ctx *)hpd;
-	struct oz_pd *pd = usb_ctx->pd;
-	struct oz_elt_buf *eb;
-	int i;
-	int hdr_size;
-	u8 *data;
-	struct usb_iso_packet_descriptor *desc;
-
-	if (pd->mode & OZ_F_ISOC_NO_ELTS) {
-		for (i = 0; i < urb->number_of_packets; i++) {
-			u8 *data;
-			desc = &urb->iso_frame_desc[i];
-			data = ((u8 *)urb->transfer_buffer)+desc->offset;
-			oz_send_isoc_unit(pd, ep_num, data, desc->length);
-		}
-		return 0;
-	}
-
-	hdr_size = sizeof(struct oz_isoc_fixed) - 1;
-	eb = &pd->elt_buff;
-	i = 0;
-	while (i < urb->number_of_packets) {
-		struct oz_elt_info *ei = oz_elt_info_alloc(eb);
-		struct oz_elt *elt;
-		struct oz_isoc_fixed *body;
-		int unit_count;
-		int unit_size;
-		int rem;
-		if (ei == 0)
-			return -1;
-		rem = MAX_ISOC_FIXED_DATA;
-		elt = (struct oz_elt *)ei->data;
-		body = (struct oz_isoc_fixed *)(elt + 1);
-		body->type = OZ_USB_ENDPOINT_DATA;
-		body->endpoint = ep_num;
-		body->format = OZ_DATA_F_ISOC_FIXED;
-		unit_size = urb->iso_frame_desc[i].length;
-		body->unit_size = (u8)unit_size;
-		data = ((u8 *)(elt+1)) + hdr_size;
-		unit_count = 0;
-		while (i < urb->number_of_packets) {
-			desc = &urb->iso_frame_desc[i];
-			if ((unit_size == desc->length) &&
-				(desc->length <= rem)) {
-				memcpy(data, ((u8 *)urb->transfer_buffer) +
-					desc->offset, unit_size);
-				data += unit_size;
-				rem -= unit_size;
-				unit_count++;
-				desc->status = 0;
-				desc->actual_length = desc->length;
-				i++;
-			} else {
-				break;
-			}
-		}
-		elt->length = hdr_size + MAX_ISOC_FIXED_DATA - rem;
-		/* Store the number of units in body->frame_number for the
-		 * moment. This field will be correctly determined before
-		 * the element is sent. */
-		body->frame_number = (u8)unit_count;
-		oz_usb_submit_elt(eb, ei, usb_ctx, ep_num,
-			pd->mode & OZ_F_ISOC_ANYTIME);
-	}
-	return 0;
-}
-/*------------------------------------------------------------------------------
- * Context: softirq-serialized
- */
-void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
-	struct oz_usb_hdr *usb_hdr, int len)
-{
-	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;
-	switch (data_hdr->format) {
-	case OZ_DATA_F_MULTIPLE_FIXED: {
-			struct oz_multiple_fixed *body =
-				(struct oz_multiple_fixed *)data_hdr;
-			u8 *data = body->data;
-			int n = (len - sizeof(struct oz_multiple_fixed)+1)
-				/ body->unit_size;
-			while (n--) {
-				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
-					data, body->unit_size);
-				data += body->unit_size;
-			}
-		}
-		break;
-	case OZ_DATA_F_ISOC_FIXED: {
-			struct oz_isoc_fixed *body =
-				(struct oz_isoc_fixed *)data_hdr;
-			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
-			int unit_size = body->unit_size;
-			u8 *data = body->data;
-			int count;
-			int i;
-			if (!unit_size)
-				break;
-			count = data_len/unit_size;
-			for (i = 0; i < count; i++) {
-				oz_hcd_data_ind(usb_ctx->hport,
-					body->endpoint, data, unit_size);
-				data += unit_size;
-			}
-		}
-		break;
-	}
-
-}
-/*------------------------------------------------------------------------------
- * This is called when the PD has received a USB element. The type of element
- * is determined and is then passed to an appropriate handler function.
- * Context: softirq-serialized
- */
-void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)
-{
-	struct oz_usb_hdr *usb_hdr = (struct oz_usb_hdr *)(elt + 1);
-	struct oz_usb_ctx *usb_ctx;
-
-	spin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	usb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB-1];
-	if (usb_ctx)
-		oz_usb_get(usb_ctx);
-	spin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	if (usb_ctx == 0)
-		return; /* Context has gone so nothing to do. */
-	if (usb_ctx->stopped)
-		goto done;
-	/* If sequence number is non-zero then check it is not a duplicate.
-	 * Zero sequence numbers are always accepted.
-	 */
-	if (usb_hdr->elt_seq_num != 0) {
-		if (((usb_ctx->rx_seq_num - usb_hdr->elt_seq_num) & 0x80) == 0)
-			/* Reject duplicate element. */
-			goto done;
-	}
-	usb_ctx->rx_seq_num = usb_hdr->elt_seq_num;
-	switch (usb_hdr->type) {
-	case OZ_GET_DESC_RSP: {
-			struct oz_get_desc_rsp *body =
-				(struct oz_get_desc_rsp *)usb_hdr;
-			int data_len = elt->length -
-					sizeof(struct oz_get_desc_rsp) + 1;
-			u16 offs = le16_to_cpu(get_unaligned(&body->offset));
-			u16 total_size =
-				le16_to_cpu(get_unaligned(&body->total_size));
-			oz_trace("USB_REQ_GET_DESCRIPTOR - cnf\n");
-			oz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,
-					body->rcode, body->data,
-					data_len, offs, total_size);
-		}
-		break;
-	case OZ_SET_CONFIG_RSP: {
-			struct oz_set_config_rsp *body =
-				(struct oz_set_config_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport, body->req_id,
-				body->rcode, 0, 0);
-		}
-		break;
-	case OZ_SET_INTERFACE_RSP: {
-			struct oz_set_interface_rsp *body =
-				(struct oz_set_interface_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport,
-				body->req_id, body->rcode, 0, 0);
-		}
-		break;
-	case OZ_VENDOR_CLASS_RSP: {
-			struct oz_vendor_class_rsp *body =
-				(struct oz_vendor_class_rsp *)usb_hdr;
-			oz_hcd_control_cnf(usb_ctx->hport, body->req_id,
-				body->rcode, body->data, elt->length-
-				sizeof(struct oz_vendor_class_rsp)+1);
-		}
-		break;
-	case OZ_USB_ENDPOINT_DATA:
-		oz_usb_handle_ep_data(usb_ctx, usb_hdr, elt->length);
-		break;
-	}
-done:
-	oz_usb_put(usb_ctx);
-}
-/*------------------------------------------------------------------------------
- * Context: softirq, process
- */
-void oz_usb_farewell(struct oz_pd *pd, u8 ep_num, u8 *data, u8 len)
-{
-	struct oz_usb_ctx *usb_ctx;
-	spin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	usb_ctx = (struct oz_usb_ctx *)pd->app_ctx[OZ_APPID_USB-1];
-	if (usb_ctx)
-		oz_usb_get(usb_ctx);
-	spin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);
-	if (usb_ctx == 0)
-		return; /* Context has gone so nothing to do. */
-	if (!usb_ctx->stopped) {
-		oz_trace("Farewell indicated ep = 0x%x\n", ep_num);
-		oz_hcd_data_ind(usb_ctx->hport, ep_num, data, len);
-	}
-	oz_usb_put(usb_ctx);
-}
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_cfg.h	2014-12-03 11:07:31.000000000 +0000
@@ -1342,6 +1342,13 @@
 #define CFG_P2P_DEVICE_ADDRESS_ADMINISTRATED_MAX                 ( 1 )
 #define CFG_P2P_DEVICE_ADDRESS_ADMINISTRATED_DEFAULT             ( 0 )
 
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+#define CFG_MC_ADDR_LIST_FILTER_NAME               "isMcAddrListFilter"
+#define CFG_MC_ADDR_LIST_FILTER_MIN                ( 0 )
+#define CFG_MC_ADDR_LIST_FILTER_MAX                ( 1 )
+#define CFG_MC_ADDR_LIST_FILTER_DEFAULT            ( 0 )
+#endif
+
 #define CFG_ENABLE_SSR                      "gEnableSSR"
 #define CFG_ENABLE_SSR_MIN                  ( 0 )
 #define CFG_ENABLE_SSR_MAX                  ( 1 )
@@ -1776,16 +1783,6 @@
 #define CFG_SPLIT_SCAN_TRAFFIC_MONITOR_TIMER_MAX       ( 10000 )
 #define CFG_SPLIT_SCAN_TRAFFIC_MONITOR_TIMER_DEFAULT   ( 5000 )
 
-#define CFG_RA_FILTER_ENABLE_NAME               "gRAFilterEnable"
-#define CFG_RA_FILTER_ENABLE_DEFAULT            (1)
-#define CFG_RA_FILTER_ENABLE_MIN                (0)
-#define CFG_RA_FILTER_ENABLE_MAX                (1)
-
-#define CFG_RA_RATE_LIMIT_INTERVAL_NAME         "gRARateLimitInterval"
-#define CFG_RA_RATE_LIMIT_INTERVAL_DEFAULT      (60)
-#define CFG_RA_RATE_LIMIT_INTERVAL_MIN          (0)
-#define CFG_RA_RATE_LIMIT_INTERVAL_MAX          (60)
-
 /*--------------------------------------------------------------------------- 
   Type declarations
   -------------------------------------------------------------------------*/ 
@@ -2113,6 +2110,9 @@
    v_U8_t                      allowMCCGODiffBI;
    v_BOOL_t                    isP2pDeviceAddrAdministrated;
    v_U8_t                      thermalMitigationEnable;
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+   v_BOOL_t                    isMcAddrListFilter;
+#endif
 #ifdef WLAN_FEATURE_11AC
    v_U8_t                      vhtChannelWidth;
    v_U8_t                      vhtRxMCS;
@@ -2165,8 +2165,6 @@
    v_U32_t                     cfgMaxMediumTime;
    v_U8_t                      enableTrafficMonitor;
    v_U32_t                     trafficIdleTimeout;
-   v_BOOL_t                    cfgRAFilterEnable;
-   v_U16_t                     cfgRARateLimitInterval;
 } hdd_config_t;
 /*--------------------------------------------------------------------------- 
   Function declarations and documenation
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_main.h	2014-12-03 11:07:31.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -190,8 +190,6 @@
 #define GTK_OFFLOAD_DISABLE 1
 #endif
 
-#define MAX_USER_COMMAND_SIZE 4096
-
 #define HDD_MAC_ADDR_LEN    6
 typedef v_U8_t tWlanHddMacAddr[HDD_MAC_ADDR_LEN];
 
@@ -684,13 +682,6 @@
 
    /** Handle to the network device */
    struct net_device *dev;
-
-#ifdef WLAN_NS_OFFLOAD
-   /** IPv6 notifier callback for handling NS offload on change in IP */
-   struct notifier_block ipv6_notifier;
-   bool ipv6_notifier_registered;
-   struct work_struct  ipv6NotifierWorkQueue;
-#endif
     
    //TODO Move this to sta Ctx
    struct wireless_dev wdev ;
@@ -1109,7 +1100,5 @@
 int wlan_hdd_setIPv6Filter(hdd_context_t *pHddCtx, tANI_U8 filterType, tANI_U8 sessionId);
 #endif
 VOS_STATUS hdd_issta_p2p_clientconnected(hdd_context_t *pHddCtx);
-#ifdef WLAN_NS_OFFLOAD
-void hdd_ipv6_notifier_work_queue(struct work_struct *work);
-#endif
+
 #endif    // end #if !defined( WLAN_HDD_MAIN_H )
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/inc/wlan_hdd_power.h	2014-12-03 11:07:31.000000000 +0000
@@ -102,6 +102,6 @@
 void hdd_conf_gtk_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable);
 #endif
 #ifdef WLAN_NS_OFFLOAD
-void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, int fenable);
+void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable);
 #endif
 #endif // if !defined __WLAN_QCT_DRIVER_H
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_assoc.c	2014-12-03 11:07:31.000000000 +0000
@@ -2299,12 +2299,9 @@
                 if (pHddCtx->hdd_mcastbcast_filter_set == TRUE)
                 {
                     hdd_conf_mcastbcast_filter(pHddCtx, FALSE);
-
-                    if (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid) {
-                        pHddCtx->configuredMcastBcastFilter =
-                            pHddCtx->sus_res_mcastbcast_filter;
-                        pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
-                    }
+                    pHddCtx->configuredMcastBcastFilter =
+                        pHddCtx->sus_res_mcastbcast_filter;
+                    pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
 
                     hddLog(VOS_TRACE_LEVEL_INFO,
                            "offload: disassociation happening, restoring configuredMcastBcastFilter");
@@ -2314,12 +2311,19 @@
                            "offload: already called mcastbcast filter");
                     (WLAN_HDD_GET_CTX(pAdapter))->hdd_mcastbcast_filter_set = FALSE;
                 }
-#ifdef WLAN_FEATURE_PACKET_FILTERING
-                /* Call to clear any MC Addr List filter applied after
-                 * successful connection.
-                 */
-                wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+#ifdef WLAN_FEATURE_PACKET_FILTERING    
+                if (pHddCtx->cfg_ini->isMcAddrListFilter)
+                {
+                    /*Multicast addr filtering is enabled*/
+                    if (pAdapter->mc_addr_list.isFilterApplied)
+                    {
+                        /*Filter applied during suspend mode*/
+                        /*Clear it here*/
+                        wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+                    }
+                }
 #endif
+
             }
             break;
         case eCSR_ROAM_IBSS_LEAVE:
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg.c	2014-12-03 11:07:31.000000000 +0000
@@ -1998,6 +1998,14 @@
               CFG_THERMAL_MIGRATION_ENABLE_DEFAULT,
               CFG_THERMAL_MIGRATION_ENABLE_MIN,
               CFG_THERMAL_MIGRATION_ENABLE_MAX ),
+#ifdef WLAN_FEATURE_PACKET_FILTERING
+ REG_VARIABLE( CFG_MC_ADDR_LIST_FILTER_NAME, WLAN_PARAM_Integer,
+              hdd_config_t, isMcAddrListFilter,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_MC_ADDR_LIST_FILTER_DEFAULT,
+              CFG_MC_ADDR_LIST_FILTER_MIN,
+              CFG_MC_ADDR_LIST_FILTER_MAX ),
+#endif
 
 REG_VARIABLE( CFG_ENABLE_MODULATED_DTIM_NAME, WLAN_PARAM_Integer,
               hdd_config_t, enableModulatedDTIM,
@@ -2290,20 +2298,6 @@
                 CFG_TRAFFIC_IDLE_TIMEOUT_DEFAULT,
                 CFG_TRAFFIC_IDLE_TIMEOUT_MIN,
                 CFG_TRAFFIC_IDLE_TIMEOUT_MAX),
-
-   REG_VARIABLE(CFG_RA_FILTER_ENABLE_NAME, WLAN_PARAM_Integer,
-                hdd_config_t, cfgRAFilterEnable,
-                VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
-                CFG_RA_FILTER_ENABLE_DEFAULT,
-                CFG_RA_FILTER_ENABLE_MIN,
-                CFG_RA_FILTER_ENABLE_MAX ),
-
-   REG_VARIABLE(CFG_RA_RATE_LIMIT_INTERVAL_NAME, WLAN_PARAM_Integer,
-               hdd_config_t, cfgRARateLimitInterval,
-               VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
-               CFG_RA_RATE_LIMIT_INTERVAL_DEFAULT,
-               CFG_RA_RATE_LIMIT_INTERVAL_MIN,
-               CFG_RA_RATE_LIMIT_INTERVAL_MAX ),
 };
 
 /*
@@ -3794,20 +3788,6 @@
       hddLog(LOGE, "Could not pass on WNI_CFG_MAX_MEDIUM_TIME to CCM");
    }
 
-   if (ccmCfgSetInt(pHddCtx->hHal, WNI_CFG_RA_FILTER_ENABLE, pConfig->cfgRAFilterEnable,
-      NULL, eANI_BOOLEAN_FALSE) == eHAL_STATUS_FAILURE)
-   {
-      fStatus = FALSE;
-      hddLog(LOGE, "Could not pass on WNI_CFG_RA_FILTER_ENABLE to CCM");
-   }
-
-   if (ccmCfgSetInt(pHddCtx->hHal, WNI_CFG_RA_RATE_LIMIT_INTERVAL, pConfig->cfgRARateLimitInterval,
-      NULL, eANI_BOOLEAN_FALSE) == eHAL_STATUS_FAILURE)
-   {
-      fStatus = FALSE;
-      hddLog(LOGE, "Could not pass on WNI_CFG_RA_FILTER_ENABLE to CCM");
-   }
-
    return fStatus;
 }
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_cfg80211.c	2014-12-03 11:07:31.000000000 +0000
@@ -469,14 +469,6 @@
    DATA_RATE_11AC_MAX_MCS_NA
 } eDataRate11ACMaxMcs;
 
-/* SSID broadcast  type */
-typedef enum eSSIDBcastType
-{
-  eBCAST_UNKNOWN      = 0,
-  eBCAST_NORMAL       = 1,
-  eBCAST_HIDDEN       = 2,
-} tSSIDBcastType;
-
 /* MCS Based VHT rate table */
 static struct index_vht_data_rate_type supported_vht_mcs_rate[] =
 {
@@ -519,8 +511,6 @@
         return NULL;
     }
 
-    wiphy->country_ie_pref = NL80211_COUNTRY_IE_IGNORE_CORE;
-
     return wiphy;
 }
 
@@ -4696,31 +4686,19 @@
         if( request->ie_len )
         {
             /* save this for future association (join requires this) */
-            /*TODO: Array needs to be converted to dynamic allocation,
-             * as multiple ie.s can be sent in cfg80211_scan_request structure
-             * CR 597966
-             */
             memset( &pScanInfo->scanAddIE, 0, sizeof(pScanInfo->scanAddIE) );
             memcpy( pScanInfo->scanAddIE.addIEdata, request->ie, request->ie_len);
             pScanInfo->scanAddIE.length = request->ie_len;
 
-            if ((WLAN_HDD_INFRA_STATION == pAdapter->device_mode) ||
+            if((WLAN_HDD_INFRA_STATION == pAdapter->device_mode) ||
                 (WLAN_HDD_P2P_CLIENT == pAdapter->device_mode) ||
-                (WLAN_HDD_P2P_DEVICE == pAdapter->device_mode))
+                (WLAN_HDD_P2P_DEVICE == pAdapter->device_mode)
+              )
             {
-                if ( request->ie_len <= SIR_MAC_MAX_IE_LENGTH)
-                {
-                    pwextBuf->roamProfile.nAddIEScanLength = request->ie_len;
-                    memcpy( pwextBuf->roamProfile.addIEScan,
-                                     request->ie, request->ie_len);
-                }
-                else
-                {
-                    hddLog(VOS_TRACE_LEVEL_ERROR, "Scan Ie length is invalid:"
-                             "%d", request->ie_len);
-                }
-
+               pwextBuf->roamProfile.pAddIEScan = pScanInfo->scanAddIE.addIEdata;
+               pwextBuf->roamProfile.nAddIEScanLength = pScanInfo->scanAddIE.length;
             }
+
             scanRequest.uIEFieldLen = pScanInfo->scanAddIE.length;
             scanRequest.pIEField = pScanInfo->scanAddIE.addIEdata;
 
@@ -7140,7 +7118,7 @@
     tpSirPNOScanReq pPnoRequest = NULL;
     hdd_context_t *pHddCtx;
     tHalHandle hHal;
-    v_U32_t i, indx, num_ch, j;
+    v_U32_t i, indx, num_ch;
     u8 valid_ch[WNI_CFG_VALID_CHANNEL_LIST_LEN];
     u8 channels_allowed[WNI_CFG_VALID_CHANNEL_LIST_LEN];
     v_U32_t num_channels_allowed = WNI_CFG_VALID_CHANNEL_LIST_LEN;
@@ -7245,7 +7223,7 @@
                request->match_sets[i].ssid.ssid_len);
         pPnoRequest->aNetworks[i].authentication = 0; /*eAUTH_TYPE_ANY*/
         pPnoRequest->aNetworks[i].encryption     = 0; /*eED_ANY*/
-        pPnoRequest->aNetworks[i].bcastNetwType  = eBCAST_NORMAL; /*eBCAST_NORMAL*/
+        pPnoRequest->aNetworks[i].bcastNetwType  = 0; /*eBCAST_UNKNOWN*/
 
         /*Copying list of valid channel into request */
         memcpy(pPnoRequest->aNetworks[i].aChannels, valid_ch, num_ch);
@@ -7254,26 +7232,6 @@
         pPnoRequest->aNetworks[i].rssiThreshold = 0; //Default value
     }
 
-    for (i = 0; i < request->n_ssids; i++)
-    {
-        j = 0;
-        while (j < pPnoRequest->ucNetworksCount)
-        {
-            if ((pPnoRequest->aNetworks[j].ssId.length ==
-                 request->ssids[i].ssid_len) &&
-                 (0 == memcmp(pPnoRequest->aNetworks[j].ssId.ssId,
-                            request->ssids[i].ssid,
-                            pPnoRequest->aNetworks[j].ssId.length)))
-            {
-                pPnoRequest->aNetworks[j].bcastNetwType = eBCAST_HIDDEN;
-                break;
-            }
-            j++;
-        }
-    }
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "Number of hidden networks being Configured = %d",
-              request->n_ssids);
     /* framework provides interval in ms */
     pPnoRequest->scanTimers.ucScanTimersCount = 1;
     pPnoRequest->scanTimers.aTimerValues[0].uTimerValue =
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_early_suspend.c	2014-12-03 11:07:31.000000000 +0000
@@ -107,8 +107,6 @@
 #include "wlan_hdd_packet_filtering.h"
 
 #define HDD_SSR_BRING_UP_TIME 180000
-#define NS_DEFAULT_SLOT_INDEX 4
-#define NS_EXTENDED_SLOT_INDEX 18
 
 static eHalStatus g_full_pwr_status;
 static eHalStatus g_standby_status;
@@ -562,157 +560,22 @@
 }
 
 #ifdef WLAN_NS_OFFLOAD
-void hdd_ipv6_notifier_work_queue(struct work_struct *work)
-{
-    hdd_adapter_t* pAdapter =
-             container_of(work, hdd_adapter_t, ipv6NotifierWorkQueue);
-    hdd_context_t *pHddCtx;
-    int status;
-
-    hddLog(LOG1, FL("Reconfiguring NS Offload"));
-    pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
-    status = wlan_hdd_validate_context(pHddCtx);
-    if (0 != status)
-    {
-        hddLog(LOGE, FL("HDD context is invalid"));
-        return;
-    }
-
-    if ((eConnectionState_Associated ==
-                (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState)
-         && (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid))
-    {
-        // This invocation being part of the IPv6 registration callback,
-        // we are passing second parameter as 2 to avoid registration
-        // of IPv6 notifier again.
-        hdd_conf_ns_offload(pAdapter, 2);
-    }
-}
-
-static int wlan_hdd_ipv6_changed(struct notifier_block *nb,
-                                   unsigned long data, void *arg)
-{
-    struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)arg;
-    struct net_device *ndev = ifa->idev->dev;
-    hdd_adapter_t *pAdapter =
-             container_of(nb, struct hdd_adapter_s, ipv6_notifier);
-    hdd_context_t *pHddCtx;
-    int status;
-
-    if (pAdapter && pAdapter->dev == ndev)
-    {
-        pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
-        status = wlan_hdd_validate_context(pHddCtx);
-        if (0 != status)
-        {
-            hddLog(LOGE, FL("HDD context is invalid"));
-            return NOTIFY_DONE;
-        }
-
-        schedule_work(&pAdapter->ipv6NotifierWorkQueue);
-    }
-
-    return NOTIFY_DONE;
-}
-
-/**----------------------------------------------------------------------------
-
-  \brief hdd_conf_ns_offload() - Configure NS offload
-
-  Called during SUSPEND to configure the NS offload (MC BC filter) which
-  reduces power consumption.
-
-  \param  - pAdapter - Adapter context for which NS offload is to be configured
-  \param  - fenable - 0 - disable.
-                      1 - enable. (with IPv6 notifier registration)
-                      2 - enable. (without IPv6 notifier registration)
-
-  \return - void
-
-  ---------------------------------------------------------------------------*/
-void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, int fenable)
+void hdd_conf_ns_offload(hdd_adapter_t *pAdapter, v_BOOL_t fenable)
 {
     struct inet6_dev *in6_dev;
     struct inet6_ifaddr *ifp;
     struct list_head *p;
+    tANI_U8 selfIPv6Addr[SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA][SIR_MAC_IPV6_ADDR_LEN] = {{0,}};
+    tANI_BOOLEAN selfIPv6AddrValid[SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA] = {0};
     tSirHostOffloadReq offLoadRequest;
-    int slot_index = NS_DEFAULT_SLOT_INDEX;
-    tANI_U8 **selfIPv6Addr;
-    tANI_U8 *selfIPv6AddrValid;
     hdd_context_t *pHddCtx;
-    tHalHandle halHandle;
-    int status;
 
-    int i = 0, slot = 0;
-    int ret = 0;
+    int i =0;
     eHalStatus returnStatus;
 
-    ENTER();
-    hddLog(LOG1, FL(" fenable = %d"), fenable);
-
-    if (NULL == pAdapter)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD adapter is Null"));
-        return;
-    }
-
-    halHandle = WLAN_HDD_GET_HAL_CTX(pAdapter);
     pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
-    status = wlan_hdd_validate_context(pHddCtx);
-
-    if (0 != status)
-    {
-        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                   "%s: HDD context is not valid", __func__);
-        return;
-    }
-
-    if (sme_IsFeatureSupportedByFW(EXTENDED_NSOFFLOAD_SLOT))
-    {
-        slot_index = NS_EXTENDED_SLOT_INDEX;
-    }
-
-    hddLog(VOS_TRACE_LEVEL_INFO, FL("slot_idex = %d"), slot_index);
-
-    selfIPv6AddrValid =
-            (tANI_U8 *)vos_mem_malloc(sizeof(tANI_U8) * slot_index);
-
-    if (NULL == selfIPv6AddrValid)
-    {
-        hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory for"
-                                         " selfIPv6AddrValid"));
-        goto end;
-    }
-
-    memset(selfIPv6AddrValid, 0, slot_index * sizeof(tANI_U8));
-
-    selfIPv6Addr = (tANI_U8 **)vos_mem_malloc(sizeof(tANI_U8 *) * slot_index);
-
-    if (NULL == selfIPv6Addr)
-    {
-        hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory for"
-                                         " selfIPv6Addr"));
-        goto end;
-    }
-
-    memset(selfIPv6Addr, 0, slot_index * sizeof(tANI_U8 *));
-
-    for (slot = 0; slot < slot_index; slot++)
-    {
-        selfIPv6Addr[slot] =
-           (tANI_U8 *)vos_mem_malloc(SIR_MAC_IPV6_ADDR_LEN);
-        if (NULL == selfIPv6Addr[slot])
-        {
-            hddLog (VOS_TRACE_LEVEL_ERROR, FL("Failed to allocate memory"
-                                              "for selfIPv6Addr"));
-            goto end;
-        }
-        memset(selfIPv6Addr[slot], 0, SIR_MAC_IPV6_ADDR_LEN);
-    }
-
-    i = 0;
-
+    ENTER();
     if (fenable)
     {
         in6_dev = __in6_dev_get(pAdapter->dev);
@@ -721,47 +584,34 @@
             //read_lock_bh(&in6_dev->lock);
             list_for_each(p, &in6_dev->addr_list)
             {
-                if (i >= slot_index)
-                {
-                    hddLog (VOS_TRACE_LEVEL_ERROR,
-                            FL("IPv6 address list is greater than IPv6"
-                               "address supported by firmware"));
-                    hddLog (VOS_TRACE_LEVEL_ERROR,
-                            FL("FW supported IPv6 address = %d"), slot_index);
-                    break;
-                }
                 ifp = list_entry(p, struct inet6_ifaddr, if_list);
                 switch(ipv6_addr_src_scope(&ifp->addr))
                 {
                     case IPV6_ADDR_SCOPE_LINKLOCAL:
-                        vos_mem_copy(selfIPv6Addr[i], &ifp->addr.s6_addr,
+                        vos_mem_copy(&selfIPv6Addr[0], &ifp->addr.s6_addr,
                                 sizeof(ifp->addr.s6_addr));
-                        selfIPv6AddrValid[i] = SIR_IPV6_ADDR_VALID;
+                        selfIPv6AddrValid[0] = SIR_IPV6_ADDR_VALID;
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                           FL("Found IPV6_ADDR_SCOPE_LINKLOCAL Address : %pI6"),
-                               selfIPv6Addr[i]);
+                               "Found IPV6_ADDR_SCOPE_LINKLOCAL Address : %pI6",
+                               selfIPv6Addr[0]);
                         break;
                     case IPV6_ADDR_SCOPE_GLOBAL:
-                        vos_mem_copy(selfIPv6Addr[i], &ifp->addr.s6_addr,
+                        vos_mem_copy(&selfIPv6Addr[1], &ifp->addr.s6_addr,
                                 sizeof(ifp->addr.s6_addr));
-                        selfIPv6AddrValid[i] = SIR_IPV6_ADDR_VALID;
+                        selfIPv6AddrValid[1] = SIR_IPV6_ADDR_VALID;
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                           FL("Found IPV6_ADDR_SCOPE_GLOBAL Address : %pI6"),
-                               selfIPv6Addr[i]);
+                               "Found IPV6_ADDR_SCOPE_GLOBAL Address : %pI6",
+                               selfIPv6Addr[1]);
                         break;
                     default:
-                        hddLog(VOS_TRACE_LEVEL_ERROR,
-                           FL("The Scope %d is not supported"),
-                               ipv6_addr_src_scope(&ifp->addr));
+                        hddLog(LOGE, "The Scope %d is not supported",
+                                ipv6_addr_src_scope(&ifp->addr));
                 }
-                if (selfIPv6AddrValid[i] == SIR_IPV6_ADDR_VALID)
-                {
-                    i++;
-                }
-            }
 
+            }
+            //read_unlock_bh(&in6_dev->lock);
             vos_mem_zero(&offLoadRequest, sizeof(offLoadRequest));
-            for (i =0; i < slot_index; i++)
+            for (i =0; i<SIR_MAC_NUM_TARGET_IPV6_NS_OFFLOAD_NA; i++)
             {
                 if (selfIPv6AddrValid[i])
                 {
@@ -779,40 +629,32 @@
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[1] = 0x02;
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[11] = 0x01;
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr[12] = 0xFF;
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[13] =
-                                                          selfIPv6Addr[i][13];
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[14] =
-                                                          selfIPv6Addr[i][14];
-                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[15] =
-                                                          selfIPv6Addr[i][15];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[13] = selfIPv6Addr[i][13];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[14] = selfIPv6Addr[i][14];
+                    offLoadRequest.nsOffloadInfo.selfIPv6Addr[15] = selfIPv6Addr[i][15];
                     offLoadRequest.nsOffloadInfo.slotIdx = i;
 
                     vos_mem_copy(&offLoadRequest.nsOffloadInfo.targetIPv6Addr[0],
-                        selfIPv6Addr[i], sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
+                                &selfIPv6Addr[i][0], sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
                     vos_mem_copy(&offLoadRequest.nsOffloadInfo.selfMacAddr,
                                 &pAdapter->macAddressCurrent.bytes,
                                 sizeof(tANI_U8)*SIR_MAC_ADDR_LEN);
 
-                    offLoadRequest.nsOffloadInfo.targetIPv6AddrValid[0] =
-                                                          SIR_IPV6_ADDR_VALID;
+                    offLoadRequest.nsOffloadInfo.targetIPv6AddrValid[0] = SIR_IPV6_ADDR_VALID;
                     offLoadRequest.offloadType =  SIR_IPV6_NS_OFFLOAD;
                     offLoadRequest.enableOrDisable = SIR_OFFLOAD_ENABLE;
 
                     hddLog (VOS_TRACE_LEVEL_INFO,
-                       FL("configuredMcastBcastFilter: %d"
-                       "NSOffload Slot = %d"),
-                       pHddCtx->configuredMcastBcastFilter, i);
+                    "configuredMcastBcastFilter: %d",pHddCtx->configuredMcastBcastFilter);
 
                     if ((VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid)
                        && ((HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST ==
                           pHddCtx->sus_res_mcastbcast_filter) ||
-                         (HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST_BROADCAST ==
-                          pHddCtx->sus_res_mcastbcast_filter))
-                       && (!pHddCtx->cfg_ini->fEnableMCAddrList))
+                          (HDD_MCASTBCASTFILTER_FILTER_ALL_MULTICAST_BROADCAST ==
+                          pHddCtx->sus_res_mcastbcast_filter)))
                     {
                         hddLog (VOS_TRACE_LEVEL_INFO,
-                        FL("Set offLoadRequest with"
-                           "SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE"));
+                        "Set offLoadRequest with SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE \n", __func__);
                         offLoadRequest.enableOrDisable =
                          SIR_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE;
                     }
@@ -822,87 +664,45 @@
                                 sizeof(tANI_U8)*SIR_MAC_IPV6_ADDR_LEN);
 
                     hddLog (VOS_TRACE_LEVEL_INFO,
-                    FL("Setting NSOffload with solicitedIp: %pI6,"
-                       "targetIp: %pI6"),
+                    "Setting NSOffload with solicitedIp: %pI6, targetIp: %pI6",
                     offLoadRequest.nsOffloadInfo.selfIPv6Addr,
                     offLoadRequest.nsOffloadInfo.targetIPv6Addr[0]);
 
                     //Configure the Firmware with this
-                    returnStatus = sme_SetHostOffload(halHandle,
+                    returnStatus = sme_SetHostOffload(WLAN_HDD_GET_HAL_CTX(pAdapter),
                                     pAdapter->sessionId, &offLoadRequest);
                     if(eHAL_STATUS_SUCCESS != returnStatus)
                     {
                         hddLog(VOS_TRACE_LEVEL_ERROR,
-                        FL("Failed to enable HostOffload feature with"
-                           " status: %d"), returnStatus);
+                        FL("Failed to enable HostOffload feature with status: %d"),
+                        returnStatus);
                     }
                     vos_mem_zero(&offLoadRequest, sizeof(offLoadRequest));
                 }
             }
-            if (fenable == 1 && !pAdapter->ipv6_notifier_registered)
-            {
-                // Register IPv6 notifier to notify if any change in IP
-                // So that we can reconfigure the offload parameters
-                pAdapter->ipv6_notifier.notifier_call =
-                             wlan_hdd_ipv6_changed;
-                ret = register_inet6addr_notifier(&pAdapter->ipv6_notifier);
-                if (ret)
-                {
-                    hddLog(LOGE, FL("Failed to register IPv6 notifier"));
-                }
-                else
-                {
-                    hddLog(LOG1, FL("Registered IPv6 notifier"));
-                    pAdapter->ipv6_notifier_registered = true;
-                }
-            }
         }
         else
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,
                     FL("IPv6 dev does not exist. Failed to request NSOffload"));
-              goto end;
+            return;
         }
     }
     else
     {
         //Disable NSOffload
-        if (pAdapter->ipv6_notifier_registered)
-        {
-            hddLog(LOG1, FL("Unregistered IPv6 notifier"));
-            unregister_inet6addr_notifier(&pAdapter->ipv6_notifier);
-            pAdapter->ipv6_notifier_registered = false;
-        }
         vos_mem_zero((void *)&offLoadRequest, sizeof(tSirHostOffloadReq));
         offLoadRequest.enableOrDisable = SIR_OFFLOAD_DISABLE;
         offLoadRequest.offloadType =  SIR_IPV6_NS_OFFLOAD;
 
-	for (i = 0; i < slot_index; i++)
-        {
-            hddLog(VOS_TRACE_LEVEL_INFO, FL("Disable Slot= %d"), i);
-            offLoadRequest.nsOffloadInfo.slotIdx = i;
-            if (eHAL_STATUS_SUCCESS !=
+        if (eHAL_STATUS_SUCCESS !=
                  sme_SetHostOffload(WLAN_HDD_GET_HAL_CTX(pAdapter),
                  pAdapter->sessionId, &offLoadRequest))
-            {
-                hddLog(VOS_TRACE_LEVEL_ERROR, FL("Failure to disable"
-                                                 " %d Slot"), i);
-            }
+        {
+            hddLog(VOS_TRACE_LEVEL_ERROR, FL("Failure to disable"
+                             "NSOffload feature"));
         }
     }
-end:
-    while (slot > 0 && selfIPv6Addr[--slot])
-    {
-       vos_mem_free(selfIPv6Addr[slot]);
-    }
-    if (selfIPv6Addr)
-    {
-       vos_mem_free(selfIPv6Addr);
-    }
-    if (selfIPv6AddrValid)
-    {
-       vos_mem_free(selfIPv6AddrValid);
-    }
     return;
 }
 #endif
@@ -1105,11 +905,19 @@
         wlanSuspendParam->configuredMcstBcstFilterSetting = pHddCtx->configuredMcastBcastFilter;
 
 #ifdef WLAN_FEATURE_PACKET_FILTERING
-        /* During suspend, configure MC Addr list filter to the firmware
-         * function takes care of checking necessary conditions before
-         * configuring.
-         */
-        wlan_hdd_set_mc_addr_list(pAdapter, TRUE);
+        if (pHddCtx->cfg_ini->isMcAddrListFilter)
+        {
+           /*Multicast addr list filter is enabled during suspend*/
+           if (((pAdapter->device_mode == WLAN_HDD_INFRA_STATION) ||
+                    (pAdapter->device_mode == WLAN_HDD_P2P_CLIENT))
+                 && pAdapter->mc_addr_list.mc_cnt
+                 && (eConnectionState_Associated ==
+                    (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState))
+           {
+              /*set the filter*/
+              wlan_hdd_set_mc_addr_list(pAdapter, TRUE);
+           }
+        }
 #endif
     }
 
@@ -1153,11 +961,9 @@
 
     pHddCtx->hdd_mcastbcast_filter_set = FALSE;
 
-    if (VOS_TRUE == pHddCtx->sus_res_mcastbcast_filter_valid) {
-        pHddCtx->configuredMcastBcastFilter =
-            pHddCtx->sus_res_mcastbcast_filter;
-        pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
-    }
+    pHddCtx->configuredMcastBcastFilter =
+      pHddCtx->sus_res_mcastbcast_filter;
+    pHddCtx->sus_res_mcastbcast_filter_valid = VOS_FALSE;
 
     hddLog(VOS_TRACE_LEVEL_INFO,
            "offload: in hdd_conf_resume_ind, restoring configuredMcastBcastFilter");
@@ -1166,10 +972,16 @@
 
 
 #ifdef WLAN_FEATURE_PACKET_FILTERING
-    /* Filer was applied during suspend inditication
-     * clear it when we resume.
-     */
-    wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+    if (pHddCtx->cfg_ini->isMcAddrListFilter)
+    {
+       /*Multicast addr filtering is enabled*/
+       if (pAdapter->mc_addr_list.isFilterApplied)
+       {
+          /*Filter applied during suspend mode*/
+          /*Clear it here*/
+          wlan_hdd_set_mc_addr_list(pAdapter, FALSE);
+       }
+    }
 #endif
 }
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_hostapd.c	2014-12-03 11:07:31.000000000 +0000
@@ -1338,14 +1338,7 @@
 {
     hdd_adapter_t *pHostapdAdapter = (netdev_priv(dev));
     v_U8_t *peerMacAddr;    
-   
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
+    
     ENTER();
     /* iwpriv tool or framework calls this ioctl with
      * data passed in extra (less than 16 octets);
@@ -2151,17 +2144,9 @@
    u_int8_t *pos;
    tpSap_WPSIE pSap_WPSIe;
    u_int8_t WPSIeType;
-   u_int16_t length;  
-   int ret = 0;
+   u_int16_t length;   
    ENTER();
 
-   if (!capable(CAP_NET_ADMIN))
-   {
-     VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-	       FL("permission check failed"));
-     return -EPERM;
-   }
-
    if(!wrqu->data.length)
       return 0;
 
@@ -2184,8 +2169,8 @@
          case DOT11F_EID_WPA: 
             if (wps_genie[1] < 2 + 4)
             {
-	       ret = -EINVAL;
-	       goto exit;
+               vos_mem_free(pSap_WPSIe); 
+               return -EINVAL;
             }
             else if (memcmp(&wps_genie[2], "\x00\x50\xf2\x04", 4) == 0) 
             {
@@ -2243,11 +2228,6 @@
                       pos += 2; 
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > sizeof(pSap_WPSIe->sapwpsie.sapWPSBeaconIE.UUID_E))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSBeaconIE.UUID_E, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSBeaconIE.FieldPresent |= WPS_BEACON_UUIDE_PRESENT; 
                       pos += length;
@@ -2262,8 +2242,8 @@
                    
                    default:
                       hddLog (LOGW, "UNKNOWN TLV in WPS IE(%x)\n", (*pos<<8 | *(pos+1)));
-		      ret = -EINVAL;
-		      goto exit;
+                      vos_mem_free(pSap_WPSIe);
+                      return -EINVAL; 
                 }
               }  
             }
@@ -2275,8 +2255,8 @@
                  
          default:
             hddLog (LOGE, "%s Set UNKNOWN IE %X",__func__, wps_genie[0]);
-	    ret = -EINVAL;
-	    goto exit;
+            vos_mem_free(pSap_WPSIe);
+            return 0;
       }
     } 
     else if( wps_genie[0] == eQC_WPS_PROBE_RSP_IE)
@@ -2288,8 +2268,8 @@
          case DOT11F_EID_WPA: 
             if (wps_genie[1] < 2 + 4)
             {
-	       ret = -EINVAL;
-	       goto exit;
+               vos_mem_free(pSap_WPSIe); 
+               return -EINVAL;
             }
             else if (memcmp(&wps_genie[2], "\x00\x50\xf2\x04", 4) == 0) 
             {
@@ -2353,11 +2333,6 @@
                       pos += 2; 
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.UUID_E)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.UUID_E, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_UUIDE_PRESENT;
                       pos += length;
@@ -2367,11 +2342,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length >  (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.name)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.num_name = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.Manufacture.name, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MANUFACTURE_PRESENT;
@@ -2382,11 +2352,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelName.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MODELNAME_PRESENT;
@@ -2396,11 +2361,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.ModelNumber.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_MODELNUMBER_PRESENT;
@@ -2410,11 +2370,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.SerialNumber.text, pos, length);
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.FieldPresent |= WPS_PROBRSP_SERIALNUMBER_PRESENT;
@@ -2425,6 +2380,7 @@
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceCategory = (*pos<<8 | *(pos+1));
                       hddLog(LOG1, "primary dev category: %d\n", pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceCategory);  
                       pos += 2;
+                      
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.PrimaryDeviceOUI, pos, HDD_WPS_DEVICE_OUI_LEN);
                       hddLog(LOG1, "primary dev oui: %02x, %02x, %02x, %02x\n", pos[0], pos[1], pos[2], pos[3]);
                       pos += 4;
@@ -2437,11 +2393,6 @@
                       pos += 2;
                       length = *pos<<8 | *(pos+1);
                       pos += 2;
-		      if (length > (sizeof(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.text)))
-		      {
-			ret = -EINVAL;
-			goto exit;
-		      }
                       pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.num_text = length;
                       vos_mem_copy(pSap_WPSIe->sapwpsie.sapWPSProbeRspIE.DeviceName.text, pos, length);
                       pos += length;
@@ -2473,8 +2424,6 @@
       } // switch
     }
     halStatus = WLANSAP_Set_WpsIe(pVosContext, pSap_WPSIe);
-    if (halStatus != eHAL_STATUS_SUCCESS)
-      ret = -EINVAL;
     pHostapdState = WLAN_HDD_GET_HOSTAP_STATE_PTR(pHostapdAdapter);
     if( pHostapdState->bCommit && WPSIeType == eQC_WPS_PROBE_RSP_IE)
     {
@@ -2483,10 +2432,9 @@
         WLANSAP_Update_WpsIe ( pVosContext );
     }
  
- exit:
     vos_mem_free(pSap_WPSIe);   
     EXIT();
-    return ret;
+    return halStatus;
 }
 
 static int iw_softap_stopbss(struct net_device *dev,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_main.c	2014-12-03 11:07:31.000000000 +0000
@@ -101,8 +101,6 @@
 #include <bapInternal.h>
 #endif // WLAN_BTAMP_FEATURE
 
-#include <linux/inetdevice.h>
-#include <net/addrconf.h>
 #include <linux/wireless.h>
 #include <net/cfg80211.h>
 #include "wlan_hdd_cfg80211.h"
@@ -197,6 +195,7 @@
 #endif
 
 void hdd_wlan_initial_scan(hdd_adapter_t *pAdapter);
+int isWDresetInProgress(void);
 
 extern int hdd_setBand_helper(struct net_device *dev, tANI_U8* ptr);
 #if  defined (WLAN_FEATURE_VOWIFI_11R) || defined (FEATURE_WLAN_CCX) || defined(FEATURE_WLAN_LFR)
@@ -227,6 +226,9 @@
       (strncmp(dev->name, "p2p", 3)))
       return NOTIFY_DONE;
 
+   if (isWDresetInProgress())
+      return NOTIFY_DONE;
+
    if (!dev->ieee80211_ptr)
       return NOTIFY_DONE;
 
@@ -245,9 +247,6 @@
       return NOTIFY_DONE;
    }
 
-   if (pHddCtx->isLogpInProgress)
-      return NOTIFY_DONE;
-
    hddLog(VOS_TRACE_LEVEL_INFO, "%s: %s New Net Device State = %lu",
           __func__, dev->name, state);
 
@@ -3771,11 +3770,6 @@
             hdd_deinit_adapter(pHddCtx, pAdapter);
             goto err_free_netdev;
          }
-
-#ifdef WLAN_NS_OFFLOAD
-         // Workqueue which gets scheduled in IPv6 notification callback.
-         INIT_WORK(&pAdapter->ipv6NotifierWorkQueue, hdd_ipv6_notifier_work_queue);
-#endif
          //Stop the Interface TX queue.
          netif_tx_disable(pAdapter->dev);
          //netif_tx_disable(pWlanDev);
@@ -3869,6 +3863,7 @@
       }
    }
 
+
    if( VOS_STATUS_SUCCESS == status )
    {
       //Add it to the hdd's session list. 
@@ -4065,17 +4060,6 @@
          {
             hdd_abort_mac_scan(pHddCtx);
          }
-#ifdef WLAN_NS_OFFLOAD
-#ifdef WLAN_OPEN_SOURCE
-         cancel_work_sync(&pAdapter->ipv6NotifierWorkQueue);
-#endif
-         if (pAdapter->ipv6_notifier_registered)
-         {
-            hddLog(LOG1, FL("Unregistered IPv6 notifier"));
-            unregister_inet6addr_notifier(&pAdapter->ipv6_notifier);
-            pAdapter->ipv6_notifier_registered = false;
-         }
-#endif
 
          if (test_bit(SME_SESSION_OPENED, &pAdapter->event_flags)) 
          {
@@ -6293,7 +6277,7 @@
    }
    else
    {
-      while(pHddCtx->isLogpInProgress) {
+      while(isWDresetInProgress()) {
          VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
               "%s:SSR in Progress; block rmmod for 1 second!!!", __func__);
          msleep(1000);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_oemdata.c	2014-12-03 11:07:31.000000000 +0000
@@ -203,12 +203,6 @@
     hdd_adapter_t *pAdapter = (netdev_priv(dev));
     hdd_wext_state_t *pwextBuf = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
 
-    if (!capable(CAP_NET_ADMIN)) {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_scan.c	2014-12-03 11:07:31.000000000 +0000
@@ -685,8 +685,7 @@
 
       if (wrqu->data.flags & IW_SCAN_THIS_ESSID)  {
 
-          if(scanReq->essid_len &&
-               (scanReq->essid_len <= SIR_MAC_MAX_SSID_LENGTH)) {
+          if(scanReq->essid_len) {
               scanRequest.SSIDs.numOfSSIDs = 1;
               scanRequest.SSIDs.SSIDList =( tCsrSSIDInfo *)vos_mem_malloc(sizeof(tCsrSSIDInfo));
               if(scanRequest.SSIDs.SSIDList) {
@@ -700,10 +699,6 @@
                 VOS_ASSERT(0);
               }
           }
-          else
-          {
-            hddLog(LOGE, FL("Invalid essid length : %d"), scanReq->essid_len);
-          }
       }
 
        /* set min and max channel time */
@@ -745,20 +740,10 @@
        memcpy( pHddCtx->scan_info.scanAddIE.addIEdata, pwextBuf->genIE.addIEdata, 
            pwextBuf->genIE.length );
        pHddCtx->scan_info.scanAddIE.length = pwextBuf->genIE.length;
-      /* Maximum length of each IE is SIR_MAC_MAX_IE_LENGTH */
-       if (SIR_MAC_MAX_IE_LENGTH  >=  pwextBuf->genIE.length)
-       {
-           memcpy( pwextBuf->roamProfile.addIEScan,
-                       pHddCtx->scan_info.scanAddIE.addIEdata,
-                       pHddCtx->scan_info.scanAddIE.length);
-           pwextBuf->roamProfile.nAddIEScanLength =
-                                pHddCtx->scan_info.scanAddIE.length;
-       }
-       else
-       {
-           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                     "Invalid ScanIE, Length is %d", pwextBuf->genIE.length);
-       }
+
+       pwextBuf->roamProfile.pAddIEScan = pHddCtx->scan_info.scanAddIE.addIEdata;
+       pwextBuf->roamProfile.nAddIEScanLength = pHddCtx->scan_info.scanAddIE.length;
+   
        /* clear previous genIE after use it */
        memset( &pwextBuf->genIE, 0, sizeof(pwextBuf->genIE) );
    }
@@ -1136,20 +1121,10 @@
             memcpy( pHddCtx->scan_info.scanAddIE.addIEdata, pwextBuf->genIE.addIEdata, 
                 pwextBuf->genIE.length );
             pHddCtx->scan_info.scanAddIE.length = pwextBuf->genIE.length;
-            if (SIR_MAC_MAX_IE_LENGTH  >=  pwextBuf->genIE.length)
-            {
-                memcpy( pwextBuf->roamProfile.addIEScan,
-                           pHddCtx->scan_info.scanAddIE.addIEdata,
-                           pHddCtx->scan_info.scanAddIE.length);
-                pwextBuf->roamProfile.nAddIEScanLength =
-                                  pHddCtx->scan_info.scanAddIE.length;
-            }
-            else
-            {
-                VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                         "Invalid ScanIE, Length is %d",
-                          pwextBuf->genIE.length);
-            }
+
+            pwextBuf->roamProfile.pAddIEScan = pHddCtx->scan_info.scanAddIE.addIEdata;
+            pwextBuf->roamProfile.nAddIEScanLength = pHddCtx->scan_info.scanAddIE.length;
+
             /* clear previous genIE after use it */
             memset( &pwextBuf->genIE, 0, sizeof(pwextBuf->genIE) );
         }
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wext.c	2014-12-03 11:07:31.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -250,12 +250,17 @@
 #define WLAN_PRIV_DEL_TSPEC (SIOCIWFIRSTPRIV + 11)
 #define WLAN_PRIV_GET_TSPEC (SIOCIWFIRSTPRIV + 13)
 
-/* (SIOCIWFIRSTPRIV + 8)  is currently unused */
-/* (SIOCIWFIRSTPRIV + 16) is currently unused */
-/* (SIOCIWFIRSTPRIV + 10) is currently unused */
-/* (SIOCIWFIRSTPRIV + 12) is currently unused */
-/* (SIOCIWFIRSTPRIV + 14) is currently unused */
-/* (SIOCIWFIRSTPRIV + 15) is currently unused */
+#ifdef FEATURE_WLAN_WAPI
+/* Private ioctls EVEN NO: SET, ODD NO:GET */
+#define WLAN_PRIV_SET_WAPI_MODE         (SIOCIWFIRSTPRIV + 8)
+#define WLAN_PRIV_GET_WAPI_MODE         (SIOCIWFIRSTPRIV + 16)
+#define WLAN_PRIV_SET_WAPI_ASSOC_INFO   (SIOCIWFIRSTPRIV + 10)
+#define WLAN_PRIV_SET_WAPI_KEY          (SIOCIWFIRSTPRIV + 12)
+#define WLAN_PRIV_SET_WAPI_BKID         (SIOCIWFIRSTPRIV + 14)
+#define WLAN_PRIV_GET_WAPI_BKID         (SIOCIWFIRSTPRIV + 15)
+#define WAPI_PSK_AKM_SUITE  0x02721400
+#define WAPI_CERT_AKM_SUITE 0x01721400
+#endif
 
 #ifdef FEATURE_OEM_DATA_SUPPORT
 /* Private ioctls for setting the measurement configuration */
@@ -363,56 +368,6 @@
 
 /**---------------------------------------------------------------------------
 
-  \brief mem_alloc_copy_from_user_helper -
-
-   Helper function to allocate buffer and copy user data.
-
-  \param  - wrqu - Pointer to IOCTL Data.
-            len  - size
-
-  \return - On Success pointer to buffer, On failure NULL
-
-  --------------------------------------------------------------------------*/
-static void *mem_alloc_copy_from_user_helper(const void *wrqu_data, size_t len)
-{
-    u8 *ptr = NULL;
-
-  /* in order to protect the code, an extra byte is post appended to the buffer
-   * and the null termination is added.  However, when allocating (len+1) byte
-   * of memory, we need to make sure that there is no uint overflow when doing
-   * addition. In theory check len < UINT_MAX protects the uint overflow. For
-   * wlan private ioctl, the buffer size is much less than UINT_MAX, as a good
-   * guess, now, it is assumed that the private command buffer size is no
-   * greater than 4K (4096 bytes). So we use 4096 as the upper boundary for now.
-   */
-    if (len > MAX_USER_COMMAND_SIZE)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "Invalid length");
-        return NULL;
-    }
-
-    ptr = kmalloc(len + 1, GFP_KERNEL);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "unable to allocate memory");
-        return NULL;
-    }
-
-    if (copy_from_user(ptr, wrqu_data, len))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: failed to copy data to user buffer", __func__);
-        kfree(ptr);
-        return NULL;
-    }
-    ptr[len] = '\0';
-    return ptr;
-}
-
-/**---------------------------------------------------------------------------
-
   \brief hdd_wlan_get_version() -
 
    This function use to get Wlan Driver, Firmware, & Hardware Version.
@@ -953,8 +908,8 @@
    pWextState->roamProfile.pRSNReqIE = (tANI_U8 *)NULL;
 
    pWextState->roamProfile.bWPSAssociation = VOS_FALSE;
+   pWextState->roamProfile.pAddIEScan = (tANI_U8 *)NULL;
    pWextState->roamProfile.nAddIEScanLength = 0;
-   memset(pWextState->roamProfile.addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH+2);
    pWextState->roamProfile.pAddIEAssoc = (tANI_U8 *)NULL;
    pWextState->roamProfile.nAddIEAssocLength = 0;
 
@@ -1575,37 +1530,24 @@
         union iwreq_data *wrqu,
         char *extra)
 {
-    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+   hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
     hdd_wext_state_t *pWextState = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
-    u_int8_t *genie = NULL;
-    u_int8_t *base_genie = NULL;
+    u_int8_t *genie;
     v_U16_t remLen;
- 
-    ENTER();
-
-    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress) {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, 
-                  "%s:LOGP in Progress. Ignore!!!",__func__);
-        return 0;
-    }
 
-    if (!wrqu->data.length) {
-        hdd_clearRoamProfileIe(pAdapter);
-        EXIT();
-        return 0;
-    }
+   ENTER();
+   if(!wrqu->data.length) {
+      hdd_clearRoamProfileIe(pAdapter);
+      EXIT();
+      return 0;
+   }
 
-    base_genie = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                                 wrqu->data.length);
-    if (NULL == base_genie)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-    
-    genie = base_genie;
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress) {
+      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, "%s:LOGP in Progress. Ignore!!!",__func__);
+      return 0;
+   }
 
+    genie = wrqu->data.pointer;
     remLen = wrqu->data.length;
 
     hddLog(LOG1,"iw_set_genie ioctl IE[0x%X], LEN[%d]\n", genie[0], genie[1]);
@@ -1614,7 +1556,7 @@
     memset( &pWextState->genIE, 0, sizeof(pWextState->genIE) );
 
     while (remLen >= 2)
-    {
+   {
         v_U16_t eLen = 0;
         v_U8_t elementId;
         elementId = *genie++;
@@ -1628,10 +1570,7 @@
          {
             case IE_EID_VENDOR:
                 if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen) /* should have at least OUI */
-		{
-                    kfree(base_genie);
-                    return -EINVAL;
-		}
+                return -EINVAL;
 
                 if (0 == memcmp(&genie[0], "\x00\x50\xf2\x04", 4))
                 {
@@ -1644,8 +1583,7 @@
                        hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
                                                       "Need bigger buffer space\n");
                        VOS_ASSERT(0);
-                       kfree(base_genie);
-		       return -ENOMEM;
+                       return -ENOMEM;
                     }
                     // save to Additional IE ; it should be accumulated to handle WPS IE + other IE
                     memcpy( pWextState->genIE.addIEdata + curGenIELen, genie - 2, eLen + 2);
@@ -1654,14 +1592,6 @@
                 else if (0 == memcmp(&genie[0], "\x00\x50\xf2", 3))
                 {
                     hddLog (VOS_TRACE_LEVEL_INFO, "%s Set WPA IE (len %d)",__func__, eLen + 2);
-                    if ((eLen + 2) > (sizeof(pWextState->WPARSNIE)))
-		      {
-			hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
-			      "Need bigger buffer space");
-			VOS_ASSERT(0);
-                        kfree(base_genie);
-                        return -ENOMEM;
-		      }
                     memset( pWextState->WPARSNIE, 0, MAX_WPA_RSN_IE_LEN );
                     memcpy( pWextState->WPARSNIE, genie - 2, (eLen + 2));
                     pWextState->roamProfile.pWPAReqIE = pWextState->WPARSNIE;
@@ -1678,7 +1608,6 @@
                        hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
                                                       "Need bigger buffer space\n");
                        VOS_ASSERT(0);
-                       kfree(base_genie);
                        return -ENOMEM;
                     }
                     // save to Additional IE ; it should be accumulated to handle WPS IE + other IE
@@ -1688,14 +1617,6 @@
               break;
          case DOT11F_EID_RSN:
                 hddLog (LOG1, "%s Set RSN IE (len %d)",__func__, eLen+2);
-                if ((eLen + 2) > (sizeof(pWextState->WPARSNIE)))
-		  {
-                    hddLog(VOS_TRACE_LEVEL_FATAL, "Cannot accommodate genIE. "
-			   "Need bigger buffer space");
-                    VOS_ASSERT(0);
-                    kfree(base_genie);
-                    return -ENOMEM;
-		  }
                 memset( pWextState->WPARSNIE, 0, MAX_WPA_RSN_IE_LEN );
                 memcpy( pWextState->WPARSNIE, genie - 2, (eLen + 2));
                 pWextState->roamProfile.pRSNReqIE = pWextState->WPARSNIE;
@@ -1704,14 +1625,12 @@
 
          default:
                 hddLog (LOGE, "%s Set UNKNOWN IE %X",__func__, elementId);
-		kfree(base_genie);
-                return 0;
-        }
+            return 0;
+    }
         genie += eLen;
         remLen -= eLen;
     }
     EXIT();
-    kfree(base_genie);
     return 0;
 }
 
@@ -1756,16 +1675,9 @@
                                    pAdapter->sessionId,
                                    &length,
                                    genIeBytes);
+    wrqu->data.length = VOS_MIN((u_int16_t) length, DOT11F_IE_RSN_MAX_LEN);
 
-    length = VOS_MIN((u_int16_t) length, DOT11F_IE_RSN_MAX_LEN);
-    if (wrqu->data.length < length)
-    {
-        hddLog(LOG1, "%s: failed to copy data to user buffer", __func__);
-        return -EFAULT;
-    }
-
-    vos_mem_copy(extra, (v_VOID_t*)genIeBytes, wrqu->data.length);
-    wrqu->data.length = length;
+    vos_mem_copy( wrqu->data.pointer, (v_VOID_t*)genIeBytes, wrqu->data.length);
 
     hddLog(LOG1,"%s: RSN IE of %d bytes returned\n", __func__, wrqu->data.length );
 
@@ -2465,7 +2377,7 @@
    }
 
   /* a value is being successfully returned */
-   return rc;
+   return 0;
 }
 
 
@@ -2481,7 +2393,7 @@
                        union iwreq_data *wrqu, char *extra)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-   char *cmd = extra;
+   char *cmd = (char*)wrqu->data.pointer;
    int len = wrqu->data.length;
    v_S7_t s7Rssi = 0;
    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
@@ -2528,7 +2440,7 @@
    }
 
    /* a value is being successfully returned */
-   return rc;
+   return 0;
 }
 
 /*
@@ -2738,23 +2650,13 @@
                        union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    char *cmd = NULL;
+    char *cmd = (char*)wrqu->data.pointer;
     int cmd_len = wrqu->data.length;
     int ret = 0;
-    int rc = 0;
-    VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
-
+    int status = 0;
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
     ENTER();
-    cmd = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == cmd)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
 
     if (ioctl_debug)
     {
@@ -2765,32 +2667,27 @@
            "%s: ***Received %s cmd from Wi-Fi GUI***", __func__, cmd);
 
     if (pHddCtx->isLogpInProgress) {
-        if (ioctl_debug)
-        {
-            pr_info("%s: RESTART in progress\n", __func__);
-        }
+       if (ioctl_debug)
+       {
+          pr_info("%s: RESTART in progress\n", __func__);
+       }
 
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-                  "%s:LOGP in Progress. Ignore!!!",__func__);
-        kfree(cmd);
-        return -EBUSY;
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                 "%s:LOGP in Progress. Ignore!!!",__func__);
+       return status;
     }
 
     if(strncmp(cmd, "CSCAN",5) == 0 )
     {
-        if (eHAL_STATUS_SUCCESS != iw_set_cscan(dev, info, wrqu, cmd)) {
-            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                      "%s: Error in iw_set_scan!", __func__);
-            rc = -EINVAL;
-        }
+       status = iw_set_cscan(dev, info, wrqu, extra);
     }
     else if( strcasecmp(cmd, "start") == 0 ) {
 
         hddLog(VOS_TRACE_LEVEL_INFO_HIGH, "Start command\n");
         /*Exit from Deep sleep or standby if we get the driver START cmd from android GUI*/
+        status = wlan_hdd_exit_lowpower(pHddCtx, pAdapter);
 
-        vos_status = wlan_hdd_exit_lowpower(pHddCtx, pAdapter);
-        if (vos_status == VOS_STATUS_SUCCESS)
+        if(status == VOS_STATUS_SUCCESS)
         {
             union iwreq_data wrqu;
             char buf[10];
@@ -2801,8 +2698,7 @@
         }
         else
         {
-            hddLog(VOS_TRACE_LEVEL_FATAL, "%s: START CMD Status %d", __func__, vos_status);
-            rc = -EIO;
+            hddLog(VOS_TRACE_LEVEL_FATAL, "%s: START CMD Status %d", __func__, status);
         }
         goto done;
     }
@@ -2817,6 +2713,7 @@
         memset(&wrqu, 0, sizeof(wrqu));
         wrqu.data.length = strlcpy(buf, "STOP", sizeof(buf));
         wireless_send_event(pAdapter->dev, IWEVCUSTOM, &wrqu, buf);
+        status = VOS_STATUS_SUCCESS;
         goto done;
     }
     else if (strcasecmp(cmd, "macaddr") == 0)
@@ -2840,18 +2737,17 @@
     }
     else if( strcasecmp(cmd, "linkspeed") == 0 )
     {
-        ret = iw_get_linkspeed(dev, info, wrqu, extra);
+        status = iw_get_linkspeed(dev, info, wrqu, extra);
     }
     else if( strncasecmp(cmd, "COUNTRY", 7) == 0 ) {
         char *country_code;
         long lrc;
-        eHalStatus eHal_status;
 
         country_code =  cmd + 8;
 
         init_completion(&pAdapter->change_country_code);
 
-        eHal_status = sme_ChangeCountryCode(pHddCtx->hHal,
+        status = (int)sme_ChangeCountryCode(pHddCtx->hHal,
                                             (void *)(tSmeChangeCountryCallback)wlan_hdd_change_country_code_callback,
                                             country_code,
                                             pAdapter,
@@ -2864,20 +2760,19 @@
         if (lrc <= 0)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"%s: SME %s while setting country code ",
-                   __func__, "Timed out");
+                 __func__, "Timed out");
         }
 
-        if (eHAL_STATUS_SUCCESS != eHal_status)
+        if( 0 != status )
         {
             VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                       "%s: SME Change Country code fail \n", __func__);
-            kfree(cmd);
-            return -EIO;
+                       "%s: SME Change Country code fail \n",__func__);
+            return VOS_STATUS_E_FAILURE;
         }
     }
     else if( strncasecmp(cmd, "rssi", 4) == 0 )
     {
-        ret = iw_get_rssi(dev, info, wrqu, extra);
+        status = iw_get_rssi(dev, info, wrqu, extra);
     }
     else if( strncasecmp(cmd, "powermode", 9) == 0 ) {
         int mode;
@@ -2948,23 +2843,20 @@
     else if( strncasecmp(cmd, "pno",3) == 0 ) {
 
         hddLog( VOS_TRACE_LEVEL_INFO, "pno\n");
-        vos_status = iw_set_pno(dev, info, wrqu, cmd, 3);
-        kfree(cmd);
-        return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+        status = iw_set_pno(dev, info, wrqu, extra, 3);
+        return status;
     }
     else if( strncasecmp(cmd, "rssifilter",10) == 0 ) {
 
         hddLog( VOS_TRACE_LEVEL_INFO, "rssifilter\n");
-        vos_status = iw_set_rssi_filter(dev, info, wrqu, cmd, 10);
-        kfree(cmd);
-        return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+        status = iw_set_rssi_filter(dev, info, wrqu, extra, 10);
+        return status;
     }
 #endif /*FEATURE_WLAN_SCAN_PNO*/
     else if( strncasecmp(cmd, "powerparams",11) == 0 ) {
       hddLog( VOS_TRACE_LEVEL_INFO, "powerparams\n");
-      vos_status = iw_set_power_params(dev, info, wrqu, cmd, 11);
-      kfree(cmd);
-      return (vos_status == VOS_STATUS_SUCCESS) ? 0 : -EINVAL;
+      status = iw_set_power_params(dev, info, wrqu, extra, 11);
+      return status;
     }
     else if( 0 == strncasecmp(cmd, "CONFIG-TX-TRACKING", 18) ) {
         tSirTxPerTrackingParam tTxPerTrackingParam;
@@ -2977,8 +2869,7 @@
         if (0 == tTxPerTrackingParam.ucTxPerTrackingPeriod)
         {
             VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Period input is not correct");
-            kfree(cmd);
-            return -EIO;
+            return VOS_STATUS_E_FAILURE;
         }
 
         // use default value 5 is the input is not reasonable. in unit of 10%
@@ -2995,12 +2886,9 @@
             tTxPerTrackingParam.uTxPerTrackingWatermark = TX_PER_TRACKING_DEFAULT_WATERMARK;
         }
 
-        if (eHAL_STATUS_SUCCESS !=
-            sme_SetTxPerTracking(pHddCtx->hHal,
-                                 hdd_tx_per_hit_cb,
-                                 (void*)pAdapter, &tTxPerTrackingParam)) {
-            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Set Tx PER Tracking Failed!");
-            rc = -EIO;
+        status = sme_SetTxPerTracking(pHddCtx->hHal, hdd_tx_per_hit_cb, (void*)pAdapter, &tTxPerTrackingParam);
+        if(status != eHAL_STATUS_SUCCESS){
+           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "Set Tx PER Tracking Failed!");
         }
     }
     else {
@@ -3014,27 +2902,16 @@
     if ((ret < 0) || (ret >= cmd_len))
     {
        /* there was an encoding error or overflow */
-       rc = -EINVAL;
-    }
-    else if (ret > 0)
-    {
-        if (copy_to_user(wrqu->data.pointer, cmd, ret))
-        {
-            hddLog(VOS_TRACE_LEVEL_ERROR,
-                   "%s: failed to copy data to user buffer", __func__);
-            kfree(cmd);
-            return -EFAULT;
-        }
-        wrqu->data.length = ret;
+       status = -EIO;
     }
 
     if (ioctl_debug)
     {
        pr_info("%s: rsp [%s] len [%d] status %d\n",
-               __func__, cmd, wrqu->data.length, rc);
+               __func__, cmd, wrqu->data.length, status);
     }
-    kfree(cmd);
-    return rc;
+    return status;
+
 }
 
 static int iw_set_nick(struct net_device *dev,
@@ -3981,19 +3858,14 @@
     VOS_STATUS vstatus;
     int sub_cmd = wrqu->data.flags;
     int ret = 0; /* success */
-    char *pBuffer = NULL;
     hdd_adapter_t *pAdapter = (netdev_priv(dev));
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 #ifdef WLAN_FEATURE_VOWIFI
     hdd_config_t  *pConfig = pHddCtx->cfg_ini;
 #endif /* WLAN_FEATURE_VOWIFI */
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "%s: Received length %d", __func__, wrqu->data.length);
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
@@ -4002,30 +3874,15 @@
         return -EBUSY;
     }
 
-    /* ODD number is used for set, copy data using copy_from_user */
-    pBuffer = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                              wrqu->data.length);
-    if (NULL == pBuffer)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "%s: Received length %d", __func__, wrqu->data.length);
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "%s: Received data %s", __func__, pBuffer);
-
     switch(sub_cmd)
     {
        case WE_WOWL_ADD_PTRN:
           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "ADD_PTRN\n");
-          hdd_add_wowl_ptrn(pAdapter, pBuffer);
+          hdd_add_wowl_ptrn(pAdapter, (char*)wrqu->data.pointer);
           break;
        case WE_WOWL_DEL_PTRN:
           VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "DEL_PTRN\n");
-          hdd_del_wowl_ptrn(pAdapter, pBuffer);
+          hdd_del_wowl_ptrn(pAdapter, (char*)wrqu->data.pointer);
           break;
 #if defined WLAN_FEATURE_VOWIFI
        case WE_NEIGHBOR_REPORT_REQUEST:
@@ -4040,7 +3897,7 @@
                 if( !neighborReq.no_ssid )
                 {
                    neighborReq.ssid.length = (wrqu->data.length - 1) > 32 ? 32 : (wrqu->data.length - 1) ;
-                   vos_mem_copy( neighborReq.ssid.ssId, pBuffer, neighborReq.ssid.length );
+                   vos_mem_copy( neighborReq.ssid.ssId, wrqu->data.pointer, neighborReq.ssid.length );
                 }
 
                 callbackInfo.neighborRspCallback = NULL;
@@ -4061,7 +3918,7 @@
           sme_updateP2pIe( WLAN_HDD_GET_HAL_CTX(pAdapter), wrqu->data.pointer, wrqu->data.length );
           break;
        case WE_SET_CONFIG:
-          vstatus = hdd_execute_config_command(pHddCtx, pBuffer);
+          vstatus = hdd_execute_config_command(pHddCtx, wrqu->data.pointer);
           if (VOS_STATUS_SUCCESS != vstatus)
           {
              ret = -EINVAL;
@@ -4074,7 +3931,6 @@
            break;
        }
     }
-    kfree(pBuffer);
     return ret;
 }
 
@@ -4186,13 +4042,6 @@
     int sub_cmd = value[0];
     int ret = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
@@ -4644,6 +4493,7 @@
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
     tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
     int sub_cmd = wrqu->data.flags;
+    int *value = (int*)wrqu->data.pointer;
     int apps_args[MAX_VAR_ARGS] = {0};
     int num_args = wrqu->data.length;
     hdd_station_ctx_t *pStaCtx = NULL ;
@@ -4651,13 +4501,6 @@
     int cmd = 0;
     int staId = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
     hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -4671,14 +4514,7 @@
     {
        num_args = MAX_VAR_ARGS;
     }
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    if (copy_from_user(apps_args, wrqu->data.pointer, (sizeof(int)) * num_args))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: failed to copy data to user buffer", __func__);
-        return -EFAULT;
-    }
+    vos_mem_copy(apps_args, value, (sizeof(int)) * num_args);
 
     if(( sub_cmd == WE_MCC_CONFIG_CREDENTIAL ) ||
         (sub_cmd == WE_MCC_CONFIG_PARAMS ))
@@ -4998,6 +4834,287 @@
    return 0;
 }
 
+
+#ifdef FEATURE_WLAN_WAPI
+static int iw_qcom_set_wapi_mode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    hdd_wext_state_t *pWextState = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
+    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+    tCsrRoamProfile *pRoamProfile = &pWextState->roamProfile;
+
+    WAPI_FUNCTION_MODE *pWapiMode = (WAPI_FUNCTION_MODE *)wrqu->data.pointer;
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_mode called");
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Input Data (wreq) WAPI Mode:%02d", __func__, pWapiMode->wapiMode);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+    if(WZC_ORIGINAL == pWapiMode->wapiMode) {
+        hddLog(LOG1, "%s: WAPI Mode Set to OFF", __func__);
+         /* Set Encryption mode to defualt , this allows next successfull non-WAPI Association */
+        pRoamProfile->EncryptionType.numEntries = 1;
+        pRoamProfile->EncryptionType.encryptionType[0] = eCSR_ENCRYPT_TYPE_NONE;
+        pRoamProfile->mcEncryptionType.numEntries = 1;
+        pRoamProfile->mcEncryptionType.encryptionType[0] = eCSR_ENCRYPT_TYPE_NONE;
+
+        pRoamProfile->AuthType.numEntries = 1;
+        pHddStaCtx->conn_info.authType = eCSR_AUTH_TYPE_OPEN_SYSTEM;
+        pRoamProfile->AuthType.authType[0] = pHddStaCtx->conn_info.authType;
+    }
+    else if(WAPI_EXTENTION == pWapiMode->wapiMode) {
+        hddLog(LOG1, "%s: WAPI Mode Set to ON", __func__);
+    }
+    else
+         return -EINVAL;
+
+    pAdapter->wapi_info.nWapiMode = pWapiMode->wapiMode;
+
+    return 0;
+}
+
+static int iw_qcom_get_wapi_mode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    WAPI_FUNCTION_MODE *pWapiMode = (WAPI_FUNCTION_MODE *)(extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+    hddLog(LOG1, "The function iw_qcom_get_wapi_mode called");
+
+    pWapiMode->wapiMode = pAdapter->wapi_info.nWapiMode;
+    hddLog(LOG1, "%s: GET WAPI Mode Value:%02d", __func__, pWapiMode->wapiMode);
+    printk("\nGET WAPI MODE:%d",pWapiMode->wapiMode);
+    return 0;
+}
+
+static int iw_qcom_set_wapi_assoc_info(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+//    WAPI_AssocInfo *pWapiAssocInfo = (WAPI_AssocInfo *)(wrqu->data.pointer);
+    WAPI_AssocInfo *pWapiAssocInfo = (WAPI_AssocInfo *)(extra);
+    int i = 0, j = 0;
+    hddLog(LOG1, "The function iw_qcom_set_wapi_assoc_info called");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+    VOS_ASSERT(pWapiAssocInfo);
+
+    hddLog(LOG1, "%s: INPUT DATA:\nElement ID:0x%02x Length:0x%02x Version:0x%04x\n",__func__,pWapiAssocInfo->elementID,pWapiAssocInfo->length,pWapiAssocInfo->version);
+    hddLog(LOG1,"%s: akm Suite Cnt:0x%04x",__func__,pWapiAssocInfo->akmSuiteCount);
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"akm suite[%02d]:0x%08lx",i,pWapiAssocInfo->akmSuite[i]);
+
+    hddLog(LOG1,"%s: Unicast Suite Cnt:0x%04x",__func__,pWapiAssocInfo->unicastSuiteCount);
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1, "Unicast suite[%02d]:0x%08lx",i,pWapiAssocInfo->unicastSuite[i]);
+
+    hddLog(LOG1,"%s: Multicast suite:0x%08lx Wapi capa:0x%04x",__func__,pWapiAssocInfo->multicastSuite,pWapiAssocInfo->wapiCability);
+    hddLog(LOG1, "%s: BKID Cnt:0x%04x\n",__func__,pWapiAssocInfo->bkidCount);
+    for(i = 0 ; i < 16 ; i++) {
+        hddLog(LOG1, "BKID List[%02d].bkid:0x",i);
+        for(j = 0 ; j < 16 ; j++)
+            hddLog(LOG1,"%02x",pWapiAssocInfo->bkidList[i].bkid[j]);
+    }
+
+    /* We are not using the entire IE as provided by the supplicant.
+     * This is being calculated by SME. This is the same as in the
+     * case of WPA. Only the auth mode information needs to be
+     * extracted here*/
+    if ( pWapiAssocInfo->akmSuite[0] == WAPI_PSK_AKM_SUITE ) {
+       hddLog(LOG1, "%s: WAPI AUTH MODE SET TO PSK",__func__);
+       pAdapter->wapi_info.wapiAuthMode = WAPI_AUTH_MODE_PSK;
+    }
+
+    if ( pWapiAssocInfo->akmSuite[0] == WAPI_CERT_AKM_SUITE) {
+       hddLog(LOG1, "%s: WAPI AUTH MODE SET TO CERTIFICATE",__func__);
+       pAdapter->wapi_info.wapiAuthMode = WAPI_AUTH_MODE_CERT;
+    }
+    return 0;
+}
+
+static int iw_qcom_set_wapi_key(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+    eHalStatus       halStatus   = eHAL_STATUS_SUCCESS;
+    tANI_U32         roamId      = 0xFF;
+    tANI_U8         *pKeyPtr     = NULL;
+    v_BOOL_t         isConnected = TRUE;
+    tCsrRoamSetKey   setKey;
+    int i = 0;
+    WLAN_WAPI_KEY *pWapiKey = (WLAN_WAPI_KEY *)(extra);
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_key called ");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    hddLog(LOG1,":%s: INPUT DATA:\nKey Type:0x%02x Key Direction:0x%02x KEY ID:0x%02x\n", __func__, pWapiKey->keyType, pWapiKey->keyDirection, pWapiKey->keyId);
+    hddLog(LOG1,"Add Index:0x");
+    for(i =0 ; i < 12 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->addrIndex[i]);
+
+    hddLog(LOG1,"\n%s: WAPI ENCRYPTION KEY LENGTH:0x%04x", __func__,pWapiKey->wpiekLen);
+    hddLog(LOG1, "WAPI ENCRYPTION KEY:0x");
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->wpiek[i]);
+
+    hddLog(LOG1,"\n%s: WAPI INTEGRITY CHECK KEY LENGTH:0x%04x", __func__,pWapiKey->wpickLen);
+    hddLog(LOG1,"WAPI INTEGRITY CHECK KEY:0x");
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->wpick[i]);
+
+    hddLog(LOG1,"\nWAPI PN NUMBER:0x");
+    for(i = 0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pWapiKey->pn[i]);
+
+    // Clear the setkey memory
+    vos_mem_zero(&setKey,sizeof(tCsrRoamSetKey));
+    // Store Key ID
+    setKey.keyId = (unsigned char)( pWapiKey->keyId );
+    // SET WAPI Encryption
+    setKey.encType  = eCSR_ENCRYPT_TYPE_WPI;
+    // Key Directionn both TX and RX
+    setKey.keyDirection = eSIR_TX_RX; // Do WE NEED to update this based on Key Type as GRP/UNICAST??
+    // the PAE role
+    setKey.paeRole = 0 ;
+
+    switch ( pWapiKey->keyType )
+    {
+        case PAIRWISE_KEY:
+        {
+            isConnected = hdd_connIsConnected(pHddStaCtx);
+            vos_mem_copy(setKey.peerMac,&pHddStaCtx->conn_info.bssId,WNI_CFG_BSSID_LEN);
+            break;
+        }
+        case GROUP_KEY:
+        {
+            vos_set_macaddr_broadcast( (v_MACADDR_t *)setKey.peerMac );
+            break;
+        }
+        default:
+        {
+            //Any other option is invalid.
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "[%4d] %s() failed to Set Key. Invalid key type %d", __LINE__,__func__ , -1 );
+
+            hddLog(LOGE," %s: Error WAPI Key Add Type",__func__);
+            halStatus = !eHAL_STATUS_SUCCESS; // NEED TO UPDATE THIS WITH CORRECT VALUE
+            break; // NEED RETURN FROM HERE ????
+        }
+    }
+
+    // Concatenating the Encryption Key (EK) and the MIC key (CK): EK followed by CK
+    setKey.keyLength = (v_U16_t)((pWapiKey->wpiekLen)+(pWapiKey->wpickLen));
+    pKeyPtr = setKey.Key;
+    memcpy( pKeyPtr, pWapiKey->wpiek, pWapiKey->wpiekLen );
+    pKeyPtr += pWapiKey->wpiekLen;
+    memcpy( pKeyPtr, pWapiKey->wpick, pWapiKey->wpickLen );
+
+    // Set the new key with SME.
+    pHddStaCtx->roam_info.roamingState = HDD_ROAM_STATE_SETTING_KEY;
+
+    if ( isConnected ) {
+        halStatus = sme_RoamSetKey( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, &setKey, &roamId );
+        if ( halStatus != eHAL_STATUS_SUCCESS )
+        {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "[%4d] sme_RoamSetKey returned ERROR status= %d", __LINE__, halStatus );
+
+            pHddStaCtx->roam_info.roamingState = HDD_ROAM_STATE_NONE;
+        }
+    }
+#if 0 /// NEED TO CHECK ON THIS
+    else
+    {
+        // Store the keys in the adapter to be moved to the profile & passed to
+        // SME in the ConnectRequest if we are not yet in connected state.
+         memcpy( &pAdapter->setKey[ setKey.keyId ], &setKey, sizeof( setKey ) );
+         pAdapter->fKeySet[ setKey.keyId ] = TRUE;
+
+         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_MED,
+                    "  Saving key [idx= %d] to apply when moving to connected state ",
+                    setKey.keyId );
+
+    }
+#endif
+    return halStatus;
+}
+
+static int iw_qcom_set_wapi_bkid(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+#ifdef WLAN_DEBUG
+    int i = 0;
+    WLAN_BKID_LIST  *pBkid       = ( WLAN_BKID_LIST *) (wrqu->data.pointer);
+#endif
+
+    hddLog(LOG1, "The function iw_qcom_set_wapi_bkid called");
+    hddLog(LOG1, "%s: Received length %d", __func__, wrqu->data.length);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)wrqu->data.pointer);
+    hddLog(LOG1, "%s: Received data %s", __func__, (char*)extra);
+
+    hddLog(LOG1,"%s: INPUT DATA:\n BKID Length:0x%08lx\n", __func__,pBkid->length);
+    hddLog(LOG1,"%s: BKID Cnt:0x%04lx",pBkid->BKIDCount);
+
+    hddLog(LOG1,"BKID KEY LIST[0]:0x");
+
+    if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
+    {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                                  "%s:LOGP in Progress. Ignore!!!", __func__);
+       return -EBUSY;
+    }
+
+#ifdef WLAN_DEBUG
+    for(i =0 ; i < 16 ; i++)
+        hddLog(LOG1,"%02x",pBkid->BKID[0].bkid[i]);
+#endif
+
+    return 0;
+}
+
+static int iw_qcom_get_wapi_bkid(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    /* Yet to implement this function, 19th April 2010 */
+    hddLog(LOG1, "The function iw_qcom_get_wapi_bkid called ");
+
+    return 0;
+}
+#endif /* FEATURE_WLAN_WAPI */
+
 #ifdef WLAN_FEATURE_VOWIFI_11R
 //
 //
@@ -5042,7 +5159,7 @@
 #endif
 
     // Pass the received FT IEs to SME
-    sme_SetFTIEs( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, extra,
+    sme_SetFTIEs( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, wrqu->data.pointer,
         wrqu->data.length);
 
     return 0;
@@ -5054,7 +5171,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpRcvFltMcAddrList pRequest = (tpRcvFltMcAddrList)extra;
+    tpRcvFltMcAddrList pRequest = (tpRcvFltMcAddrList)wrqu->data.pointer;
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
     tpSirWlanSetRxpFilters wlanRxpFilterParam;
     tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
@@ -5168,13 +5285,6 @@
     tpSirWlanSetRxpFilters wlanRxpFilterParam;
     hddLog(VOS_TRACE_LEVEL_INFO_HIGH, "%s: ", __func__);
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-		FL("permission check failed"));
-      return -EPERM;
-    }
-
     //Reset the filter to INI value as we have to clear the dynamic filter
     pHddCtx->configuredMcastBcastFilter = pHddCtx->cfg_ini->mcastBcastFilterSetting;
 
@@ -5215,7 +5325,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpHostOffloadRequest pRequest = (tpHostOffloadRequest)extra;
+    tpHostOffloadRequest pRequest = (tpHostOffloadRequest)wrqu->data.pointer;
     tSirHostOffloadReq offloadRequest;
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -5287,7 +5397,7 @@
         union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpKeepAliveRequest pRequest = (tpKeepAliveRequest)extra;
+    tpKeepAliveRequest pRequest = (tpKeepAliveRequest)wrqu->data.pointer;
     tSirKeepAliveReq keepaliveRequest;
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -5401,9 +5511,6 @@
 
                 hddLog(VOS_TRACE_LEVEL_INFO, "Data Offset %d Data Len %d\n",
                         pRequest->paramsData[i].dataOffset, pRequest->paramsData[i].dataLength);
-                if ((sizeof(packetFilterSetReq.paramsData[i].compareData)) <
-                           (pRequest->paramsData[i].dataLength))
-                    return -EINVAL;
 
                 memcpy(&packetFilterSetReq.paramsData[i].compareData,
                         pRequest->paramsData[i].compareData, pRequest->paramsData[i].dataLength);
@@ -5636,112 +5743,47 @@
 
 void wlan_hdd_set_mc_addr_list(hdd_adapter_t *pAdapter, v_U8_t set)
 {
+    v_U8_t filterAction;
+    tPacketFilterCfg request;
     v_U8_t i;
-    tpSirRcvFltMcAddrList pMulticastAddrs = NULL;
-    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
-    hdd_context_t* pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
-    if (NULL == hHal)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HAL Handle is NULL"));
-        return;
-    }
-    if (NULL == pHddCtx)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD CTX is NULL"));
-        return;
-    }
+    filterAction = set ? HDD_RCV_FILTER_SET : HDD_RCV_FILTER_CLEAR;
 
-    /* Check if INI is enabled or not, other wise just return
-     */
-    if (pHddCtx->cfg_ini->fEnableMCAddrList)
+    /*set mulitcast addr list*/
+    for (i = 0; i < pAdapter->mc_addr_list.mc_cnt; i++)
     {
-        pMulticastAddrs = vos_mem_malloc(sizeof(tSirRcvFltMcAddrList));
-        if (NULL == pMulticastAddrs)
-        {
-            hddLog(VOS_TRACE_LEVEL_ERROR, FL("Could not allocate Memory"));
-            return;
-        }
-
+        memset(&request, 0, sizeof (tPacketFilterCfg));
+        request.filterAction = filterAction;
+        request.filterId = i; 
         if (set)
         {
-            /* Following pre-conditions should be satisfied before wei
-             * configure the MC address list.
-             */
-            if (((pAdapter->device_mode == WLAN_HDD_INFRA_STATION) ||
-               (pAdapter->device_mode == WLAN_HDD_P2P_CLIENT))
-               && pAdapter->mc_addr_list.mc_cnt
-               && (eConnectionState_Associated ==
-               (WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.connState))
-            {
-                pMulticastAddrs->ulMulticastAddrCnt =
-                                 pAdapter->mc_addr_list.mc_cnt;
-                for (i = 0; i < pAdapter->mc_addr_list.mc_cnt; i++)
-                {
-                    memcpy(&(pMulticastAddrs->multicastAddr[i][0]),
-                            &(pAdapter->mc_addr_list.addr[i][0]),
-                            sizeof(pAdapter->mc_addr_list.addr[i]));
-                    hddLog(VOS_TRACE_LEVEL_INFO,
-                            "%s: %s multicast filter: addr ="
-                            MAC_ADDRESS_STR,
-                            __func__, set ? "setting" : "clearing",
-                            MAC_ADDR_ARRAY(pMulticastAddrs->multicastAddr[i]));
-                }
-                /* Set multicast filter */
-                sme_8023MulticastList(hHal, pAdapter->sessionId,
-                                      pMulticastAddrs);
-            }
-        }
-        else
-        {
-            /* Need to clear only if it was previously configured
-             */
-            if (pAdapter->mc_addr_list.isFilterApplied)
-            {
-                pMulticastAddrs->ulMulticastAddrCnt = 0;
-                sme_8023MulticastList(hHal, pAdapter->sessionId,
-                                      pMulticastAddrs);
-            }
-
+            request.numParams = 1; 
+            request.paramsData[0].protocolLayer = HDD_FILTER_PROTO_TYPE_MAC; 
+            request.paramsData[0].cmpFlag = HDD_FILTER_CMP_TYPE_EQUAL;   
+            request.paramsData[0].dataOffset = WLAN_HDD_80211_FRM_DA_OFFSET;
+            request.paramsData[0].dataLength = ETH_ALEN;
+            memcpy(&(request.paramsData[0].compareData[0]), 
+                    &(pAdapter->mc_addr_list.addr[i][0]), ETH_ALEN);
+            /*set mulitcast filters*/
+            hddLog(VOS_TRACE_LEVEL_INFO, 
+                    "%s: %s multicast filter: addr =" 
+                    MAC_ADDRESS_STR,
+                    __func__, set ? "setting" : "clearing", 
+                    MAC_ADDR_ARRAY(request.paramsData[0].compareData));
         }
-        pAdapter->mc_addr_list.isFilterApplied = set ? TRUE : FALSE;
-    }
-    else
-    {
-        hddLog(VOS_TRACE_LEVEL_INFO,
-                FL("fEnableMCAddrList is not enabled in INI"));
+        wlan_hdd_set_filter(pHddCtx, &request, pAdapter->sessionId);
     }
-    return;
+    pAdapter->mc_addr_list.isFilterApplied = set ? TRUE : FALSE;
 }
 
 static int iw_set_packet_filter_params(struct net_device *dev, struct iw_request_info *info,
         union iwreq_data *wrqu, char *extra)
-{
+{   
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tpPacketFilterCfg pRequest = NULL;
-    int ret;
-
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    pRequest = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                               wrqu->data.length);
-    if (NULL == pRequest)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
+    tpPacketFilterCfg pRequest = (tpPacketFilterCfg)wrqu->data.pointer;
 
-    ret = wlan_hdd_set_filter(WLAN_HDD_GET_CTX(pAdapter), pRequest, pAdapter->sessionId);
-    kfree(pRequest);
-
-    return ret;
+    return wlan_hdd_set_filter(WLAN_HDD_GET_CTX(pAdapter), pRequest, pAdapter->sessionId);
 }
 #endif
 static int iw_get_statistics(struct net_device *dev,
@@ -5972,7 +6014,7 @@
   VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
             "PNO data len %d data %s",
             wrqu->data.length,
-            extra);
+            (char *)wrqu->data.pointer);
 
   if (wrqu->data.length <= nOffset )
   {
@@ -6010,7 +6052,7 @@
 
     scan every 5 seconds 2 times, scan every 300 seconds until stopped
   -----------------------------------------------------------------------*/
-  ptr = extra + nOffset;
+  ptr = (char*)(wrqu->data.pointer + nOffset);
 
   sscanf(ptr,"%hhu%n", &(pnoRequest.enable), &nOffset);
 
@@ -6221,7 +6263,7 @@
     v_U8_t rssiThreshold = 0;
     v_U8_t nRead;
 
-    nRead = sscanf(extra + nOffset,"%hhu",
+    nRead = sscanf(wrqu->data.pointer + nOffset,"%hhu",
            &rssiThreshold);
 
     if ( 1 != nRead )
@@ -6382,17 +6424,10 @@
                            union iwreq_data *wrqu, char *extra)
 {
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
-    tANI_U8 *ptr = NULL;
+    tANI_U8 *ptr = (tANI_U8*)wrqu->data.pointer;
     int ret = 0;
 
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s: ", __func__);
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s: ", __func__);
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
     {
@@ -6401,56 +6436,23 @@
         return -EBUSY;
     }
 
-    /* ODD number is used for set, copy data using copy_from_user */
-    ptr = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
     if (memcmp(ptr, "SETBAND ", 8) == 0)
     {
         /* Change band request received */
         ret = hdd_setBand_helper(dev, ptr);
-    }
-    kfree(ptr);
+        return ret;
 
-    return ret;
+    }
+    return 0;
 }
 
 static int iw_set_power_params_priv(struct net_device *dev,
                            struct iw_request_info *info,
                            union iwreq_data *wrqu, char *extra)
 {
-    int ret;
-    char *ptr;
-
-    if (!capable(CAP_NET_ADMIN))
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  FL("permission check failed"));
-        return -EPERM;
-    }
-
-    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-              "Set power params Private");
-
-    /* ODD number is used for set, copy data using copy_from_user */
-    ptr = mem_alloc_copy_from_user_helper(wrqu->data.pointer,
-                                          wrqu->data.length);
-    if (NULL == ptr)
-    {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "mem_alloc_copy_from_user_helper fail");
-        return -ENOMEM;
-    }
-
-    ret = iw_set_power_params(dev, info, wrqu, ptr, 0);
-    kfree(ptr);
-    return ret;
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                "Set power params Private");
+  return iw_set_power_params(dev,info,wrqu,extra,0);
 }
 
 
@@ -6664,6 +6666,14 @@
    [WLAN_PRIV_GET_OEM_DATA_RSP - SIOCIWFIRSTPRIV] = iw_get_oem_data_rsp, //oem data req Specifc
 #endif
 
+#ifdef FEATURE_WLAN_WAPI
+   [WLAN_PRIV_SET_WAPI_MODE             - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_mode,
+   [WLAN_PRIV_GET_WAPI_MODE             - SIOCIWFIRSTPRIV]  = iw_qcom_get_wapi_mode,
+   [WLAN_PRIV_SET_WAPI_ASSOC_INFO       - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_assoc_info,
+   [WLAN_PRIV_SET_WAPI_KEY              - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_key,
+   [WLAN_PRIV_SET_WAPI_BKID             - SIOCIWFIRSTPRIV]  = iw_qcom_set_wapi_bkid,
+   [WLAN_PRIV_GET_WAPI_BKID             - SIOCIWFIRSTPRIV]  = iw_qcom_get_wapi_bkid,
+#endif /* FEATURE_WLAN_WAPI */
 #ifdef WLAN_FEATURE_VOWIFI_11R
    [WLAN_PRIV_SET_FTIES                 - SIOCIWFIRSTPRIV]   = iw_set_fties,
 #endif
@@ -7012,6 +7022,44 @@
         "get_oem_data_rsp" },
 #endif
 
+#ifdef FEATURE_WLAN_WAPI
+   /* handlers for main ioctl SET_WAPI_MODE */
+    {   WLAN_PRIV_SET_WAPI_MODE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "SET_WAPI_MODE" },
+
+   /* handlers for main ioctl GET_WAPI_MODE */
+    {   WLAN_PRIV_GET_WAPI_MODE,
+        0,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "GET_WAPI_MODE" },
+
+   /* handlers for main ioctl SET_ASSOC_INFO */
+    {   WLAN_PRIV_SET_WAPI_ASSOC_INFO,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 400,
+        0,
+        "SET_WAPI_ASSOC" },
+
+   /* handlers for main ioctl SET_WAPI_KEY */
+    {   WLAN_PRIV_SET_WAPI_KEY,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 71,
+        0,
+        "SET_WAPI_KEY" },
+
+   /* handlers for main ioctl SET_WAPI_BKID */
+    {   WLAN_PRIV_SET_WAPI_BKID,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 24,
+        0,
+        "SET_WAPI_BKID" },
+
+   /* handlers for main ioctl GET_WAPI_BKID */
+    {   WLAN_PRIV_GET_WAPI_BKID,
+        0,
+        IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 24,
+        "GET_WAPI_BKID" },
+#endif /* FEATURE_WLAN_WAPI */
+
     /* handlers for main ioctl - host offload */
     {
         WLAN_PRIV_SET_HOST_OFFLOAD,
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/HDD/src/wlan_hdd_wmm.c	2014-12-03 11:07:31.000000000 +0000
@@ -81,7 +81,6 @@
 #include <linux/semaphore.h>
 #include <wlan_hdd_hostapd.h>
 #include <wlan_hdd_softap_tx_rx.h>
-#include <vos_sched.h>
 
 // change logging behavior based upon debug flag
 #ifdef HDD_WMM_DEBUG
@@ -1814,14 +1813,6 @@
 
    hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);
 
-   if (isWDresetInProgress())
-   {
-       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
-                  FL("called during WDReset"));
-       skb->priority = SME_QOS_WMM_UP_BE;
-       return HDD_LINUX_AC_BE;
-   }
-
    // if we don't want QoS or the AP doesn't support Qos
    // All traffic will get equal opportuniy to transmit data frames.
    if( hdd_wmm_is_active(pAdapter) ) {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/qwlan_version.h	2014-12-03 11:07:31.000000000 +0000
@@ -60,9 +60,9 @@
 #define QWLAN_VERSION_MINOR            2
 #define QWLAN_VERSION_PATCH            3
 #define QWLAN_VERSION_EXTRA            ""
-#define QWLAN_VERSION_BUILD            23
+#define QWLAN_VERSION_BUILD            13
 
-#define QWLAN_VERSIONSTR              "3.2.3.23"
+#define QWLAN_VERSIONSTR              "3.2.3.13"
 
 #endif /* QWLAN_VERSION_H */
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgAp.h	2014-12-03 11:07:31.000000000 +0000
@@ -360,8 +360,6 @@
 #define WNI_CFG_ENABLE_MCC_ADAPTIVE_SCHED    295
 #define WNI_CFG_DISABLE_LDPC_WITH_TXBF_AP    296
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT    297
-#define WNI_CFG_RA_FILTER_ENABLE    298
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL    299
 
 /*
  * String parameter lengths 
@@ -2488,26 +2486,10 @@
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_APMAX    255
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_APDEF    3
 
-#define WNI_CFG_RA_FILTER_ENABLE_STAMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_STAMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_STADEF    1
-
-#define WNI_CFG_RA_FILTER_ENABLE_APMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_APMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_APDEF    1
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STADEF    60
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_APDEF    60
-
-#define CFG_PARAM_MAX_NUM         300
-#define CFG_AP_IBUF_MAX_SIZE      239
+#define CFG_PARAM_MAX_NUM         298
+#define CFG_AP_IBUF_MAX_SIZE      237
 #define CFG_AP_SBUF_MAX_SIZE      3422
-#define CFG_STA_IBUF_MAX_SIZE     234
+#define CFG_STA_IBUF_MAX_SIZE     232
 #define CFG_STA_SBUF_MAX_SIZE     3388
 #define CFG_SEM_MAX_NUM           19
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/inc/wniCfgSta.h	2014-12-03 11:07:31.000000000 +0000
@@ -354,8 +354,6 @@
 #define WNI_CFG_ENABLE_MCC_ADAPTIVE_SCHED    295
 #define WNI_CFG_DISABLE_LDPC_WITH_TXBF_AP    296
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT    297
-#define WNI_CFG_RA_FILTER_ENABLE    298
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL    299
 
 /*
  * String parameter lengths 
@@ -1617,16 +1615,8 @@
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_STAMAX    255
 #define WNI_CFG_AP_LINK_MONITOR_TIMEOUT_STADEF    3
 
-#define WNI_CFG_RA_FILTER_ENABLE_STAMIN    0
-#define WNI_CFG_RA_FILTER_ENABLE_STAMAX    1
-#define WNI_CFG_RA_FILTER_ENABLE_STADEF    1
-
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMIN    0
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STAMAX    60
-#define WNI_CFG_RA_RATE_LIMIT_INTERVAL_STADEF    60
-
-#define CFG_PARAM_MAX_NUM        300
-#define CFG_STA_IBUF_MAX_SIZE    234
+#define CFG_PARAM_MAX_NUM        298
+#define CFG_STA_IBUF_MAX_SIZE    232
 #define CFG_STA_SBUF_MAX_SIZE    3388
 #define CFG_SEM_MAX_NUM          19
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgParamName.c	2014-12-03 11:07:31.000000000 +0000
@@ -350,8 +350,6 @@
     (unsigned char *)"ENABLE_MCC_ADAPTIVE_SCHED",
     (unsigned char *)"DISABLE_LDPC_WITH_TXBF_AP",
     (unsigned char *)"AP_LINK_MONITOR_TIMEOUT",
-    (unsigned char *)"RA_FILTER_ENABLE",
-    (unsigned char *)"RA_RATE_LIMIT_INTERVAL",
 };
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/cfg/cfgUtil/cfg.txt	2014-12-03 11:07:31.000000000 +0000
@@ -1,4 +1,4 @@
- *
+/*
  * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
@@ -17,7 +17,7 @@
  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
- *
+ */
 * Copyright (c) 2012, The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
@@ -4498,27 +4498,3 @@
 V    RW    NP
 HAL
 1    255    3
-
-* RA filter enable/disable
-*
-WNI_CFG_RA_FILTER_ENABLE    I    4    7
-V    RW    NP
-HAL
-0    1     1
-V    RW    NP
-HAL
-0    1     1
-*
-*
-
-* RA filter rate interval
-*
-WNI_CFG_RA_RATE_LIMIT_INTERVAL    I    4    7
-V    RW    NP
-HAL
-0    60     60
-V    RW     NP
-HAL
-0    60     60
-*
-*
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/include/sirParams.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/include/sirParams.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/include/sirParams.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/include/sirParams.h	2014-12-03 11:07:31.000000000 +0000
@@ -97,7 +97,6 @@
 #ifdef WLAN_FEATURE_ROAM_SCAN_OFFLOAD
    WLAN_ROAM_SCAN_OFFLOAD = 23,
 #endif
-   EXTENDED_NSOFFLOAD_SLOT = 24,
    //MAX_FEATURE_SUPPORTED = 128
 } placeHolderInCapBitmap;
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limProcessBeaconFrame.c	2014-12-03 11:07:31.000000000 +0000
@@ -157,9 +157,14 @@
         if ((pMac->lim.gLimMlmState  == eLIM_MLM_WT_PROBE_RESP_STATE) ||
             (pMac->lim.gLimMlmState  == eLIM_MLM_PASSIVE_SCAN_STATE))
         {
-            limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo,
-                   ((pMac->lim.gLimHalScanState == eLIM_HAL_SCANNING_STATE) ? eANI_BOOLEAN_TRUE : eANI_BOOLEAN_FALSE),
-                   eANI_BOOLEAN_FALSE);
+            //If we are scanning for P2P, only accept probe rsp
+            if((pMac->lim.gLimHalScanState != eLIM_HAL_SCANNING_STATE) || (NULL == pMac->lim.gpLimMlmScanReq) 
+               || !pMac->lim.gpLimMlmScanReq->p2pSearch )
+            {
+                limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo, 
+                       ((pMac->lim.gLimHalScanState == eLIM_HAL_SCANNING_STATE) ? eANI_BOOLEAN_TRUE : eANI_BOOLEAN_FALSE), 
+                       eANI_BOOLEAN_FALSE);
+            }
         }
         else if (pMac->lim.gLimMlmState == eLIM_MLM_LEARN_STATE)
         {
@@ -276,8 +281,12 @@
         if ( (pMac->lim.gLimMlmState == eLIM_MLM_WT_PROBE_RESP_STATE) ||
              (pMac->lim.gLimMlmState == eLIM_MLM_PASSIVE_SCAN_STATE) )
         {
-            limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo,
-                                         eANI_BOOLEAN_TRUE, eANI_BOOLEAN_FALSE);
+            //If we are scanning for P2P, only accept probe rsp
+            if((pMac->lim.gLimHalScanState != eLIM_HAL_SCANNING_STATE) || (NULL == pMac->lim.gpLimMlmScanReq) 
+               || !pMac->lim.gpLimMlmScanReq->p2pSearch )
+            {
+                limCheckAndAddBssDescription(pMac, pBeacon, pRxPacketInfo, eANI_BOOLEAN_TRUE, eANI_BOOLEAN_FALSE);
+            }
         }
         else if (pMac->lim.gLimMlmState == eLIM_MLM_LEARN_STATE)
         {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.c	2014-12-03 11:07:31.000000000 +0000
@@ -139,14 +139,14 @@
  * @return None
  */
 #if defined WLAN_FEATURE_VOWIFI
-eHalStatus
+void
 limCollectBssDescription(tpAniSirGlobal pMac,
                          tSirBssDescription *pBssDescr,
                          tpSirProbeRespBeacon pBPR,
                          tANI_U8  *pRxPacketInfo,
                          tANI_U8  fScanning)
 #else
-eHalStatus
+void
 limCollectBssDescription(tpAniSirGlobal pMac,
                          tSirBssDescription *pBssDescr,
                          tpSirProbeRespBeacon pBPR,
@@ -165,17 +165,6 @@
     rxChannel = WDA_GET_RX_CH(pRxPacketInfo);
     pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);
 
-    /**
-     * Drop all the beacons and probe response without P2P IE during P2P search
-     */
-    if (NULL != pMac->lim.gpLimMlmScanReq && pMac->lim.gpLimMlmScanReq->p2pSearch)
-    {
-        if (NULL == limGetP2pIEPtr(pMac, (pBody + SIR_MAC_B_PR_SSID_OFFSET), ieLen))
-        {
-            limLog( pMac, LOG3, MAC_ADDRESS_STR, MAC_ADDR_ARRAY(pHdr->bssId));
-            return eHAL_STATUS_FAILURE;
-        }
-    }
 
     /**
      * Length of BSS desription is without length of
@@ -294,7 +283,7 @@
         pBssDescr->aniIndicator,
         ieLen );
 
-    return eHAL_STATUS_SUCCESS;
+    return;
 } /*** end limCollectBssDescription() ***/
 
 /**
@@ -508,19 +497,11 @@
 
     // In scan state, store scan result.
 #if defined WLAN_FEATURE_VOWIFI
-    status = limCollectBssDescription(pMac, &pBssDescr->bssDescription,
+    limCollectBssDescription(pMac, &pBssDescr->bssDescription,
                              pBPR, pRxPacketInfo, fScanning);
-    if (eHAL_STATUS_SUCCESS != status)
-    {
-        goto last;
-    }
 #else
-    status = limCollectBssDescription(pMac, &pBssDescr->bssDescription,
+    limCollectBssDescription(pMac, &pBssDescr->bssDescription,
                              pBPR, pRxPacketInfo);
-    if (eHAL_STATUS_SUCCESS != status)
-    {
-        goto last;
-    }
 #endif
     /* Calling dfsChannelList which will convert DFS channel
      * to Active channel for x secs if this channel is DFS channel */
@@ -614,12 +595,10 @@
         }
     }//(eANI_BOOLEAN_TRUE == fScanning)
 
-last:
     if( eHAL_STATUS_SUCCESS != status )
     {
         palFreeMemory( pMac->hHdd, pBssDescr );
     }
-    return;
 } /****** end limCheckAndAddBssDescription() ******/
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/MAC/src/pe/lim/limScanResultUtils.h	2014-12-03 11:07:31.000000000 +0000
@@ -76,13 +76,13 @@
 tANI_U32 limDeactivateMinChannelTimerDuringScan(tpAniSirGlobal);
 void    limCheckAndAddBssDescription(tpAniSirGlobal, tpSirProbeRespBeacon, tANI_U8 *, tANI_BOOLEAN, tANI_U8);
 #if defined WLAN_FEATURE_VOWIFI
-eHalStatus    limCollectBssDescription(tpAniSirGlobal,
+void    limCollectBssDescription(tpAniSirGlobal,
                                  tSirBssDescription *,
                                  tpSirProbeRespBeacon,
                                  tANI_U8 *,
                                  tANI_U8);
 #else
-eHalStatus    limCollectBssDescription(tpAniSirGlobal,
+void    limCollectBssDescription(tpAniSirGlobal,
                                  tSirBssDescription *,
                                  tpSirProbeRespBeacon,
                                  tANI_U8 *);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrApi.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrApi.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrApi.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrApi.h	2014-12-03 11:07:31.000000000 +0000
@@ -846,13 +846,8 @@
     tANI_U8 *pWAPIReqIE;   //If not null, it has the IE byte stream for WAPI
 #endif /* FEATURE_WLAN_WAPI */
 
-    //The byte count in the pAddIE for scan (at the time of join)
-    tANI_U32 nAddIEScanLength;
-    /* Additional IE information.
-     * It has the IE byte stream for additional IE,
-     * which can be WSC IE and/or P2P IE
-     */
-    tANI_U8  addIEScan[SIR_MAC_MAX_IE_LENGTH+2];       //Additional IE information.
+    tANI_U32 nAddIEScanLength;   //The byte count in the pAddIE for scan (at the time of join)
+    tANI_U8 *pAddIEScan;       //If not null, it has the IE byte stream for additional IE, which can be WSC IE and/or P2P IE
     tANI_U32 nAddIEAssocLength;   //The byte count in the pAddIE for assoc
     tANI_U8 *pAddIEAssoc;       //If not null, it has the IE byte stream for additional IE, which can be WSC IE and/or P2P IE
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrInternal.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrInternal.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/inc/csrInternal.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/inc/csrInternal.h	2014-12-03 11:07:31.000000000 +0000
@@ -883,11 +883,8 @@
     tANI_U32 nWapiRspIeLength;    //the byte count for pWapiRspIE
     tANI_U8 *pWapiRspIE;  //this contain the WAPI IE in beacon/probe rsp
 #endif /* FEATURE_WLAN_WAPI */
-    tANI_U32 nAddIEScanLength;  //length of addIeScan
-    /* This contains the additional IE in (unicast)
-     *  probe request at the time of join
-     */
-    tANI_U8 addIEScan[SIR_MAC_MAX_IE_LENGTH+2];
+    tANI_U32 nAddIEScanLength;  //the byte count of pAddIeScanIE;
+    tANI_U8 *pAddIEScan; //this contains the additional IE in (unicast) probe request at the time of join
     tANI_U32 nAddIEAssocLength;      //the byte count for pAddIeAssocIE
     tANI_U8 *pAddIEAssoc; //this contains the additional IE in (re) assoc request
 
@@ -1112,6 +1109,10 @@
 void csrScanResumeIMPS( tpAniSirGlobal pMac );
 
 eHalStatus csrInitGetChannels(tpAniSirGlobal pMac);
+// Getting the 5GHz Channel list
+eHalStatus csrGet5GChannels(tpAniSirGlobal pMac);
+// Getting the 2.4GHz Channel list
+eHalStatus csrGet24GChannels(tpAniSirGlobal pMac);
 
 eHalStatus csrSetModifyProfileFields(tpAniSirGlobal pMac, tANI_U32 sessionId,
                                      tCsrRoamModifyProfileFields *pModifyProfileFields);
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiRoam.c	2014-12-03 11:07:31.000000000 +0000
@@ -1902,6 +1902,121 @@
     return status;
 }
 
+eHalStatus csrGet5GChannels(tpAniSirGlobal pMac)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    tANI_U8 num20MHzChannelsFound = 0;
+    VOS_STATUS vosStatus;
+    tANI_U8 num40MHzChannelsFound = 0;
+    tANI_U8 Index = 0;
+    tANI_U8 channelList = 0;
+
+    // Updating the defaultpower Table for changed Domain Id
+    vosStatus = vos_nv_getChannelListWithPower( pMac->scan.defaultPowerTable, &num20MHzChannelsFound,
+                                                pMac->scan.defaultPowerTable40MHz, &num40MHzChannelsFound);
+
+    if ( (VOS_STATUS_SUCCESS != vosStatus) || (num20MHzChannelsFound == 0) )
+    {
+        smsLog( pMac, LOGE, FL("failed to get channels"));
+        status = eHAL_STATUS_FAILURE;
+    }
+    else
+    {
+        if ( num20MHzChannelsFound > WNI_CFG_VALID_CHANNEL_LIST_LEN )
+        {
+            num20MHzChannelsFound = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        }
+
+        // Move the only 5GHZ channel list to the global data,
+        // As 2.4GHZ list coming from the AP for the changed domain
+        // structure -- this will be used as the scan list
+        for(channelList = 0; channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN; channelList++)
+        {
+            // If Channel is 5GHz just break the for loop
+            if(!(pMac->scan.base20MHzChannels.channelList[ channelList ] > 0 && pMac->scan.base20MHzChannels.channelList[ channelList ] <= 14))
+                break;
+        }
+        // Update the 5G channels from nv.bin
+        for ( Index = 0; Index < num20MHzChannelsFound; Index++)
+        {
+            if(pMac->scan.defaultPowerTable[Index].chanId >= 36 && pMac->scan.defaultPowerTable[Index].chanId <= 165)
+            {
+                if(channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN)
+                {
+                   pMac->scan.base20MHzChannels.channelList[ channelList ] = pMac->scan.defaultPowerTable[Index].chanId;
+                   channelList++;
+                }
+            }
+        }
+
+        pMac->scan.numChannelsDefault = (num20MHzChannelsFound > channelList) ? num20MHzChannelsFound : channelList;
+        pMac->scan.base20MHzChannels.numChannels = (num20MHzChannelsFound > channelList) ? num20MHzChannelsFound : channelList;
+        // Filling the remaining index as Zero Just for causion
+        for(Index = pMac->scan.base20MHzChannels.numChannels; Index < WNI_CFG_VALID_CHANNEL_LIST_LEN; Index++)
+            pMac->scan.base20MHzChannels.channelList[ Index ] = 0;
+    }
+    return status;
+}
+
+eHalStatus csrGet24GChannels(tpAniSirGlobal pMac)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    tANI_U8 num20MHzChannelsFound = 0;
+    VOS_STATUS vosStatus;
+    tANI_U8 Index = 0;
+    tANI_U8 num40MHzChannelsFound = 0;
+    tANI_U8 channelList5GBackup[WNI_CFG_VALID_CHANNEL_LIST_LEN] = {0}, nuum5GchannelListBackup;
+    tANI_U8 channelList = 0;
+
+    // Read the scan channel list (including the power limit) from EEPROM
+    vosStatus = vos_nv_getChannelListWithPower( pMac->scan.defaultPowerTable, &num20MHzChannelsFound,
+                                                pMac->scan.defaultPowerTable40MHz, &num40MHzChannelsFound);
+
+    if ( (VOS_STATUS_SUCCESS != vosStatus) || (num20MHzChannelsFound == 0) )
+    {
+        smsLog( pMac, LOGE, FL("failed to get channels \n"));
+        status = eHAL_STATUS_FAILURE;
+    }
+    else
+    {
+        if ( num20MHzChannelsFound > WNI_CFG_VALID_CHANNEL_LIST_LEN )
+        {
+            num20MHzChannelsFound = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        }
+
+        // Move the 2.4GHZ channel list only to the global data,
+        // As 5GHz list been provided by AP as part of 11d IE
+        // structure -- this will be used as the scan list
+        for(channelList = 0, nuum5GchannelListBackup = 0; channelList < WNI_CFG_VALID_CHANNEL_LIST_LEN; channelList++)
+        {
+            if(pMac->scan.base20MHzChannels.channelList[ channelList ] >= 36 && pMac->scan.base20MHzChannels.channelList[ channelList ] <= 165)
+            {
+                // First taking the 5GHz channel list backup
+                channelList5GBackup[nuum5GchannelListBackup] = pMac->scan.base20MHzChannels.channelList[ channelList ];
+                nuum5GchannelListBackup++;
+            }
+        }
+        // Updating the 2.4GHz list
+        for ( Index = 0; Index < num20MHzChannelsFound; Index++)
+        {
+            if(pMac->scan.defaultPowerTable[Index].chanId > 0 && pMac->scan.defaultPowerTable[Index].chanId <= 14)
+                pMac->scan.base20MHzChannels.channelList[ Index ] = pMac->scan.defaultPowerTable[Index].chanId;
+        }
+        // Restoring the Backed up 5 GHZ channels
+        for(channelList = 0;channelList < nuum5GchannelListBackup; channelList++ )
+        {
+            if (Index < WNI_CFG_VALID_CHANNEL_LIST_LEN)
+            {
+                pMac->scan.base20MHzChannels.channelList[ Index ] = channelList5GBackup[channelList];
+                Index++;
+            }
+        }
+
+        pMac->scan.numChannelsDefault = (num20MHzChannelsFound > Index) ? num20MHzChannelsFound : Index;
+        pMac->scan.base20MHzChannels.numChannels = (num20MHzChannelsFound > Index) ? num20MHzChannelsFound : Index;
+    }
+    return (status);
+}
 
 eHalStatus csrInitGetChannels(tpAniSirGlobal pMac)
 {
@@ -5630,19 +5745,15 @@
 #endif /* FEATURE_WLAN_WAPI */
         if(pSrcProfile->nAddIEScanLength)
         {
-            memset(pDstProfile->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH);
-            if ( SIR_MAC_MAX_IE_LENGTH >=  pSrcProfile->nAddIEScanLength)
-            {
-                vos_mem_copy(pDstProfile->addIEScan, pSrcProfile->addIEScan,
-                          pSrcProfile->nAddIEScanLength);
-                pDstProfile->nAddIEScanLength = pSrcProfile->nAddIEScanLength;
-            }
-            else
+            status = palAllocateMemory(pMac->hHdd,
+                     (void **)&pDstProfile->pAddIEScan, pSrcProfile->nAddIEScanLength);
+            if(!HAL_STATUS_SUCCESS(status))
             {
-                VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                      FL(" AddIEScanLength is not valid %u"),
-                                  pSrcProfile->nAddIEScanLength);
+                break;
             }
+            pDstProfile->nAddIEScanLength = pSrcProfile->nAddIEScanLength;
+            palCopyMemory(pMac->hHdd, pDstProfile->pAddIEScan, pSrcProfile->pAddIEScan,
+                pSrcProfile->nAddIEScanLength);
         }
         if(pSrcProfile->nAddIEAssocLength)
         {
@@ -6842,17 +6953,7 @@
                 smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
                 return;
             }
-
-            /* While switching between two AP, csr will reissue roam command again
-               to the nextbss if it was interrupted by the dissconnect req for the
-               previous bss.During this csr is incrementing bRefAssocStartCnt twice.
-               so reset the bRefAssocStartCnt.
-            */
-            if(pSession->bRefAssocStartCnt > 0)
-            {
-                pSession->bRefAssocStartCnt--;
-            }
-
+            
             if( pCommand->u.roamCmd.fStopWds )
             {
                 palZeroMemory(pMac->hHdd, &roamInfo, sizeof(tCsrRoamInfo));
@@ -7755,7 +7856,7 @@
             tSirSmeAssocIndToUpperLayerCnf *pUpperLayerAssocCnf;
             tCsrRoamInfo roamInfo;
             tCsrRoamInfo *pRoamInfo = NULL;
-            tANI_U32 sessionId = 0;
+            tANI_U32 sessionId;
             eHalStatus status;
             smsLog( pMac, LOG1, FL("ASSOCIATION confirmation can be given to upper layer "));
             palZeroMemory(pMac->hHdd, &roamInfo, sizeof(tCsrRoamInfo));
@@ -8529,6 +8630,7 @@
     tCsrRoamSession *pSession = NULL;
     tpSirSmeSwitchChannelInd pSwitchChnInd;
     tSmeMaxAssocInd *pSmeMaxAssocInd;
+    tSmeCmd pCommand;
     pSirMsg->messageType = (pSirMsg->messageType);
     pSirMsg->length = (pSirMsg->length);
     pSirMsg->statusCode = (pSirMsg->statusCode);
@@ -8610,105 +8712,77 @@
             }
             break;
         case eWNI_SME_DISASSOC_IND:
+            smsLog( pMac, LOGE, FL("DISASSOCIATION Indication from MAC"));
+            // Check if AP dis-associated us because of MIC failure. If so,
+            // then we need to take action immediately and not wait till the
+            // the WmStatusChange requests is pushed and processed
+            pDisassocInd = (tSirSmeDisassocInd *)pSirMsg;
+            status = csrRoamGetSessionIdFromBSSID( pMac, (tCsrBssid *)pDisassocInd->bssId, &sessionId );
+            if( HAL_STATUS_SUCCESS( status ) )
             {
-                // Check if AP dis-associated us because of MIC failure. If so,
-                // then we need to take action immediately and not wait till the
-                // the WmStatusChange requests is pushed and processed
-                tSmeCmd *pCommand;
-
-                pDisassocInd = (tSirSmeDisassocInd *)pSirMsg;
-                status = csrRoamGetSessionIdFromBSSID( pMac,
-                                   (tCsrBssid *)pDisassocInd->bssId, &sessionId );
-                if( HAL_STATUS_SUCCESS( status ) )
-                {
-                    smsLog( pMac, LOGE, FL("DISASSOCIATION Indication from MAC"
-                                       " for session %d "), sessionId);
-                    smsLog( pMac, LOGE, FL("DISASSOCIATION from peer ="
-                                      MAC_ADDRESS_STR " "
-                                      " reason = %d status = %d "),
-                                     MAC_ADDR_ARRAY(pDisassocInd->peerMacAddr),
-                                     pDisassocInd->reasonCode,
-                                     pDisassocInd->statusCode);
-                    // If we are in neighbor preauth done state then on receiving
-                    // disassoc or deauth we dont roam instead we just disassoc
-                    // from current ap and then go to disconnected state
-                    // This happens for CCX and 11r FT connections ONLY.
+                // If we are in neighbor preauth done state then on receiving
+                // disassoc or deauth we dont roam instead we just disassoc
+                // from current ap and then go to disconnected state 
+                // This happens for CCX and 11r FT connections ONLY.
 #ifdef WLAN_FEATURE_VOWIFI_11R
-                    if (csrRoamIs11rAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIs11rAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
 #ifdef FEATURE_WLAN_CCX
-                    if (csrRoamIsCCXAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIsCCXAssoc(pMac) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
 #ifdef FEATURE_WLAN_LFR
-                    if (csrRoamIsFastRoamEnabled(pMac, sessionId) && (csrNeighborRoamStatePreauthDone(pMac)))
-                    {
-                        csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
-                    }
+                if (csrRoamIsFastRoamEnabled(pMac, sessionId) && (csrNeighborRoamStatePreauthDone(pMac)))
+                {
+                    csrNeighborRoamTranistionPreauthDoneToDisconnected(pMac);
+                }
 #endif
-                    pSession = CSR_GET_SESSION( pMac, sessionId );
+                pSession = CSR_GET_SESSION( pMac, sessionId );
 
-                    if (!pSession)
-                    {
-                        smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
-                        return;
-                    }
+                if(!pSession)
+                {
+                    smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
+                    return;
+                }
 
-                    if ( csrIsConnStateInfra( pMac, sessionId ) )
-                    {
-                        pSession->connectState = eCSR_ASSOC_STATE_TYPE_NOT_CONNECTED;
-                    }
+                if ( csrIsConnStateInfra( pMac, sessionId ) )
+                {
+                    pSession->connectState = eCSR_ASSOC_STATE_TYPE_NOT_CONNECTED;
+                }
 #ifndef WLAN_MDM_CODE_REDUCTION_OPT
-                    sme_QosCsrEventInd(pMac, (v_U8_t)sessionId, SME_QOS_CSR_DISCONNECT_IND, NULL);
+                sme_QosCsrEventInd(pMac, (v_U8_t)sessionId, SME_QOS_CSR_DISCONNECT_IND, NULL);
 #endif
-                    csrRoamLinkDown(pMac, sessionId);
-                    csrRoamIssueWmStatusChange( pMac, sessionId, eCsrDisassociated, pSirMsg );
-                    if (CSR_IS_INFRA_AP(&pSession->connectedProfile))
-                    {
+                csrRoamLinkDown(pMac, sessionId);
+                csrRoamIssueWmStatusChange( pMac, sessionId, eCsrDisassociated, pSirMsg );
+                if(CSR_IS_INFRA_AP(&pSession->connectedProfile))
+                {
 
-                        pCommand = csrGetCommandBuffer(pMac);
-                        if (NULL == pCommand)
-                        {
-                            smsLog( pMac, LOGE, FL(" fail to get command buffer") );
-                            status = eHAL_STATUS_RESOURCES;
-                        }
-                        pRoamInfo = &roamInfo;
-                        pRoamInfo->statusCode = pDisassocInd->statusCode;
-                        pRoamInfo->u.pConnectedProfile = &pSession->connectedProfile;
-                        pRoamInfo->staId = (tANI_U8)pDisassocInd->staId;
+                    pRoamInfo = &roamInfo;
 
-                        vos_mem_copy(pRoamInfo->peerMac, pDisassocInd->peerMacAddr,
-                                     sizeof(tSirMacAddr));
-                        vos_mem_copy(&pRoamInfo->bssid, pDisassocInd->bssId,
-                                     sizeof(tCsrBssid));
+                    pRoamInfo->statusCode = pDisassocInd->statusCode; 
+                    pRoamInfo->u.pConnectedProfile = &pSession->connectedProfile;
 
-                        status = csrRoamCallCallback(pMac, sessionId, pRoamInfo, 0,
-                                        eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_DISASSOC_IND);
+                    pRoamInfo->staId = (tANI_U8)pDisassocInd->staId;
 
-                        /*
-                         *  STA/P2P client got  disassociated so remove any pending deauth
-                         *  commands in sme pending list
-                         */
-                        pCommand->command = eSmeCommandRoam;
-                        pCommand->sessionId = (tANI_U8)sessionId;
-                        pCommand->u.roamCmd.roamReason = eCsrForcedDeauthSta;
-                        vos_mem_copy(pCommand->u.roamCmd.peerMac,
-                                     pDisassocInd->peerMacAddr,
-                                     sizeof(tSirMacAddr));
-                        csrRoamRemoveDuplicateCommand(pMac, sessionId, pCommand, eCsrForcedDeauthSta);
-                        csrReleaseCommand( pMac, pCommand );
+                    palCopyMemory(pMac->hHdd, pRoamInfo->peerMac, pDisassocInd->peerMacAddr, sizeof(tSirMacAddr));
+                    palCopyMemory(pMac->hHdd, &pRoamInfo->bssid, pDisassocInd->bssId, sizeof(tCsrBssid));
 
-                    }
-                }
-                else
-                {
-                    smsLog(pMac, LOGE, FL(" Session Id not found for BSSID " MAC_ADDRESS_STR),
-                                            MAC_ADDR_ARRAY(pDisassocInd->bssId));
+                    status = csrRoamCallCallback(pMac, sessionId, pRoamInfo, 0, eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_DISASSOC_IND);
+
+                    /*
+                    *  STA/P2P client got  disassociated so remove any pending deauth 
+                    *  commands in sme pending list
+                    */
+                    pCommand.command = eSmeCommandRoam;
+                    pCommand.sessionId = (tANI_U8)sessionId;
+                    pCommand.u.roamCmd.roamReason = eCsrForcedDeauthSta;
+                    vos_mem_copy(pCommand.u.roamCmd.peerMac, pDisassocInd->peerMacAddr, sizeof(tSirMacAddr));
+                    csrRoamRemoveDuplicateCommand(pMac, sessionId, &pCommand, eCsrForcedDeauthSta);
                 }
             }
             break;
@@ -11930,22 +12004,36 @@
         }
 #endif /* FEATURE_WLAN_CCX */
         // addIEScan
-        if (pProfile->nAddIEScanLength)
+        if(pProfile->nAddIEScanLength && pProfile->pAddIEScan)
         {
             ieLen = pProfile->nAddIEScanLength;
-            memset(pSession->addIEScan, 0 , pSession->nAddIEScanLength);
+            if(ieLen > pSession->nAddIEScanLength)
+            {
+                if(pSession->pAddIEScan && pSession->nAddIEScanLength)
+                {
+                    palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+                }
+                status = palAllocateMemory(pMac->hHdd,
+                                 (void **)&pSession->pAddIEScan, ieLen);
+                if(!HAL_STATUS_SUCCESS(status)) break;
+            }
             pSession->nAddIEScanLength = ieLen;
-            vos_mem_copy(pSession->addIEScan, pProfile->addIEScan, ieLen);
+            palCopyMemory(pMac->hHdd, pSession->pAddIEScan, 
+                                      pProfile->pAddIEScan, ieLen);
             wTmp = pal_cpu_to_be16( ieLen );
             palCopyMemory( pMac->hHdd, pBuf, &wTmp, sizeof(tANI_U16) );
             pBuf += sizeof(tANI_U16);
-            vos_mem_copy(pBuf, pProfile->addIEScan, ieLen);
+            palCopyMemory( pMac->hHdd, pBuf, pProfile->pAddIEScan, ieLen );
             pBuf += ieLen;
         }
         else
         {
-            memset(pSession->addIEScan, 0, pSession->nAddIEScanLength);
             pSession->nAddIEScanLength = 0;
+            if(pSession->pAddIEScan)
+            {
+                palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+                pSession->pAddIEScan = NULL;
+            }
             *pBuf = 0;
             *(pBuf + 1) = 0;
             pBuf += 2;
@@ -13461,9 +13549,10 @@
     }
     pSession->nWapiRspIeLength = 0;
 #endif /* FEATURE_WLAN_WAPI */
-    if (pSession->nAddIEScanLength)
+    if(pSession->pAddIEScan)
     {
-       memset(pSession->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH);
+        palFreeMemory(pMac->hHdd, pSession->pAddIEScan);
+        pSession->pAddIEScan = NULL;
     }
     pSession->nAddIEScanLength = 0;
     if(pSession->pAddIEAssoc)
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrApiScan.c	2014-12-03 11:07:31.000000000 +0000
@@ -3664,14 +3664,12 @@
         if ( CSR_IS_CHANNEL_5GHZ( pMac->scan.channelOf11dInfo ) )
         {
             // and the 2.4 band is empty, then populate the 2.4 channel info
-            if ( !csrLLIsListEmpty( &pMac->scan.channelPowerInfoList24, LL_ACCESS_LOCK ) ) break;
             fPopulate5GBand = FALSE;
         }
         else
         {
             // else, we found channel info in the 2.4 GHz band.  If the 5.0 band is empty
             // set the 5.0 band info from the 2.4 country code.
-            if ( !csrLLIsListEmpty( &pMac->scan.channelPowerInfoList5G, LL_ACCESS_LOCK ) ) break;
             fPopulate5GBand = TRUE;
         }
         csrSaveChannelPowerForBand( pMac, fPopulate5GBand );
@@ -3766,6 +3764,7 @@
 tANI_BOOLEAN csrLearnCountryInformation( tpAniSirGlobal pMac, tSirBssDescription *pSirBssDesc,
                                          tDot11fBeaconIEs *pIes, tANI_BOOLEAN fForce)
 {
+    tANI_U8 Num2GChannels, bMaxNumChn;
     eHalStatus status;
     tANI_BOOLEAN fRet = eANI_BOOLEAN_FALSE;
     v_REGDOMAIN_t domainId;
@@ -3885,66 +3884,56 @@
             }
         }
         smsLog(pMac, LOG3, FL("  %d sets each one is %d"), pIesLocal->Country.num_triplets, sizeof(tSirMacChanInfo));
-
-        // set the indicator of the channel where the country IE was found...
-        pMac->scan.channelOf11dInfo = pSirBssDesc->channelId;
-        status = csrGetRegulatoryDomainForCountry(pMac,
-                       pIesLocal->Country.country, &domainId );
-        if ( status != eHAL_STATUS_SUCCESS )
+        // save the channel/power information from the Channel IE.
+        //sizeof(tSirMacChanInfo) has to be 3
+        if (eHAL_STATUS_SUCCESS != csrSaveToChannelPower2G_5G( pMac, pIesLocal->Country.num_triplets * sizeof(tSirMacChanInfo),
+                    (tSirMacChanInfo *)(&pIesLocal->Country.triplets[0]) ))
         {
-            smsLog( pMac, LOGE, FL("  fail to get regId %d"), domainId );
             fRet = eANI_BOOLEAN_FALSE;
             return fRet;
         }
+
+        // set the indicator of the channel where the country IE was found...
+        pMac->scan.channelOf11dInfo = pSirBssDesc->channelId;
+        csrGetRegulatoryDomainForCountry(pMac, pIesLocal->Country.country, &domainId );
         // Checking for Domain Id change
         if ( domainId != pMac->scan.domainIdCurrent )
         {
-            vos_mem_copy(pMac->scan.countryCode11d,
-                                  pIesLocal->Country.country,
-                                  sizeof( pMac->scan.countryCode11d ) );
-            /* Set Current Country code and Current Regulatory domain */
-            status = csrSetRegulatoryDomain(pMac, domainId, NULL);
-            if (eHAL_STATUS_SUCCESS != status)
-            {
-                smsLog(pMac, LOGE, "Set Reg Domain Fail %d", status);
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
-            }
-            //csrSetRegulatoryDomain will fail if the country doesn't fit our domain criteria.
-            vos_mem_copy(pMac->scan.countryCodeCurrent,
-                            pIesLocal->Country.country, WNI_CFG_COUNTRY_CODE_LEN);
-            //Simply set it to cfg.
+            tSirMacChanInfo* pMacChnSet = (tSirMacChanInfo *)(&pIesLocal->Country.triplets[0]);
+            palCopyMemory( pMac->hHdd, pMac->scan.countryCode11d, pIesLocal->Country.country,
+                                        sizeof( pMac->scan.countryCode11d ) );
             csrSetCfgCountryCode(pMac, pIesLocal->Country.country);
-
-            /* overwrite the defualt country code */
-            vos_mem_copy(pMac->scan.countryCodeDefault,
-                                      pMac->scan.countryCodeCurrent,
-                                      WNI_CFG_COUNTRY_CODE_LEN);
-            /* Set Current RegDomain */
-            status = WDA_SetRegDomain(pMac, domainId);
-            if ( status != eHAL_STATUS_SUCCESS )
-            {
-                smsLog( pMac, LOGE, FL("  fail to Set regId %d"), domainId );
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
-            }
-             /* set to default domain ID */
+            WDA_SetRegDomain(pMac, domainId);
             pMac->scan.domainIdCurrent = domainId;
-            /* get the channels based on new cc */
-            status = csrInitGetChannels( pMac );
-
-            if ( status != eHAL_STATUS_SUCCESS )
+            // Check whether AP provided the 2.4GHZ list or 5GHZ list
+            if(CSR_IS_CHANNEL_24GHZ(pMacChnSet[0].firstChanNum))
             {
-                smsLog( pMac, LOGE, FL("  fail to get Channels "));
-                fRet = eANI_BOOLEAN_FALSE;
-                return fRet;
+                // AP Provided the 2.4 Channels, Update the 5GHz channels from nv.bin
+                csrGet5GChannels(pMac );
             }
+            else
+            {
+                // AP Provided the 5G Channels, Update the 2.4GHZ channel list from nv.bin
+                csrGet24GChannels(pMac );
+            }
+        }
+        // Populate both band channel lists based on what we found in the country information...
+        csrSetOppositeBandChannelInfo( pMac );
+        bMaxNumChn = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+        // construct 2GHz channel list first
+        csrConstructCurrentValidChannelList( pMac, &pMac->scan.channelPowerInfoList24, pMac->scan.channels11d.channelList, 
+                                                bMaxNumChn, &Num2GChannels );
+        // construct 5GHz channel list now
+        if(bMaxNumChn > Num2GChannels)
+        {
+            csrConstructCurrentValidChannelList( pMac, &pMac->scan.channelPowerInfoList5G, pMac->scan.channels11d.channelList + Num2GChannels,
+                                                 bMaxNumChn - Num2GChannels,
+                                                 &pMac->scan.channels11d.numChannels );
+        }
 
-            /* reset info based on new cc, and we are done */
-            csrResetCountryInformation(pMac, eANI_BOOLEAN_TRUE, eANI_BOOLEAN_TRUE);
-            fRet = eANI_BOOLEAN_TRUE;
+        pMac->scan.channels11d.numChannels += Num2GChannels;
+        fRet = eANI_BOOLEAN_TRUE;
 
-        }
     } while( 0 );
     
     if( !pIes && pIesLocal )
@@ -6785,7 +6774,7 @@
             {
                 pScanCmd->u.scanCmd.u.scanRequest.p2pSearch = 1;
             }
-            if(pProfile->nAddIEScanLength)
+            if(pProfile->pAddIEScan)
             {
                 status = palAllocateMemory(pMac->hHdd,
                                 (void **)&pScanCmd->u.scanCmd.u.scanRequest.pIEField,
@@ -6793,7 +6782,7 @@
                 palZeroMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->nAddIEScanLength);
                 if(HAL_STATUS_SUCCESS(status))
                 {
-                    palCopyMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->addIEScan, pProfile->nAddIEScanLength);
+                    palCopyMemory(pMac->hHdd, pScanCmd->u.scanCmd.u.scanRequest.pIEField, pProfile->pAddIEScan, pProfile->nAddIEScanLength);
                     pScanCmd->u.scanCmd.u.scanRequest.uIEFieldLen = pProfile->nAddIEScanLength;
                 }
                 else
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrNeighborRoam.c	2014-12-03 11:07:31.000000000 +0000
@@ -3896,9 +3896,7 @@
     int  init_ft_flag = FALSE;
 #endif
 
-    // if session id invalid then we need return failure
-    if (NULL == pNeighborRoamInfo  || !CSR_IS_SESSION_VALID(pMac, sessionId) ||
-	(NULL == pMac->roam.roamSession[sessionId].pCurRoamProfile))
+    if (NULL == pNeighborRoamInfo)
     {
         return eHAL_STATUS_FAILURE;
     }
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/csr/csrUtil.c	2014-12-03 11:07:31.000000000 +0000
@@ -5759,10 +5759,11 @@
             pProfile->pWAPIReqIE = NULL;
         }
 #endif /* FEATURE_WLAN_WAPI */
-        if (pProfile->nAddIEScanLength)
+
+        if(pProfile->pAddIEScan)
         {
-           memset(pProfile->addIEScan, 0 , SIR_MAC_MAX_IE_LENGTH+2);
-           pProfile->nAddIEScanLength = 0;
+            palFreeMemory(pMac->hHdd, pProfile->pAddIEScan);
+            pProfile->pAddIEScan = NULL;
         }
 
         if(pProfile->pAddIEAssoc)
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/SME/src/sme_common/sme_Api.c	2014-12-03 11:07:31.000000000 +0000
@@ -5960,11 +5960,6 @@
          smsLog(pMac, LOG2, "%s:SSID=%s frame length %d",
              __func__, dumpSsId, pPrefNetworkFoundInd->frameLength);
 
-         /* Flush scan results, So as to avoid indication/updation of
-          * stale entries, which may not have aged out during APPS collapse
-          */
-         sme_ScanFlushResult(hHal,0);
-
          //Save the frame to scan result
          if (pPrefNetworkFoundInd->mesgLen > sizeof(tSirPrefNetworkFoundInd))
          {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.c	2014-12-03 11:07:31.000000000 +0000
@@ -626,8 +626,7 @@
       "%s: MC Thread exiting!!!!", __func__);
   complete_and_exit(&pSchedContext->McShutdown, 0);
 } /* VosMCThread() */
-
-v_BOOL_t isWDresetInProgress(void)
+int isWDresetInProgress(void)
 {
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO,
                 "%s: Reset is in Progress...",__func__);
@@ -637,7 +636,7 @@
    }
    else
    {
-      return FALSE;
+      return 0;
    }
 }
 /*---------------------------------------------------------------------------
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.h flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.h
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/VOSS/src/vos_sched.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/VOSS/src/vos_sched.h	2014-12-03 11:07:31.000000000 +0000
@@ -504,6 +504,5 @@
 void vos_timer_module_init( void );
 VOS_STATUS vos_watchdog_wlan_shutdown(void);
 VOS_STATUS vos_watchdog_wlan_re_init(void);
-v_BOOL_t isWDresetInProgress(void);
 
 #endif // #if !defined __VOSS_SCHED_H
diff -urN flo-ElementalX-5.00/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c
--- flo-ElementalX-5.00/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/CORE/WDA/src/wlan_qct_wda.c	2014-12-03 11:07:31.000000000 +0000
@@ -1477,38 +1477,6 @@
    tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
                             + sizeof(tHalCfg) + tlvStruct->length) ;
 
-   /* QWLAN_HAL_CFG_RA_FILTER_ENABLE  */
-   tlvStruct->type = QWLAN_HAL_CFG_RA_FILTER_ENABLE ;
-   tlvStruct->length = sizeof(tANI_U32);
-   configDataValue = (tANI_U32 *)(tlvStruct + 1);
-
-   if (wlan_cfgGetInt(pMac, WNI_CFG_RA_FILTER_ENABLE,
-                                            configDataValue ) != eSIR_SUCCESS)
-   {
-      VOS_TRACE( VOS_MODULE_ID_WDA, VOS_TRACE_LEVEL_ERROR,
-               "Failed to get value for WNI_CFG_RA_FILTER_ENABLE");
-      goto handle_failure;
-   }
-
-   tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
-                           + sizeof(tHalCfg) + tlvStruct->length) ;
-
-   /* QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL  */
-   tlvStruct->type = QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL ;
-   tlvStruct->length = sizeof(tANI_U32);
-   configDataValue = (tANI_U32 *)(tlvStruct + 1);
-
-   if (wlan_cfgGetInt(pMac, WNI_CFG_RA_RATE_LIMIT_INTERVAL,
-                                            configDataValue ) != eSIR_SUCCESS)
-   {
-      VOS_TRACE( VOS_MODULE_ID_WDA, VOS_TRACE_LEVEL_ERROR,
-               "Failed to get value for WNI_CFG_RA_RATE_LIMIT_INTERVAL");
-      goto handle_failure;
-   }
-
-   tlvStruct = (tHalCfg *)( (tANI_U8 *) tlvStruct
-                           + sizeof(tHalCfg) + tlvStruct->length) ;
-
    wdiStartParams->usConfigBufferLen = (tANI_U8 *)tlvStruct - tlvStructStart ;
 #ifdef WLAN_DEBUG
    {
diff -urN flo-ElementalX-5.00/drivers/staging/prima/Kbuild flo-ElementalX-5.00-patched/drivers/staging/prima/Kbuild
--- flo-ElementalX-5.00/drivers/staging/prima/Kbuild	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/Kbuild	2014-12-03 11:07:31.000000000 +0000
@@ -628,7 +628,7 @@
 endif
 
 # Fix build for GCC 4.7
-EXTRA_CFLAGS += -Wno-maybe-uninitialized -Wno-unused-function -Wno-array-bounds
+EXTRA_CFLAGS += -Wno-maybe-uninitialized -Wno-unused-function
 
 KBUILD_CPPFLAGS += $(CDEFINES)
 
Binary files flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_cfg.dat and flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_cfg.dat differ
diff -urN flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini
--- flo-ElementalX-5.00/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/firmware_bin/WCNSS_qcom_cfg.ini	2014-12-03 11:07:31.000000000 +0000
@@ -396,20 +396,6 @@
 gRrmNonOperChanMax=8
 gRrmRandIntvl=100
 
-# TDLS Support
-gEnableTDLSSupport=1
-gEnableTDLSImplicitTrigger=1
-gTDLSExternalControl=1
-gTDLSTxStatsPeriod=500
-gTDLSTxPacketThreshold=10
-gTDLSDiscoveryPeriod=20000
-gTDLSMaxDiscoveryAttempt=5
-gTDLSIdleTimeout=40000
-gTDLSRssiHysteresis=100
-gTDLSRSSITriggerThreshold=-60
-gTDLSIdlePacketThreshold=5
-gTDLSRSSITeardownThreshold=-70
-
 END
 
 # Note: Configuration parser would not read anything past the END marker
diff -urN flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_cfg.h flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_cfg.h
--- flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_cfg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_cfg.h	2014-12-03 11:07:31.000000000 +0000
@@ -155,9 +155,8 @@
 #define QWLAN_HAL_CFG_ENABLE_DETECT_PS_SUPPORT          101
 #define QWLAN_HAL_CFG_AP_LINK_MONITOR_TIMEOUT           102
 #define QWLAN_HAL_CFG_BTC_DWELL_TIME_MULTIPLIER         103
-#define QWLAN_HAL_CFG_RA_FILTER_ENABLE                  104
-#define QWLAN_HAL_CFG_RA_RATE_LIMIT_INTERVAL            105
-#define QWLAN_HAL_CFG_MAX_PARAMS                        106
+#define QWLAN_HAL_CFG_ENABLE_TDLS_OXYGEN_MODE           104
+#define QWLAN_HAL_CFG_MAX_PARAMS                        105
 
 
 
diff -urN flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_msg.h flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_msg.h
--- flo-ElementalX-5.00/drivers/staging/prima/riva/inc/wlan_hal_msg.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/prima/riva/inc/wlan_hal_msg.h	2014-12-03 11:07:31.000000000 +0000
@@ -5666,7 +5666,6 @@
     RATECTRL           = 21,
     WOW                = 22,
     WLAN_ROAM_SCAN_OFFLOAD = 23,
-    EXTENDED_NSOFFLOAD_SLOT = 24,
     //MAX_FEATURE_SUPPORTED = 128
 } placeHolderInCapBitmap;
 
diff -urN flo-ElementalX-5.00/drivers/staging/vt6656/main_usb.c flo-ElementalX-5.00-patched/drivers/staging/vt6656/main_usb.c
--- flo-ElementalX-5.00/drivers/staging/vt6656/main_usb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/vt6656/main_usb.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,2097 +0,0 @@
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * File: main_usb.c
- *
- * Purpose: driver entry for initial, open, close, tx and rx.
- *
- * Author: Lyndon Chen
- *
- * Date: Dec 8, 2005
- *
- * Functions:
- *
- *   vt6656_probe - module initial (insmod) driver entry
- *   device_remove1 - module remove entry
- *   device_open - allocate dma/descripter resource & initial mac/bbp function
- *   device_xmit - asynchrous data tx function
- *   device_set_multi - set mac filter
- *   device_ioctl - ioctl entry
- *   device_close - shutdown mac/bbp & free dma/descripter resource
- *   device_alloc_frag_buf - rx fragement pre-allocated function
- *   device_free_tx_bufs - free tx buffer function
- *   device_dma0_tx_80211- tx 802.11 frame via dma0
- *   device_dma0_xmit- tx PS bufferred frame via dma0
- *   device_init_registers- initial MAC & BBP & RF internal registers.
- *   device_init_rings- initial tx/rx ring buffer
- *   device_init_defrag_cb- initial & allocate de-fragement buffer.
- *   device_tx_srv- tx interrupt service function
- *
- * Revision History:
- */
-#undef __NO_VERSION__
-
-#include "device.h"
-#include "card.h"
-#include "baseband.h"
-#include "mac.h"
-#include "tether.h"
-#include "wmgr.h"
-#include "wctl.h"
-#include "power.h"
-#include "wcmd.h"
-#include "iocmd.h"
-#include "tcrc.h"
-#include "rxtx.h"
-#include "bssdb.h"
-#include "hostap.h"
-#include "wpactl.h"
-#include "ioctl.h"
-#include "iwctl.h"
-#include "dpc.h"
-#include "datarate.h"
-#include "rf.h"
-#include "firmware.h"
-#include "rndis.h"
-#include "control.h"
-#include "channel.h"
-#include "int.h"
-#include "iowpa.h"
-
-/*---------------------  Static Definitions -------------------------*/
-//static int          msglevel                =MSG_LEVEL_DEBUG;
-static int          msglevel                =MSG_LEVEL_INFO;
-
-//
-// Define module options
-//
-
-// Version Information
-#define DRIVER_AUTHOR "VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>"
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION(DEVICE_FULL_DRV_NAM);
-
-#define DEVICE_PARAM(N,D) \
-        static int N[MAX_UINTS]=OPTION_DEFAULT;\
-        module_param_array(N, int, NULL, 0);\
-        MODULE_PARM_DESC(N, D);
-
-#define RX_DESC_MIN0     16
-#define RX_DESC_MAX0     128
-#define RX_DESC_DEF0     64
-DEVICE_PARAM(RxDescriptors0,"Number of receive usb desc buffer");
-
-
-#define TX_DESC_MIN0     16
-#define TX_DESC_MAX0     128
-#define TX_DESC_DEF0     64
-DEVICE_PARAM(TxDescriptors0,"Number of transmit usb desc buffer");
-
-
-#define CHANNEL_MIN     1
-#define CHANNEL_MAX     14
-#define CHANNEL_DEF     6
-
-DEVICE_PARAM(Channel, "Channel number");
-
-
-/* PreambleType[] is the preamble length used for transmit.
-   0: indicate allows long preamble type
-   1: indicate allows short preamble type
-*/
-
-#define PREAMBLE_TYPE_DEF     1
-
-DEVICE_PARAM(PreambleType, "Preamble Type");
-
-
-#define RTS_THRESH_MIN     512
-#define RTS_THRESH_MAX     2347
-#define RTS_THRESH_DEF     2347
-
-DEVICE_PARAM(RTSThreshold, "RTS threshold");
-
-
-#define FRAG_THRESH_MIN     256
-#define FRAG_THRESH_MAX     2346
-#define FRAG_THRESH_DEF     2346
-
-DEVICE_PARAM(FragThreshold, "Fragmentation threshold");
-
-
-#define DATA_RATE_MIN     0
-#define DATA_RATE_MAX     13
-#define DATA_RATE_DEF     13
-/* datarate[] index
-   0: indicate 1 Mbps   0x02
-   1: indicate 2 Mbps   0x04
-   2: indicate 5.5 Mbps 0x0B
-   3: indicate 11 Mbps  0x16
-   4: indicate 6 Mbps   0x0c
-   5: indicate 9 Mbps   0x12
-   6: indicate 12 Mbps  0x18
-   7: indicate 18 Mbps  0x24
-   8: indicate 24 Mbps  0x30
-   9: indicate 36 Mbps  0x48
-  10: indicate 48 Mbps  0x60
-  11: indicate 54 Mbps  0x6c
-  12: indicate 72 Mbps  0x90
-  13: indicate auto rate
-*/
-
-DEVICE_PARAM(ConnectionRate, "Connection data rate");
-
-#define OP_MODE_MAX     2
-#define OP_MODE_DEF     0
-#define OP_MODE_MIN     0
-
-DEVICE_PARAM(OPMode, "Infrastruct, adhoc, AP mode ");
-
-/* OpMode[] is used for transmit.
-   0: indicate infrastruct mode used
-   1: indicate adhoc mode used
-   2: indicate AP mode used
-*/
-
-
-/* PSMode[]
-   0: indicate disable power saving mode
-   1: indicate enable power saving mode
-*/
-
-#define PS_MODE_DEF     0
-
-DEVICE_PARAM(PSMode, "Power saving mode");
-
-
-#define SHORT_RETRY_MIN     0
-#define SHORT_RETRY_MAX     31
-#define SHORT_RETRY_DEF     8
-
-
-DEVICE_PARAM(ShortRetryLimit, "Short frame retry limits");
-
-#define LONG_RETRY_MIN     0
-#define LONG_RETRY_MAX     15
-#define LONG_RETRY_DEF     4
-
-
-DEVICE_PARAM(LongRetryLimit, "long frame retry limits");
-
-
-/* BasebandType[] baseband type selected
-   0: indicate 802.11a type
-   1: indicate 802.11b type
-   2: indicate 802.11g type
-*/
-#define BBP_TYPE_MIN     0
-#define BBP_TYPE_MAX     2
-#define BBP_TYPE_DEF     2
-
-DEVICE_PARAM(BasebandType, "baseband type");
-
-
-
-/* 80211hEnable[]
-   0: indicate disable 802.11h
-   1: indicate enable 802.11h
-*/
-
-#define X80211h_MODE_DEF     0
-
-DEVICE_PARAM(b80211hEnable, "802.11h mode");
-
-
-//
-// Static vars definitions
-//
-
-static struct usb_device_id vt6656_table[] __devinitdata = {
-	{USB_DEVICE(VNT_USB_VENDOR_ID, VNT_USB_PRODUCT_ID)},
-	{}
-};
-
-// Frequency list (map channels to frequencies)
-/*
-static const long frequency_list[] = {
-    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2484,
-    4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,
-    5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210, 5220, 5230, 5240,
-    5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600, 5620, 5640, 5660, 5680,
-    5700, 5745, 5765, 5785, 5805, 5825
-	};
-
-
-#ifndef IW_ENCODE_NOKEY
-#define IW_ENCODE_NOKEY         0x0800
-#define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
-#endif
-
-static const struct iw_handler_def	iwctl_handler_def;
-*/
-
-/*---------------------  Static Functions  --------------------------*/
-
-static int vt6656_probe(struct usb_interface *intf,
-			const struct usb_device_id *id);
-static void vt6656_disconnect(struct usb_interface *intf);
-
-#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
-static int vt6656_suspend(struct usb_interface *intf, pm_message_t message);
-static int vt6656_resume(struct usb_interface *intf);
-#endif /* CONFIG_PM */
-
-static struct net_device_stats *device_get_stats(struct net_device *dev);
-static int  device_open(struct net_device *dev);
-static int  device_xmit(struct sk_buff *skb, struct net_device *dev);
-static void device_set_multi(struct net_device *dev);
-static int  device_close(struct net_device *dev);
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-
-static BOOL device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType);
-static BOOL device_init_defrag_cb(PSDevice pDevice);
-static void device_init_diversity_timer(PSDevice pDevice);
-static int  device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev);
-
-static int  ethtool_ioctl(struct net_device *dev, void *useraddr);
-static void device_free_tx_bufs(PSDevice pDevice);
-static void device_free_rx_bufs(PSDevice pDevice);
-static void device_free_int_bufs(PSDevice pDevice);
-static void device_free_frag_bufs(PSDevice pDevice);
-static BOOL device_alloc_bufs(PSDevice pDevice);
-
-static int Read_config_file(PSDevice pDevice);
-static unsigned char *Config_FileOperation(PSDevice pDevice);
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest,
-				   unsigned char *source);
-
-static BOOL device_release_WPADEV(PSDevice pDevice);
-
-static void usb_device_reset(PSDevice pDevice);
-
-
-
-/*---------------------  Export Variables  --------------------------*/
-
-/*---------------------  Export Functions  --------------------------*/
-
-
-static void
-device_set_options(PSDevice pDevice) {
-
-    BYTE    abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    BYTE    abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    u8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-
-    memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-    memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-    memcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);
-
-    pDevice->cbTD = TX_DESC_DEF0;
-    pDevice->cbRD = RX_DESC_DEF0;
-    pDevice->uChannel = CHANNEL_DEF;
-    pDevice->wRTSThreshold = RTS_THRESH_DEF;
-    pDevice->wFragmentationThreshold = FRAG_THRESH_DEF;
-    pDevice->byShortRetryLimit = SHORT_RETRY_DEF;
-    pDevice->byLongRetryLimit = LONG_RETRY_DEF;
-    pDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;
-    pDevice->byShortPreamble = PREAMBLE_TYPE_DEF;
-    pDevice->ePSMode = PS_MODE_DEF;
-    pDevice->b11hEnable = X80211h_MODE_DEF;
-    pDevice->eOPMode = OP_MODE_DEF;
-    pDevice->uConnectionRate = DATA_RATE_DEF;
-    if (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = TRUE;
-    pDevice->byBBType = BBP_TYPE_DEF;
-    pDevice->byPacketType = pDevice->byBBType;
-    pDevice->byAutoFBCtrl = AUTO_FB_0;
-    pDevice->bUpdateBBVGA = TRUE;
-    pDevice->byFOETuning = 0;
-    pDevice->byAutoPwrTunning = 0;
-    pDevice->wCTSDuration = 0;
-    pDevice->byPreambleType = 0;
-    pDevice->bExistSWNetAddr = FALSE;
-//    pDevice->bDiversityRegCtlON = TRUE;
-    pDevice->bDiversityRegCtlON = FALSE;
-}
-
-
-static void device_init_diversity_timer(PSDevice pDevice)
-{
-    init_timer(&pDevice->TimerSQ3Tmax1);
-    pDevice->TimerSQ3Tmax1.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);
-
-    init_timer(&pDevice->TimerSQ3Tmax2);
-    pDevice->TimerSQ3Tmax2.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;
-    pDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);
-
-    init_timer(&pDevice->TimerSQ3Tmax3);
-    pDevice->TimerSQ3Tmax3.data = (unsigned long)pDevice;
-    pDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerSQ3Tmax3CallBack;
-    pDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);
-
-    return;
-}
-
-
-//
-// Initialiation of MAC & BBP registers
-//
-
-static BOOL device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)
-{
-    u8 abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    u8 abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
-    u8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
-    BYTE            byAntenna;
-    unsigned int            ii;
-    CMD_CARD_INIT   sInitCmd;
-    int ntStatus = STATUS_SUCCESS;
-    RSP_CARD_INIT   sInitRsp;
-    PSMgmtObject    pMgmt = &(pDevice->sMgmtObj);
-    BYTE            byTmp;
-    BYTE            byCalibTXIQ = 0;
-    BYTE            byCalibTXDC = 0;
-    BYTE            byCalibRXIQ = 0;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---->INIbInitAdapter. [%d][%d]\n", InitType, pDevice->byPacketType);
-	spin_lock_irq(&pDevice->lock);
-	if (InitType == DEVICE_INIT_COLD) {
-		memcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);
-		memcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);
-		memcpy(pDevice->abySNAP_Bridgetunnel,
-		       abySNAP_Bridgetunnel,
-		       ETH_ALEN);
-
-        if ( !FIRMWAREbCheckVersion(pDevice) ) {
-            if (FIRMWAREbDownload(pDevice) == TRUE) {
-                if (FIRMWAREbBrach2Sram(pDevice) == FALSE) {
-                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbBrach2Sram fail \n");
-                  	spin_unlock_irq(&pDevice->lock);
-                    return FALSE;
-                }
-            } else {
-
-                DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbDownload fail \n");
-                spin_unlock_irq(&pDevice->lock);
-                return FALSE;
-            }
-        }
-
-        if ( !BBbVT3184Init(pDevice) ) {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" BBbVT3184Init fail \n");
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-    }
-
-    sInitCmd.byInitClass = (BYTE)InitType;
-    sInitCmd.bExistSWNetAddr = (BYTE) pDevice->bExistSWNetAddr;
-    for (ii = 0; ii < 6; ii++)
-	sInitCmd.bySWNetAddr[ii] = pDevice->abyCurrentNetAddr[ii];
-    sInitCmd.byShortRetryLimit = pDevice->byShortRetryLimit;
-    sInitCmd.byLongRetryLimit = pDevice->byLongRetryLimit;
-
-    //issue Card_init command to device
-    ntStatus = CONTROLnsRequestOut(pDevice,
-                                    MESSAGE_TYPE_CARDINIT,
-                                    0,
-                                    0,
-                                    sizeof(CMD_CARD_INIT),
-                                    (PBYTE) &(sInitCmd));
-
-    if ( ntStatus != STATUS_SUCCESS ) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Issue Card init fail \n");
-        spin_unlock_irq(&pDevice->lock);
-        return FALSE;
-    }
-    if (InitType == DEVICE_INIT_COLD) {
-
-        ntStatus = CONTROLnsRequestIn(pDevice,MESSAGE_TYPE_INIT_RSP,0,0,sizeof(RSP_CARD_INIT), (PBYTE) &(sInitRsp));
-
-        if (ntStatus != STATUS_SUCCESS) {
-            DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Cardinit request in status fail!\n");
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-
-        //Local ID for AES functions
-        ntStatus = CONTROLnsRequestIn(pDevice,
-                                    MESSAGE_TYPE_READ,
-                                    MAC_REG_LOCALID,
-                                    MESSAGE_REQUEST_MACREG,
-                                    1,
-                                    &pDevice->byLocalID);
-
-        if ( ntStatus != STATUS_SUCCESS ) {
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-
-        // Do MACbSoftwareReset in MACvInitialize
-        // force CCK
-        pDevice->bCCK = TRUE;
-        pDevice->bProtectMode = FALSE;          //Only used in 11g type, sync with ERP IE
-        pDevice->bNonERPPresent = FALSE;
-        pDevice->bBarkerPreambleMd = FALSE;
-        if ( pDevice->bFixRate ) {
-            pDevice->wCurrentRate = (WORD) pDevice->uConnectionRate;
-        } else {
-            if ( pDevice->byBBType == BB_TYPE_11B )
-                pDevice->wCurrentRate = RATE_11M;
-            else
-                pDevice->wCurrentRate = RATE_54M;
-        }
-
-        CHvInitChannelTable(pDevice);
-
-        pDevice->byTopOFDMBasicRate = RATE_24M;
-        pDevice->byTopCCKBasicRate = RATE_1M;
-        pDevice->byRevId = 0;                   //Target to IF pin while programming to RF chip.
-        pDevice->byCurPwr = 0xFF;
-
-        pDevice->byCCKPwr = pDevice->abyEEPROM[EEP_OFS_PWR_CCK];
-        pDevice->byOFDMPwrG = pDevice->abyEEPROM[EEP_OFS_PWR_OFDMG];
-        // Load power Table
-        for (ii=0;ii<14;ii++) {
-            pDevice->abyCCKPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_CCK_PWR_TBL];
-            if (pDevice->abyCCKPwrTbl[ii] == 0)
-                pDevice->abyCCKPwrTbl[ii] = pDevice->byCCKPwr;
-            pDevice->abyOFDMPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDM_PWR_TBL];
-            if (pDevice->abyOFDMPwrTbl[ii] == 0)
-                pDevice->abyOFDMPwrTbl[ii] = pDevice->byOFDMPwrG;
-        }
-
-	  //original zonetype is USA,but customize zonetype is europe,
-	  // then need recover 12,13 ,14 channel  with 11 channel
-          if(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||
-	        (pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&
-	     (pDevice->byOriginalZonetype == ZoneType_USA)) {
-		for (ii = 11; ii < 14; ii++) {
-			pDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];
-			pDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];
-		}
-	  }
-
-        //{{ RobertYu: 20041124
-        pDevice->byOFDMPwrA = 0x34; // same as RFbMA2829SelectChannel
-        // Load OFDM A Power Table
-        for (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) { //RobertYu:20041224, bug using CB_MAX_CHANNEL
-            pDevice->abyOFDMAPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDMA_PWR_TBL];
-            if (pDevice->abyOFDMAPwrTbl[ii] == 0)
-                pDevice->abyOFDMAPwrTbl[ii] = pDevice->byOFDMPwrA;
-        }
-        //}} RobertYu
-
-        byAntenna = pDevice->abyEEPROM[EEP_OFS_ANTENNA];
-        if (byAntenna & EEP_ANTINV)
-            pDevice->bTxRxAntInv = TRUE;
-        else
-            pDevice->bTxRxAntInv = FALSE;
-
-        byAntenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-        if (byAntenna == 0) // if not set default is All
-            byAntenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-        if (byAntenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-            pDevice->byAntennaCount = 2;
-            pDevice->byTxAntennaMode = ANT_B;
-            pDevice->dwTxAntennaSel = 1;
-            pDevice->dwRxAntennaSel = 1;
-            if (pDevice->bTxRxAntInv == TRUE)
-                pDevice->byRxAntennaMode = ANT_A;
-            else
-                pDevice->byRxAntennaMode = ANT_B;
-
-            if (pDevice->bDiversityRegCtlON)
-                pDevice->bDiversityEnable = TRUE;
-            else
-                pDevice->bDiversityEnable = FALSE;
-        } else  {
-            pDevice->bDiversityEnable = FALSE;
-            pDevice->byAntennaCount = 1;
-            pDevice->dwTxAntennaSel = 0;
-            pDevice->dwRxAntennaSel = 0;
-            if (byAntenna & EEP_ANTENNA_AUX) {
-                pDevice->byTxAntennaMode = ANT_A;
-                if (pDevice->bTxRxAntInv == TRUE)
-                    pDevice->byRxAntennaMode = ANT_B;
-                else
-                    pDevice->byRxAntennaMode = ANT_A;
-            } else {
-                pDevice->byTxAntennaMode = ANT_B;
-                if (pDevice->bTxRxAntInv == TRUE)
-                    pDevice->byRxAntennaMode = ANT_A;
-                else
-                    pDevice->byRxAntennaMode = ANT_B;
-            }
-        }
-        pDevice->ulDiversityNValue = 100*255;
-        pDevice->ulDiversityMValue = 100*16;
-        pDevice->byTMax = 1;
-        pDevice->byTMax2 = 4;
-        pDevice->ulSQ3TH = 0;
-        pDevice->byTMax3 = 64;
-        // -----------------------------------------------------------------
-
-        //Get Auto Fall Back Type
-        pDevice->byAutoFBCtrl = AUTO_FB_0;
-
-        // Set SCAN Time
-        pDevice->uScanTime = WLAN_SCAN_MINITIME;
-
-        // default Auto Mode
-        //pDevice->NetworkType = Ndis802_11Automode;
-        pDevice->eConfigPHYMode = PHY_TYPE_AUTO;
-        pDevice->byBBType = BB_TYPE_11G;
-
-        // initialize BBP registers
-        pDevice->ulTxPower = 25;
-
-        // Get Channel range
-        pDevice->byMinChannel = 1;
-        pDevice->byMaxChannel = CB_MAX_CHANNEL;
-
-        // Get RFType
-        pDevice->byRFType = sInitRsp.byRFType;
-
-        if ((pDevice->byRFType & RF_EMU) != 0) {
-            // force change RevID for VT3253 emu
-            pDevice->byRevId = 0x80;
-        }
-
-        // Load EEPROM calibrated vt3266 parameters
-        if (pDevice->byRFType == RF_VT3226D0) {
-            if((pDevice->abyEEPROM[EEP_OFS_MAJOR_VER] == 0x1) &&
-                (pDevice->abyEEPROM[EEP_OFS_MINOR_VER] >= 0x4)) {
-                byCalibTXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_IQ];
-                byCalibTXDC = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_DC];
-                byCalibRXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_RX_IQ];
-                if( (byCalibTXIQ || byCalibTXDC || byCalibRXIQ) ) {
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x03); // CR255, Set BB to support TX/RX IQ and DC compensation Mode
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFB, byCalibTXIQ); // CR251, TX I/Q Imbalance Calibration
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFC, byCalibTXDC); // CR252, TX DC-Offset Calibration
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFD, byCalibRXIQ); // CR253, RX I/Q Imbalance Calibration
-                } else {
-                // turn off BB Calibration compensation
-                    ControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x0); // CR255
-                }
-            }
-        }
-        pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-        pMgmt->uCurrChannel = pDevice->uChannel;
-        pMgmt->uIBSSChannel = pDevice->uChannel;
-        CARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);
-
-        // get Permanent network address
-        memcpy(pDevice->abyPermanentNetAddr,&(sInitRsp.byNetAddr[0]),6);
-	memcpy(pDevice->abyCurrentNetAddr,
-	       pDevice->abyPermanentNetAddr,
-	       ETH_ALEN);
-
-        // if exist SW network address, use SW network address.
-
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %pM\n",
-		pDevice->abyCurrentNetAddr);
-    }
-
-    // Set BB and packet type at the same time.
-    // Set Short Slot Time, xIFS, and RSPINF.
-    if (pDevice->byBBType == BB_TYPE_11A) {
-        CARDbAddBasicRate(pDevice, RATE_6M);
-        pDevice->bShortSlotTime = TRUE;
-    } else {
-        CARDbAddBasicRate(pDevice, RATE_1M);
-        pDevice->bShortSlotTime = FALSE;
-    }
-    BBvSetShortSlotTime(pDevice);
-    CARDvSetBSSMode(pDevice);
-
-    if (pDevice->bUpdateBBVGA) {
-        pDevice->byBBVGACurrent = pDevice->abyBBVGA[0];
-        pDevice->byBBVGANew = pDevice->byBBVGACurrent;
-        BBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);
-    }
-
-    pDevice->byRadioCtl = pDevice->abyEEPROM[EEP_OFS_RADIOCTL];
-    pDevice->bHWRadioOff = FALSE;
-    if ( (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) != 0 ) {
-        ntStatus = CONTROLnsRequestIn(pDevice,
-                                    MESSAGE_TYPE_READ,
-                                    MAC_REG_GPIOCTL1,
-                                    MESSAGE_REQUEST_MACREG,
-                                    1,
-                                    &byTmp);
-
-        if ( ntStatus != STATUS_SUCCESS ) {
-            spin_unlock_irq(&pDevice->lock);
-            return FALSE;
-        }
-        if ( (byTmp & GPIO3_DATA) == 0 ) {
-            pDevice->bHWRadioOff = TRUE;
-            MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-        } else {
-            MACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);
-            pDevice->bHWRadioOff = FALSE;
-        }
-
-    } //EEP_RADIOCTL_ENABLE
-
-    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_TMLEN,0x38);
-    ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
-    MACvRegBitsOn(pDevice,MAC_REG_GPIOCTL0,0x01);
-
-    if ((pDevice->bHWRadioOff == TRUE) || (pDevice->bRadioControlOff == TRUE)) {
-        CARDbRadioPowerOff(pDevice);
-    } else {
-        CARDbRadioPowerOn(pDevice);
-    }
-
-    spin_unlock_irq(&pDevice->lock);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----INIbInitAdapter Exit\n");
-    return TRUE;
-}
-
-static BOOL device_release_WPADEV(PSDevice pDevice)
-{
-  viawget_wpa_header *wpahdr;
-  int ii=0;
- // wait_queue_head_t	Set_wait;
-  //send device close to wpa_supplicnat layer
-    if (pDevice->bWPADEVUp==TRUE) {
-                 wpahdr = (viawget_wpa_header *)pDevice->skb->data;
-                 wpahdr->type = VIAWGET_DEVICECLOSE_MSG;
-                 wpahdr->resp_ie_len = 0;
-                 wpahdr->req_ie_len = 0;
-                 skb_put(pDevice->skb, sizeof(viawget_wpa_header));
-                 pDevice->skb->dev = pDevice->wpadev;
-		 skb_reset_mac_header(pDevice->skb);
-                 pDevice->skb->pkt_type = PACKET_HOST;
-                 pDevice->skb->protocol = htons(ETH_P_802_2);
-                 memset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));
-                 netif_rx(pDevice->skb);
-                 pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-
- //wait release WPADEV
-              //    init_waitqueue_head(&Set_wait);
-              //    wait_event_timeout(Set_wait, ((pDevice->wpadev==NULL)&&(pDevice->skb == NULL)),5*HZ);    //1s wait
-              while(pDevice->bWPADEVUp==TRUE) {
-	        set_current_state(TASK_UNINTERRUPTIBLE);
-                 schedule_timeout (HZ/20);          //wait 50ms
-                 ii++;
-	        if(ii>20)
-		  break;
-              }
-           }
-    return TRUE;
-}
-
-#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
-
-static int vt6656_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device || !device->dev)
-		return -ENODEV;
-
-	if (device->flags & DEVICE_FLAGS_OPENED)
-		device_close(device->dev);
-
-	usb_put_dev(interface_to_usbdev(intf));
-
-	return 0;
-}
-
-static int vt6656_resume(struct usb_interface *intf)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device || !device->dev)
-		return -ENODEV;
-
-	usb_get_dev(interface_to_usbdev(intf));
-
-	if (!(device->flags & DEVICE_FLAGS_OPENED))
-		device_open(device->dev);
-
-	return 0;
-}
-
-#endif /* CONFIG_PM */
-
-static const struct net_device_ops device_netdev_ops = {
-    .ndo_open               = device_open,
-    .ndo_stop               = device_close,
-    .ndo_do_ioctl           = device_ioctl,
-    .ndo_get_stats          = device_get_stats,
-    .ndo_start_xmit         = device_xmit,
-    .ndo_set_rx_mode	    = device_set_multi,
-};
-
-static int __devinit
-vt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	u8 fake_mac[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
-	struct usb_device *udev = interface_to_usbdev(intf);
-	int rc = 0;
-	struct net_device *netdev = NULL;
-	PSDevice pDevice = NULL;
-
-	printk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-	printk(KERN_NOTICE "Copyright (c) 2004 VIA Networking Technologies, Inc.\n");
-
-	udev = usb_get_dev(udev);
-	netdev = alloc_etherdev(sizeof(DEVICE_INFO));
-	if (!netdev) {
-		printk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");
-		rc = -ENOMEM;
-		goto err_nomem;
-	}
-
-	pDevice = netdev_priv(netdev);
-	memset(pDevice, 0, sizeof(DEVICE_INFO));
-
-	pDevice->dev = netdev;
-	pDevice->usb = udev;
-
-	device_set_options(pDevice);
-	spin_lock_init(&pDevice->lock);
-
-	pDevice->tx_80211 = device_dma0_tx_80211;
-	pDevice->sMgmtObj.pAdapter = (void *) pDevice;
-
-	netdev->netdev_ops = &device_netdev_ops;
-	netdev->wireless_handlers =
-		(struct iw_handler_def *) &iwctl_handler_def;
-
-	usb_set_intfdata(intf, pDevice);
-	SET_NETDEV_DEV(netdev, &intf->dev);
-	memcpy(pDevice->dev->dev_addr, fake_mac, ETH_ALEN);
-	rc = register_netdev(netdev);
-	if (rc) {
-		printk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");
-		goto err_netdev;
-	}
-
-	usb_device_reset(pDevice);
-
-	{
-		union iwreq_data wrqu;
-		memset(&wrqu, 0, sizeof(wrqu));
-		wrqu.data.flags = RT_INSMOD_EVENT_FLAG;
-		wrqu.data.length = IFNAMSIZ;
-		wireless_send_event(pDevice->dev,
-				    IWEVCUSTOM,
-				    &wrqu,
-				    pDevice->dev->name);
-	}
-
-	return 0;
-
-err_netdev:
-	free_netdev(netdev);
-err_nomem:
-	usb_put_dev(udev);
-
-	return rc;
-}
-
-static void device_free_tx_bufs(PSDevice pDevice)
-{
-    PUSB_SEND_CONTEXT pTxContext;
-    int ii;
-
-    for (ii = 0; ii < pDevice->cbTD; ii++) {
-
-        pTxContext = pDevice->apTD[ii];
-        //de-allocate URBs
-        if (pTxContext->pUrb) {
-            usb_kill_urb(pTxContext->pUrb);
-            usb_free_urb(pTxContext->pUrb);
-        }
-        kfree(pTxContext);
-    }
-    return;
-}
-
-
-static void device_free_rx_bufs(PSDevice pDevice)
-{
-    PRCB pRCB;
-    int ii;
-
-    for (ii = 0; ii < pDevice->cbRD; ii++) {
-
-        pRCB = pDevice->apRCB[ii];
-        //de-allocate URBs
-        if (pRCB->pUrb) {
-            usb_kill_urb(pRCB->pUrb);
-            usb_free_urb(pRCB->pUrb);
-        }
-        //de-allocate skb
-        if (pRCB->skb)
-            dev_kfree_skb(pRCB->skb);
-    }
-    kfree(pDevice->pRCBMem);
-
-    return;
-}
-
-static void usb_device_reset(PSDevice pDevice)
-{
- int status;
- status = usb_reset_device(pDevice->usb);
-	if (status)
-            printk("usb_device_reset fail status=%d\n",status);
-	return ;
-}
-
-static void device_free_int_bufs(PSDevice pDevice)
-{
-    kfree(pDevice->intBuf.pDataBuf);
-    return;
-}
-
-
-static BOOL device_alloc_bufs(PSDevice pDevice) {
-
-    PUSB_SEND_CONTEXT pTxContext;
-    PRCB pRCB;
-    int ii;
-
-
-    for (ii = 0; ii < pDevice->cbTD; ii++) {
-
-        pTxContext = kmalloc(sizeof(USB_SEND_CONTEXT), GFP_KERNEL);
-        if (pTxContext == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate tx usb context failed\n", pDevice->dev->name);
-            goto free_tx;
-        }
-        pDevice->apTD[ii] = pTxContext;
-	pTxContext->pDevice = (void *) pDevice;
-        //allocate URBs
-        pTxContext->pUrb = usb_alloc_urb(0, GFP_ATOMIC);
-        if (pTxContext->pUrb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "alloc tx urb failed\n");
-            goto free_tx;
-        }
-        pTxContext->bBoolInUse = FALSE;
-    }
-
-    // allocate rcb mem
-	pDevice->pRCBMem = kzalloc((sizeof(RCB) * pDevice->cbRD), GFP_KERNEL);
-    if (pDevice->pRCBMem == NULL) {
-        DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : alloc rx usb context failed\n", pDevice->dev->name);
-        goto free_tx;
-    }
-
-
-    pDevice->FirstRecvFreeList = NULL;
-    pDevice->LastRecvFreeList = NULL;
-    pDevice->FirstRecvMngList = NULL;
-    pDevice->LastRecvMngList = NULL;
-    pDevice->NumRecvFreeList = 0;
-    pRCB = (PRCB) pDevice->pRCBMem;
-
-    for (ii = 0; ii < pDevice->cbRD; ii++) {
-
-        pDevice->apRCB[ii] = pRCB;
-	pRCB->pDevice = (void *) pDevice;
-        //allocate URBs
-        pRCB->pUrb = usb_alloc_urb(0, GFP_ATOMIC);
-
-        if (pRCB->pUrb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx urb\n");
-            goto free_rx_tx;
-        }
-        pRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-        if (pRCB->skb == NULL) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx skb\n");
-            goto free_rx_tx;
-        }
-        pRCB->skb->dev = pDevice->dev;
-        pRCB->bBoolInUse = FALSE;
-        EnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);
-        pDevice->NumRecvFreeList++;
-        pRCB++;
-    }
-
-
-	pDevice->pControlURB = usb_alloc_urb(0, GFP_ATOMIC);
-	if (pDevice->pControlURB == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc control urb\n");
-	    goto free_rx_tx;
-	}
-
-	pDevice->pInterruptURB = usb_alloc_urb(0, GFP_ATOMIC);
-	if (pDevice->pInterruptURB == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int urb\n");
-	    usb_free_urb(pDevice->pControlURB);
-	    goto free_rx_tx;
-	}
-
-    pDevice->intBuf.pDataBuf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);
-	if (pDevice->intBuf.pDataBuf == NULL) {
-	    DBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int buf\n");
-	    usb_free_urb(pDevice->pControlURB);
-	    usb_free_urb(pDevice->pInterruptURB);
-	    goto free_rx_tx;
-	}
-
-    return TRUE;
-
-free_rx_tx:
-    device_free_rx_bufs(pDevice);
-
-free_tx:
-    device_free_tx_bufs(pDevice);
-
-	return FALSE;
-}
-
-
-
-
-static BOOL device_init_defrag_cb(PSDevice pDevice) {
-    int i;
-    PSDeFragControlBlock pDeF;
-
-    /* Init the fragment ctl entries */
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-        pDeF = &(pDevice->sRxDFCB[i]);
-        if (!device_alloc_frag_buf(pDevice, pDeF)) {
-            DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",
-                pDevice->dev->name);
-            goto free_frag;
-        }
-    }
-    pDevice->cbDFCB = CB_MAX_RX_FRAG;
-    pDevice->cbFreeDFCB = pDevice->cbDFCB;
-    return TRUE;
-
-free_frag:
-    device_free_frag_bufs(pDevice);
-    return FALSE;
-}
-
-
-
-static void device_free_frag_bufs(PSDevice pDevice) {
-    PSDeFragControlBlock pDeF;
-    int i;
-
-    for (i = 0; i < CB_MAX_RX_FRAG; i++) {
-
-        pDeF = &(pDevice->sRxDFCB[i]);
-
-        if (pDeF->skb)
-            dev_kfree_skb(pDeF->skb);
-    }
-}
-
-
-
-BOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {
-
-    pDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
-    if (pDeF->skb == NULL)
-        return FALSE;
-    ASSERT(pDeF->skb);
-    pDeF->skb->dev = pDevice->dev;
-
-    return TRUE;
-}
-
-
-/*-----------------------------------------------------------------*/
-
-static int  device_open(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
-
-     extern SWPAResult wpa_Result;
-     memset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));
-     wpa_Result.proto = 0;
-     wpa_Result.key_mgmt = 0;
-     wpa_Result.eap_type = 0;
-     wpa_Result.authenticated = FALSE;
-     pDevice->fWPA_Authened = FALSE;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_open...\n");
-
-
-    pDevice->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
-
-    if (device_alloc_bufs(pDevice) == FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_alloc_bufs fail... \n");
-        return -ENOMEM;
-    }
-
-    if (device_init_defrag_cb(pDevice)== FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Initial defragement cb fail \n");
-        goto free_rx_tx;
-    }
-
-    MP_CLEAR_FLAG(pDevice, fMP_DISCONNECTED);
-    MP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);
-    MP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);
-    MP_SET_FLAG(pDevice, fMP_POST_READS);
-    MP_SET_FLAG(pDevice, fMP_POST_WRITES);
-
-   //read config file
-    Read_config_file(pDevice);
-
-    if (device_init_registers(pDevice, DEVICE_INIT_COLD) == FALSE) {
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " init register fail\n");
-        goto free_all;
-    }
-
-    device_set_multi(pDevice->dev);
-    // Init for Key Management
-
-    KeyvInitTable(pDevice,&pDevice->sKey);
-    memcpy(pDevice->sMgmtObj.abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);
-    memcpy(pDevice->dev->dev_addr, pDevice->abyCurrentNetAddr, ETH_ALEN);
-    pDevice->bStopTx0Pkt = FALSE;
-    pDevice->bStopDataPkt = FALSE;
-    pDevice->bRoaming = FALSE;
-    pDevice->bIsRoaming = FALSE;
-    pDevice->bEnableRoaming = FALSE;
-    if (pDevice->bDiversityRegCtlON) {
-        device_init_diversity_timer(pDevice);
-    }
-
-    vMgrObjectInit(pDevice);
-    tasklet_init(&pDevice->RxMngWorkItem, (void *)RXvMngWorkItem, (unsigned long)pDevice);
-    tasklet_init(&pDevice->ReadWorkItem, (void *)RXvWorkItem, (unsigned long)pDevice);
-    tasklet_init(&pDevice->EventWorkItem, (void *)INTvWorkItem, (unsigned long)pDevice);
-    add_timer(&(pDevice->sMgmtObj.sTimerSecondCallback));
-    pDevice->int_interval = 100;  //Max 100 microframes.
-    pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
-
-    pDevice->bIsRxWorkItemQueued = TRUE;
-    pDevice->fKillEventPollingThread = FALSE;
-    pDevice->bEventAvailable = FALSE;
-
-   pDevice->bWPADEVUp = FALSE;
-#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-     pDevice->bwextstep0 = FALSE;
-     pDevice->bwextstep1 = FALSE;
-     pDevice->bwextstep2 = FALSE;
-     pDevice->bwextstep3 = FALSE;
-     pDevice->bWPASuppWextEnabled = FALSE;
-#endif
-    pDevice->byReAssocCount = 0;
-
-    RXvWorkItem(pDevice);
-    INTvWorkItem(pDevice);
-
-    // Patch: if WEP key already set by iwconfig but device not yet open
-    if ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {
-         spin_lock_irq(&pDevice->lock);
-         KeybSetDefaultKey( pDevice,
-                            &(pDevice->sKey),
-                            pDevice->byKeyIndex | (1 << 31),
-                            pDevice->uKeyLength,
-                            NULL,
-                            pDevice->abyKey,
-                            KEY_CTL_WEP
-                          );
-         spin_unlock_irq(&pDevice->lock);
-         pDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;
-    }
-
-    if (pDevice->sMgmtObj.eConfigMode == WMAC_CONFIG_AP) {
-		bScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);
-	}
-	else {
-	//mike:mark@2008-11-10
-	  bScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
-	  /* bScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL); */
-    }
-
-
-    netif_stop_queue(pDevice->dev);
-    pDevice->flags |= DEVICE_FLAGS_OPENED;
-
-{
-  union iwreq_data      wrqu;
-  memset(&wrqu, 0, sizeof(wrqu));
-  wrqu.data.flags = RT_UPDEV_EVENT_FLAG;
-  wireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);
-}
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");
-    return 0;
-
-free_all:
-    device_free_frag_bufs(pDevice);
-free_rx_tx:
-    device_free_rx_bufs(pDevice);
-    device_free_tx_bufs(pDevice);
-    device_free_int_bufs(pDevice);
-	usb_kill_urb(pDevice->pControlURB);
-	usb_kill_urb(pDevice->pInterruptURB);
-    usb_free_urb(pDevice->pControlURB);
-    usb_free_urb(pDevice->pInterruptURB);
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open fail.. \n");
-    return -ENOMEM;
-}
-
-
-
-static int  device_close(struct net_device *dev) {
-    PSDevice    pDevice=(PSDevice) netdev_priv(dev);
-    PSMgmtObject     pMgmt = &(pDevice->sMgmtObj);
-
-        int uu;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close1 \n");
-    if (pDevice == NULL)
-        return -ENODEV;
-
-{
-  union iwreq_data      wrqu;
-  memset(&wrqu, 0, sizeof(wrqu));
-  wrqu.data.flags = RT_DOWNDEV_EVENT_FLAG;
-  wireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);
-}
-
-    if (pDevice->bLinkPass) {
-	bScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-        mdelay(30);
-    }
-
-device_release_WPADEV(pDevice);
-
-        memset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
-        pMgmt->bShareKeyAlgorithm = FALSE;
-        pDevice->bEncryptionEnable = FALSE;
-        pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;
-	spin_lock_irq(&pDevice->lock);
-	for (uu = 0; uu < MAX_KEY_TABLE; uu++)
-                MACvDisableKeyEntry(pDevice,uu);
-	spin_unlock_irq(&pDevice->lock);
-
-    if ((pDevice->flags & DEVICE_FLAGS_UNPLUG) == FALSE) {
-        MACbShutdown(pDevice);
-    }
-    netif_stop_queue(pDevice->dev);
-    MP_SET_FLAG(pDevice, fMP_DISCONNECTED);
-    MP_CLEAR_FLAG(pDevice, fMP_POST_WRITES);
-    MP_CLEAR_FLAG(pDevice, fMP_POST_READS);
-    pDevice->fKillEventPollingThread = TRUE;
-    del_timer(&pDevice->sTimerCommand);
-    del_timer(&pMgmt->sTimerSecondCallback);
-
-    del_timer(&pDevice->sTimerTxData);
-
-    if (pDevice->bDiversityRegCtlON) {
-        del_timer(&pDevice->TimerSQ3Tmax1);
-        del_timer(&pDevice->TimerSQ3Tmax2);
-        del_timer(&pDevice->TimerSQ3Tmax3);
-    }
-    tasklet_kill(&pDevice->RxMngWorkItem);
-    tasklet_kill(&pDevice->ReadWorkItem);
-    tasklet_kill(&pDevice->EventWorkItem);
-
-   pDevice->bRoaming = FALSE;
-   pDevice->bIsRoaming = FALSE;
-   pDevice->bEnableRoaming = FALSE;
-    pDevice->bCmdRunning = FALSE;
-    pDevice->bLinkPass = FALSE;
-    memset(pMgmt->abyCurrBSSID, 0, 6);
-    pMgmt->eCurrState = WMAC_STATE_IDLE;
-
-    device_free_tx_bufs(pDevice);
-    device_free_rx_bufs(pDevice);
-    device_free_int_bufs(pDevice);
-    device_free_frag_bufs(pDevice);
-
-	usb_kill_urb(pDevice->pControlURB);
-	usb_kill_urb(pDevice->pInterruptURB);
-    usb_free_urb(pDevice->pControlURB);
-    usb_free_urb(pDevice->pInterruptURB);
-
-    BSSvClearNodeDBTable(pDevice, 0);
-    pDevice->flags &=(~DEVICE_FLAGS_OPENED);
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close2 \n");
-
-    return 0;
-}
-
-static void __devexit vt6656_disconnect(struct usb_interface *intf)
-{
-	PSDevice device = usb_get_intfdata(intf);
-
-	if (!device)
-		return;
-
-	{
-		union iwreq_data req;
-		memset(&req, 0, sizeof(req));
-		req.data.flags = RT_RMMOD_EVENT_FLAG;
-		wireless_send_event(device->dev, IWEVCUSTOM, &req, NULL);
-	}
-
-	device_release_WPADEV(device);
-
-	if (device->firmware)
-		release_firmware(device->firmware);
-
-	usb_set_intfdata(intf, NULL);
-	usb_put_dev(interface_to_usbdev(intf));
-
-	device->flags |= DEVICE_FLAGS_UNPLUG;
-
-	if (device->dev) {
-		unregister_netdev(device->dev);
-		wpa_set_wpadev(device, 0);
-		free_netdev(device->dev);
-	}
-}
-
-static int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)
-{
-	PSDevice pDevice = netdev_priv(dev);
-
-	spin_lock_irq(&pDevice->lock);
-
-	if (unlikely(pDevice->bStopTx0Pkt))
-		dev_kfree_skb_irq(skb);
-	else
-		vDMA0_tx_80211(pDevice, skb);
-
-	spin_unlock_irq(&pDevice->lock);
-
-	return NETDEV_TX_OK;
-}
-
-static int device_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	PSDevice pDevice = netdev_priv(dev);
-	struct net_device_stats *stats = &pDevice->stats;
-
-	spin_lock_irq(&pDevice->lock);
-
-	netif_stop_queue(dev);
-
-	if (!pDevice->bLinkPass) {
-		dev_kfree_skb_irq(skb);
-		goto out;
-	}
-
-	if (pDevice->bStopDataPkt) {
-		dev_kfree_skb_irq(skb);
-		stats->tx_dropped++;
-		goto out;
-	}
-
-	if (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb)) {
-		if (netif_queue_stopped(dev))
-			netif_wake_queue(dev);
-	}
-
-out:
-	spin_unlock_irq(&pDevice->lock);
-
-	return NETDEV_TX_OK;
-}
-
-static unsigned const ethernet_polynomial = 0x04c11db7U;
-static inline u32 ether_crc(int length, unsigned char *data)
-{
-    int crc = -1;
-
-    while(--length >= 0) {
-        unsigned char current_octet = *data++;
-        int bit;
-        for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
-            crc = (crc << 1) ^
-                ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
-        }
-    }
-    return crc;
-}
-
-//find out  the start  position of str2 from str1
-static unsigned char *kstrstr(const unsigned char *str1,
-			      const unsigned char *str2) {
-  int str1_len = strlen(str1);
-  int str2_len = strlen(str2);
-
-  while (str1_len >= str2_len) {
-       str1_len--;
-      if(memcmp(str1,str2,str2_len)==0)
-	return (unsigned char *) str1;
-        str1++;
-  }
-  return NULL;
-}
-
-static int Config_FileGetParameter(unsigned char *string,
-				   unsigned char *dest,
-				   unsigned char *source)
-{
-  unsigned char buf1[100];
-  unsigned char buf2[100];
-  unsigned char *start_p = NULL, *end_p = NULL, *tmp_p = NULL;
-  int ii;
-
-    memset(buf1,0,100);
-    strcat(buf1, string);
-    strcat(buf1, "=");
-    source+=strlen(buf1);
-
-//find target string start point
-    start_p = kstrstr(source,buf1);
-    if (start_p == NULL)
-	return FALSE;
-
-//check if current config line is marked by "#" ??
-    for (ii = 1; ; ii++) {
-	if (memcmp(start_p - ii, "\n", 1) == 0)
-		break;
-	if (memcmp(start_p - ii, "#", 1) == 0)
-		return FALSE;
-    }
-
-//find target string end point
-     end_p = kstrstr(start_p,"\n");
-     if (end_p == NULL) {       //can't find "\n",but don't care
-          end_p=start_p+strlen(start_p);   //no include "\n"
-       }
-
-   memset(buf2,0,100);
-   memcpy(buf2,start_p,end_p-start_p);    //get the tartget line
-   buf2[end_p-start_p]='\0';
-
-   //find value
-   start_p = kstrstr(buf2,"=");
-   if (start_p == NULL)
-      return FALSE;
-   memset(buf1,0,100);
-   strcpy(buf1,start_p+1);
-
-  //except space
-  tmp_p = buf1;
-  while(*tmp_p != 0x00) {
-  	if(*tmp_p==' ')
-	    tmp_p++;
-         else
-	  break;
-  }
-
-   memcpy(dest,tmp_p,strlen(tmp_p));
- return TRUE;
-}
-
-//if read fail,return NULL,or return data pointer;
-static unsigned char *Config_FileOperation(PSDevice pDevice)
-{
-    unsigned char *config_path = CONFIG_PATH;
-    unsigned char *buffer = NULL;
-    struct file   *filp=NULL;
-    mm_segment_t old_fs = get_fs();
-    //int oldfsuid=0,oldfsgid=0;
-    int result = 0;
-
-    set_fs (KERNEL_DS);
-    /* Can't do this anymore, so we rely on correct filesystem permissions:
-    //Make sure a caller can read or write power as root
-    oldfsuid=current->fsuid;
-    oldfsgid=current->fsgid;
-    current->fsuid = 0;
-    current->fsgid = 0;
-    */
-
-    //open file
-      filp = filp_open(config_path, O_RDWR, 0);
-        if (IS_ERR(filp)) {
-	     printk("Config_FileOperation file Not exist\n");
-	     result=-1;
-             goto error2;
-	  }
-
-     if(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {
-           printk("file %s cann't readable or writable?\n",config_path);
-	  result = -1;
-	  goto error1;
-     	}
-
-    buffer = kmalloc(1024, GFP_KERNEL);
-    if(buffer==NULL) {
-      printk("allocate mem for file fail?\n");
-      result = -1;
-      goto error1;
-    }
-
-    if(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {
-     printk("read file error?\n");
-     result = -1;
-    }
-
-error1:
-  if(filp_close(filp,NULL))
-       printk("Config_FileOperation:close file fail\n");
-
-error2:
-  set_fs (old_fs);
-
-  /*
-  current->fsuid=oldfsuid;
-  current->fsgid=oldfsgid;
-  */
-
-if(result!=0) {
-    kfree(buffer);
-    buffer=NULL;
-}
-  return buffer;
-}
-
-//return --->-1:fail;  >=0:successful
-static int Read_config_file(PSDevice pDevice) {
-  int result = 0;
-  unsigned char tmpbuffer[100];
-  unsigned char *buffer = NULL;
-
-  //init config setting
- pDevice->config_file.ZoneType = -1;
- pDevice->config_file.eAuthenMode = -1;
- pDevice->config_file.eEncryptionStatus = -1;
-
-  buffer = Config_FileOperation(pDevice);
-  if (buffer == NULL) {
-     result =-1;
-     return result;
-  }
-
-//get zonetype
-{
-    memset(tmpbuffer,0,sizeof(tmpbuffer));
-    if(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer) ==TRUE) {
-    if(memcmp(tmpbuffer,"USA",3)==0) {
-      pDevice->config_file.ZoneType=ZoneType_USA;
-    }
-    else if(memcmp(tmpbuffer,"JAPAN",5)==0) {
-      pDevice->config_file.ZoneType=ZoneType_Japan;
-    }
-    else if(memcmp(tmpbuffer,"EUROPE",6)==0) {
-     pDevice->config_file.ZoneType=ZoneType_Europe;
-    }
-    else {
-      printk("Unknown Zonetype[%s]?\n",tmpbuffer);
-   }
- }
-}
-
-//get other parameter
-  {
-	memset(tmpbuffer,0,sizeof(tmpbuffer));
-       if(Config_FileGetParameter("AUTHENMODE",tmpbuffer,buffer)==TRUE) {
-	 pDevice->config_file.eAuthenMode = (int) simple_strtol(tmpbuffer, NULL, 10);
-       }
-
-	memset(tmpbuffer,0,sizeof(tmpbuffer));
-       if(Config_FileGetParameter("ENCRYPTIONMODE",tmpbuffer,buffer)==TRUE) {
-	 pDevice->config_file.eEncryptionStatus= (int) simple_strtol(tmpbuffer, NULL, 10);
-       }
-  }
-
-  kfree(buffer);
-  return result;
-}
-
-static void device_set_multi(struct net_device *dev) {
-    PSDevice         pDevice = (PSDevice) netdev_priv(dev);
-    PSMgmtObject     pMgmt = &(pDevice->sMgmtObj);
-    u32              mc_filter[2];
-    int              ii;
-    struct netdev_hw_addr *ha;
-    BYTE             pbyData[8] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
-    BYTE             byTmpMode = 0;
-    int              rc;
-
-
-	spin_lock_irq(&pDevice->lock);
-    rc = CONTROLnsRequestIn(pDevice,
-                            MESSAGE_TYPE_READ,
-                            MAC_REG_RCR,
-                            MESSAGE_REQUEST_MACREG,
-                            1,
-                            &byTmpMode
-                            );
-    if (rc == 0) pDevice->byRxMode = byTmpMode;
-
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode in= %x\n", pDevice->byRxMode);
-
-    if (dev->flags & IFF_PROMISC) {         // Set promiscuous.
-        DBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
-        // Unconditionally log net taps.
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);
-    }
-    else if ((netdev_mc_count(dev) > pDevice->multicast_limit) ||
-	     (dev->flags & IFF_ALLMULTI)) {
-        CONTROLnsRequestOut(pDevice,
-                            MESSAGE_TYPE_WRITE,
-                            MAC_REG_MAR0,
-                            MESSAGE_REQUEST_MACREG,
-                            8,
-                            pbyData
-                            );
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-    else {
-        memset(mc_filter, 0, sizeof(mc_filter));
-	netdev_for_each_mc_addr(ha, dev) {
-            int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
-            mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
-        }
-        for (ii = 0; ii < 4; ii++) {
-             MACvWriteMultiAddr(pDevice, ii, *((PBYTE)&mc_filter[0] + ii));
-             MACvWriteMultiAddr(pDevice, ii+ 4, *((PBYTE)&mc_filter[1] + ii));
-        }
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-    }
-
-    if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-        // If AP mode, don't enable RCR_UNICAST. Since hw only compare addr1 with local mac.
-        pDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);
-        pDevice->byRxMode &= ~(RCR_UNICAST);
-    }
-    ControlvWriteByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, pDevice->byRxMode);
-    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode out= %x\n", pDevice->byRxMode);
-	spin_unlock_irq(&pDevice->lock);
-
-}
-
-
-static struct net_device_stats *device_get_stats(struct net_device *dev) {
-    PSDevice pDevice=(PSDevice) netdev_priv(dev);
-
-    return &pDevice->stats;
-}
-
-
-static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {
-	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
-    PSMgmtObject        pMgmt = &(pDevice->sMgmtObj);
-    PSCmdRequest        pReq;
-    //BOOL                bCommit = FALSE;
-	struct iwreq *wrq = (struct iwreq *) rq;
-	int                 rc =0;
-
-    if (pMgmt == NULL) {
-        rc = -EFAULT;
-        return rc;
-    }
-
-    switch(cmd) {
-
-	case SIOCGIWNAME:
-		rc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);
-		break;
-
-	case SIOCSIWNWID:
-	case SIOCGIWNWID:     //0x8b03  support
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Set frequency/channel
-	case SIOCSIWFREQ:
-	    rc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Get frequency/channel
-	case SIOCGIWFREQ:
-		rc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);
-		break;
-
-		// Set desired network name (ESSID)
-	case SIOCSIWESSID:
-
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {
-				rc = -E2BIG;
-				break;
-			}
-			if (copy_from_user(essid, wrq->u.essid.pointer,
-					   wrq->u.essid.length)) {
-				rc = -EFAULT;
-				break;
-			}
-			rc = iwctl_siwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
-		}
-		break;
-
-
-		// Get current network name (ESSID)
-	case SIOCGIWESSID:
-
-		{
-			char essid[IW_ESSID_MAX_SIZE+1];
-			if (wrq->u.essid.pointer) {
-				iwctl_giwessid(dev, NULL,
-					    &(wrq->u.essid), essid);
-				if (copy_to_user(wrq->u.essid.pointer,
-						         essid,
-						         wrq->u.essid.length) )
-					rc = -EFAULT;
-			}
-		}
-		break;
-
-	case SIOCSIWAP:
-
-		rc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-
-		// Get current Access Point (BSSID)
-	case SIOCGIWAP:
-		rc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);
-		break;
-
-
-		// Set desired station name
-	case SIOCSIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-		// Get current station name
-	case SIOCGIWNICKN:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-		// Set the desired bit-rate
-	case SIOCSIWRATE:
-		rc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-	// Get the current bit-rate
-	case SIOCGIWRATE:
-		iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);
-		break;
-
-	// Set the desired RTS threshold
-	case SIOCSIWRTS:
-
-		rc = iwctl_siwrts(dev, &(wrq->u.rts));
-		break;
-
-	// Get the current RTS threshold
-	case SIOCGIWRTS:
-
-		rc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);
-		break;
-
-		// Set the desired fragmentation threshold
-	case SIOCSIWFRAG:
-
-		rc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);
-	    break;
-
-	// Get the current fragmentation threshold
-	case SIOCGIWFRAG:
-
-		rc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);
-		break;
-
-		// Set mode of operation
-	case SIOCSIWMODE:
-    	rc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Get mode of operation
-	case SIOCGIWMODE:
-		iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);
-		break;
-
-		// Set WEP keys and mode
-	case SIOCSIWENCODE:
-		{
-            char abyKey[WLAN_WEP232_KEYLEN];
-
-			if (wrq->u.encoding.pointer) {
-
-
-				if (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {
-					rc = -E2BIG;
-					break;
-				}
-				memset(abyKey, 0, WLAN_WEP232_KEYLEN);
-				if (copy_from_user(abyKey,
-				                  wrq->u.encoding.pointer,
-				                  wrq->u.encoding.length)) {
-					rc = -EFAULT;
-					break;
-				}
-			} else if (wrq->u.encoding.length != 0) {
-				rc = -EINVAL;
-				break;
-			}
-			rc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-		}
-		break;
-
-		// Get the WEP keys and mode
-	case SIOCGIWENCODE:
-
-		if (!capable(CAP_NET_ADMIN)) {
-			rc = -EPERM;
-			break;
-		}
-		{
-		    char abyKey[WLAN_WEP232_KEYLEN];
-
-		    rc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);
-		    if (rc != 0) break;
-			if (wrq->u.encoding.pointer) {
-				if (copy_to_user(wrq->u.encoding.pointer,
-						        abyKey,
-						        wrq->u.encoding.length))
-					rc = -EFAULT;
-			}
-		}
-		break;
-
-		// Get the current Tx-Power
-	case SIOCGIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWTXPOW:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");
-        rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCSIWRETRY:
-
-		rc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-	case SIOCGIWRETRY:
-
-		rc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);
-		break;
-
-		// Get range of parameters
-	case SIOCGIWRANGE:
-
-		{
-			struct iw_range range;
-
-			iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);
-			if (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))
-				rc = -EFAULT;
-		}
-
-		break;
-
-	case SIOCGIWPOWER:
-
-		rc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-
-	case SIOCSIWPOWER:
-
-		rc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);
-		break;
-
-
-	case SIOCGIWSENS:
-
-	    rc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);
-		break;
-
-	case SIOCSIWSENS:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-	case SIOCGIWAPLIST:
-	    {
-            char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];
-
-		    if (wrq->u.data.pointer) {
-		        rc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);
-		        if (rc == 0) {
-                    if (copy_to_user(wrq->u.data.pointer,
-					                buffer,
-					               (wrq->u.data.length * (sizeof(struct sockaddr) +  sizeof(struct iw_quality)))
-				        ))
-				    rc = -EFAULT;
-		        }
-            }
-        }
-		break;
-
-
-#ifdef WIRELESS_SPY
-		// Set the spy list
-	case SIOCSIWSPY:
-
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-		// Get the spy list
-	case SIOCGIWSPY:
-
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");
-		rc = -EOPNOTSUPP;
-		break;
-
-#endif // WIRELESS_SPY
-
-	case SIOCGIWPRIV:
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");
-		rc = -EOPNOTSUPP;
-/*
-		if(wrq->u.data.pointer) {
-			wrq->u.data.length = sizeof(iwctl_private_args) / sizeof( iwctl_private_args[0]);
-
-			if(copy_to_user(wrq->u.data.pointer,
-					(u_char *) iwctl_private_args,
-					sizeof(iwctl_private_args)))
-				rc = -EFAULT;
-		}
-*/
-		break;
-
-#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-	case SIOCSIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH\n");
-		rc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCGIWAUTH:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");
-		rc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);
-		break;
-
-	case SIOCSIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");
-		rc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCGIWGENIE:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");
-		rc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-	case SIOCSIWENCODEEXT:
-		{
-			char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
-			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");
-			if(wrq->u.encoding.pointer){
-				memset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);
-				if(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){
-					rc = -E2BIG;
-					break;
-				}
-				if(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){
-					rc = -EFAULT;
-					break;
-				}
-			}else if(wrq->u.encoding.length != 0){
-				rc = -EINVAL;
-				break;
-			}
-			rc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);
-		}
-		break;
-
-	case SIOCGIWENCODEEXT:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");
-		rc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);
-		break;
-
-	case SIOCSIWMLME:
-		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");
-		rc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
-		break;
-
-#endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-
-    case IOCTL_CMD_TEST:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-        pReq = (PSCmdRequest)rq;
-
-   //20080130-01,<Remark> by Mike Liu
-      // if(pDevice->bLinkPass==TRUE)
-          pReq->wResult = MAGIC_CODE;         //Linking status:0x3142
-   //20080130-02,<Remark> by Mike Liu
-      //  else
-      //	 pReq->wResult = MAGIC_CODE+1;    //disconnect status:0x3143
-        break;
-
-    case IOCTL_CMD_SET:
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&
-		       (((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))
-		{
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-	    if (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {
-		    return -EBUSY;
-	    }
-        rc = private_ioctl(pDevice, rq);
-        clear_bit( 0, (void*)&(pMgmt->uCmdBusy));
-        break;
-
-    case IOCTL_CMD_HOSTAPD:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-		rc = vt6656_hostap_ioctl(pDevice, &wrq->u.data);
-        break;
-
-    case IOCTL_CMD_WPA:
-
-		if (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {
-		    rc = -EFAULT;
-		    break;
-		} else {
-		    rc = 0;
-		}
-
-		rc = wpa_ioctl(pDevice, &wrq->u.data);
-        break;
-
-	case SIOCETHTOOL:
-        return ethtool_ioctl(dev, (void *) rq->ifr_data);
-	// All other calls are currently unsupported
-
-	default:
-		rc = -EOPNOTSUPP;
-        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);
-
-
-    }
-
-    if (pDevice->bCommit) {
-       if (pMgmt->eConfigMode == WMAC_CONFIG_AP) {
-           netif_stop_queue(pDevice->dev);
-           spin_lock_irq(&pDevice->lock);
-	bScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);
-           spin_unlock_irq(&pDevice->lock);
-       }
-       else {
-           DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");
-           spin_lock_irq(&pDevice->lock);
-//2007-1121-01<Modify>by EinsnLiu
-	    if (pDevice->bLinkPass &&
-		  memcmp(pMgmt->abyCurrSSID,pMgmt->abyDesireSSID,WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN)) {
-		bScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);
-	     } else {
-           pDevice->bLinkPass = FALSE;
-	   pMgmt->eCurrState = WMAC_STATE_IDLE;
-	   memset(pMgmt->abyCurrBSSID, 0, 6);
-		 }
-           ControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);
-//End Modify
-           netif_stop_queue(pDevice->dev);
-#ifdef  WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
-           pMgmt->eScanType = WMAC_SCAN_ACTIVE;
-	   if (!pDevice->bWPASuppWextEnabled)
-#endif
-		bScheduleCommand((void *) pDevice,
-				 WLAN_CMD_BSSID_SCAN,
-				 pMgmt->abyDesireSSID);
-		bScheduleCommand((void *) pDevice,
-				 WLAN_CMD_SSID,
-				 NULL);
-           spin_unlock_irq(&pDevice->lock);
-      }
-      pDevice->bCommit = FALSE;
-    }
-
-
-    return rc;
-}
-
-
-static int ethtool_ioctl(struct net_device *dev, void *useraddr)
-{
-	u32 ethcmd;
-
-	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
-		return -EFAULT;
-
-        switch (ethcmd) {
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
-		strncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);
-		strncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);
-		if (copy_to_user(useraddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-
-        }
-
-	return -EOPNOTSUPP;
-}
-
-
-/*------------------------------------------------------------------*/
-
-MODULE_DEVICE_TABLE(usb, vt6656_table);
-
-static struct usb_driver vt6656_driver = {
-	.name =		DEVICE_NAME,
-	.probe =	vt6656_probe,
-	.disconnect =	vt6656_disconnect,
-	.id_table =	vt6656_table,
-#ifdef CONFIG_PM
-	.suspend = vt6656_suspend,
-	.resume = vt6656_resume,
-#endif /* CONFIG_PM */
-};
-
-module_usb_driver(vt6656_driver);
diff -urN flo-ElementalX-5.00/drivers/staging/xgifb/XGI_main.h flo-ElementalX-5.00-patched/drivers/staging/xgifb/XGI_main.h
--- flo-ElementalX-5.00/drivers/staging/xgifb/XGI_main.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/staging/xgifb/XGI_main.h	2016-05-10 02:52:00.000000000 +0000
@@ -1,504 +0,0 @@
-#ifndef _XGIFB_MAIN
-#define _XGIFB_MAIN
-
-
-/* ------------------- Constant Definitions ------------------------- */
-
-
-#include "XGIfb.h"
-#include "vb_struct.h"
-#include "../../video/sis/sis.h"
-#include "vb_def.h"
-
-#define XGIFAIL(x) do { printk(x "\n"); return -EINVAL; } while (0)
-
-#ifndef PCI_DEVICE_ID_XGI_41
-#define PCI_DEVICE_ID_XGI_41      0x041
-#endif
-#ifndef PCI_DEVICE_ID_XGI_42
-#define PCI_DEVICE_ID_XGI_42      0x042
-#endif
-#ifndef PCI_DEVICE_ID_XGI_27
-#define PCI_DEVICE_ID_XGI_27      0x027
-#endif
-
-static DEFINE_PCI_DEVICE_TABLE(xgifb_pci_table) = {
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_20)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_27)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_40)},
-	{PCI_DEVICE(PCI_VENDOR_ID_XGI, PCI_DEVICE_ID_XGI_42)},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, xgifb_pci_table);
-
-/* To be included in fb.h */
-#define XGISR			  (xgifb_info->dev_info.P3c4)
-#define XGICR			  (xgifb_info->dev_info.P3d4)
-#define XGIDACA			  (xgifb_info->dev_info.P3c8)
-#define XGIDACD			  (xgifb_info->dev_info.P3c9)
-#define XGIPART1		  (xgifb_info->dev_info.Part1Port)
-#define XGIPART2		  (xgifb_info->dev_info.Part2Port)
-#define XGIPART3		  (xgifb_info->dev_info.Part3Port)
-#define XGIPART4		  (xgifb_info->dev_info.Part4Port)
-#define XGIPART5		  (xgifb_info->dev_info.Part5Port)
-#define XGIDAC2A                  XGIPART5
-#define XGIDAC2D                  (XGIPART5 + 1)
-
-#define IND_XGI_SCRATCH_REG_CR30  0x30  /* CRs */
-#define IND_XGI_SCRATCH_REG_CR31  0x31
-#define IND_XGI_SCRATCH_REG_CR32  0x32
-#define IND_XGI_SCRATCH_REG_CR33  0x33
-#define IND_XGI_LCD_PANEL         0x36
-#define IND_XGI_SCRATCH_REG_CR37  0x37
-
-#define XGI_DRAM_SIZE_MASK     0xF0  /*SR14 */
-#define XGI_DRAM_SIZE_1MB      0x00
-#define XGI_DRAM_SIZE_2MB      0x01
-#define XGI_DRAM_SIZE_4MB      0x02
-#define XGI_DRAM_SIZE_8MB      0x03
-#define XGI_DRAM_SIZE_16MB     0x04
-#define XGI_DRAM_SIZE_32MB     0x05
-#define XGI_DRAM_SIZE_64MB     0x06
-#define XGI_DRAM_SIZE_128MB    0x07
-#define XGI_DRAM_SIZE_256MB    0x08
-
-/* ------------------- Global Variables ----------------------------- */
-
-/* display status */
-static int XGIfb_crt1off;
-static int XGIfb_forcecrt1 = -1;
-
-/* global flags */
-static int XGIfb_tvmode;
-static int enable_dstn;
-static int XGIfb_ypan = -1;
-
-/* TW: CRT2 type (for overriding autodetection) */
-static int XGIfb_crt2type = -1;
-/* PR: Tv plug type (for overriding autodetection) */
-static int XGIfb_tvplug = -1;
-
-/* TW: For ioctl XGIFB_GET_INFO */
-/* XGIfb_info XGIfbinfo; */
-
-#define MD_XGI300 1
-#define MD_XGI315 2
-
-/* mode table */
-static const struct _XGIbios_mode {
-	char name[15];
-	u8 mode_no;
-	u16 vesa_mode_no_1;  /* "XGI defined" VESA mode number */
-	u16 vesa_mode_no_2;  /* Real VESA mode numbers */
-	u16 xres;
-	u16 yres;
-	u16 bpp;
-	u16 rate_idx;
-	u16 cols;
-	u16 rows;
-	u8  chipset;
-} XGIbios_mode[] = {
-	{"320x240x16",   0x56, 0x0000, 0x0000,  320,  240, 16, 1,  40, 15,
-	 MD_XGI315},
-	{"320x480x8",    0x5A, 0x0000, 0x0000,  320,  480,  8, 1,  40, 30,
-	 MD_XGI315},  /* TW: FSTN */
-	{"320x480x16",   0x5B, 0x0000, 0x0000,  320,  480, 16, 1,  40, 30,
-	 MD_XGI315},  /* TW: FSTN */
-	{"640x480x8",    0x2E, 0x0101, 0x0101,  640,  480,  8, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"640x480x16",   0x44, 0x0111, 0x0111,  640,  480, 16, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"640x480x24",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},  /* TW: That's for people who mix up color-
-					and fb depth */
-	{"640x480x32",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x8",    0x31, 0x0000, 0x0000,  720,  480,  8, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x16",   0x33, 0x0000, 0x0000,  720,  480, 16, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x24",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x480x32",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x8",    0x32, 0x0000, 0x0000,  720,  576,  8, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x16",   0x34, 0x0000, 0x0000,  720,  576, 16, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x24",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"720x576x32",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x8",    0x70, 0x0000, 0x0000,  800,  480,  8, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x16",   0x7a, 0x0000, 0x0000,  800,  480, 16, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x24",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x480x32",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x8",    0x30, 0x0103, 0x0103,  800,  600,  8, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-#define DEFAULT_MODE              20 /* index for 800x600x16 */
-	{"800x600x16",   0x47, 0x0114, 0x0114,  800,  600, 16, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x24",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"800x600x32",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x8",   0x71, 0x0000, 0x0000, 1024,  576,  8, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x16",  0x74, 0x0000, 0x0000, 1024,  576, 16, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x24",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x576x32",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36,
-	 MD_XGI300|MD_XGI315},
-	{"1024x600x8",   0x20, 0x0000, 0x0000, 1024,  600,  8, 1, 128, 37,
-	 MD_XGI300          },  /* TW: 300 series only */
-	{"1024x600x16",  0x21, 0x0000, 0x0000, 1024,  600, 16, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x600x24",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x600x32",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37,
-	 MD_XGI300          },
-	{"1024x768x8",   0x38, 0x0105, 0x0105, 1024,  768,  8, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x16",  0x4A, 0x0117, 0x0117, 1024,  768, 16, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x24",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1024x768x32",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48,
-	 MD_XGI300|MD_XGI315},
-	{"1152x768x8",   0x23, 0x0000, 0x0000, 1152,  768,  8, 1, 144, 48,
-	 MD_XGI300          },  /* TW: 300 series only */
-	{"1152x768x16",  0x24, 0x0000, 0x0000, 1152,  768, 16, 1, 144, 48,
-	 MD_XGI300          },
-	{"1152x768x24",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48,
-	 MD_XGI300          },
-	{"1152x768x32",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48,
-	 MD_XGI300          },
-	{"1280x720x8",   0x79, 0x0000, 0x0000, 1280,  720,  8, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x16",  0x75, 0x0000, 0x0000, 1280,  720, 16, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x24",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x720x32",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45,
-	 MD_XGI300|MD_XGI315},
-	{"1280x768x8",   0x23, 0x0000, 0x0000, 1280,  768,  8, 1, 160, 48,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"1280x768x16",  0x24, 0x0000, 0x0000, 1280,  768, 16, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x768x24",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x768x32",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,
-	 MD_XGI315},
-	{"1280x960x8",   0x7C, 0x0000, 0x0000, 1280,  960,  8, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x16",  0x7D, 0x0000, 0x0000, 1280,  960, 16, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x24",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x960x32",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x8",  0x3A, 0x0107, 0x0107, 1280, 1024,  8, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x16", 0x4D, 0x011a, 0x011a, 1280, 1024, 16, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x24", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1280x1024x32", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64,
-	 MD_XGI300|MD_XGI315},
-	{"1400x1050x8",  0x26, 0x0000, 0x0000, 1400, 1050,  8, 1, 175, 65,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"1400x1050x16", 0x27, 0x0000, 0x0000, 1400, 1050, 16, 1, 175, 65,
-	 MD_XGI315},
-	{"1400x1050x24", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,
-	 MD_XGI315},
-	{"1400x1050x32", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,
-	 MD_XGI315},
-	{"1600x1200x8",  0x3C, 0x0130, 0x011c, 1600, 1200,  8, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x16", 0x3D, 0x0131, 0x011e, 1600, 1200, 16, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x24", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1600x1200x32", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x8",  0x68, 0x013f, 0x0000, 1920, 1440,  8, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x16", 0x69, 0x0140, 0x0000, 1920, 1440, 16, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x24", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"1920x1440x32", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75,
-	 MD_XGI300|MD_XGI315},
-	{"2048x1536x8",  0x6c, 0x0000, 0x0000, 2048, 1536,  8, 1, 256, 96,
-	 MD_XGI315},  /* TW: 310/325 series only */
-	{"2048x1536x16", 0x6d, 0x0000, 0x0000, 2048, 1536, 16, 1, 256, 96,
-	 MD_XGI315},
-	{"2048x1536x24", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,
-	 MD_XGI315},
-	{"2048x1536x32", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,
-	 MD_XGI315},
-	{"\0", 0x00, 0, 0, 0, 0, 0, 0, 0}
-};
-
-/* TW: CR36 evaluation */
-static const unsigned short XGI300paneltype[] = {
-	 LCD_UNKNOWN,  LCD_800x600, LCD_1024x768, LCD_1280x1024,
-	LCD_1280x960,  LCD_640x480, LCD_1024x600, LCD_1152x768,
-	LCD_1024x768, LCD_1024x768, LCD_1024x768,
-	LCD_1024x768, LCD_1024x768, LCD_1024x768, LCD_1024x768};
-
-static const unsigned short XGI310paneltype[] = {
-	 LCD_UNKNOWN,   LCD_800x600, LCD_1024x768, LCD_1280x1024,
-	 LCD_640x480,  LCD_1024x600, LCD_1152x864, LCD_1280x960,
-	LCD_1152x768, LCD_1400x1050, LCD_1280x768, LCD_1600x1200,
-	LCD_1024x768,  LCD_1024x768, LCD_1024x768};
-
-static const struct _XGI_crt2type {
-	char name[10];
-	int type_no;
-	int tvplug_no;
-} XGI_crt2type[] = {
-	{"NONE",	0,		-1},
-	{"LCD",		XGIFB_DISP_LCD,	-1},
-	{"TV",		XGIFB_DISP_TV,	-1},
-	{"VGA",		XGIFB_DISP_CRT,	-1},
-	{"SVIDEO",	XGIFB_DISP_TV,	TVPLUG_SVIDEO},
-	{"COMPOSITE",	XGIFB_DISP_TV,	TVPLUG_COMPOSITE},
-	{"SCART",	XGIFB_DISP_TV,	TVPLUG_SCART},
-	{"none",	0,		-1},
-	{"lcd",		XGIFB_DISP_LCD,	-1},
-	{"tv",		XGIFB_DISP_TV,	-1},
-	{"vga",		XGIFB_DISP_CRT,	-1},
-	{"svideo",	XGIFB_DISP_TV,	TVPLUG_SVIDEO},
-	{"composite",	XGIFB_DISP_TV,	TVPLUG_COMPOSITE},
-	{"scart",	XGIFB_DISP_TV,	TVPLUG_SCART},
-	{"\0",		-1,		-1}
-};
-
-/* TV standard */
-static const struct _XGI_tvtype {
-	char name[6];
-	int type_no;
-} XGI_tvtype[] = {
-	{"PAL",		1},
-	{"NTSC",	2},
-	{"pal",		1},
-	{"ntsc",	2},
-	{"\0",		-1}
-};
-
-static const struct _XGI_vrate {
-	u16 idx;
-	u16 xres;
-	u16 yres;
-	u16 refresh;
-} XGIfb_vrate[] = {
-	{1,  640,  480, 60}, {2,  640,  480,  72},
-	{3, 640,   480,  75}, {4,  640, 480,  85},
-
-	{5,  640,  480, 100}, {6,  640,  480, 120},
-	{7, 640,   480, 160}, {8,  640, 480, 200},
-
-	{1,  720,  480, 60},
-	{1,  720,  576, 58},
-	{1,  800,  480, 60}, {2,  800,  480,  75}, {3, 800,   480,  85},
-	{1,  800,  600,  60}, {2, 800,   600,  72}, {3,  800, 600,  75},
-	{4,  800,  600, 85}, {5,  800,  600, 100},
-	{6, 800,   600, 120}, {7,  800, 600, 160},
-
-	{1, 1024,  768,  60}, {2, 1024,  768,  70}, {3, 1024, 768,  75},
-	{4, 1024,  768, 85}, {5, 1024,  768, 100}, {6, 1024,  768, 120},
-	{1, 1024,  576, 60}, {2, 1024,  576,  75}, {3, 1024,  576,  85},
-	{1, 1024,  600, 60},
-	{1, 1152,  768, 60},
-	{1, 1280,  720, 60}, {2, 1280,  720,  75}, {3, 1280,  720,  85},
-	{1, 1280,  768, 60},
-	{1, 1280, 1024,  60}, {2, 1280, 1024,  75}, {3, 1280, 1024,  85},
-	{1, 1280,  960, 70},
-	{1, 1400, 1050, 60},
-	{1, 1600, 1200, 60}, {2, 1600, 1200,  65},
-	{3, 1600, 1200,  70}, {4, 1600, 1200,  75},
-
-	{5, 1600, 1200, 85}, {6, 1600, 1200, 100},
-	{7, 1600, 1200, 120},
-
-	{1, 1920, 1440, 60}, {2, 1920, 1440,  65},
-	{3, 1920, 1440,  70}, {4, 1920, 1440,  75},
-
-	{5, 1920, 1440, 85}, {6, 1920, 1440, 100},
-	{1, 2048, 1536, 60}, {2, 2048, 1536,  65},
-	{3, 2048, 1536,  70}, {4, 2048, 1536,  75},
-
-	{5, 2048, 1536, 85},
-	{0, 0, 0, 0}
-};
-
-static const struct _chswtable {
-	int subsysVendor;
-	int subsysCard;
-	char *vendorName;
-	char *cardName;
-} mychswtable[] = {
-	{ 0x1631, 0x1002, "Mitachi", "0x1002" },
-	{ 0,      0,      ""       , ""       }
-};
-
-/* Eden Chen */
-static const struct _XGI_TV_filter {
-	u8 filter[9][4];
-} XGI_TV_filter[] = {
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_0 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_1 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_2 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xF6, 0x06, 0x1A, 0x14},
-	    {0xFA, 0x06, 0x16, 0x14},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_3 */
-	    {0xF1, 0x04, 0x1F, 0x18},
-	    {0xEE, 0x0D, 0x22, 0x06},
-	    {0xF7, 0x06, 0x19, 0x14},
-	    {0xF4, 0x0B, 0x1C, 0x0A},
-	    {0xFA, 0x07, 0x16, 0x12},
-	    {0xF9, 0x0A, 0x17, 0x0C},
-	    {0x00, 0x07, 0x10, 0x12},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_4 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_5 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xF6, 0x06, 0x1A, 0x14},
-	    {0xFA, 0x06, 0x16, 0x14},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_6 */
-	    {0xEB, 0x04, 0x25, 0x18},
-	    {0xE7, 0x0E, 0x29, 0x04},
-	    {0xEE, 0x0C, 0x22, 0x08},
-	    {0xF6, 0x0B, 0x1A, 0x0A},
-	    {0xF9, 0x0A, 0x17, 0x0C},
-	    {0xFC, 0x0A, 0x14, 0x0C},
-	    {0x00, 0x08, 0x10, 0x10},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* NTSCFilter_7 */
-	    {0xEC, 0x02, 0x24, 0x1C},
-	    {0xF2, 0x04, 0x1E, 0x18},
-	    {0xEB, 0x15, 0x25, 0xF6},
-	    {0xF4, 0x10, 0x1C, 0x00},
-	    {0xF8, 0x0F, 0x18, 0x02},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0x01, 0x06, 0x0F, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_0 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_1 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_2 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xF1, 0xF7, 0x01, 0x32},
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xF9, 0xFF, 0x17, 0x22},
-	    {0xFB, 0x01, 0x15, 0x1E},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_3 */
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xEE, 0xFE, 0x22, 0x24},
-	    {0xF3, 0x00, 0x1D, 0x20},
-	    {0xF9, 0x03, 0x17, 0x1A},
-	    {0xFB, 0x02, 0x14, 0x1E},
-	    {0xFB, 0x04, 0x15, 0x18},
-	    {0x00, 0x06, 0x10, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_4 */
-	    {0x00, 0xE0, 0x10, 0x60},
-	    {0x00, 0xEE, 0x10, 0x44},
-	    {0x00, 0xF4, 0x10, 0x38},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0x00, 0x00, 0x10, 0x20},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_5 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xF1, 0xF7, 0x1F, 0x32},
-	    {0xF5, 0xFB, 0x1B, 0x2A},
-	    {0xF9, 0xFF, 0x17, 0x22},
-	    {0xFB, 0x01, 0x15, 0x1E},
-	    {0x00, 0x04, 0x10, 0x18},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_6 */
-	    {0xF5, 0xEE, 0x1B, 0x2A},
-	    {0xEE, 0xFE, 0x22, 0x24},
-	    {0xF3, 0x00, 0x1D, 0x20},
-	    {0xF9, 0x03, 0x17, 0x1A},
-	    {0xFB, 0x02, 0x14, 0x1E},
-	    {0xFB, 0x04, 0x15, 0x18},
-	    {0x00, 0x06, 0x10, 0x14},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } },
-	{ { {0x00, 0x00, 0x00, 0x40},  /* PALFilter_7 */
-	    {0xF5, 0xEE, 0x1B, 0x44},
-	    {0xF8, 0xF4, 0x18, 0x38},
-	    {0xFC, 0xFB, 0x14, 0x2A},
-	    {0xEB, 0x05, 0x25, 0x16},
-	    {0xF1, 0x05, 0x1F, 0x16},
-	    {0xFA, 0x07, 0x16, 0x12},
-	    {0x00, 0x07, 0x10, 0x12},
-	    {0xFF, 0xFF, 0xFF, 0xFF} } }
-};
-
-static int           filter = -1;
-
-#endif
diff -urN flo-ElementalX-5.00/drivers/usb/host/ehci-sched.c flo-ElementalX-5.00-patched/drivers/usb/host/ehci-sched.c
--- flo-ElementalX-5.00/drivers/usb/host/ehci-sched.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/usb/host/ehci-sched.c	2016-06-01 16:28:43.000000000 +0000
@@ -829,7 +829,7 @@
 {
 	int		status;
 	unsigned	uframe;
-	__hc32		c_mask = 0;
+	__hc32		c_mask;
 	unsigned	frame;		/* 0..(qh->period - 1), or NO_FRAME */
 	struct ehci_qh_hw	*hw = qh->hw;
 
diff -urN flo-ElementalX-5.00/drivers/usb/otg/otg-wakelock.c flo-ElementalX-5.00-patched/drivers/usb/otg/otg-wakelock.c
--- flo-ElementalX-5.00/drivers/usb/otg/otg-wakelock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/usb/otg/otg-wakelock.c	2016-05-10 02:52:00.000000000 +0000
@@ -1,170 +0,0 @@
-/*
- * otg-wakelock.c
- *
- * Copyright (C) 2011 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/notifier.h>
-#include <linux/wakelock.h>
-#include <linux/spinlock.h>
-#include <linux/usb/otg.h>
-
-#define TEMPORARY_HOLD_TIME	2000
-
-static bool enabled = true;
-static struct usb_phy *otgwl_xceiv;
-static struct notifier_block otgwl_nb;
-
-/*
- * otgwl_spinlock is held while the VBUS lock is grabbed or dropped and the
- * held field is updated to match.
- */
-
-static DEFINE_SPINLOCK(otgwl_spinlock);
-
-/*
- * Only one lock, but since these 3 fields are associated with each other...
- */
-
-struct otgwl_lock {
-	char name[40];
-	struct wake_lock wakelock;
-	bool held;
-};
-
-/*
- * VBUS present lock.  Also used as a timed lock on charger
- * connect/disconnect and USB host disconnect, to allow the system
- * to react to the change in power.
- */
-
-static struct otgwl_lock vbus_lock;
-
-static void otgwl_hold(struct otgwl_lock *lock)
-{
-	if (!lock->held) {
-		wake_lock(&lock->wakelock);
-		lock->held = true;
-	}
-}
-
-static void otgwl_temporary_hold(struct otgwl_lock *lock)
-{
-	wake_lock_timeout(&lock->wakelock,
-			  msecs_to_jiffies(TEMPORARY_HOLD_TIME));
-	lock->held = false;
-}
-
-static void otgwl_drop(struct otgwl_lock *lock)
-{
-	if (lock->held) {
-		wake_unlock(&lock->wakelock);
-		lock->held = false;
-	}
-}
-
-static void otgwl_handle_event(unsigned long event)
-{
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&otgwl_spinlock, irqflags);
-
-	if (!enabled) {
-		otgwl_drop(&vbus_lock);
-		spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
-		return;
-	}
-
-	switch (event) {
-	case USB_EVENT_VBUS:
-	case USB_EVENT_ENUMERATED:
-		otgwl_hold(&vbus_lock);
-		break;
-
-	case USB_EVENT_NONE:
-	case USB_EVENT_ID:
-	case USB_EVENT_CHARGER:
-		otgwl_temporary_hold(&vbus_lock);
-		break;
-
-	default:
-		break;
-	}
-
-	spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
-}
-
-static int otgwl_otg_notifications(struct notifier_block *nb,
-				   unsigned long event, void *unused)
-{
-	otgwl_handle_event(event);
-	return NOTIFY_OK;
-}
-
-static int set_enabled(const char *val, const struct kernel_param *kp)
-{
-	int rv = param_set_bool(val, kp);
-
-	if (rv)
-		return rv;
-
-	if (otgwl_xceiv)
-		otgwl_handle_event(otgwl_xceiv->last_event);
-
-	return 0;
-}
-
-static struct kernel_param_ops enabled_param_ops = {
-	.set = set_enabled,
-	.get = param_get_bool,
-};
-
-module_param_cb(enabled, &enabled_param_ops, &enabled, 0644);
-MODULE_PARM_DESC(enabled, "enable wakelock when VBUS present");
-
-static int __init otg_wakelock_init(void)
-{
-	int ret;
-
-	otgwl_xceiv = usb_get_transceiver();
-
-	if (!otgwl_xceiv) {
-		pr_err("%s: No USB transceiver found\n", __func__);
-		return -ENODEV;
-	}
-
-	snprintf(vbus_lock.name, sizeof(vbus_lock.name), "vbus-%s",
-		 dev_name(otgwl_xceiv->dev));
-	wake_lock_init(&vbus_lock.wakelock, WAKE_LOCK_SUSPEND,
-		       vbus_lock.name);
-
-	otgwl_nb.notifier_call = otgwl_otg_notifications;
-	ret = usb_register_notifier(otgwl_xceiv, &otgwl_nb);
-
-	if (ret) {
-		pr_err("%s: usb_register_notifier on transceiver %s"
-		       " failed\n", __func__,
-		       dev_name(otgwl_xceiv->dev));
-		otgwl_xceiv = NULL;
-		wake_lock_destroy(&vbus_lock.wakelock);
-		return ret;
-	}
-
-	otgwl_handle_event(otgwl_xceiv->last_event);
-	return ret;
-}
-
-late_initcall(otg_wakelock_init);
diff -urN flo-ElementalX-5.00/drivers/video/console/fbcon.c flo-ElementalX-5.00-patched/drivers/video/console/fbcon.c
--- flo-ElementalX-5.00/drivers/video/console/fbcon.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/console/fbcon.c	2014-12-03 03:07:30.000000000 +0000
@@ -3570,7 +3570,7 @@
 	return 0;
 }
 
-module_init(fb_console_init);
+late_initcall(fb_console_init);
 
 #ifdef MODULE
 
diff -urN flo-ElementalX-5.00/drivers/video/msm/Kconfig flo-ElementalX-5.00-patched/drivers/video/msm/Kconfig
--- flo-ElementalX-5.00/drivers/video/msm/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/Kconfig	2016-06-02 00:51:30.000000000 +0000
@@ -687,6 +687,9 @@
 config FB_MSM_DEFAULT_DEPTH_ARGB8888
 	bool "32 bits per pixel (ARGB8888)"
 
+config FB_MSM_DEFAULT_DEPTH_BGRA8888
+	bool "32 bits per pixel (BGRA8888) (actually ARGB/xRGB)"
+	
 config FB_MSM_DEFAULT_DEPTH_RGBA8888
 	bool "32 bits per pixel (RGBA8888)"
 
diff -urN flo-ElementalX-5.00/drivers/video/msm/mdp4_overlay.c flo-ElementalX-5.00-patched/drivers/video/msm/mdp4_overlay.c
--- flo-ElementalX-5.00/drivers/video/msm/mdp4_overlay.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/mdp4_overlay.c	2014-12-03 11:07:31.000000000 +0000
@@ -3045,10 +3045,10 @@
 		 ib_quota_total, perf_req->mdp_ib_bw);
 
 	if (ab_quota_total > mdp_max_bw)
-		pr_debug("%s: req ab bw=%llu is larger than max bw=%llu",
+		pr_warn("%s: req ab bw=%llu is larger than max bw=%llu",
 			__func__, ab_quota_total, mdp_max_bw);
 	if (ib_quota_total > mdp_max_bw)
-		pr_debug("%s: req ib bw=%llu is larger than max bw=%llu",
+		pr_warn("%s: req ib bw=%llu is larger than max bw=%llu",
 			__func__, ib_quota_total, mdp_max_bw);
 
 	pr_debug("%s %d: pid %d cnt %d clk %d ov0_blt %d, ov1_blt %d\n",
diff -urN flo-ElementalX-5.00/drivers/video/msm/mdss/mdss_fb.c flo-ElementalX-5.00-patched/drivers/video/msm/mdss/mdss_fb.c
--- flo-ElementalX-5.00/drivers/video/msm/mdss/mdss_fb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/mdss/mdss_fb.c	2014-12-03 11:07:31.000000000 +0000
@@ -741,6 +741,25 @@
 		bpp = 4;
 		break;
 
+	case MDP_BGRA_8888:
+		fix->type = FB_TYPE_PACKED_PIXELS;
+		fix->xpanstep = 1;
+		fix->ypanstep = 1;
+		var->vmode = FB_VMODE_NONINTERLACED;
+		var->blue.offset = 16;
+		var->green.offset = 8;
+		var->red.offset = 0;
+		var->blue.length = 8;
+		var->green.length = 8;
+		var->red.length = 8;
+		var->blue.msb_right = 0;
+		var->green.msb_right = 0;
+		var->red.msb_right = 0;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		bpp = 4;
+		break;
+
 	case MDP_YCRYCB_H2V1:
 		fix->type = FB_TYPE_INTERLEAVED_PLANES;
 		fix->xpanstep = 2;
@@ -1060,10 +1079,14 @@
 		break;
 
 	case 32:
-		if (var->transp.offset == 24)
+		if (var->transp.offset == 24) {
+			if (var->red.offset == 16)
+				mfd->fb_imgType	= MDP_BGRA_8888;
+			else
+				mfd->fb_imgType = MDP_RGBA_8888;
+		} else {
 			mfd->fb_imgType = MDP_ARGB_8888;
-		else
-			mfd->fb_imgType	= MDP_RGBA_8888;
+		}
 		break;
 
 	default:
diff -urN flo-ElementalX-5.00/drivers/video/msm/msm_fb.c flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb.c
--- flo-ElementalX-5.00/drivers/video/msm/msm_fb.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb.c	2014-12-03 11:07:31.000000000 +0000
@@ -46,7 +46,6 @@
 #include <linux/sync.h>
 #include <linux/sw_sync.h>
 #include <linux/file.h>
-#include <linux/moduleparam.h>
 
 #define MSM_FB_C
 #include "msm_fb.h"
@@ -63,9 +62,6 @@
 #undef CONFIG_HAS_EARLYSUSPEND
 #endif
 
-int backlight_dimmer = 0;
-module_param(backlight_dimmer, int, 0755);
-
 static unsigned char *fbram;
 static unsigned char *fbram_phys;
 static int fbram_size;
@@ -204,21 +200,11 @@
 		bl_lvl = 0;
 	else if (value >= MAX_BACKLIGHT_BRIGHTNESS)
 		bl_lvl = mfd->panel_info.bl_max;
-	else if (backlight_dimmer > 0) {
-		if (value <= backlight_dimmer) {
-			bl_lvl = 1;
-		} else {
-			bl_lvl = (mfd->panel_info.bl_min + ((value - 1) * 2 *
-				(mfd->panel_info.bl_max - mfd->panel_info.bl_min) +
-				MAX_BACKLIGHT_BRIGHTNESS - 1) /
-				(MAX_BACKLIGHT_BRIGHTNESS - 1) / 2) - backlight_dimmer;
-		}
-	} else {
+	else
 		bl_lvl = mfd->panel_info.bl_min + ((value - 1) * 2 *
 			(mfd->panel_info.bl_max - mfd->panel_info.bl_min) +
 			MAX_BACKLIGHT_BRIGHTNESS - 1) /
 			(MAX_BACKLIGHT_BRIGHTNESS - 1) / 2;
-	}
 
 	down(&mfd->sem);
 	msm_fb_set_backlight(mfd, bl_lvl);
@@ -1366,6 +1352,25 @@
 		bpp = 4;
 		break;
 
+	case MDP_BGRA_8888:
+		fix->type = FB_TYPE_PACKED_PIXELS;
+		fix->xpanstep = 1;
+		fix->ypanstep = 1;
+		var->vmode = FB_VMODE_NONINTERLACED;
+		var->blue.offset = 16;
+		var->green.offset = 8;
+		var->red.offset = 0;
+		var->blue.length = 8;
+		var->green.length = 8;
+		var->red.length = 8;
+		var->blue.msb_right = 0;
+		var->green.msb_right = 0;
+		var->red.msb_right = 0;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		bpp = 4;
+		break;
+
 	case MDP_YCRYCB_H2V1:
 		/* ToDo: need to check TV-Out YUV422i framebuffer format */
 		/*       we might need to create new type define */
@@ -1618,11 +1623,6 @@
 	    ("FrameBuffer[%d] %dx%d size=%d bytes is registered successfully!\n",
 	     mfd->index, fbi->var.xres, fbi->var.yres, fbi->fix.smem_len);
 
-#ifdef CONFIG_UPDATE_LCDC_LUT
-	if (msm_fb_pdata->update_lcdc_lut)
-		msm_fb_pdata->update_lcdc_lut();
-#endif
-
 #ifdef CONFIG_FB_MSM_LOGO
 	/* Flip buffer */
 	if (!load_565rle_image(INIT_IMAGE_FILE, bf_supported))
@@ -2342,11 +2342,15 @@
 		break;
 
 	case 32:
-		if (var->transp.offset == 24)
+		if (var->transp.offset == 24) {
+			if (var->red.offset == 16)
+				mfd->fb_imgType	= MDP_BGRA_8888;
+			else
+				mfd->fb_imgType = MDP_RGBA_8888;
+		} else {
 			mfd->fb_imgType = MDP_ARGB_8888;
-		else
-			mfd->fb_imgType = MDP_RGBA_8888;
-		break;
+		}
+	break;
 
 	default:
 		return -EINVAL;
@@ -4068,6 +4072,10 @@
 		ret = msm_fb_resume_sw_refresher(mfd);
 		break;
 
+    case FBIO_WAITFORVSYNC:
+        ret = mdp4_overlay_wait4vsync(info);
+        break;
+
 	case MSMFB_CURSOR:
 		ret = copy_from_user(&cursor, argp, sizeof(cursor));
 		if (ret)
diff -urN flo-ElementalX-5.00/drivers/video/msm/msm_fb_def.h flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb_def.h
--- flo-ElementalX-5.00/drivers/video/msm/msm_fb_def.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/video/msm/msm_fb_def.h	2014-12-03 11:07:31.000000000 +0000
@@ -92,6 +92,8 @@
 #define MSMFB_DEFAULT_TYPE MDP_ARGB_8888
 #elif defined(CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888)
 #define MSMFB_DEFAULT_TYPE MDP_RGBA_8888
+#elif defined(CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888)
+#define MSMFB_DEFAULT_TYPE MDP_BGRA_8888
 #else
 #define MSMFB_DEFAULT_TYPE MDP_RGB_565
 #endif
diff -urN flo-ElementalX-5.00/fs/proc/namespaces.c flo-ElementalX-5.00-patched/fs/proc/namespaces.c
--- flo-ElementalX-5.00/fs/proc/namespaces.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/fs/proc/namespaces.c	2016-06-01 15:49:17.000000000 +0000
@@ -24,9 +24,9 @@
 #ifdef CONFIG_IPC_NS
 	&ipcns_operations,
 #endif
-#ifdef CONFIG_PID_NS
-	&pidns_operations,
-#endif
+//#ifdef CONFIG_PID_NS
+//	&pidns_operations,
+//#endif
 	&mntns_operations,
 };
 
diff -urN flo-ElementalX-5.00/include/config/auto.conf flo-ElementalX-5.00-patched/include/config/auto.conf
--- flo-ElementalX-5.00/include/config/auto.conf	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/auto.conf	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,1369 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_RING_BUFFER=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SCSI_DMA=y
+CONFIG_MSM_VIDC_VENC=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_RFS_ACCEL=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_CRC32=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_HAVE_AOUT=y
+CONFIG_VFP=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_AEABI=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SECCOMP=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_MSM_REMOTE_SPINLOCK_SFPB=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+CONFIG_MSM_IPC_ROUTER_SECURITY=y
+CONFIG_KERNEL_MSM_CONTIG_MEM_REGION=y
+CONFIG_BT_RFCOMM=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_INOTIFY_USER=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_RC_CORE=y
+CONFIG_BATTERY_ASUS_BQ27541=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_BINFMT_MISC=y
+CONFIG_MSM_BT_POWER=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_UHID=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_FSNOTIFY=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_INET6_TUNNEL=y
+CONFIG_USB_SUSPEND=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_HIDRAW=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_USB_HSIC_SMSC_HUB=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX=y
+CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_MSM_SMP=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_USB_EHCI_MSM_HOST4=y
+CONFIG_MSM_PM8X60=y
+CONFIG_FIB_RULES=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_HID_EMS_FF=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_IPV6=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_BQL=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_USB_DEVICEFS=y
+CONFIG_DEVTMPFS=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_WLAN=y
+CONFIG_NAMESPACES=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_SENSORS_CAP1106=y
+CONFIG_SMUX_CTL=y
+CONFIG_ATAGS_PROC=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_TUN=y
+CONFIG_USB_OTG_UTILS=y
+CONFIG_CFG80211=y
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_DM_CRYPT=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_HID_BELKIN=y
+CONFIG_VIDEO_IR_I2C=y
+CONFIG_MSM_XO=y
+CONFIG_FB_MSM_OVERLAY1_WRITEBACK=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_HID_ACRUX=y
+CONFIG_RD_LZMA=y
+CONFIG_USB=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_ETHERNET=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_DQL=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_TCP_CONG_LP=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_HID_CHERRY=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_MSM_PCIE=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_PICOLCD=y
+CONFIG_BCMA_POSSIBLE=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_VGA_ARB=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_SND_SOC=y
+CONFIG_SYNC=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_PRINTK=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_TIMERFD=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_FB_MSM_MIPI_DSI_NOVATEK=y
+CONFIG_DNS_RESOLVER=y
+CONFIG_TRACEPOINTS=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_IRDA=y
+CONFIG_BOUNCE=y
+CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
+CONFIG_SHMEM=y
+CONFIG_MIGRATION=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_HID_PRIMAX=y
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DNOTIFY=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_SND_SOC_CS8427=y
+CONFIG_CRYPTO_DES=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_MSM_SMD=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_NET_CLS_U32=y
+CONFIG_EXPORTFS=y
+CONFIG_ARM_GIC=y
+CONFIG_SERIO=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+CONFIG_MSM7X00A_USE_GP_TIMER=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_MA600_DONGLE=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_MSM_QDSP6_APR=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_I2C_QUP=y
+CONFIG_MFD_PM8XXX=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ENCRYPTED_KEYS=y
+CONFIG_HWMON=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_MSM_KRAIT_WFE_FIXUP=y
+CONFIG_STM_LIS3DH=y
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_MSM_L2_ERP_2BIT_PANIC=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_MSM_LPASS_8960=y
+CONFIG_PM_CLK=y
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_FB_MSM_DTV=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_CPU_VOLTAGE_TABLE=y
+CONFIG_SLIMPORT_ANX7808=y
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_LOCKD=y
+CONFIG_GPIO_PM8XXX=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ARM=y
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_HID_SAITEK=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_RPCSEC_GSS_KRB5=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_SPS_SUPPORT_BAMDMA=y
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_KERNEL_XZ=y
+CONFIG_USB_STORAGE=y
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_BOARD_HEADER_FILE=""
+CONFIG_STANDALONE=y
+CONFIG_SCHED_MC=y
+CONFIG_SPI_QUP=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_IR_LIRC_CODEC=y
+CONFIG_DONGLE=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_FB_MSM_EXT_INTERFACE_COMMON=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_ASHMEM=y
+CONFIG_BLOCK=y
+CONFIG_HAVE_IDE=y
+CONFIG_HID_APPLE=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_EXFAT_FS=y
+CONFIG_INPUT_MPU3050=y
+CONFIG_MSM_VIDC_1080P=y
+CONFIG_USER_NS=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_ASUSTEK_HEADSET=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_BUG=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_PM=y
+CONFIG_MACH_ASUSTEK=y
+CONFIG_SPI=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_SWITCH=y
+CONFIG_DEVKMEM=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_PPP_DEFLATE=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_VT=y
+CONFIG_USB_NET_NET1080=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_HID_TIVO=y
+CONFIG_REGMAP_SPI=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MFD_PM8038_CORE=y
+CONFIG_MSM_PIL_TZAPPS=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_WEXT_CORE=y
+CONFIG_MSM_DSPS=y
+CONFIG_NLS=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_SENSORS_PM8XXX_ADC=y
+CONFIG_PPPOE=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_IRQ_WORK=y
+CONFIG_PCI_MSI=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_CLEANCACHE=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_DIAG_OVER_USB=y
+CONFIG_USB_COMMON=y
+CONFIG_TASK_XACCT=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+CONFIG_INET_IPCOMP=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_EVENT_TRACING=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_CYPRESS=y
+CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
+CONFIG_FB_MSM_MIPI_DSI_JDI=y
+CONFIG_MSM_AUDIO_QDSP6=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_PPP_MPPE=y
+CONFIG_USB_IRDA=y
+CONFIG_RFKILL=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_KEY=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_MSM_SSBI=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_EVENTFD=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_IPV6_SIT=y
+CONFIG_XFRM=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT=y
+CONFIG_MSM_WFD=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_MMC_MSM_SDC1_SUPPORT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_CRYPTO_LZ4=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_RD_LZO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_HID_LCPOWER=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_PM_DEBUG=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_BT_HCISMD=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_MSM_AVS_HW=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MSM_QDSP6_CODECS=y
+CONFIG_INPUT_LID=y
+CONFIG_NET_VENDOR_RDC=y
+CONFIG_CPUSETS=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_MSM_PIL_VIDC=y
+CONFIG_MSM_DMA_TEST=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_FAT_FS=y
+CONFIG_WCD9304_CODEC=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HIGHMEM=y
+CONFIG_SPS=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED=y
+CONFIG_INET_TUNNEL=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_EEPROM_93CX6=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_LIB80211=y
+CONFIG_MFD_CORE=y
+CONFIG_REGULATOR_MSM_GPIO=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_STOP_MACHINE=y
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_SND_SOC_QDSP6=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_CPU_FREQ=y
+CONFIG_MSM_KGSL_DRM=y
+CONFIG_USB_GSPCA=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_NLS_ASCII=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_USB_CSW_HACK=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_USB_NET_CDC_SUBSET=y
+CONFIG_FB_MSM=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_BLK_CGROUP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
+CONFIG_SND_USB=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_RD_GZIP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_LBDAF=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_V4L_PCI_DRIVERS=y
+CONFIG_HID_ROCCAT=y
+CONFIG_NET_VENDOR_HP=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_N_SMUX=y
+CONFIG_BINFMT_ELF=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_HOTPLUG=y
+CONFIG_INET6_AH=y
+CONFIG_CPU_CP15=y
+CONFIG_USB_SERIAL=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_KEYS=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_KEXEC_HARDBOOT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_SLABINFO=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_MSM_CACHE_DUMP=y
+CONFIG_TIMER_STATS=y
+CONFIG_MSM_SMD_LOGGING=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_CRYPTO_HW=y
+CONFIG_GENLOCK_MISCDEVICE=y
+CONFIG_FB_MSM_TVOUT_NONE=y
+CONFIG_ION=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_PHYS_OFFSET=0x80200000
+CONFIG_HID_GREENASIA=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_SPI_MASTER=y
+CONFIG_FB_MSM_LCDC_HW=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_ANDROID_PERSISTENT_RAM=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_HID_GYRATION=y
+CONFIG_USB_WDM=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_INPUT_JOYDEV=y
+CONFIG_EARLYSUSPEND=y
+CONFIG_THERMAL_TSENS8960=y
+CONFIG_USB_ACM=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_CRC16=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_NET_CLS=y
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_TMPFS=y
+CONFIG_ANON_INODES=y
+CONFIG_FUTEX=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_VMSPLIT_3G=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_USB_HID=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_SND_SOC_WCD9310=y
+CONFIG_ANDROID=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_FB_MSM_NO_MDP_PIPE_CTRL=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_MSM_L1_ERR_PANIC=y
+CONFIG_FANOTIFY=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_SMC911X=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_SYSVIPC=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_SMSC911X=y
+CONFIG_GPIO_MSM_V2=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_MODULES=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_USB_GADGET=y
+CONFIG_SOUND=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_UNIX=y
+CONFIG_HAVE_CLK=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_LZ4HC=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_NFS_FS=y
+CONFIG_XPS=y
+CONFIG_INET_ESP=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_MD=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FONTS=y
+CONFIG_MEDIA_TUNER=y
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+CONFIG_RD_BZIP2=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_NF_NAT=y
+CONFIG_ION_MSM=y
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_MSM_KGSL_SIMPLE_GOV=y
+CONFIG_CPU_IDLE=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_MPM=y
+CONFIG_NFS_COMMON=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_REGULATOR=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_EFI_PARTITION=y
+CONFIG_LOG_BUF_SHIFT=21
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_NET_VENDOR_8390=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_VFAT_FS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+CONFIG_PID_NS=y
+CONFIG_MSM_KGSL_2D=y
+CONFIG_KEXEC=y
+CONFIG_CRC32_SLICEBY8=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_CPU_RMAP=y
+CONFIG_SND_HWDEP=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_MFD_PM8XXX_SPK=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_WAKELOCK=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_INPUT_MISC=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_SUSPEND=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_AMSS_7X25_VERSION_2009=y
+CONFIG_MSM_PIL=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_CPU_FREQ_MSM=y
+CONFIG_MSM_PM_TIMEOUT_HALT=y
+CONFIG_FS_MBCACHE=y
+CONFIG_RTC_CLASS=y
+CONFIG_MFD_PM8XXX_IRQ=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_CPU_PM=y
+CONFIG_MSM_VIDC_VDEC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_MSM_IOMMU=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_TCP_CONG_ILLINOIS=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_SLUB=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_SLIP=y
+CONFIG_PM_SLEEP=y
+CONFIG_I2C=y
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_MSM_SOC_REV_NONE=y
+CONFIG_FB_MSM_BACKLIGHT=y
+CONFIG_FRAME_POINTER=y
+CONFIG_BT_HIDP=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_MFD_PM8XXX_MISC=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_DEBUG_FS=y
+CONFIG_ARCH_MSM_KRAIT=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_BASE_FULL=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_SUNRPC=y
+CONFIG_MFD_PM8XXX_PWM=y
+CONFIG_QSEECOM=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_FW_LOADER=y
+CONFIG_KALLSYMS=y
+CONFIG_PCI=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_CRYPTO_XTS=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MII=y
+CONFIG_SIGNALFD=y
+CONFIG_NET_CORE=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_EXT4_FS=y
+CONFIG_WCNSS_CORE=m
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_XZ_DEC=y
+CONFIG_USB_BELKIN=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_LOCKD_V4=y
+CONFIG_DUMMY=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_MSM_CPU_PWRCTL=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_HAS_IOMEM=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_PPPOPNS=y
+CONFIG_UID_CPUTIME=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_MSM_RESET_MODEM=y
+CONFIG_IOSCHED_TEST=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_EPOLL=y
+CONFIG_SND_PCM=y
+CONFIG_CAP_SENSOR_RMNET_CTL=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NET=y
+CONFIG_LEDS_PM8XXX=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_SND_JACK=y
+CONFIG_USB_QCOM_DIAG_BRIDGE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_VFPv3=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_IOMMU_PGTABLES_L2=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_PACKET=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_BCM2079X=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NFS_V3=y
+CONFIG_FB_MSM_MIPI_LG_1080_HD_PT=y
+CONFIG_NOP_TRACER=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_INET=y
+CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_MSM_IOMMU_GPU_SYNC=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_FREEZER=y
+CONFIG_BT=y
+CONFIG_RFKILL_PM=y
+CONFIG_MACH_APQ8064_FLO=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_REED_SOLOMON=y
+CONFIG_PMIC8XXX_VIBRATOR=y
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_FB_MSM_HDMI_COMMON=y
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_CP_ACCESS=y
+CONFIG_HID_WACOM=y
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=y
+CONFIG_RTC_LIB=y
+CONFIG_MSM_WCNSS_SSR_8960=m
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_CRYPTO_AES=y
+CONFIG_GPIOLIB=y
+CONFIG_MODEM_SUPPORT=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_USER_RC_INPUT=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_SWP_EMULATE=y
+CONFIG_FB_MSM_MIPI_DSI=y
+CONFIG_UIO=y
+CONFIG_SND_ARM=y
+CONFIG_HID_WALTOP=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_FB_MSM_MIPI_DSI_LG=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_LIRC=y
+CONFIG_BT_BNEP=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_RD_XZ=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
+CONFIG_SND_DRIVERS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_LCD_KCAL=y
+CONFIG_NO_HZ=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_USB_MSM_OTG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_INET6_ESP=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MMC_MSM=y
+CONFIG_MSM_AMSS_VERSION_6225=y
+CONFIG_TASKSTATS=y
+CONFIG_SLIMBUS_MSM_CTRL=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_FONT_8x8=y
+CONFIG_SMC91X=y
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_CPU_V7=y
+CONFIG_HID_TWINHAN=y
+CONFIG_GPIO_SX150X=y
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_FB_MSM_OVERLAY=y
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_MSM_PIL_QDSP6V4=y
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_SMP=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_PRIMA_WLAN=m
+CONFIG_ARM_NR_BANKS=8
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_L2TP=y
+CONFIG_MSM_WATCHDOG=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_GENERIC_IO=y
+CONFIG_LIBCRC32C=y
+CONFIG_GPIO_PM8XXX_MPP=y
+CONFIG_KEYBOARD_MATRIX=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_MSM_DCVS=y
+CONFIG_GENERIC_BUG=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_HID_SONY=y
+CONFIG_HW_CONSOLE=y
+CONFIG_DEVMEM=y
+CONFIG_SND_SPI=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_EZKEY=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_MSM_GSS_SSR_8064=y
+CONFIG_NEON=y
+CONFIG_MSM_VCAP=y
+CONFIG_GENERIC_ACL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_COMPAT_BRK=y
+CONFIG_LOCALVERSION="-flo"
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_ADAPTERS=y
+CONFIG_CRYPTO=y
+CONFIG_MSM_SCM=y
+CONFIG_NET_VENDOR_BROCADE=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_CMDLINE=""
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_FB_VIRTUAL=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_MSM_RMNET_SMUX=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_SCSI_MOD=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_AUDIT_TREE=y
+CONFIG_VIDEOBUF2_DMA_SG=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_MSM_L1_ERR_LOG=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_SERIAL_CORE=y
+CONFIG_FUSE_FS=y
+CONFIG_UID16=y
+CONFIG_EMBEDDED=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_VIDEO_DEV=y
+CONFIG_NFS_V4=y
+CONFIG_PPP_FILTER=y
+CONFIG_FB_MSM_MDP_HW=y
+CONFIG_MSM_SMD_QMI=y
+CONFIG_HAS_DMA=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_SCSI=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_MSM_MDP40=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_MSM_SMD_NMEA=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_JBD2=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_PHYLIB=y
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_IPC_NS=y
+CONFIG_CPU_HAS_L2_PMU=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_DIAG_CHAR=y
+CONFIG_FTRACE=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_PPPOL2TP=y
+CONFIG_HID_TOPSEED=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_KSM=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
+CONFIG_NF_NAT_H323=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_HID_A4TECH=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_PROFILING=y
+CONFIG_SPARSEMEM=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_MSM_NATIVE_RESTART=y
+CONFIG_RTC_DRV_PM8XXX=y
+CONFIG_MSM7X00A_SLEEP_MODE=0
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_SLHC=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_HAVE_SMP=y
+CONFIG_SCSI_TGT=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_SCHED_SMT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_HID_ORTEK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_REGULATOR_PM8XXX=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_MMC_BLOCK=y
+CONFIG_NET_CLS_FW=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
+CONFIG_SND_PCI=y
+CONFIG_EXPERT=y
+CONFIG_RTAC=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
+CONFIG_ASUSTEK_PCBID=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_PROC=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FRAME_WARN=1024
+CONFIG_USB_NET_CDC_NCM=y
+CONFIG_CFG80211_REG_DEBUG=y
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_UPDATE_LCDC_LUT=y
+CONFIG_SND_SOC_WCD9304=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CGROUPS=y
+CONFIG_MMC=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_ARM_TICKET_LOCKS=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_HID_LOGITECH=y
+CONFIG_STACKTRACE=y
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_PPPOLAC=y
+CONFIG_MULTI_IRQ_HANDLER=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_MSM_PIL_DSPS=y
+CONFIG_HAS_IOPORT=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_HZ=100
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_FB_BACKLIGHT=y
+CONFIG_MSM_SMD_DEBUG=y
+CONFIG_QCACHE=y
+CONFIG_INET_AH=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_FB_MSM_OVERLAY0_WRITEBACK=y
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_IPV6_MIP6=y
+CONFIG_NLATTR=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_ARCH_MSM8960=y
+CONFIG_NR_CPUS=4
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+CONFIG_HID_KYE=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_SYSFS=y
+CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_ARM_THUMB=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_SLIMBUS=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_N_SMUX_LOOPBACK=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_FB_SYS_FOPS=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_FB=y
+CONFIG_TRACING=y
+CONFIG_I2C_COMPAT=y
+CONFIG_CPU_32v7=y
+CONFIG_MSM_BUSPM_DEV=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FRANDOM=y
+CONFIG_BT_HCIUART=y
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_THERMAL=y
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_HID_PETALYNX=y
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_MSM_VIDC=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_MSM_KGSL=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_RPS=y
+CONFIG_USB_NET_ZAURUS=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_WCD9310_CODEC=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_VIDEO_MEDIA=y
+CONFIG_IP_MULTICAST=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_MFD_PM8921_CORE=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_CPU_32v6K=y
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_TICK_ONESHOT=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_SW_SYNC=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_MSM_PIL_GSS=y
+CONFIG_HW_RANDOM=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USB_SERIAL_CSVT=y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_THERMAL_PM8XXX=y
+CONFIG_IRTTY_SIR=y
+CONFIG_CPUPOWER=y
+CONFIG_MSM_SPM_V2=y
+CONFIG_BASE_SMALL=0
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_MSM_SLEEPER=y
+CONFIG_PROC_FS=y
+CONFIG_NET_PACKET_ENGINE=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_RC_MAP=y
+CONFIG_WEXT_PRIV=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_SND_SOC_MSM8960=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_SND=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_ARCH_MSM8930=y
+CONFIG_MSM_TZ_LOG=y
+CONFIG_SND_SOC_MSM_STUB=y
+CONFIG_MSM_EVENT_TIMER=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_MSM_AMSS_VERSION=6225
+CONFIG_IKCONFIG=y
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_MSM_RPM=y
+CONFIG_SYSCTL=y
+CONFIG_ARCH_MSM=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_CIFS=y
+CONFIG_XFRM_USER=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_MACH_APQ8064_DEB=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT=y
+CONFIG_GENLOCK=y
+CONFIG_MSM_HSIC_SYSMON=y
+CONFIG_NET_NS=y
+CONFIG_SOUND_CONTROL_HAX_GPL=y
+CONFIG_MSM_EBI_ERP=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_MSM_ULTRASOUND=y
+CONFIG_PPP_ASYNC=y
+CONFIG_MSM_SMD_TTY=y
+CONFIG_UID_STAT=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_AUDIT=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+CONFIG_ASUSTEK_KEYPAD=y
+CONFIG_CMA_AREAS=7
+CONFIG_HID_MULTITOUCH=y
+CONFIG_SECURITY=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_HID_ELECOM=y
+CONFIG_SND_TIMER=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_BLK_DEV=y
+CONFIG_MFD_PM8821_CORE=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_SENSORS_EPM_ADC=y
+CONFIG_PRIMA_WLAN_LFR=y
+CONFIG_IOMMU_API=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_NET_SCHED=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_FB_MSM_MIPI_JDI_CMD_MODE=y
+CONFIG_PRINTK_TIME=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_SECCOMP_FILTER=y
+CONFIG_PPP=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_ARCH_APQ8064=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_INET_DIAG=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_ELF_CORE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_MSM_CACHE_ERP=y
+CONFIG_USB_SUPPORT=y
+CONFIG_SND_SOC_MSM_QDSP6_INTF=y
+CONFIG_DIAGFWD_BRIDGE_CODE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_STAGING=y
+CONFIG_USB_QCOM_MDM_BRIDGE=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_MSM_IDLE_STATS=y
+CONFIG_BT_HCIUART_IBS=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MSM_RMNET_USB=y
+CONFIG_USB_QCOM_KS_BRIDGE=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_DRM=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=y
+CONFIG_PREEMPT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_MSM_CACHE_DUMP_ON_PANIC=y
+CONFIG_BINARY_PRINTF=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_FB_MSM_HDMI_MSM_PANEL=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_MSM_N_WAY_SMD=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HID_NTRIG=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CIFS_POSIX=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_CROSS_COMPILE=""
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_HID_HOLTEK=y
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_MSM_PIL_RIVA=y
+CONFIG_REGMAP=y
+CONFIG_NLS_UTF8=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_MSM_RUN_QUEUE_STATS=y
+CONFIG_USB_USBNET=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_FHANDLE=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_NEW_LEDS=y
+CONFIG_SWAP=y
+CONFIG_SND_SOC_VOICE=y
+CONFIG_CRC_CCITT=y
+CONFIG_ANDROID_PMEM=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_WAKE_TIMEOUT=y
+CONFIG_AVERAGE=y
+CONFIG_MSM_RPM_REGULATOR=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_MSM_HSIC_TTY=y
+CONFIG_ARCH_MSM_KRAITMP=y
+CONFIG_CMA=y
+CONFIG_CHARGER_SMB345=y
+CONFIG_RCU_FANOUT=32
+CONFIG_BITREVERSE=y
+CONFIG_DEVPORT=y
+CONFIG_MSM_ROTATOR=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_PRIMA_WLAN_OKC=y
+CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT=2
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_MSM_GPIOMUX=y
+CONFIG_MFD_PM8XXX_DEBUG=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_MSM_N_WAY_SMSM=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_IOSCHED_FIOPS=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_FILE_LOCKING=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_MSM_MULTIMEDIA_USE_ION=y
+CONFIG_AIO=y
+CONFIG_NET_EMATCH=y
+CONFIG_PERF_EVENTS=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_LEDS_CLASS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_HID_SUPPORT=y
+CONFIG_FB_MSM_HDMI_3D=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_MSM_MODEM_8960=y
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_UTS_NS=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_MOUSE_PS2=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_WEXT_SPY=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_INPUT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_RD_LZ4=y
+CONFIG_MMU=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_USB_SIERRA_NET=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
+CONFIG_MFD_PM8821_IRQ=y
diff -urN flo-ElementalX-5.00/include/config/auto.conf.cmd flo-ElementalX-5.00-patched/include/config/auto.conf.cmd
--- flo-ElementalX-5.00/include/config/auto.conf.cmd	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/auto.conf.cmd	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,816 @@
+deps_config := \
+	lib/xz/Kconfig \
+	lib/Kconfig \
+	drivers/crypto/caam/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/evm/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/integrity/Kconfig \
+	security/yama/Kconfig \
+	security/apparmor/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/ceph/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig.ore \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/pstore/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx6/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/logfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/yaffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/exfat/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/fanotify/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/f2fs/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/coresight/Kconfig \
+	drivers/gud/Kconfig \
+	drivers/devfreq/Kconfig \
+	drivers/virt/Kconfig \
+	drivers/rpmsg/Kconfig \
+	drivers/remoteproc/Kconfig \
+	drivers/iommu/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/hwspinlock/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/platform/msm/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/cpupower/Kconfig \
+	drivers/staging/prima/Kconfig \
+	drivers/staging/ozwpan/Kconfig \
+	drivers/staging/ramster/Kconfig \
+	drivers/staging/telephony/Kconfig \
+	drivers/staging/android/switch/Kconfig \
+	drivers/staging/android/Kconfig \
+	drivers/staging/omapdrm/Kconfig \
+	drivers/staging/media/lirc/Kconfig \
+	drivers/staging/media/solo6x10/Kconfig \
+	drivers/staging/media/go7007/Kconfig \
+	drivers/staging/media/easycap/Kconfig \
+	drivers/staging/media/dt3155v4l/Kconfig \
+	drivers/staging/media/cxd2099/Kconfig \
+	drivers/staging/media/as102/Kconfig \
+	drivers/staging/media/Kconfig \
+	drivers/staging/nvec/Kconfig \
+	drivers/staging/mei/Kconfig \
+	drivers/staging/ste_rmi4/Kconfig \
+	drivers/staging/cptm1217/Kconfig \
+	drivers/staging/speakup/Kconfig \
+	drivers/staging/ft1000/Kconfig \
+	drivers/staging/bcm/Kconfig \
+	drivers/staging/keucr/Kconfig \
+	drivers/staging/sbe-2t3e3/Kconfig \
+	drivers/staging/quickstart/Kconfig \
+	drivers/staging/tidspbridge/Kconfig \
+	drivers/staging/xgifb/Kconfig \
+	drivers/staging/cxt1e1/Kconfig \
+	drivers/staging/crystalhd/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/zsmalloc/Kconfig \
+	drivers/staging/qcache/Kconfig \
+	drivers/staging/zcache/Kconfig \
+	drivers/staging/zram/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/resolver/Kconfig \
+	drivers/staging/iio/meter/Kconfig \
+	drivers/staging/iio/magnetometer/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/imu/Kconfig \
+	drivers/staging/iio/impedance-analyzer/Kconfig \
+	drivers/staging/iio/gyro/Kconfig \
+	drivers/staging/iio/dds/Kconfig \
+	drivers/staging/iio/dac/Kconfig \
+	drivers/staging/iio/cdc/Kconfig \
+	drivers/staging/iio/addac/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/vme/boards/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/rts5139/Kconfig \
+	drivers/staging/rts_pstor/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/rtl8192e/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/olpc_dcon/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/serial/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/hv/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srpt/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/qib/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/switch/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/renesas_usbhs/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/dwc3/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/tegra/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/samsung/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/mxs/Kconfig \
+	sound/soc/msm/Kconfig \
+	sound/soc/mid-x86/Kconfig \
+	sound/soc/kirkwood/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/nuc900/Kconfig \
+	sound/soc/jz4740/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/ep93xx/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/firewire/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/exynos/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/msm/mdss/Kconfig \
+	drivers/video/msm/vidc/Kconfig \
+	drivers/video/msm/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/msm/Kconfig \
+	drivers/gpu/ion/Kconfig \
+	drivers/gpu/stub/Kconfig \
+	drivers/gpu/drm/udl/Kconfig \
+	drivers/gpu/drm/gma500/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/gpu/drm/exynos/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/mpq/demux/Kconfig \
+	drivers/media/dvb/mpq/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/ddbridge/Kconfig \
+	drivers/media/dvb/ngene/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/wl128x/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/msm_wfd/Kconfig \
+	drivers/media/video/msm_vidc/Kconfig \
+	drivers/media/video/s5p-tv/Kconfig \
+	drivers/media/video/blackfin/Kconfig \
+	drivers/media/video/omap/Kconfig \
+	drivers/media/video/davinci/Kconfig \
+	drivers/media/video/marvell-ccic/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/cx25821/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/tm6000/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/tlg2300/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/m5mols/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/platform/msm/camera_v2/Kconfig \
+	drivers/media/platform/msm/camera_v1/Kconfig \
+	drivers/media/platform/msm/Kconfig \
+	drivers/media/platform/Kconfig \
+	drivers/media/rc/keymaps/Kconfig \
+	drivers/media/rc/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/bcma/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/pmbus/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/pinctrl/Kconfig \
+	drivers/ptp/Kconfig \
+	drivers/pps/generators/Kconfig \
+	drivers/pps/clients/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/hsi/clients/Kconfig \
+	drivers/hsi/Kconfig \
+	drivers/slimbus/Kconfig \
+	drivers/spmi/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/tty/hvc/Kconfig \
+	drivers/char/diag/Kconfig \
+	drivers/tty/serial/8250/Kconfig \
+	drivers/tty/serial/Kconfig \
+	drivers/tty/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/net/hyperv/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/mwifiex/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/wl1251/Kconfig \
+	drivers/net/wireless/rtlwifi/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlegacy/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/brcm80211/Kconfig \
+	drivers/net/wireless/bcmdhd/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/ath6kl/Kconfig \
+	drivers/net/wireless/ath/carl9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/rtl818x/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/net/slip/Kconfig \
+	drivers/net/ppp/Kconfig \
+	drivers/net/plip/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/hippi/Kconfig \
+	drivers/net/fddi/Kconfig \
+	drivers/net/ethernet/xircom/Kconfig \
+	drivers/net/ethernet/xilinx/Kconfig \
+	drivers/net/ethernet/via/Kconfig \
+	drivers/net/ethernet/tundra/Kconfig \
+	drivers/net/ethernet/toshiba/Kconfig \
+	drivers/net/ethernet/tile/Kconfig \
+	drivers/net/ethernet/ti/Kconfig \
+	drivers/net/ethernet/tehuti/Kconfig \
+	drivers/net/ethernet/sun/Kconfig \
+	drivers/net/ethernet/stmicro/stmmac/Kconfig \
+	drivers/net/ethernet/stmicro/Kconfig \
+	drivers/net/ethernet/smsc/Kconfig \
+	drivers/net/ethernet/sgi/Kconfig \
+	drivers/net/ethernet/sfc/Kconfig \
+	drivers/net/ethernet/sis/Kconfig \
+	drivers/net/ethernet/silan/Kconfig \
+	drivers/net/ethernet/seeq/Kconfig \
+	drivers/net/ethernet/rdc/Kconfig \
+	drivers/net/ethernet/renesas/Kconfig \
+	drivers/net/ethernet/realtek/Kconfig \
+	drivers/net/ethernet/racal/Kconfig \
+	drivers/net/ethernet/qlogic/Kconfig \
+	drivers/net/ethernet/pasemi/Kconfig \
+	drivers/net/ethernet/packetengines/Kconfig \
+	drivers/net/ethernet/oki-semi/pch_gbe/Kconfig \
+	drivers/net/ethernet/oki-semi/Kconfig \
+	drivers/net/ethernet/octeon/Kconfig \
+	drivers/net/ethernet/nxp/Kconfig \
+	drivers/net/ethernet/nvidia/Kconfig \
+	drivers/net/ethernet/nuvoton/Kconfig \
+	drivers/net/ethernet/8390/Kconfig \
+	drivers/net/ethernet/natsemi/Kconfig \
+	drivers/net/ethernet/myricom/Kconfig \
+	drivers/net/ethernet/msm/Kconfig \
+	drivers/net/ethernet/microchip/Kconfig \
+	drivers/net/ethernet/micrel/Kconfig \
+	drivers/net/ethernet/mellanox/mlx4/Kconfig \
+	drivers/net/ethernet/mellanox/Kconfig \
+	drivers/net/ethernet/marvell/Kconfig \
+	drivers/net/ethernet/icplus/Kconfig \
+	drivers/net/ethernet/xscale/ixp2000/Kconfig \
+	drivers/net/ethernet/xscale/Kconfig \
+	drivers/net/ethernet/i825xx/Kconfig \
+	drivers/net/ethernet/intel/Kconfig \
+	drivers/net/ethernet/ibm/emac/Kconfig \
+	drivers/net/ethernet/ibm/Kconfig \
+	drivers/net/ethernet/hp/Kconfig \
+	drivers/net/ethernet/fujitsu/Kconfig \
+	drivers/net/ethernet/freescale/fs_enet/Kconfig \
+	drivers/net/ethernet/freescale/Kconfig \
+	drivers/net/ethernet/faraday/Kconfig \
+	drivers/net/ethernet/neterion/Kconfig \
+	drivers/net/ethernet/emulex/benet/Kconfig \
+	drivers/net/ethernet/emulex/Kconfig \
+	drivers/net/ethernet/dlink/Kconfig \
+	drivers/net/ethernet/dec/tulip/Kconfig \
+	drivers/net/ethernet/dec/Kconfig \
+	drivers/net/ethernet/davicom/Kconfig \
+	drivers/net/ethernet/cisco/enic/Kconfig \
+	drivers/net/ethernet/cisco/Kconfig \
+	drivers/net/ethernet/cirrus/Kconfig \
+	drivers/net/ethernet/chelsio/Kconfig \
+	drivers/net/ethernet/calxeda/Kconfig \
+	drivers/net/ethernet/brocade/bna/Kconfig \
+	drivers/net/ethernet/brocade/Kconfig \
+	drivers/net/ethernet/broadcom/Kconfig \
+	drivers/net/ethernet/adi/Kconfig \
+	drivers/net/ethernet/cadence/Kconfig \
+	drivers/net/ethernet/atheros/Kconfig \
+	drivers/net/ethernet/apple/Kconfig \
+	drivers/net/ethernet/amd/Kconfig \
+	drivers/net/ethernet/alteon/Kconfig \
+	drivers/net/ethernet/aeroflex/Kconfig \
+	drivers/net/ethernet/adaptec/Kconfig \
+	drivers/net/ethernet/3com/Kconfig \
+	drivers/net/ethernet/Kconfig \
+	drivers/net/dsa/Kconfig \
+	drivers/net/caif/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/team/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/target/iscsi/Kconfig \
+	drivers/target/tcm_fc/Kconfig \
+	drivers/target/loopback/Kconfig \
+	drivers/target/Kconfig \
+	drivers/md/persistent-data/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/ufs/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2fc/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgbi/cxgb4i/Kconfig \
+	drivers/scsi/cxgbi/cxgb3i/Kconfig \
+	drivers/scsi/cxgbi/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/slimport_anx7808/Kconfig \
+	drivers/misc/altera-stapl/Kconfig \
+	drivers/misc/carma/Kconfig \
+	drivers/misc/lis3lv02d/Kconfig \
+	drivers/misc/ti-st/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/mtip32xx/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/regmap/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	drivers/nfc/Kconfig \
+	net/nfc/llcp/Kconfig \
+	net/nfc/nci/Kconfig \
+	net/nfc/Kconfig \
+	net/ceph/Kconfig \
+	net/caif/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/softing/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/cc770/Kconfig \
+	drivers/net/can/c_can/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/openvswitch/Kconfig \
+	net/batman-adv/Kconfig \
+	net/dns_resolver/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/l2tp/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/ipset/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig.powerpc \
+	drivers/cpufreq/Kconfig.arm \
+	drivers/cpufreq/Kconfig.x86 \
+	drivers/cpufreq/Kconfig \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	kernel/time/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	arch/arm/mach-w90x900/Kconfig \
+	arch/arm/mach-vt8500/Kconfig \
+	arch/arm/plat-versatile/Kconfig \
+	arch/arm/mach-vexpress/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-ux500/Kconfig \
+	arch/arm/mach-u300/Kconfig \
+	arch/arm/mach-tegra/Kconfig \
+	drivers/sh/intc/Kconfig \
+	drivers/sh/Kconfig \
+	arch/arm/mach-shmobile/Kconfig \
+	arch/arm/mach-exynos/Kconfig \
+	arch/arm/mach-s5pv210/Kconfig \
+	arch/arm/mach-s5pc100/Kconfig \
+	arch/arm/mach-s5p64x0/Kconfig \
+	arch/arm/mach-s3c64xx/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c24xx/Kconfig \
+	arch/arm/mach-spear6xx/Kconfig \
+	arch/arm/mach-spear3xx/Kconfig \
+	arch/arm/plat-spear/Kconfig \
+	arch/arm/plat-s5p/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/plat-samsung/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-mmp/Kconfig \
+	arch/arm/plat-pxa/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/plat-nomadik/Kconfig \
+	arch/arm/mach-nomadik/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-mxs/devices/Kconfig \
+	arch/arm/mach-mxs/Kconfig \
+	arch/arm/mach-imx/Kconfig \
+	arch/arm/plat-mxc/devices/Kconfig \
+	arch/arm/plat-mxc/Kconfig \
+	arch/arm/mach-mv78xx0/Kconfig \
+	arch/arm/mach-msm/asustek/flo/Kconfig \
+	arch/arm/mach-msm/asustek/Kconfig.board \
+	arch/arm/mach-msm/asustek/Kconfig \
+	arch/arm/mach-msm/lge/mako/Kconfig \
+	arch/arm/mach-msm/lge/Kconfig.board \
+	arch/arm/mach-msm/lge/Kconfig \
+	arch/arm/mach-msm/Kconfig \
+	arch/arm/mach-lpc32xx/Kconfig \
+	arch/arm/mach-ks8695/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-gemini/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-dove/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-cns3xxx/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	arch/arm/mach-bcmring/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/partitions/Kconfig \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	kernel/irq/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "3.4.0"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(SRCARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -urN flo-ElementalX-5.00/include/config/kernel.release flo-ElementalX-5.00-patched/include/config/kernel.release
--- flo-ElementalX-5.00/include/config/kernel.release	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/kernel.release	2016-06-03 17:55:19.000000000 +0000
@@ -0,0 +1 @@
+3.4.0-flo
diff -urN flo-ElementalX-5.00/include/config/tristate.conf flo-ElementalX-5.00-patched/include/config/tristate.conf
--- flo-ElementalX-5.00/include/config/tristate.conf	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/config/tristate.conf	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,572 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.0 Kernel Configuration
+#
+CONFIG_NF_CONNTRACK_H323=Y
+CONFIG_MSM_VIDC_VENC=Y
+CONFIG_IP_NF_TARGET_REDIRECT=Y
+CONFIG_CRC32=Y
+CONFIG_NF_NAT_PROTO_SCTP=Y
+CONFIG_IR_JVC_DECODER=Y
+CONFIG_IR_MCE_KBD_DECODER=Y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=Y
+CONFIG_BLK_DEV_DM=Y
+CONFIG_MSM_RPM_LOG=Y
+CONFIG_BT_RFCOMM=Y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=Y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=Y
+CONFIG_CRYPTO_MD4=Y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=Y
+CONFIG_PPP_SYNC_TTY=Y
+CONFIG_RC_CORE=Y
+CONFIG_BATTERY_ASUS_BQ27541=Y
+CONFIG_HID_SPEEDLINK=Y
+CONFIG_CPU_FREQ_GOV_ELEMENTALX=Y
+CONFIG_TCP_CONG_HTCP=Y
+CONFIG_BINFMT_MISC=Y
+CONFIG_MSM_BT_POWER=Y
+CONFIG_NETFILTER_XT_MATCH_HELPER=Y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=Y
+CONFIG_UHID=Y
+CONFIG_INET6_TUNNEL=Y
+CONFIG_HID_PRODIKEYS=Y
+CONFIG_VIDEOBUF2_MSM_MEM=Y
+CONFIG_USB_HSIC_SMSC_HUB=Y
+CONFIG_HID_EMS_FF=Y
+CONFIG_IP6_NF_MANGLE=Y
+CONFIG_IPV6=Y
+CONFIG_CRYPTO_AEAD=Y
+CONFIG_NET_CLS_FLOW=Y
+CONFIG_USB_STORAGE_USBAT=Y
+CONFIG_NF_NAT_PROTO_GRE=Y
+CONFIG_IP6_NF_TARGET_REJECT=Y
+CONFIG_IR_NEC_DECODER=Y
+CONFIG_SENSORS_CAP1106=Y
+CONFIG_SMUX_CTL=Y
+CONFIG_XFRM_IPCOMP=Y
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_NETFILTER_NETLINK_QUEUE=Y
+CONFIG_TUN=Y
+CONFIG_CFG80211=Y
+CONFIG_DM_CRYPT=Y
+CONFIG_LZO_DECOMPRESS=Y
+CONFIG_HID_BELKIN=Y
+CONFIG_VIDEO_IR_I2C=Y
+CONFIG_USB_SERIAL_OPTION=Y
+CONFIG_HID_ACRUX=Y
+CONFIG_USB=Y
+CONFIG_CRYPTO_HMAC=Y
+CONFIG_FRAMEBUFFER_CONSOLE=M
+CONFIG_TCP_CONG_LP=Y
+CONFIG_IP_NF_ARPTABLES=Y
+CONFIG_HID_CHERRY=Y
+CONFIG_HID_SUNPLUS=Y
+CONFIG_HID_PICOLCD=Y
+CONFIG_SND_SOC=Y
+CONFIG_MEDIA_TUNER_XC5000=Y
+CONFIG_FB_SYS_FILLRECT=Y
+CONFIG_HID_THRUSTMASTER=Y
+CONFIG_DNS_RESOLVER=Y
+CONFIG_CRYPTO_AUTHENC=Y
+CONFIG_IRDA=Y
+CONFIG_HID_PRIMAX=Y
+CONFIG_DECOMPRESS_LZMA=Y
+CONFIG_CRYPTO_CTS=Y
+CONFIG_INPUT_MOUSEDEV=Y
+CONFIG_SND_SOC_CS8427=Y
+CONFIG_CRYPTO_DES=Y
+CONFIG_NLS_CODEPAGE_437=Y
+CONFIG_NET_CLS_U32=Y
+CONFIG_EXPORTFS=Y
+CONFIG_SERIO=Y
+CONFIG_FB_SYS_IMAGEBLIT=Y
+CONFIG_SUNRPC_GSS=Y
+CONFIG_MA600_DONGLE=Y
+CONFIG_NET_EMATCH_U32=Y
+CONFIG_I2C_QUP=Y
+CONFIG_MFD_PM8XXX=Y
+CONFIG_NF_CONNTRACK_SANE=Y
+CONFIG_NF_CT_PROTO_DCCP=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_ENCRYPTED_KEYS=Y
+CONFIG_HWMON=Y
+CONFIG_CRYPTO_TWOFISH_COMMON=Y
+CONFIG_STM_LIS3DH=Y
+CONFIG_USB_VIDEO_CLASS=Y
+CONFIG_MSM_LPASS_8960=Y
+CONFIG_USB_EHSET_TEST_FIXTURE=Y
+CONFIG_SLIMPORT_ANX7808=Y
+CONFIG_LOCKD=Y
+CONFIG_GPIO_PM8XXX=Y
+CONFIG_ANDROID_TIMED_GPIO=Y
+CONFIG_HID_SAITEK=Y
+CONFIG_RPCSEC_GSS_KRB5=Y
+CONFIG_NETFILTER_XT_MATCH_STRING=Y
+CONFIG_USB_STORAGE=Y
+CONFIG_SPI_QUP=Y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=Y
+CONFIG_IR_LIRC_CODEC=Y
+CONFIG_SND_USB_AUDIO=Y
+CONFIG_TCP_CONG_YEAH=Y
+CONFIG_HID_APPLE=Y
+CONFIG_MEDIA_TUNER_TDA827X=Y
+CONFIG_IP_NF_ARP_MANGLE=Y
+CONFIG_EXFAT_FS=Y
+CONFIG_INPUT_MPU3050=Y
+CONFIG_ASUSTEK_HEADSET=Y
+CONFIG_NF_CONNTRACK_PPTP=Y
+CONFIG_NET_EMATCH_META=Y
+CONFIG_NF_CONNTRACK_IRC=Y
+CONFIG_SWITCH=Y
+CONFIG_PPP_DEFLATE=Y
+CONFIG_TEXTSEARCH_KMP=Y
+CONFIG_USB_NET_NET1080=Y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=Y
+CONFIG_HID_TIVO=Y
+CONFIG_REGMAP_SPI=Y
+CONFIG_MFD_PM8038_CORE=Y
+CONFIG_MSM_PIL_TZAPPS=Y
+CONFIG_POWER_SUPPLY=Y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=Y
+CONFIG_NLS=Y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=Y
+CONFIG_HID_MAGICMOUSE=Y
+CONFIG_SENSORS_PM8XXX_ADC=Y
+CONFIG_PPPOE=Y
+CONFIG_FB_SYS_COPYAREA=Y
+CONFIG_USB_STORAGE_ALAUDA=Y
+CONFIG_USB_COMMON=Y
+CONFIG_MEDIA_TUNER_TDA18271=Y
+CONFIG_IP6_NF_IPTABLES=Y
+CONFIG_LZ4_COMPRESS=Y
+CONFIG_CPU_FREQ_GOV_USERSPACE=Y
+CONFIG_INET_IPCOMP=Y
+CONFIG_HID_KEYTOUCH=Y
+CONFIG_HID_CYPRESS=Y
+CONFIG_NLS_ISO8859_1=Y
+CONFIG_CRYPTO_WORKQUEUE=Y
+CONFIG_TCP_CONG_HYBLA=Y
+CONFIG_HID_KENSINGTON=Y
+CONFIG_BACKLIGHT_GENERIC=Y
+CONFIG_USB_EHCI_HCD=Y
+CONFIG_CPU_FREQ_TABLE=Y
+CONFIG_TEXTSEARCH_BM=Y
+CONFIG_HID_ZYDACRON=Y
+CONFIG_PPP_MPPE=Y
+CONFIG_USB_IRDA=Y
+CONFIG_RFKILL=Y
+CONFIG_NET_KEY=Y
+CONFIG_IOSCHED_DEADLINE=Y
+CONFIG_IPV6_SIT=Y
+CONFIG_CRYPTO_SHA1_ARM=Y
+CONFIG_IP_NF_TARGET_MASQUERADE=Y
+CONFIG_NF_CONNTRACK_BROADCAST=Y
+CONFIG_CRYPTO_LZ4=Y
+CONFIG_IR_RC5_SZ_DECODER=Y
+CONFIG_NF_NAT_PROTO_DCCP=Y
+CONFIG_SCSI_WAIT_SCAN=M
+CONFIG_BACKLIGHT_CLASS_DEVICE=Y
+CONFIG_NF_DEFRAG_IPV4=Y
+CONFIG_INET_XFRM_MODE_BEET=Y
+CONFIG_HID_LCPOWER=Y
+CONFIG_CRYPTO_DEFLATE=Y
+CONFIG_BT_HCISMD=Y
+CONFIG_NETFILTER_NETLINK_LOG=Y
+CONFIG_INPUT_LID=Y
+CONFIG_NETFILTER_XT_MATCH_MARK=Y
+CONFIG_MSM_PIL_VIDC=Y
+CONFIG_MSM_DMA_TEST=Y
+CONFIG_IP_NF_MANGLE=Y
+CONFIG_INET6_XFRM_MODE_TUNNEL=Y
+CONFIG_MEDIA_SUPPORT=Y
+CONFIG_IP_NF_FILTER=Y
+CONFIG_HID_ZEROPLUS=Y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=Y
+CONFIG_FAT_FS=Y
+CONFIG_WCD9304_CODEC=Y
+CONFIG_TEXTSEARCH_FSM=Y
+CONFIG_IP6_NF_RAW=Y
+CONFIG_INET_TUNNEL=Y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=Y
+CONFIG_EEPROM_93CX6=Y
+CONFIG_IOSCHED_CFQ=Y
+CONFIG_LIB80211=Y
+CONFIG_MFD_CORE=Y
+CONFIG_REGULATOR_MSM_GPIO=Y
+CONFIG_SND_SOC_QDSP6=Y
+CONFIG_USB_GSPCA=Y
+CONFIG_NLS_ASCII=Y
+CONFIG_USB_NET_CDC_SUBSET=Y
+CONFIG_FB_MSM=Y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=Y
+CONFIG_BLK_CGROUP=Y
+CONFIG_CRYPTO_RNG=Y
+CONFIG_VIDEOBUF2_MEMOPS=Y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=Y
+CONFIG_HID_ROCCAT=Y
+CONFIG_INET_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_MD5=Y
+CONFIG_MEDIA_TUNER_TEA5767=Y
+CONFIG_N_SMUX=Y
+CONFIG_INET6_AH=Y
+CONFIG_USB_SERIAL=Y
+CONFIG_INET_XFRM_TUNNEL=Y
+CONFIG_NETFILTER_XT_MARK=Y
+CONFIG_NETFILTER_XTABLES=Y
+CONFIG_USB_STORAGE_DATAFAB=Y
+CONFIG_TCP_CONG_VEGAS=Y
+CONFIG_ION=Y
+CONFIG_USB_STORAGE_KARMA=Y
+CONFIG_HID_GREENASIA=Y
+CONFIG_HID_GYRATION=Y
+CONFIG_USB_WDM=Y
+CONFIG_INPUT_JOYDEV=Y
+CONFIG_THERMAL_TSENS8960=Y
+CONFIG_USB_ACM=Y
+CONFIG_CRC16=Y
+CONFIG_USB_NET_AX8817X=Y
+CONFIG_CRYPTO_GF128MUL=Y
+CONFIG_REGMAP_I2C=Y
+CONFIG_USB_HID=Y
+CONFIG_IOSCHED_SIO=Y
+CONFIG_SND_SOC_WCD9310=Y
+CONFIG_IOSCHED_ROW=Y
+CONFIG_SMC911X=Y
+CONFIG_CRYPTO_PCOMP2=Y
+CONFIG_SMSC911X=Y
+CONFIG_GPIO_MSM_V2=Y
+CONFIG_KEYBOARD_GPIO=Y
+CONFIG_NF_CONNTRACK_FTP=Y
+CONFIG_IP_NF_MATCH_ECN=Y
+CONFIG_USB_GADGET=Y
+CONFIG_SOUND=Y
+CONFIG_MEDIA_TUNER_TDA9887=Y
+CONFIG_UNIX=Y
+CONFIG_CRYPTO_HASH2=Y
+CONFIG_CRYPTO_LZ4HC=Y
+CONFIG_USB_STORAGE_ISD200=Y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=Y
+CONFIG_NFS_FS=Y
+CONFIG_INET_ESP=Y
+CONFIG_LZ4_DECOMPRESS=Y
+CONFIG_NF_CONNTRACK_IPV6=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_MEDIA_TUNER=Y
+CONFIG_INPUT_UINPUT=Y
+CONFIG_MEDIA_TUNER_SIMPLE=Y
+CONFIG_KEYBOARD_ATKBD=Y
+CONFIG_NF_NAT=Y
+CONFIG_ION_MSM=Y
+CONFIG_MSM_ADSP_LOADER=Y
+CONFIG_CHR_DEV_SCH=Y
+CONFIG_CRYPTO_HASH=Y
+CONFIG_VFAT_FS=Y
+CONFIG_MSM_KGSL_2D=Y
+CONFIG_MSM_ADSPRPC=Y
+CONFIG_SND_HWDEP=Y
+CONFIG_BLK_DEV_LOOP=Y
+CONFIG_MFD_PM8XXX_SPK=Y
+CONFIG_NF_NAT_IRC=Y
+CONFIG_MEDIA_TUNER_XC2028=Y
+CONFIG_SND_COMPRESS_OFFLOAD=Y
+CONFIG_CRYPTO_CBC=Y
+CONFIG_FS_MBCACHE=Y
+CONFIG_MSM_VIDC_VDEC=Y
+CONFIG_NF_NAT_TFTP=Y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=Y
+CONFIG_TCP_CONG_ILLINOIS=Y
+CONFIG_CRYPTO_MANAGER2=Y
+CONFIG_NETFILTER_XT_TARGET_LOG=Y
+CONFIG_SLIP=Y
+CONFIG_I2C=Y
+CONFIG_BT_HIDP=Y
+CONFIG_MFD_PM8XXX_MISC=Y
+CONFIG_CRYPTO_ECB=Y
+CONFIG_NF_CONNTRACK_AMANDA=Y
+CONFIG_FB_CFB_IMAGEBLIT=Y
+CONFIG_ZLIB_DEFLATE=Y
+CONFIG_SUNRPC=Y
+CONFIG_MFD_PM8XXX_PWM=Y
+CONFIG_QSEECOM=Y
+CONFIG_FW_LOADER=Y
+CONFIG_CRYPTO_XTS=Y
+CONFIG_DECOMPRESS_XZ=Y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=Y
+CONFIG_MII=Y
+CONFIG_EXT4_FS=Y
+CONFIG_WCNSS_CORE=M
+CONFIG_CRYPTO_SHA1=Y
+CONFIG_XZ_DEC=Y
+CONFIG_DUMMY=Y
+CONFIG_SND_RAWMIDI=Y
+CONFIG_PPPOPNS=Y
+CONFIG_UID_CPUTIME=Y
+CONFIG_USB_STORAGE_SDDR09=Y
+CONFIG_IP_NF_MATCH_TTL=Y
+CONFIG_MSM_RESET_MODEM=Y
+CONFIG_IOSCHED_TEST=Y
+CONFIG_NET_SCH_PRIO=Y
+CONFIG_SND_PCM=Y
+CONFIG_IR_SONY_DECODER=Y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=Y
+CONFIG_LEDS_PM8XXX=Y
+CONFIG_INPUT_EVDEV=Y
+CONFIG_USB_QCOM_DIAG_BRIDGE=Y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=Y
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=Y
+CONFIG_NETFILTER_XT_MATCH_DSCP=Y
+CONFIG_HID_DRAGONRISE=Y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=Y
+CONFIG_USB_NET_CDCETHER=Y
+CONFIG_PACKET=Y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=Y
+CONFIG_NF_CONNTRACK_TFTP=Y
+CONFIG_CRYPTO_TWOFISH=Y
+CONFIG_BT=Y
+CONFIG_REED_SOLOMON=Y
+CONFIG_PMIC8XXX_VIBRATOR=Y
+CONFIG_LZ4HC_COMPRESS=Y
+CONFIG_CP_ACCESS=Y
+CONFIG_HID_WACOM=Y
+CONFIG_SND_SOC_MSM_HOSTLESS_PCM=Y
+CONFIG_MSM_WCNSS_SSR_8960=M
+CONFIG_NETFILTER_XT_MATCH_POLICY=Y
+CONFIG_CRYPTO_AES=Y
+CONFIG_USER_RC_INPUT=Y
+CONFIG_UIO=Y
+CONFIG_HID_WALTOP=Y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=Y
+CONFIG_SERIO_SERPORT=Y
+CONFIG_LIRC=Y
+CONFIG_BT_BNEP=Y
+CONFIG_SERIAL_MSM_HS=Y
+CONFIG_INET_XFRM_MODE_TUNNEL=Y
+CONFIG_LCD_KCAL=Y
+CONFIG_CPU_FREQ_STAT=Y
+CONFIG_USB_MSM_OTG=Y
+CONFIG_INET6_ESP=Y
+CONFIG_AUTOFS4_FS=Y
+CONFIG_MMC_MSM=Y
+CONFIG_SLIMBUS_MSM_CTRL=Y
+CONFIG_IP6_NF_FILTER=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=Y
+CONFIG_SMC91X=Y
+CONFIG_HID_TWINHAN=Y
+CONFIG_NETFILTER_XT_MATCH_ECN=Y
+CONFIG_USB_STORAGE_SDDR55=Y
+CONFIG_DECOMPRESS_LZ4=Y
+CONFIG_MSM_PIL_QDSP6V4=Y
+CONFIG_NETFILTER_XT_MATCH_TIME=Y
+CONFIG_NETFILTER_XT_MATCH_MAC=Y
+CONFIG_PRIMA_WLAN=M
+CONFIG_NETFILTER_XT_TARGET_NFLOG=Y
+CONFIG_L2TP=Y
+CONFIG_TCP_CONG_WESTWOOD=Y
+CONFIG_LIBCRC32C=Y
+CONFIG_GPIO_PM8XXX_MPP=Y
+CONFIG_KEYBOARD_MATRIX=Y
+CONFIG_CRYPTO_SHA256=Y
+CONFIG_INET_TCP_DIAG=Y
+CONFIG_HID_SONY=Y
+CONFIG_HID_MONTEREY=Y
+CONFIG_HID_EZKEY=Y
+CONFIG_MSM_VCAP=Y
+CONFIG_RADIO_IRIS=Y
+CONFIG_CRYPTO=Y
+CONFIG_IP_NF_IPTABLES=Y
+CONFIG_FB_VIRTUAL=Y
+CONFIG_VIDEOBUF2_DMA_CONTIG=Y
+CONFIG_HID_SAMSUNG=Y
+CONFIG_TCP_CONG_HSTCP=Y
+CONFIG_SCSI_MOD=Y
+CONFIG_VIDEOBUF2_DMA_SG=Y
+CONFIG_CRYPTO_CRC32C=Y
+CONFIG_SERIAL_CORE=Y
+CONFIG_FUSE_FS=Y
+CONFIG_HID_MICROSOFT=Y
+CONFIG_MFD_PM8XXX_BATT_ALARM=Y
+CONFIG_NF_DEFRAG_IPV6=Y
+CONFIG_VIDEO_DEV=Y
+CONFIG_NF_CT_PROTO_SCTP=Y
+CONFIG_SCSI=Y
+CONFIG_FB_CFB_FILLRECT=Y
+CONFIG_NF_NAT_PPTP=Y
+CONFIG_HID_CHICONY=Y
+CONFIG_HID=Y
+CONFIG_MEDIA_TUNER_TDA8290=Y
+CONFIG_JBD2=Y
+CONFIG_INET6_IPCOMP=Y
+CONFIG_PHYLIB=Y
+CONFIG_MEDIA_TUNER_MT20XX=Y
+CONFIG_DIAG_CHAR=Y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=Y
+CONFIG_IP_NF_SECURITY=Y
+CONFIG_IP_NF_RAW=Y
+CONFIG_IP_NF_ARPFILTER=Y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=Y
+CONFIG_PPPOL2TP=Y
+CONFIG_HID_TOPSEED=Y
+CONFIG_DECOMPRESS_BZIP2=Y
+CONFIG_NF_NAT_H323=Y
+CONFIG_HID_A4TECH=Y
+CONFIG_MEDIA_TUNER_MC44S803=Y
+CONFIG_IP_NF_TARGET_NETMAP=Y
+CONFIG_INPUT_FF_MEMLESS=Y
+CONFIG_CHR_DEV_SG=Y
+CONFIG_NF_NAT_AMANDA=Y
+CONFIG_IR_GPIO_CIR=Y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_ARC4=Y
+CONFIG_RTC_DRV_PM8XXX=Y
+CONFIG_USB_CI13XXX_MSM=Y
+CONFIG_SLHC=Y
+CONFIG_SCSI_TGT=Y
+CONFIG_CRYPTO_MANAGER=Y
+CONFIG_NET_SCH_HTB=Y
+CONFIG_PPP_BSDCOMP=Y
+CONFIG_HID_ORTEK=Y
+CONFIG_NETFILTER_XT_TARGET_MARK=Y
+CONFIG_REGULATOR_PM8XXX=Y
+CONFIG_I2C_ALGOBIT=Y
+CONFIG_MMC_BLOCK=Y
+CONFIG_NET_CLS_FW=Y
+CONFIG_IR_SANYO_DECODER=Y
+CONFIG_USB_NET_CDC_NCM=Y
+CONFIG_SND_SOC_WCD9304=Y
+CONFIG_MMC=Y
+CONFIG_LZO_COMPRESS=Y
+CONFIG_CRYPTO_SEQIV=Y
+CONFIG_HID_LOGITECH=Y
+CONFIG_PPPOLAC=Y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=Y
+CONFIG_MSM_PIL_DSPS=Y
+CONFIG_NETFILTER_XT_MATCH_U32=Y
+CONFIG_QCACHE=Y
+CONFIG_INET_AH=Y
+CONFIG_IPV6_MIP6=Y
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_NETFILTER_XT_CONNMARK=Y
+CONFIG_HID_KYE=Y
+CONFIG_IP_NF_MATCH_AH=Y
+CONFIG_TCP_CONG_VENO=Y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=Y
+CONFIG_N_SMUX_LOOPBACK=Y
+CONFIG_FB_SYS_FOPS=Y
+CONFIG_MEDIA_TUNER_XC4000=Y
+CONFIG_FB=Y
+CONFIG_MSM_BUSPM_DEV=Y
+CONFIG_BT_HCIUART=Y
+CONFIG_THERMAL=Y
+CONFIG_HID_PETALYNX=Y
+CONFIG_NF_CONNTRACK_IPV4=Y
+CONFIG_MSM_KGSL=Y
+CONFIG_SERIAL_MSM_HSL=Y
+CONFIG_USB_NET_ZAURUS=Y
+CONFIG_INET6_XFRM_TUNNEL=Y
+CONFIG_WCD9310_CODEC=Y
+CONFIG_MSM_RPM_STATS_LOG=Y
+CONFIG_NET_EMATCH_NBYTE=Y
+CONFIG_VIDEO_MEDIA=Y
+CONFIG_INPUT_KEYCHORD=Y
+CONFIG_MFD_PM8921_CORE=Y
+CONFIG_HID_LOGITECH_DJ=Y
+CONFIG_NF_NAT_PROTO_UDPLITE=Y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=Y
+CONFIG_CRYPTO_CTR=Y
+CONFIG_MSM_PIL_GSS=Y
+CONFIG_HW_RANDOM=Y
+CONFIG_USB_SERIAL_CSVT=Y
+CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO=Y
+CONFIG_VIDEOBUF2_CORE=Y
+CONFIG_THERMAL_PM8XXX=Y
+CONFIG_IRTTY_SIR=Y
+CONFIG_CPUPOWER=Y
+CONFIG_CRYPTO_BLKCIPHER2=Y
+CONFIG_VIDEOBUF2_VMALLOC=Y
+CONFIG_RC_MAP=Y
+CONFIG_SND_SOC_MSM8960=Y
+CONFIG_HID_PANTHERLORD=Y
+CONFIG_SND=Y
+CONFIG_IR_RC6_DECODER=Y
+CONFIG_MSM_TZ_LOG=Y
+CONFIG_SND_SOC_MSM_STUB=Y
+CONFIG_IKCONFIG=Y
+CONFIG_HW_RANDOM_MSM=Y
+CONFIG_CIFS=Y
+CONFIG_XFRM_USER=Y
+CONFIG_TCP_CONG_BIC=Y
+CONFIG_MSM_HSIC_SYSMON=Y
+CONFIG_SOUND_CONTROL_HAX_GPL=Y
+CONFIG_NET_EMATCH_CMP=Y
+CONFIG_PPP_ASYNC=Y
+CONFIG_HID_MULTITOUCH=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=Y
+CONFIG_HID_ELECOM=Y
+CONFIG_SND_TIMER=Y
+CONFIG_MFD_PM8821_CORE=Y
+CONFIG_NFS_ACL_SUPPORT=Y
+CONFIG_TCP_CONG_SCALABLE=Y
+CONFIG_SENSORS_EPM_ADC=Y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=Y
+CONFIG_CRYPTO_ANSI_CPRNG=Y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=Y
+CONFIG_PPP=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=Y
+CONFIG_INET_DIAG=Y
+CONFIG_NF_NAT_FTP=Y
+CONFIG_NF_CT_PROTO_UDPLITE=Y
+CONFIG_USB_QCOM_MDM_BRIDGE=Y
+CONFIG_HID_UCLOGIC=Y
+CONFIG_MSM_RMNET_USB=Y
+CONFIG_USB_QCOM_KS_BRIDGE=Y
+CONFIG_BLK_DEV_RAM=Y
+CONFIG_NETFILTER_XT_MATCH_STATE=Y
+CONFIG_USB_STORAGE_FREECOM=Y
+CONFIG_IR_RC5_DECODER=Y
+CONFIG_DRM=Y
+CONFIG_INET6_XFRM_MODE_BEET=Y
+CONFIG_MSM_RPM_RBCPR_STATS_LOG=Y
+CONFIG_FB_CFB_COPYAREA=Y
+CONFIG_USB_STORAGE_JUMPSHOT=Y
+CONFIG_VIDEO_V4L2=Y
+CONFIG_HID_NTRIG=Y
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_DECOMPRESS_LZO=Y
+CONFIG_I2C_CHARDEV=Y
+CONFIG_MEDIA_TUNER_TEA5761=Y
+CONFIG_HID_HOLTEK=Y
+CONFIG_CRYPTO_AES_ARM=Y
+CONFIG_MSM_PIL_RIVA=Y
+CONFIG_NLS_UTF8=Y
+CONFIG_JOYSTICK_XPAD=Y
+CONFIG_NETFILTER_TPROXY=Y
+CONFIG_USB_USBNET=Y
+CONFIG_HID_SMARTJOYPLUS=Y
+CONFIG_CRC_CCITT=Y
+CONFIG_BLK_DEV_SD=Y
+CONFIG_NETFILTER_NETLINK=Y
+CONFIG_WAKE_TIMEOUT=Y
+CONFIG_CHARGER_SMB345=Y
+CONFIG_BITREVERSE=Y
+CONFIG_MSM_ROTATOR=Y
+CONFIG_USB_SERIAL_WWAN=Y
+CONFIG_VIDEO_V4L2_COMMON=Y
+CONFIG_CRYPTO_BLKCIPHER=Y
+CONFIG_MFD_PM8XXX_DEBUG=Y
+CONFIG_USB_STORAGE_ONETOUCH=Y
+CONFIG_NF_CONNTRACK=Y
+CONFIG_IOSCHED_FIOPS=Y
+CONFIG_LCD_CLASS_DEVICE=Y
+CONFIG_SND_SOC_I2C_AND_SPI=Y
+CONFIG_IP_NF_TARGET_REJECT=Y
+CONFIG_LEDS_CLASS=Y
+CONFIG_NF_CT_PROTO_GRE=Y
+CONFIG_NF_CT_NETLINK=Y
+CONFIG_NET_EMATCH_TEXT=Y
+CONFIG_CRYPTO_AEAD2=Y
+CONFIG_MOUSE_PS2=Y
+CONFIG_NETFILTER_XT_MATCH_HL=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_INPUT=Y
+CONFIG_USB_SIERRA_NET=Y
diff -urN flo-ElementalX-5.00/include/generated/asm-offsets.h flo-ElementalX-5.00-patched/include/generated/asm-offsets.h
--- flo-ElementalX-5.00/include/generated/asm-offsets.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/asm-offsets.h	2016-06-02 09:34:02.000000000 +0000
@@ -0,0 +1,73 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 280 /* offsetof(struct task_struct, active_mm)	@ */
+#define TSK_STACK_CANARY 344 /* offsetof(struct task_struct, stack_canary)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 80 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 96 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 288 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+#define VFP_CPU 272 /* offsetof(union vfp_state, hard.cpu)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define MM_CONTEXT_ID 348 /* offsetof(struct mm_struct, context.id)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 24 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 72 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 4 /* offsetof(struct machine_desc, name)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#define CACHE_FLUSH_KERN_ALL 4 /* offsetof(struct cpu_cache_fns, flush_kern_all)	@ */
+
+#define DMA_BIDIRECTIONAL 0 /* DMA_BIDIRECTIONAL	@ */
+#define DMA_TO_DEVICE 1 /* DMA_TO_DEVICE	@ */
+#define DMA_FROM_DEVICE 2 /* DMA_FROM_DEVICE	@ */
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/autoconf.h flo-ElementalX-5.00-patched/include/generated/autoconf.h
--- flo-ElementalX-5.00/include/generated/autoconf.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/autoconf.h	2016-06-03 17:15:30.000000000 +0000
@@ -0,0 +1,1371 @@
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * Linux/arm 3.4.0 Kernel Configuration
+ *
+ */
+#define CONFIG_RING_BUFFER 1
+#define CONFIG_NF_CONNTRACK_H323 1
+#define CONFIG_HAVE_ARCH_SECCOMP_FILTER 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_MSM_VIDC_VENC 1
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_RFS_ACCEL 1
+#define CONFIG_IP_NF_TARGET_REDIRECT 1
+#define CONFIG_CRC32 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_NF_NAT_PROTO_SCTP 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_VFP 1
+#define CONFIG_IR_JVC_DECODER 1
+#define CONFIG_AEABI 1
+#define CONFIG_IR_MCE_KBD_DECODER 1
+#define CONFIG_CPU_FREQ_GOV_CONSERVATIVE 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_SECCOMP 1
+#define CONFIG_BLK_DEV_DM 1
+#define CONFIG_MSM_REMOTE_SPINLOCK_SFPB 1
+#define CONFIG_MSM_RPM_LOG 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_MSM_SHOW_RESUME_IRQ 1
+#define CONFIG_MSM_IPC_ROUTER_SECURITY 1
+#define CONFIG_KERNEL_MSM_CONTIG_MEM_REGION 1
+#define CONFIG_BT_RFCOMM 1
+#define CONFIG_LEDS_TRIGGER_HEARTBEAT 1
+#define CONFIG_UACCESS_WITH_MEMCPY 1
+#define CONFIG_XZ_DEC_IA64 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_NF_CONNTRACK_NETBIOS_NS 1
+#define CONFIG_SCSI_LOGGING 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define CONFIG_CRYPTO_MD4 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_CGROUP_DEVICE 1
+#define CONFIG_PPP_SYNC_TTY 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_RC_CORE 1
+#define CONFIG_BATTERY_ASUS_BQ27541 1
+#define CONFIG_HID_SPEEDLINK 1
+#define CONFIG_CPU_FREQ_GOV_ELEMENTALX 1
+#define CONFIG_TCP_CONG_HTCP 1
+#define CONFIG_EXT4_FS_POSIX_ACL 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_MSM_BT_POWER 1
+#define CONFIG_NETFILTER_XT_MATCH_HELPER 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATISTIC 1
+#define CONFIG_MSM_L2_SPM 1
+#define CONFIG_UHID 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_BLK_DEV_LOOP_MIN_COUNT 8
+#define CONFIG_INET6_TUNNEL 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_CRYPTO_MANAGER_DISABLE_TESTS 1
+#define CONFIG_HIDRAW 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_HID_PRODIKEYS 1
+#define CONFIG_VIDEOBUF2_MSM_MEM 1
+#define CONFIG_USB_HSIC_SMSC_HUB 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_ELEMENTALX 1
+#define CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER 1
+#define CONFIG_DYNAMIC_DEBUG 1
+#define CONFIG_MSM_SMP 1
+#define CONFIG_HAVE_MEMORY_PRESENT 1
+#define CONFIG_USB_EHCI_MSM_HOST4 1
+#define CONFIG_MSM_PM8X60 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_HID_ACRUX_FF 1
+#define CONFIG_RT_GROUP_SCHED 1
+#define CONFIG_HID_EMS_FF 1
+#define CONFIG_KTIME_SCALAR 1
+#define CONFIG_IP6_NF_MANGLE 1
+#define CONFIG_SCSI_CONSTANTS 1
+#define CONFIG_IPV6 1
+#define CONFIG_CRYPTO_AEAD 1
+#define CONFIG_BQL 1
+#define CONFIG_INPUT_MOUSEDEV_PSAUX 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_UEVENT_HELPER_PATH ""
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_DEVTMPFS 1
+#define CONFIG_NET_CLS_FLOW 1
+#define CONFIG_USB_STORAGE_USBAT 1
+#define CONFIG_NF_NAT_PROTO_GRE 1
+#define CONFIG_ANDROID_BINDER_IPC 1
+#define CONFIG_IP6_NF_TARGET_REJECT 1
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_IR_NEC_DECODER 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_WLAN 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
+#define CONFIG_HAVE_ARM_SCU 1
+#define CONFIG_BLK_DEV_BSG 1
+#define CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG 1
+#define CONFIG_SENSORS_CAP1106 1
+#define CONFIG_SMUX_CTL 1
+#define CONFIG_ATAGS_PROC 1
+#define CONFIG_XFRM_IPCOMP 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_NETFILTER_NETLINK_QUEUE 1
+#define CONFIG_TUN 1
+#define CONFIG_USB_OTG_UTILS 1
+#define CONFIG_CFG80211 1
+#define CONFIG_TREE_PREEMPT_RCU 1
+#define CONFIG_DM_CRYPT 1
+#define CONFIG_REED_SOLOMON_ENC8 1
+#define CONFIG_HAVE_PROC_CPU 1
+#define CONFIG_LZO_DECOMPRESS 1
+#define CONFIG_USB_EHCI_ROOT_HUB_TT 1
+#define CONFIG_IOMMU_SUPPORT 1
+#define CONFIG_HID_BELKIN 1
+#define CONFIG_VIDEO_IR_I2C 1
+#define CONFIG_MSM_XO 1
+#define CONFIG_FB_MSM_OVERLAY1_WRITEBACK 1
+#define CONFIG_USB_SERIAL_OPTION 1
+#define CONFIG_HID_ACRUX 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_USB 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_ETHERNET 1
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define CONFIG_SCSI_SCAN_ASYNC 1
+#define CONFIG_HAVE_DMA_CONTIGUOUS 1
+#define CONFIG_DQL 1
+#define CONFIG_FRAMEBUFFER_CONSOLE_MODULE 1
+#define CONFIG_TCP_CONG_LP 1
+#define CONFIG_IP_NF_ARPTABLES 1
+#define CONFIG_USB_EHCI_MSM_HSIC 1
+#define CONFIG_HID_CHERRY 1
+#define CONFIG_USB_EHCI_MSM 1
+#define CONFIG_MSM_PCIE 1
+#define CONFIG_HID_SUNPLUS 1
+#define CONFIG_HID_PICOLCD 1
+#define CONFIG_BCMA_POSSIBLE 1
+#define CONFIG_NET_VENDOR_CIRRUS 1
+#define CONFIG_VGA_ARB 1
+#define CONFIG_FORCE_MAX_ZONEORDER 11
+#define CONFIG_SND_SOC 1
+#define CONFIG_SYNC 1
+#define CONFIG_CAN_PM_TRACE 1
+#define CONFIG_MEDIA_TUNER_XC5000 1
+#define CONFIG_PRINTK 1
+#define CONFIG_NF_CONNTRACK_PROC_COMPAT 1
+#define CONFIG_FB_SYS_FILLRECT 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_HID_THRUSTMASTER 1
+#define CONFIG_FB_MSM_MIPI_DSI_NOVATEK 1
+#define CONFIG_DNS_RESOLVER 1
+#define CONFIG_TRACEPOINTS 1
+#define CONFIG_CRYPTO_AUTHENC 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_VIDEO_V4L2_SUBDEV_API 1
+#define CONFIG_IRDA 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_MSM_KGSL_PAGE_TABLE_SIZE 0xFFF0000
+#define CONFIG_SHMEM 1
+#define CONFIG_MIGRATION 1
+#define CONFIG_HAVE_ARCH_JUMP_LABEL 1
+#define CONFIG_MMC_BLOCK_MINORS 32
+#define CONFIG_HID_PRIMAX 1
+#define CONFIG_RMNET_SMD_DATA_CHANNEL ""
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_CRYPTO_CTS 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_SND_SOC_CS8427 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_MSM_IPC_ROUTER_SMD_XPRT 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_MSM_SMD 1
+#define CONFIG_CFG80211_INTERNAL_REGDB 1
+#define CONFIG_NET_CLS_U32 1
+#define CONFIG_EXPORTFS 1
+#define CONFIG_ARM_GIC 1
+#define CONFIG_SERIO 1
+#define CONFIG_INPUT_MOUSE 1
+#define CONFIG_FB_SYS_IMAGEBLIT 1
+#define CONFIG_MSM7X00A_USE_GP_TIMER 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_MA600_DONGLE 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_MSM_QDSP6_APR 1
+#define CONFIG_NET_EMATCH_U32 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_I2C_QUP 1
+#define CONFIG_MFD_PM8XXX 1
+#define CONFIG_NF_CONNTRACK_SANE 1
+#define CONFIG_HAVE_BPF_JIT 1
+#define CONFIG_NF_CT_PROTO_DCCP 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_ENCRYPTED_KEYS 1
+#define CONFIG_HWMON 1
+#define CONFIG_USB_G_ANDROID 1
+#define CONFIG_NET_VENDOR_DLINK 1
+#define CONFIG_CRYPTO_TWOFISH_COMMON 1
+#define CONFIG_AUDITSYSCALL 1
+#define CONFIG_MSM_KRAIT_WFE_FIXUP 1
+#define CONFIG_STM_LIS3DH 1
+#define CONFIG_MSM_IPC_ROUTER 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_MSM_L2_ERP_2BIT_PANIC 1
+#define CONFIG_USB_VIDEO_CLASS 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_MSM_LPASS_8960 1
+#define CONFIG_PM_CLK 1
+#define CONFIG_CMA_SIZE_SEL_MBYTES 1
+#define CONFIG_CPU_IDLE_GOV_MENU 1
+#define CONFIG_FB_MSM_DTV 1
+#define CONFIG_USB_EHSET_TEST_FIXTURE 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_CPU_VOLTAGE_TABLE 1
+#define CONFIG_SLIMPORT_ANX7808 1
+#define CONFIG_USB_DEVICE_CLASS 1
+#define CONFIG_LOCKD 1
+#define CONFIG_GPIO_PM8XXX 1
+#define CONFIG_ANDROID_TIMED_GPIO 1
+#define CONFIG_ARM 1
+#define CONFIG_NET_VENDOR_MICROCHIP 1
+#define CONFIG_HID_SAITEK 1
+#define CONFIG_ARM_L1_CACHE_SHIFT 6
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_NET_VENDOR_ADAPTEC 1
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_NETFILTER_XT_MATCH_STRING 1
+#define CONFIG_ARM_CPU_TOPOLOGY 1
+#define CONFIG_HAS_WAKELOCK 1
+#define CONFIG_SPS_SUPPORT_BAMDMA 1
+#define CONFIG_NET_VENDOR_SILAN 1
+#define CONFIG_KERNEL_XZ 1
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_NET_VENDOR_BROADCOM 1
+#define CONFIG_BOARD_HEADER_FILE ""
+#define CONFIG_STANDALONE 1
+#define CONFIG_SCHED_MC 1
+#define CONFIG_SPI_QUP 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_IR_LIRC_CODEC 1
+#define CONFIG_DONGLE 1
+#define CONFIG_ARCH_HAS_CPUFREQ 1
+#define CONFIG_FB_MSM_EXT_INTERFACE_COMMON 1
+#define CONFIG_SND_USB_AUDIO 1
+#define CONFIG_TCP_CONG_YEAH 1
+#define CONFIG_ASHMEM 1
+#define CONFIG_BLOCK 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_HID_APPLE 1
+#define CONFIG_MEDIA_TUNER_TDA827X 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_IP_NF_ARP_MANGLE 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_EXFAT_FS 1
+#define CONFIG_INPUT_MPU3050 1
+#define CONFIG_MSM_VIDC_1080P 1
+#define CONFIG_USER_NS 1
+#define CONFIG_MSM_BAM_DMUX 1
+#define CONFIG_ASUSTEK_HEADSET 1
+#define CONFIG_NF_CONNTRACK_PPTP 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_BUG 1
+#define CONFIG_CONTEXT_SWITCH_TRACER 1
+#define CONFIG_NET_EMATCH_META 1
+#define CONFIG_PM 1
+#define CONFIG_MACH_ASUSTEK 1
+#define CONFIG_SPI 1
+#define CONFIG_NF_CONNTRACK_IRC 1
+#define CONFIG_SWITCH 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
+#define CONFIG_PPP_DEFLATE 1
+#define CONFIG_TEXTSEARCH_KMP 1
+#define CONFIG_VT 1
+#define CONFIG_USB_NET_NET1080 1
+#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY 1
+#define CONFIG_HID_TIVO 1
+#define CONFIG_REGMAP_SPI 1
+#define CONFIG_MSM_SYSMON_COMM 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_MFD_PM8038_CORE 1
+#define CONFIG_MSM_PIL_TZAPPS 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_CIFS_XATTR 1
+#define CONFIG_CPU_CACHE_VIPT 1
+#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM 1
+#define CONFIG_V4L_USB_DRIVERS 1
+#define CONFIG_WEXT_CORE 1
+#define CONFIG_MSM_DSPS 1
+#define CONFIG_NLS 1
+#define CONFIG_NETFILTER_XT_TARGET_SECMARK 1
+#define CONFIG_HID_MAGICMOUSE 1
+#define CONFIG_SENSORS_PM8XXX_ADC 1
+#define CONFIG_PPPOE 1
+#define CONFIG_REED_SOLOMON_DEC8 1
+#define CONFIG_IRQ_WORK 1
+#define CONFIG_PCI_MSI 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_FB_SYS_COPYAREA 1
+#define CONFIG_CLEANCACHE 1
+#define CONFIG_USB_STORAGE_ALAUDA 1
+#define CONFIG_SPARSEMEM_EXTREME 1
+#define CONFIG_DIAG_OVER_USB 1
+#define CONFIG_USB_COMMON 1
+#define CONFIG_TASK_XACCT 1
+#define CONFIG_MEDIA_TUNER_TDA18271 1
+#define CONFIG_IP6_NF_IPTABLES 1
+#define CONFIG_LZ4_COMPRESS 1
+#define CONFIG_CPU_FREQ_GOV_USERSPACE 1
+#define CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES 1
+#define CONFIG_INET_IPCOMP 1
+#define CONFIG_VGA_ARB_MAX_GPUS 16
+#define CONFIG_EVENT_TRACING 1
+#define CONFIG_HID_KEYTOUCH 1
+#define CONFIG_HID_CYPRESS 1
+#define CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET 1000000000
+#define CONFIG_FB_MSM_MIPI_DSI_JDI 1
+#define CONFIG_MSM_AUDIO_QDSP6 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_TCP_CONG_HYBLA 1
+#define CONFIG_HID_KENSINGTON 1
+#define CONFIG_BACKLIGHT_GENERIC 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_TEXTSEARCH_BM 1
+#define CONFIG_NF_CONNTRACK_PROCFS 1
+#define CONFIG_HID_ZYDACRON 1
+#define CONFIG_PPP_MPPE 1
+#define CONFIG_USB_IRDA 1
+#define CONFIG_RFKILL 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_MSM_SSBI 1
+#define CONFIG_CGROUP_FREEZER 1
+#define CONFIG_CPU_TLB_V7 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_XFRM 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_FB_MSM_MIPI_NOVATEK_1080_HD_PT 1
+#define CONFIG_MSM_WFD 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_CRYPTO_SHA1_ARM 1
+#define CONFIG_MMC_MSM_SDC1_SUPPORT 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE 1
+#define CONFIG_NF_CONNTRACK_BROADCAST 1
+#define CONFIG_CRYPTO_LZ4 1
+#define CONFIG_IR_RC5_SZ_DECODER 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_NF_NAT_PROTO_DCCP 1
+#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
+#define CONFIG_DEBUG_GPIO 1
+#define CONFIG_RD_LZO 1
+#define CONFIG_ANDROID_LOW_MEMORY_KILLER 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_NF_CONNTRACK_SECMARK 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_NET_VENDOR_EXAR 1
+#define CONFIG_NET_VENDOR_SEEQ 1
+#define CONFIG_NF_DEFRAG_IPV4 1
+#define CONFIG_MIGHT_HAVE_PCI 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_HID_LCPOWER 1
+#define CONFIG_MMC_UNSAFE_RESUME 1
+#define CONFIG_HAVE_ARCH_PFN_VALID 1
+#define CONFIG_CPU_COPY_V6 1
+#define CONFIG_PM_DEBUG 1
+#define CONFIG_IPV6_ROUTE_INFO 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_CRYPTO_DEFLATE 1
+#define CONFIG_BT_HCISMD 1
+#define CONFIG_IPV6_ROUTER_PREF 1
+#define CONFIG_SERIAL_MSM_HSL_CONSOLE 1
+#define CONFIG_SLIP_COMPRESSED 1
+#define CONFIG_MSM_AVS_HW 1
+#define CONFIG_NETFILTER_NETLINK_LOG 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_MSM_QDSP6_CODECS 1
+#define CONFIG_INPUT_LID 1
+#define CONFIG_NET_VENDOR_RDC 1
+#define CONFIG_CPUSETS 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK 1
+#define CONFIG_MSM_PIL_VIDC 1
+#define CONFIG_MSM_DMA_TEST 1
+#define CONFIG_IP_NF_MANGLE 1
+#define CONFIG_MSM_DLOAD_MODE 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_MEDIA_SUPPORT 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_IP_NF_FILTER 1
+#define CONFIG_HID_ZEROPLUS 1
+#define CONFIG_NETFILTER_XT_MATCH_LENGTH 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_WCD9304_CODEC 1
+#define CONFIG_TEXTSEARCH_FSM 1
+#define CONFIG_HIGHMEM 1
+#define CONFIG_SPS 1
+#define CONFIG_IP6_NF_RAW 1
+#define CONFIG_MSM_BUS_RPM_MULTI_TIER_ENABLED 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_NETFILTER_XT_TARGET_NOTRACK 1
+#define CONFIG_EEPROM_93CX6 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_LIB80211 1
+#define CONFIG_MFD_CORE 1
+#define CONFIG_REGULATOR_MSM_GPIO 1
+#define CONFIG_HAVE_KERNEL_XZ 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_RFKILL_LEDS 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_VIDEO_HELPER_CHIPS_AUTO 1
+#define CONFIG_SND_SOC_QDSP6 1
+#define CONFIG_CLS_U32_MARK 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_MSM_KGSL_DRM 1
+#define CONFIG_USB_GSPCA 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_MODULE_FORCE_LOAD 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_NFS_V3_ACL 1
+#define CONFIG_USB_CSW_HACK 1
+#define CONFIG_DETECT_HUNG_TASK 1
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_USB_NET_CDC_SUBSET 1
+#define CONFIG_FB_MSM 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNMARK 1
+#define CONFIG_BLK_CGROUP 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_CRYPTO_RNG 1
+#define CONFIG_MSM_IDLE_WAIT_ON_MODEM 0
+#define CONFIG_SND_USB 1
+#define CONFIG_VIDEOBUF2_MEMOPS 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define CONFIG_LBDAF 1
+#define CONFIG_USB_STORAGE_CYPRESS_ATACB 1
+#define CONFIG_EXT4_FS_SECURITY 1
+#define CONFIG_V4L_PCI_DRIVERS 1
+#define CONFIG_HID_ROCCAT 1
+#define CONFIG_NET_VENDOR_HP 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_MSM_IPC_LOGGING 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE 1
+#define CONFIG_MEDIA_TUNER_TEA5767 1
+#define CONFIG_OABI_COMPAT 1
+#define CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define CONFIG_N_SMUX 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_AUDIT_GENERIC 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_NEED_MACH_MEMORY_H 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_INET6_AH 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_USB_SERIAL 1
+#define CONFIG_NET_VENDOR_ALTEON 1
+#define CONFIG_KEYS 1
+#define CONFIG_INET_XFRM_TUNNEL 1
+#define CONFIG_NETFILTER_XT_MARK 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_KEXEC_HARDBOOT 1
+#define CONFIG_RESOURCE_COUNTERS 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_USB_STORAGE_DATAFAB 1
+#define CONFIG_TCP_CONG_VEGAS 1
+#define CONFIG_MSM_CACHE_DUMP 1
+#define CONFIG_TIMER_STATS 1
+#define CONFIG_MSM_SMD_LOGGING 1
+#define CONFIG_PM_SLEEP_SMP 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_GENLOCK_MISCDEVICE 1
+#define CONFIG_FB_MSM_TVOUT_NONE 1
+#define CONFIG_ION 1
+#define CONFIG_USB_STORAGE_KARMA 1
+#define CONFIG_PHYS_OFFSET 0x80200000
+#define CONFIG_HID_GREENASIA 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_FB_MSM_LCDC_HW 1
+#define CONFIG_VT_HW_CONSOLE_BINDING 1
+#define CONFIG_ANDROID_PERSISTENT_RAM 1
+#define CONFIG_SLIP_MODE_SLIP6 1
+#define CONFIG_HID_GYRATION 1
+#define CONFIG_USB_WDM 1
+#define CONFIG_THERMAL_HWMON 1
+#define CONFIG_XZ_DEC_X86 1
+#define CONFIG_INPUT_JOYDEV 1
+#define CONFIG_EARLYSUSPEND 1
+#define CONFIG_THERMAL_TSENS8960 1
+#define CONFIG_USB_ACM 1
+#define CONFIG_MSM_SMD_PKT 1
+#define CONFIG_CRC16 1
+#define CONFIG_USB_NET_AX8817X 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_CRYPTO_GF128MUL 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_CPU_HAS_PMU 1
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_FUTEX 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_REGMAP_I2C 1
+#define CONFIG_NET_VENDOR_REALTEK 1
+#define CONFIG_JOYSTICK_XPAD_FF 1
+#define CONFIG_VMSPLIT_3G 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_SECURITY_NETWORK 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_MSM_DIRECT_SCLK_ACCESS 1
+#define CONFIG_NET_VENDOR_EMULEX 1
+#define CONFIG_USB_HID 1
+#define CONFIG_IOSCHED_SIO 1
+#define CONFIG_SND_SOC_WCD9310 1
+#define CONFIG_ANDROID 1
+#define CONFIG_SLUB_DEBUG 1
+#define CONFIG_NF_CONNTRACK_EVENTS 1
+#define CONFIG_FB_MSM_NO_MDP_PIPE_CTRL 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_MSM_L1_ERR_PANIC 1
+#define CONFIG_FANOTIFY 1
+#define CONFIG_IOSCHED_ROW 1
+#define CONFIG_SMC911X 1
+#define CONFIG_CGROUP_SCHED 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_CRYPTO_PCOMP2 1
+#define CONFIG_SMSC911X 1
+#define CONFIG_GPIO_MSM_V2 1
+#define CONFIG_KEYBOARD_GPIO 1
+#define CONFIG_NF_CONNTRACK_FTP 1
+#define CONFIG_MODULES 1
+#define CONFIG_IP_NF_MATCH_ECN 1
+#define CONFIG_CPU_HAS_ASID 1
+#define CONFIG_USB_GADGET 1
+#define CONFIG_SOUND 1
+#define CONFIG_EVENT_POWER_TRACING_DEPRECATED 1
+#define CONFIG_MEDIA_TUNER_TDA9887 1
+#define CONFIG_AUDIT_WATCH 1
+#define CONFIG_UNIX 1
+#define CONFIG_HAVE_CLK 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_CRYPTO_LZ4HC 1
+#define CONFIG_DEFAULT_HOSTNAME "(none)"
+#define CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS 2
+#define CONFIG_USB_STORAGE_ISD200 1
+#define CONFIG_CPU_FREQ_GOV_POWERSAVE 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_XPS 1
+#define CONFIG_INET_ESP 1
+#define CONFIG_SECURITY_SELINUX_DEVELOP 1
+#define CONFIG_LZ4_DECOMPRESS 1
+#define CONFIG_NF_CONNTRACK_IPV6 1
+#define CONFIG_MD 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_BSD_PROCESS_ACCT_V3 1
+#define CONFIG_FONTS 1
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_MMC_MSM_SPS_SUPPORT 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_INPUT_UINPUT 1
+#define CONFIG_ARCH_SUPPORTS_MSI 1
+#define CONFIG_MEDIA_TUNER_SIMPLE 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_NF_NAT 1
+#define CONFIG_ION_MSM 1
+#define CONFIG_NET_VENDOR_OKI 1
+#define CONFIG_MSM_KGSL_SIMPLE_GOV 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_MSM_ADSP_LOADER 1
+#define CONFIG_MSM_MPM 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_CHR_DEV_SCH 1
+#define CONFIG_REGULATOR 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_LOG_BUF_SHIFT 21
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_NET_VENDOR_8390 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE 1
+#define CONFIG_PID_NS 1
+#define CONFIG_MSM_KGSL_2D 1
+#define CONFIG_KEXEC 1
+#define CONFIG_CRC32_SLICEBY8 1
+#define CONFIG_MSM_ADSPRPC 1
+#define CONFIG_CPU_RMAP 1
+#define CONFIG_SND_HWDEP 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_DEFAULT_HUNG_TASK_TIMEOUT 120
+#define CONFIG_MFD_PM8XXX_SPK 1
+#define CONFIG_CFQ_GROUP_IOSCHED 1
+#define CONFIG_WAKELOCK 1
+#define CONFIG_NF_NAT_IRC 1
+#define CONFIG_MEDIA_TUNER_XC2028 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_SND_COMPRESS_OFFLOAD 1
+#define CONFIG_CPU_PABRT_V7 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_AMSS_7X25_VERSION_2009 1
+#define CONFIG_MSM_PIL 1
+#define CONFIG_FB_MSM_TRIPLE_BUFFER 1
+#define CONFIG_MEDIA_CONTROLLER 1
+#define CONFIG_CPU_FREQ_MSM 1
+#define CONFIG_MSM_PM_TIMEOUT_HALT 1
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_MFD_PM8XXX_IRQ 1
+#define CONFIG_TMPFS_XATTR 1
+#define CONFIG_CPU_PM 1
+#define CONFIG_MSM_VIDC_VDEC 1
+#define CONFIG_NF_NAT_TFTP 1
+#define CONFIG_NETFILTER_XT_MATCH_MULTIPORT 1
+#define CONFIG_CPU_CACHE_V7 1
+#define CONFIG_MSM_IOMMU 1
+#define CONFIG_ARCH_SELECT_MEMORY_MODEL 1
+#define CONFIG_TCP_CONG_ILLINOIS 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_USB_GADGET_VBUS_DRAW 500
+#define CONFIG_NET_VENDOR_MYRI 1
+#define CONFIG_GENERIC_PCI_IOMAP 1
+#define CONFIG_NETFILTER_XT_TARGET_LOG 1
+#define CONFIG_SLUB 1
+#define CONFIG_XZ_DEC_BCJ 1
+#define CONFIG_SLIP 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_I2C 1
+#define CONFIG_MSM_RMNET_BAM 1
+#define CONFIG_PPP_MULTILINK 1
+#define CONFIG_MSM_SOC_REV_NONE 1
+#define CONFIG_FB_MSM_BACKLIGHT 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_BT_HIDP 1
+#define CONFIG_CPU_ABRT_EV7 1
+#define CONFIG_MFD_PM8XXX_MISC 1
+#define CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_SND_DYNAMIC_MINORS 1
+#define CONFIG_BT_HCIUART_ATH3K 1
+#define CONFIG_NF_CONNTRACK_AMANDA 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_ARCH_MSM_KRAIT 1
+#define CONFIG_NET_VENDOR_AMD 1
+#define CONFIG_HAVE_KERNEL_LZ4 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_MFD_PM8XXX_PWM 1
+#define CONFIG_QSEECOM 1
+#define CONFIG_GPIO_SYSFS 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_PCI 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_CRYPTO_XTS 1
+#define CONFIG_DECOMPRESS_XZ 1
+#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE 1
+#define CONFIG_PCI_QUIRKS 1
+#define CONFIG_MII 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_NET_CORE 1
+#define CONFIG_MOUSE_PS2_ALPS 1
+#define CONFIG_EXT4_FS 1
+#define CONFIG_WCNSS_CORE_MODULE 1
+#define CONFIG_UNINLINE_SPIN_UNLOCK 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_ARM_DMA_MEM_BUFFERABLE 1
+#define CONFIG_IPV6_PRIVACY 1
+#define CONFIG_XZ_DEC 1
+#define CONFIG_USB_BELKIN 1
+#define CONFIG_NET_VENDOR_TI 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_DUMMY 1
+#define CONFIG_USB_GADGET_DUALSPEED 1
+#define CONFIG_MSM_CPU_PWRCTL 1
+#define CONFIG_STRICT_MEMORY_RWX 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_SND_RAWMIDI 1
+#define CONFIG_PPPOPNS 1
+#define CONFIG_UID_CPUTIME 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_HAVE_ARCH_HAS_CURRENT_TIMER 1
+#define CONFIG_USB_STORAGE_SDDR09 1
+#define CONFIG_IP_NF_MATCH_TTL 1
+#define CONFIG_MSM_RESET_MODEM 1
+#define CONFIG_IOSCHED_TEST 1
+#define CONFIG_NET_SCH_PRIO 1
+#define CONFIG_EPOLL 1
+#define CONFIG_SND_PCM 1
+#define CONFIG_CAP_SENSOR_RMNET_CTL 1
+#define CONFIG_PM_RUNTIME 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_BT_BNEP_MC_FILTER 1
+#define CONFIG_IR_SONY_DECODER 1
+#define CONFIG_NETFILTER_XT_MATCH_COMMENT 1
+#define CONFIG_NET 1
+#define CONFIG_LEDS_PM8XXX 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_SND_JACK 1
+#define CONFIG_USB_QCOM_DIAG_BRIDGE 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPMSS 1
+#define CONFIG_TOUCHSCREEN_ELAN_TF_3K 1
+#define CONFIG_NETFILTER_XT_MATCH_DSCP 1
+#define CONFIG_HID_DRAGONRISE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK 1
+#define CONFIG_MMC_PARANOID_SD_INIT 1
+#define CONFIG_VFPv3 1
+#define CONFIG_FW_LOADER_USER_HELPER 1
+#define CONFIG_IOMMU_PGTABLES_L2 1
+#define CONFIG_USB_NET_CDCETHER 1
+#define CONFIG_PACKET 1
+#define CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE 1
+#define CONFIG_HAVE_CLK_PREPARE 1
+#define CONFIG_NETFILTER_XT_MATCH_IPRANGE 1
+#define CONFIG_BCM2079X 1
+#define CONFIG_NF_CONNTRACK_TFTP 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_FB_MSM_MIPI_LG_1080_HD_PT 1
+#define CONFIG_NOP_TRACER 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_INET 1
+#define CONFIG_FB_MSM_MIPI_JDI_1080_HD_PT 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_XZ_DEC_POWERPC 1
+#define CONFIG_MSM_IOMMU_GPU_SYNC 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_CRYPTO_TWOFISH 1
+#define CONFIG_FREEZER 1
+#define CONFIG_BT 1
+#define CONFIG_RFKILL_PM 1
+#define CONFIG_MACH_APQ8064_FLO 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_REED_SOLOMON 1
+#define CONFIG_PMIC8XXX_VIBRATOR 1
+#define CONFIG_EXFAT_DEFAULT_CODEPAGE 437
+#define CONFIG_FB_MSM_HDMI_COMMON 1
+#define CONFIG_NET_VENDOR_CHELSIO 1
+#define CONFIG_LZ4HC_COMPRESS 1
+#define CONFIG_CP_ACCESS 1
+#define CONFIG_HID_WACOM 1
+#define CONFIG_SND_SOC_MSM_HOSTLESS_PCM 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_MSM_WCNSS_SSR_8960_MODULE 1
+#define CONFIG_USB_EHCI_EHSET 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_MODEM_SUPPORT 1
+#define CONFIG_EXT4_USE_FOR_EXT23 1
+#define CONFIG_USER_RC_INPUT 1
+#define CONFIG_BT_HCIUART_H4 1
+#define CONFIG_SWP_EMULATE 1
+#define CONFIG_FB_MSM_MIPI_DSI 1
+#define CONFIG_UIO 1
+#define CONFIG_SND_ARM 1
+#define CONFIG_HID_WALTOP 1
+#define CONFIG_NF_CONNTRACK_MARK 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT 1
+#define CONFIG_NET_VENDOR_SMSC 1
+#define CONFIG_USE_GENERIC_SMP_HELPERS 1
+#define CONFIG_FB_MSM_MIPI_DSI_LG 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_LIRC 1
+#define CONFIG_BT_BNEP 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_SERIAL_MSM_HS 1
+#define CONFIG_RD_XZ 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_PREEMPT_RCU 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_MSM_SLEEP_TIME_OVERRIDE 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_LCD_KCAL 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_RTC_INTF_ALARM 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_CPU_FREQ_STAT 1
+#define CONFIG_ARM_HAS_SG_CHAIN 1
+#define CONFIG_USB_MSM_OTG 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_NET_VENDOR_DEC 1
+#define CONFIG_INET6_ESP 1
+#define CONFIG_AUTOFS4_FS 1
+#define CONFIG_MMC_MSM 1
+#define CONFIG_MSM_AMSS_VERSION_6225 1
+#define CONFIG_TASKSTATS 1
+#define CONFIG_SLIMBUS_MSM_CTRL 1
+#define CONFIG_IP6_NF_FILTER 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_NEED_DMA_MAP_STATE 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_SOUND_CONTROL_HAX_3_GPL 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_FONT_8x8 1
+#define CONFIG_SMC91X 1
+#define CONFIG_NET_VENDOR_ATHEROS 1
+#define CONFIG_CPU_V7 1
+#define CONFIG_HID_TWINHAN 1
+#define CONFIG_GPIO_SX150X 1
+#define CONFIG_NET_VENDOR_SUN 1
+#define CONFIG_PANIC_TIMEOUT 0
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_FB_MSM_OVERLAY 1
+#define CONFIG_INPUT_JOYSTICK 1
+#define CONFIG_MSM_IDLE_STATS_FIRST_BUCKET 62500
+#define CONFIG_NETFILTER_XT_MATCH_ECN 1
+#define CONFIG_USB_STORAGE_SDDR55 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_DECOMPRESS_LZ4 1
+#define CONFIG_SPARSEMEM_MANUAL 1
+#define CONFIG_MSM_PIL_QDSP6V4 1
+#define CONFIG_NEED_MACH_IO_H 1
+#define CONFIG_SMP 1
+#define CONFIG_NETFILTER_XT_MATCH_TIME 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_NET_VENDOR_I825XX 1
+#define CONFIG_NETFILTER_XT_MATCH_MAC 1
+#define CONFIG_PRIMA_WLAN_MODULE 1
+#define CONFIG_ARM_NR_BANKS 8
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG 1
+#define CONFIG_GENERIC_ALLOCATOR 1
+#define CONFIG_L2TP 1
+#define CONFIG_MSM_WATCHDOG 1
+#define CONFIG_TCP_CONG_WESTWOOD 1
+#define CONFIG_KALLSYMS_ALL 1
+#define CONFIG_ANDROID_TIMED_OUTPUT 1
+#define CONFIG_GENERIC_IO 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_GPIO_PM8XXX_MPP 1
+#define CONFIG_KEYBOARD_MATRIX 1
+#define CONFIG_ARCH_NR_GPIO 0
+#define CONFIG_MSM_DCVS 1
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_CRYPTO_SHA256 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_HID_SONY 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_DEVMEM 1
+#define CONFIG_SND_SPI 1
+#define CONFIG_HID_MONTEREY 1
+#define CONFIG_HID_EZKEY 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_JOYSTICK_XPAD_LEDS 1
+#define CONFIG_MSM_GSS_SSR_8064 1
+#define CONFIG_NEON 1
+#define CONFIG_MSM_VCAP 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_LOCALVERSION "-flo"
+#define CONFIG_RADIO_IRIS 1
+#define CONFIG_RADIO_ADAPTERS 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_MSM_SCM 1
+#define CONFIG_NET_VENDOR_BROCADE 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_IP_NF_IPTABLES 1
+#define CONFIG_MSM_SUBSYSTEM_RESTART 1
+#define CONFIG_CMDLINE ""
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+#define CONFIG_FB_VIRTUAL 1
+#define CONFIG_NET_VENDOR_QLOGIC 1
+#define CONFIG_VIDEOBUF2_DMA_CONTIG 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_DEFAULT_CUBIC 1
+#define CONFIG_HID_SAMSUNG 1
+#define CONFIG_HW_PERF_EVENTS 1
+#define CONFIG_MSM_RMNET_SMUX 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_GENERIC_IRQ_SHOW 1
+#define CONFIG_IPV6_OPTIMISTIC_DAD 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_TCP_CONG_HSTCP 1
+#define CONFIG_SCSI_MOD 1
+#define CONFIG_NET_VENDOR_MICREL 1
+#define CONFIG_AUDIT_TREE 1
+#define CONFIG_VIDEOBUF2_DMA_SG 1
+#define CONFIG_THERMAL_MONITOR 1
+#define CONFIG_MSM_L1_ERR_LOG 1
+#define CONFIG_CRYPTO_CRC32C 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_FUSE_FS 1
+#define CONFIG_UID16 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_HID_MICROSOFT 1
+#define CONFIG_EXFAT_DEFAULT_IOCHARSET "utf8"
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_MFD_PM8XXX_BATT_ALARM 1
+#define CONFIG_NF_DEFRAG_IPV6 1
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_PPP_FILTER 1
+#define CONFIG_FB_MSM_MDP_HW 1
+#define CONFIG_MSM_SMD_QMI 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_NF_CT_PROTO_SCTP 1
+#define CONFIG_SCSI 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_FB_MSM_MDP40 1
+#define CONFIG_NF_NAT_PPTP 1
+#define CONFIG_HID_CHICONY 1
+#define CONFIG_HID 1
+#define CONFIG_USB_ARMLINUX 1
+#define CONFIG_CLKDEV_LOOKUP 1
+#define CONFIG_NET_VENDOR_MELLANOX 1
+#define CONFIG_VT_CONSOLE_SLEEP 1
+#define CONFIG_MSM_SMD_NMEA 1
+#define CONFIG_MEDIA_TUNER_TDA8290 1
+#define CONFIG_JBD2 1
+#define CONFIG_INET6_IPCOMP 1
+#define CONFIG_ANDROID_RAM_CONSOLE 1
+#define CONFIG_NET_VENDOR_MARVELL 1
+#define CONFIG_PHYLIB 1
+#define CONFIG_NET_VENDOR_NVIDIA 1
+#define CONFIG_NET_VENDOR_FARADAY 1
+#define CONFIG_ARCH_HAS_HOLES_MEMORYMODEL 1
+#define CONFIG_IRQ_DOMAIN 1
+#define CONFIG_LSM_MMAP_MIN_ADDR 4096
+#define CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_MODE 1
+#define CONFIG_MEDIA_TUNER_MT20XX 1
+#define CONFIG_IPC_NS 1
+#define CONFIG_CPU_HAS_L2_PMU 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_DIAG_CHAR 1
+#define CONFIG_FTRACE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNLIMIT 1
+#define CONFIG_IP_NF_SECURITY 1
+#define CONFIG_IP_NF_RAW 1
+#define CONFIG_IP_NF_ARPFILTER 1
+#define CONFIG_ARM_L1_CACHE_SHIFT_6 1
+#define CONFIG_NETFILTER_XT_MATCH_SOCKET 1
+#define CONFIG_PPPOL2TP 1
+#define CONFIG_HID_TOPSEED 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_KSM 1
+#define CONFIG_NET_VENDOR_STMICRO 1
+#define CONFIG_MSM_IDLE_STATS_BUCKET_COUNT 10
+#define CONFIG_NF_NAT_H323 1
+#define CONFIG_XZ_DEC_SPARC 1
+#define CONFIG_ARCH_SPARSEMEM_DEFAULT 1
+#define CONFIG_HID_A4TECH 1
+#define CONFIG_MEDIA_TUNER_MC44S803 1
+#define CONFIG_IP_NF_TARGET_NETMAP 1
+#define CONFIG_RCU_CPU_STALL_TIMEOUT 60
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_HAVE_HW_BRKPT_RESERVED_RW_ACCESS 1
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_HOLES_IN_ZONE 1
+#define CONFIG_MSM_BUS_SCALING 1
+#define CONFIG_ARM_CPU_SUSPEND 1
+#define CONFIG_NF_NAT_AMANDA 1
+#define CONFIG_IR_GPIO_CIR 1
+#define CONFIG_PROFILING 1
+#define CONFIG_SPARSEMEM 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_MSM_NATIVE_RESTART 1
+#define CONFIG_RTC_DRV_PM8XXX 1
+#define CONFIG_MSM7X00A_SLEEP_MODE 0
+#define CONFIG_USB_CI13XXX_MSM 1
+#define CONFIG_SLHC 1
+#define CONFIG_NET_VENDOR_TEHUTI 1
+#define CONFIG_HAVE_SMP 1
+#define CONFIG_SCSI_TGT 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_NET_SCH_HTB 1
+#define CONFIG_PPP_BSDCOMP 1
+#define CONFIG_SCHED_SMT 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_HID_ORTEK 1
+#define CONFIG_NETFILTER_XT_TARGET_MARK 1
+#define CONFIG_REGULATOR_PM8XXX 1
+#define CONFIG_PCI_SYSCALL 1
+#define CONFIG_IPV6_SUBTREES 1
+#define CONFIG_I2C_ALGOBIT 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_NET_CLS_FW 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME 20000000
+#define CONFIG_SND_PCI 1
+#define CONFIG_EXPERT 1
+#define CONFIG_RTAC 1
+#define CONFIG_IR_SANYO_DECODER 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE 1
+#define CONFIG_ASUSTEK_PCBID 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_WEXT_PROC 1
+#define CONFIG_PERF_USE_VMALLOC 1
+#define CONFIG_FB_MSM_MIPI_LG_VIDEO_MODE 1
+#define CONFIG_TASK_IO_ACCOUNTING 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_USB_NET_CDC_NCM 1
+#define CONFIG_CFG80211_REG_DEBUG 1
+#define CONFIG_RCU_CPU_STALL_VERBOSE 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_UPDATE_LCDC_LUT 1
+#define CONFIG_SND_SOC_WCD9304 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_CGROUPS 1
+#define CONFIG_MMC 1
+#define CONFIG_LZO_COMPRESS 1
+#define CONFIG_ARM_TICKET_LOCKS 1
+#define CONFIG_CRYPTO_SEQIV 1
+#define CONFIG_HID_LOGITECH 1
+#define CONFIG_STACKTRACE 1
+#define CONFIG_MSM_SMD_PKG4 1
+#define CONFIG_PPPOLAC 1
+#define CONFIG_MULTI_IRQ_HANDLER 1
+#define CONFIG_NETFILTER_XT_TARGET_IDLETIMER 1
+#define CONFIG_MSM_PIL_DSPS 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_CGROUP_CPUACCT 1
+#define CONFIG_FB_EARLYSUSPEND 1
+#define CONFIG_NET_VENDOR_VIA 1
+#define CONFIG_HZ 100
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_NETFILTER_XT_MATCH_U32 1
+#define CONFIG_FB_BACKLIGHT 1
+#define CONFIG_MSM_SMD_DEBUG 1
+#define CONFIG_QCACHE 1
+#define CONFIG_INET_AH 1
+#define CONFIG_MMC_PERF_PROFILING 1
+#define CONFIG_FB_MSM_OVERLAY0_WRITEBACK 1
+#define CONFIG_DEFAULT_IOSCHED "deadline"
+#define CONFIG_IPV6_MIP6 1
+#define CONFIG_NLATTR 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_ARCH_MSM8960 1
+#define CONFIG_NR_CPUS 4
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_NETFILTER_XT_CONNMARK 1
+#define CONFIG_HID_KYE 1
+#define CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define CONFIG_FIRMWARE_IN_KERNEL 1
+#define CONFIG_SYSFS 1
+#define CONFIG_MSM7X00A_IDLE_SPIN_TIME 80000
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_IP_NF_MATCH_AH 1
+#define CONFIG_TCP_CONG_VENO 1
+#define CONFIG_SLIMBUS 1
+#define CONFIG_NETFILTER_XT_MATCH_LIMIT 1
+#define CONFIG_N_SMUX_LOOPBACK 1
+#define CONFIG_CC_STACKPROTECTOR 1
+#define CONFIG_XZ_DEC_ARM 1
+#define CONFIG_FB_SYS_FOPS 1
+#define CONFIG_MEDIA_TUNER_XC4000 1
+#define CONFIG_FB 1
+#define CONFIG_TRACING 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_CPU_32v7 1
+#define CONFIG_MSM_BUSPM_DEV 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FRANDOM 1
+#define CONFIG_BT_HCIUART 1
+#define CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE 0
+#define CONFIG_FB_MSM_DEFAULT_DEPTH_BGRA8888 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_THERMAL 1
+#define CONFIG_NET_VENDOR_3COM 1
+#define CONFIG_HID_PETALYNX 1
+#define CONFIG_CMA_SIZE_MBYTES 16
+#define CONFIG_MSM_VIDC 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_NF_CONNTRACK_IPV4 1
+#define CONFIG_ZONE_DMA_FLAG 0
+#define CONFIG_MSM_KGSL 1
+#define CONFIG_SERIAL_MSM_HSL 1
+#define CONFIG_NET_VENDOR_INTEL 1
+#define CONFIG_RPS 1
+#define CONFIG_USB_NET_ZAURUS 1
+#define CONFIG_INET6_XFRM_TUNNEL 1
+#define CONFIG_PROC_PID_CPUSET 1
+#define CONFIG_WCD9310_CODEC 1
+#define CONFIG_MSM_RPM_STATS_LOG 1
+#define CONFIG_NET_EMATCH_NBYTE 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_WAKELOCK_STAT 1
+#define CONFIG_INPUT_KEYCHORD 1
+#define CONFIG_MFD_PM8921_CORE 1
+#define CONFIG_HAS_EARLYSUSPEND 1
+#define CONFIG_CPU_32v6K 1
+#define CONFIG_NET_VENDOR_CISCO 1
+#define CONFIG_HID_LOGITECH_DJ 1
+#define CONFIG_DEFAULT_SECURITY "selinux"
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_NF_NAT_PROTO_UDPLITE 1
+#define CONFIG_USB_SERIAL_SIERRAWIRELESS 1
+#define CONFIG_CRYPTO_CTR 1
+#define CONFIG_CGROUP_DEBUG 1
+#define CONFIG_RMNET_SMD_CTL_CHANNEL ""
+#define CONFIG_SW_SYNC 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_MSM_PIL_GSS 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_MUTEX_SPIN_ON_OWNER 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_HAVE_DMA_ATTRS 1
+#define CONFIG_USB_SERIAL_CSVT 1
+#define CONFIG_SND_SOC_MSM_QDSP6_HDMI_AUDIO 1
+#define CONFIG_VIDEOBUF2_CORE 1
+#define CONFIG_THERMAL_PM8XXX 1
+#define CONFIG_IRTTY_SIR 1
+#define CONFIG_CPUPOWER 1
+#define CONFIG_MSM_SPM_V2 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_SECURITY_SELINUX_AVC_STATS 1
+#define CONFIG_DEVPTS_MULTIPLE_INSTANCES 1
+#define CONFIG_MSM_SLEEPER 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_NET_PACKET_ENGINE 1
+#define CONFIG_VIDEOBUF2_VMALLOC 1
+#define CONFIG_RC_MAP 1
+#define CONFIG_WEXT_PRIV 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_SND_SOC_MSM8960 1
+#define CONFIG_HID_PANTHERLORD 1
+#define CONFIG_SND 1
+#define CONFIG_IR_RC6_DECODER 1
+#define CONFIG_ARCH_MSM8930 1
+#define CONFIG_MSM_TZ_LOG 1
+#define CONFIG_SND_SOC_MSM_STUB 1
+#define CONFIG_MSM_EVENT_TIMER 1
+#define CONFIG_V4L_PLATFORM_DRIVERS 1
+#define CONFIG_NET_VENDOR_NATSEMI 1
+#define CONFIG_MSM_AMSS_VERSION 6225
+#define CONFIG_IKCONFIG 1
+#define CONFIG_NFS_USE_KERNEL_DNS 1
+#define CONFIG_MSM_RPM 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_ARCH_MSM 1
+#define CONFIG_LOCAL_TIMERS 1
+#define CONFIG_HAVE_C_RECORDMCOUNT 1
+#define CONFIG_HW_RANDOM_MSM 1
+#define CONFIG_CIFS 1
+#define CONFIG_XFRM_USER 1
+#define CONFIG_TCP_CONG_BIC 1
+#define CONFIG_MACH_APQ8064_DEB 1
+#define CONFIG_TASK_DELAY_ACCT 1
+#define CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT 1
+#define CONFIG_GENLOCK 1
+#define CONFIG_MSM_HSIC_SYSMON 1
+#define CONFIG_NET_NS 1
+#define CONFIG_SOUND_CONTROL_HAX_GPL 1
+#define CONFIG_MSM_EBI_ERP 1
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_NET_EMATCH_CMP 1
+#define CONFIG_MSM_ULTRASOUND 1
+#define CONFIG_PPP_ASYNC 1
+#define CONFIG_MSM_SMD_TTY 1
+#define CONFIG_UID_STAT 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_AUDIT 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_RTC_INTF_ALARM_DEV 1
+#define CONFIG_ASUSTEK_KEYPAD 1
+#define CONFIG_CMA_AREAS 7
+#define CONFIG_HID_MULTITOUCH 1
+#define CONFIG_SECURITY 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2 1
+#define CONFIG_HID_ELECOM 1
+#define CONFIG_SND_TIMER 1
+#define CONFIG_USB_EHCI_TT_NEWSCHED 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_BLK_DEV 1
+#define CONFIG_MFD_PM8821_CORE 1
+#define CONFIG_NFS_ACL_SUPPORT 1
+#define CONFIG_TCP_CONG_SCALABLE 1
+#define CONFIG_SENSORS_EPM_ADC 1
+#define CONFIG_PRIMA_WLAN_LFR 1
+#define CONFIG_IOMMU_API 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNMARK 1
+#define CONFIG_CRYPTO_ANSI_CPRNG 1
+#define CONFIG_SECURITY_SELINUX 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNSECMARK 1
+#define CONFIG_FB_MSM_MIPI_JDI_CMD_MODE 1
+#define CONFIG_PRINTK_TIME 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_SECCOMP_FILTER 1
+#define CONFIG_PPP 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA 1
+#define CONFIG_ARCH_APQ8064 1
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NF_NAT_FTP 1
+#define CONFIG_NF_CT_PROTO_UDPLITE 1
+#define CONFIG_IKCONFIG_PROC 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_TEXTSEARCH 1
+#define CONFIG_MSM_CACHE_ERP 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_SOC_MSM_QDSP6_INTF 1
+#define CONFIG_DIAGFWD_BRIDGE_CODE 1
+#define CONFIG_NETFILTER_XT_MATCH_QTAGUID 1
+#define CONFIG_STAGING 1
+#define CONFIG_USB_QCOM_MDM_BRIDGE 1
+#define CONFIG_NET_VENDOR_SIS 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_HID_UCLOGIC 1
+#define CONFIG_MSM_IDLE_STATS 1
+#define CONFIG_BT_HCIUART_IBS 1
+#define CONFIG_FANOTIFY_ACCESS_PERMISSIONS 1
+#define CONFIG_CFG80211_WEXT 1
+#define CONFIG_MSM_RMNET_USB 1
+#define CONFIG_USB_QCOM_KS_BRIDGE 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE 1
+#define CONFIG_USB_STORAGE_FREECOM 1
+#define CONFIG_IR_RC5_DECODER 1
+#define CONFIG_DRM 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define CONFIG_MSM_RPM_RBCPR_STATS_LOG 1
+#define CONFIG_PREEMPT 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MSM_CACHE_DUMP_ON_PANIC 1
+#define CONFIG_BINARY_PRINTF 1
+#define CONFIG_USB_STORAGE_JUMPSHOT 1
+#define CONFIG_FB_MSM_HDMI_MSM_PANEL 1
+#define CONFIG_MMC_CLKGATE 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_MSM_N_WAY_SMD 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_HID_NTRIG 1
+#define CONFIG_DMA_SHARED_BUFFER 1
+#define CONFIG_CIFS_POSIX 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_DECOMPRESS_LZO 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_CROSS_COMPILE ""
+#define CONFIG_MEDIA_TUNER_TEA5761 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_HID_HOLTEK 1
+#define CONFIG_CRYPTO_AES_ARM 1
+#define CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define CONFIG_XZ_DEC_ARMTHUMB 1
+#define CONFIG_MSM_PIL_RIVA 1
+#define CONFIG_REGMAP 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_JOYSTICK_XPAD 1
+#define CONFIG_NETFILTER_TPROXY 1
+#define CONFIG_MSM_RUN_QUEUE_STATS 1
+#define CONFIG_USB_USBNET 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_FHANDLE 1
+#define CONFIG_HID_SMARTJOYPLUS 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_SWAP 1
+#define CONFIG_SND_SOC_VOICE 1
+#define CONFIG_CRC_CCITT 1
+#define CONFIG_ANDROID_PMEM 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_NETFILTER_NETLINK 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_WAKE_TIMEOUT 1
+#define CONFIG_AVERAGE 1
+#define CONFIG_MSM_RPM_REGULATOR 1
+#define CONFIG_PREEMPT_COUNT 1
+#define CONFIG_USB_ARCH_HAS_XHCI 1
+#define CONFIG_USB_GADGET_DEBUG_FILES 1
+#define CONFIG_MSM_HSIC_TTY 1
+#define CONFIG_ARCH_MSM_KRAITMP 1
+#define CONFIG_CMA 1
+#define CONFIG_CHARGER_SMB345 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_BITREVERSE 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_MSM_ROTATOR 1
+#define CONFIG_BLK_DEV_RAM_SIZE 4096
+#define CONFIG_USB_SERIAL_WWAN 1
+#define CONFIG_PRIMA_WLAN_OKC 1
+#define CONFIG_MSM_IDLE_STATS_BUCKET_SHIFT 2
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_UIO_MSM_SHAREDMEM 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_MSM_GPIOMUX 1
+#define CONFIG_MFD_PM8XXX_DEBUG 1
+#define CONFIG_USB_STORAGE_ONETOUCH 1
+#define CONFIG_MSM_N_WAY_SMSM 1
+#define CONFIG_NF_CONNTRACK 1
+#define CONFIG_IOSCHED_FIOPS 1
+#define CONFIG_LCD_CLASS_DEVICE 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_SND_SOC_I2C_AND_SPI 1
+#define CONFIG_MSM_MULTIMEDIA_USE_ION 1
+#define CONFIG_AIO 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_PERF_EVENTS 1
+#define CONFIG_IP_NF_TARGET_REJECT 1
+#define CONFIG_LEDS_CLASS 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_FB_MSM_HDMI_3D 1
+#define CONFIG_DEFAULT_DEADLINE 1
+#define CONFIG_EXT4_FS_XATTR 1
+#define CONFIG_MSM_MODEM_8960 1
+#define CONFIG_LOCKUP_DETECTOR 1
+#define CONFIG_NET_ACTIVITY_STATS 1
+#define CONFIG_CMA_ALIGNMENT 8
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_UTS_NS 1
+#define CONFIG_NF_CT_PROTO_GRE 1
+#define CONFIG_NF_CT_NETLINK 1
+#define CONFIG_NET_EMATCH_TEXT 1
+#define CONFIG_DEFAULT_SECURITY_SELINUX 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_MOUSE_PS2 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_NETFILTER_XT_MATCH_HL 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_WEXT_SPY 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_HAVE_MEMBLOCK 1
+#define CONFIG_INPUT 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RD_LZ4 1
+#define CONFIG_MMU 1
+#define CONFIG_HAVE_IRQ_WORK 1
+#define CONFIG_USER_WAKELOCK 1
+#define CONFIG_USB_SIERRA_NET 1
+#define CONFIG_ENABLE_DEFAULT_TRACERS 1
+#define CONFIG_MSM7X00A_IDLE_SLEEP_MODE 1
+#define CONFIG_MFD_PM8821_IRQ 1
diff -urN flo-ElementalX-5.00/include/generated/bounds.h flo-ElementalX-5.00-patched/include/generated/bounds.h
--- flo-ElementalX-5.00/include/generated/bounds.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/bounds.h	2016-06-01 21:26:31.000000000 +0000
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define NR_PAGEFLAGS 22 /* __NR_PAGEFLAGS	@ */
+#define MAX_NR_ZONES 3 /* __MAX_NR_ZONES	@ */
+#define NR_PCG_FLAGS 3 /* __NR_PCG_FLAGS	@ */
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/compile.h flo-ElementalX-5.00-patched/include/generated/compile.h
--- flo-ElementalX-5.00/include/generated/compile.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/compile.h	2016-06-03 17:56:07.000000000 +0000
@@ -0,0 +1,7 @@
+/* This file is auto generated, version 37 */
+/* SMP PREEMPT */
+#define UTS_MACHINE "arm"
+#define UTS_VERSION "#37 SMP PREEMPT Fri Jun 3 17:56:07 Local time zone must be set--"
+#define LINUX_COMPILE_BY "root"
+#define LINUX_COMPILE_HOST "porteus"
+#define LINUX_COMPILER "gcc version 4.9.4 20151028 (prerelease) (Linaro GCC 4.9-2016.02) "
diff -urN flo-ElementalX-5.00/include/generated/mach-types.h flo-ElementalX-5.00-patched/include/generated/mach-types.h
--- flo-ElementalX-5.00/include/generated/mach-types.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/mach-types.h	2016-06-01 15:48:31.000000000 +0000
@@ -0,0 +1,15351 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_GUMSTIX              373
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_PALMLD               835
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_PALMTE2              844
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_PALMTX               885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_OMAP_3430SDP         1138
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_TREO680              1230
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COLIBRI320           1340
+#define MACH_TYPE_CAM60                1351
+#define MACH_TYPE_AT91EB01             1354
+#define MACH_TYPE_DB88F5281            1358
+#define MACH_TYPE_CSB726               1359
+#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
+#define MACH_TYPE_LITTLETON            1388
+#define MACH_TYPE_REALVIEW_PB11MP      1407
+#define MACH_TYPE_MX27_3DS             1430
+#define MACH_TYPE_HALIBUT              1439
+#define MACH_TYPE_TROUT                1440
+#define MACH_TYPE_TCT_HAMMER           1460
+#define MACH_TYPE_HERALD               1461
+#define MACH_TYPE_SIM_ONE              1476
+#define MACH_TYPE_JIVE                 1490
+#define MACH_TYPE_SAM9_L9260           1501
+#define MACH_TYPE_REALVIEW_PB1176      1504
+#define MACH_TYPE_YL9200               1507
+#define MACH_TYPE_RD88F5182            1508
+#define MACH_TYPE_KUROBOX_PRO          1509
+#define MACH_TYPE_MX31_3DS             1511
+#define MACH_TYPE_QONG                 1524
+#define MACH_TYPE_OMAP2EVM             1534
+#define MACH_TYPE_OMAP3EVM             1535
+#define MACH_TYPE_DNS323               1542
+#define MACH_TYPE_OMAP3_BEAGLE         1546
+#define MACH_TYPE_NOKIA_N810           1548
+#define MACH_TYPE_PCM038               1551
+#define MACH_TYPE_TS209                1565
+#define MACH_TYPE_AT91CAP9ADK          1566
+#define MACH_TYPE_MX31MOBOARD          1574
+#define MACH_TYPE_VISION_EP9307        1578
+#define MACH_TYPE_TERASTATION_PRO2     1584
+#define MACH_TYPE_LINKSTATION_PRO      1585
+#define MACH_TYPE_E350                 1596
+#define MACH_TYPE_TS409                1601
+#define MACH_TYPE_RSI_EWS              1609
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_NEUROS_OSD2          1647
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_DAVINCI_DA830_EVM    1781
+#define MACH_TYPE_DOVE_DB              1788
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_USB_A9G20            1841
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_EUKREA_CPUIMX27      1975
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_TX37                 2127
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_TX25                 2177
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_VEXPRESS             2272
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_SMDK6442             2324
+#define MACH_TYPE_OPENRD_BASE          2325
+#define MACH_TYPE_DEVKIT8000           2330
+#define MACH_TYPE_MX51_EFIKAMX         2336
+#define MACH_TYPE_CM_T35               2341
+#define MACH_TYPE_NET2BIG              2342
+#define MACH_TYPE_IGEP0020             2344
+#define MACH_TYPE_NUC932EVB            2356
+#define MACH_TYPE_OPENRD_CLIENT        2361
+#define MACH_TYPE_U8500                2368
+#define MACH_TYPE_MX51_EFIKASB         2370
+#define MACH_TYPE_MARVELL_JASPER       2382
+#define MACH_TYPE_FLINT                2383
+#define MACH_TYPE_TAVOREVB3            2384
+#define MACH_TYPE_TOUCHBOOK            2393
+#define MACH_TYPE_RAUMFELD_RC          2413
+#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
+#define MACH_TYPE_RAUMFELD_SPEAKER     2415
+#define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_MX51_M2ID            2428
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_TX51                 2529
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_RIOT_BEI2            2576
+#define MACH_TYPE_RIOT_X37             2578
+#define MACH_TYPE_PCA101               2595
+#define MACH_TYPE_CAPC7117             2612
+#define MACH_TYPE_ICONTROL             2624
+#define MACH_TYPE_GPLUGD               2625
+#define MACH_TYPE_QSD8X50A_ST1_5       2627
+#define MACH_TYPE_MX23EVK              2629
+#define MACH_TYPE_AP4EVB               2630
+#define MACH_TYPE_MITYOMAPL138         2650
+#define MACH_TYPE_GURUPLUG             2659
+#define MACH_TYPE_SPEAR310             2660
+#define MACH_TYPE_SPEAR320             2661
+#define MACH_TYPE_AQUILA               2676
+#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
+#define MACH_TYPE_MSM7X30_SURF         2679
+#define MACH_TYPE_EA2478DEVKIT         2683
+#define MACH_TYPE_TERASTATION_WXL      2697
+#define MACH_TYPE_MSM7X25_SURF         2703
+#define MACH_TYPE_MSM7X25_FFA          2704
+#define MACH_TYPE_MSM7X27_SURF         2705
+#define MACH_TYPE_MSM7X27_FFA          2706
+#define MACH_TYPE_MSM7X30_FFA          2707
+#define MACH_TYPE_QSD8X50_SURF         2708
+#define MACH_TYPE_QSD8X50_FFA          2710
+#define MACH_TYPE_MX53_EVK             2716
+#define MACH_TYPE_IGEP0030             2717
+#define MACH_TYPE_SBC3530              2722
+#define MACH_TYPE_SAARB                2727
+#define MACH_TYPE_HARMONY              2731
+#define MACH_TYPE_MSM7X30_FLUID        2741
+#define MACH_TYPE_CM_T3517             2750
+#define MACH_TYPE_WBD222               2753
+#define MACH_TYPE_MSM8X60_SURF         2755
+#define MACH_TYPE_MSM8X60_SIM          2756
+#define MACH_TYPE_TCC8000_SDK          2758
+#define MACH_TYPE_NANOS                2759
+#define MACH_TYPE_STAMP9G45            2761
+#define MACH_TYPE_MSM8X55_SURF         2768
+#define MACH_TYPE_MSM8X55_FFA          2769
+#define MACH_TYPE_CNS3420VB            2776
+#define MACH_TYPE_OMAP4_PANDA          2791
+#define MACH_TYPE_TI8168EVM            2800
+#define MACH_TYPE_TETON_BGA            2816
+#define MACH_TYPE_EUKREA_CPUIMX25SD    2820
+#define MACH_TYPE_EUKREA_CPUIMX35SD    2821
+#define MACH_TYPE_EUKREA_CPUIMX51SD    2822
+#define MACH_TYPE_EUKREA_CPUIMX51      2823
+#define MACH_TYPE_SMDKC210             2838
+#define MACH_TYPE_PCA102               2843
+#define MACH_TYPE_T5325                2846
+#define MACH_TYPE_INCOME               2849
+#define MACH_TYPE_VVBOX_SDORIG2        2857
+#define MACH_TYPE_VVBOX_SDLITE2        2858
+#define MACH_TYPE_VVBOX_SDPRO4         2859
+#define MACH_TYPE_MX257SX              2861
+#define MACH_TYPE_GONI                 2862
+#define MACH_TYPE_MSM8X55_SVLTE_FFA    2863
+#define MACH_TYPE_MSM8X55_SVLTE_SURF   2864
+#define MACH_TYPE_BV07                 2882
+#define MACH_TYPE_OPENRD_ULTIMATE      2884
+#define MACH_TYPE_DEVIXP               2885
+#define MACH_TYPE_MICCPT               2886
+#define MACH_TYPE_MIC256               2887
+#define MACH_TYPE_U5500                2890
+#define MACH_TYPE_LINKSTATION_LSCHL    2913
+#define MACH_TYPE_SMDKV310             2925
+#define MACH_TYPE_WM8505_7IN_NETBOOK   2928
+#define MACH_TYPE_CRANEBOARD           2932
+#define MACH_TYPE_SMDK6450             2938
+#define MACH_TYPE_BROWNSTONE           2957
+#define MACH_TYPE_FLEXIBITY            2965
+#define MACH_TYPE_MX50_RDP             2988
+#define MACH_TYPE_UNIVERSAL_C210       2989
+#define MACH_TYPE_REAL6410             2990
+#define MACH_TYPE_DOCKSTAR             2998
+#define MACH_TYPE_TI8148EVM            3004
+#define MACH_TYPE_SEABOARD             3005
+#define MACH_TYPE_MX53_ARD             3010
+#define MACH_TYPE_MX53_SMD             3011
+#define MACH_TYPE_MSM8X60_RUMI3        3016
+#define MACH_TYPE_MSM8X60_FFA          3017
+#define MACH_TYPE_CM_A510              3020
+#define MACH_TYPE_FSM9XXX_SURF         3028
+#define MACH_TYPE_FSM9XXX_FFA          3029
+#define MACH_TYPE_TX28                 3043
+#define MACH_TYPE_PCONTROL_G20         3062
+#define MACH_TYPE_VPR200               3087
+#define MACH_TYPE_TORBRECK             3090
+#define MACH_TYPE_PRIMA2_EVB           3103
+#define MACH_TYPE_MSM8X60_FLUID        3124
+#define MACH_TYPE_PAZ00                3128
+#define MACH_TYPE_ACMENETUSFOXG20      3129
+#define MACH_TYPE_MSM8X60_FUSION       3181
+#define MACH_TYPE_AG5EVM               3189
+#define MACH_TYPE_TSUNAGI              3197
+#define MACH_TYPE_MSM8X60_FUSN_FFA     3199
+#define MACH_TYPE_ICS_IF_VOIP          3206
+#define MACH_TYPE_WLF_CRAGG_6410       3207
+#define MACH_TYPE_TRIMSLICE            3209
+#define MACH_TYPE_MACKEREL             3211
+#define MACH_TYPE_KAEN                 3217
+#define MACH_TYPE_NOKIA_RM680          3220
+#define MACH_TYPE_DM6446_ADBOX         3226
+#define MACH_TYPE_QUAD_SALSA           3227
+#define MACH_TYPE_ABB_GMA_1_1          3228
+#define MACH_TYPE_SVCID                3229
+#define MACH_TYPE_MSM8960_SIM          3230
+#define MACH_TYPE_MSM8960_RUMI3        3231
+#define MACH_TYPE_ICON_G               3232
+#define MACH_TYPE_MB3                  3233
+#define MACH_TYPE_GSIA18S              3234
+#define MACH_TYPE_PIVICC               3235
+#define MACH_TYPE_PCM048               3236
+#define MACH_TYPE_DDS                  3237
+#define MACH_TYPE_CHALTEN_XA1          3238
+#define MACH_TYPE_TS48XX               3239
+#define MACH_TYPE_TONGA2_TFTTIMER      3240
+#define MACH_TYPE_WHISTLER             3241
+#define MACH_TYPE_ASL_PHOENIX          3242
+#define MACH_TYPE_AT91SAM9263OTLITE    3243
+#define MACH_TYPE_DDPLUG               3244
+#define MACH_TYPE_D2PLUG               3245
+#define MACH_TYPE_KZM9D                3246
+#define MACH_TYPE_VERDI_LTE            3247
+#define MACH_TYPE_NANOZOOM             3248
+#define MACH_TYPE_DM3730_SOM_LV        3249
+#define MACH_TYPE_DM3730_TORPEDO       3250
+#define MACH_TYPE_ANCHOVY              3251
+#define MACH_TYPE_RE2REV20             3253
+#define MACH_TYPE_RE2REV21             3254
+#define MACH_TYPE_CNS21XX              3255
+#define MACH_TYPE_RIDER                3257
+#define MACH_TYPE_NSK330               3258
+#define MACH_TYPE_CNS2133EVB           3259
+#define MACH_TYPE_Z3_816X_MOD          3260
+#define MACH_TYPE_Z3_814X_MOD          3261
+#define MACH_TYPE_BEECT                3262
+#define MACH_TYPE_DMA_THUNDERBUG       3263
+#define MACH_TYPE_OMN_AT91SAM9G20      3264
+#define MACH_TYPE_MX25_E2S_UC          3265
+#define MACH_TYPE_MIONE                3266
+#define MACH_TYPE_TOP9000_TCU          3267
+#define MACH_TYPE_TOP9000_BSL          3268
+#define MACH_TYPE_KINGDOM              3269
+#define MACH_TYPE_ARMADILLO460         3270
+#define MACH_TYPE_LQ2                  3271
+#define MACH_TYPE_SWEDA_TMS2           3272
+#define MACH_TYPE_MX53_LOCO            3273
+#define MACH_TYPE_ACER_A8              3275
+#define MACH_TYPE_ACER_GAUGUIN         3276
+#define MACH_TYPE_GUPPY                3277
+#define MACH_TYPE_MX61_ARD             3278
+#define MACH_TYPE_TX53                 3279
+#define MACH_TYPE_OMAPL138_CASE_A3     3280
+#define MACH_TYPE_UEMD                 3281
+#define MACH_TYPE_CCWMX51MUT           3282
+#define MACH_TYPE_ROCKHOPPER           3283
+#define MACH_TYPE_ENCORE               3284
+#define MACH_TYPE_HKDKC100             3285
+#define MACH_TYPE_TS42XX               3286
+#define MACH_TYPE_AEBL                 3287
+#define MACH_TYPE_WARIO                3288
+#define MACH_TYPE_GFS_SPM              3289
+#define MACH_TYPE_CM_T3730             3290
+#define MACH_TYPE_ISC3                 3291
+#define MACH_TYPE_RASCAL               3292
+#define MACH_TYPE_HREFV60              3293
+#define MACH_TYPE_TPT_2_0              3294
+#define MACH_TYPE_SPLENDOR             3296
+#define MACH_TYPE_MSM8X60_QT           3298
+#define MACH_TYPE_HTC_HD_MINI          3299
+#define MACH_TYPE_ATHENE               3300
+#define MACH_TYPE_DEEP_R_EK_1          3301
+#define MACH_TYPE_VIVOW_CT             3302
+#define MACH_TYPE_NERY_1000            3303
+#define MACH_TYPE_RFL109145_SSRV       3304
+#define MACH_TYPE_NMH                  3305
+#define MACH_TYPE_WN802T               3306
+#define MACH_TYPE_DRAGONET             3307
+#define MACH_TYPE_AT91SAM9263DESK16L   3309
+#define MACH_TYPE_BCMHANA_SV           3310
+#define MACH_TYPE_BCMHANA_TABLET       3311
+#define MACH_TYPE_KOI                  3312
+#define MACH_TYPE_TS4800               3313
+#define MACH_TYPE_TQMA9263             3314
+#define MACH_TYPE_HOLIDAY              3315
+#define MACH_TYPE_PCATS_OVERLAY        3317
+#define MACH_TYPE_HWGW6410             3318
+#define MACH_TYPE_SHENZHOU             3319
+#define MACH_TYPE_CWME9210             3320
+#define MACH_TYPE_CWME9210JS           3321
+#define MACH_TYPE_COLIBRI_TEGRA2       3323
+#define MACH_TYPE_W21                  3324
+#define MACH_TYPE_POLYSAT1             3325
+#define MACH_TYPE_DATAWAY              3326
+#define MACH_TYPE_COBRAL138            3327
+#define MACH_TYPE_ROVERPCS8            3328
+#define MACH_TYPE_MARVELC              3329
+#define MACH_TYPE_NAVEFIHID            3330
+#define MACH_TYPE_DM365_CV100          3331
+#define MACH_TYPE_ABLE                 3332
+#define MACH_TYPE_LEGACY               3333
+#define MACH_TYPE_ICONG                3334
+#define MACH_TYPE_ROVER_G8             3335
+#define MACH_TYPE_T5388P               3336
+#define MACH_TYPE_DINGO                3337
+#define MACH_TYPE_GOFLEXHOME           3338
+#define MACH_TYPE_LANREADYFN511        3340
+#define MACH_TYPE_OMAP3_BAIA           3341
+#define MACH_TYPE_OMAP3SMARTDISPLAY    3342
+#define MACH_TYPE_XILINX               3343
+#define MACH_TYPE_A2F                  3344
+#define MACH_TYPE_SKY25                3345
+#define MACH_TYPE_CCMX53               3346
+#define MACH_TYPE_CCMX53JS             3347
+#define MACH_TYPE_CCWMX53              3348
+#define MACH_TYPE_CCWMX53JS            3349
+#define MACH_TYPE_FRISMS               3350
+#define MACH_TYPE_MSM7X27A_FFA         3351
+#define MACH_TYPE_MSM7X27A_SURF        3352
+#define MACH_TYPE_MSM7X27A_RUMI3       3353
+#define MACH_TYPE_DIMMSAM9G20          3354
+#define MACH_TYPE_DIMM_IMX28           3355
+#define MACH_TYPE_AMK_A4               3356
+#define MACH_TYPE_GNET_SGME            3357
+#define MACH_TYPE_SHOOTER_U            3358
+#define MACH_TYPE_VMX53                3359
+#define MACH_TYPE_RHINO                3360
+#define MACH_TYPE_ARMLEX4210           3361
+#define MACH_TYPE_SWARCOEXTMODEM       3362
+#define MACH_TYPE_SNOWBALL             3363
+#define MACH_TYPE_PCM049               3364
+#define MACH_TYPE_VIGOR                3365
+#define MACH_TYPE_OSLO_AMUNDSEN        3366
+#define MACH_TYPE_GSL_DIAMOND          3367
+#define MACH_TYPE_CV2201               3368
+#define MACH_TYPE_CV2202               3369
+#define MACH_TYPE_CV2203               3370
+#define MACH_TYPE_VIT_IBOX             3371
+#define MACH_TYPE_DM6441_ESP           3372
+#define MACH_TYPE_AT91SAM9X5EK         3373
+#define MACH_TYPE_LIBRA                3374
+#define MACH_TYPE_EASYCRRH             3375
+#define MACH_TYPE_TRIPEL               3376
+#define MACH_TYPE_ENDIAN_MINI          3377
+#define MACH_TYPE_XILINX_EP107         3378
+#define MACH_TYPE_NURI                 3379
+#define MACH_TYPE_JANUS                3380
+#define MACH_TYPE_DDNAS                3381
+#define MACH_TYPE_TAG                  3382
+#define MACH_TYPE_TAGW                 3383
+#define MACH_TYPE_NITROGEN_VM_IMX51    3384
+#define MACH_TYPE_VIPRINET             3385
+#define MACH_TYPE_BOCKW                3386
+#define MACH_TYPE_EVA2000              3387
+#define MACH_TYPE_STEELYARD            3388
+#define MACH_TYPE_NSSLSBOARD           3392
+#define MACH_TYPE_GENEVA_B5            3393
+#define MACH_TYPE_SPEAR1340            3394
+#define MACH_TYPE_REXMAS               3395
+#define MACH_TYPE_MSM8960_CDP          3396
+#define MACH_TYPE_MSM8960_MTP          3397
+#define MACH_TYPE_MSM8960_FLUID        3398
+#define MACH_TYPE_MSM8960_APQ          3399
+#define MACH_TYPE_HELIOS_V2            3400
+#define MACH_TYPE_MIF10P               3401
+#define MACH_TYPE_IAM28                3402
+#define MACH_TYPE_PICASSO              3403
+#define MACH_TYPE_MR301A               3404
+#define MACH_TYPE_NOTLE                3405
+#define MACH_TYPE_EELX2                3406
+#define MACH_TYPE_MOON                 3407
+#define MACH_TYPE_RUBY                 3408
+#define MACH_TYPE_GOLDENGATE           3409
+#define MACH_TYPE_CTBU_GEN2            3410
+#define MACH_TYPE_KMP_AM17_01          3411
+#define MACH_TYPE_WTPLUG               3412
+#define MACH_TYPE_MX27SU2              3413
+#define MACH_TYPE_NB31                 3414
+#define MACH_TYPE_HJSDU                3415
+#define MACH_TYPE_TD3_REV1             3416
+#define MACH_TYPE_EAG_CI4000           3417
+#define MACH_TYPE_NET5BIG_NAND_V2      3418
+#define MACH_TYPE_CPX2                 3419
+#define MACH_TYPE_NET2BIG_NAND_V2      3420
+#define MACH_TYPE_ECUV5                3421
+#define MACH_TYPE_HSGX6D               3422
+#define MACH_TYPE_DAWAD7               3423
+#define MACH_TYPE_SAM9REPEATER         3424
+#define MACH_TYPE_GT_I5700             3425
+#define MACH_TYPE_CTERA_PLUG_C2        3426
+#define MACH_TYPE_MARVELCT             3427
+#define MACH_TYPE_AG11005              3428
+#define MACH_TYPE_VANGOGH              3430
+#define MACH_TYPE_MATRIX505            3431
+#define MACH_TYPE_OCE_NIGMA            3432
+#define MACH_TYPE_T55                  3433
+#define MACH_TYPE_BIO3K                3434
+#define MACH_TYPE_EXPRESSCT            3435
+#define MACH_TYPE_CARDHU               3436
+#define MACH_TYPE_ARUBA                3437
+#define MACH_TYPE_BONAIRE              3438
+#define MACH_TYPE_NUC700EVB            3439
+#define MACH_TYPE_NUC710EVB            3440
+#define MACH_TYPE_NUC740EVB            3441
+#define MACH_TYPE_NUC745EVB            3442
+#define MACH_TYPE_TRANSCEDE            3443
+#define MACH_TYPE_MORA                 3444
+#define MACH_TYPE_NDA_EVM              3445
+#define MACH_TYPE_TIMU                 3446
+#define MACH_TYPE_EXPRESSH             3447
+#define MACH_TYPE_VERIDIS_A300         3448
+#define MACH_TYPE_DM368_LEOPARD        3449
+#define MACH_TYPE_OMAP_MCOP            3450
+#define MACH_TYPE_TRITIP               3451
+#define MACH_TYPE_SM1K                 3452
+#define MACH_TYPE_MONCH                3453
+#define MACH_TYPE_CURACAO              3454
+#define MACH_TYPE_ORIGEN               3455
+#define MACH_TYPE_EPC10                3456
+#define MACH_TYPE_SGH_I740             3457
+#define MACH_TYPE_TUNA                 3458
+#define MACH_TYPE_MX51_TULIP           3459
+#define MACH_TYPE_MX51_ASTER7          3460
+#define MACH_TYPE_ACRO37XBRD           3461
+#define MACH_TYPE_ELKE                 3462
+#define MACH_TYPE_SBC6000X             3463
+#define MACH_TYPE_R1801E               3464
+#define MACH_TYPE_H1600                3465
+#define MACH_TYPE_MINI210              3466
+#define MACH_TYPE_MINI8168             3467
+#define MACH_TYPE_PC7308               3468
+#define MACH_TYPE_KMM2M01              3470
+#define MACH_TYPE_MX51EREBUS           3471
+#define MACH_TYPE_WM8650REFBOARD       3472
+#define MACH_TYPE_TUXRAIL              3473
+#define MACH_TYPE_ARTHUR               3474
+#define MACH_TYPE_DOORBOY              3475
+#define MACH_TYPE_XARINA               3476
+#define MACH_TYPE_ROVERX7              3477
+#define MACH_TYPE_SDVR                 3478
+#define MACH_TYPE_ACER_MAYA            3479
+#define MACH_TYPE_PICO                 3480
+#define MACH_TYPE_CWMX233              3481
+#define MACH_TYPE_CWAM1808             3482
+#define MACH_TYPE_CWDM365              3483
+#define MACH_TYPE_MX51_MORAY           3484
+#define MACH_TYPE_THALES_CBC           3485
+#define MACH_TYPE_BLUEPOINT            3486
+#define MACH_TYPE_DIR665               3487
+#define MACH_TYPE_ACMEROVER1           3488
+#define MACH_TYPE_SHOOTER_CT           3489
+#define MACH_TYPE_BLISS                3490
+#define MACH_TYPE_BLISSC               3491
+#define MACH_TYPE_THALES_ADC           3492
+#define MACH_TYPE_UBISYS_P9D_EVP       3493
+#define MACH_TYPE_ATDGP318             3494
+#define MACH_TYPE_DMA210U              3495
+#define MACH_TYPE_EM_T3                3496
+#define MACH_TYPE_HTX3250              3497
+#define MACH_TYPE_G50                  3498
+#define MACH_TYPE_ECO5                 3499
+#define MACH_TYPE_WINTERGRASP          3500
+#define MACH_TYPE_PURO                 3501
+#define MACH_TYPE_SHOOTER_K            3502
+#define MACH_TYPE_NSPIRE               3503
+#define MACH_TYPE_MICKXX               3504
+#define MACH_TYPE_LXMB                 3505
+#define MACH_TYPE_ADAM                 3507
+#define MACH_TYPE_B1004                3508
+#define MACH_TYPE_OBOEA                3509
+#define MACH_TYPE_A1015                3510
+#define MACH_TYPE_ROBIN_VBDT30         3511
+#define MACH_TYPE_TEGRA_ENTERPRISE     3512
+#define MACH_TYPE_RFL108200_MK10       3513
+#define MACH_TYPE_RFL108300_MK16       3514
+#define MACH_TYPE_ROVER_V7             3515
+#define MACH_TYPE_MIPHONE              3516
+#define MACH_TYPE_FEMTOBTS             3517
+#define MACH_TYPE_MONOPOLI             3518
+#define MACH_TYPE_BOSS                 3519
+#define MACH_TYPE_DAVINCI_DM368_VTAM   3520
+#define MACH_TYPE_CLCON                3521
+#define MACH_TYPE_NOKIA_RM696          3522
+#define MACH_TYPE_TAHITI               3523
+#define MACH_TYPE_FIGHTER              3524
+#define MACH_TYPE_SGH_I710             3525
+#define MACH_TYPE_INTEGREPROSCB        3526
+#define MACH_TYPE_MONZA                3527
+#define MACH_TYPE_CALIMAIN             3528
+#define MACH_TYPE_MX6Q_SABREAUTO       3529
+#define MACH_TYPE_GMA01X               3530
+#define MACH_TYPE_SBC51                3531
+#define MACH_TYPE_FIT                  3532
+#define MACH_TYPE_STEELHEAD            3533
+#define MACH_TYPE_PANTHER              3534
+#define MACH_TYPE_MSM8960_LIQUID       3535
+#define MACH_TYPE_LEXIKONCT            3536
+#define MACH_TYPE_NS2816_STB           3537
+#define MACH_TYPE_SEI_MM2_LPC3250      3538
+#define MACH_TYPE_CMIMX53              3539
+#define MACH_TYPE_SANDWICH             3540
+#define MACH_TYPE_CHIEF                3541
+#define MACH_TYPE_POGO_E02             3542
+#define MACH_TYPE_MIKRAP_X168          3543
+#define MACH_TYPE_HTCMOZART            3544
+#define MACH_TYPE_HTCGOLD              3545
+#define MACH_TYPE_MT72XX               3546
+#define MACH_TYPE_MX51_IVY             3547
+#define MACH_TYPE_MX51_LVD             3548
+#define MACH_TYPE_OMAP3_WISER2         3549
+#define MACH_TYPE_DREAMPLUG            3550
+#define MACH_TYPE_COBAS_C_111          3551
+#define MACH_TYPE_COBAS_U_411          3552
+#define MACH_TYPE_HSSD                 3553
+#define MACH_TYPE_IOM35X               3554
+#define MACH_TYPE_PSOM_OMAP            3555
+#define MACH_TYPE_IPHONE_2G            3556
+#define MACH_TYPE_IPHONE_3G            3557
+#define MACH_TYPE_IPOD_TOUCH_1G        3558
+#define MACH_TYPE_PHAROS_TPC           3559
+#define MACH_TYPE_MX53_HYDRA           3560
+#define MACH_TYPE_NS2816_DEV_BOARD     3561
+#define MACH_TYPE_IPHONE_3GS           3562
+#define MACH_TYPE_IPHONE_4             3563
+#define MACH_TYPE_IPOD_TOUCH_4G        3564
+#define MACH_TYPE_DRAGON_E1100         3565
+#define MACH_TYPE_TOPSIDE              3566
+#define MACH_TYPE_IRISIII              3567
+#define MACH_TYPE_DETO_MACARM9         3568
+#define MACH_TYPE_ETI_D1               3569
+#define MACH_TYPE_SOM3530SDK           3570
+#define MACH_TYPE_OC_ENGINE            3571
+#define MACH_TYPE_APQ8064_SIM          3572
+#define MACH_TYPE_ALPS                 3575
+#define MACH_TYPE_TNY_T3730            3576
+#define MACH_TYPE_GERYON_NFE           3577
+#define MACH_TYPE_NS2816_REF_BOARD     3578
+#define MACH_TYPE_SILVERSTONE          3579
+#define MACH_TYPE_MTT2440              3580
+#define MACH_TYPE_YNICDB               3581
+#define MACH_TYPE_BCT                  3582
+#define MACH_TYPE_TUSCAN               3583
+#define MACH_TYPE_XBT_SAM9G45          3584
+#define MACH_TYPE_ENBW_CMC             3585
+#define MACH_TYPE_MSM8X60_DRAGON       3586
+#define MACH_TYPE_CH104MX257           3587
+#define MACH_TYPE_OPENPRI              3588
+#define MACH_TYPE_AM335XEVM            3589
+#define MACH_TYPE_PICODMB              3590
+#define MACH_TYPE_WALUIGI              3591
+#define MACH_TYPE_PUNICAG7             3592
+#define MACH_TYPE_IPAD_1G              3593
+#define MACH_TYPE_APPLETV_2G           3594
+#define MACH_TYPE_MACH_ECOG45          3595
+#define MACH_TYPE_AIT_CAM_ENC_4XX      3596
+#define MACH_TYPE_RUNNYMEDE            3597
+#define MACH_TYPE_PLAY                 3598
+#define MACH_TYPE_HW90260              3599
+#define MACH_TYPE_TAGH                 3600
+#define MACH_TYPE_FILBERT              3601
+#define MACH_TYPE_GETINGE_NETCOMV3     3602
+#define MACH_TYPE_CW20                 3603
+#define MACH_TYPE_CINEMA               3604
+#define MACH_TYPE_CINEMA_TEA           3605
+#define MACH_TYPE_CINEMA_COFFEE        3606
+#define MACH_TYPE_CINEMA_JUICE         3607
+#define MACH_TYPE_MX53_MIRAGE2         3609
+#define MACH_TYPE_MX53_EFIKASB         3610
+#define MACH_TYPE_STM_B2000            3612
+#define MACH_TYPE_M28EVK               3613
+#define MACH_TYPE_PDA                  3614
+#define MACH_TYPE_MERAKI_MR58          3615
+#define MACH_TYPE_KOTA2                3616
+#define MACH_TYPE_LETCOOL              3617
+#define MACH_TYPE_MX27IAT              3618
+#define MACH_TYPE_APOLLO_TD            3619
+#define MACH_TYPE_ARENA                3620
+#define MACH_TYPE_GSNGATEWAY           3621
+#define MACH_TYPE_LF2000               3622
+#define MACH_TYPE_BONITO               3623
+#define MACH_TYPE_ASYMPTOTE            3624
+#define MACH_TYPE_BST2BRD              3625
+#define MACH_TYPE_TX335S               3626
+#define MACH_TYPE_PELCO_TESLA          3627
+#define MACH_TYPE_RRHTESTPLAT          3628
+#define MACH_TYPE_VIDTONIC_PRO         3629
+#define MACH_TYPE_PL_APOLLO            3630
+#define MACH_TYPE_PL_PHOENIX           3631
+#define MACH_TYPE_M28CU3               3632
+#define MACH_TYPE_VVBOX_HD             3633
+#define MACH_TYPE_COREWARE_SAM9260_    3634
+#define MACH_TYPE_MARMADUKE            3635
+#define MACH_TYPE_AMG_XLCORE_CAMERA    3636
+#define MACH_TYPE_OMAP3_EGF            3637
+#define MACH_TYPE_SMDK4212             3638
+#define MACH_TYPE_DNP9200              3639
+#define MACH_TYPE_TF101                3640
+#define MACH_TYPE_OMAP3SILVIO          3641
+#define MACH_TYPE_PICASSO2             3642
+#define MACH_TYPE_VANGOGH2             3643
+#define MACH_TYPE_OLPC_XO_1_75         3644
+#define MACH_TYPE_GX400                3645
+#define MACH_TYPE_GS300                3646
+#define MACH_TYPE_ACER_A9              3647
+#define MACH_TYPE_VIVOW_EVM            3648
+#define MACH_TYPE_VELOCE_CXQ           3649
+#define MACH_TYPE_VELOCE_CXM           3650
+#define MACH_TYPE_P1852                3651
+#define MACH_TYPE_NAXY100              3652
+#define MACH_TYPE_TAISHAN              3653
+#define MACH_TYPE_TOUCHLINK            3654
+#define MACH_TYPE_STM32F103ZE          3655
+#define MACH_TYPE_MCX                  3656
+#define MACH_TYPE_STM_NMHDK_FLI7610    3657
+#define MACH_TYPE_TOP28X               3658
+#define MACH_TYPE_OKL4VP_MICROVISOR    3659
+#define MACH_TYPE_POP                  3660
+#define MACH_TYPE_LAYER                3661
+#define MACH_TYPE_TRONDHEIM            3662
+#define MACH_TYPE_EVA                  3663
+#define MACH_TYPE_TRUST_TAURUS         3664
+#define MACH_TYPE_NS2816_HUASHAN       3665
+#define MACH_TYPE_NS2816_YANGCHENG     3666
+#define MACH_TYPE_P852                 3667
+#define MACH_TYPE_FLEA3                3668
+#define MACH_TYPE_BOWFIN               3669
+#define MACH_TYPE_MV88DE3100           3670
+#define MACH_TYPE_PIA_AM35X            3671
+#define MACH_TYPE_CEDAR                3672
+#define MACH_TYPE_PICASSO_E            3673
+#define MACH_TYPE_SAMSUNG_E60          3674
+#define MACH_TYPE_MSM9615_CDP          3675
+#define MACH_TYPE_SDVR_MINI            3676
+#define MACH_TYPE_OMAP3_IJ3K           3677
+#define MACH_TYPE_MODASMC1             3678
+#define MACH_TYPE_APQ8064_RUMI3        3679
+#define MACH_TYPE_MATRIX506            3680
+#define MACH_TYPE_MSM9615_MTP          3681
+#define MACH_TYPE_DM36X_SPAWNDC        3682
+#define MACH_TYPE_SFF792               3683
+#define MACH_TYPE_AM335XIAEVM          3684
+#define MACH_TYPE_G3C2440              3685
+#define MACH_TYPE_TION270              3686
+#define MACH_TYPE_W22Q7ARM02           3687
+#define MACH_TYPE_OMAP_CAT             3688
+#define MACH_TYPE_AT91SAM9N12EK        3689
+#define MACH_TYPE_MORRISON             3690
+#define MACH_TYPE_SVDU                 3691
+#define MACH_TYPE_LPP01                3692
+#define MACH_TYPE_UBC283               3693
+#define MACH_TYPE_ZEPPELIN             3694
+#define MACH_TYPE_MOTUS                3695
+#define MACH_TYPE_NEOMAINBOARD         3696
+#define MACH_TYPE_DEVKIT3250           3697
+#define MACH_TYPE_DEVKIT7000           3698
+#define MACH_TYPE_FMC_UIC              3699
+#define MACH_TYPE_FMC_DCM              3700
+#define MACH_TYPE_BATWM                3701
+#define MACH_TYPE_ATLAS6CB             3702
+#define MACH_TYPE_BLUE                 3705
+#define MACH_TYPE_COLORADO             3706
+#define MACH_TYPE_POPC                 3707
+#define MACH_TYPE_PROMWAD_JADE         3708
+#define MACH_TYPE_AMP                  3709
+#define MACH_TYPE_GNET_AMP             3710
+#define MACH_TYPE_TOQUES               3711
+#define MACH_TYPE_DCT_STORM            3713
+#define MACH_TYPE_OWL                  3715
+#define MACH_TYPE_COGENT_CSB1741       3716
+#define MACH_TYPE_ADILLUSTRA610        3718
+#define MACH_TYPE_ECAFE_NA04           3719
+#define MACH_TYPE_POPCT                3720
+#define MACH_TYPE_OMAP3_HELENA         3721
+#define MACH_TYPE_ACH                  3722
+#define MACH_TYPE_MODULE_DTB           3723
+#define MACH_TYPE_OSLO_ELISABETH       3725
+#define MACH_TYPE_TT01                 3726
+#define MACH_TYPE_MSM8930_CDP          3727
+#define MACH_TYPE_MSM8930_MTP          3728
+#define MACH_TYPE_MSM8930_FLUID        3729
+#define MACH_TYPE_LTU11                3730
+#define MACH_TYPE_AM1808_SPAWNCO       3731
+#define MACH_TYPE_FLX6410              3732
+#define MACH_TYPE_MX6Q_QSB             3733
+#define MACH_TYPE_MX53_PLT424          3734
+#define MACH_TYPE_JASMINE              3735
+#define MACH_TYPE_L138_OWLBOARD_PLUS   3736
+#define MACH_TYPE_WR21                 3737
+#define MACH_TYPE_PEABOY               3739
+#define MACH_TYPE_MX28_PLATO           3740
+#define MACH_TYPE_KACOM2               3741
+#define MACH_TYPE_SLCO                 3742
+#define MACH_TYPE_IMX51PICO            3743
+#define MACH_TYPE_GLINK1               3744
+#define MACH_TYPE_DIAMOND              3745
+#define MACH_TYPE_D9000                3746
+#define MACH_TYPE_W5300E01             3747
+#define MACH_TYPE_IM6000               3748
+#define MACH_TYPE_MX51_FRED51          3749
+#define MACH_TYPE_STM32F2              3750
+#define MACH_TYPE_VILLE                3751
+#define MACH_TYPE_PTIP_MURNAU          3752
+#define MACH_TYPE_PTIP_CLASSIC         3753
+#define MACH_TYPE_MX53GRB              3754
+#define MACH_TYPE_GAGARIN              3755
+#define MACH_TYPE_MSM7627A_QRD1        3756
+#define MACH_TYPE_NAS2BIG              3757
+#define MACH_TYPE_SUPERFEMTO           3758
+#define MACH_TYPE_TEUFEL               3759
+#define MACH_TYPE_DINARA               3760
+#define MACH_TYPE_VANQUISH             3761
+#define MACH_TYPE_ZIPABOX1             3762
+#define MACH_TYPE_U9540                3763
+#define MACH_TYPE_JET                  3764
+#define MACH_TYPE_SMDK4412             3765
+#define MACH_TYPE_ELITE                3766
+#define MACH_TYPE_SPEAR320_HMI         3767
+#define MACH_TYPE_ONTARIO              3768
+#define MACH_TYPE_MX6Q_SABRELITE       3769
+#define MACH_TYPE_VC200                3770
+#define MACH_TYPE_MSM7625A_FFA         3771
+#define MACH_TYPE_MSM7625A_SURF        3772
+#define MACH_TYPE_BENTHOSSBP           3773
+#define MACH_TYPE_SMDK5210             3774
+#define MACH_TYPE_EMPQ2300             3775
+#define MACH_TYPE_MINIPOS              3776
+#define MACH_TYPE_OMAP5_SEVM           3777
+#define MACH_TYPE_SHELTER              3778
+#define MACH_TYPE_OMAP3_DEVKIT8500     3779
+#define MACH_TYPE_EDGETD               3780
+#define MACH_TYPE_COPPERYARD           3781
+#define MACH_TYPE_EDGE                 3782
+#define MACH_TYPE_EDGE_U               3783
+#define MACH_TYPE_EDGE_TD              3784
+#define MACH_TYPE_WDSS                 3785
+#define MACH_TYPE_DL_PB25              3786
+#define MACH_TYPE_DSS11                3787
+#define MACH_TYPE_CPA                  3788
+#define MACH_TYPE_APTP2000             3789
+#define MACH_TYPE_MARZEN               3790
+#define MACH_TYPE_ST_TURBINE           3791
+#define MACH_TYPE_GTL_IT3300           3792
+#define MACH_TYPE_MX6_MULE             3793
+#define MACH_TYPE_V7PXA_DT             3794
+#define MACH_TYPE_V7MMP_DT             3795
+#define MACH_TYPE_DRAGON7              3796
+#define MACH_TYPE_KROME                3797
+#define MACH_TYPE_ORATISDANTE          3798
+#define MACH_TYPE_FATHOM               3799
+#define MACH_TYPE_DNS325               3800
+#define MACH_TYPE_SARNEN               3801
+#define MACH_TYPE_UBISYS_G1            3802
+#define MACH_TYPE_MX53_PF1             3803
+#define MACH_TYPE_ASANTI               3804
+#define MACH_TYPE_VOLTA                3805
+#define MACH_TYPE_KNIGHT               3807
+#define MACH_TYPE_BEAGLEBONE           3808
+#define MACH_TYPE_BECKER               3809
+#define MACH_TYPE_FC360                3810
+#define MACH_TYPE_PMI2_XLS             3811
+#define MACH_TYPE_TARANTO              3812
+#define MACH_TYPE_PLUTUX               3813
+#define MACH_TYPE_IPMP_MEDCOM          3814
+#define MACH_TYPE_ABSOLUT              3815
+#define MACH_TYPE_AWPB3                3816
+#define MACH_TYPE_NFP32XX_DT           3817
+#define MACH_TYPE_DL_PB53              3818
+#define MACH_TYPE_ACU_II               3819
+#define MACH_TYPE_AVALON               3820
+#define MACH_TYPE_SPHINX               3821
+#define MACH_TYPE_TITAN_T              3822
+#define MACH_TYPE_HARVEST_BORIS        3823
+#define MACH_TYPE_MACH_MSM7X30_M3S     3824
+#define MACH_TYPE_SMDK5250             3825
+#define MACH_TYPE_IMXT_LITE            3826
+#define MACH_TYPE_IMXT_STD             3827
+#define MACH_TYPE_IMXT_LOG             3828
+#define MACH_TYPE_IMXT_NAV             3829
+#define MACH_TYPE_IMXT_FULL            3830
+#define MACH_TYPE_AG09015              3831
+#define MACH_TYPE_AM3517_MT_VENTOUX    3832
+#define MACH_TYPE_DP1ARM9              3833
+#define MACH_TYPE_PICASSO_M            3834
+#define MACH_TYPE_VIDEO_GADGET         3835
+#define MACH_TYPE_MTT_OM3X             3836
+#define MACH_TYPE_MX6Q_ARM2            3837
+#define MACH_TYPE_PICOSAM9G45          3838
+#define MACH_TYPE_VPM_DM365            3839
+#define MACH_TYPE_BONFIRE              3840
+#define MACH_TYPE_MT2P2D               3841
+#define MACH_TYPE_SIGPDA01             3842
+#define MACH_TYPE_CN27                 3843
+#define MACH_TYPE_MX25_CWTAP           3844
+#define MACH_TYPE_APF28                3845
+#define MACH_TYPE_PELCO_MAXWELL        3846
+#define MACH_TYPE_GE_PHOENIX           3847
+#define MACH_TYPE_EMPC_A500            3848
+#define MACH_TYPE_IMS_ARM9             3849
+#define MACH_TYPE_MINI2416             3850
+#define MACH_TYPE_MINI2450             3851
+#define MACH_TYPE_MINI310              3852
+#define MACH_TYPE_SPEAR_HURRICANE      3853
+#define MACH_TYPE_MT7208               3854
+#define MACH_TYPE_LPC178X              3855
+#define MACH_TYPE_FARLEYS              3856
+#define MACH_TYPE_EFM32GG_DK3750       3857
+#define MACH_TYPE_ZEUS_BOARD           3858
+#define MACH_TYPE_CC51                 3859
+#define MACH_TYPE_FXI_C210             3860
+#define MACH_TYPE_MSM8627_CDP          3861
+#define MACH_TYPE_MSM8627_MTP          3862
+#define MACH_TYPE_ARMADILLO800EVA      3863
+#define MACH_TYPE_PRIMOU               3864
+#define MACH_TYPE_PRIMOC               3865
+#define MACH_TYPE_PRIMOCT              3866
+#define MACH_TYPE_A9500                3867
+#define MACH_TYPE_PLUTO                3869
+#define MACH_TYPE_ACFX100              3870
+#define MACH_TYPE_MSM8625_RUMI3        3871
+#define MACH_TYPE_VALENTE              3872
+#define MACH_TYPE_CRFS_RFEYE           3873
+#define MACH_TYPE_RFEYE                3874
+#define MACH_TYPE_PHIDGET_SBC3         3875
+#define MACH_TYPE_TCW_MIKA             3876
+#define MACH_TYPE_IMX28_EGF            3877
+#define MACH_TYPE_VALENTE_WX           3878
+#define MACH_TYPE_HUANGSHANS           3879
+#define MACH_TYPE_BOSPHORUS1           3880
+#define MACH_TYPE_PRIMA                3881
+#define MACH_TYPE_EVITA_ULK            3884
+#define MACH_TYPE_MERISC600            3885
+#define MACH_TYPE_DOLAK                3886
+#define MACH_TYPE_SBC53                3887
+#define MACH_TYPE_ELITE_ULK            3888
+#define MACH_TYPE_POV2                 3889
+#define MACH_TYPE_IPOD_TOUCH_2G        3890
+#define MACH_TYPE_DA850_PQAB           3891
+#define MACH_TYPE_MSM7627A_EVB         3934
+#define MACH_TYPE_APQ8064_CDP          3948
+#define MACH_TYPE_APQ8064_MTP          3949
+#define MACH_TYPE_APQ8064_LIQUID       3951
+#define MACH_TYPE_MPQ8064_CDP          3993
+#define MACH_TYPE_MPQ8064_HRD          3994
+#define MACH_TYPE_MPQ8064_DTV          3995
+#define MACH_TYPE_MSM7627A_QRD3        4005
+#define MACH_TYPE_MSM8625_SURF         4037
+#define MACH_TYPE_MSM8625_EVB          4042
+#define MACH_TYPE_MSM8625_QRD7         4095
+#define MACH_TYPE_MSM8625_FFA          4166
+#define MACH_TYPE_MSM8625_EVT          4193
+#define MACH_TYPE_APQ8064_MAKO         7800
+#define MACH_TYPE_APQ8064_FLO          7801
+#define MACH_TYPE_APQ8064_DEB          7802
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMLD
+# endif
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
+#else
+# define machine_is_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTE2
+# endif
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
+#else
+# define machine_is_palmte2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTX
+# endif
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
+#else
+# define machine_is_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT5
+# endif
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
+#else
+# define machine_is_palmt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTC
+# endif
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
+#else
+# define machine_is_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
+# endif
+# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
+#else
+# define machine_is_omap_3430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO680
+# endif
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
+#else
+# define machine_is_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI320
+# endif
+# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
+#else
+# define machine_is_colibri320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAM60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAM60
+# endif
+# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
+#else
+# define machine_is_cam60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91EB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91EB01
+# endif
+# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
+#else
+# define machine_is_at91eb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F5281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F5281
+# endif
+# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
+#else
+# define machine_is_db88f5281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB726
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB726
+# endif
+# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
+#else
+# define machine_is_csb726()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
+# endif
+# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
+#else
+# define machine_is_davinci_dm6467_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
+# endif
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
+#else
+# define machine_is_davinci_dm355_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITTLETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITTLETON
+# endif
+# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
+#else
+# define machine_is_littleton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB11MP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
+# endif
+# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
+#else
+# define machine_is_realview_pb11mp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_3DS
+# endif
+# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
+#else
+# define machine_is_mx27_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALIBUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALIBUT
+# endif
+# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
+#else
+# define machine_is_halibut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROUT
+# endif
+# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
+#else
+# define machine_is_trout()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCT_HAMMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
+# endif
+# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
+#else
+# define machine_is_tct_hammer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERALD
+# endif
+# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
+#else
+# define machine_is_herald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIM_ONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIM_ONE
+# endif
+# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
+#else
+# define machine_is_sim_one()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIVE
+# endif
+# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
+#else
+# define machine_is_jive()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9260
+# endif
+# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
+#else
+# define machine_is_sam9_l9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
+# endif
+# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
+#else
+# define machine_is_realview_pb1176()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL9200
+# endif
+# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
+#else
+# define machine_is_yl9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5182
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5182
+# endif
+# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
+#else
+# define machine_is_rd88f5182()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KUROBOX_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
+# endif
+# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
+#else
+# define machine_is_kurobox_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_3DS
+# endif
+# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
+#else
+# define machine_is_mx31_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QONG
+# endif
+# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
+#else
+# define machine_is_qong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP2EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP2EVM
+# endif
+# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
+#else
+# define machine_is_omap2evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3EVM
+# endif
+# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
+#else
+# define machine_is_omap3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS323
+# endif
+# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
+#else
+# define machine_is_dns323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BEAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
+# endif
+# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
+#else
+# define machine_is_omap3_beagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810
+# endif
+# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
+#else
+# define machine_is_nokia_n810()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM038
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM038
+# endif
+# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
+#else
+# define machine_is_pcm038()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS209
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS209
+# endif
+# define machine_is_ts209()	(machine_arch_type == MACH_TYPE_TS209)
+#else
+# define machine_is_ts209()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9ADK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
+# endif
+# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
+#else
+# define machine_is_at91cap9adk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31MOBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
+# endif
+# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
+#else
+# define machine_is_mx31moboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VISION_EP9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VISION_EP9307
+# endif
+# define machine_is_vision_ep9307()	(machine_arch_type == MACH_TYPE_VISION_EP9307)
+#else
+# define machine_is_vision_ep9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_PRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
+# endif
+# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
+#else
+# define machine_is_terastation_pro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
+# endif
+# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
+#else
+# define machine_is_linkstation_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E350
+# endif
+# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
+#else
+# define machine_is_e350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS409
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS409
+# endif
+# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
+#else
+# define machine_is_ts409()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSI_EWS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSI_EWS
+# endif
+# define machine_is_rsi_ews()	(machine_arch_type == MACH_TYPE_RSI_EWS)
+#else
+# define machine_is_rsi_ews()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEUROS_OSD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
+# endif
+# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
+#else
+# define machine_is_neuros_osd2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
+# endif
+# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
+#else
+# define machine_is_davinci_da830_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB
+# endif
+# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
+#else
+# define machine_is_dove_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9G20
+# endif
+# define machine_is_usb_a9g20()	(machine_arch_type == MACH_TYPE_USB_A9G20)
+#else
+# define machine_is_usb_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX27
+# endif
+# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX27)
+#else
+# define machine_is_eukrea_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX37
+# endif
+# define machine_is_tx37()	(machine_arch_type == MACH_TYPE_TX37)
+#else
+# define machine_is_tx37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX25
+# endif
+# define machine_is_tx25()	(machine_arch_type == MACH_TYPE_TX25)
+#else
+# define machine_is_tx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEXPRESS
+# endif
+# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
+#else
+# define machine_is_vexpress()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6442
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6442
+# endif
+# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
+#else
+# define machine_is_smdk6442()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
+# endif
+# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
+#else
+# define machine_is_openrd_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT8000
+# endif
+# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
+#else
+# define machine_is_devkit8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
+# endif
+# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
+#else
+# define machine_is_mx51_efikamx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T35
+# endif
+# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
+#else
+# define machine_is_cm_t35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG
+# endif
+# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
+#else
+# define machine_is_net2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0020
+# endif
+# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
+#else
+# define machine_is_igep0020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC932EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC932EVB
+# endif
+# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
+#else
+# define machine_is_nuc932evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_CLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
+# endif
+# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
+#else
+# define machine_is_openrd_client()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U8500
+# endif
+# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
+#else
+# define machine_is_u8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
+# endif
+# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
+#else
+# define machine_is_mx51_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
+# endif
+# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
+#else
+# define machine_is_marvell_jasper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLINT
+# endif
+# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
+#else
+# define machine_is_flint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB3
+# endif
+# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
+#else
+# define machine_is_tavorevb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
+# endif
+# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
+#else
+# define machine_is_touchbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_RC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
+# endif
+# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
+#else
+# define machine_is_raumfeld_rc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
+# endif
+# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
+#else
+# define machine_is_raumfeld_connector()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
+# endif
+# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
+#else
+# define machine_is_raumfeld_speaker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNETV107X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNETV107X
+# endif
+# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
+#else
+# define machine_is_tnetv107x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_M2ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_M2ID
+# endif
+# define machine_is_mx51_m2id()	(machine_arch_type == MACH_TYPE_MX51_M2ID)
+#else
+# define machine_is_mx51_m2id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX51
+# endif
+# define machine_is_tx51()	(machine_arch_type == MACH_TYPE_TX51)
+#else
+# define machine_is_tx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_BEI2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_BEI2
+# endif
+# define machine_is_riot_bei2()	(machine_arch_type == MACH_TYPE_RIOT_BEI2)
+#else
+# define machine_is_riot_bei2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_X37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_X37
+# endif
+# define machine_is_riot_x37()	(machine_arch_type == MACH_TYPE_RIOT_X37)
+#else
+# define machine_is_riot_x37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA101
+# endif
+# define machine_is_pca101()	(machine_arch_type == MACH_TYPE_PCA101)
+#else
+# define machine_is_pca101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAPC7117
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAPC7117
+# endif
+# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
+#else
+# define machine_is_capc7117()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTROL
+# endif
+# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
+#else
+# define machine_is_icontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPLUGD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPLUGD
+# endif
+# define machine_is_gplugd()	(machine_arch_type == MACH_TYPE_GPLUGD)
+#else
+# define machine_is_gplugd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
+# endif
+# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
+#else
+# define machine_is_qsd8x50a_st1_5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX23EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX23EVK
+# endif
+# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
+#else
+# define machine_is_mx23evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP4EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP4EVB
+# endif
+# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
+#else
+# define machine_is_ap4evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MITYOMAPL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
+# endif
+# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
+#else
+# define machine_is_mityomapl138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURUPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURUPLUG
+# endif
+# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
+#else
+# define machine_is_guruplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR310
+# endif
+# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
+#else
+# define machine_is_spear310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320
+# endif
+# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
+#else
+# define machine_is_spear320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUILA
+# endif
+# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
+#else
+# define machine_is_aquila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
+# endif
+# define machine_is_esata_sheevaplug()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
+#else
+# define machine_is_esata_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
+# endif
+# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
+#else
+# define machine_is_msm7x30_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA2478DEVKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA2478DEVKIT
+# endif
+# define machine_is_ea2478devkit()	(machine_arch_type == MACH_TYPE_EA2478DEVKIT)
+#else
+# define machine_is_ea2478devkit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_WXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
+# endif
+# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
+#else
+# define machine_is_terastation_wxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
+# endif
+# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
+#else
+# define machine_is_msm7x25_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
+# endif
+# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
+#else
+# define machine_is_msm7x25_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
+# endif
+# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
+#else
+# define machine_is_msm7x27_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
+# endif
+# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
+#else
+# define machine_is_msm7x27_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
+# endif
+# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
+#else
+# define machine_is_msm7x30_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
+# endif
+# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
+#else
+# define machine_is_qsd8x50_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_FFA
+# endif
+# define machine_is_qsd8x50_ffa()	(machine_arch_type == MACH_TYPE_QSD8X50_FFA)
+#else
+# define machine_is_qsd8x50_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EVK
+# endif
+# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
+#else
+# define machine_is_mx53_evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0030
+# endif
+# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
+#else
+# define machine_is_igep0030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC3530
+# endif
+# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
+#else
+# define machine_is_sbc3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB
+# endif
+# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
+#else
+# define machine_is_saarb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARMONY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARMONY
+# endif
+# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
+#else
+# define machine_is_harmony()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
+# endif
+# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
+#else
+# define machine_is_msm7x30_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3517
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3517
+# endif
+# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
+#else
+# define machine_is_cm_t3517()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD222
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD222
+# endif
+# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
+#else
+# define machine_is_wbd222()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
+# endif
+# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
+#else
+# define machine_is_msm8x60_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
+# endif
+# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
+#else
+# define machine_is_msm8x60_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC8000_SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
+# endif
+# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
+#else
+# define machine_is_tcc8000_sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOS
+# endif
+# define machine_is_nanos()	(machine_arch_type == MACH_TYPE_NANOS)
+#else
+# define machine_is_nanos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G45
+# endif
+# define machine_is_stamp9g45()	(machine_arch_type == MACH_TYPE_STAMP9G45)
+#else
+# define machine_is_stamp9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SURF
+# endif
+# define machine_is_msm8x55_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SURF)
+#else
+# define machine_is_msm8x55_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_FFA
+# endif
+# define machine_is_msm8x55_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_FFA)
+#else
+# define machine_is_msm8x55_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS3420VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS3420VB
+# endif
+# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
+#else
+# define machine_is_cns3420vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP4_PANDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
+# endif
+# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
+#else
+# define machine_is_omap4_panda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8168EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8168EVM
+# endif
+# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
+#else
+# define machine_is_ti8168evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON_BGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON_BGA
+# endif
+# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
+#else
+# define machine_is_teton_bga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX25SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25SD
+# endif
+# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25SD)
+#else
+# define machine_is_eukrea_cpuimx25sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX35SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35SD
+# endif
+# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35SD)
+#else
+# define machine_is_eukrea_cpuimx35sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
+# endif
+# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
+#else
+# define machine_is_eukrea_cpuimx51sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
+# endif
+# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
+#else
+# define machine_is_eukrea_cpuimx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC210
+# endif
+# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
+#else
+# define machine_is_smdkc210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA102
+# endif
+# define machine_is_pca102()	(machine_arch_type == MACH_TYPE_PCA102)
+#else
+# define machine_is_pca102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5325
+# endif
+# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
+#else
+# define machine_is_t5325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCOME
+# endif
+# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
+#else
+# define machine_is_income()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDORIG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDORIG2
+# endif
+# define machine_is_vvbox_sdorig2()	(machine_arch_type == MACH_TYPE_VVBOX_SDORIG2)
+#else
+# define machine_is_vvbox_sdorig2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDLITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDLITE2
+# endif
+# define machine_is_vvbox_sdlite2()	(machine_arch_type == MACH_TYPE_VVBOX_SDLITE2)
+#else
+# define machine_is_vvbox_sdlite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDPRO4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDPRO4
+# endif
+# define machine_is_vvbox_sdpro4()	(machine_arch_type == MACH_TYPE_VVBOX_SDPRO4)
+#else
+# define machine_is_vvbox_sdpro4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SX
+# endif
+# define machine_is_mx257sx()	(machine_arch_type == MACH_TYPE_MX257SX)
+#else
+# define machine_is_mx257sx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GONI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONI
+# endif
+# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
+#else
+# define machine_is_goni()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_FFA
+# endif
+# define machine_is_msm8x55_svlte_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_FFA)
+#else
+# define machine_is_msm8x55_svlte_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_SURF
+# endif
+# define machine_is_msm8x55_svlte_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_SURF)
+#else
+# define machine_is_msm8x55_svlte_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BV07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BV07
+# endif
+# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
+#else
+# define machine_is_bv07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_ULTIMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
+# endif
+# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
+#else
+# define machine_is_openrd_ultimate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVIXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVIXP
+# endif
+# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
+#else
+# define machine_is_devixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICCPT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICCPT
+# endif
+# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
+#else
+# define machine_is_miccpt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIC256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIC256
+# endif
+# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
+#else
+# define machine_is_mic256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U5500
+# endif
+# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
+#else
+# define machine_is_u5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LSCHL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
+# endif
+# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
+#else
+# define machine_is_linkstation_lschl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV310
+# endif
+# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
+#else
+# define machine_is_smdkv310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
+# endif
+# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
+#else
+# define machine_is_wm8505_7in_netbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRANEBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRANEBOARD
+# endif
+# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
+#else
+# define machine_is_craneboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6450
+# endif
+# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
+#else
+# define machine_is_smdk6450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BROWNSTONE
+# endif
+# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
+#else
+# define machine_is_brownstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEXIBITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXIBITY
+# endif
+# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
+#else
+# define machine_is_flexibity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_RDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_RDP
+# endif
+# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
+#else
+# define machine_is_mx50_rdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSAL_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
+# endif
+# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
+#else
+# define machine_is_universal_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REAL6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REAL6410
+# endif
+# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
+#else
+# define machine_is_real6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOCKSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOCKSTAR
+# endif
+# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
+#else
+# define machine_is_dockstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8148EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8148EVM
+# endif
+# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
+#else
+# define machine_is_ti8148evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABOARD
+# endif
+# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
+#else
+# define machine_is_seaboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_ARD
+# endif
+# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
+#else
+# define machine_is_mx53_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_SMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_SMD
+# endif
+# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
+#else
+# define machine_is_mx53_smd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
+# endif
+# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
+#else
+# define machine_is_msm8x60_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
+# endif
+# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
+#else
+# define machine_is_msm8x60_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_A510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_A510
+# endif
+# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
+#else
+# define machine_is_cm_a510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_SURF
+# endif
+# define machine_is_fsm9xxx_surf()	(machine_arch_type == MACH_TYPE_FSM9XXX_SURF)
+#else
+# define machine_is_fsm9xxx_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_FFA
+# endif
+# define machine_is_fsm9xxx_ffa()	(machine_arch_type == MACH_TYPE_FSM9XXX_FFA)
+#else
+# define machine_is_fsm9xxx_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX28
+# endif
+# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
+#else
+# define machine_is_tx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCONTROL_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
+# endif
+# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
+#else
+# define machine_is_pcontrol_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPR200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPR200
+# endif
+# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
+#else
+# define machine_is_vpr200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORBRECK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORBRECK
+# endif
+# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
+#else
+# define machine_is_torbreck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA2_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
+# endif
+# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
+#else
+# define machine_is_prima2_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FLUID
+# endif
+# define machine_is_msm8x60_fluid()	(machine_arch_type == MACH_TYPE_MSM8X60_FLUID)
+#else
+# define machine_is_msm8x60_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PAZ00
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PAZ00
+# endif
+# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
+#else
+# define machine_is_paz00()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMENETUSFOXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
+# endif
+# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
+#else
+# define machine_is_acmenetusfoxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FUSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FUSION
+# endif
+# define machine_is_msm8x60_fusion()	(machine_arch_type == MACH_TYPE_MSM8X60_FUSION)
+#else
+# define machine_is_msm8x60_fusion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG5EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG5EVM
+# endif
+# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
+#else
+# define machine_is_ag5evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSUNAGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSUNAGI
+# endif
+# define machine_is_tsunagi()	(machine_arch_type == MACH_TYPE_TSUNAGI)
+#else
+# define machine_is_tsunagi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FUSN_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FUSN_FFA
+# endif
+# define machine_is_msm8x60_fusn_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FUSN_FFA)
+#else
+# define machine_is_msm8x60_fusn_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICS_IF_VOIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
+# endif
+# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
+#else
+# define machine_is_ics_if_voip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLF_CRAGG_6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
+# endif
+# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
+#else
+# define machine_is_wlf_cragg_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIMSLICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIMSLICE
+# endif
+# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
+#else
+# define machine_is_trimslice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACKEREL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACKEREL
+# endif
+# define machine_is_mackerel()	(machine_arch_type == MACH_TYPE_MACKEREL)
+#else
+# define machine_is_mackerel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAEN
+# endif
+# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
+#else
+# define machine_is_kaen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
+# endif
+# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
+#else
+# define machine_is_nokia_rm680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6446_ADBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6446_ADBOX
+# endif
+# define machine_is_dm6446_adbox()	(machine_arch_type == MACH_TYPE_DM6446_ADBOX)
+#else
+# define machine_is_dm6446_adbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUAD_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUAD_SALSA
+# endif
+# define machine_is_quad_salsa()	(machine_arch_type == MACH_TYPE_QUAD_SALSA)
+#else
+# define machine_is_quad_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABB_GMA_1_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABB_GMA_1_1
+# endif
+# define machine_is_abb_gma_1_1()	(machine_arch_type == MACH_TYPE_ABB_GMA_1_1)
+#else
+# define machine_is_abb_gma_1_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVCID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVCID
+# endif
+# define machine_is_svcid()	(machine_arch_type == MACH_TYPE_SVCID)
+#else
+# define machine_is_svcid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
+# endif
+# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
+#else
+# define machine_is_msm8960_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
+# endif
+# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
+#else
+# define machine_is_msm8960_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON_G
+# endif
+# define machine_is_icon_g()	(machine_arch_type == MACH_TYPE_ICON_G)
+#else
+# define machine_is_icon_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB3
+# endif
+# define machine_is_mb3()	(machine_arch_type == MACH_TYPE_MB3)
+#else
+# define machine_is_mb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSIA18S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSIA18S
+# endif
+# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
+#else
+# define machine_is_gsia18s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIVICC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIVICC
+# endif
+# define machine_is_pivicc()	(machine_arch_type == MACH_TYPE_PIVICC)
+#else
+# define machine_is_pivicc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM048
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM048
+# endif
+# define machine_is_pcm048()	(machine_arch_type == MACH_TYPE_PCM048)
+#else
+# define machine_is_pcm048()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDS
+# endif
+# define machine_is_dds()	(machine_arch_type == MACH_TYPE_DDS)
+#else
+# define machine_is_dds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHALTEN_XA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHALTEN_XA1
+# endif
+# define machine_is_chalten_xa1()	(machine_arch_type == MACH_TYPE_CHALTEN_XA1)
+#else
+# define machine_is_chalten_xa1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS48XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS48XX
+# endif
+# define machine_is_ts48xx()	(machine_arch_type == MACH_TYPE_TS48XX)
+#else
+# define machine_is_ts48xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TONGA2_TFTTIMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TONGA2_TFTTIMER
+# endif
+# define machine_is_tonga2_tfttimer()	(machine_arch_type == MACH_TYPE_TONGA2_TFTTIMER)
+#else
+# define machine_is_tonga2_tfttimer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHISTLER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHISTLER
+# endif
+# define machine_is_whistler()	(machine_arch_type == MACH_TYPE_WHISTLER)
+#else
+# define machine_is_whistler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASL_PHOENIX
+# endif
+# define machine_is_asl_phoenix()	(machine_arch_type == MACH_TYPE_ASL_PHOENIX)
+#else
+# define machine_is_asl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263OTLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263OTLITE
+# endif
+# define machine_is_at91sam9263otlite()	(machine_arch_type == MACH_TYPE_AT91SAM9263OTLITE)
+#else
+# define machine_is_at91sam9263otlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDPLUG
+# endif
+# define machine_is_ddplug()	(machine_arch_type == MACH_TYPE_DDPLUG)
+#else
+# define machine_is_ddplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2PLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2PLUG
+# endif
+# define machine_is_d2plug()	(machine_arch_type == MACH_TYPE_D2PLUG)
+#else
+# define machine_is_d2plug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM9D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM9D
+# endif
+# define machine_is_kzm9d()	(machine_arch_type == MACH_TYPE_KZM9D)
+#else
+# define machine_is_kzm9d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI_LTE
+# endif
+# define machine_is_verdi_lte()	(machine_arch_type == MACH_TYPE_VERDI_LTE)
+#else
+# define machine_is_verdi_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOZOOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOZOOM
+# endif
+# define machine_is_nanozoom()	(machine_arch_type == MACH_TYPE_NANOZOOM)
+#else
+# define machine_is_nanozoom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_SOM_LV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_SOM_LV
+# endif
+# define machine_is_dm3730_som_lv()	(machine_arch_type == MACH_TYPE_DM3730_SOM_LV)
+#else
+# define machine_is_dm3730_som_lv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_TORPEDO
+# endif
+# define machine_is_dm3730_torpedo()	(machine_arch_type == MACH_TYPE_DM3730_TORPEDO)
+#else
+# define machine_is_dm3730_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANCHOVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANCHOVY
+# endif
+# define machine_is_anchovy()	(machine_arch_type == MACH_TYPE_ANCHOVY)
+#else
+# define machine_is_anchovy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV20
+# endif
+# define machine_is_re2rev20()	(machine_arch_type == MACH_TYPE_RE2REV20)
+#else
+# define machine_is_re2rev20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV21
+# endif
+# define machine_is_re2rev21()	(machine_arch_type == MACH_TYPE_RE2REV21)
+#else
+# define machine_is_re2rev21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS21XX
+# endif
+# define machine_is_cns21xx()	(machine_arch_type == MACH_TYPE_CNS21XX)
+#else
+# define machine_is_cns21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIDER
+# endif
+# define machine_is_rider()	(machine_arch_type == MACH_TYPE_RIDER)
+#else
+# define machine_is_rider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSK330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSK330
+# endif
+# define machine_is_nsk330()	(machine_arch_type == MACH_TYPE_NSK330)
+#else
+# define machine_is_nsk330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS2133EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS2133EVB
+# endif
+# define machine_is_cns2133evb()	(machine_arch_type == MACH_TYPE_CNS2133EVB)
+#else
+# define machine_is_cns2133evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_816X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_816X_MOD
+# endif
+# define machine_is_z3_816x_mod()	(machine_arch_type == MACH_TYPE_Z3_816X_MOD)
+#else
+# define machine_is_z3_816x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_814X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_814X_MOD
+# endif
+# define machine_is_z3_814x_mod()	(machine_arch_type == MACH_TYPE_Z3_814X_MOD)
+#else
+# define machine_is_z3_814x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEECT
+# endif
+# define machine_is_beect()	(machine_arch_type == MACH_TYPE_BEECT)
+#else
+# define machine_is_beect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA_THUNDERBUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA_THUNDERBUG
+# endif
+# define machine_is_dma_thunderbug()	(machine_arch_type == MACH_TYPE_DMA_THUNDERBUG)
+#else
+# define machine_is_dma_thunderbug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMN_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMN_AT91SAM9G20
+# endif
+# define machine_is_omn_at91sam9g20()	(machine_arch_type == MACH_TYPE_OMN_AT91SAM9G20)
+#else
+# define machine_is_omn_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_E2S_UC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_E2S_UC
+# endif
+# define machine_is_mx25_e2s_uc()	(machine_arch_type == MACH_TYPE_MX25_E2S_UC)
+#else
+# define machine_is_mx25_e2s_uc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIONE
+# endif
+# define machine_is_mione()	(machine_arch_type == MACH_TYPE_MIONE)
+#else
+# define machine_is_mione()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_TCU
+# endif
+# define machine_is_top9000_tcu()	(machine_arch_type == MACH_TYPE_TOP9000_TCU)
+#else
+# define machine_is_top9000_tcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_BSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_BSL
+# endif
+# define machine_is_top9000_bsl()	(machine_arch_type == MACH_TYPE_TOP9000_BSL)
+#else
+# define machine_is_top9000_bsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KINGDOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGDOM
+# endif
+# define machine_is_kingdom()	(machine_arch_type == MACH_TYPE_KINGDOM)
+#else
+# define machine_is_kingdom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO460
+# endif
+# define machine_is_armadillo460()	(machine_arch_type == MACH_TYPE_ARMADILLO460)
+#else
+# define machine_is_armadillo460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LQ2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LQ2
+# endif
+# define machine_is_lq2()	(machine_arch_type == MACH_TYPE_LQ2)
+#else
+# define machine_is_lq2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDA_TMS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDA_TMS2
+# endif
+# define machine_is_sweda_tms2()	(machine_arch_type == MACH_TYPE_SWEDA_TMS2)
+#else
+# define machine_is_sweda_tms2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_LOCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_LOCO
+# endif
+# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
+#else
+# define machine_is_mx53_loco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A8
+# endif
+# define machine_is_acer_a8()	(machine_arch_type == MACH_TYPE_ACER_A8)
+#else
+# define machine_is_acer_a8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_GAUGUIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_GAUGUIN
+# endif
+# define machine_is_acer_gauguin()	(machine_arch_type == MACH_TYPE_ACER_GAUGUIN)
+#else
+# define machine_is_acer_gauguin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUPPY
+# endif
+# define machine_is_guppy()	(machine_arch_type == MACH_TYPE_GUPPY)
+#else
+# define machine_is_guppy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX61_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX61_ARD
+# endif
+# define machine_is_mx61_ard()	(machine_arch_type == MACH_TYPE_MX61_ARD)
+#else
+# define machine_is_mx61_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX53
+# endif
+# define machine_is_tx53()	(machine_arch_type == MACH_TYPE_TX53)
+#else
+# define machine_is_tx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_CASE_A3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_CASE_A3
+# endif
+# define machine_is_omapl138_case_a3()	(machine_arch_type == MACH_TYPE_OMAPL138_CASE_A3)
+#else
+# define machine_is_omapl138_case_a3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEMD
+# endif
+# define machine_is_uemd()	(machine_arch_type == MACH_TYPE_UEMD)
+#else
+# define machine_is_uemd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51MUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51MUT
+# endif
+# define machine_is_ccwmx51mut()	(machine_arch_type == MACH_TYPE_CCWMX51MUT)
+#else
+# define machine_is_ccwmx51mut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROCKHOPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROCKHOPPER
+# endif
+# define machine_is_rockhopper()	(machine_arch_type == MACH_TYPE_ROCKHOPPER)
+#else
+# define machine_is_rockhopper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENCORE
+# endif
+# define machine_is_encore()	(machine_arch_type == MACH_TYPE_ENCORE)
+#else
+# define machine_is_encore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HKDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HKDKC100
+# endif
+# define machine_is_hkdkc100()	(machine_arch_type == MACH_TYPE_HKDKC100)
+#else
+# define machine_is_hkdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS42XX
+# endif
+# define machine_is_ts42xx()	(machine_arch_type == MACH_TYPE_TS42XX)
+#else
+# define machine_is_ts42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AEBL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AEBL
+# endif
+# define machine_is_aebl()	(machine_arch_type == MACH_TYPE_AEBL)
+#else
+# define machine_is_aebl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WARIO
+# endif
+# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
+#else
+# define machine_is_wario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GFS_SPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GFS_SPM
+# endif
+# define machine_is_gfs_spm()	(machine_arch_type == MACH_TYPE_GFS_SPM)
+#else
+# define machine_is_gfs_spm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3730
+# endif
+# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
+#else
+# define machine_is_cm_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISC3
+# endif
+# define machine_is_isc3()	(machine_arch_type == MACH_TYPE_ISC3)
+#else
+# define machine_is_isc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RASCAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RASCAL
+# endif
+# define machine_is_rascal()	(machine_arch_type == MACH_TYPE_RASCAL)
+#else
+# define machine_is_rascal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HREFV60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HREFV60
+# endif
+# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
+#else
+# define machine_is_hrefv60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPT_2_0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPT_2_0
+# endif
+# define machine_is_tpt_2_0()	(machine_arch_type == MACH_TYPE_TPT_2_0)
+#else
+# define machine_is_tpt_2_0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPLENDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPLENDOR
+# endif
+# define machine_is_splendor()	(machine_arch_type == MACH_TYPE_SPLENDOR)
+#else
+# define machine_is_splendor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QT
+# endif
+# define machine_is_msm8x60_qt()	(machine_arch_type == MACH_TYPE_MSM8X60_QT)
+#else
+# define machine_is_msm8x60_qt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_HD_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_HD_MINI
+# endif
+# define machine_is_htc_hd_mini()	(machine_arch_type == MACH_TYPE_HTC_HD_MINI)
+#else
+# define machine_is_htc_hd_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATHENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATHENE
+# endif
+# define machine_is_athene()	(machine_arch_type == MACH_TYPE_ATHENE)
+#else
+# define machine_is_athene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEEP_R_EK_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEEP_R_EK_1
+# endif
+# define machine_is_deep_r_ek_1()	(machine_arch_type == MACH_TYPE_DEEP_R_EK_1)
+#else
+# define machine_is_deep_r_ek_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_CT
+# endif
+# define machine_is_vivow_ct()	(machine_arch_type == MACH_TYPE_VIVOW_CT)
+#else
+# define machine_is_vivow_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NERY_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NERY_1000
+# endif
+# define machine_is_nery_1000()	(machine_arch_type == MACH_TYPE_NERY_1000)
+#else
+# define machine_is_nery_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL109145_SSRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL109145_SSRV
+# endif
+# define machine_is_rfl109145_ssrv()	(machine_arch_type == MACH_TYPE_RFL109145_SSRV)
+#else
+# define machine_is_rfl109145_ssrv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NMH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMH
+# endif
+# define machine_is_nmh()	(machine_arch_type == MACH_TYPE_NMH)
+#else
+# define machine_is_nmh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WN802T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WN802T
+# endif
+# define machine_is_wn802t()	(machine_arch_type == MACH_TYPE_WN802T)
+#else
+# define machine_is_wn802t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGONET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGONET
+# endif
+# define machine_is_dragonet()	(machine_arch_type == MACH_TYPE_DRAGONET)
+#else
+# define machine_is_dragonet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263DESK16L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESK16L
+# endif
+# define machine_is_at91sam9263desk16l()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESK16L)
+#else
+# define machine_is_at91sam9263desk16l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_SV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_SV
+# endif
+# define machine_is_bcmhana_sv()	(machine_arch_type == MACH_TYPE_BCMHANA_SV)
+#else
+# define machine_is_bcmhana_sv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_TABLET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_TABLET
+# endif
+# define machine_is_bcmhana_tablet()	(machine_arch_type == MACH_TYPE_BCMHANA_TABLET)
+#else
+# define machine_is_bcmhana_tablet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOI
+# endif
+# define machine_is_koi()	(machine_arch_type == MACH_TYPE_KOI)
+#else
+# define machine_is_koi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS4800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS4800
+# endif
+# define machine_is_ts4800()	(machine_arch_type == MACH_TYPE_TS4800)
+#else
+# define machine_is_ts4800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA9263
+# endif
+# define machine_is_tqma9263()	(machine_arch_type == MACH_TYPE_TQMA9263)
+#else
+# define machine_is_tqma9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOLIDAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOLIDAY
+# endif
+# define machine_is_holiday()	(machine_arch_type == MACH_TYPE_HOLIDAY)
+#else
+# define machine_is_holiday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCATS_OVERLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCATS_OVERLAY
+# endif
+# define machine_is_pcats_overlay()	(machine_arch_type == MACH_TYPE_PCATS_OVERLAY)
+#else
+# define machine_is_pcats_overlay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HWGW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HWGW6410
+# endif
+# define machine_is_hwgw6410()	(machine_arch_type == MACH_TYPE_HWGW6410)
+#else
+# define machine_is_hwgw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHENZHOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHENZHOU
+# endif
+# define machine_is_shenzhou()	(machine_arch_type == MACH_TYPE_SHENZHOU)
+#else
+# define machine_is_shenzhou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210
+# endif
+# define machine_is_cwme9210()	(machine_arch_type == MACH_TYPE_CWME9210)
+#else
+# define machine_is_cwme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210JS
+# endif
+# define machine_is_cwme9210js()	(machine_arch_type == MACH_TYPE_CWME9210JS)
+#else
+# define machine_is_cwme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI_TEGRA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI_TEGRA2
+# endif
+# define machine_is_colibri_tegra2()	(machine_arch_type == MACH_TYPE_COLIBRI_TEGRA2)
+#else
+# define machine_is_colibri_tegra2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W21
+# endif
+# define machine_is_w21()	(machine_arch_type == MACH_TYPE_W21)
+#else
+# define machine_is_w21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLYSAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLYSAT1
+# endif
+# define machine_is_polysat1()	(machine_arch_type == MACH_TYPE_POLYSAT1)
+#else
+# define machine_is_polysat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATAWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATAWAY
+# endif
+# define machine_is_dataway()	(machine_arch_type == MACH_TYPE_DATAWAY)
+#else
+# define machine_is_dataway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBRAL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBRAL138
+# endif
+# define machine_is_cobral138()	(machine_arch_type == MACH_TYPE_COBRAL138)
+#else
+# define machine_is_cobral138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERPCS8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERPCS8
+# endif
+# define machine_is_roverpcs8()	(machine_arch_type == MACH_TYPE_ROVERPCS8)
+#else
+# define machine_is_roverpcs8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELC
+# endif
+# define machine_is_marvelc()	(machine_arch_type == MACH_TYPE_MARVELC)
+#else
+# define machine_is_marvelc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVEFIHID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVEFIHID
+# endif
+# define machine_is_navefihid()	(machine_arch_type == MACH_TYPE_NAVEFIHID)
+#else
+# define machine_is_navefihid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM365_CV100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM365_CV100
+# endif
+# define machine_is_dm365_cv100()	(machine_arch_type == MACH_TYPE_DM365_CV100)
+#else
+# define machine_is_dm365_cv100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABLE
+# endif
+# define machine_is_able()	(machine_arch_type == MACH_TYPE_ABLE)
+#else
+# define machine_is_able()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGACY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGACY
+# endif
+# define machine_is_legacy()	(machine_arch_type == MACH_TYPE_LEGACY)
+#else
+# define machine_is_legacy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONG
+# endif
+# define machine_is_icong()	(machine_arch_type == MACH_TYPE_ICONG)
+#else
+# define machine_is_icong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_G8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_G8
+# endif
+# define machine_is_rover_g8()	(machine_arch_type == MACH_TYPE_ROVER_G8)
+#else
+# define machine_is_rover_g8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5388P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5388P
+# endif
+# define machine_is_t5388p()	(machine_arch_type == MACH_TYPE_T5388P)
+#else
+# define machine_is_t5388p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINGO
+# endif
+# define machine_is_dingo()	(machine_arch_type == MACH_TYPE_DINGO)
+#else
+# define machine_is_dingo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXHOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXHOME
+# endif
+# define machine_is_goflexhome()	(machine_arch_type == MACH_TYPE_GOFLEXHOME)
+#else
+# define machine_is_goflexhome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN511
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN511
+# endif
+# define machine_is_lanreadyfn511()	(machine_arch_type == MACH_TYPE_LANREADYFN511)
+#else
+# define machine_is_lanreadyfn511()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BAIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BAIA
+# endif
+# define machine_is_omap3_baia()	(machine_arch_type == MACH_TYPE_OMAP3_BAIA)
+#else
+# define machine_is_omap3_baia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SMARTDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SMARTDISPLAY
+# endif
+# define machine_is_omap3smartdisplay()	(machine_arch_type == MACH_TYPE_OMAP3SMARTDISPLAY)
+#else
+# define machine_is_omap3smartdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX
+# endif
+# define machine_is_xilinx()	(machine_arch_type == MACH_TYPE_XILINX)
+#else
+# define machine_is_xilinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A2F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A2F
+# endif
+# define machine_is_a2f()	(machine_arch_type == MACH_TYPE_A2F)
+#else
+# define machine_is_a2f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY25
+# endif
+# define machine_is_sky25()	(machine_arch_type == MACH_TYPE_SKY25)
+#else
+# define machine_is_sky25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53
+# endif
+# define machine_is_ccmx53()	(machine_arch_type == MACH_TYPE_CCMX53)
+#else
+# define machine_is_ccmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53JS
+# endif
+# define machine_is_ccmx53js()	(machine_arch_type == MACH_TYPE_CCMX53JS)
+#else
+# define machine_is_ccmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53
+# endif
+# define machine_is_ccwmx53()	(machine_arch_type == MACH_TYPE_CCWMX53)
+#else
+# define machine_is_ccwmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53JS
+# endif
+# define machine_is_ccwmx53js()	(machine_arch_type == MACH_TYPE_CCWMX53JS)
+#else
+# define machine_is_ccwmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRISMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRISMS
+# endif
+# define machine_is_frisms()	(machine_arch_type == MACH_TYPE_FRISMS)
+#else
+# define machine_is_frisms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_FFA
+# endif
+# define machine_is_msm7x27a_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27A_FFA)
+#else
+# define machine_is_msm7x27a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_SURF
+# endif
+# define machine_is_msm7x27a_surf()	(machine_arch_type == MACH_TYPE_MSM7X27A_SURF)
+#else
+# define machine_is_msm7x27a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_RUMI3
+# endif
+# define machine_is_msm7x27a_rumi3()	(machine_arch_type == MACH_TYPE_MSM7X27A_RUMI3)
+#else
+# define machine_is_msm7x27a_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMSAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMSAM9G20
+# endif
+# define machine_is_dimmsam9g20()	(machine_arch_type == MACH_TYPE_DIMMSAM9G20)
+#else
+# define machine_is_dimmsam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_IMX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_IMX28
+# endif
+# define machine_is_dimm_imx28()	(machine_arch_type == MACH_TYPE_DIMM_IMX28)
+#else
+# define machine_is_dimm_imx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMK_A4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMK_A4
+# endif
+# define machine_is_amk_a4()	(machine_arch_type == MACH_TYPE_AMK_A4)
+#else
+# define machine_is_amk_a4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGME
+# endif
+# define machine_is_gnet_sgme()	(machine_arch_type == MACH_TYPE_GNET_SGME)
+#else
+# define machine_is_gnet_sgme()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_U
+# endif
+# define machine_is_shooter_u()	(machine_arch_type == MACH_TYPE_SHOOTER_U)
+#else
+# define machine_is_shooter_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX53
+# endif
+# define machine_is_vmx53()	(machine_arch_type == MACH_TYPE_VMX53)
+#else
+# define machine_is_vmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHINO
+# endif
+# define machine_is_rhino()	(machine_arch_type == MACH_TYPE_RHINO)
+#else
+# define machine_is_rhino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLEX4210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLEX4210
+# endif
+# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
+#else
+# define machine_is_armlex4210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOEXTMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOEXTMODEM
+# endif
+# define machine_is_swarcoextmodem()	(machine_arch_type == MACH_TYPE_SWARCOEXTMODEM)
+#else
+# define machine_is_swarcoextmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNOWBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNOWBALL
+# endif
+# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
+#else
+# define machine_is_snowball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM049
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM049
+# endif
+# define machine_is_pcm049()	(machine_arch_type == MACH_TYPE_PCM049)
+#else
+# define machine_is_pcm049()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIGOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIGOR
+# endif
+# define machine_is_vigor()	(machine_arch_type == MACH_TYPE_VIGOR)
+#else
+# define machine_is_vigor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_AMUNDSEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_AMUNDSEN
+# endif
+# define machine_is_oslo_amundsen()	(machine_arch_type == MACH_TYPE_OSLO_AMUNDSEN)
+#else
+# define machine_is_oslo_amundsen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSL_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSL_DIAMOND
+# endif
+# define machine_is_gsl_diamond()	(machine_arch_type == MACH_TYPE_GSL_DIAMOND)
+#else
+# define machine_is_gsl_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2201
+# endif
+# define machine_is_cv2201()	(machine_arch_type == MACH_TYPE_CV2201)
+#else
+# define machine_is_cv2201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2202
+# endif
+# define machine_is_cv2202()	(machine_arch_type == MACH_TYPE_CV2202)
+#else
+# define machine_is_cv2202()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2203
+# endif
+# define machine_is_cv2203()	(machine_arch_type == MACH_TYPE_CV2203)
+#else
+# define machine_is_cv2203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIT_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIT_IBOX
+# endif
+# define machine_is_vit_ibox()	(machine_arch_type == MACH_TYPE_VIT_IBOX)
+#else
+# define machine_is_vit_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6441_ESP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6441_ESP
+# endif
+# define machine_is_dm6441_esp()	(machine_arch_type == MACH_TYPE_DM6441_ESP)
+#else
+# define machine_is_dm6441_esp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9X5EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9X5EK
+# endif
+# define machine_is_at91sam9x5ek()	(machine_arch_type == MACH_TYPE_AT91SAM9X5EK)
+#else
+# define machine_is_at91sam9x5ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBRA
+# endif
+# define machine_is_libra()	(machine_arch_type == MACH_TYPE_LIBRA)
+#else
+# define machine_is_libra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EASYCRRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EASYCRRH
+# endif
+# define machine_is_easycrrh()	(machine_arch_type == MACH_TYPE_EASYCRRH)
+#else
+# define machine_is_easycrrh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIPEL
+# endif
+# define machine_is_tripel()	(machine_arch_type == MACH_TYPE_TRIPEL)
+#else
+# define machine_is_tripel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDIAN_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDIAN_MINI
+# endif
+# define machine_is_endian_mini()	(machine_arch_type == MACH_TYPE_ENDIAN_MINI)
+#else
+# define machine_is_endian_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX_EP107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX_EP107
+# endif
+# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
+#else
+# define machine_is_xilinx_ep107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NURI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NURI
+# endif
+# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
+#else
+# define machine_is_nuri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JANUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS
+# endif
+# define machine_is_janus()	(machine_arch_type == MACH_TYPE_JANUS)
+#else
+# define machine_is_janus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDNAS
+# endif
+# define machine_is_ddnas()	(machine_arch_type == MACH_TYPE_DDNAS)
+#else
+# define machine_is_ddnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAG
+# endif
+# define machine_is_tag()	(machine_arch_type == MACH_TYPE_TAG)
+#else
+# define machine_is_tag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGW
+# endif
+# define machine_is_tagw()	(machine_arch_type == MACH_TYPE_TAGW)
+#else
+# define machine_is_tagw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_VM_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_VM_IMX51
+# endif
+# define machine_is_nitrogen_vm_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_VM_IMX51)
+#else
+# define machine_is_nitrogen_vm_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIPRINET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPRINET
+# endif
+# define machine_is_viprinet()	(machine_arch_type == MACH_TYPE_VIPRINET)
+#else
+# define machine_is_viprinet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOCKW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOCKW
+# endif
+# define machine_is_bockw()	(machine_arch_type == MACH_TYPE_BOCKW)
+#else
+# define machine_is_bockw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA2000
+# endif
+# define machine_is_eva2000()	(machine_arch_type == MACH_TYPE_EVA2000)
+#else
+# define machine_is_eva2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELYARD
+# endif
+# define machine_is_steelyard()	(machine_arch_type == MACH_TYPE_STEELYARD)
+#else
+# define machine_is_steelyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSSLSBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSSLSBOARD
+# endif
+# define machine_is_nsslsboard()	(machine_arch_type == MACH_TYPE_NSSLSBOARD)
+#else
+# define machine_is_nsslsboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA_B5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA_B5
+# endif
+# define machine_is_geneva_b5()	(machine_arch_type == MACH_TYPE_GENEVA_B5)
+#else
+# define machine_is_geneva_b5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1340
+# endif
+# define machine_is_spear1340()	(machine_arch_type == MACH_TYPE_SPEAR1340)
+#else
+# define machine_is_spear1340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REXMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REXMAS
+# endif
+# define machine_is_rexmas()	(machine_arch_type == MACH_TYPE_REXMAS)
+#else
+# define machine_is_rexmas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_CDP
+# endif
+# define machine_is_msm8960_cdp()	(machine_arch_type == MACH_TYPE_MSM8960_CDP)
+#else
+# define machine_is_msm8960_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_MTP
+# endif
+# define machine_is_msm8960_mtp()	(machine_arch_type == MACH_TYPE_MSM8960_MTP)
+#else
+# define machine_is_msm8960_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_FLUID
+# endif
+# define machine_is_msm8960_fluid()	(machine_arch_type == MACH_TYPE_MSM8960_FLUID)
+#else
+# define machine_is_msm8960_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_APQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_APQ
+# endif
+# define machine_is_msm8960_apq()	(machine_arch_type == MACH_TYPE_MSM8960_APQ)
+#else
+# define machine_is_msm8960_apq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V2
+# endif
+# define machine_is_helios_v2()	(machine_arch_type == MACH_TYPE_HELIOS_V2)
+#else
+# define machine_is_helios_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIF10P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIF10P
+# endif
+# define machine_is_mif10p()	(machine_arch_type == MACH_TYPE_MIF10P)
+#else
+# define machine_is_mif10p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IAM28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM28
+# endif
+# define machine_is_iam28()	(machine_arch_type == MACH_TYPE_IAM28)
+#else
+# define machine_is_iam28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO
+# endif
+# define machine_is_picasso()	(machine_arch_type == MACH_TYPE_PICASSO)
+#else
+# define machine_is_picasso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MR301A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MR301A
+# endif
+# define machine_is_mr301a()	(machine_arch_type == MACH_TYPE_MR301A)
+#else
+# define machine_is_mr301a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTLE
+# endif
+# define machine_is_notle()	(machine_arch_type == MACH_TYPE_NOTLE)
+#else
+# define machine_is_notle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EELX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EELX2
+# endif
+# define machine_is_eelx2()	(machine_arch_type == MACH_TYPE_EELX2)
+#else
+# define machine_is_eelx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOON
+# endif
+# define machine_is_moon()	(machine_arch_type == MACH_TYPE_MOON)
+#else
+# define machine_is_moon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBY
+# endif
+# define machine_is_ruby()	(machine_arch_type == MACH_TYPE_RUBY)
+#else
+# define machine_is_ruby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOLDENGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOLDENGATE
+# endif
+# define machine_is_goldengate()	(machine_arch_type == MACH_TYPE_GOLDENGATE)
+#else
+# define machine_is_goldengate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTBU_GEN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTBU_GEN2
+# endif
+# define machine_is_ctbu_gen2()	(machine_arch_type == MACH_TYPE_CTBU_GEN2)
+#else
+# define machine_is_ctbu_gen2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMP_AM17_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMP_AM17_01
+# endif
+# define machine_is_kmp_am17_01()	(machine_arch_type == MACH_TYPE_KMP_AM17_01)
+#else
+# define machine_is_kmp_am17_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WTPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WTPLUG
+# endif
+# define machine_is_wtplug()	(machine_arch_type == MACH_TYPE_WTPLUG)
+#else
+# define machine_is_wtplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27SU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27SU2
+# endif
+# define machine_is_mx27su2()	(machine_arch_type == MACH_TYPE_MX27SU2)
+#else
+# define machine_is_mx27su2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB31
+# endif
+# define machine_is_nb31()	(machine_arch_type == MACH_TYPE_NB31)
+#else
+# define machine_is_nb31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HJSDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HJSDU
+# endif
+# define machine_is_hjsdu()	(machine_arch_type == MACH_TYPE_HJSDU)
+#else
+# define machine_is_hjsdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TD3_REV1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TD3_REV1
+# endif
+# define machine_is_td3_rev1()	(machine_arch_type == MACH_TYPE_TD3_REV1)
+#else
+# define machine_is_td3_rev1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAG_CI4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAG_CI4000
+# endif
+# define machine_is_eag_ci4000()	(machine_arch_type == MACH_TYPE_EAG_CI4000)
+#else
+# define machine_is_eag_ci4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_NAND_V2
+# endif
+# define machine_is_net5big_nand_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_NAND_V2)
+#else
+# define machine_is_net5big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPX2
+# endif
+# define machine_is_cpx2()	(machine_arch_type == MACH_TYPE_CPX2)
+#else
+# define machine_is_cpx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_NAND_V2
+# endif
+# define machine_is_net2big_nand_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_NAND_V2)
+#else
+# define machine_is_net2big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECUV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECUV5
+# endif
+# define machine_is_ecuv5()	(machine_arch_type == MACH_TYPE_ECUV5)
+#else
+# define machine_is_ecuv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSGX6D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSGX6D
+# endif
+# define machine_is_hsgx6d()	(machine_arch_type == MACH_TYPE_HSGX6D)
+#else
+# define machine_is_hsgx6d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAWAD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAWAD7
+# endif
+# define machine_is_dawad7()	(machine_arch_type == MACH_TYPE_DAWAD7)
+#else
+# define machine_is_dawad7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9REPEATER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9REPEATER
+# endif
+# define machine_is_sam9repeater()	(machine_arch_type == MACH_TYPE_SAM9REPEATER)
+#else
+# define machine_is_sam9repeater()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GT_I5700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GT_I5700
+# endif
+# define machine_is_gt_i5700()	(machine_arch_type == MACH_TYPE_GT_I5700)
+#else
+# define machine_is_gt_i5700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C2
+# endif
+# define machine_is_ctera_plug_c2()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C2)
+#else
+# define machine_is_ctera_plug_c2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELCT
+# endif
+# define machine_is_marvelct()	(machine_arch_type == MACH_TYPE_MARVELCT)
+#else
+# define machine_is_marvelct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG11005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG11005
+# endif
+# define machine_is_ag11005()	(machine_arch_type == MACH_TYPE_AG11005)
+#else
+# define machine_is_ag11005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH
+# endif
+# define machine_is_vangogh()	(machine_arch_type == MACH_TYPE_VANGOGH)
+#else
+# define machine_is_vangogh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX505
+# endif
+# define machine_is_matrix505()	(machine_arch_type == MACH_TYPE_MATRIX505)
+#else
+# define machine_is_matrix505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_NIGMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_NIGMA
+# endif
+# define machine_is_oce_nigma()	(machine_arch_type == MACH_TYPE_OCE_NIGMA)
+#else
+# define machine_is_oce_nigma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T55
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T55
+# endif
+# define machine_is_t55()	(machine_arch_type == MACH_TYPE_T55)
+#else
+# define machine_is_t55()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIO3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIO3K
+# endif
+# define machine_is_bio3k()	(machine_arch_type == MACH_TYPE_BIO3K)
+#else
+# define machine_is_bio3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSCT
+# endif
+# define machine_is_expressct()	(machine_arch_type == MACH_TYPE_EXPRESSCT)
+#else
+# define machine_is_expressct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARDHU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARDHU
+# endif
+# define machine_is_cardhu()	(machine_arch_type == MACH_TYPE_CARDHU)
+#else
+# define machine_is_cardhu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARUBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARUBA
+# endif
+# define machine_is_aruba()	(machine_arch_type == MACH_TYPE_ARUBA)
+#else
+# define machine_is_aruba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONAIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONAIRE
+# endif
+# define machine_is_bonaire()	(machine_arch_type == MACH_TYPE_BONAIRE)
+#else
+# define machine_is_bonaire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC700EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC700EVB
+# endif
+# define machine_is_nuc700evb()	(machine_arch_type == MACH_TYPE_NUC700EVB)
+#else
+# define machine_is_nuc700evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC710EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC710EVB
+# endif
+# define machine_is_nuc710evb()	(machine_arch_type == MACH_TYPE_NUC710EVB)
+#else
+# define machine_is_nuc710evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC740EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC740EVB
+# endif
+# define machine_is_nuc740evb()	(machine_arch_type == MACH_TYPE_NUC740EVB)
+#else
+# define machine_is_nuc740evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC745EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC745EVB
+# endif
+# define machine_is_nuc745evb()	(machine_arch_type == MACH_TYPE_NUC745EVB)
+#else
+# define machine_is_nuc745evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRANSCEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRANSCEDE
+# endif
+# define machine_is_transcede()	(machine_arch_type == MACH_TYPE_TRANSCEDE)
+#else
+# define machine_is_transcede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORA
+# endif
+# define machine_is_mora()	(machine_arch_type == MACH_TYPE_MORA)
+#else
+# define machine_is_mora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NDA_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NDA_EVM
+# endif
+# define machine_is_nda_evm()	(machine_arch_type == MACH_TYPE_NDA_EVM)
+#else
+# define machine_is_nda_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIMU
+# endif
+# define machine_is_timu()	(machine_arch_type == MACH_TYPE_TIMU)
+#else
+# define machine_is_timu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSH
+# endif
+# define machine_is_expressh()	(machine_arch_type == MACH_TYPE_EXPRESSH)
+#else
+# define machine_is_expressh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERIDIS_A300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERIDIS_A300
+# endif
+# define machine_is_veridis_a300()	(machine_arch_type == MACH_TYPE_VERIDIS_A300)
+#else
+# define machine_is_veridis_a300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM368_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM368_LEOPARD
+# endif
+# define machine_is_dm368_leopard()	(machine_arch_type == MACH_TYPE_DM368_LEOPARD)
+#else
+# define machine_is_dm368_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_MCOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_MCOP
+# endif
+# define machine_is_omap_mcop()	(machine_arch_type == MACH_TYPE_OMAP_MCOP)
+#else
+# define machine_is_omap_mcop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRITIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRITIP
+# endif
+# define machine_is_tritip()	(machine_arch_type == MACH_TYPE_TRITIP)
+#else
+# define machine_is_tritip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM1K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM1K
+# endif
+# define machine_is_sm1k()	(machine_arch_type == MACH_TYPE_SM1K)
+#else
+# define machine_is_sm1k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONCH
+# endif
+# define machine_is_monch()	(machine_arch_type == MACH_TYPE_MONCH)
+#else
+# define machine_is_monch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CURACAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CURACAO
+# endif
+# define machine_is_curacao()	(machine_arch_type == MACH_TYPE_CURACAO)
+#else
+# define machine_is_curacao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORIGEN
+# endif
+# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
+#else
+# define machine_is_origen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPC10
+# endif
+# define machine_is_epc10()	(machine_arch_type == MACH_TYPE_EPC10)
+#else
+# define machine_is_epc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I740
+# endif
+# define machine_is_sgh_i740()	(machine_arch_type == MACH_TYPE_SGH_I740)
+#else
+# define machine_is_sgh_i740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNA
+# endif
+# define machine_is_tuna()	(machine_arch_type == MACH_TYPE_TUNA)
+#else
+# define machine_is_tuna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_TULIP
+# endif
+# define machine_is_mx51_tulip()	(machine_arch_type == MACH_TYPE_MX51_TULIP)
+#else
+# define machine_is_mx51_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_ASTER7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_ASTER7
+# endif
+# define machine_is_mx51_aster7()	(machine_arch_type == MACH_TYPE_MX51_ASTER7)
+#else
+# define machine_is_mx51_aster7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACRO37XBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACRO37XBRD
+# endif
+# define machine_is_acro37xbrd()	(machine_arch_type == MACH_TYPE_ACRO37XBRD)
+#else
+# define machine_is_acro37xbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELKE
+# endif
+# define machine_is_elke()	(machine_arch_type == MACH_TYPE_ELKE)
+#else
+# define machine_is_elke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC6000X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC6000X
+# endif
+# define machine_is_sbc6000x()	(machine_arch_type == MACH_TYPE_SBC6000X)
+#else
+# define machine_is_sbc6000x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1801E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1801E
+# endif
+# define machine_is_r1801e()	(machine_arch_type == MACH_TYPE_R1801E)
+#else
+# define machine_is_r1801e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1600
+# endif
+# define machine_is_h1600()	(machine_arch_type == MACH_TYPE_H1600)
+#else
+# define machine_is_h1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI210
+# endif
+# define machine_is_mini210()	(machine_arch_type == MACH_TYPE_MINI210)
+#else
+# define machine_is_mini210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI8168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI8168
+# endif
+# define machine_is_mini8168()	(machine_arch_type == MACH_TYPE_MINI8168)
+#else
+# define machine_is_mini8168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7308
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7308
+# endif
+# define machine_is_pc7308()	(machine_arch_type == MACH_TYPE_PC7308)
+#else
+# define machine_is_pc7308()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMM2M01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMM2M01
+# endif
+# define machine_is_kmm2m01()	(machine_arch_type == MACH_TYPE_KMM2M01)
+#else
+# define machine_is_kmm2m01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51EREBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51EREBUS
+# endif
+# define machine_is_mx51erebus()	(machine_arch_type == MACH_TYPE_MX51EREBUS)
+#else
+# define machine_is_mx51erebus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8650REFBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8650REFBOARD
+# endif
+# define machine_is_wm8650refboard()	(machine_arch_type == MACH_TYPE_WM8650REFBOARD)
+#else
+# define machine_is_wm8650refboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUXRAIL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUXRAIL
+# endif
+# define machine_is_tuxrail()	(machine_arch_type == MACH_TYPE_TUXRAIL)
+#else
+# define machine_is_tuxrail()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARTHUR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARTHUR
+# endif
+# define machine_is_arthur()	(machine_arch_type == MACH_TYPE_ARTHUR)
+#else
+# define machine_is_arthur()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOORBOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOORBOY
+# endif
+# define machine_is_doorboy()	(machine_arch_type == MACH_TYPE_DOORBOY)
+#else
+# define machine_is_doorboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARINA
+# endif
+# define machine_is_xarina()	(machine_arch_type == MACH_TYPE_XARINA)
+#else
+# define machine_is_xarina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERX7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERX7
+# endif
+# define machine_is_roverx7()	(machine_arch_type == MACH_TYPE_ROVERX7)
+#else
+# define machine_is_roverx7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR
+# endif
+# define machine_is_sdvr()	(machine_arch_type == MACH_TYPE_SDVR)
+#else
+# define machine_is_sdvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_MAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_MAYA
+# endif
+# define machine_is_acer_maya()	(machine_arch_type == MACH_TYPE_ACER_MAYA)
+#else
+# define machine_is_acer_maya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICO
+# endif
+# define machine_is_pico()	(machine_arch_type == MACH_TYPE_PICO)
+#else
+# define machine_is_pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX233
+# endif
+# define machine_is_cwmx233()	(machine_arch_type == MACH_TYPE_CWMX233)
+#else
+# define machine_is_cwmx233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWAM1808
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWAM1808
+# endif
+# define machine_is_cwam1808()	(machine_arch_type == MACH_TYPE_CWAM1808)
+#else
+# define machine_is_cwam1808()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWDM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWDM365
+# endif
+# define machine_is_cwdm365()	(machine_arch_type == MACH_TYPE_CWDM365)
+#else
+# define machine_is_cwdm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_MORAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_MORAY
+# endif
+# define machine_is_mx51_moray()	(machine_arch_type == MACH_TYPE_MX51_MORAY)
+#else
+# define machine_is_mx51_moray()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_CBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_CBC
+# endif
+# define machine_is_thales_cbc()	(machine_arch_type == MACH_TYPE_THALES_CBC)
+#else
+# define machine_is_thales_cbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEPOINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEPOINT
+# endif
+# define machine_is_bluepoint()	(machine_arch_type == MACH_TYPE_BLUEPOINT)
+#else
+# define machine_is_bluepoint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIR665
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIR665
+# endif
+# define machine_is_dir665()	(machine_arch_type == MACH_TYPE_DIR665)
+#else
+# define machine_is_dir665()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMEROVER1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMEROVER1
+# endif
+# define machine_is_acmerover1()	(machine_arch_type == MACH_TYPE_ACMEROVER1)
+#else
+# define machine_is_acmerover1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_CT
+# endif
+# define machine_is_shooter_ct()	(machine_arch_type == MACH_TYPE_SHOOTER_CT)
+#else
+# define machine_is_shooter_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISS
+# endif
+# define machine_is_bliss()	(machine_arch_type == MACH_TYPE_BLISS)
+#else
+# define machine_is_bliss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISSC
+# endif
+# define machine_is_blissc()	(machine_arch_type == MACH_TYPE_BLISSC)
+#else
+# define machine_is_blissc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_ADC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_ADC
+# endif
+# define machine_is_thales_adc()	(machine_arch_type == MACH_TYPE_THALES_ADC)
+#else
+# define machine_is_thales_adc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9D_EVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9D_EVP
+# endif
+# define machine_is_ubisys_p9d_evp()	(machine_arch_type == MACH_TYPE_UBISYS_P9D_EVP)
+#else
+# define machine_is_ubisys_p9d_evp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATDGP318
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATDGP318
+# endif
+# define machine_is_atdgp318()	(machine_arch_type == MACH_TYPE_ATDGP318)
+#else
+# define machine_is_atdgp318()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA210U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA210U
+# endif
+# define machine_is_dma210u()	(machine_arch_type == MACH_TYPE_DMA210U)
+#else
+# define machine_is_dma210u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_T3
+# endif
+# define machine_is_em_t3()	(machine_arch_type == MACH_TYPE_EM_T3)
+#else
+# define machine_is_em_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTX3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTX3250
+# endif
+# define machine_is_htx3250()	(machine_arch_type == MACH_TYPE_HTX3250)
+#else
+# define machine_is_htx3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G50
+# endif
+# define machine_is_g50()	(machine_arch_type == MACH_TYPE_G50)
+#else
+# define machine_is_g50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO5
+# endif
+# define machine_is_eco5()	(machine_arch_type == MACH_TYPE_ECO5)
+#else
+# define machine_is_eco5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WINTERGRASP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WINTERGRASP
+# endif
+# define machine_is_wintergrasp()	(machine_arch_type == MACH_TYPE_WINTERGRASP)
+#else
+# define machine_is_wintergrasp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PURO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PURO
+# endif
+# define machine_is_puro()	(machine_arch_type == MACH_TYPE_PURO)
+#else
+# define machine_is_puro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_K
+# endif
+# define machine_is_shooter_k()	(machine_arch_type == MACH_TYPE_SHOOTER_K)
+#else
+# define machine_is_shooter_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSPIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSPIRE
+# endif
+# define machine_is_nspire()	(machine_arch_type == MACH_TYPE_NSPIRE)
+#else
+# define machine_is_nspire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICKXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICKXX
+# endif
+# define machine_is_mickxx()	(machine_arch_type == MACH_TYPE_MICKXX)
+#else
+# define machine_is_mickxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LXMB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LXMB
+# endif
+# define machine_is_lxmb()	(machine_arch_type == MACH_TYPE_LXMB)
+#else
+# define machine_is_lxmb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAM
+# endif
+# define machine_is_adam()	(machine_arch_type == MACH_TYPE_ADAM)
+#else
+# define machine_is_adam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B1004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B1004
+# endif
+# define machine_is_b1004()	(machine_arch_type == MACH_TYPE_B1004)
+#else
+# define machine_is_b1004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OBOEA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OBOEA
+# endif
+# define machine_is_oboea()	(machine_arch_type == MACH_TYPE_OBOEA)
+#else
+# define machine_is_oboea()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A1015
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A1015
+# endif
+# define machine_is_a1015()	(machine_arch_type == MACH_TYPE_A1015)
+#else
+# define machine_is_a1015()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROBIN_VBDT30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROBIN_VBDT30
+# endif
+# define machine_is_robin_vbdt30()	(machine_arch_type == MACH_TYPE_ROBIN_VBDT30)
+#else
+# define machine_is_robin_vbdt30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_ENTERPRISE
+# endif
+# define machine_is_tegra_enterprise()	(machine_arch_type == MACH_TYPE_TEGRA_ENTERPRISE)
+#else
+# define machine_is_tegra_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL108200_MK10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL108200_MK10
+# endif
+# define machine_is_rfl108200_mk10()	(machine_arch_type == MACH_TYPE_RFL108200_MK10)
+#else
+# define machine_is_rfl108200_mk10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL108300_MK16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL108300_MK16
+# endif
+# define machine_is_rfl108300_mk16()	(machine_arch_type == MACH_TYPE_RFL108300_MK16)
+#else
+# define machine_is_rfl108300_mk16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_V7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_V7
+# endif
+# define machine_is_rover_v7()	(machine_arch_type == MACH_TYPE_ROVER_V7)
+#else
+# define machine_is_rover_v7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPHONE
+# endif
+# define machine_is_miphone()	(machine_arch_type == MACH_TYPE_MIPHONE)
+#else
+# define machine_is_miphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FEMTOBTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FEMTOBTS
+# endif
+# define machine_is_femtobts()	(machine_arch_type == MACH_TYPE_FEMTOBTS)
+#else
+# define machine_is_femtobts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONOPOLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONOPOLI
+# endif
+# define machine_is_monopoli()	(machine_arch_type == MACH_TYPE_MONOPOLI)
+#else
+# define machine_is_monopoli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOSS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOSS
+# endif
+# define machine_is_boss()	(machine_arch_type == MACH_TYPE_BOSS)
+#else
+# define machine_is_boss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM368_VTAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM368_VTAM
+# endif
+# define machine_is_davinci_dm368_vtam()	(machine_arch_type == MACH_TYPE_DAVINCI_DM368_VTAM)
+#else
+# define machine_is_davinci_dm368_vtam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLCON
+# endif
+# define machine_is_clcon()	(machine_arch_type == MACH_TYPE_CLCON)
+#else
+# define machine_is_clcon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM696
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM696
+# endif
+# define machine_is_nokia_rm696()	(machine_arch_type == MACH_TYPE_NOKIA_RM696)
+#else
+# define machine_is_nokia_rm696()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAHITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAHITI
+# endif
+# define machine_is_tahiti()	(machine_arch_type == MACH_TYPE_TAHITI)
+#else
+# define machine_is_tahiti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIGHTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIGHTER
+# endif
+# define machine_is_fighter()	(machine_arch_type == MACH_TYPE_FIGHTER)
+#else
+# define machine_is_fighter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I710
+# endif
+# define machine_is_sgh_i710()	(machine_arch_type == MACH_TYPE_SGH_I710)
+#else
+# define machine_is_sgh_i710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTEGREPROSCB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGREPROSCB
+# endif
+# define machine_is_integreproscb()	(machine_arch_type == MACH_TYPE_INTEGREPROSCB)
+#else
+# define machine_is_integreproscb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONZA
+# endif
+# define machine_is_monza()	(machine_arch_type == MACH_TYPE_MONZA)
+#else
+# define machine_is_monza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CALIMAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CALIMAIN
+# endif
+# define machine_is_calimain()	(machine_arch_type == MACH_TYPE_CALIMAIN)
+#else
+# define machine_is_calimain()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_SABREAUTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_SABREAUTO
+# endif
+# define machine_is_mx6q_sabreauto()	(machine_arch_type == MACH_TYPE_MX6Q_SABREAUTO)
+#else
+# define machine_is_mx6q_sabreauto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GMA01X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMA01X
+# endif
+# define machine_is_gma01x()	(machine_arch_type == MACH_TYPE_GMA01X)
+#else
+# define machine_is_gma01x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC51
+# endif
+# define machine_is_sbc51()	(machine_arch_type == MACH_TYPE_SBC51)
+#else
+# define machine_is_sbc51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIT
+# endif
+# define machine_is_fit()	(machine_arch_type == MACH_TYPE_FIT)
+#else
+# define machine_is_fit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELHEAD
+# endif
+# define machine_is_steelhead()	(machine_arch_type == MACH_TYPE_STEELHEAD)
+#else
+# define machine_is_steelhead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PANTHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTHER
+# endif
+# define machine_is_panther()	(machine_arch_type == MACH_TYPE_PANTHER)
+#else
+# define machine_is_panther()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_LIQUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_LIQUID
+# endif
+# define machine_is_msm8960_liquid()	(machine_arch_type == MACH_TYPE_MSM8960_LIQUID)
+#else
+# define machine_is_msm8960_liquid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXIKONCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXIKONCT
+# endif
+# define machine_is_lexikonct()	(machine_arch_type == MACH_TYPE_LEXIKONCT)
+#else
+# define machine_is_lexikonct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_STB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_STB
+# endif
+# define machine_is_ns2816_stb()	(machine_arch_type == MACH_TYPE_NS2816_STB)
+#else
+# define machine_is_ns2816_stb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEI_MM2_LPC3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEI_MM2_LPC3250
+# endif
+# define machine_is_sei_mm2_lpc3250()	(machine_arch_type == MACH_TYPE_SEI_MM2_LPC3250)
+#else
+# define machine_is_sei_mm2_lpc3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMIMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMIMX53
+# endif
+# define machine_is_cmimx53()	(machine_arch_type == MACH_TYPE_CMIMX53)
+#else
+# define machine_is_cmimx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDWICH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDWICH
+# endif
+# define machine_is_sandwich()	(machine_arch_type == MACH_TYPE_SANDWICH)
+#else
+# define machine_is_sandwich()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHIEF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIEF
+# endif
+# define machine_is_chief()	(machine_arch_type == MACH_TYPE_CHIEF)
+#else
+# define machine_is_chief()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POGO_E02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POGO_E02
+# endif
+# define machine_is_pogo_e02()	(machine_arch_type == MACH_TYPE_POGO_E02)
+#else
+# define machine_is_pogo_e02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIKRAP_X168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIKRAP_X168
+# endif
+# define machine_is_mikrap_x168()	(machine_arch_type == MACH_TYPE_MIKRAP_X168)
+#else
+# define machine_is_mikrap_x168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCMOZART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCMOZART
+# endif
+# define machine_is_htcmozart()	(machine_arch_type == MACH_TYPE_HTCMOZART)
+#else
+# define machine_is_htcmozart()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCGOLD
+# endif
+# define machine_is_htcgold()	(machine_arch_type == MACH_TYPE_HTCGOLD)
+#else
+# define machine_is_htcgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT72XX
+# endif
+# define machine_is_mt72xx()	(machine_arch_type == MACH_TYPE_MT72XX)
+#else
+# define machine_is_mt72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_IVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_IVY
+# endif
+# define machine_is_mx51_ivy()	(machine_arch_type == MACH_TYPE_MX51_IVY)
+#else
+# define machine_is_mx51_ivy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_LVD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_LVD
+# endif
+# define machine_is_mx51_lvd()	(machine_arch_type == MACH_TYPE_MX51_LVD)
+#else
+# define machine_is_mx51_lvd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WISER2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WISER2
+# endif
+# define machine_is_omap3_wiser2()	(machine_arch_type == MACH_TYPE_OMAP3_WISER2)
+#else
+# define machine_is_omap3_wiser2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREAMPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREAMPLUG
+# endif
+# define machine_is_dreamplug()	(machine_arch_type == MACH_TYPE_DREAMPLUG)
+#else
+# define machine_is_dreamplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBAS_C_111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBAS_C_111
+# endif
+# define machine_is_cobas_c_111()	(machine_arch_type == MACH_TYPE_COBAS_C_111)
+#else
+# define machine_is_cobas_c_111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBAS_U_411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBAS_U_411
+# endif
+# define machine_is_cobas_u_411()	(machine_arch_type == MACH_TYPE_COBAS_U_411)
+#else
+# define machine_is_cobas_u_411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSSD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSSD
+# endif
+# define machine_is_hssd()	(machine_arch_type == MACH_TYPE_HSSD)
+#else
+# define machine_is_hssd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IOM35X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IOM35X
+# endif
+# define machine_is_iom35x()	(machine_arch_type == MACH_TYPE_IOM35X)
+#else
+# define machine_is_iom35x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PSOM_OMAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSOM_OMAP
+# endif
+# define machine_is_psom_omap()	(machine_arch_type == MACH_TYPE_PSOM_OMAP)
+#else
+# define machine_is_psom_omap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_2G
+# endif
+# define machine_is_iphone_2g()	(machine_arch_type == MACH_TYPE_IPHONE_2G)
+#else
+# define machine_is_iphone_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_3G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_3G
+# endif
+# define machine_is_iphone_3g()	(machine_arch_type == MACH_TYPE_IPHONE_3G)
+#else
+# define machine_is_iphone_3g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_1G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_1G
+# endif
+# define machine_is_ipod_touch_1g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_1G)
+#else
+# define machine_is_ipod_touch_1g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHAROS_TPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHAROS_TPC
+# endif
+# define machine_is_pharos_tpc()	(machine_arch_type == MACH_TYPE_PHAROS_TPC)
+#else
+# define machine_is_pharos_tpc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_HYDRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_HYDRA
+# endif
+# define machine_is_mx53_hydra()	(machine_arch_type == MACH_TYPE_MX53_HYDRA)
+#else
+# define machine_is_mx53_hydra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_DEV_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_DEV_BOARD
+# endif
+# define machine_is_ns2816_dev_board()	(machine_arch_type == MACH_TYPE_NS2816_DEV_BOARD)
+#else
+# define machine_is_ns2816_dev_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_3GS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_3GS
+# endif
+# define machine_is_iphone_3gs()	(machine_arch_type == MACH_TYPE_IPHONE_3GS)
+#else
+# define machine_is_iphone_3gs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPHONE_4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPHONE_4
+# endif
+# define machine_is_iphone_4()	(machine_arch_type == MACH_TYPE_IPHONE_4)
+#else
+# define machine_is_iphone_4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_4G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_4G
+# endif
+# define machine_is_ipod_touch_4g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_4G)
+#else
+# define machine_is_ipod_touch_4g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON_E1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON_E1100
+# endif
+# define machine_is_dragon_e1100()	(machine_arch_type == MACH_TYPE_DRAGON_E1100)
+#else
+# define machine_is_dragon_e1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPSIDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPSIDE
+# endif
+# define machine_is_topside()	(machine_arch_type == MACH_TYPE_TOPSIDE)
+#else
+# define machine_is_topside()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IRISIII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IRISIII
+# endif
+# define machine_is_irisiii()	(machine_arch_type == MACH_TYPE_IRISIII)
+#else
+# define machine_is_irisiii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DETO_MACARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DETO_MACARM9
+# endif
+# define machine_is_deto_macarm9()	(machine_arch_type == MACH_TYPE_DETO_MACARM9)
+#else
+# define machine_is_deto_macarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_D1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_D1
+# endif
+# define machine_is_eti_d1()	(machine_arch_type == MACH_TYPE_ETI_D1)
+#else
+# define machine_is_eti_d1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOM3530SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOM3530SDK
+# endif
+# define machine_is_som3530sdk()	(machine_arch_type == MACH_TYPE_SOM3530SDK)
+#else
+# define machine_is_som3530sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OC_ENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OC_ENGINE
+# endif
+# define machine_is_oc_engine()	(machine_arch_type == MACH_TYPE_OC_ENGINE)
+#else
+# define machine_is_oc_engine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_SIM
+# endif
+# define machine_is_apq8064_sim()	(machine_arch_type == MACH_TYPE_APQ8064_SIM)
+#else
+# define machine_is_apq8064_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPS
+# endif
+# define machine_is_alps()	(machine_arch_type == MACH_TYPE_ALPS)
+#else
+# define machine_is_alps()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_T3730
+# endif
+# define machine_is_tny_t3730()	(machine_arch_type == MACH_TYPE_TNY_T3730)
+#else
+# define machine_is_tny_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GERYON_NFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GERYON_NFE
+# endif
+# define machine_is_geryon_nfe()	(machine_arch_type == MACH_TYPE_GERYON_NFE)
+#else
+# define machine_is_geryon_nfe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_REF_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_REF_BOARD
+# endif
+# define machine_is_ns2816_ref_board()	(machine_arch_type == MACH_TYPE_NS2816_REF_BOARD)
+#else
+# define machine_is_ns2816_ref_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SILVERSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SILVERSTONE
+# endif
+# define machine_is_silverstone()	(machine_arch_type == MACH_TYPE_SILVERSTONE)
+#else
+# define machine_is_silverstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT2440
+# endif
+# define machine_is_mtt2440()	(machine_arch_type == MACH_TYPE_MTT2440)
+#else
+# define machine_is_mtt2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YNICDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YNICDB
+# endif
+# define machine_is_ynicdb()	(machine_arch_type == MACH_TYPE_YNICDB)
+#else
+# define machine_is_ynicdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCT
+# endif
+# define machine_is_bct()	(machine_arch_type == MACH_TYPE_BCT)
+#else
+# define machine_is_bct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUSCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUSCAN
+# endif
+# define machine_is_tuscan()	(machine_arch_type == MACH_TYPE_TUSCAN)
+#else
+# define machine_is_tuscan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBT_SAM9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBT_SAM9G45
+# endif
+# define machine_is_xbt_sam9g45()	(machine_arch_type == MACH_TYPE_XBT_SAM9G45)
+#else
+# define machine_is_xbt_sam9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENBW_CMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENBW_CMC
+# endif
+# define machine_is_enbw_cmc()	(machine_arch_type == MACH_TYPE_ENBW_CMC)
+#else
+# define machine_is_enbw_cmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_DRAGON
+# endif
+# define machine_is_msm8x60_dragon()	(machine_arch_type == MACH_TYPE_MSM8X60_DRAGON)
+#else
+# define machine_is_msm8x60_dragon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CH104MX257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CH104MX257
+# endif
+# define machine_is_ch104mx257()	(machine_arch_type == MACH_TYPE_CH104MX257)
+#else
+# define machine_is_ch104mx257()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENPRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENPRI
+# endif
+# define machine_is_openpri()	(machine_arch_type == MACH_TYPE_OPENPRI)
+#else
+# define machine_is_openpri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM335XEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM335XEVM
+# endif
+# define machine_is_am335xevm()	(machine_arch_type == MACH_TYPE_AM335XEVM)
+#else
+# define machine_is_am335xevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICODMB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICODMB
+# endif
+# define machine_is_picodmb()	(machine_arch_type == MACH_TYPE_PICODMB)
+#else
+# define machine_is_picodmb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WALUIGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WALUIGI
+# endif
+# define machine_is_waluigi()	(machine_arch_type == MACH_TYPE_WALUIGI)
+#else
+# define machine_is_waluigi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUNICAG7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUNICAG7
+# endif
+# define machine_is_punicag7()	(machine_arch_type == MACH_TYPE_PUNICAG7)
+#else
+# define machine_is_punicag7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAD_1G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAD_1G
+# endif
+# define machine_is_ipad_1g()	(machine_arch_type == MACH_TYPE_IPAD_1G)
+#else
+# define machine_is_ipad_1g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APPLETV_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APPLETV_2G
+# endif
+# define machine_is_appletv_2g()	(machine_arch_type == MACH_TYPE_APPLETV_2G)
+#else
+# define machine_is_appletv_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_ECOG45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_ECOG45
+# endif
+# define machine_is_mach_ecog45()	(machine_arch_type == MACH_TYPE_MACH_ECOG45)
+#else
+# define machine_is_mach_ecog45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIT_CAM_ENC_4XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIT_CAM_ENC_4XX
+# endif
+# define machine_is_ait_cam_enc_4xx()	(machine_arch_type == MACH_TYPE_AIT_CAM_ENC_4XX)
+#else
+# define machine_is_ait_cam_enc_4xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUNNYMEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUNNYMEDE
+# endif
+# define machine_is_runnymede()	(machine_arch_type == MACH_TYPE_RUNNYMEDE)
+#else
+# define machine_is_runnymede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLAY
+# endif
+# define machine_is_play()	(machine_arch_type == MACH_TYPE_PLAY)
+#else
+# define machine_is_play()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90260
+# endif
+# define machine_is_hw90260()	(machine_arch_type == MACH_TYPE_HW90260)
+#else
+# define machine_is_hw90260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGH
+# endif
+# define machine_is_tagh()	(machine_arch_type == MACH_TYPE_TAGH)
+#else
+# define machine_is_tagh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FILBERT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILBERT
+# endif
+# define machine_is_filbert()	(machine_arch_type == MACH_TYPE_FILBERT)
+#else
+# define machine_is_filbert()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GETINGE_NETCOMV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GETINGE_NETCOMV3
+# endif
+# define machine_is_getinge_netcomv3()	(machine_arch_type == MACH_TYPE_GETINGE_NETCOMV3)
+#else
+# define machine_is_getinge_netcomv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CW20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CW20
+# endif
+# define machine_is_cw20()	(machine_arch_type == MACH_TYPE_CW20)
+#else
+# define machine_is_cw20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA
+# endif
+# define machine_is_cinema()	(machine_arch_type == MACH_TYPE_CINEMA)
+#else
+# define machine_is_cinema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_TEA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_TEA
+# endif
+# define machine_is_cinema_tea()	(machine_arch_type == MACH_TYPE_CINEMA_TEA)
+#else
+# define machine_is_cinema_tea()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_COFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_COFFEE
+# endif
+# define machine_is_cinema_coffee()	(machine_arch_type == MACH_TYPE_CINEMA_COFFEE)
+#else
+# define machine_is_cinema_coffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CINEMA_JUICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINEMA_JUICE
+# endif
+# define machine_is_cinema_juice()	(machine_arch_type == MACH_TYPE_CINEMA_JUICE)
+#else
+# define machine_is_cinema_juice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_MIRAGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_MIRAGE2
+# endif
+# define machine_is_mx53_mirage2()	(machine_arch_type == MACH_TYPE_MX53_MIRAGE2)
+#else
+# define machine_is_mx53_mirage2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EFIKASB
+# endif
+# define machine_is_mx53_efikasb()	(machine_arch_type == MACH_TYPE_MX53_EFIKASB)
+#else
+# define machine_is_mx53_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM_B2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM_B2000
+# endif
+# define machine_is_stm_b2000()	(machine_arch_type == MACH_TYPE_STM_B2000)
+#else
+# define machine_is_stm_b2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M28EVK
+# endif
+# define machine_is_m28evk()	(machine_arch_type == MACH_TYPE_M28EVK)
+#else
+# define machine_is_m28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA
+# endif
+# define machine_is_pda()	(machine_arch_type == MACH_TYPE_PDA)
+#else
+# define machine_is_pda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERAKI_MR58
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERAKI_MR58
+# endif
+# define machine_is_meraki_mr58()	(machine_arch_type == MACH_TYPE_MERAKI_MR58)
+#else
+# define machine_is_meraki_mr58()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOTA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOTA2
+# endif
+# define machine_is_kota2()	(machine_arch_type == MACH_TYPE_KOTA2)
+#else
+# define machine_is_kota2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LETCOOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LETCOOL
+# endif
+# define machine_is_letcool()	(machine_arch_type == MACH_TYPE_LETCOOL)
+#else
+# define machine_is_letcool()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27IAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27IAT
+# endif
+# define machine_is_mx27iat()	(machine_arch_type == MACH_TYPE_MX27IAT)
+#else
+# define machine_is_mx27iat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APOLLO_TD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APOLLO_TD
+# endif
+# define machine_is_apollo_td()	(machine_arch_type == MACH_TYPE_APOLLO_TD)
+#else
+# define machine_is_apollo_td()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARENA
+# endif
+# define machine_is_arena()	(machine_arch_type == MACH_TYPE_ARENA)
+#else
+# define machine_is_arena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSNGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSNGATEWAY
+# endif
+# define machine_is_gsngateway()	(machine_arch_type == MACH_TYPE_GSNGATEWAY)
+#else
+# define machine_is_gsngateway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LF2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LF2000
+# endif
+# define machine_is_lf2000()	(machine_arch_type == MACH_TYPE_LF2000)
+#else
+# define machine_is_lf2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONITO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONITO
+# endif
+# define machine_is_bonito()	(machine_arch_type == MACH_TYPE_BONITO)
+#else
+# define machine_is_bonito()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASYMPTOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASYMPTOTE
+# endif
+# define machine_is_asymptote()	(machine_arch_type == MACH_TYPE_ASYMPTOTE)
+#else
+# define machine_is_asymptote()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BST2BRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BST2BRD
+# endif
+# define machine_is_bst2brd()	(machine_arch_type == MACH_TYPE_BST2BRD)
+#else
+# define machine_is_bst2brd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX335S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX335S
+# endif
+# define machine_is_tx335s()	(machine_arch_type == MACH_TYPE_TX335S)
+#else
+# define machine_is_tx335s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_TESLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_TESLA
+# endif
+# define machine_is_pelco_tesla()	(machine_arch_type == MACH_TYPE_PELCO_TESLA)
+#else
+# define machine_is_pelco_tesla()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RRHTESTPLAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RRHTESTPLAT
+# endif
+# define machine_is_rrhtestplat()	(machine_arch_type == MACH_TYPE_RRHTESTPLAT)
+#else
+# define machine_is_rrhtestplat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIDTONIC_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIDTONIC_PRO
+# endif
+# define machine_is_vidtonic_pro()	(machine_arch_type == MACH_TYPE_VIDTONIC_PRO)
+#else
+# define machine_is_vidtonic_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PL_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PL_APOLLO
+# endif
+# define machine_is_pl_apollo()	(machine_arch_type == MACH_TYPE_PL_APOLLO)
+#else
+# define machine_is_pl_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PL_PHOENIX
+# endif
+# define machine_is_pl_phoenix()	(machine_arch_type == MACH_TYPE_PL_PHOENIX)
+#else
+# define machine_is_pl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M28CU3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M28CU3
+# endif
+# define machine_is_m28cu3()	(machine_arch_type == MACH_TYPE_M28CU3)
+#else
+# define machine_is_m28cu3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_HD
+# endif
+# define machine_is_vvbox_hd()	(machine_arch_type == MACH_TYPE_VVBOX_HD)
+#else
+# define machine_is_vvbox_hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREWARE_SAM9260_
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREWARE_SAM9260_
+# endif
+# define machine_is_coreware_sam9260_()	(machine_arch_type == MACH_TYPE_COREWARE_SAM9260_)
+#else
+# define machine_is_coreware_sam9260_()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARMADUKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARMADUKE
+# endif
+# define machine_is_marmaduke()	(machine_arch_type == MACH_TYPE_MARMADUKE)
+#else
+# define machine_is_marmaduke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMG_XLCORE_CAMERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMG_XLCORE_CAMERA
+# endif
+# define machine_is_amg_xlcore_camera()	(machine_arch_type == MACH_TYPE_AMG_XLCORE_CAMERA)
+#else
+# define machine_is_amg_xlcore_camera()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_EGF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_EGF
+# endif
+# define machine_is_omap3_egf()	(machine_arch_type == MACH_TYPE_OMAP3_EGF)
+#else
+# define machine_is_omap3_egf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4212
+# endif
+# define machine_is_smdk4212()	(machine_arch_type == MACH_TYPE_SMDK4212)
+#else
+# define machine_is_smdk4212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNP9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP9200
+# endif
+# define machine_is_dnp9200()	(machine_arch_type == MACH_TYPE_DNP9200)
+#else
+# define machine_is_dnp9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TF101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TF101
+# endif
+# define machine_is_tf101()	(machine_arch_type == MACH_TYPE_TF101)
+#else
+# define machine_is_tf101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SILVIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SILVIO
+# endif
+# define machine_is_omap3silvio()	(machine_arch_type == MACH_TYPE_OMAP3SILVIO)
+#else
+# define machine_is_omap3silvio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO2
+# endif
+# define machine_is_picasso2()	(machine_arch_type == MACH_TYPE_PICASSO2)
+#else
+# define machine_is_picasso2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH2
+# endif
+# define machine_is_vangogh2()	(machine_arch_type == MACH_TYPE_VANGOGH2)
+#else
+# define machine_is_vangogh2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLPC_XO_1_75
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLPC_XO_1_75
+# endif
+# define machine_is_olpc_xo_1_75()	(machine_arch_type == MACH_TYPE_OLPC_XO_1_75)
+#else
+# define machine_is_olpc_xo_1_75()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GX400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GX400
+# endif
+# define machine_is_gx400()	(machine_arch_type == MACH_TYPE_GX400)
+#else
+# define machine_is_gx400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GS300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GS300
+# endif
+# define machine_is_gs300()	(machine_arch_type == MACH_TYPE_GS300)
+#else
+# define machine_is_gs300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A9
+# endif
+# define machine_is_acer_a9()	(machine_arch_type == MACH_TYPE_ACER_A9)
+#else
+# define machine_is_acer_a9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_EVM
+# endif
+# define machine_is_vivow_evm()	(machine_arch_type == MACH_TYPE_VIVOW_EVM)
+#else
+# define machine_is_vivow_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VELOCE_CXQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VELOCE_CXQ
+# endif
+# define machine_is_veloce_cxq()	(machine_arch_type == MACH_TYPE_VELOCE_CXQ)
+#else
+# define machine_is_veloce_cxq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VELOCE_CXM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VELOCE_CXM
+# endif
+# define machine_is_veloce_cxm()	(machine_arch_type == MACH_TYPE_VELOCE_CXM)
+#else
+# define machine_is_veloce_cxm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P1852
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P1852
+# endif
+# define machine_is_p1852()	(machine_arch_type == MACH_TYPE_P1852)
+#else
+# define machine_is_p1852()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY100
+# endif
+# define machine_is_naxy100()	(machine_arch_type == MACH_TYPE_NAXY100)
+#else
+# define machine_is_naxy100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAISHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAISHAN
+# endif
+# define machine_is_taishan()	(machine_arch_type == MACH_TYPE_TAISHAN)
+#else
+# define machine_is_taishan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHLINK
+# endif
+# define machine_is_touchlink()	(machine_arch_type == MACH_TYPE_TOUCHLINK)
+#else
+# define machine_is_touchlink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM32F103ZE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM32F103ZE
+# endif
+# define machine_is_stm32f103ze()	(machine_arch_type == MACH_TYPE_STM32F103ZE)
+#else
+# define machine_is_stm32f103ze()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCX
+# endif
+# define machine_is_mcx()	(machine_arch_type == MACH_TYPE_MCX)
+#else
+# define machine_is_mcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM_NMHDK_FLI7610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM_NMHDK_FLI7610
+# endif
+# define machine_is_stm_nmhdk_fli7610()	(machine_arch_type == MACH_TYPE_STM_NMHDK_FLI7610)
+#else
+# define machine_is_stm_nmhdk_fli7610()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP28X
+# endif
+# define machine_is_top28x()	(machine_arch_type == MACH_TYPE_TOP28X)
+#else
+# define machine_is_top28x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OKL4VP_MICROVISOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OKL4VP_MICROVISOR
+# endif
+# define machine_is_okl4vp_microvisor()	(machine_arch_type == MACH_TYPE_OKL4VP_MICROVISOR)
+#else
+# define machine_is_okl4vp_microvisor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POP
+# endif
+# define machine_is_pop()	(machine_arch_type == MACH_TYPE_POP)
+#else
+# define machine_is_pop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAYER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAYER
+# endif
+# define machine_is_layer()	(machine_arch_type == MACH_TYPE_LAYER)
+#else
+# define machine_is_layer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRONDHEIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRONDHEIM
+# endif
+# define machine_is_trondheim()	(machine_arch_type == MACH_TYPE_TRONDHEIM)
+#else
+# define machine_is_trondheim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA
+# endif
+# define machine_is_eva()	(machine_arch_type == MACH_TYPE_EVA)
+#else
+# define machine_is_eva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRUST_TAURUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRUST_TAURUS
+# endif
+# define machine_is_trust_taurus()	(machine_arch_type == MACH_TYPE_TRUST_TAURUS)
+#else
+# define machine_is_trust_taurus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_HUASHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_HUASHAN
+# endif
+# define machine_is_ns2816_huashan()	(machine_arch_type == MACH_TYPE_NS2816_HUASHAN)
+#else
+# define machine_is_ns2816_huashan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_YANGCHENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_YANGCHENG
+# endif
+# define machine_is_ns2816_yangcheng()	(machine_arch_type == MACH_TYPE_NS2816_YANGCHENG)
+#else
+# define machine_is_ns2816_yangcheng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P852
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P852
+# endif
+# define machine_is_p852()	(machine_arch_type == MACH_TYPE_P852)
+#else
+# define machine_is_p852()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEA3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEA3
+# endif
+# define machine_is_flea3()	(machine_arch_type == MACH_TYPE_FLEA3)
+#else
+# define machine_is_flea3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOWFIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOWFIN
+# endif
+# define machine_is_bowfin()	(machine_arch_type == MACH_TYPE_BOWFIN)
+#else
+# define machine_is_bowfin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88DE3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88DE3100
+# endif
+# define machine_is_mv88de3100()	(machine_arch_type == MACH_TYPE_MV88DE3100)
+#else
+# define machine_is_mv88de3100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIA_AM35X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIA_AM35X
+# endif
+# define machine_is_pia_am35x()	(machine_arch_type == MACH_TYPE_PIA_AM35X)
+#else
+# define machine_is_pia_am35x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEDAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEDAR
+# endif
+# define machine_is_cedar()	(machine_arch_type == MACH_TYPE_CEDAR)
+#else
+# define machine_is_cedar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO_E
+# endif
+# define machine_is_picasso_e()	(machine_arch_type == MACH_TYPE_PICASSO_E)
+#else
+# define machine_is_picasso_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSUNG_E60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSUNG_E60
+# endif
+# define machine_is_samsung_e60()	(machine_arch_type == MACH_TYPE_SAMSUNG_E60)
+#else
+# define machine_is_samsung_e60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM9615_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM9615_CDP
+# endif
+# define machine_is_msm9615_cdp()	(machine_arch_type == MACH_TYPE_MSM9615_CDP)
+#else
+# define machine_is_msm9615_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR_MINI
+# endif
+# define machine_is_sdvr_mini()	(machine_arch_type == MACH_TYPE_SDVR_MINI)
+#else
+# define machine_is_sdvr_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_IJ3K
+# endif
+# define machine_is_omap3_ij3k()	(machine_arch_type == MACH_TYPE_OMAP3_IJ3K)
+#else
+# define machine_is_omap3_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MODASMC1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MODASMC1
+# endif
+# define machine_is_modasmc1()	(machine_arch_type == MACH_TYPE_MODASMC1)
+#else
+# define machine_is_modasmc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_RUMI3
+# endif
+# define machine_is_apq8064_rumi3()	(machine_arch_type == MACH_TYPE_APQ8064_RUMI3)
+#else
+# define machine_is_apq8064_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX506
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX506
+# endif
+# define machine_is_matrix506()	(machine_arch_type == MACH_TYPE_MATRIX506)
+#else
+# define machine_is_matrix506()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM9615_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM9615_MTP
+# endif
+# define machine_is_msm9615_mtp()	(machine_arch_type == MACH_TYPE_MSM9615_MTP)
+#else
+# define machine_is_msm9615_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM36X_SPAWNDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM36X_SPAWNDC
+# endif
+# define machine_is_dm36x_spawndc()	(machine_arch_type == MACH_TYPE_DM36X_SPAWNDC)
+#else
+# define machine_is_dm36x_spawndc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFF792
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFF792
+# endif
+# define machine_is_sff792()	(machine_arch_type == MACH_TYPE_SFF792)
+#else
+# define machine_is_sff792()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM335XIAEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM335XIAEVM
+# endif
+# define machine_is_am335xiaevm()	(machine_arch_type == MACH_TYPE_AM335XIAEVM)
+#else
+# define machine_is_am335xiaevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3C2440
+# endif
+# define machine_is_g3c2440()	(machine_arch_type == MACH_TYPE_G3C2440)
+#else
+# define machine_is_g3c2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TION270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TION270
+# endif
+# define machine_is_tion270()	(machine_arch_type == MACH_TYPE_TION270)
+#else
+# define machine_is_tion270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W22Q7ARM02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W22Q7ARM02
+# endif
+# define machine_is_w22q7arm02()	(machine_arch_type == MACH_TYPE_W22Q7ARM02)
+#else
+# define machine_is_w22q7arm02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_CAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_CAT
+# endif
+# define machine_is_omap_cat()	(machine_arch_type == MACH_TYPE_OMAP_CAT)
+#else
+# define machine_is_omap_cat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9N12EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9N12EK
+# endif
+# define machine_is_at91sam9n12ek()	(machine_arch_type == MACH_TYPE_AT91SAM9N12EK)
+#else
+# define machine_is_at91sam9n12ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORRISON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORRISON
+# endif
+# define machine_is_morrison()	(machine_arch_type == MACH_TYPE_MORRISON)
+#else
+# define machine_is_morrison()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVDU
+# endif
+# define machine_is_svdu()	(machine_arch_type == MACH_TYPE_SVDU)
+#else
+# define machine_is_svdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPP01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPP01
+# endif
+# define machine_is_lpp01()	(machine_arch_type == MACH_TYPE_LPP01)
+#else
+# define machine_is_lpp01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBC283
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBC283
+# endif
+# define machine_is_ubc283()	(machine_arch_type == MACH_TYPE_UBC283)
+#else
+# define machine_is_ubc283()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEPPELIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEPPELIN
+# endif
+# define machine_is_zeppelin()	(machine_arch_type == MACH_TYPE_ZEPPELIN)
+#else
+# define machine_is_zeppelin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTUS
+# endif
+# define machine_is_motus()	(machine_arch_type == MACH_TYPE_MOTUS)
+#else
+# define machine_is_motus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOMAINBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOMAINBOARD
+# endif
+# define machine_is_neomainboard()	(machine_arch_type == MACH_TYPE_NEOMAINBOARD)
+#else
+# define machine_is_neomainboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT3250
+# endif
+# define machine_is_devkit3250()	(machine_arch_type == MACH_TYPE_DEVKIT3250)
+#else
+# define machine_is_devkit3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT7000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT7000
+# endif
+# define machine_is_devkit7000()	(machine_arch_type == MACH_TYPE_DEVKIT7000)
+#else
+# define machine_is_devkit7000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMC_UIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMC_UIC
+# endif
+# define machine_is_fmc_uic()	(machine_arch_type == MACH_TYPE_FMC_UIC)
+#else
+# define machine_is_fmc_uic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMC_DCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMC_DCM
+# endif
+# define machine_is_fmc_dcm()	(machine_arch_type == MACH_TYPE_FMC_DCM)
+#else
+# define machine_is_fmc_dcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATWM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATWM
+# endif
+# define machine_is_batwm()	(machine_arch_type == MACH_TYPE_BATWM)
+#else
+# define machine_is_batwm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS6CB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS6CB
+# endif
+# define machine_is_atlas6cb()	(machine_arch_type == MACH_TYPE_ATLAS6CB)
+#else
+# define machine_is_atlas6cb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE
+# endif
+# define machine_is_blue()	(machine_arch_type == MACH_TYPE_BLUE)
+#else
+# define machine_is_blue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLORADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLORADO
+# endif
+# define machine_is_colorado()	(machine_arch_type == MACH_TYPE_COLORADO)
+#else
+# define machine_is_colorado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POPC
+# endif
+# define machine_is_popc()	(machine_arch_type == MACH_TYPE_POPC)
+#else
+# define machine_is_popc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PROMWAD_JADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PROMWAD_JADE
+# endif
+# define machine_is_promwad_jade()	(machine_arch_type == MACH_TYPE_PROMWAD_JADE)
+#else
+# define machine_is_promwad_jade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMP
+# endif
+# define machine_is_amp()	(machine_arch_type == MACH_TYPE_AMP)
+#else
+# define machine_is_amp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_AMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_AMP
+# endif
+# define machine_is_gnet_amp()	(machine_arch_type == MACH_TYPE_GNET_AMP)
+#else
+# define machine_is_gnet_amp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOQUES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOQUES
+# endif
+# define machine_is_toques()	(machine_arch_type == MACH_TYPE_TOQUES)
+#else
+# define machine_is_toques()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCT_STORM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCT_STORM
+# endif
+# define machine_is_dct_storm()	(machine_arch_type == MACH_TYPE_DCT_STORM)
+#else
+# define machine_is_dct_storm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OWL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OWL
+# endif
+# define machine_is_owl()	(machine_arch_type == MACH_TYPE_OWL)
+#else
+# define machine_is_owl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COGENT_CSB1741
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT_CSB1741
+# endif
+# define machine_is_cogent_csb1741()	(machine_arch_type == MACH_TYPE_COGENT_CSB1741)
+#else
+# define machine_is_cogent_csb1741()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADILLUSTRA610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADILLUSTRA610
+# endif
+# define machine_is_adillustra610()	(machine_arch_type == MACH_TYPE_ADILLUSTRA610)
+#else
+# define machine_is_adillustra610()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECAFE_NA04
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECAFE_NA04
+# endif
+# define machine_is_ecafe_na04()	(machine_arch_type == MACH_TYPE_ECAFE_NA04)
+#else
+# define machine_is_ecafe_na04()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POPCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POPCT
+# endif
+# define machine_is_popct()	(machine_arch_type == MACH_TYPE_POPCT)
+#else
+# define machine_is_popct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_HELENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_HELENA
+# endif
+# define machine_is_omap3_helena()	(machine_arch_type == MACH_TYPE_OMAP3_HELENA)
+#else
+# define machine_is_omap3_helena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACH
+# endif
+# define machine_is_ach()	(machine_arch_type == MACH_TYPE_ACH)
+#else
+# define machine_is_ach()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MODULE_DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MODULE_DTB
+# endif
+# define machine_is_module_dtb()	(machine_arch_type == MACH_TYPE_MODULE_DTB)
+#else
+# define machine_is_module_dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_ELISABETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_ELISABETH
+# endif
+# define machine_is_oslo_elisabeth()	(machine_arch_type == MACH_TYPE_OSLO_ELISABETH)
+#else
+# define machine_is_oslo_elisabeth()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT01
+# endif
+# define machine_is_tt01()	(machine_arch_type == MACH_TYPE_TT01)
+#else
+# define machine_is_tt01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_CDP
+# endif
+# define machine_is_msm8930_cdp()	(machine_arch_type == MACH_TYPE_MSM8930_CDP)
+#else
+# define machine_is_msm8930_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_MTP
+# endif
+# define machine_is_msm8930_mtp()	(machine_arch_type == MACH_TYPE_MSM8930_MTP)
+#else
+# define machine_is_msm8930_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8930_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8930_FLUID
+# endif
+# define machine_is_msm8930_fluid()	(machine_arch_type == MACH_TYPE_MSM8930_FLUID)
+#else
+# define machine_is_msm8930_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LTU11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LTU11
+# endif
+# define machine_is_ltu11()	(machine_arch_type == MACH_TYPE_LTU11)
+#else
+# define machine_is_ltu11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM1808_SPAWNCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM1808_SPAWNCO
+# endif
+# define machine_is_am1808_spawnco()	(machine_arch_type == MACH_TYPE_AM1808_SPAWNCO)
+#else
+# define machine_is_am1808_spawnco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLX6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLX6410
+# endif
+# define machine_is_flx6410()	(machine_arch_type == MACH_TYPE_FLX6410)
+#else
+# define machine_is_flx6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_QSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_QSB
+# endif
+# define machine_is_mx6q_qsb()	(machine_arch_type == MACH_TYPE_MX6Q_QSB)
+#else
+# define machine_is_mx6q_qsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_PLT424
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_PLT424
+# endif
+# define machine_is_mx53_plt424()	(machine_arch_type == MACH_TYPE_MX53_PLT424)
+#else
+# define machine_is_mx53_plt424()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JASMINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASMINE
+# endif
+# define machine_is_jasmine()	(machine_arch_type == MACH_TYPE_JASMINE)
+#else
+# define machine_is_jasmine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L138_OWLBOARD_PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L138_OWLBOARD_PLUS
+# endif
+# define machine_is_l138_owlboard_plus()	(machine_arch_type == MACH_TYPE_L138_OWLBOARD_PLUS)
+#else
+# define machine_is_l138_owlboard_plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WR21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WR21
+# endif
+# define machine_is_wr21()	(machine_arch_type == MACH_TYPE_WR21)
+#else
+# define machine_is_wr21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEABOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEABOY
+# endif
+# define machine_is_peaboy()	(machine_arch_type == MACH_TYPE_PEABOY)
+#else
+# define machine_is_peaboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28_PLATO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28_PLATO
+# endif
+# define machine_is_mx28_plato()	(machine_arch_type == MACH_TYPE_MX28_PLATO)
+#else
+# define machine_is_mx28_plato()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM2
+# endif
+# define machine_is_kacom2()	(machine_arch_type == MACH_TYPE_KACOM2)
+#else
+# define machine_is_kacom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLCO
+# endif
+# define machine_is_slco()	(machine_arch_type == MACH_TYPE_SLCO)
+#else
+# define machine_is_slco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX51PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX51PICO
+# endif
+# define machine_is_imx51pico()	(machine_arch_type == MACH_TYPE_IMX51PICO)
+#else
+# define machine_is_imx51pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLINK1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLINK1
+# endif
+# define machine_is_glink1()	(machine_arch_type == MACH_TYPE_GLINK1)
+#else
+# define machine_is_glink1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIAMOND
+# endif
+# define machine_is_diamond()	(machine_arch_type == MACH_TYPE_DIAMOND)
+#else
+# define machine_is_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D9000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D9000
+# endif
+# define machine_is_d9000()	(machine_arch_type == MACH_TYPE_D9000)
+#else
+# define machine_is_d9000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W5300E01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W5300E01
+# endif
+# define machine_is_w5300e01()	(machine_arch_type == MACH_TYPE_W5300E01)
+#else
+# define machine_is_w5300e01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM6000
+# endif
+# define machine_is_im6000()	(machine_arch_type == MACH_TYPE_IM6000)
+#else
+# define machine_is_im6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_FRED51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_FRED51
+# endif
+# define machine_is_mx51_fred51()	(machine_arch_type == MACH_TYPE_MX51_FRED51)
+#else
+# define machine_is_mx51_fred51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM32F2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM32F2
+# endif
+# define machine_is_stm32f2()	(machine_arch_type == MACH_TYPE_STM32F2)
+#else
+# define machine_is_stm32f2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VILLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VILLE
+# endif
+# define machine_is_ville()	(machine_arch_type == MACH_TYPE_VILLE)
+#else
+# define machine_is_ville()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTIP_MURNAU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTIP_MURNAU
+# endif
+# define machine_is_ptip_murnau()	(machine_arch_type == MACH_TYPE_PTIP_MURNAU)
+#else
+# define machine_is_ptip_murnau()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTIP_CLASSIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTIP_CLASSIC
+# endif
+# define machine_is_ptip_classic()	(machine_arch_type == MACH_TYPE_PTIP_CLASSIC)
+#else
+# define machine_is_ptip_classic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53GRB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53GRB
+# endif
+# define machine_is_mx53grb()	(machine_arch_type == MACH_TYPE_MX53GRB)
+#else
+# define machine_is_mx53grb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GAGARIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GAGARIN
+# endif
+# define machine_is_gagarin()	(machine_arch_type == MACH_TYPE_GAGARIN)
+#else
+# define machine_is_gagarin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_QRD1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_QRD1
+# endif
+# define machine_is_msm7627a_qrd1()	(machine_arch_type == MACH_TYPE_MSM7627A_QRD1)
+#else
+# define machine_is_msm7627a_qrd1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS2BIG
+# endif
+# define machine_is_nas2big()	(machine_arch_type == MACH_TYPE_NAS2BIG)
+#else
+# define machine_is_nas2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUPERFEMTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUPERFEMTO
+# endif
+# define machine_is_superfemto()	(machine_arch_type == MACH_TYPE_SUPERFEMTO)
+#else
+# define machine_is_superfemto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEUFEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEUFEL
+# endif
+# define machine_is_teufel()	(machine_arch_type == MACH_TYPE_TEUFEL)
+#else
+# define machine_is_teufel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINARA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINARA
+# endif
+# define machine_is_dinara()	(machine_arch_type == MACH_TYPE_DINARA)
+#else
+# define machine_is_dinara()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANQUISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANQUISH
+# endif
+# define machine_is_vanquish()	(machine_arch_type == MACH_TYPE_VANQUISH)
+#else
+# define machine_is_vanquish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPABOX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPABOX1
+# endif
+# define machine_is_zipabox1()	(machine_arch_type == MACH_TYPE_ZIPABOX1)
+#else
+# define machine_is_zipabox1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U9540
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U9540
+# endif
+# define machine_is_u9540()	(machine_arch_type == MACH_TYPE_U9540)
+#else
+# define machine_is_u9540()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JET
+# endif
+# define machine_is_jet()	(machine_arch_type == MACH_TYPE_JET)
+#else
+# define machine_is_jet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4412
+# endif
+# define machine_is_smdk4412()	(machine_arch_type == MACH_TYPE_SMDK4412)
+#else
+# define machine_is_smdk4412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELITE
+# endif
+# define machine_is_elite()	(machine_arch_type == MACH_TYPE_ELITE)
+#else
+# define machine_is_elite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320_HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320_HMI
+# endif
+# define machine_is_spear320_hmi()	(machine_arch_type == MACH_TYPE_SPEAR320_HMI)
+#else
+# define machine_is_spear320_hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTARIO
+# endif
+# define machine_is_ontario()	(machine_arch_type == MACH_TYPE_ONTARIO)
+#else
+# define machine_is_ontario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_SABRELITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_SABRELITE
+# endif
+# define machine_is_mx6q_sabrelite()	(machine_arch_type == MACH_TYPE_MX6Q_SABRELITE)
+#else
+# define machine_is_mx6q_sabrelite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC200
+# endif
+# define machine_is_vc200()	(machine_arch_type == MACH_TYPE_VC200)
+#else
+# define machine_is_vc200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7625A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7625A_FFA
+# endif
+# define machine_is_msm7625a_ffa()	(machine_arch_type == MACH_TYPE_MSM7625A_FFA)
+#else
+# define machine_is_msm7625a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7625A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7625A_SURF
+# endif
+# define machine_is_msm7625a_surf()	(machine_arch_type == MACH_TYPE_MSM7625A_SURF)
+#else
+# define machine_is_msm7625a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENTHOSSBP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENTHOSSBP
+# endif
+# define machine_is_benthossbp()	(machine_arch_type == MACH_TYPE_BENTHOSSBP)
+#else
+# define machine_is_benthossbp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5210
+# endif
+# define machine_is_smdk5210()	(machine_arch_type == MACH_TYPE_SMDK5210)
+#else
+# define machine_is_smdk5210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPQ2300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPQ2300
+# endif
+# define machine_is_empq2300()	(machine_arch_type == MACH_TYPE_EMPQ2300)
+#else
+# define machine_is_empq2300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIPOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPOS
+# endif
+# define machine_is_minipos()	(machine_arch_type == MACH_TYPE_MINIPOS)
+#else
+# define machine_is_minipos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP5_SEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP5_SEVM
+# endif
+# define machine_is_omap5_sevm()	(machine_arch_type == MACH_TYPE_OMAP5_SEVM)
+#else
+# define machine_is_omap5_sevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHELTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHELTER
+# endif
+# define machine_is_shelter()	(machine_arch_type == MACH_TYPE_SHELTER)
+#else
+# define machine_is_shelter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_DEVKIT8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_DEVKIT8500
+# endif
+# define machine_is_omap3_devkit8500()	(machine_arch_type == MACH_TYPE_OMAP3_DEVKIT8500)
+#else
+# define machine_is_omap3_devkit8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGETD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGETD
+# endif
+# define machine_is_edgetd()	(machine_arch_type == MACH_TYPE_EDGETD)
+#else
+# define machine_is_edgetd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COPPERYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COPPERYARD
+# endif
+# define machine_is_copperyard()	(machine_arch_type == MACH_TYPE_COPPERYARD)
+#else
+# define machine_is_copperyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE
+# endif
+# define machine_is_edge()	(machine_arch_type == MACH_TYPE_EDGE)
+#else
+# define machine_is_edge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE_U
+# endif
+# define machine_is_edge_u()	(machine_arch_type == MACH_TYPE_EDGE_U)
+#else
+# define machine_is_edge_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGE_TD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGE_TD
+# endif
+# define machine_is_edge_td()	(machine_arch_type == MACH_TYPE_EDGE_TD)
+#else
+# define machine_is_edge_td()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WDSS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WDSS
+# endif
+# define machine_is_wdss()	(machine_arch_type == MACH_TYPE_WDSS)
+#else
+# define machine_is_wdss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DL_PB25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DL_PB25
+# endif
+# define machine_is_dl_pb25()	(machine_arch_type == MACH_TYPE_DL_PB25)
+#else
+# define machine_is_dl_pb25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSS11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSS11
+# endif
+# define machine_is_dss11()	(machine_arch_type == MACH_TYPE_DSS11)
+#else
+# define machine_is_dss11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPA
+# endif
+# define machine_is_cpa()	(machine_arch_type == MACH_TYPE_CPA)
+#else
+# define machine_is_cpa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APTP2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APTP2000
+# endif
+# define machine_is_aptp2000()	(machine_arch_type == MACH_TYPE_APTP2000)
+#else
+# define machine_is_aptp2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARZEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARZEN
+# endif
+# define machine_is_marzen()	(machine_arch_type == MACH_TYPE_MARZEN)
+#else
+# define machine_is_marzen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ST_TURBINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ST_TURBINE
+# endif
+# define machine_is_st_turbine()	(machine_arch_type == MACH_TYPE_ST_TURBINE)
+#else
+# define machine_is_st_turbine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTL_IT3300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTL_IT3300
+# endif
+# define machine_is_gtl_it3300()	(machine_arch_type == MACH_TYPE_GTL_IT3300)
+#else
+# define machine_is_gtl_it3300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6_MULE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6_MULE
+# endif
+# define machine_is_mx6_mule()	(machine_arch_type == MACH_TYPE_MX6_MULE)
+#else
+# define machine_is_mx6_mule()	(0)
+#endif
+
+#ifdef CONFIG_MACH_V7PXA_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_V7PXA_DT
+# endif
+# define machine_is_v7pxa_dt()	(machine_arch_type == MACH_TYPE_V7PXA_DT)
+#else
+# define machine_is_v7pxa_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_V7MMP_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_V7MMP_DT
+# endif
+# define machine_is_v7mmp_dt()	(machine_arch_type == MACH_TYPE_V7MMP_DT)
+#else
+# define machine_is_v7mmp_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON7
+# endif
+# define machine_is_dragon7()	(machine_arch_type == MACH_TYPE_DRAGON7)
+#else
+# define machine_is_dragon7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KROME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KROME
+# endif
+# define machine_is_krome()	(machine_arch_type == MACH_TYPE_KROME)
+#else
+# define machine_is_krome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISDANTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISDANTE
+# endif
+# define machine_is_oratisdante()	(machine_arch_type == MACH_TYPE_ORATISDANTE)
+#else
+# define machine_is_oratisdante()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FATHOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FATHOM
+# endif
+# define machine_is_fathom()	(machine_arch_type == MACH_TYPE_FATHOM)
+#else
+# define machine_is_fathom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS325
+# endif
+# define machine_is_dns325()	(machine_arch_type == MACH_TYPE_DNS325)
+#else
+# define machine_is_dns325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SARNEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SARNEN
+# endif
+# define machine_is_sarnen()	(machine_arch_type == MACH_TYPE_SARNEN)
+#else
+# define machine_is_sarnen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_G1
+# endif
+# define machine_is_ubisys_g1()	(machine_arch_type == MACH_TYPE_UBISYS_G1)
+#else
+# define machine_is_ubisys_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_PF1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_PF1
+# endif
+# define machine_is_mx53_pf1()	(machine_arch_type == MACH_TYPE_MX53_PF1)
+#else
+# define machine_is_mx53_pf1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASANTI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASANTI
+# endif
+# define machine_is_asanti()	(machine_arch_type == MACH_TYPE_ASANTI)
+#else
+# define machine_is_asanti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOLTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOLTA
+# endif
+# define machine_is_volta()	(machine_arch_type == MACH_TYPE_VOLTA)
+#else
+# define machine_is_volta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KNIGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KNIGHT
+# endif
+# define machine_is_knight()	(machine_arch_type == MACH_TYPE_KNIGHT)
+#else
+# define machine_is_knight()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEAGLEBONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEAGLEBONE
+# endif
+# define machine_is_beaglebone()	(machine_arch_type == MACH_TYPE_BEAGLEBONE)
+#else
+# define machine_is_beaglebone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BECKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BECKER
+# endif
+# define machine_is_becker()	(machine_arch_type == MACH_TYPE_BECKER)
+#else
+# define machine_is_becker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FC360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FC360
+# endif
+# define machine_is_fc360()	(machine_arch_type == MACH_TYPE_FC360)
+#else
+# define machine_is_fc360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PMI2_XLS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PMI2_XLS
+# endif
+# define machine_is_pmi2_xls()	(machine_arch_type == MACH_TYPE_PMI2_XLS)
+#else
+# define machine_is_pmi2_xls()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TARANTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARANTO
+# endif
+# define machine_is_taranto()	(machine_arch_type == MACH_TYPE_TARANTO)
+#else
+# define machine_is_taranto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLUTUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLUTUX
+# endif
+# define machine_is_plutux()	(machine_arch_type == MACH_TYPE_PLUTUX)
+#else
+# define machine_is_plutux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPMP_MEDCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPMP_MEDCOM
+# endif
+# define machine_is_ipmp_medcom()	(machine_arch_type == MACH_TYPE_IPMP_MEDCOM)
+#else
+# define machine_is_ipmp_medcom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABSOLUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABSOLUT
+# endif
+# define machine_is_absolut()	(machine_arch_type == MACH_TYPE_ABSOLUT)
+#else
+# define machine_is_absolut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWPB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWPB3
+# endif
+# define machine_is_awpb3()	(machine_arch_type == MACH_TYPE_AWPB3)
+#else
+# define machine_is_awpb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NFP32XX_DT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NFP32XX_DT
+# endif
+# define machine_is_nfp32xx_dt()	(machine_arch_type == MACH_TYPE_NFP32XX_DT)
+#else
+# define machine_is_nfp32xx_dt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DL_PB53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DL_PB53
+# endif
+# define machine_is_dl_pb53()	(machine_arch_type == MACH_TYPE_DL_PB53)
+#else
+# define machine_is_dl_pb53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACU_II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACU_II
+# endif
+# define machine_is_acu_ii()	(machine_arch_type == MACH_TYPE_ACU_II)
+#else
+# define machine_is_acu_ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVALON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVALON
+# endif
+# define machine_is_avalon()	(machine_arch_type == MACH_TYPE_AVALON)
+#else
+# define machine_is_avalon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPHINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPHINX
+# endif
+# define machine_is_sphinx()	(machine_arch_type == MACH_TYPE_SPHINX)
+#else
+# define machine_is_sphinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TITAN_T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TITAN_T
+# endif
+# define machine_is_titan_t()	(machine_arch_type == MACH_TYPE_TITAN_T)
+#else
+# define machine_is_titan_t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARVEST_BORIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARVEST_BORIS
+# endif
+# define machine_is_harvest_boris()	(machine_arch_type == MACH_TYPE_HARVEST_BORIS)
+#else
+# define machine_is_harvest_boris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_MSM7X30_M3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_MSM7X30_M3S
+# endif
+# define machine_is_mach_msm7x30_m3s()	(machine_arch_type == MACH_TYPE_MACH_MSM7X30_M3S)
+#else
+# define machine_is_mach_msm7x30_m3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5250
+# endif
+# define machine_is_smdk5250()	(machine_arch_type == MACH_TYPE_SMDK5250)
+#else
+# define machine_is_smdk5250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_LITE
+# endif
+# define machine_is_imxt_lite()	(machine_arch_type == MACH_TYPE_IMXT_LITE)
+#else
+# define machine_is_imxt_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_STD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_STD
+# endif
+# define machine_is_imxt_std()	(machine_arch_type == MACH_TYPE_IMXT_STD)
+#else
+# define machine_is_imxt_std()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_LOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_LOG
+# endif
+# define machine_is_imxt_log()	(machine_arch_type == MACH_TYPE_IMXT_LOG)
+#else
+# define machine_is_imxt_log()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_NAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_NAV
+# endif
+# define machine_is_imxt_nav()	(machine_arch_type == MACH_TYPE_IMXT_NAV)
+#else
+# define machine_is_imxt_nav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMXT_FULL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMXT_FULL
+# endif
+# define machine_is_imxt_full()	(machine_arch_type == MACH_TYPE_IMXT_FULL)
+#else
+# define machine_is_imxt_full()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG09015
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG09015
+# endif
+# define machine_is_ag09015()	(machine_arch_type == MACH_TYPE_AG09015)
+#else
+# define machine_is_ag09015()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM3517_MT_VENTOUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM3517_MT_VENTOUX
+# endif
+# define machine_is_am3517_mt_ventoux()	(machine_arch_type == MACH_TYPE_AM3517_MT_VENTOUX)
+#else
+# define machine_is_am3517_mt_ventoux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1ARM9
+# endif
+# define machine_is_dp1arm9()	(machine_arch_type == MACH_TYPE_DP1ARM9)
+#else
+# define machine_is_dp1arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO_M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO_M
+# endif
+# define machine_is_picasso_m()	(machine_arch_type == MACH_TYPE_PICASSO_M)
+#else
+# define machine_is_picasso_m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIDEO_GADGET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIDEO_GADGET
+# endif
+# define machine_is_video_gadget()	(machine_arch_type == MACH_TYPE_VIDEO_GADGET)
+#else
+# define machine_is_video_gadget()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_OM3X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_OM3X
+# endif
+# define machine_is_mtt_om3x()	(machine_arch_type == MACH_TYPE_MTT_OM3X)
+#else
+# define machine_is_mtt_om3x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX6Q_ARM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX6Q_ARM2
+# endif
+# define machine_is_mx6q_arm2()	(machine_arch_type == MACH_TYPE_MX6Q_ARM2)
+#else
+# define machine_is_mx6q_arm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOSAM9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOSAM9G45
+# endif
+# define machine_is_picosam9g45()	(machine_arch_type == MACH_TYPE_PICOSAM9G45)
+#else
+# define machine_is_picosam9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPM_DM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPM_DM365
+# endif
+# define machine_is_vpm_dm365()	(machine_arch_type == MACH_TYPE_VPM_DM365)
+#else
+# define machine_is_vpm_dm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONFIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONFIRE
+# endif
+# define machine_is_bonfire()	(machine_arch_type == MACH_TYPE_BONFIRE)
+#else
+# define machine_is_bonfire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT2P2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT2P2D
+# endif
+# define machine_is_mt2p2d()	(machine_arch_type == MACH_TYPE_MT2P2D)
+#else
+# define machine_is_mt2p2d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGPDA01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGPDA01
+# endif
+# define machine_is_sigpda01()	(machine_arch_type == MACH_TYPE_SIGPDA01)
+#else
+# define machine_is_sigpda01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CN27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CN27
+# endif
+# define machine_is_cn27()	(machine_arch_type == MACH_TYPE_CN27)
+#else
+# define machine_is_cn27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_CWTAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_CWTAP
+# endif
+# define machine_is_mx25_cwtap()	(machine_arch_type == MACH_TYPE_MX25_CWTAP)
+#else
+# define machine_is_mx25_cwtap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF28
+# endif
+# define machine_is_apf28()	(machine_arch_type == MACH_TYPE_APF28)
+#else
+# define machine_is_apf28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MAXWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MAXWELL
+# endif
+# define machine_is_pelco_maxwell()	(machine_arch_type == MACH_TYPE_PELCO_MAXWELL)
+#else
+# define machine_is_pelco_maxwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GE_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GE_PHOENIX
+# endif
+# define machine_is_ge_phoenix()	(machine_arch_type == MACH_TYPE_GE_PHOENIX)
+#else
+# define machine_is_ge_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC_A500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC_A500
+# endif
+# define machine_is_empc_a500()	(machine_arch_type == MACH_TYPE_EMPC_A500)
+#else
+# define machine_is_empc_a500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMS_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMS_ARM9
+# endif
+# define machine_is_ims_arm9()	(machine_arch_type == MACH_TYPE_IMS_ARM9)
+#else
+# define machine_is_ims_arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2416
+# endif
+# define machine_is_mini2416()	(machine_arch_type == MACH_TYPE_MINI2416)
+#else
+# define machine_is_mini2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2450
+# endif
+# define machine_is_mini2450()	(machine_arch_type == MACH_TYPE_MINI2450)
+#else
+# define machine_is_mini2450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI310
+# endif
+# define machine_is_mini310()	(machine_arch_type == MACH_TYPE_MINI310)
+#else
+# define machine_is_mini310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR_HURRICANE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR_HURRICANE
+# endif
+# define machine_is_spear_hurricane()	(machine_arch_type == MACH_TYPE_SPEAR_HURRICANE)
+#else
+# define machine_is_spear_hurricane()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT7208
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT7208
+# endif
+# define machine_is_mt7208()	(machine_arch_type == MACH_TYPE_MT7208)
+#else
+# define machine_is_mt7208()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC178X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC178X
+# endif
+# define machine_is_lpc178x()	(machine_arch_type == MACH_TYPE_LPC178X)
+#else
+# define machine_is_lpc178x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARLEYS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARLEYS
+# endif
+# define machine_is_farleys()	(machine_arch_type == MACH_TYPE_FARLEYS)
+#else
+# define machine_is_farleys()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFM32GG_DK3750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFM32GG_DK3750
+# endif
+# define machine_is_efm32gg_dk3750()	(machine_arch_type == MACH_TYPE_EFM32GG_DK3750)
+#else
+# define machine_is_efm32gg_dk3750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEUS_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEUS_BOARD
+# endif
+# define machine_is_zeus_board()	(machine_arch_type == MACH_TYPE_ZEUS_BOARD)
+#else
+# define machine_is_zeus_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC51
+# endif
+# define machine_is_cc51()	(machine_arch_type == MACH_TYPE_CC51)
+#else
+# define machine_is_cc51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FXI_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FXI_C210
+# endif
+# define machine_is_fxi_c210()	(machine_arch_type == MACH_TYPE_FXI_C210)
+#else
+# define machine_is_fxi_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8627_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8627_CDP
+# endif
+# define machine_is_msm8627_cdp()	(machine_arch_type == MACH_TYPE_MSM8627_CDP)
+#else
+# define machine_is_msm8627_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8627_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8627_MTP
+# endif
+# define machine_is_msm8627_mtp()	(machine_arch_type == MACH_TYPE_MSM8627_MTP)
+#else
+# define machine_is_msm8627_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO800EVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO800EVA
+# endif
+# define machine_is_armadillo800eva()	(machine_arch_type == MACH_TYPE_ARMADILLO800EVA)
+#else
+# define machine_is_armadillo800eva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOU
+# endif
+# define machine_is_primou()	(machine_arch_type == MACH_TYPE_PRIMOU)
+#else
+# define machine_is_primou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOC
+# endif
+# define machine_is_primoc()	(machine_arch_type == MACH_TYPE_PRIMOC)
+#else
+# define machine_is_primoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMOCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMOCT
+# endif
+# define machine_is_primoct()	(machine_arch_type == MACH_TYPE_PRIMOCT)
+#else
+# define machine_is_primoct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9500
+# endif
+# define machine_is_a9500()	(machine_arch_type == MACH_TYPE_A9500)
+#else
+# define machine_is_a9500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLUTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLUTO
+# endif
+# define machine_is_pluto()	(machine_arch_type == MACH_TYPE_PLUTO)
+#else
+# define machine_is_pluto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACFX100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACFX100
+# endif
+# define machine_is_acfx100()	(machine_arch_type == MACH_TYPE_ACFX100)
+#else
+# define machine_is_acfx100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_RUMI3
+# endif
+# define machine_is_msm8625_rumi3()	(machine_arch_type == MACH_TYPE_MSM8625_RUMI3)
+#else
+# define machine_is_msm8625_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALENTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALENTE
+# endif
+# define machine_is_valente()	(machine_arch_type == MACH_TYPE_VALENTE)
+#else
+# define machine_is_valente()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRFS_RFEYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRFS_RFEYE
+# endif
+# define machine_is_crfs_rfeye()	(machine_arch_type == MACH_TYPE_CRFS_RFEYE)
+#else
+# define machine_is_crfs_rfeye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFEYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFEYE
+# endif
+# define machine_is_rfeye()	(machine_arch_type == MACH_TYPE_RFEYE)
+#else
+# define machine_is_rfeye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC3
+# endif
+# define machine_is_phidget_sbc3()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC3)
+#else
+# define machine_is_phidget_sbc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCW_MIKA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCW_MIKA
+# endif
+# define machine_is_tcw_mika()	(machine_arch_type == MACH_TYPE_TCW_MIKA)
+#else
+# define machine_is_tcw_mika()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX28_EGF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX28_EGF
+# endif
+# define machine_is_imx28_egf()	(machine_arch_type == MACH_TYPE_IMX28_EGF)
+#else
+# define machine_is_imx28_egf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALENTE_WX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALENTE_WX
+# endif
+# define machine_is_valente_wx()	(machine_arch_type == MACH_TYPE_VALENTE_WX)
+#else
+# define machine_is_valente_wx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUANGSHANS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUANGSHANS
+# endif
+# define machine_is_huangshans()	(machine_arch_type == MACH_TYPE_HUANGSHANS)
+#else
+# define machine_is_huangshans()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOSPHORUS1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOSPHORUS1
+# endif
+# define machine_is_bosphorus1()	(machine_arch_type == MACH_TYPE_BOSPHORUS1)
+#else
+# define machine_is_bosphorus1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA
+# endif
+# define machine_is_prima()	(machine_arch_type == MACH_TYPE_PRIMA)
+#else
+# define machine_is_prima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVITA_ULK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVITA_ULK
+# endif
+# define machine_is_evita_ulk()	(machine_arch_type == MACH_TYPE_EVITA_ULK)
+#else
+# define machine_is_evita_ulk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERISC600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERISC600
+# endif
+# define machine_is_merisc600()	(machine_arch_type == MACH_TYPE_MERISC600)
+#else
+# define machine_is_merisc600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOLAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOLAK
+# endif
+# define machine_is_dolak()	(machine_arch_type == MACH_TYPE_DOLAK)
+#else
+# define machine_is_dolak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC53
+# endif
+# define machine_is_sbc53()	(machine_arch_type == MACH_TYPE_SBC53)
+#else
+# define machine_is_sbc53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELITE_ULK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELITE_ULK
+# endif
+# define machine_is_elite_ulk()	(machine_arch_type == MACH_TYPE_ELITE_ULK)
+#else
+# define machine_is_elite_ulk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POV2
+# endif
+# define machine_is_pov2()	(machine_arch_type == MACH_TYPE_POV2)
+#else
+# define machine_is_pov2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPOD_TOUCH_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD_TOUCH_2G
+# endif
+# define machine_is_ipod_touch_2g()	(machine_arch_type == MACH_TYPE_IPOD_TOUCH_2G)
+#else
+# define machine_is_ipod_touch_2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DA850_PQAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DA850_PQAB
+# endif
+# define machine_is_da850_pqab()	(machine_arch_type == MACH_TYPE_DA850_PQAB)
+#else
+# define machine_is_da850_pqab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_EVB
+# endif
+# define machine_is_msm7627a_evb()	(machine_arch_type == MACH_TYPE_MSM7627A_EVB)
+#else
+# define machine_is_msm7627a_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_CDP
+# endif
+# define machine_is_apq8064_cdp()	(machine_arch_type == MACH_TYPE_APQ8064_CDP)
+#else
+# define machine_is_apq8064_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_MTP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_MTP
+# endif
+# define machine_is_apq8064_mtp()	(machine_arch_type == MACH_TYPE_APQ8064_MTP)
+#else
+# define machine_is_apq8064_mtp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_LIQUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_LIQUID
+# endif
+# define machine_is_apq8064_liquid()	(machine_arch_type == MACH_TYPE_APQ8064_LIQUID)
+#else
+# define machine_is_apq8064_liquid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_CDP
+# endif
+# define machine_is_mpq8064_cdp()	(machine_arch_type == MACH_TYPE_MPQ8064_CDP)
+#else
+# define machine_is_mpq8064_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_HRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_HRD
+# endif
+# define machine_is_mpq8064_hrd()	(machine_arch_type == MACH_TYPE_MPQ8064_HRD)
+#else
+# define machine_is_mpq8064_hrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPQ8064_DTV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPQ8064_DTV
+# endif
+# define machine_is_mpq8064_dtv()	(machine_arch_type == MACH_TYPE_MPQ8064_DTV)
+#else
+# define machine_is_mpq8064_dtv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7627A_QRD3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7627A_QRD3
+# endif
+# define machine_is_msm7627a_qrd3()	(machine_arch_type == MACH_TYPE_MSM7627A_QRD3)
+#else
+# define machine_is_msm7627a_qrd3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_SURF
+# endif
+# define machine_is_msm8625_surf()	(machine_arch_type == MACH_TYPE_MSM8625_SURF)
+#else
+# define machine_is_msm8625_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_EVB
+# endif
+# define machine_is_msm8625_evb()	(machine_arch_type == MACH_TYPE_MSM8625_EVB)
+#else
+# define machine_is_msm8625_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_QRD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_QRD7
+# endif
+# define machine_is_msm8625_qrd7()	(machine_arch_type == MACH_TYPE_MSM8625_QRD7)
+#else
+# define machine_is_msm8625_qrd7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_FFA
+# endif
+# define machine_is_msm8625_ffa()	(machine_arch_type == MACH_TYPE_MSM8625_FFA)
+#else
+# define machine_is_msm8625_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8625_EVT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8625_EVT
+# endif
+# define machine_is_msm8625_evt()	(machine_arch_type == MACH_TYPE_MSM8625_EVT)
+#else
+# define machine_is_msm8625_evt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_MAKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_MAKO
+# endif
+# define machine_is_apq8064_mako()	(machine_arch_type == MACH_TYPE_APQ8064_MAKO)
+#else
+# define machine_is_apq8064_mako()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_FLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_FLO
+# endif
+# define machine_is_apq8064_flo()	(machine_arch_type == MACH_TYPE_APQ8064_FLO)
+#else
+# define machine_is_apq8064_flo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APQ8064_DEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APQ8064_DEB
+# endif
+# define machine_is_apq8064_deb()	(machine_arch_type == MACH_TYPE_APQ8064_DEB)
+#else
+# define machine_is_apq8064_deb()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -urN flo-ElementalX-5.00/include/generated/utsrelease.h flo-ElementalX-5.00-patched/include/generated/utsrelease.h
--- flo-ElementalX-5.00/include/generated/utsrelease.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/generated/utsrelease.h	2016-06-01 15:48:28.000000000 +0000
@@ -0,0 +1 @@
+#define UTS_RELEASE "3.4.0-flo"
diff -urN flo-ElementalX-5.00/include/linux/device.h flo-ElementalX-5.00-patched/include/linux/device.h
--- flo-ElementalX-5.00/include/linux/device.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/device.h	2014-12-03 11:07:31.000000000 +0000
@@ -531,6 +531,10 @@
 #else
 extern void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp);
 #endif
+extern void devres_for_each_res(struct device *dev, dr_release_t release,
+				dr_match_t match, void *match_data,
+				void (*fn)(struct device *, void *, void *),
+				void *data);
 extern void devres_free(void *res);
 extern void devres_add(struct device *dev, void *res);
 extern void *devres_find(struct device *dev, dr_release_t release,
@@ -683,6 +687,11 @@
 	void	(*release)(struct device *dev);
 };
 
+static inline struct device *kobj_to_dev(struct kobject *kobj)
+{
+	return container_of(kobj, struct device, kobj);
+}
+
 /* Get the wakeup routines, which depend on struct device */
 #include <linux/pm_wakeup.h>
 
diff -urN flo-ElementalX-5.00/include/linux/firmware.h flo-ElementalX-5.00-patched/include/linux/firmware.h
--- flo-ElementalX-5.00/include/linux/firmware.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/firmware.h	2016-06-01 15:47:50.000000000 +0000
@@ -12,6 +12,9 @@
 	size_t size;
 	const u8 *data;
 	struct page **pages;
+
+	/* firmware loader private fields */
+	void *priv;
 };
 
 struct module;
@@ -44,6 +47,8 @@
 	void (*cont)(const struct firmware *fw, void *context));
 
 void release_firmware(const struct firmware *fw);
+int cache_firmware(const char *name);
+int uncache_firmware(const char *name);
 #else
 static inline int request_firmware(const struct firmware **fw,
 				   const char *name,
@@ -62,6 +67,16 @@
 static inline void release_firmware(const struct firmware *fw)
 {
 }
+
+static inline int cache_firmware(const char *name)
+{
+	return -ENOENT;
+}
+
+static inline int uncache_firmware(const char *name)
+{
+	return -EINVAL;
+}
 #endif
 
 #endif
diff -urN flo-ElementalX-5.00/include/linux/genhd.h flo-ElementalX-5.00-patched/include/linux/genhd.h
--- flo-ElementalX-5.00/include/linux/genhd.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/genhd.h	2016-06-01 16:13:59.000000000 +0000
@@ -16,7 +16,7 @@
 
 #ifdef CONFIG_BLOCK
 
-#define kobj_to_dev(k)		container_of((k), struct device, kobj)
+//#define kobj_to_dev(k)		container_of((k), struct device, kobj)
 #define dev_to_disk(device)	container_of((device), struct gendisk, part0.__dev)
 #define dev_to_part(device)	container_of((device), struct hd_struct, __dev)
 #define disk_to_dev(disk)	(&(disk)->part0.__dev)
diff -urN flo-ElementalX-5.00/include/linux/genlock.h flo-ElementalX-5.00-patched/include/linux/genlock.h
--- flo-ElementalX-5.00/include/linux/genlock.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/genlock.h	2016-06-03 17:13:57.000000000 +0000
@@ -8,6 +8,7 @@
 
 struct genlock_handle *genlock_get_handle(void);
 struct genlock_handle *genlock_get_handle_fd(int fd);
+int genlock_get_fd_handle(struct genlock_handle *handle);
 void genlock_put_handle(struct genlock_handle *handle);
 struct genlock *genlock_create_lock(struct genlock_handle *);
 struct genlock *genlock_attach_lock(struct genlock_handle *, int fd);
diff -urN flo-ElementalX-5.00/include/linux/ion.h flo-ElementalX-5.00-patched/include/linux/ion.h
--- flo-ElementalX-5.00/include/linux/ion.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/ion.h	2016-06-03 17:03:09.000000000 +0000
@@ -243,11 +243,19 @@
 void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
 
 /**
- * ion_share_dma_buf() - given an ion client, create a dma-buf fd
+ * ion_share_dma_buf() - share buffer as dma-buf
  * @client:	the client
  * @handle:	the handle
  */
-int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle);
+struct dma_buf *ion_share_dma_buf(struct ion_client *client,
+						struct ion_handle *handle);
+
+/**
+ * ion_share_dma_buf_fd() - given an ion client, create a dma-buf fd
+ * @client:	the client
+ * @handle:	the handle
+ */
+int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle);
 
 /**
  * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
diff -urN flo-ElementalX-5.00/include/linux/pm.h flo-ElementalX-5.00-patched/include/linux/pm.h
--- flo-ElementalX-5.00/include/linux/pm.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/pm.h	2016-06-01 15:47:50.000000000 +0000
@@ -640,6 +640,7 @@
 	} while (0)
 
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
+extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));
 
 extern int pm_generic_prepare(struct device *dev);
 extern int pm_generic_suspend_late(struct device *dev);
@@ -679,6 +680,10 @@
 	return 0;
 }
 
+static inline void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))
+{
+}
+
 #define pm_generic_prepare	NULL
 #define pm_generic_suspend	NULL
 #define pm_generic_resume	NULL
diff -urN flo-ElementalX-5.00/include/linux/version.h flo-ElementalX-5.00-patched/include/linux/version.h
--- flo-ElementalX-5.00/include/linux/version.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/linux/version.h	2016-06-01 15:48:26.000000000 +0000
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 197632
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -urN flo-ElementalX-5.00/include/net/bluetooth/amp.h flo-ElementalX-5.00-patched/include/net/bluetooth/amp.h
--- flo-ElementalX-5.00/include/net/bluetooth/amp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/amp.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,293 +0,0 @@
-/*
-   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 and
-   only version 2 as published by the Free Software Foundation.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-*/
-
-#ifndef __AMP_H
-#define __AMP_H
-
-/* AMP defaults */
-
-#define A2MP_RSP_TIMEOUT        (8000)  /*  8 seconds */
-
-/* A2MP Protocol */
-
-/* A2MP command codes */
-#define A2MP_COMMAND_REJ         0x01
-#define A2MP_DISCOVER_REQ        0x02
-#define A2MP_DISCOVER_RSP        0x03
-#define A2MP_CHANGE_NOTIFY       0x04
-#define A2MP_CHANGE_RSP          0x05
-#define A2MP_GETINFO_REQ         0x06
-#define A2MP_GETINFO_RSP         0x07
-#define A2MP_GETAMPASSOC_REQ     0x08
-#define A2MP_GETAMPASSOC_RSP     0x09
-#define A2MP_CREATEPHYSLINK_REQ  0x0A
-#define A2MP_CREATEPHYSLINK_RSP  0x0B
-#define A2MP_DISCONNPHYSLINK_REQ 0x0C
-#define A2MP_DISCONNPHYSLINK_RSP 0x0D
-
-struct a2mp_cmd_hdr {
-	__u8       code;
-	__u8       ident;
-	__le16     len;
-} __packed;
-
-struct a2mp_cmd_rej {
-	__le16     reason;
-} __packed;
-
-struct a2mp_discover_req {
-	__le16     mtu;
-	__le16     ext_feat;
-} __packed;
-
-struct a2mp_cl {
-	__u8       id;
-	__u8       type;
-	__u8       status;
-} __packed;
-
-struct a2mp_discover_rsp {
-	__le16     mtu;
-	__le16     ext_feat;
-	struct a2mp_cl cl[0];
-} __packed;
-
-struct a2mp_getinfo_req {
-	__u8       id;
-} __packed;
-
-struct a2mp_getinfo_rsp {
-	__u8       id;
-	__u8       status;
-	__le32     total_bw;
-	__le32     max_bw;
-	__le32     min_latency;
-	__le16     pal_cap;
-	__le16     assoc_size;
-} __packed;
-
-struct a2mp_getampassoc_req {
-	__u8       id;
-} __packed;
-
-struct a2mp_getampassoc_rsp {
-	__u8       id;
-	__u8       status;
-	__u8       amp_assoc[0];
-} __packed;
-
-struct a2mp_createphyslink_req {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       amp_assoc[0];
-} __packed;
-
-struct a2mp_createphyslink_rsp {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       status;
-} __packed;
-
-struct a2mp_disconnphyslink_req {
-	__u8       local_id;
-	__u8       remote_id;
-} __packed;
-
-struct a2mp_disconnphyslink_rsp {
-	__u8       local_id;
-	__u8       remote_id;
-	__u8       status;
-} __packed;
-
-
-/* L2CAP-AMP module interface */
-int amp_init(void);
-void amp_exit(void);
-
-/* L2CAP-AMP fixed channel interface */
-void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb);
-
-/* L2CAP-AMP link interface */
-void amp_create_physical(struct l2cap_conn *conn, struct sock *sk);
-void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk);
-
-/* AMP manager internals */
-struct amp_ctrl {
-	struct  amp_mgr *mgr;
-	__u8    id;
-	__u8    type;
-	__u8    status;
-	__u32   total_bw;
-	__u32   max_bw;
-	__u32   min_latency;
-	__u16   pal_cap;
-	__u16   max_assoc_size;
-};
-
-struct amp_mgr {
-	struct list_head list;
-	__u8    discovered;
-	__u8    next_ident;
-	struct l2cap_conn *l2cap_conn;
-	struct socket *a2mp_sock;
-	struct list_head  ctx_list;
-	rwlock_t       ctx_list_lock;
-	struct amp_ctrl *ctrls;          /* @@ TODO s.b. list of controllers */
-	struct sk_buff *skb;
-	__u8   connected;
-};
-
-/* AMP Manager signalling contexts */
-#define AMP_GETAMPASSOC       1
-#define AMP_CREATEPHYSLINK    2
-#define AMP_ACCEPTPHYSLINK    3
-#define AMP_CREATELOGLINK     4
-#define AMP_ACCEPTLOGLINK     5
-
-/* Get AMP Assoc sequence */
-#define AMP_GAA_INIT           0
-#define AMP_GAA_RLAA_COMPLETE  1
-struct amp_gaa_state {
-	__u8       req_ident;
-	__u16      len_so_far;
-	__u8      *assoc;
-};
-
-/* Create Physical Link sequence */
-#define AMP_CPL_INIT           0
-#define AMP_CPL_DISC_RSP       1
-#define AMP_CPL_GETINFO_RSP    2
-#define AMP_CPL_GAA_RSP        3
-#define AMP_CPL_CPL_STATUS     4
-#define AMP_CPL_WRA_COMPLETE   5
-#define AMP_CPL_CHANNEL_SELECT 6
-#define AMP_CPL_RLA_COMPLETE   7
-#define AMP_CPL_PL_COMPLETE    8
-#define AMP_CPL_PL_CANCEL      9
-struct amp_cpl_state {
-	__u8       remote_id;
-	__u16      max_len;
-	__u8      *remote_assoc;
-	__u8      *local_assoc;
-	__u16      len_so_far;
-	__u16      rem_len;
-	__u8       phy_handle;
-};
-
-/* Accept Physical Link sequence */
-#define AMP_APL_INIT           0
-#define AMP_APL_APL_STATUS     1
-#define AMP_APL_WRA_COMPLETE   2
-#define AMP_APL_PL_COMPLETE    3
-struct amp_apl_state {
-	__u8       remote_id;
-	__u8       req_ident;
-	__u8      *remote_assoc;
-	__u16      len_so_far;
-	__u16      rem_len;
-	__u8       phy_handle;
-};
-
-/* Create/Accept Logical Link sequence */
-#define AMP_LOG_INIT         0
-#define AMP_LOG_LL_STATUS    1
-#define AMP_LOG_LL_COMPLETE  2
-struct amp_log_state {
-	__u8       remote_id;
-};
-
-/* Possible event types a context may wait for */
-#define AMP_INIT            0x01
-#define AMP_HCI_EVENT       0x02
-#define AMP_HCI_CMD_CMPLT   0x04
-#define AMP_HCI_CMD_STATUS  0x08
-#define AMP_A2MP_RSP        0x10
-#define AMP_KILLED          0x20
-#define AMP_CANCEL          0x40
-struct amp_ctx {
-	struct list_head list;
-	struct amp_mgr *mgr;
-	struct hci_dev *hdev;
-	__u8       type;
-	__u8       state;
-	union {
-		struct amp_gaa_state gaa;
-		struct amp_cpl_state cpl;
-		struct amp_apl_state apl;
-	} d;
-	__u8 evt_type;
-	__u8 evt_code;
-	__u16 opcode;
-	__u8 id;
-	__u8 rsp_ident;
-
-	struct sock *sk;
-	struct amp_ctx *deferred;
-	struct timer_list timer;
-};
-
-/* AMP work */
-struct amp_work_pl_timeout {
-	struct work_struct work;
-	struct amp_ctrl *ctrl;
-};
-struct amp_work_ctx_timeout {
-	struct work_struct work;
-	struct amp_ctx *ctx;
-};
-struct amp_work_data_ready {
-	struct work_struct work;
-	struct sock *sk;
-	int bytes;
-};
-struct amp_work_state_change {
-	struct work_struct work;
-	struct sock *sk;
-};
-struct amp_work_conn_ind {
-	struct work_struct work;
-	struct hci_conn *hcon;
-	struct sk_buff *skb;
-};
-struct amp_work_create_physical {
-	struct work_struct work;
-	struct l2cap_conn *conn;
-	u8 id;
-	struct sock *sk;
-};
-struct amp_work_accept_physical {
-	struct work_struct work;
-	struct l2cap_conn *conn;
-	u8 id;
-	struct sock *sk;
-};
-struct amp_work_cmd_cmplt {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u16 opcode;
-	struct sk_buff *skb;
-};
-struct amp_work_cmd_status {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u16 opcode;
-	u8 status;
-};
-struct amp_work_event {
-	struct work_struct work;
-	struct hci_dev *hdev;
-	u8 event;
-	struct sk_buff *skb;
-};
-
-#endif /* __AMP_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/bluetooth.h flo-ElementalX-5.00-patched/include/net/bluetooth/bluetooth.h
--- flo-ElementalX-5.00/include/net/bluetooth/bluetooth.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/bluetooth.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
-/*
+/* 
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -12,20 +12,20 @@
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
    IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
    SOFTWARE IS DISCLAIMED.
 */
 
 #ifndef __BLUETOOTH_H
 #define __BLUETOOTH_H
 
-#include <linux/types.h>
+#include <asm/types.h>
 #include <asm/byteorder.h>
 #include <linux/list.h>
 #include <linux/poll.h>
@@ -36,9 +36,13 @@
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #endif
 
+/* Bluetooth versions */
+#define BLUETOOTH_VER_1_1	1
+#define BLUETOOTH_VER_1_2	2
+#define BLUETOOTH_VER_2_0	3
+
 /* Reserv for core and drivers use */
 #define BT_SKB_RESERVE	8
-#define BT_SKB_RESERVE_80211	32
 
 #define BTPROTO_L2CAP	0
 #define BTPROTO_HCI	1
@@ -63,68 +67,56 @@
 #define BT_SECURITY_LOW		1
 #define BT_SECURITY_MEDIUM	2
 #define BT_SECURITY_HIGH	3
-#define BT_SECURITY_VERY_HIGH	4
 
 #define BT_DEFER_SETUP	7
+
 #define BT_FLUSHABLE	8
 
+#define BT_FLUSHABLE_OFF	0
+#define BT_FLUSHABLE_ON		1
+
 #define BT_POWER	9
 struct bt_power {
 	__u8 force_active;
 };
+#define BT_POWER_FORCE_ACTIVE_OFF 0
+#define BT_POWER_FORCE_ACTIVE_ON  1
 
-#define BT_AMP_POLICY          10
+#define BT_CHANNEL_POLICY	10
 
-/* Require BR/EDR (default policy)
- *   AMP controllers cannot be used
- *   Channel move requests from the remote device are denied
- *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR
+/* BR/EDR only (default policy)
+ *   AMP controllers cannot be used.
+ *   Channel move requests from the remote device are denied.
+ *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR.
  */
-#define BT_AMP_POLICY_REQUIRE_BR_EDR   0
+#define BT_CHANNEL_POLICY_BREDR_ONLY		0
 
-/* Prefer BR/EDR
- *   Allow use of AMP controllers
- *   If the L2CAP channel is currently on AMP, move it to BR/EDR
- *   Channel move requests from the remote device are allowed
+/* BR/EDR Preferred
+ *   Allow use of AMP controllers.
+ *   If the L2CAP channel is currently on AMP, move it to BR/EDR.
+ *   Channel move requests from the remote device are allowed.
  */
-#define BT_AMP_POLICY_PREFER_BR_EDR    1
+#define BT_CHANNEL_POLICY_BREDR_PREFERRED	1
 
-/* Prefer AMP
+/* AMP Preferred
  *   Allow use of AMP controllers
  *   If the L2CAP channel is currently on BR/EDR and AMP controller
- *     resources are available, initiate a channel move to AMP
- *   Channel move requests from the remote device are allowed
+ *     resources are available, initiate a channel move to AMP.
+ *   Channel move requests from the remote device are allowed.
  *   If the L2CAP socket has not been connected yet, try to create
  *     and configure the channel directly on an AMP controller rather
- *     than BR/EDR
+ *     than BR/EDR.
  */
-#define BT_AMP_POLICY_PREFER_AMP       2
-
-#define BT_LE_PARAMS	100
-
-#define BT_LE_SCAN_WINDOW_MIN		0x0004
-#define BT_LE_SCAN_WINDOW_MAX		0x4000
-#define BT_LE_SCAN_WINDOW_DEF		0x0004
-
-#define BT_LE_SCAN_INTERVAL_MIN		0x0004
-#define BT_LE_SCAN_INTERVAL_MAX		0x4000
-#define BT_LE_SCAN_INTERVAL_DEF		0x0008
-
-#define BT_LE_CONN_INTERVAL_MIN		0x0006
-#define BT_LE_CONN_INTERVAL_MAX		0x0C80
-#define BT_LE_CONN_INTERVAL_MIN_DEF	0x0008
-#define BT_LE_CONN_INTERVAL_MAX_DEF	0x0100
-
-#define BT_LE_LATENCY_MAX		0x01F4
-#define BT_LE_LATENCY_DEF		0x0000
-
-#define BT_LE_SUP_TO_MIN		0x000A
-#define BT_LE_SUP_TO_MAX		0x0C80
-#define BT_LE_SUP_TO_DEFAULT		0X03E8
+#define BT_CHANNEL_POLICY_AMP_PREFERRED		2
 
-#define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
-#define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
-#define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
+__printf(1, 2)
+int bt_info(const char *fmt, ...);
+__printf(1, 2)
+int bt_err(const char *fmt, ...);
+
+#define BT_INFO(fmt, ...)	bt_info(fmt "\n", ##__VA_ARGS__)
+#define BT_ERR(fmt, ...)	bt_err(fmt "\n", ##__VA_ARGS__)
+#define BT_DBG(fmt, ...)	pr_debug(fmt "\n", ##__VA_ARGS__)
 
 /* Connection and socket states */
 enum {
@@ -139,13 +131,40 @@
 	BT_CLOSED
 };
 
+/* If unused will be removed by compiler */
+static inline const char *state_to_string(int state)
+{
+	switch (state) {
+	case BT_CONNECTED:
+		return "BT_CONNECTED";
+	case BT_OPEN:
+		return "BT_OPEN";
+	case BT_BOUND:
+		return "BT_BOUND";
+	case BT_LISTEN:
+		return "BT_LISTEN";
+	case BT_CONNECT:
+		return "BT_CONNECT";
+	case BT_CONNECT2:
+		return "BT_CONNECT2";
+	case BT_CONFIG:
+		return "BT_CONFIG";
+	case BT_DISCONN:
+		return "BT_DISCONN";
+	case BT_CLOSED:
+		return "BT_CLOSED";
+	}
+
+	return "invalid state";
+}
+
 /* BD Address */
 typedef struct {
 	__u8 b[6];
 } __packed bdaddr_t;
 
-#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0} })
-#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff} })
+#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})
+#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff}})
 
 /* Copy, swap, convert BD Address */
 static inline int bacmp(bdaddr_t *ba1, bdaddr_t *ba2)
@@ -165,20 +184,6 @@
 
 #define bt_sk(__sk) ((struct bt_sock *) __sk)
 
-struct bt_le_params {
-	__u8  prohibit_remote_chg;
-	__u8  filter_policy;
-	__u16 scan_interval;
-	__u16 scan_window;
-	__u16 interval_min;
-	__u16 interval_max;
-	__u16 latency;
-	__u16 supervision_timeout;
-	__u16 min_ce_len;
-	__u16 max_ce_len;
-	__u16 conn_timeout;
-};
-
 struct bt_sock {
 	struct sock sk;
 	bdaddr_t    src;
@@ -186,7 +191,7 @@
 	struct list_head accept_q;
 	struct sock *parent;
 	u32 defer_setup;
-	struct bt_le_params le_params;
+	bool suspended;
 };
 
 struct bt_sock_list {
@@ -202,7 +207,7 @@
 				struct msghdr *msg, size_t len, int flags);
 int  bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 			struct msghdr *msg, size_t len, int flags);
-uint bt_sock_poll(struct file *file, struct socket *sock, poll_table *wait);
+uint bt_sock_poll(struct file * file, struct socket *sock, poll_table *wait);
 int  bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
 
@@ -211,25 +216,14 @@
 struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
 
 /* Skb helpers */
-struct bt_l2cap_control {
-	__u8  frame_type;
-	__u8  final;
-	__u8  sar;
-	__u8  super;
-	__u16 reqseq;
-	__u16 txseq;
-	__u8  poll;
-	__u8  fcs;
-};
-
 struct bt_skb_cb {
 	__u8 pkt_type;
 	__u8 incoming;
 	__u16 expect;
+	__u16 tx_seq;
 	__u8 retries;
+	__u8 sar;
 	__u8 force_active;
-	unsigned short channel;
-	struct bt_l2cap_control control;
 };
 #define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
 
@@ -237,8 +231,7 @@
 {
 	struct sk_buff *skb;
 
-	skb = alloc_skb(len + BT_SKB_RESERVE, how);
-	if (skb) {
+	if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -251,8 +244,7 @@
 	struct sk_buff *skb;
 
 	release_sock(sk);
-	skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err);
-	if (skb) {
+	if ((skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err))) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -277,7 +269,7 @@
 	return NULL;
 }
 
-int bt_err(__u16 code);
+int bt_to_errno(__u16 code);
 
 extern int hci_sock_init(void);
 extern void hci_sock_cleanup(void);
@@ -293,4 +285,6 @@
 int sco_init(void);
 void sco_exit(void);
 
+void bt_sock_reclassify_lock(struct sock *sk, int proto);
+
 #endif /* __BLUETOOTH_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci.h	2014-12-03 11:07:31.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,7 +25,7 @@
 #ifndef __HCI_H
 #define __HCI_H
 
-#define HCI_MAX_ACL_SIZE	1500
+#define HCI_MAX_ACL_SIZE	1024
 #define HCI_MAX_SCO_SIZE	255
 #define HCI_MAX_EVENT_SIZE	260
 #define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
@@ -37,7 +37,7 @@
 #define HCI_DEV_DOWN			4
 #define HCI_DEV_SUSPEND			5
 #define HCI_DEV_RESUME			6
-#define HCI_DEV_WRITE			7
+#define HCI_SMD                7
 
 /* HCI notify events */
 #define HCI_NOTIFY_CONN_ADD		1
@@ -52,7 +52,6 @@
 #define HCI_RS232	4
 #define HCI_PCI		5
 #define HCI_SDIO	6
-#define HCI_SMD		7
 
 /* HCI controller types */
 #define HCI_BREDR	0x00
@@ -79,6 +78,14 @@
 
 	HCI_RAW,
 
+	HCI_RESET,
+};
+
+/*
+ * BR/EDR and/or LE controller flags: the flags defined here should represent
+ * states from the controller.
+ */
+enum {
 	HCI_SETUP,
 	HCI_AUTO_OFF,
 	HCI_MGMT,
@@ -86,8 +93,16 @@
 	HCI_SERVICE_CACHE,
 	HCI_LINK_KEYS,
 	HCI_DEBUG_KEYS,
+	HCI_UNREGISTER,
 
-	HCI_RESET,
+	HCI_LE_SCAN,
+	HCI_SSP_ENABLED,
+	HCI_HS_ENABLED,
+	HCI_LE_ENABLED,
+	HCI_CONNECTABLE,
+	HCI_DISCOVERABLE,
+	HCI_LINK_SECURITY,
+	HCI_PENDING_CLASS,
 };
 
 /* HCI ioctl defines */
@@ -101,7 +116,6 @@
 #define HCIGETCONNLIST	_IOR('H', 212, int)
 #define HCIGETCONNINFO	_IOR('H', 213, int)
 #define HCIGETAUTHINFO	_IOR('H', 215, int)
-#define HCISETAUTHINFO  _IOR('H', 216, int)
 
 #define HCISETRAW	_IOW('H', 220, int)
 #define HCISETSCAN	_IOW('H', 221, int)
@@ -124,7 +138,8 @@
 #define HCI_PAIRING_TIMEOUT	(60000)	/* 60 seconds */
 #define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
 #define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
-#define HCI_CMD_TIMEOUT		(5000)	/* 5 seconds */
+#define HCI_CMD_TIMEOUT		(1000)	/* 1 seconds */
+#define HCI_ACL_TX_TIMEOUT	(45000)	/* 45 seconds */
 
 /* HCI data types */
 #define HCI_COMMAND_PKT		0x01
@@ -160,35 +175,16 @@
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
-#define ESCO_WBS	(ESCO_EV3 | (EDR_ESCO_MASK ^ ESCO_2EV3))
-
-#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
-#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
-#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
-			EDR_ESCO_MASK)
-
-/* Air Coding Format */
-#define ACF_CVSD	0x0000;
-#define ACF_ULAW	0x0001;
-#define ACF_ALAW	0x0002;
-#define ACF_TRANS	0x0003;
-
-/* Retransmission Effort */
-#define RE_NO_RETRANS		0x00;
-#define RE_POWER_CONSUMP	0x01;
-#define RE_LINK_QUALITY		0x02;
-#define RE_DONT_CARE		0xFF;
+#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
 
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
 #define ACL_CONT		0x01
 #define ACL_START		0x02
-#define ACL_COMPLETE		0x03
 #define ACL_ACTIVE_BCAST	0x04
 #define ACL_PICO_BCAST		0x08
 
-#define ACL_PB_MASK	(ACL_CONT | ACL_START)
-
 /* Baseband links */
 #define SCO_LINK	0x00
 #define ACL_LINK	0x01
@@ -224,6 +220,7 @@
 
 #define LMP_EV4		0x01
 #define LMP_EV5		0x02
+#define LMP_NO_BREDR	0x20
 #define LMP_LE		0x40
 
 #define LMP_SNIFF_SUBR	0x02
@@ -233,11 +230,18 @@
 #define LMP_EDR_3S_ESCO	0x80
 
 #define LMP_EXT_INQ	0x01
+#define LMP_SIMUL_LE_BR	0x02
 #define LMP_SIMPLE_PAIR	0x08
 #define LMP_NO_FLUSH	0x40
 
 #define LMP_LSTO	0x01
 #define LMP_INQ_TX_PWR	0x02
+#define LMP_EXTFEATURES	0x80
+
+/* Extended LMP features */
+#define LMP_HOST_SSP		0x01
+#define LMP_HOST_LE		0x02
+#define LMP_HOST_LE_BREDR	0x04
 
 /* Connection modes */
 #define HCI_CM_ACTIVE	0x0000
@@ -268,9 +272,46 @@
 #define HCI_AT_GENERAL_BONDING		0x04
 #define HCI_AT_GENERAL_BONDING_MITM	0x05
 
+/* Link Key types */
+#define HCI_LK_COMBINATION		0x00
+#define HCI_LK_LOCAL_UNIT		0x01
+#define HCI_LK_REMOTE_UNIT		0x02
+#define HCI_LK_DEBUG_COMBINATION	0x03
+#define HCI_LK_UNAUTH_COMBINATION	0x04
+#define HCI_LK_AUTH_COMBINATION		0x05
+#define HCI_LK_CHANGED_COMBINATION	0x06
+/* The spec doesn't define types for SMP keys, the _MASTER suffix is implied */
+#define HCI_SMP_STK			0x80
+#define HCI_SMP_STK_SLAVE		0x81
+#define HCI_SMP_LTK			0x82
+#define HCI_SMP_LTK_SLAVE		0x83
+
+/* ---- HCI Error Codes ---- */
+#define HCI_ERROR_AUTH_FAILURE		0x05
+#define HCI_ERROR_REJ_BAD_ADDR		0x0f
+#define HCI_ERROR_REMOTE_USER_TERM	0x13
+#define HCI_ERROR_LOCAL_HOST_TERM	0x16
+#define HCI_ERROR_PAIRING_NOT_ALLOWED	0x18
+
 /* Flow control modes */
-#define HCI_PACKET_BASED_FLOW_CTL_MODE	0x00
-#define HCI_BLOCK_BASED_FLOW_CTL_MODE	0x01
+#define HCI_FLOW_CTL_MODE_PACKET_BASED	0x00
+#define HCI_FLOW_CTL_MODE_BLOCK_BASED	0x01
+
+/* Extended Inquiry Response field types */
+#define EIR_FLAGS		0x01 /* flags */
+#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
+#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
+#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
+#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
+#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
+#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
+#define EIR_NAME_SHORT		0x08 /* shortened local name */
+#define EIR_NAME_COMPLETE	0x09 /* complete local name */
+#define EIR_TX_POWER		0x0A /* transmit power level */
+#define EIR_CLASS_OF_DEV	0x0D /* Class of Device */
+#define EIR_SSP_HASH_C		0x0E /* Simple Pairing Hash C */
+#define EIR_SSP_RAND_R		0x0F /* Simple Pairing Randomizer R */
+#define EIR_DEVICE_ID		0x10 /* device ID */
 
 /* -----  HCI Commands ---- */
 #define HCI_OP_NOP			0x0000
@@ -331,11 +372,6 @@
 	__u8     link_key[16];
 } __packed;
 
-struct hci_rp_link_key_reply {
-	__u8     status;
-	bdaddr_t bdaddr;
-} __packed;
-
 #define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
 struct hci_cp_link_key_neg_reply {
 	bdaddr_t bdaddr;
@@ -412,11 +448,6 @@
 	__le16   handle;
 } __packed;
 
-#define HCI_OP_READ_CLOCK_OFFSET	0x041f
-struct hci_cp_read_clock_offset {
-	__le16   handle;
-} __packed;
-
 #define HCI_OP_SETUP_SYNC_CONN		0x0428
 struct hci_cp_setup_sync_conn {
 	__le16   handle;
@@ -464,6 +495,14 @@
 
 #define HCI_OP_USER_CONFIRM_NEG_REPLY	0x042d
 
+#define HCI_OP_USER_PASSKEY_REPLY		0x042e
+struct hci_cp_user_passkey_reply {
+	bdaddr_t bdaddr;
+	__le32	passkey;
+} __packed;
+
+#define HCI_OP_USER_PASSKEY_NEG_REPLY	0x042f
+
 #define HCI_OP_REMOTE_OOB_DATA_REPLY	0x0430
 struct hci_cp_remote_oob_data_reply {
 	bdaddr_t bdaddr;
@@ -482,69 +521,6 @@
 	__u8     reason;
 } __packed;
 
-#define HCI_OP_CREATE_PHYS_LINK		0x0435
-struct hci_cp_create_phys_link {
-	__u8     phy_handle;
-	__u8     key_len;
-	__u8     type;
-	__u8     data[32];
-} __packed;
-
-#define HCI_OP_ACCEPT_PHYS_LINK		0x0436
-struct hci_cp_accept_phys_link {
-	__u8     phy_handle;
-	__u8     key_len;
-	__u8     type;
-	__u8     data[32];
-} __packed;
-
-#define HCI_OP_DISCONN_PHYS_LINK	0x0437
-struct hci_cp_disconn_phys_link {
-	__u8     phy_handle;
-	__u8     reason;
-} __packed;
-
-struct hci_ext_fs {
-	__u8       id;
-	__u8       type;
-	__le16     max_sdu;
-	__le32     sdu_arr_time;
-	__le32     acc_latency;
-	__le32     flush_to;
-} __packed;
-
-#define HCI_OP_CREATE_LOGICAL_LINK	0x0438
-#define HCI_OP_ACCEPT_LOGICAL_LINK	0x0439
-struct hci_cp_create_logical_link {
-	__u8               phy_handle;
-	struct hci_ext_fs  tx_fs;
-	struct hci_ext_fs  rx_fs;
-} __packed;
-
-#define HCI_OP_DISCONN_LOGICAL_LINK	0x043a
-struct hci_cp_disconn_logical_link {
-	__le16   log_handle;
-} __packed;
-
-#define HCI_OP_LOGICAL_LINK_CANCEL	0x043b
-struct hci_cp_logical_link_cancel {
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-struct hci_rp_logical_link_cancel {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-#define HCI_OP_FLOW_SPEC_MODIFY		0x043c
-struct hci_cp_flow_spec_modify {
-	__le16             log_handle;
-	struct hci_ext_fs  tx_fs;
-	struct hci_ext_fs  rx_fs;
-} __packed;
-
 #define HCI_OP_SNIFF_MODE		0x0803
 struct hci_cp_sniff_mode {
 	__le16   handle;
@@ -705,12 +681,6 @@
 	__le16   voice_setting;
 } __packed;
 
-#define HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0c28
-struct hci_cp_write_automatic_flush_timeout {
-	__le16   handle;
-	__le16   timeout;
-} __packed;
-
 #define HCI_OP_HOST_BUFFER_SIZE		0x0c33
 struct hci_cp_host_buffer_size {
 	__le16   acl_mtu;
@@ -719,20 +689,14 @@
 	__le16   sco_max_pkt;
 } __packed;
 
-#define HCI_OP_WRITE_CURRENT_IAC_LAP	0x0c3a
-struct hci_cp_write_current_iac_lap {
-	__u8     num_current_iac;
-	__u8     lap[6];
-} __packed;
-
 #define HCI_OP_WRITE_INQUIRY_MODE	0x0c45
 
 #define HCI_MAX_EIR_LENGTH		240
 
 #define HCI_OP_WRITE_EIR		0x0c52
 struct hci_cp_write_eir {
-	uint8_t		fec;
-	uint8_t		data[HCI_MAX_EIR_LENGTH];
+	__u8	fec;
+	__u8	data[HCI_MAX_EIR_LENGTH];
 } __packed;
 
 #define HCI_OP_READ_SSP_MODE		0x0c55
@@ -755,70 +719,16 @@
 
 #define HCI_OP_READ_INQ_RSP_TX_POWER	0x0c58
 
-#define HCI_OP_READ_LL_TIMEOUT		0x0c61
-struct hci_rp_read_ll_timeout {
-	__u8     status;
-	__le16   timeout;
-} __packed;
-
-#define HCI_OP_WRITE_LL_TIMEOUT		0x0c62
-struct hci_cp_write_ll_timeout {
-	__le16   timeout;
-} __packed;
-
-#define HCI_OP_SET_EVENT_MASK_PAGE2	0x0c63
-struct hci_cp_set_event_mask_page2 {
-	__u8     mask[8];
-} __packed;
-
-#define HCI_OP_READ_LOCATION_DATA	0x0c64
-struct hci_rp_read_location_data {
-	__u8     status;
-	__u8     loc_dom_aware;
-	__u8     loc_dom;
-	__u8     loc_dom_opts;
-	__u8     loc_opts;
-} __packed;
-
-#define HCI_OP_WRITE_LOCATION_DATA	0x0c65
-struct hci_cp_write_location_data {
-	__u8     loc_dom_aware;
-	__u8     loc_dom;
-	__u8     loc_dom_opts;
-	__u8     loc_opts;
-} __packed;
-
 #define HCI_OP_READ_FLOW_CONTROL_MODE	0x0c66
 struct hci_rp_read_flow_control_mode {
 	__u8     status;
 	__u8     mode;
 } __packed;
 
-#define HCI_OP_WRITE_FLOW_CONTROL_MODE	0x0c67
-struct hci_cp_write_flow_control_mode {
-	__u8     mode;
-} __packed;
-
-#define HCI_OP_READ_BE_FLUSH_TIMEOUT	0x0c69
-struct hci_cp_read_be_flush_timeout {
-	__le16   log_handle;
-} __packed;
-
-struct hci_rp_read_be_flush_timeout {
-	__u8     status;
-	__le32   timeout;
-} __packed;
-
-#define HCI_OP_WRITE_BE_FLUSH_TIMEOUT	0x0c6a
-struct hci_cp_write_be_flush_timeout {
-	__le16   log_handle;
-	__le32   timeout;
-} __packed;
-
-#define HCI_OP_SHORT_RANGE_MODE		0x0c6b
-struct hci_cp_short_range_mode {
-	__u8     phy_handle;
-	__u8     mode;
+#define HCI_OP_WRITE_LE_HOST_SUPPORTED	0x0c6d
+struct hci_cp_write_le_host_supported {
+	__u8	le;
+	__u8	simul;
 } __packed;
 
 #define HCI_OP_READ_LOCAL_VERSION	0x1001
@@ -844,6 +754,9 @@
 } __packed;
 
 #define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
+struct hci_cp_read_local_ext_features {
+	__u8     page;
+} __packed;
 struct hci_rp_read_local_ext_features {
 	__u8     status;
 	__u8     page;
@@ -870,20 +783,19 @@
 struct hci_rp_read_data_block_size {
 	__u8     status;
 	__le16   max_acl_len;
-	__le16   data_block_len;
+	__le16   block_len;
 	__le16   num_blocks;
 } __packed;
 
-#define HCI_OP_READ_RSSI	0x1405
-struct hci_cp_read_rssi {
-	__le16   handle;
+#define HCI_OP_WRITE_PAGE_SCAN_ACTIVITY	0x0c1c
+struct hci_cp_write_page_scan_activity {
+	__le16   interval;
+	__le16   window;
 } __packed;
 
-struct hci_rp_read_rssi {
-	__u8     status;
-	__le16   handle;
-	__s8     rssi;
-} __packed;
+#define HCI_OP_WRITE_PAGE_SCAN_TYPE	0x0c47
+	#define PAGE_SCAN_TYPE_STANDARD		0x00
+	#define PAGE_SCAN_TYPE_INTERLACED	0x01
 
 #define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
 struct hci_rp_read_local_amp_info {
@@ -900,33 +812,6 @@
 	__le32   be_flush_to;
 } __packed;
 
-#define HCI_OP_READ_LOCAL_AMP_ASSOC	0x140a
-struct hci_cp_read_local_amp_assoc {
-	__u8     phy_handle;
-	__le16   len_so_far;
-	__le16   max_len;
-} __packed;
-
-struct hci_rp_read_local_amp_assoc {
-	__u8     status;
-	__u8     phy_handle;
-	__le16   rem_len;
-	__u8     frag[248];
-} __packed;
-
-#define HCI_OP_WRITE_REMOTE_AMP_ASSOC	0x140b
-struct hci_cp_write_remote_amp_assoc {
-	__u8     phy_handle;
-	__le16   len_so_far;
-	__le16   rem_len;
-	__u8     frag[248];
-} __packed;
-
-struct hci_rp_write_remote_amp_assoc {
-	__u8     status;
-	__u8     phy_handle;
-} __packed;
-
 #define HCI_OP_LE_SET_EVENT_MASK	0x2001
 struct hci_cp_le_set_event_mask {
 	__u8     mask[8];
@@ -939,19 +824,22 @@
 	__u8     le_max_pkt;
 } __packed;
 
-#define HCI_OP_LE_SET_SCAN_PARAMETERS	0x200b
-struct hci_cp_le_set_scan_parameters {
-	__u8	type;
-	__le16	interval;
-	__le16	window;
-	__u8	own_bdaddr_type;
-	__u8	filter;
+#define HCI_OP_LE_SET_SCAN_PARAM	0x200b
+struct hci_cp_le_set_scan_param {
+	__u8    type;
+	__le16  interval;
+	__le16  window;
+	__u8    own_address_type;
+	__u8    filter_policy;
 } __packed;
 
+#define LE_SCANNING_DISABLED		0x00
+#define LE_SCANNING_ENABLED		0x01
+
 #define HCI_OP_LE_SET_SCAN_ENABLE	0x200c
 struct hci_cp_le_set_scan_enable {
-	__u8	enable;
-	__u8	filter_dup;
+	__u8     enable;
+	__u8     filter_dup;
 } __packed;
 
 #define HCI_OP_LE_CREATE_CONN		0x200d
@@ -972,26 +860,6 @@
 
 #define HCI_OP_LE_CREATE_CONN_CANCEL	0x200e
 
-#define HCI_OP_LE_READ_WHITE_LIST_SIZE	0x200F
-struct hci_rp_le_read_white_list_size {
-	__u8     status;
-	__u8     size;
-} __packed;
-
-#define HCI_OP_LE_CLEAR_WHITE_LIST	0x2010
-
-#define HCI_OP_LE_ADD_DEV_WHITE_LIST	0x2011
-struct hci_cp_le_add_dev_white_list {
-	__u8     addr_type;
-	bdaddr_t addr;
-} __packed;
-
-#define HCI_OP_LE_REMOVE_DEV_WHITE_LIST 0x2012
-struct hci_cp_le_remove_dev_white_list {
-	__u8     addr_type;
-	bdaddr_t addr;
-} __packed;
-
 #define HCI_OP_LE_CONN_UPDATE		0x2013
 struct hci_cp_le_conn_update {
 	__le16   handle;
@@ -1003,16 +871,6 @@
 	__le16   max_ce_len;
 } __packed;
 
-#define HCI_OP_LE_ENCRYPT		0x2017
-struct hci_cp_le_encrypt {
-	__u8	key[16];
-	__u8	data[16];
-} __packed;
-struct hci_cp_le_encrypt_reply {
-	__u8     status;
-	__u8     encrypted[16];
-} __packed;
-
 #define HCI_OP_LE_START_ENC		0x2019
 struct hci_cp_le_start_enc {
 	__le16	handle;
@@ -1153,9 +1011,14 @@
 } __packed;
 
 #define HCI_EV_NUM_COMP_PKTS		0x13
+struct hci_comp_pkts_info {
+	__le16   handle;
+	__le16   count;
+} __packed;
+
 struct hci_ev_num_comp_pkts {
 	__u8     num_hndl;
-	/* variable length part */
+	struct hci_comp_pkts_info handles[0];
 } __packed;
 
 #define HCI_EV_MODE_CHANGE		0x14
@@ -1295,8 +1158,8 @@
 } __packed;
 
 #define HCI_EV_USER_PASSKEY_REQUEST	0x34
-struct hci_ev_user_passkey_request {
-	bdaddr_t bdaddr;
+struct hci_ev_user_passkey_req {
+	bdaddr_t	bdaddr;
 } __packed;
 
 #define HCI_EV_REMOTE_OOB_DATA_REQUEST	0x35
@@ -1310,12 +1173,6 @@
 	bdaddr_t bdaddr;
 } __packed;
 
-#define HCI_EV_USER_PASSKEY_NOTIFICATION	0x3b
-struct hci_ev_user_passkey_notification {
-	bdaddr_t	bdaddr;
-	__le32		passkey;
-} __packed;
-
 #define HCI_EV_REMOTE_HOST_FEATURES	0x3d
 struct hci_ev_remote_host_features {
 	bdaddr_t bdaddr;
@@ -1327,6 +1184,19 @@
 	__u8     subevent;
 } __packed;
 
+#define HCI_EV_NUM_COMP_BLOCKS		0x48
+struct hci_comp_blocks_info {
+	__le16   handle;
+	__le16   pkts;
+	__le16   blocks;
+} __packed;
+
+struct hci_ev_num_comp_blocks {
+	__le16   num_blocks;
+	__u8     num_hndl;
+	struct hci_comp_blocks_info handles[0];
+} __packed;
+
 /* Low energy meta events */
 #define HCI_EV_LE_CONN_COMPLETE		0x01
 struct hci_ev_le_conn_complete {
@@ -1341,6 +1211,14 @@
 	__u8     clk_accurancy;
 } __packed;
 
+#define HCI_EV_LE_LTK_REQ		0x05
+struct hci_ev_le_ltk_req {
+	__le16	handle;
+	__u8	random[8];
+	__le16	ediv;
+} __packed;
+
+/* Advertising report event types */
 #define ADV_IND		0x00
 #define ADV_DIRECT_IND	0x01
 #define ADV_SCAN_IND	0x02
@@ -1359,81 +1237,6 @@
 	__u8	 data[0];
 } __packed;
 
-#define HCI_EV_LE_CONN_UPDATE_COMPLETE	0x03
-struct hci_ev_le_conn_update_complete {
-	__u8     status;
-	__le16   handle;
-	__le16   interval;
-	__le16   latency;
-	__le16   supervision_timeout;
-} __packed;
-
-#define HCI_EV_LE_LTK_REQ		0x05
-struct hci_ev_le_ltk_req {
-	__le16	handle;
-	__u8	random[8];
-	__le16	ediv;
-} __packed;
-
-#define HCI_EV_PHYS_LINK_COMPLETE	0x40
-struct hci_ev_phys_link_complete {
-	__u8     status;
-	__u8     phy_handle;
-} __packed;
-
-#define HCI_EV_CHANNEL_SELECTED		0x41
-struct hci_ev_channel_selected {
-	__u8     phy_handle;
-} __packed;
-
-#define HCI_EV_DISCONN_PHYS_LINK_COMPLETE	0x42
-struct hci_ev_disconn_phys_link_complete {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     reason;
-} __packed;
-
-#define HCI_EV_LOG_LINK_COMPLETE	0x45
-struct hci_ev_log_link_complete {
-	__u8     status;
-	__le16   log_handle;
-	__u8     phy_handle;
-	__u8     flow_spec_id;
-} __packed;
-
-#define HCI_EV_DISCONN_LOG_LINK_COMPLETE	0x46
-struct hci_ev_disconn_log_link_complete {
-	__u8     status;
-	__le16   log_handle;
-	__u8     reason;
-} __packed;
-
-#define HCI_EV_FLOW_SPEC_MODIFY_COMPLETE	0x47
-struct hci_ev_flow_spec_modify_complete {
-	__u8     status;
-	__le16   log_handle;
-} __packed;
-
-#define HCI_EV_NUM_COMP_BLOCKS		0x48
-struct hci_ev_num_comp_blocks {
-	__le16   total_num_blocks;
-	__u8     num_hndl;
-	/* variable length part */
-} __packed;
-
-#define HCI_EV_SHORT_RANGE_MODE_COMPLETE	0x4c
-struct hci_ev_short_range_mode_complete {
-	__u8     status;
-	__u8     phy_handle;
-	__u8     mode;
-} __packed;
-
-#define HCI_EV_AMP_STATUS_CHANGE	0x4d
-struct hci_ev_amp_status_change {
-	__u8     status;
-	__u8     amp_status;
-} __packed;
-
 /* Internal events generated by Bluetooth stack */
 #define HCI_EV_STACK_INTERNAL	0xfd
 struct hci_ev_stack_internal {
@@ -1481,7 +1284,6 @@
 	__u8	dlen;
 } __packed;
 
-#ifdef __KERNEL__
 #include <linux/skbuff.h>
 static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
 {
@@ -1497,7 +1299,6 @@
 {
 	return (struct hci_sco_hdr *) skb->data;
 }
-#endif
 
 /* Command opcode pack/unpack */
 #define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
@@ -1528,7 +1329,8 @@
 #define HCI_DEV_NONE	0xffff
 
 #define HCI_CHANNEL_RAW		0
-#define HCI_CHANNEL_CONTROL	1
+#define HCI_CHANNEL_MONITOR	2
+#define HCI_CHANNEL_CONTROL	3
 
 struct hci_filter {
 	unsigned long type_mask;
@@ -1591,11 +1393,6 @@
 	__u8     out;
 	__u16    state;
 	__u32    link_mode;
-	__u32    mtu;
-	__u32    cnt;
-	__u32    pkts;
-	__u8     pending_sec_level;
-	__u8     ssp_mode;
 };
 
 struct hci_dev_req {
@@ -1634,4 +1431,7 @@
 };
 #define IREQ_CACHE_FLUSH 0x0001
 
+extern bool enable_hs;
+extern bool enable_le;
+
 #endif /* __HCI_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci_core.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci_core.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci_core.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci_core.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012, The Linux Foundation. All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,11 +25,11 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
+#include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
-#include <linux/wakelock.h>
-/* HCI upper protocols */
-#define HCI_PROTO_L2CAP	0
-#define HCI_PROTO_SCO	1
+
+/* HCI priority */
+#define HCI_PRIO_MAX	7
 
 /* HCI Core structures */
 struct inquiry_data {
@@ -44,30 +44,40 @@
 };
 
 struct inquiry_entry {
-	struct inquiry_entry	*next;
+	struct list_head	all;		/* inq_cache.all */
+	struct list_head	list;		/* unknown or resolve */
+	enum {
+		NAME_NOT_KNOWN,
+		NAME_NEEDED,
+		NAME_PENDING,
+		NAME_KNOWN,
+	} name_state;
 	__u32			timestamp;
 	struct inquiry_data	data;
 };
 
-struct inquiry_cache {
-	spinlock_t		lock;
+struct discovery_state {
+	int			type;
+	enum {
+		DISCOVERY_STOPPED,
+		DISCOVERY_STARTING,
+		DISCOVERY_FINDING,
+		DISCOVERY_RESOLVING,
+		DISCOVERY_STOPPING,
+	} state;
+	struct list_head	all;		/* All devices found during inquiry */
+	struct list_head	unknown;	/* Name state not known */
+	struct list_head	resolve;	/* Name needs to be resolved */
 	__u32			timestamp;
-	struct inquiry_entry	*list;
 };
 
 struct hci_conn_hash {
 	struct list_head list;
-	spinlock_t       lock;
 	unsigned int     acl_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;
 };
 
-struct hci_chan_list {
-	struct list_head list;
-	spinlock_t       lock;
-};
-
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -79,37 +89,24 @@
 	u8 svc_hint;
 };
 
-struct key_master_id {
+struct smp_ltk {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+	u8 authenticated;
+	u8 type;
+	u8 enc_size;
 	__le16 ediv;
 	u8 rand[8];
-} __packed;
-
-#define KEY_TYPE_LE_BASE	0x11
-#define KEY_TYPE_LTK		0x11
-#define KEY_TYPE_IRK		0x12
-#define KEY_TYPE_CSRK		0x13
-
-struct link_key_data {
-	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
 	u8 val[16];
-	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[0];
 } __packed;
 
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
+	u8 type;
 	u8 val[16];
 	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[0];
 };
 
 struct oob_data {
@@ -123,14 +120,21 @@
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
-	u8 flags;
 };
 
+struct le_scan_params {
+	u8 type;
+	u16 interval;
+	u16 window;
+	int timeout;
+};
+
+#define HCI_MAX_SHORT_NAME_LENGTH	10
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
-	spinlock_t	lock;
-	atomic_t	refcnt;
+	struct mutex	lock;
 
 	char		name[8];
 	unsigned long	flags;
@@ -139,13 +143,14 @@
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
+	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
+	__u8		host_features[8];
 	__u8		commands[64];
-	__u8		ssp_mode;
 	__u8		hci_ver;
 	__u16		hci_rev;
 	__u8		lmp_ver;
@@ -174,7 +179,9 @@
 	__u32		amp_max_flush_to;
 	__u32		amp_be_flush_to;
 
-	__s8		is_wbs;
+	__u8		flow_ctl_mode;
+
+	unsigned int	auto_accept_delay;
 
 	unsigned long	quirks;
 
@@ -183,17 +190,17 @@
 	unsigned int	sco_cnt;
 	unsigned int	le_cnt;
 
-	__u8	flow_ctl_mode;
-
 	unsigned int	acl_mtu;
 	unsigned int	sco_mtu;
 	unsigned int	le_mtu;
 	unsigned int	acl_pkts;
 	unsigned int	sco_pkts;
 	unsigned int	le_pkts;
-	unsigned int	le_white_list_size;
 
-	unsigned int	data_block_len;
+	__u16		block_len;
+	__u16		block_mtu;
+	__u16		num_blocks;
+	__u16		block_cnt;
 
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
@@ -202,13 +209,18 @@
 	struct workqueue_struct	*workqueue;
 
 	struct work_struct	power_on;
-	struct work_struct	power_off;
-	struct timer_list	off_timer;
+	struct delayed_work	power_off;
+
+	__u16			discov_timeout;
+	struct delayed_work	discov_off;
+
+	struct delayed_work	service_cache;
 
 	struct timer_list	cmd_timer;
-	struct tasklet_struct	cmd_task;
-	struct tasklet_struct	rx_task;
-	struct tasklet_struct	tx_task;
+
+	struct work_struct	rx_work;
+	struct work_struct	cmd_work;
+	struct work_struct	tx_work;
 
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;
@@ -224,34 +236,27 @@
 
 	__u16			init_last_cmd;
 
-	struct crypto_blkcipher	*tfm;
+	struct list_head	mgmt_pending;
 
-	struct inquiry_cache	inq_cache;
+	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;
-	struct hci_chan_list	chan_list;
 	struct list_head	blacklist;
 
 	struct list_head	uuids;
 
 	struct list_head	link_keys;
 
+	struct list_head	long_term_keys;
+
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
-	rwlock_t		adv_entries_lock;
-	struct timer_list	adv_timer;
-
-	struct timer_list	disco_timer;
-	struct timer_list	disco_le_timer;
-	__u8			disco_state;
-	int			disco_int_phase;
-	int			disco_int_count;
+	struct delayed_work	adv_work;
 
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
 
-	void			*driver_data;
 	void			*core_data;
 
 	atomic_t		promisc;
@@ -263,13 +268,17 @@
 
 	struct rfkill		*rfkill;
 
-	struct module		*owner;
+	unsigned long		dev_flags;
+
+	struct delayed_work	le_scan_disable;
+
+	struct work_struct	le_scan;
+	struct le_scan_params	le_scan_params;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
 	int (*send)(struct sk_buff *skb);
-	void (*destruct)(struct hci_dev *hdev);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
 };
@@ -278,85 +287,53 @@
 	struct list_head list;
 
 	atomic_t	refcnt;
-	spinlock_t	lock;
 
 	bdaddr_t	dst;
-	__u8		 dst_id;
-	__u8            dst_type;
+	__u8		dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;
 	__u8		type;
-	__u8		out;
+	bool		out;
 	__u8		attempt;
 	__u8		dev_class[3];
 	__u8		features[8];
-	__u8		ssp_mode;
 	__u16		interval;
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;
+	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
 	__u8		pending_sec_level;
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
-	__u8		auth_initiator;
-	__u8		power_save;
 	__u16		disc_timeout;
-	__u16		conn_timeout;
-	unsigned long	pend;
+	unsigned long	flags;
 
 	__u8		remote_cap;
-	__u8		remote_oob;
 	__u8		remote_auth;
-
-	__s8	rssi_threshold;
-	__u16	rssi_update_interval;
-	__u8	rssi_update_thresh_exceed;
+	bool		flush_key;
 
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
+	struct list_head chan_list;
 
-	struct timer_list disc_timer;
+	struct delayed_work disc_work;
 	struct timer_list idle_timer;
-	struct delayed_work	rssi_update_work;
-	struct timer_list encrypt_pause_timer;
+	struct timer_list auto_accept_timer;
 
-	struct work_struct work_add;
-	struct work_struct work_del;
-	struct wake_lock idle_lock;
 	struct device	dev;
 	atomic_t	devref;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
-	void		*priv;
-
-	__u8             link_key[16];
-	__u8             key_type;
-
-	struct hci_conn	*link;
-
-	/* Low Energy SMP pairing data */
-	__u8		oob; /* OOB pairing supported */
-	__u8		tk_valid; /* TK value is valid */
-	__u8		cfm_pending; /* CONFIRM cmd may be sent */
-	__u8		preq[7]; /* Pairing Request */
-	__u8		prsp[7]; /* Pairing Response */
-	__u8		prnd[16]; /* Pairing Random */
-	__u8		pcnf[16]; /* Pairing Confirm */
-	__u8		tk[16]; /* Temporary Key */
-	__u8		smp_key_size;
-	__u8		sec_req;
-	__u8		auth;
 	void		*smp_conn;
-	struct timer_list smp_timer;
-	__u8		conn_valid;
 
+	struct hci_conn	*link;
 
 	void (*connect_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*security_cfm_cb)	(struct hci_conn *conn, u8 status);
@@ -365,47 +342,54 @@
 
 struct hci_chan {
 	struct list_head list;
-	struct hci_dev	*hdev;
-	__u16		state;
-	atomic_t	refcnt;
-	__u16		ll_handle;
-	struct hci_ext_fs	tx_fs;
-	struct hci_ext_fs	rx_fs;
-	struct hci_conn	*conn;
-	void		*l2cap_sk;
+
+	struct hci_conn *conn;
+	struct sk_buff_head data_q;
+	unsigned int	sent;
 };
 
-extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
+/* ----- HCI interface to upper protocols ----- */
+extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
+extern int l2cap_disconn_ind(struct hci_conn *hcon);
+extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
+extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
+extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+
+extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
+extern int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
+extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
-#define INQUIRY_ENTRY_AGE_MAX   (HZ*60*60)   /* 1 Hour */
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
-#define inquiry_cache_lock(c)		spin_lock(&c->lock)
-#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
-#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
-#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
-
-static inline void inquiry_cache_init(struct hci_dev *hdev)
-{
-	struct inquiry_cache *c = &hdev->inq_cache;
-	spin_lock_init(&c->lock);
-	c->list = NULL;
+static inline void discovery_init(struct hci_dev *hdev)
+{
+	hdev->discovery.state = DISCOVERY_STOPPED;
+	INIT_LIST_HEAD(&hdev->discovery.all);
+	INIT_LIST_HEAD(&hdev->discovery.unknown);
+	INIT_LIST_HEAD(&hdev->discovery.resolve);
 }
 
+bool hci_discovery_active(struct hci_dev *hdev);
+
+void hci_discovery_set_state(struct hci_dev *hdev, int state);
+
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
-	return c->list == NULL;
+	return list_empty(&hdev->discovery.all);
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
+	struct discovery_state *c = &hdev->discovery;
 	return jiffies - c->timestamp;
 }
 
@@ -414,31 +398,53 @@
 	return jiffies - e->timestamp;
 }
 
-struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
+					       bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr,
+						       int state);
+void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
+				      struct inquiry_entry *ie);
+bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+			      bool name_known, bool *ssp);
 
 /* ----- HCI Connections ----- */
 enum {
 	HCI_CONN_AUTH_PEND,
+	HCI_CONN_REAUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
+	HCI_CONN_LE_SMP_PEND,
+	HCI_CONN_MGMT_CONNECTED,
+	HCI_CONN_SSP_ENABLED,
+	HCI_CONN_POWER_SAVE,
+	HCI_CONN_REMOTE_OOB,
 };
 
+static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	return (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
+				test_bit(HCI_CONN_SSP_ENABLED, &conn->flags));
+}
+
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
 	h->acl_num = 0;
 	h->sco_num = 0;
+	h->le_num = 0;
 }
 
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_add(&c->list, &h->list);
+	list_add_rcu(&c->list, &h->list);
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num++;
@@ -456,7 +462,10 @@
 static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_del(&c->list);
+
+	list_del_rcu(&c->list);
+	synchronize_rcu();
+
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num--;
@@ -471,55 +480,58 @@
 	}
 }
 
+static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	switch (type) {
+	case ACL_LINK:
+		return h->acl_num;
+	case LE_LINK:
+		return h->le_num;
+	case SCO_LINK:
+	case ESCO_LINK:
+		return h->sco_num;
+	default:
+		return 0;
+	}
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->handle == handle)
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->handle == handle) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
+	rcu_read_unlock();
 
-static inline void hci_chan_list_init(struct hci_dev *hdev)
-{
-	struct hci_chan_list *h = &hdev->chan_list;
-	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
+	return NULL;
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 							__u8 type, bdaddr_t *ba)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && !bacmp(&c->dst, ba))
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && !bacmp(&c->dst, ba)) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
 
-static inline struct hci_conn *hci_conn_hash_lookup_id(struct hci_dev *hdev,
-					bdaddr_t *ba, __u8 id)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
-	struct hci_conn  *c;
+	rcu_read_unlock();
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (!bacmp(&c->dst, ba) && (c->dst_id == id))
-			return c;
-	}
 	return NULL;
 }
 
@@ -527,44 +539,19 @@
 							__u8 type, __u16 state)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && c->state == state)
-			return c;
-	}
-	return NULL;
-}
-
-static inline struct hci_chan *hci_chan_list_lookup_handle(struct hci_dev *hdev,
-					__u16 handle)
-{
-	struct hci_chan_list *l = &hdev->chan_list;
-	struct list_head *p;
-	struct hci_chan  *c;
+	rcu_read_lock();
 
-	list_for_each(p, &l->list) {
-		c = list_entry(p, struct hci_chan, list);
-		if (c->ll_handle == handle)
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && c->state == state) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
-	return NULL;
-}
 
-static inline struct hci_chan *hci_chan_list_lookup_id(struct hci_dev *hdev,
-					__u8 handle)
-{
-	struct hci_chan_list *l = &hdev->chan_list;
-	struct list_head *p;
-	struct hci_chan  *c;
+	rcu_read_unlock();
 
-	list_for_each(p, &l->list) {
-		c = list_entry(p, struct hci_chan, list);
-		if (c->conn->handle == handle)
-			return c;
-	}
 	return NULL;
 }
 
@@ -574,60 +561,32 @@
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst);
-struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
-							__u8 addr_type);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
-void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process);
+void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_chan *hci_chan_add(struct hci_dev *hdev);
+struct hci_chan *hci_chan_create(struct hci_conn *conn);
 int hci_chan_del(struct hci_chan *chan);
-static inline void hci_chan_hold(struct hci_chan *chan)
-{
-	atomic_inc(&chan->refcnt);
-}
-int hci_chan_put(struct hci_chan *chan);
+void hci_chan_list_flush(struct hci_conn *conn);
 
-struct hci_chan *hci_chan_create(struct hci_chan *chan,
-				struct hci_ext_fs *tx_fs,
-				struct hci_ext_fs *rx_fs);
-void hci_chan_modify(struct hci_chan *chan,
-				struct hci_ext_fs *tx_fs,
-				struct hci_ext_fs *rx_fs);
-
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst,
-					__u8 sec_level, __u8 auth_type);
-struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
-					bdaddr_t *dst, __u8 sec_level,
-					__u8 auth_type,
-					struct bt_le_params *le_params);
-void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
-void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
-void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+						__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
-void hci_disconnect(struct hci_conn *conn, __u8 reason);
-void hci_disconnect_amp(struct hci_conn *conn, __u8 reason);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
-void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 void hci_conn_hold_device(struct hci_conn *conn);
 void hci_conn_put_device(struct hci_conn *conn);
 
-void hci_conn_set_rssi_reporter(struct hci_conn *conn,
-		s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed);
-void hci_conn_unset_rssi_reporter(struct hci_conn *conn);
-
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	del_timer(&conn->disc_timer);
+	cancel_delayed_work(&conn->disc_work);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
@@ -639,54 +598,54 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 4;
-			} else
+					timeo *= 2;
+			} else {
 				timeo = msecs_to_jiffies(10);
-		} else
+			}
+		} else {
 			timeo = msecs_to_jiffies(10);
-		mod_timer(&conn->disc_timer, jiffies + timeo);
+		}
+		cancel_delayed_work(&conn->disc_work);
+		queue_delayed_work(conn->hdev->workqueue,
+					&conn->disc_work, timeo);
 	}
 }
 
 /* ----- HCI Devices ----- */
-static inline void __hci_dev_put(struct hci_dev *d)
-{
-	if (atomic_dec_and_test(&d->refcnt))
-		d->destruct(d);
-}
-
 static inline void hci_dev_put(struct hci_dev *d)
 {
-	__hci_dev_put(d);
-	module_put(d->owner);
+	put_device(&d->dev);
 }
 
-static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
+static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 {
-	atomic_inc(&d->refcnt);
+	get_device(&d->dev);
 	return d;
 }
 
-static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
+#define hci_dev_lock(d)		mutex_lock(&d->lock)
+#define hci_dev_unlock(d)	mutex_unlock(&d->lock)
+
+#define to_hci_dev(d) container_of(d, struct hci_dev, dev)
+#define to_hci_conn(c) container_of(c, struct hci_conn, dev)
+
+static inline void *hci_get_drvdata(struct hci_dev *hdev)
 {
-	if (try_module_get(d->owner))
-		return __hci_dev_hold(d);
-	return NULL;
+	return dev_get_drvdata(&hdev->dev);
 }
 
-#define hci_dev_lock(d)		spin_lock(&d->lock)
-#define hci_dev_unlock(d)	spin_unlock(&d->lock)
-#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
-#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
+{
+	dev_set_drvdata(&hdev->dev, data);
+}
 
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
-struct hci_dev *hci_dev_get_type(__u8 amp_type);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);
 int hci_register_dev(struct hci_dev *hdev);
-int hci_unregister_dev(struct hci_dev *hdev);
+void hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);
@@ -699,23 +658,27 @@
 int hci_get_conn_list(void __user *arg);
 int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
-int hci_set_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-						u8 *key, u8 type, u8 pin_len);
-struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
-struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
-					bdaddr_t *bdaddr, u8 type);
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr, u8 type,
-		u8 auth, u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
+int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
+		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
+int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16 ediv,
+		u8 rand[8]);
+struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 addr_type);
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
@@ -739,8 +702,9 @@
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
-int hci_register_sysfs(struct hci_dev *hdev);
-void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_init_sysfs(struct hci_dev *hdev);
+int hci_add_sysfs(struct hci_dev *hdev);
+void hci_del_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
@@ -756,55 +720,46 @@
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
+#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
 
-/* ----- HCI protocols ----- */
-struct hci_proto {
-	char		*name;
-	unsigned int	id;
-	unsigned long	flags;
-
-	void		*priv;
+/* ----- Extended LMP capabilities ----- */
+#define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
 
-	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
-	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
-	int (*disconn_ind)	(struct hci_conn *conn);
-	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason,
-							__u8 is_process);
-	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
-	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
-	int (*create_cfm)	(struct hci_chan *chan, __u8 status);
-	int (*modify_cfm)	(struct hci_chan *chan, __u8 status);
-	int (*destroy_cfm)	(struct hci_chan *chan, __u8 status);
-};
-
-static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+/* ----- HCI protocols ----- */
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								__u8 type)
 {
-	register struct hci_proto *hp;
-	int mask = 0;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	switch (type) {
+	case ACL_LINK:
+		return l2cap_connect_ind(hdev, bdaddr);
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	case SCO_LINK:
+	case ESCO_LINK:
+		return sco_connect_ind(hdev, bdaddr);
 
-	return mask;
+	default:
+		BT_ERR("unknown link type %d", type);
+		return -EINVAL;
+	}
 }
 
 static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_connect_cfm(conn, status);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_connect_cfm(conn, status);
+		break;
+
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->connect_cfm_cb)
 		conn->connect_cfm_cb(conn, status);
@@ -812,32 +767,29 @@
 
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
-	register struct hci_proto *hp;
-	int reason = 0x13;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return HCI_ERROR_REMOTE_USER_TERM;
 
-	return reason;
+	return l2cap_disconn_ind(conn);
 }
 
-static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason,
-							__u8 is_process)
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason, is_process);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason, is_process);
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->disconn_cfm_cb)
 		conn->disconn_cfm_cb(conn, reason);
@@ -845,79 +797,41 @@
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
 	__u8 encrypt;
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
 		return;
 
-	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
+		return;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_create_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->create_cfm)
-		hp->create_cfm(chan, status);
-}
-
-static inline void hci_proto_modify_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->modify_cfm)
-		hp->modify_cfm(chan, status);
-}
-
-static inline void hci_proto_destroy_cfm(struct hci_chan *chan, __u8 status)
-{
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->destroy_cfm)
-		hp->destroy_cfm(chan, status);
-}
-
-int hci_register_proto(struct hci_proto *hproto);
-int hci_unregister_proto(struct hci_proto *hproto);
-
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;
 
 	char *name;
 
-	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
+								__u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -929,150 +843,196 @@
 
 	hci_proto_auth_cfm(conn, status);
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
 	struct list_head *p;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
 
-	if (!status && encrypt && conn->pending_sec_level > conn->sec_level)
+	if (conn->pending_sec_level > conn->sec_level)
 		conn->sec_level = conn->pending_sec_level;
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
+								__u8 role)
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
-int hci_register_cb(struct hci_cb *hcb);
-int hci_unregister_cb(struct hci_cb *hcb);
+static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
+{
+	size_t parsed = 0;
 
-int hci_register_notifier(struct notifier_block *nb);
-int hci_unregister_notifier(struct notifier_block *nb);
+	if (data_len < 2)
+		return false;
 
-/* AMP Manager event callbacks */
-struct amp_mgr_cb {
-	struct list_head list;
-	void (*amp_cmd_complete_event) (struct hci_dev *hdev, __u16 opcode,
-					struct sk_buff *skb);
-	void (*amp_cmd_status_event) (struct hci_dev *hdev, __u16 opcode,
-					__u8 status);
-	void (*amp_event) (struct hci_dev *hdev, __u8 ev_code,
-					struct sk_buff *skb);
-};
+	while (parsed < data_len - 1) {
+		u8 field_len = data[0];
+
+		if (field_len == 0)
+			break;
+
+		parsed += field_len + 1;
 
-void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
-			struct sk_buff *skb);
-void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status);
-void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
-			struct sk_buff *skb);
+		if (parsed > data_len)
+			break;
 
-int hci_register_amp(struct amp_mgr_cb *acb);
-int hci_unregister_amp(struct amp_mgr_cb *acb);
+		if (data[1] == type)
+			return true;
+
+		data += field_len + 1;
+	}
+
+	return false;
+}
+
+static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
+				  u8 data_len)
+{
+	eir[eir_len++] = sizeof(type) + data_len;
+	eir[eir_len++] = type;
+	memcpy(&eir[eir_len], data, data_len);
+	eir_len += data_len;
+
+	return eir_len;
+}
+
+int hci_register_cb(struct hci_cb *hcb);
+int hci_unregister_cb(struct hci_cb *hcb);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
-		struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
-void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
-
 /* ----- HCI Sockets ----- */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
-							struct sock *skip_sk);
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
+void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
+
+void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
 /* Management interface */
+#define MGMT_ADDR_BREDR			0x00
+#define MGMT_ADDR_LE_PUBLIC		0x01
+#define MGMT_ADDR_LE_RANDOM		0x02
+#define MGMT_ADDR_INVALID		0xff
+
+#define DISCOV_TYPE_BREDR		(BIT(MGMT_ADDR_BREDR))
+#define DISCOV_TYPE_LE			(BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+#define DISCOV_TYPE_INTERLEAVED		(BIT(MGMT_ADDR_BREDR) | \
+						BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
-int mgmt_index_added(u16 index);
-int mgmt_index_removed(u16 index);
-int mgmt_powered(u16 index, u8 powered);
-int mgmt_discoverable(u16 index, u8 discoverable);
-int mgmt_connectable(u16 index, u8 connectable);
-int mgmt_new_key(u16 index, struct link_key *key, u8 bonded);
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le);
-int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
-						u16 latency, u16 timeout);
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason);
-int mgmt_disconnect_failed(u16 index);
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
-int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_request(u16 index, u8 event, bdaddr_t *bdaddr,
-							__le32 value);
-int mgmt_user_oob_request(u16 index, bdaddr_t *bdaddr);
-int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
-int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
-								u8 status);
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
-				u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir);
-void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
-				u16 handle, u8 status);
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name);
-void mgmt_inquiry_started(u16 index);
-void mgmt_inquiry_complete_evt(u16 index, u8 status);
-void mgmt_disco_timeout(unsigned long data);
-void mgmt_disco_le_timeout(unsigned long data);
-int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status);
-
-/* LE SMP Management interface */
-int le_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, void *cp);
-int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3]);
-int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
-							u16 sub_ver);
-int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8]);
+int mgmt_index_added(struct hci_dev *hdev);
+int mgmt_index_removed(struct hci_dev *hdev);
+int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
+int mgmt_powered(struct hci_dev *hdev, u8 powered);
+int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
+int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
+int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
+int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
+		      bool persistent);
+int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			  u8 *dev_class);
+int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 link_type, u8 addr_type);
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 link_type, u8 addr_type, u8 status);
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			u8 addr_type, u8 status);
+int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
+int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				 u8 status);
+int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 status);
+int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 confirm_hint);
+int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type);
+int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, u8 status);
+int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+				   u8 status);
+int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
+int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+					    u8 *randomizer, u8 status);
+int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
+		      u8 ssp, u8 *eir, u16 eir_len);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
+int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
+int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
+int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+int mgmt_interleaved_discovery(struct hci_dev *hdev);
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+
+int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
@@ -1111,6 +1071,9 @@
 void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
-void hci_read_rssi(struct hci_conn *conn);
+int hci_do_inquiry(struct hci_dev *hdev, u8 length);
+int hci_cancel_inquiry(struct hci_dev *hdev);
+int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
+		int timeout);
 
 #endif /* __HCI_CORE_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/hci_mon.h flo-ElementalX-5.00-patched/include/net/bluetooth/hci_mon.h
--- flo-ElementalX-5.00/include/net/bluetooth/hci_mon.h	1970-01-01 00:00:00.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/hci_mon.h	2016-06-02 00:28:55.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+
+   Copyright (C) 2011-2012  Intel Corporation
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_MON_H
+#define __HCI_MON_H
+
+struct hci_mon_hdr {
+	__le16	opcode;
+	__le16	index;
+	__le16	len;
+} __packed;
+#define HCI_MON_HDR_SIZE 6
+
+#define HCI_MON_NEW_INDEX	0
+#define HCI_MON_DEL_INDEX	1
+#define HCI_MON_COMMAND_PKT	2
+#define HCI_MON_EVENT_PKT	3
+#define HCI_MON_ACL_TX_PKT	4
+#define HCI_MON_ACL_RX_PKT	5
+#define HCI_MON_SCO_TX_PKT	6
+#define HCI_MON_SCO_RX_PKT	7
+
+struct hci_mon_new_index {
+	__u8		type;
+	__u8		bus;
+	bdaddr_t	bdaddr;
+	char		name[8];
+} __packed;
+#define HCI_MON_NEW_INDEX_SIZE 16
+
+#endif /* __HCI_MON_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/l2cap.h flo-ElementalX-5.00-patched/include/net/bluetooth/l2cap.h
--- flo-ElementalX-5.00/include/net/bluetooth/l2cap.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/l2cap.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
 
@@ -27,32 +27,29 @@
 #ifndef __L2CAP_H
 #define __L2CAP_H
 
+#include <asm/unaligned.h>
+
 /* L2CAP defaults */
 #define L2CAP_DEFAULT_MTU		672
 #define L2CAP_DEFAULT_MIN_MTU		48
-#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xffff
 #define L2CAP_DEFAULT_FLUSH_TO		0xffff
-#define L2CAP_MAX_FLUSH_TO		0x7ff
 #define L2CAP_DEFAULT_TX_WINDOW		63
+#define L2CAP_DEFAULT_EXT_WINDOW	0x3FFF
 #define L2CAP_DEFAULT_MAX_TX		3
 #define L2CAP_DEFAULT_RETRANS_TO	2000    /* 2 seconds */
 #define L2CAP_DEFAULT_MONITOR_TO	12000   /* 12 seconds */
-#define L2CAP_DEFAULT_MAX_PDU_SIZE	1482    /* Sized for AMP or BR/EDR */
+#define L2CAP_DEFAULT_MAX_PDU_SIZE	1009    /* Sized for 3-DH5 packet */
 #define L2CAP_DEFAULT_ACK_TO		200
-#define L2CAP_BREDR_MAX_PAYLOAD		1019    /* 3-DH5 packet */
-#define L2CAP_MAX_ERTM_QUEUED		5
-#define L2CAP_MIN_ERTM_QUEUED		2
-
-#define L2CAP_A2MP_DEFAULT_MTU		670
-
-#define L2CAP_TX_WIN_MAX_ENHANCED	0x3f
-#define L2CAP_TX_WIN_MAX_EXTENDED	0x3fff
 #define L2CAP_LE_DEFAULT_MTU		23
-
-#define L2CAP_CONN_TIMEOUT	(40000) /* 40 seconds */
-#define L2CAP_INFO_TIMEOUT	(4000)  /*  4 seconds */
-#define L2CAP_MOVE_TIMEOUT		(4*HZ)  /*  4 seconds */
-#define L2CAP_MOVE_ERTX_TIMEOUT		(60*HZ) /* 60 seconds */
+#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xFFFF
+#define L2CAP_DEFAULT_SDU_ITIME		0xFFFFFFFF
+#define L2CAP_DEFAULT_ACC_LAT		0xFFFFFFFF
+
+#define L2CAP_DISC_TIMEOUT		msecs_to_jiffies(100)
+#define L2CAP_DISC_REJ_TIMEOUT		msecs_to_jiffies(5000)
+#define L2CAP_ENC_TIMEOUT		msecs_to_jiffies(5000)
+#define L2CAP_CONN_TIMEOUT		msecs_to_jiffies(40000)
+#define L2CAP_INFO_TIMEOUT		msecs_to_jiffies(4000)
 
 /* L2CAP socket address */
 struct sockaddr_l2 {
@@ -87,35 +84,36 @@
 #define L2CAP_LM_TRUSTED	0x0008
 #define L2CAP_LM_RELIABLE	0x0010
 #define L2CAP_LM_SECURE		0x0020
-#define L2CAP_LM_FLUSHABLE	0x0040
 
 /* L2CAP command codes */
-#define L2CAP_COMMAND_REJ		0x01
-#define L2CAP_CONN_REQ			0x02
-#define L2CAP_CONN_RSP			0x03
-#define L2CAP_CONF_REQ			0x04
-#define L2CAP_CONF_RSP			0x05
-#define L2CAP_DISCONN_REQ		0x06
-#define L2CAP_DISCONN_RSP		0x07
-#define L2CAP_ECHO_REQ			0x08
-#define L2CAP_ECHO_RSP			0x09
-#define L2CAP_INFO_REQ			0x0a
-#define L2CAP_INFO_RSP			0x0b
+#define L2CAP_COMMAND_REJ	0x01
+#define L2CAP_CONN_REQ		0x02
+#define L2CAP_CONN_RSP		0x03
+#define L2CAP_CONF_REQ		0x04
+#define L2CAP_CONF_RSP		0x05
+#define L2CAP_DISCONN_REQ	0x06
+#define L2CAP_DISCONN_RSP	0x07
+#define L2CAP_ECHO_REQ		0x08
+#define L2CAP_ECHO_RSP		0x09
+#define L2CAP_INFO_REQ		0x0a
+#define L2CAP_INFO_RSP		0x0b
 #define L2CAP_CREATE_CHAN_REQ	0x0c
 #define L2CAP_CREATE_CHAN_RSP	0x0d
-#define L2CAP_MOVE_CHAN_REQ		0x0e
-#define L2CAP_MOVE_CHAN_RSP		0x0f
-#define L2CAP_MOVE_CHAN_CFM		0x10
+#define L2CAP_MOVE_CHAN_REQ	0x0e
+#define L2CAP_MOVE_CHAN_RSP	0x0f
+#define L2CAP_MOVE_CHAN_CFM	0x10
 #define L2CAP_MOVE_CHAN_CFM_RSP	0x11
 #define L2CAP_CONN_PARAM_UPDATE_REQ	0x12
 #define L2CAP_CONN_PARAM_UPDATE_RSP	0x13
 
-/* L2CAP feature mask */
+/* L2CAP extended feature mask */
 #define L2CAP_FEAT_FLOWCTL	0x00000001
 #define L2CAP_FEAT_RETRANS	0x00000002
+#define L2CAP_FEAT_BIDIR_QOS	0x00000004
 #define L2CAP_FEAT_ERTM		0x00000008
 #define L2CAP_FEAT_STREAMING	0x00000010
 #define L2CAP_FEAT_FCS		0x00000020
+#define L2CAP_FEAT_EXT_FLOW	0x00000040
 #define L2CAP_FEAT_FIXED_CHAN	0x00000080
 #define L2CAP_FEAT_EXT_WINDOW	0x00000100
 #define L2CAP_FEAT_UCD		0x00000200
@@ -128,52 +126,53 @@
 #define L2CAP_FC_L2CAP		0x02
 #define L2CAP_FC_A2MP		0x08
 
-/* L2CAP Control Field */
-#define L2CAP_CTRL_SAR               0xC000
-#define L2CAP_CTRL_REQSEQ            0x3F00
-#define L2CAP_CTRL_TXSEQ             0x007E
-#define L2CAP_CTRL_FINAL             0x0080
-#define L2CAP_CTRL_POLL              0x0010
-#define L2CAP_CTRL_SUPERVISE         0x000C
-#define L2CAP_CTRL_FRAME_TYPE        0x0001 /* I- or S-Frame */
-
-#define L2CAP_CTRL_TXSEQ_SHIFT      1
-#define L2CAP_CTRL_SUPERVISE_SHIFT  2
-#define L2CAP_CTRL_POLL_SHIFT       4
-#define L2CAP_CTRL_FINAL_SHIFT      7
-#define L2CAP_CTRL_REQSEQ_SHIFT     8
-#define L2CAP_CTRL_SAR_SHIFT       14
-
-#define L2CAP_EXT_CTRL_SAR           0x00030000
-#define L2CAP_EXT_CTRL_REQSEQ        0x0000FFFC
-#define L2CAP_EXT_CTRL_TXSEQ         0xFFFC0000
-#define L2CAP_EXT_CTRL_FINAL         0x00000002
-#define L2CAP_EXT_CTRL_POLL          0x00040000
-#define L2CAP_EXT_CTRL_SUPERVISE     0x00030000
-#define L2CAP_EXT_CTRL_FRAME_TYPE    0x00000001 /* I- or S-Frame */
-
-#define L2CAP_EXT_CTRL_FINAL_SHIFT      1
-#define L2CAP_EXT_CTRL_REQSEQ_SHIFT     2
-#define L2CAP_EXT_CTRL_SAR_SHIFT       16
-#define L2CAP_EXT_CTRL_SUPERVISE_SHIFT 16
-#define L2CAP_EXT_CTRL_POLL_SHIFT      18
-#define L2CAP_EXT_CTRL_TXSEQ_SHIFT     18
-
-/* L2CAP Supervisory Frame Types */
-#define L2CAP_SFRAME_RR            0x00
-#define L2CAP_SFRAME_REJ           0x01
-#define L2CAP_SFRAME_RNR           0x02
-#define L2CAP_SFRAME_SREJ          0x03
+/* L2CAP Control Field bit masks */
+#define L2CAP_CTRL_SAR			0xC000
+#define L2CAP_CTRL_REQSEQ		0x3F00
+#define L2CAP_CTRL_TXSEQ		0x007E
+#define L2CAP_CTRL_SUPERVISE		0x000C
+
+#define L2CAP_CTRL_RETRANS		0x0080
+#define L2CAP_CTRL_FINAL		0x0080
+#define L2CAP_CTRL_POLL			0x0010
+#define L2CAP_CTRL_FRAME_TYPE		0x0001 /* I- or S-Frame */
+
+#define L2CAP_CTRL_TXSEQ_SHIFT		1
+#define L2CAP_CTRL_SUPER_SHIFT		2
+#define L2CAP_CTRL_REQSEQ_SHIFT		8
+#define L2CAP_CTRL_SAR_SHIFT		14
+
+/* L2CAP Extended Control Field bit mask */
+#define L2CAP_EXT_CTRL_TXSEQ		0xFFFC0000
+#define L2CAP_EXT_CTRL_SAR		0x00030000
+#define L2CAP_EXT_CTRL_SUPERVISE	0x00030000
+#define L2CAP_EXT_CTRL_REQSEQ		0x0000FFFC
+
+#define L2CAP_EXT_CTRL_POLL		0x00040000
+#define L2CAP_EXT_CTRL_FINAL		0x00000002
+#define L2CAP_EXT_CTRL_FRAME_TYPE	0x00000001 /* I- or S-Frame */
+
+#define L2CAP_EXT_CTRL_REQSEQ_SHIFT	2
+#define L2CAP_EXT_CTRL_SAR_SHIFT	16
+#define L2CAP_EXT_CTRL_SUPER_SHIFT	16
+#define L2CAP_EXT_CTRL_TXSEQ_SHIFT	18
+
+/* L2CAP Supervisory Function */
+#define L2CAP_SUPER_RR		0x00
+#define L2CAP_SUPER_REJ		0x01
+#define L2CAP_SUPER_RNR		0x02
+#define L2CAP_SUPER_SREJ	0x03
 
 /* L2CAP Segmentation and Reassembly */
-#define L2CAP_SAR_UNSEGMENTED      0x00
-#define L2CAP_SAR_START            0x01
-#define L2CAP_SAR_END              0x02
-#define L2CAP_SAR_CONTINUE         0x03
-
-/* L2CAP ERTM / Streaming extra field lengths */
-#define L2CAP_SDULEN_SIZE       2
-#define L2CAP_FCS_SIZE          2
+#define L2CAP_SAR_UNSEGMENTED	0x00
+#define L2CAP_SAR_START		0x01
+#define L2CAP_SAR_END		0x02
+#define L2CAP_SAR_CONTINUE	0x03
+
+/* L2CAP Command rej. reasons */
+#define L2CAP_REJ_NOT_UNDERSTOOD	0x0000
+#define L2CAP_REJ_MTU_EXCEEDED		0x0001
+#define L2CAP_REJ_INVALID_CID		0x0002
 
 /* L2CAP structures */
 struct l2cap_hdr {
@@ -181,8 +180,12 @@
 	__le16     cid;
 } __packed;
 #define L2CAP_HDR_SIZE		4
-#define L2CAP_ENHANCED_HDR_SIZE	6
-#define L2CAP_EXTENDED_HDR_SIZE	8
+#define L2CAP_ENH_HDR_SIZE	6
+#define L2CAP_EXT_HDR_SIZE	8
+
+#define L2CAP_FCS_SIZE		2
+#define L2CAP_SDULEN_SIZE	2
+#define L2CAP_PSMLEN_SIZE	2
 
 struct l2cap_cmd_hdr {
 	__u8       code;
@@ -191,8 +194,19 @@
 } __packed;
 #define L2CAP_CMD_HDR_SIZE	4
 
-struct l2cap_cmd_rej {
+struct l2cap_cmd_rej_unk {
+	__le16     reason;
+} __packed;
+
+struct l2cap_cmd_rej_mtu {
 	__le16     reason;
+	__le16     max_mtu;
+} __packed;
+
+struct l2cap_cmd_rej_cid {
+	__le16     reason;
+	__le16     scid;
+	__le16     dcid;
 } __packed;
 
 struct l2cap_conn_req {
@@ -210,21 +224,21 @@
 /* channel indentifier */
 #define L2CAP_CID_SIGNALING	0x0001
 #define L2CAP_CID_CONN_LESS	0x0002
-#define L2CAP_CID_A2MP		0x0003
 #define L2CAP_CID_LE_DATA	0x0004
 #define L2CAP_CID_LE_SIGNALING	0x0005
 #define L2CAP_CID_SMP		0x0006
 #define L2CAP_CID_DYN_START	0x0040
 #define L2CAP_CID_DYN_END	0xffff
 
-/* connect result */
+/* connect/create channel results */
 #define L2CAP_CR_SUCCESS	0x0000
 #define L2CAP_CR_PEND		0x0001
 #define L2CAP_CR_BAD_PSM	0x0002
 #define L2CAP_CR_SEC_BLOCK	0x0003
 #define L2CAP_CR_NO_MEM		0x0004
+#define L2CAP_CR_BAD_AMP	0x0005
 
-/* connect status */
+/* connect/create channel status */
 #define L2CAP_CS_NO_INFO	0x0000
 #define L2CAP_CS_AUTHEN_PEND	0x0001
 #define L2CAP_CS_AUTHOR_PEND	0x0002
@@ -247,7 +261,7 @@
 #define L2CAP_CONF_REJECT	0x0002
 #define L2CAP_CONF_UNKNOWN	0x0003
 #define L2CAP_CONF_PENDING	0x0004
-#define L2CAP_CONF_FLOW_SPEC_REJECT	0x0005
+#define L2CAP_CONF_EFS_REJECT	0x0005
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -264,13 +278,8 @@
 #define L2CAP_CONF_QOS		0x03
 #define L2CAP_CONF_RFC		0x04
 #define L2CAP_CONF_FCS		0x05
-#define L2CAP_CONF_EXT_FS	0x06
-#define L2CAP_CONF_EXT_WINDOW	0x07
-
-/* QOS Service type */
-#define L2CAP_SERVICE_NO_TRAFFIC		0x00
-#define L2CAP_SERVICE_BEST_EFFORT		0x01
-#define L2CAP_SERVICE_GUARANTEED		0x02
+#define L2CAP_CONF_EFS		0x06
+#define L2CAP_CONF_EWS		0x07
 
 #define L2CAP_CONF_MAX_SIZE	22
 
@@ -283,26 +292,27 @@
 	__le16     max_pdu_size;
 } __packed;
 
-struct l2cap_conf_ext_fs {
-	__u8       id;
-	__u8       type;
-	__le16     max_sdu;
-	__le32     sdu_arr_time;
-	__le32     acc_latency;
-	__le32     flush_to;
-} __packed;
-
-struct l2cap_conf_prm {
-	__u8       fcs;
-	__le32     flush_to;
-};
-
 #define L2CAP_MODE_BASIC	0x00
 #define L2CAP_MODE_RETRANS	0x01
 #define L2CAP_MODE_FLOWCTL	0x02
 #define L2CAP_MODE_ERTM		0x03
 #define L2CAP_MODE_STREAMING	0x04
 
+struct l2cap_conf_efs {
+	__u8	id;
+	__u8	stype;
+	__le16	msdu;
+	__le32	sdu_itime;
+	__le32	acc_lat;
+	__le32	flush_to;
+} __packed;
+
+#define L2CAP_SERV_NOTRAFIC	0x00
+#define L2CAP_SERV_BESTEFFORT	0x01
+#define L2CAP_SERV_GUARANTEED	0x02
+
+#define L2CAP_BESTEFFORT_ID	0x01
+
 struct l2cap_disconn_req {
 	__le16     dcid;
 	__le16     scid;
@@ -327,83 +337,53 @@
 	__le16      psm;
 	__le16      scid;
 	__u8        amp_id;
-} __attribute__ ((packed));
+} __packed;
 
 struct l2cap_create_chan_rsp {
 	__le16      dcid;
 	__le16      scid;
 	__le16      result;
 	__le16      status;
-} __attribute__ ((packed));
-
-#define L2CAP_CREATE_CHAN_SUCCESS				(0x0000)
-#define L2CAP_CREATE_CHAN_PENDING				(0x0001)
-#define L2CAP_CREATE_CHAN_REFUSED_PSM			(0x0002)
-#define L2CAP_CREATE_CHAN_REFUSED_SECURITY		(0x0003)
-#define L2CAP_CREATE_CHAN_REFUSED_RESOURCES		(0x0004)
-#define L2CAP_CREATE_CHAN_REFUSED_CONTROLLER	(0x0005)
-
-#define L2CAP_CREATE_CHAN_STATUS_NONE			(0x0000)
-#define L2CAP_CREATE_CHAN_STATUS_AUTHENTICATION	(0x0001)
-#define L2CAP_CREATE_CHAN_STATUS_AUTHORIZATION	(0x0002)
+} __packed;
 
 struct l2cap_move_chan_req {
 	__le16      icid;
 	__u8        dest_amp_id;
-} __attribute__ ((packed));
+} __packed;
 
 struct l2cap_move_chan_rsp {
 	__le16      icid;
 	__le16      result;
-} __attribute__ ((packed));
+} __packed;
 
-#define L2CAP_MOVE_CHAN_SUCCESS				(0x0000)
-#define L2CAP_MOVE_CHAN_PENDING				(0x0001)
-#define L2CAP_MOVE_CHAN_REFUSED_CONTROLLER	(0x0002)
-#define L2CAP_MOVE_CHAN_REFUSED_SAME_ID		(0x0003)
-#define L2CAP_MOVE_CHAN_REFUSED_CONFIG		(0x0004)
-#define L2CAP_MOVE_CHAN_REFUSED_COLLISION	(0x0005)
-#define L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED	(0x0006)
+#define L2CAP_MR_SUCCESS	0x0000
+#define L2CAP_MR_PEND		0x0001
+#define L2CAP_MR_BAD_ID		0x0002
+#define L2CAP_MR_SAME_ID	0x0003
+#define L2CAP_MR_NOT_SUPP	0x0004
+#define L2CAP_MR_COLLISION	0x0005
+#define L2CAP_MR_NOT_ALLOWED	0x0006
 
 struct l2cap_move_chan_cfm {
 	__le16      icid;
 	__le16      result;
-} __attribute__ ((packed));
+} __packed;
 
-#define L2CAP_MOVE_CHAN_CONFIRMED	(0x0000)
-#define L2CAP_MOVE_CHAN_UNCONFIRMED	(0x0001)
+#define L2CAP_MC_CONFIRMED	0x0000
+#define L2CAP_MC_UNCONFIRMED	0x0001
 
 struct l2cap_move_chan_cfm_rsp {
 	__le16      icid;
-} __attribute__ ((packed));
-
-struct l2cap_amp_signal_work {
-	struct work_struct work;
-	struct l2cap_cmd_hdr cmd;
-	struct l2cap_conn *conn;
-	struct sk_buff *skb;
-	u8 *data;
-};
-
-struct l2cap_resegment_work {
-	struct work_struct work;
-	struct sock *sk;
-};
-
-struct l2cap_logical_link_work {
-	struct work_struct work;
-	struct hci_chan *chan;
-	u8 status;
-};
+} __packed;
 
 /* info type */
-#define L2CAP_IT_CL_MTU     0x0001
-#define L2CAP_IT_FEAT_MASK  0x0002
-#define L2CAP_IT_FIXED_CHAN 0x0003
+#define L2CAP_IT_CL_MTU		0x0001
+#define L2CAP_IT_FEAT_MASK	0x0002
+#define L2CAP_IT_FIXED_CHAN	0x0003
 
 /* info result */
-#define L2CAP_IR_SUCCESS    0x0000
-#define L2CAP_IR_NOTSUPP    0x0001
+#define L2CAP_IR_SUCCESS	0x0000
+#define L2CAP_IR_NOTSUPP	0x0001
 
 struct l2cap_conn_param_update_req {
 	__le16      min;
@@ -420,64 +400,21 @@
 #define L2CAP_CONN_PARAM_ACCEPTED	0x0000
 #define L2CAP_CONN_PARAM_REJECTED	0x0001
 
-/* ----- L2CAP connections ----- */
-struct l2cap_chan_list {
-	struct sock	*head;
-	rwlock_t	lock;
-};
-
-struct l2cap_conn {
-	struct hci_conn	*hcon;
-
-	bdaddr_t	*dst;
-	bdaddr_t	*src;
-
-	unsigned int	mtu;
-
-	__u32		feat_mask;
-	__u8		fc_mask;
-	struct amp_mgr *mgr;
-
-	__u8		info_state;
-	__u8		info_ident;
-
-	struct timer_list info_timer;
-
-	spinlock_t	lock;
-
-	struct sk_buff *rx_skb;
-	__u32		rx_len;
-	__u8		tx_ident;
-
-	__u8		disc_reason;
-
-	struct l2cap_chan_list chan_list;
+/* ----- L2CAP channels and connections ----- */
+struct srej_list {
+	__u16	tx_seq;
+	struct list_head list;
 };
 
-struct sock_del_list {
+struct l2cap_chan {
 	struct sock *sk;
-	struct list_head list;
-};
 
-#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
-#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
-#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
+	struct l2cap_conn	*conn;
 
-/* ----- L2CAP channel and socket info ----- */
-#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
-#define TX_QUEUE(sk) (&l2cap_pi(sk)->tx_queue)
-#define SREJ_QUEUE(sk) (&l2cap_pi(sk)->srej_queue)
+	__u8		state;
 
-struct l2cap_seq_list {
-	__u16 head;
-	__u16 tail;
-	__u16 size;
-	__u16 mask;
-	__u16 *list;
-};
+	atomic_t	refcnt;
 
-struct l2cap_pinfo {
-	struct bt_sock	bt;
 	__le16		psm;
 	__u16		dcid;
 	__u16		scid;
@@ -486,236 +423,443 @@
 	__u16		omtu;
 	__u16		flush_to;
 	__u8		mode;
-	__u8		fixed_channel;
-	__u8		num_conf_req;
-	__u8		num_conf_rsp;
-	__u8		incoming;
+	__u8		chan_type;
+	__u8		chan_policy;
+
+	__le16		sport;
 
-	__u8		fcs;
 	__u8		sec_level;
-	__u8		role_switch;
-	__u8		force_reliable;
-	__u8		flushable;
-	__u8		force_active;
+
+	__u8		ident;
 
 	__u8		conf_req[64];
 	__u8		conf_len;
-	__u8		conf_ident;
-	__u16		conf_state;
-	__u8		conn_state;
-	__u8		tx_state;
-	__u8		rx_state;
-	__u8		reconf_state;
-
-	__u8		amp_id;
-	__u8		amp_move_id;
-	__u8		amp_move_state;
-	__u8		amp_move_role;
-	__u8		amp_move_cmd_ident;
-	__u16		amp_move_reqseq;
-	__u16		amp_move_event;
+	__u8		num_conf_req;
+	__u8		num_conf_rsp;
+
+	__u8		fcs;
+
+	__u16		tx_win;
+	__u16		tx_win_max;
+	__u8		max_tx;
+	__u16		retrans_timeout;
+	__u16		monitor_timeout;
+	__u16		mps;
+
+	unsigned long	conf_state;
+	unsigned long	conn_state;
+	unsigned long	flags;
 
 	__u16		next_tx_seq;
 	__u16		expected_ack_seq;
 	__u16		expected_tx_seq;
 	__u16		buffer_seq;
+	__u16		buffer_seq_srej;
 	__u16		srej_save_reqseq;
-	__u16		last_acked_seq;
-	__u32		frames_sent;
+	__u16		frames_sent;
 	__u16		unacked_frames;
 	__u8		retry_count;
-	__u16		srej_queue_next;
+	__u8		num_acked;
 	__u16		sdu_len;
 	struct sk_buff	*sdu;
 	struct sk_buff	*sdu_last_frag;
-	atomic_t	ertm_queued;
-
-	__u8		ident;
 
-	__u16		tx_win;
-	__u16		tx_win_max;
-	__u16		ack_win;
-	__u8		max_tx;
-	__u8		amp_pref;
 	__u16		remote_tx_win;
 	__u8		remote_max_tx;
-	__u8		extended_control;
-	__u16		retrans_timeout;
-	__u16		monitor_timeout;
 	__u16		remote_mps;
-	__u16		mps;
 
-	__le16		sport;
+	__u8		local_id;
+	__u8		local_stype;
+	__u16		local_msdu;
+	__u32		local_sdu_itime;
+	__u32		local_acc_lat;
+	__u32		local_flush_to;
+
+	__u8		remote_id;
+	__u8		remote_stype;
+	__u16		remote_msdu;
+	__u32		remote_sdu_itime;
+	__u32		remote_acc_lat;
+	__u32		remote_flush_to;
+
+	struct delayed_work	chan_timer;
+	struct delayed_work	retrans_timer;
+	struct delayed_work	monitor_timer;
+	struct delayed_work	ack_timer;
+
+	struct sk_buff		*tx_send_head;
+	struct sk_buff_head	tx_q;
+	struct sk_buff_head	srej_q;
+	struct list_head	srej_l;
+
+	struct list_head	list;
+	struct list_head	global_l;
+
+	void			*data;
+	struct l2cap_ops	*ops;
+	struct mutex		lock;
+};
+
+struct l2cap_ops {
+	char			*name;
+
+	struct l2cap_chan	*(*new_connection) (void *data);
+	int			(*recv) (void *data, struct sk_buff *skb);
+	void			(*close) (void *data);
+	void			(*state_change) (void *data, int state);
+	struct sk_buff		*(*alloc_skb) (struct l2cap_chan *chan,
+					unsigned long len, int nb, int *err);
 
-	struct delayed_work	retrans_work;
-	struct delayed_work	monitor_work;
-	struct delayed_work	ack_work;
-	struct work_struct	tx_work;
-	struct sk_buff_head	tx_queue;
-	struct sk_buff_head	srej_queue;
-	struct l2cap_seq_list srej_list;
-	struct l2cap_seq_list retrans_list;
-	struct hci_conn	*ampcon;
-	struct hci_chan	*ampchan;
-	struct l2cap_conn	*conn;
-	struct l2cap_conf_prm local_conf;
-	struct l2cap_conf_prm remote_conf;
-	struct l2cap_conf_ext_fs local_fs;
-	struct l2cap_conf_ext_fs remote_fs;
-	struct sock		*next_c;
-	struct sock		*prev_c;
-};
-
-#define L2CAP_CONF_REQ_SENT       0x0001
-#define L2CAP_CONF_INPUT_DONE     0x0002
-#define L2CAP_CONF_OUTPUT_DONE    0x0004
-#define L2CAP_CONF_MTU_DONE       0x0008
-#define L2CAP_CONF_MODE_DONE      0x0010
-#define L2CAP_CONF_CONNECT_PEND   0x0020
-#define L2CAP_CONF_NO_FCS_RECV    0x0040
-#define L2CAP_CONF_STATE2_DEVICE  0x0080
-#define L2CAP_CONF_EXT_WIN_RECV   0x0100
-#define L2CAP_CONF_LOCKSTEP       0x0200
-#define L2CAP_CONF_LOCKSTEP_PEND  0x0400
-#define L2CAP_CONF_PEND_SENT      0x0800
-#define L2CAP_CONF_EFS_RECV       0x1000
+};
+
+struct l2cap_conn {
+	struct hci_conn		*hcon;
+	struct hci_chan		*hchan;
+
+	bdaddr_t		*dst;
+	bdaddr_t		*src;
+
+	unsigned int		mtu;
+
+	__u32			feat_mask;
+	__u8			fixed_chan_mask;
+
+	__u8			info_state;
+	__u8			info_ident;
+
+	struct delayed_work	info_timer;
+
+	spinlock_t		lock;
+
+	struct sk_buff		*rx_skb;
+	__u32			rx_len;
+	__u8			tx_ident;
+
+	__u8			disc_reason;
+
+	struct delayed_work	security_timer;
+	struct smp_chan		*smp_chan;
+
+	struct list_head	chan_l;
+	struct mutex		chan_lock;
+};
+
+#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
+#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
+#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
+
+#define L2CAP_CHAN_RAW			1
+#define L2CAP_CHAN_CONN_LESS		2
+#define L2CAP_CHAN_CONN_ORIENTED	3
+
+/* ----- L2CAP socket info ----- */
+#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
+
+struct l2cap_pinfo {
+	struct bt_sock		bt;
+	struct l2cap_chan	*chan;
+	struct sk_buff		*rx_busy_skb;
+};
+
+enum {
+	CONF_REQ_SENT,
+	CONF_INPUT_DONE,
+	CONF_OUTPUT_DONE,
+	CONF_MTU_DONE,
+	CONF_MODE_DONE,
+	CONF_CONNECT_PEND,
+	CONF_NO_FCS_RECV,
+	CONF_STATE2_DEVICE,
+	CONF_EWS_RECV,
+	CONF_LOC_CONF_PEND,
+	CONF_REM_CONF_PEND,
+};
 
 #define L2CAP_CONF_MAX_CONF_REQ 2
 #define L2CAP_CONF_MAX_CONF_RSP 2
 
-#define L2CAP_RECONF_NONE          0x00
-#define L2CAP_RECONF_INT           0x01
-#define L2CAP_RECONF_ACC           0x02
-
-#define L2CAP_CONN_SREJ_ACT        0x01
-#define L2CAP_CONN_REJ_ACT         0x02
-#define L2CAP_CONN_REMOTE_BUSY     0x04
-#define L2CAP_CONN_LOCAL_BUSY      0x08
-#define L2CAP_CONN_SEND_FBIT       0x10
-#define L2CAP_CONN_SENT_RNR        0x20
-
-#define L2CAP_SEQ_LIST_CLEAR       0xFFFF
-#define L2CAP_SEQ_LIST_TAIL        0x8000
-
-#define L2CAP_ERTM_TX_STATE_XMIT          0x01
-#define L2CAP_ERTM_TX_STATE_WAIT_F        0x02
-
-#define L2CAP_ERTM_RX_STATE_RECV                    0x01
-#define L2CAP_ERTM_RX_STATE_SREJ_SENT               0x02
-#define L2CAP_ERTM_RX_STATE_AMP_MOVE                0x03
-#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG             0x04
-#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE 0x05
-#define L2CAP_ERTM_RX_STATE_WAIT_F_FLAG             0x06
-
-#define L2CAP_ERTM_TXSEQ_EXPECTED        0x00
-#define L2CAP_ERTM_TXSEQ_EXPECTED_SREJ   0x01
-#define L2CAP_ERTM_TXSEQ_UNEXPECTED      0x02
-#define L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ 0x03
-#define L2CAP_ERTM_TXSEQ_DUPLICATE       0x04
-#define L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ  0x05
-#define L2CAP_ERTM_TXSEQ_INVALID         0x06
-#define L2CAP_ERTM_TXSEQ_INVALID_IGNORE  0x07
-
-#define L2CAP_ERTM_EVENT_DATA_REQUEST          0x01
-#define L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED   0x02
-#define L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR      0x03
-#define L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT  0x04
-#define L2CAP_ERTM_EVENT_RECV_FBIT             0x05
-#define L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES 0x06
-#define L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES 0x07
-#define L2CAP_ERTM_EVENT_EXPLICIT_POLL         0x08
-#define L2CAP_ERTM_EVENT_RECV_IFRAME           0x09
-#define L2CAP_ERTM_EVENT_RECV_RR               0x0a
-#define L2CAP_ERTM_EVENT_RECV_REJ              0x0b
-#define L2CAP_ERTM_EVENT_RECV_RNR              0x0c
-#define L2CAP_ERTM_EVENT_RECV_SREJ             0x0d
-#define L2CAP_ERTM_EVENT_RECV_FRAME            0x0e
-
-#define L2CAP_AMP_MOVE_NONE      0
-#define L2CAP_AMP_MOVE_INITIATOR 1
-#define L2CAP_AMP_MOVE_RESPONDER 2
-
-#define L2CAP_AMP_STATE_STABLE			0
-#define L2CAP_AMP_STATE_WAIT_CREATE		1
-#define L2CAP_AMP_STATE_WAIT_CREATE_RSP		2
-#define L2CAP_AMP_STATE_WAIT_MOVE		3
-#define L2CAP_AMP_STATE_WAIT_MOVE_RSP		4
-#define L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS	5
-#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM	6
-#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP	7
-#define L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE	8
-#define L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM	9
-#define L2CAP_AMP_STATE_WAIT_LOCAL_BUSY		10
-#define L2CAP_AMP_STATE_WAIT_PREPARE		11
-#define L2CAP_AMP_STATE_RESEGMENT		12
-
-#define L2CAP_ATT_ERROR				0x01
-#define L2CAP_ATT_MTU_REQ			0x02
-#define L2CAP_ATT_MTU_RSP			0x03
-#define L2CAP_ATT_RESPONSE_BIT			0x01
-#define L2CAP_ATT_INDICATE			0x1D
-#define L2CAP_ATT_CONFIRM			0x1E
-#define L2CAP_ATT_NOT_SUPPORTED			0x06
-
-#define __delta_seq(x, y, pi) ((x) >= (y) ? (x) - (y) : \
-				(pi)->tx_win_max + 1 - (y) + (x))
-#define __next_seq(x, pi) ((x + 1) & ((pi)->tx_win_max))
+enum {
+	CONN_SREJ_SENT,
+	CONN_WAIT_F,
+	CONN_SREJ_ACT,
+	CONN_SEND_PBIT,
+	CONN_REMOTE_BUSY,
+	CONN_LOCAL_BUSY,
+	CONN_REJ_ACT,
+	CONN_SEND_FBIT,
+	CONN_RNR_SENT,
+};
+
+/* Definitions for flags in l2cap_chan */
+enum {
+	FLAG_ROLE_SWITCH,
+	FLAG_FORCE_ACTIVE,
+	FLAG_FORCE_RELIABLE,
+	FLAG_FLUSHABLE,
+	FLAG_EXT_CTRL,
+	FLAG_EFS_ENABLE,
+};
+
+static inline void l2cap_chan_hold(struct l2cap_chan *c)
+{
+	atomic_inc(&c->refcnt);
+}
+
+static inline void l2cap_chan_put(struct l2cap_chan *c)
+{
+	if (atomic_dec_and_test(&c->refcnt))
+		kfree(c);
+}
+
+static inline void l2cap_chan_lock(struct l2cap_chan *chan)
+{
+	mutex_lock(&chan->lock);
+}
+
+static inline void l2cap_chan_unlock(struct l2cap_chan *chan)
+{
+	mutex_unlock(&chan->lock);
+}
+
+static inline void l2cap_set_timer(struct l2cap_chan *chan,
+					struct delayed_work *work, long timeout)
+{
+	BT_DBG("chan %p state %s timeout %ld", chan,
+					state_to_string(chan->state), timeout);
+
+	if (!cancel_delayed_work(work))
+		l2cap_chan_hold(chan);
+	schedule_delayed_work(work, timeout);
+}
+
+static inline bool l2cap_clear_timer(struct l2cap_chan *chan,
+					struct delayed_work *work)
+{
+	bool ret;
+
+	ret = cancel_delayed_work(work);
+	if (ret)
+		l2cap_chan_put(chan);
+
+	return ret;
+}
+
+#define __set_chan_timer(c, t) l2cap_set_timer(c, &c->chan_timer, (t))
+#define __clear_chan_timer(c) l2cap_clear_timer(c, &c->chan_timer)
+#define __set_retrans_timer(c) l2cap_set_timer(c, &c->retrans_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_RETRANS_TO));
+#define __clear_retrans_timer(c) l2cap_clear_timer(c, &c->retrans_timer)
+#define __set_monitor_timer(c) l2cap_set_timer(c, &c->monitor_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_MONITOR_TO));
+#define __clear_monitor_timer(c) l2cap_clear_timer(c, &c->monitor_timer)
+#define __set_ack_timer(c) l2cap_set_timer(c, &chan->ack_timer, \
+		msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
+#define __clear_ack_timer(c) l2cap_clear_timer(c, &c->ack_timer)
+
+static inline int __seq_offset(struct l2cap_chan *chan, __u16 seq1, __u16 seq2)
+{
+	int offset;
+
+	offset = (seq1 - seq2) % (chan->tx_win_max + 1);
+	if (offset < 0)
+		offset += (chan->tx_win_max + 1);
+
+	return offset;
+}
+
+static inline __u16 __next_seq(struct l2cap_chan *chan, __u16 seq)
+{
+	return (seq + 1) % (chan->tx_win_max + 1);
+}
+
+static inline int l2cap_tx_window_full(struct l2cap_chan *ch)
+{
+	int sub;
+
+	sub = (ch->next_tx_seq - ch->expected_ack_seq) % 64;
+
+	if (sub < 0)
+		sub += 64;
+
+	return sub == ch->remote_tx_win;
+}
+
+static inline __u16 __get_reqseq(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_REQSEQ) >>
+						L2CAP_EXT_CTRL_REQSEQ_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;
+}
+
+static inline __u32 __set_reqseq(struct l2cap_chan *chan, __u32 reqseq)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
+							L2CAP_EXT_CTRL_REQSEQ;
+	else
+		return (reqseq << L2CAP_CTRL_REQSEQ_SHIFT) & L2CAP_CTRL_REQSEQ;
+}
+
+static inline __u16 __get_txseq(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_TXSEQ) >>
+						L2CAP_EXT_CTRL_TXSEQ_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;
+}
+
+static inline __u32 __set_txseq(struct l2cap_chan *chan, __u32 txseq)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
+							L2CAP_EXT_CTRL_TXSEQ;
+	else
+		return (txseq << L2CAP_CTRL_TXSEQ_SHIFT) & L2CAP_CTRL_TXSEQ;
+}
+
+static inline bool __is_sframe(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_FRAME_TYPE;
+	else
+		return ctrl & L2CAP_CTRL_FRAME_TYPE;
+}
+
+static inline __u32 __set_sframe(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_FRAME_TYPE;
+	else
+		return L2CAP_CTRL_FRAME_TYPE;
+}
+
+static inline __u8 __get_ctrl_sar(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;
+}
+
+static inline __u32 __set_ctrl_sar(struct l2cap_chan *chan, __u32 sar)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (sar << L2CAP_EXT_CTRL_SAR_SHIFT) & L2CAP_EXT_CTRL_SAR;
+	else
+		return (sar << L2CAP_CTRL_SAR_SHIFT) & L2CAP_CTRL_SAR;
+}
+
+static inline bool __is_sar_start(struct l2cap_chan *chan, __u32 ctrl)
+{
+	return __get_ctrl_sar(chan, ctrl) == L2CAP_SAR_START;
+}
+
+static inline __u32 __get_sar_mask(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_SAR;
+	else
+		return L2CAP_CTRL_SAR;
+}
+
+static inline __u8 __get_ctrl_super(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (ctrl & L2CAP_EXT_CTRL_SUPERVISE) >>
+						L2CAP_EXT_CTRL_SUPER_SHIFT;
+	else
+		return (ctrl & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;
+}
+
+static inline __u32 __set_ctrl_super(struct l2cap_chan *chan, __u32 super)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return (super << L2CAP_EXT_CTRL_SUPER_SHIFT) &
+						L2CAP_EXT_CTRL_SUPERVISE;
+	else
+		return (super << L2CAP_CTRL_SUPER_SHIFT) &
+							L2CAP_CTRL_SUPERVISE;
+}
+
+static inline __u32 __set_ctrl_final(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_FINAL;
+	else
+		return L2CAP_CTRL_FINAL;
+}
+
+static inline bool __is_ctrl_final(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_FINAL;
+	else
+		return ctrl & L2CAP_CTRL_FINAL;
+}
+
+static inline __u32 __set_ctrl_poll(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_CTRL_POLL;
+	else
+		return L2CAP_CTRL_POLL;
+}
+
+static inline bool __is_ctrl_poll(struct l2cap_chan *chan, __u32 ctrl)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return ctrl & L2CAP_EXT_CTRL_POLL;
+	else
+		return ctrl & L2CAP_CTRL_POLL;
+}
+
+static inline __u32 __get_control(struct l2cap_chan *chan, void *p)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return get_unaligned_le32(p);
+	else
+		return get_unaligned_le16(p);
+}
+
+static inline void __put_control(struct l2cap_chan *chan, __u32 control,
+								void *p)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return put_unaligned_le32(control, p);
+	else
+		return put_unaligned_le16(control, p);
+}
+
+static inline __u8 __ctrl_size(struct l2cap_chan *chan)
+{
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		return L2CAP_EXT_HDR_SIZE - L2CAP_HDR_SIZE;
+	else
+		return L2CAP_ENH_HDR_SIZE - L2CAP_HDR_SIZE;
+}
 
 extern bool disable_ertm;
-extern const struct proto_ops l2cap_sock_ops;
-extern struct bt_sock_list l2cap_sk_list;
 
 int l2cap_init_sockets(void);
 void l2cap_cleanup_sockets(void);
 
-u8 l2cap_get_ident(struct l2cap_conn *conn);
-void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data);
-int l2cap_build_conf_req(struct sock *sk, void *data);
+void __l2cap_connect_rsp_defer(struct l2cap_chan *chan);
 int __l2cap_wait_ack(struct sock *sk);
 
-struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len);
-struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len);
-struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg,
-				size_t len, u16 sdulen, int reseg);
-int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
-			struct msghdr *msg, size_t len, int reseg);
-int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue);
-void l2cap_do_send(struct sock *sk, struct sk_buff *skb);
-void l2cap_streaming_send(struct sock *sk);
-int l2cap_ertm_send(struct sock *sk);
-int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs);
-int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff_head *skbs, u8 event);
-
-int l2cap_sock_le_params_valid(struct bt_le_params *le_params);
-void l2cap_sock_set_timer(struct sock *sk, long timeout);
-void l2cap_sock_clear_timer(struct sock *sk);
-void __l2cap_sock_close(struct sock *sk, int reason);
-void l2cap_sock_kill(struct sock *sk);
-void l2cap_sock_init(struct sock *sk, struct sock *parent);
-struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
-							int proto, gfp_t prio);
-struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
-						bdaddr_t *dst, int server);
-void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err);
-void l2cap_chan_del(struct sock *sk, int err);
-int l2cap_do_connect(struct sock *sk);
-int l2cap_data_channel(struct sock *sk, struct sk_buff *skb);
-void l2cap_amp_move_init(struct sock *sk);
-void l2cap_ertm_destruct(struct sock *sk);
-void l2cap_ertm_shutdown(struct sock *sk);
-void l2cap_ertm_recv_done(struct sock *sk);
-
-void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt);
-
-void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb);
-
-void l2cap_amp_physical_complete(int result, u8 remote_id, u8 local_id,
-				struct sock *sk);
-
-void l2cap_amp_logical_complete(int result, struct hci_conn *ampcon,
-				struct hci_chan *ampchan, struct sock *sk);
+int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm);
+int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid);
 
-void l2cap_amp_logical_destroyed(struct hci_conn *ampcon);
+struct l2cap_chan *l2cap_chan_create(struct sock *sk);
+void l2cap_chan_close(struct l2cap_chan *chan, int reason);
+void l2cap_chan_destroy(struct l2cap_chan *chan);
+int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
+								bdaddr_t *dst);
+int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
+								u32 priority);
+void l2cap_chan_busy(struct l2cap_chan *chan, int busy);
+int l2cap_chan_check_security(struct l2cap_chan *chan);
 
 #endif /* __L2CAP_H */
diff -urN flo-ElementalX-5.00/include/net/bluetooth/mgmt.h flo-ElementalX-5.00-patched/include/net/bluetooth/mgmt.h
--- flo-ElementalX-5.00/include/net/bluetooth/mgmt.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/mgmt.h	2016-06-02 00:28:55.000000000 +0000
@@ -2,6 +2,7 @@
    BlueZ - Bluetooth protocol stack for Linux
 
    Copyright (C) 2010  Nokia Corporation
+   Copyright (C) 2011-2012  Intel Corporation
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -23,399 +24,440 @@
 
 #define MGMT_INDEX_NONE			0xFFFF
 
+#define MGMT_STATUS_SUCCESS		0x00
+#define MGMT_STATUS_UNKNOWN_COMMAND	0x01
+#define MGMT_STATUS_NOT_CONNECTED	0x02
+#define MGMT_STATUS_FAILED		0x03
+#define MGMT_STATUS_CONNECT_FAILED	0x04
+#define MGMT_STATUS_AUTH_FAILED		0x05
+#define MGMT_STATUS_NOT_PAIRED		0x06
+#define MGMT_STATUS_NO_RESOURCES	0x07
+#define MGMT_STATUS_TIMEOUT		0x08
+#define MGMT_STATUS_ALREADY_CONNECTED	0x09
+#define MGMT_STATUS_BUSY		0x0a
+#define MGMT_STATUS_REJECTED		0x0b
+#define MGMT_STATUS_NOT_SUPPORTED	0x0c
+#define MGMT_STATUS_INVALID_PARAMS	0x0d
+#define MGMT_STATUS_DISCONNECTED	0x0e
+#define MGMT_STATUS_NOT_POWERED		0x0f
+#define MGMT_STATUS_CANCELLED		0x10
+#define MGMT_STATUS_INVALID_INDEX	0x11
+#define MGMT_STATUS_RFKILLED		0x12
+
 struct mgmt_hdr {
-	__le16 opcode;
-	__le16 index;
-	__le16 len;
+	__le16	opcode;
+	__le16	index;
+	__le16	len;
 } __packed;
 
+struct mgmt_addr_info {
+	bdaddr_t	bdaddr;
+	__u8		type;
+} __packed;
+#define MGMT_ADDR_INFO_SIZE		7
+
 #define MGMT_OP_READ_VERSION		0x0001
+#define MGMT_READ_VERSION_SIZE		0
 struct mgmt_rp_read_version {
-	__u8 version;
-	__le16 revision;
+	__u8	version;
+	__le16	revision;
+} __packed;
+
+#define MGMT_OP_READ_COMMANDS		0x0002
+#define MGMT_READ_COMMANDS_SIZE		0
+struct mgmt_rp_read_commands {
+	__le16	num_commands;
+	__le16	num_events;
+	__le16	opcodes[0];
 } __packed;
 
 #define MGMT_OP_READ_INDEX_LIST		0x0003
+#define MGMT_READ_INDEX_LIST_SIZE	0
 struct mgmt_rp_read_index_list {
-	__le16 num_controllers;
-	__le16 index[0];
+	__le16	num_controllers;
+	__le16	index[0];
 } __packed;
 
 /* Reserve one extra byte for names in management messages so that they
  * are always guaranteed to be nul-terminated */
 #define MGMT_MAX_NAME_LENGTH		(HCI_MAX_NAME_LENGTH + 1)
+#define MGMT_MAX_SHORT_NAME_LENGTH	(HCI_MAX_SHORT_NAME_LENGTH + 1)
+
+#define MGMT_SETTING_POWERED		0x00000001
+#define MGMT_SETTING_CONNECTABLE	0x00000002
+#define MGMT_SETTING_FAST_CONNECTABLE	0x00000004
+#define MGMT_SETTING_DISCOVERABLE	0x00000008
+#define MGMT_SETTING_PAIRABLE		0x00000010
+#define MGMT_SETTING_LINK_SECURITY	0x00000020
+#define MGMT_SETTING_SSP		0x00000040
+#define MGMT_SETTING_BREDR		0x00000080
+#define MGMT_SETTING_HS			0x00000100
+#define MGMT_SETTING_LE			0x00000200
 
 #define MGMT_OP_READ_INFO		0x0004
+#define MGMT_READ_INFO_SIZE		0
 struct mgmt_rp_read_info {
-	__u8 type;
-	__u8 powered;
-	__u8 connectable;
-	__u8 discoverable;
-	__u8 pairable;
-	__u8 sec_mode;
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
-	__u8 features[8];
-	__u16 manufacturer;
-	__u8 hci_ver;
-	__u16 hci_rev;
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-	__u8 le_white_list_size;
+	bdaddr_t	bdaddr;
+	__u8		version;
+	__le16		manufacturer;
+	__le32		supported_settings;
+	__le32		current_settings;
+	__u8		dev_class[3];
+	__u8		name[MGMT_MAX_NAME_LENGTH];
+	__u8		short_name[MGMT_MAX_SHORT_NAME_LENGTH];
 } __packed;
 
 struct mgmt_mode {
 	__u8 val;
 } __packed;
 
+#define MGMT_SETTING_SIZE		1
+
 #define MGMT_OP_SET_POWERED		0x0005
 
 #define MGMT_OP_SET_DISCOVERABLE	0x0006
+struct mgmt_cp_set_discoverable {
+	__u8	val;
+	__le16	timeout;
+} __packed;
+#define MGMT_SET_DISCOVERABLE_SIZE	3
 
 #define MGMT_OP_SET_CONNECTABLE		0x0007
 
-#define MGMT_OP_SET_PAIRABLE		0x0008
+#define MGMT_OP_SET_FAST_CONNECTABLE	0x0008
+
+#define MGMT_OP_SET_PAIRABLE		0x0009
+
+#define MGMT_OP_SET_LINK_SECURITY	0x000A
+
+#define MGMT_OP_SET_SSP			0x000B
+
+#define MGMT_OP_SET_HS			0x000C
+
+#define MGMT_OP_SET_LE			0x000D
+#define MGMT_OP_SET_DEV_CLASS		0x000E
+struct mgmt_cp_set_dev_class {
+	__u8	major;
+	__u8	minor;
+} __packed;
+#define MGMT_SET_DEV_CLASS_SIZE		2
+
+#define MGMT_OP_SET_LOCAL_NAME		0x000F
+struct mgmt_cp_set_local_name {
+	__u8	name[MGMT_MAX_NAME_LENGTH];
+	__u8	short_name[MGMT_MAX_SHORT_NAME_LENGTH];
+} __packed;
+#define MGMT_SET_LOCAL_NAME_SIZE	260
 
-#define MGMT_OP_ADD_UUID		0x0009
+#define MGMT_OP_ADD_UUID		0x0010
 struct mgmt_cp_add_uuid {
-	__u8 uuid[16];
-	__u8 svc_hint;
+	__u8	uuid[16];
+	__u8	svc_hint;
 } __packed;
+#define MGMT_ADD_UUID_SIZE		17
 
-#define MGMT_OP_REMOVE_UUID		0x000A
+#define MGMT_OP_REMOVE_UUID		0x0011
 struct mgmt_cp_remove_uuid {
-	__u8 uuid[16];
+	__u8	uuid[16];
 } __packed;
+#define MGMT_REMOVE_UUID_SIZE		16
 
-#define MGMT_OP_SET_DEV_CLASS		0x000B
-struct mgmt_cp_set_dev_class {
-	__u8 major;
-	__u8 minor;
+struct mgmt_link_key_info {
+	struct mgmt_addr_info addr;
+	__u8	type;
+	__u8	val[16];
+	__u8	pin_len;
 } __packed;
-#define MGMT_MAJOR_CLASS_MASK		0x1F
-#define MGMT_MAJOR_CLASS_LIMITED	0x20
 
-#define MGMT_OP_SET_SERVICE_CACHE	0x000C
-struct mgmt_cp_set_service_cache {
-	__u8 enable;
-} __packed;
-
-struct mgmt_key_info {
-	bdaddr_t bdaddr;
-	u8 addr_type;
-	u8 key_type;
-	u8 val[16];
-	u8 pin_len;
-	u8 auth;
-	u8 dlen;
-	u8 data[10];
-} __packed;
-
-#define MGMT_OP_LOAD_KEYS		0x000D
-struct mgmt_cp_load_keys {
-	__u8 debug_keys;
-	__le16 key_count;
-	struct mgmt_key_info keys[0];
-} __packed;
-
-#define MGMT_OP_REMOVE_KEY		0x000E
-struct mgmt_cp_remove_key {
-	bdaddr_t bdaddr;
-	__u8 disconnect;
+#define MGMT_OP_LOAD_LINK_KEYS		0x0012
+struct mgmt_cp_load_link_keys {
+	__u8	debug_keys;
+	__le16	key_count;
+	struct	mgmt_link_key_info keys[0];
+} __packed;
+#define MGMT_LOAD_LINK_KEYS_SIZE	3
+
+struct mgmt_ltk_info {
+	struct mgmt_addr_info addr;
+	__u8	authenticated;
+	__u8	master;
+	__u8	enc_size;
+	__le16	ediv;
+	__u8	rand[8];
+	__u8	val[16];
 } __packed;
 
-#define MGMT_OP_DISCONNECT		0x000F
+#define MGMT_OP_LOAD_LONG_TERM_KEYS	0x0013
+struct mgmt_cp_load_long_term_keys {
+	__le16	key_count;
+	struct	mgmt_ltk_info keys[0];
+} __packed;
+#define MGMT_LOAD_LONG_TERM_KEYS_SIZE	2
+
+#define MGMT_OP_DISCONNECT		0x0014
 struct mgmt_cp_disconnect {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_DISCONNECT_SIZE		MGMT_ADDR_INFO_SIZE
 struct mgmt_rp_disconnect {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_GET_CONNECTIONS		0x0010
+#define MGMT_OP_GET_CONNECTIONS		0x0015
+#define MGMT_GET_CONNECTIONS_SIZE	0
 struct mgmt_rp_get_connections {
 	__le16 conn_count;
-	bdaddr_t conn[0];
+	struct mgmt_addr_info addr[0];
 } __packed;
 
-#define MGMT_OP_PIN_CODE_REPLY		0x0011
+#define MGMT_OP_PIN_CODE_REPLY		0x0016
 struct mgmt_cp_pin_code_reply {
-	bdaddr_t bdaddr;
-	__u8 pin_len;
-	__u8 pin_code[16];
+	struct mgmt_addr_info addr;
+	__u8	pin_len;
+	__u8	pin_code[16];
 } __packed;
+#define MGMT_PIN_CODE_REPLY_SIZE	(MGMT_ADDR_INFO_SIZE + 17)
 struct mgmt_rp_pin_code_reply {
-	bdaddr_t bdaddr;
-	uint8_t status;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0012
+#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0017
 struct mgmt_cp_pin_code_neg_reply {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_PIN_CODE_NEG_REPLY_SIZE	MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_SET_IO_CAPABILITY	0x0013
+#define MGMT_OP_SET_IO_CAPABILITY	0x0018
 struct mgmt_cp_set_io_capability {
-	__u8 io_capability;
+	__u8	io_capability;
 } __packed;
+#define MGMT_SET_IO_CAPABILITY_SIZE	1
 
-#define MGMT_OP_PAIR_DEVICE		0x0014
+#define MGMT_OP_PAIR_DEVICE		0x0019
 struct mgmt_cp_pair_device {
-	bdaddr_t bdaddr;
-	__u8 io_cap;
+	struct mgmt_addr_info addr;
+	__u8	io_cap;
 } __packed;
+#define MGMT_PAIR_DEVICE_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
 struct mgmt_rp_pair_device {
-	bdaddr_t bdaddr;
-	__u8 status;
-} __packed;
-
-#define MGMT_OP_USER_CONFIRM_REPLY	0x0015
-struct mgmt_cp_user_confirm_reply {
-	bdaddr_t bdaddr;
-} __packed;
-struct mgmt_rp_user_confirm_reply {
-	bdaddr_t bdaddr;
-	__u8 status;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x0016
+#define MGMT_OP_CANCEL_PAIR_DEVICE	0x001A
+#define MGMT_CANCEL_PAIR_DEVICE_SIZE	MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_SET_LOCAL_NAME		0x0017
-struct mgmt_cp_set_local_name {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
+#define MGMT_OP_UNPAIR_DEVICE		0x001B
+struct mgmt_cp_unpair_device {
+	struct mgmt_addr_info addr;
+	__u8 disconnect;
 } __packed;
+#define MGMT_UNPAIR_DEVICE_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
+struct mgmt_rp_unpair_device {
+	struct mgmt_addr_info addr;
+};
 
-#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0018
-struct mgmt_rp_read_local_oob_data {
-	__u8 hash[16];
-	__u8 randomizer[16];
+#define MGMT_OP_USER_CONFIRM_REPLY	0x001C
+struct mgmt_cp_user_confirm_reply {
+	struct mgmt_addr_info addr;
 } __packed;
-
-#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0019
-struct mgmt_cp_add_remote_oob_data {
-	bdaddr_t bdaddr;
-	__u8 hash[16];
-	__u8 randomizer[16];
+#define MGMT_USER_CONFIRM_REPLY_SIZE	MGMT_ADDR_INFO_SIZE
+struct mgmt_rp_user_confirm_reply {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x001A
-struct mgmt_cp_remove_remote_oob_data {
-	bdaddr_t bdaddr;
+#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x001D
+struct mgmt_cp_user_confirm_neg_reply {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_USER_CONFIRM_NEG_REPLY_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_START_DISCOVERY		0x001B
-
-#define MGMT_OP_STOP_DISCOVERY		0x001C
-
-#define MGMT_OP_USER_PASSKEY_REPLY	0x001D
+#define MGMT_OP_USER_PASSKEY_REPLY	0x001E
 struct mgmt_cp_user_passkey_reply {
-	bdaddr_t bdaddr;
-	__le32 passkey;
+	struct mgmt_addr_info addr;
+	__le32	passkey;
 } __packed;
-
-#define MGMT_OP_RESOLVE_NAME		0x001E
-struct mgmt_cp_resolve_name {
-	bdaddr_t bdaddr;
+#define MGMT_USER_PASSKEY_REPLY_SIZE	(MGMT_ADDR_INFO_SIZE + 4)
+struct mgmt_rp_user_passkey_reply {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_SET_LIMIT_DISCOVERABLE	0x001F
-
-#define MGMT_OP_SET_CONNECTION_PARAMS	0x0020
-struct mgmt_cp_set_connection_params {
-	bdaddr_t bdaddr;
-	__le16 interval_min;
-	__le16 interval_max;
-	__le16 slave_latency;
-	__le16 timeout_multiplier;
+#define MGMT_OP_USER_PASSKEY_NEG_REPLY	0x001F
+struct mgmt_cp_user_passkey_neg_reply {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_USER_PASSKEY_NEG_REPLY_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_ENCRYPT_LINK		0x0021
-struct mgmt_cp_encrypt_link {
-	bdaddr_t bdaddr;
-	__u8 enable;
+#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0020
+#define MGMT_READ_LOCAL_OOB_DATA_SIZE	0
+struct mgmt_rp_read_local_oob_data {
+	__u8	hash[16];
+	__u8	randomizer[16];
 } __packed;
 
-#define MGMT_OP_SET_RSSI_REPORTER		0x0022
-struct mgmt_cp_set_rssi_reporter {
-	bdaddr_t	bdaddr;
-	__s8		rssi_threshold;
-	__le16	interval;
-	__u8		updateOnThreshExceed;
+#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0021
+struct mgmt_cp_add_remote_oob_data {
+	struct mgmt_addr_info addr;
+	__u8	hash[16];
+	__u8	randomizer[16];
 } __packed;
+#define MGMT_ADD_REMOTE_OOB_DATA_SIZE	(MGMT_ADDR_INFO_SIZE + 32)
 
-#define MGMT_OP_UNSET_RSSI_REPORTER		0x0023
-struct mgmt_cp_unset_rssi_reporter {
-	bdaddr_t	bdaddr;
+#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x0022
+struct mgmt_cp_remove_remote_oob_data {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_REMOVE_REMOTE_OOB_DATA_SIZE MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_CANCEL_RESOLVE_NAME	0x0024
-struct mgmt_cp_cancel_resolve_name {
-	bdaddr_t bdaddr;
+#define MGMT_OP_START_DISCOVERY		0x0023
+struct mgmt_cp_start_discovery {
+	__u8 type;
 } __packed;
+#define MGMT_START_DISCOVERY_SIZE	1
 
-#define MGMT_OP_LE_READ_WHITE_LIST_SIZE	0xE000
-
-#define MGMT_OP_LE_CLEAR_WHITE_LIST	0xE001
-
-#define MGMT_OP_LE_ADD_DEV_WHITE_LIST	0xE002
-struct mgmt_cp_le_add_dev_white_list {
-	__u8 addr_type;
-	bdaddr_t bdaddr;
+#define MGMT_OP_STOP_DISCOVERY		0x0024
+struct mgmt_cp_stop_discovery {
+	__u8 type;
 } __packed;
+#define MGMT_STOP_DISCOVERY_SIZE	1
 
-#define MGMT_OP_LE_REMOVE_DEV_WHITE_LIST	0xE003
-struct mgmt_cp_le_remove_dev_white_list {
-	__u8 addr_type;
-	bdaddr_t bdaddr;
+#define MGMT_OP_CONFIRM_NAME		0x0025
+struct mgmt_cp_confirm_name {
+	struct mgmt_addr_info addr;
+	__u8	name_known;
+} __packed;
+#define MGMT_CONFIRM_NAME_SIZE		(MGMT_ADDR_INFO_SIZE + 1)
+struct mgmt_rp_confirm_name {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_OP_LE_CREATE_CONN_WHITE_LIST	0xE004
-
-#define MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST	0xE005
+#define MGMT_OP_BLOCK_DEVICE		0x0026
+struct mgmt_cp_block_device {
+	struct mgmt_addr_info addr;
+} __packed;
+#define MGMT_BLOCK_DEVICE_SIZE		MGMT_ADDR_INFO_SIZE
 
-#define MGMT_OP_LE_CANCEL_CREATE_CONN	0xE006
-struct mgmt_cp_le_cancel_create_conn {
-	bdaddr_t	bdaddr;
+#define MGMT_OP_UNBLOCK_DEVICE		0x0027
+struct mgmt_cp_unblock_device {
+	struct mgmt_addr_info addr;
 } __packed;
+#define MGMT_UNBLOCK_DEVICE_SIZE	MGMT_ADDR_INFO_SIZE
 
 #define MGMT_EV_CMD_COMPLETE		0x0001
 struct mgmt_ev_cmd_complete {
-	__le16 opcode;
-	__u8 data[0];
+	__le16	opcode;
+	__u8	status;
+	__u8	data[0];
 } __packed;
 
 #define MGMT_EV_CMD_STATUS		0x0002
 struct mgmt_ev_cmd_status {
-	__u8 status;
-	__le16 opcode;
+	__le16	opcode;
+	__u8	status;
 } __packed;
 
 #define MGMT_EV_CONTROLLER_ERROR	0x0003
 struct mgmt_ev_controller_error {
-	__u8 error_code;
+	__u8	error_code;
 } __packed;
 
 #define MGMT_EV_INDEX_ADDED		0x0004
 
 #define MGMT_EV_INDEX_REMOVED		0x0005
 
-#define MGMT_EV_POWERED			0x0006
-
-#define MGMT_EV_DISCOVERABLE		0x0007
+#define MGMT_EV_NEW_SETTINGS		0x0006
 
-#define MGMT_EV_CONNECTABLE		0x0008
+#define MGMT_EV_CLASS_OF_DEV_CHANGED	0x0007
+struct mgmt_ev_class_of_dev_changed {
+	__u8	dev_class[3];
+};
 
-#define MGMT_EV_PAIRABLE		0x0009
+#define MGMT_EV_LOCAL_NAME_CHANGED	0x0008
+struct mgmt_ev_local_name_changed {
+	__u8	name[MGMT_MAX_NAME_LENGTH];
+	__u8	short_name[MGMT_MAX_SHORT_NAME_LENGTH];
+} __packed;
 
-#define MGMT_EV_NEW_KEY			0x000A
-struct mgmt_ev_new_key {
-	__u8 store_hint;
-	struct mgmt_key_info key;
+#define MGMT_EV_NEW_LINK_KEY		0x0009
+struct mgmt_ev_new_link_key {
+	__u8	store_hint;
+	struct mgmt_link_key_info key;
 } __packed;
 
-#define MGMT_EV_CONNECTED		0x000B
-struct mgmt_ev_connected {
-	bdaddr_t bdaddr;
-	__u8 le;
+#define MGMT_EV_NEW_LONG_TERM_KEY	0x000A
+struct mgmt_ev_new_long_term_key {
+	__u8	store_hint;
+	struct mgmt_ltk_info key;
 } __packed;
 
-#define MGMT_EV_DISCONNECTED		0x000C
-struct mgmt_ev_disconnected {
-	bdaddr_t bdaddr;
-	__u8     reason;
+#define MGMT_EV_DEVICE_CONNECTED	0x000B
+struct mgmt_ev_device_connected {
+	struct mgmt_addr_info addr;
+	__le32	flags;
+	__le16	eir_len;
+	__u8	eir[0];
 } __packed;
 
+#define MGMT_EV_DEVICE_DISCONNECTED	0x000C
+
 #define MGMT_EV_CONNECT_FAILED		0x000D
 struct mgmt_ev_connect_failed {
-	bdaddr_t bdaddr;
-	__u8 status;
+	struct mgmt_addr_info addr;
+	__u8	status;
 } __packed;
 
 #define MGMT_EV_PIN_CODE_REQUEST	0x000E
 struct mgmt_ev_pin_code_request {
-	bdaddr_t bdaddr;
-	__u8 secure;
+	struct mgmt_addr_info addr;
+	__u8	secure;
 } __packed;
 
 #define MGMT_EV_USER_CONFIRM_REQUEST	0x000F
 struct mgmt_ev_user_confirm_request {
-	bdaddr_t bdaddr;
-	__u8 auto_confirm;
-	__u8 event;
-	__le32 value;
-} __packed;
-
-#define MGMT_EV_AUTH_FAILED		0x0010
-struct mgmt_ev_auth_failed {
-	bdaddr_t bdaddr;
-	__u8 status;
-} __packed;
-
-#define MGMT_EV_LOCAL_NAME_CHANGED	0x0011
-struct mgmt_ev_local_name_changed {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
+	struct mgmt_addr_info addr;
+	__u8	confirm_hint;
+	__le32	value;
 } __packed;
 
-#define MGMT_EV_DEVICE_FOUND		0x0012
-struct mgmt_ev_device_found {
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
-	__s8 rssi;
-	__u8 le;
-	__u8 type;
-	__u8 eir[HCI_MAX_EIR_LENGTH];
-} __packed;
-
-#define MGMT_EV_REMOTE_NAME		0x0013
-struct mgmt_ev_remote_name {
-	bdaddr_t bdaddr;
-	__u8 status;
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-} __packed;
-
-#define MGMT_EV_DISCOVERING		0x0014
-
-#define MGMT_EV_USER_PASSKEY_REQUEST	0x0015
+#define MGMT_EV_USER_PASSKEY_REQUEST	0x0010
 struct mgmt_ev_user_passkey_request {
-	bdaddr_t bdaddr;
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_ENCRYPT_CHANGE		0x0016
-struct mgmt_ev_encrypt_change {
-	bdaddr_t bdaddr;
-	__u8 status;
+#define MGMT_EV_AUTH_FAILED		0x0011
+struct mgmt_ev_auth_failed {
+	struct mgmt_addr_info addr;
+	__u8	status;
 } __packed;
 
+#define MGMT_DEV_FOUND_CONFIRM_NAME    0x01
+#define MGMT_DEV_FOUND_LEGACY_PAIRING  0x02
 
-#define MGMT_EV_REMOTE_CLASS		0x0017
-struct mgmt_ev_remote_class {
-	bdaddr_t bdaddr;
-	__u8 dev_class[3];
+#define MGMT_EV_DEVICE_FOUND		0x0012
+struct mgmt_ev_device_found {
+	struct mgmt_addr_info addr;
+	__s8	rssi;
+	__u8	flags[4];
+	__le16	eir_len;
+	__u8	eir[0];
 } __packed;
 
-#define MGMT_EV_REMOTE_VERSION		0x0018
-struct mgmt_ev_remote_version {
-	bdaddr_t bdaddr;
-	__u8	lmp_ver;
-	__u16	manufacturer;
-	__u16	lmp_subver;
+#define MGMT_EV_DISCOVERING		0x0013
+struct mgmt_ev_discovering {
+	__u8	type;
+	__u8	discovering;
 } __packed;
 
-#define MGMT_EV_REMOTE_FEATURES		0x0019
-struct mgmt_ev_remote_features {
-	bdaddr_t bdaddr;
-	uint8_t features[8];
+#define MGMT_EV_DEVICE_BLOCKED		0x0014
+struct mgmt_ev_device_blocked {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_RSSI_UPDATE		0x0020
-struct mgmt_ev_rssi_update {
-	bdaddr_t	bdaddr;
-	__s8			rssi;
+#define MGMT_EV_DEVICE_UNBLOCKED	0x0015
+struct mgmt_ev_device_unblocked {
+	struct mgmt_addr_info addr;
 } __packed;
 
-#define MGMT_EV_LE_CONN_PARAMS		0xF000
-struct mgmt_ev_le_conn_params {
-	bdaddr_t bdaddr;
-	__u16 interval;
-	__u16 latency;
-	__u16 timeout;
+#define MGMT_EV_DEVICE_UNPAIRED		0x0016
+struct mgmt_ev_device_unpaired {
+	struct mgmt_addr_info addr;
 } __packed;
diff -urN flo-ElementalX-5.00/include/net/bluetooth/rfcomm.h flo-ElementalX-5.00-patched/include/net/bluetooth/rfcomm.h
--- flo-ElementalX-5.00/include/net/bluetooth/rfcomm.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/rfcomm.h	2016-06-02 00:28:55.000000000 +0000
@@ -211,6 +211,7 @@
 #define RFCOMM_AUTH_ACCEPT  6
 #define RFCOMM_AUTH_REJECT  7
 #define RFCOMM_DEFER_SETUP  8
+#define RFCOMM_ENC_DROP     9
 
 /* Scheduling flags and events */
 #define RFCOMM_SCHED_WAKEUP 31
@@ -234,7 +235,8 @@
 /* ---- RFCOMM DLCs (channels) ---- */
 struct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio);
 void rfcomm_dlc_free(struct rfcomm_dlc *d);
-int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel);
+int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
+								u8 channel);
 int  rfcomm_dlc_close(struct rfcomm_dlc *d, int reason);
 int  rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb);
 int  rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig);
@@ -271,7 +273,8 @@
 }
 
 /* ---- RFCOMM sessions ---- */
-void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst);
+void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src,
+								bdaddr_t *dst);
 
 static inline void rfcomm_session_hold(struct rfcomm_session *s)
 {
@@ -312,7 +315,8 @@
 int  rfcomm_init_sockets(void);
 void rfcomm_cleanup_sockets(void);
 
-int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d);
+int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel,
+							struct rfcomm_dlc **d);
 
 /* ---- RFCOMM TTY ---- */
 #define RFCOMM_MAX_DEV  256
diff -urN flo-ElementalX-5.00/include/net/bluetooth/sco.h flo-ElementalX-5.00-patched/include/net/bluetooth/sco.h
--- flo-ElementalX-5.00/include/net/bluetooth/sco.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/sco.h	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -31,15 +30,13 @@
 #define SCO_DEFAULT_FLUSH_TO	0xFFFF
 
 #define SCO_CONN_TIMEOUT	(HZ * 40)
-#define SCO_DISCONN_TIMEOUT	(HZ * 20)
+#define SCO_DISCONN_TIMEOUT	(HZ * 2)
 #define SCO_CONN_IDLE_TIMEOUT	(HZ * 60)
 
 /* SCO socket address */
 struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
-	__u16		sco_pkt_type;
-	__s8		is_wbs;
 };
 
 /* SCO socket options */
@@ -75,8 +72,7 @@
 
 struct sco_pinfo {
 	struct bt_sock	bt;
-	__u16		pkt_type;
-
+	__u32		flags;
 	struct sco_conn	*conn;
 };
 
diff -urN flo-ElementalX-5.00/include/net/bluetooth/smp.h flo-ElementalX-5.00-patched/include/net/bluetooth/smp.h
--- flo-ElementalX-5.00/include/net/bluetooth/smp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/include/net/bluetooth/smp.h	2016-06-02 00:28:55.000000000 +0000
@@ -55,13 +55,6 @@
 #define SMP_AUTH_BONDING	0x01
 #define SMP_AUTH_MITM		0x04
 
-#define SMP_JUST_WORKS		0x00
-#define SMP_JUST_CFM		0x01
-#define SMP_REQ_PASSKEY		0x02
-#define SMP_CFM_PASSKEY		0x03
-#define SMP_REQ_OOB		0x04
-#define SMP_OVERLAP		0xFF
-
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {
 	__u8	confirm_val[16];
@@ -122,10 +115,32 @@
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16
 
+#define SMP_FLAG_TK_VALID	1
+#define SMP_FLAG_CFM_PENDING	2
+#define SMP_FLAG_MITM_AUTH	3
+
+struct smp_chan {
+	struct l2cap_conn *conn;
+	u8		preq[7]; /* SMP Pairing Request */
+	u8		prsp[7]; /* SMP Pairing Response */
+	u8              prnd[16]; /* SMP Pairing Random (local) */
+	u8              rrnd[16]; /* SMP Pairing Random (remote) */
+	u8		pcnf[16]; /* SMP Pairing Confirm */
+	u8		tk[16]; /* SMP Temporary Key */
+	u8		enc_key_size;
+	unsigned long	smp_flags;
+	struct crypto_blkcipher	*tfm;
+	struct work_struct confirm;
+	struct work_struct random;
+
+};
+
 /* SMP Commands */
-int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level);
+int smp_conn_security(struct hci_conn *hcon, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
-int smp_link_encrypt_cmplt(struct l2cap_conn *conn, __u8 status, __u8 encrypt);
-void smp_timeout(unsigned long l2cap_conn);
+int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
+
+void smp_chan_destroy(struct l2cap_conn *conn);
 
 #endif /* __SMP_H */
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM ext4
-
-#if !defined(_TRACE_EXT4_H) || defined(TRACE_HEADER_MULTI_READ)
-#define _TRACE_EXT4_H
-
-#include <linux/writeback.h>
-#include <linux/tracepoint.h>
-
-struct ext4_allocation_context;
-struct ext4_allocation_request;
-struct ext4_extent;
-struct ext4_prealloc_space;
-struct ext4_inode_info;
-struct mpage_da_data;
-struct ext4_map_blocks;
-struct ext4_extent;
-
-#define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))
-
-TRACE_EVENT(ext4_free_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16, mode			)
-		__field(	uid_t,	uid			)
-		__field(	gid_t,	gid			)
-		__field(	__u64, blocks			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->uid	= inode->i_uid;
-		__entry->gid	= inode->i_gid;
-		__entry->blocks	= inode->i_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o uid %u gid %u blocks %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->mode,
-		  __entry->uid, __entry->gid, __entry->blocks)
-);
-
-TRACE_EVENT(ext4_request_inode,
-	TP_PROTO(struct inode *dir, int mode),
-
-	TP_ARGS(dir, mode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	dir			)
-		__field(	__u16, mode			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= dir->i_sb->s_dev;
-		__entry->dir	= dir->i_ino;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d dir %lu mode 0%o",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->dir, __entry->mode)
-);
-
-TRACE_EVENT(ext4_allocate_inode,
-	TP_PROTO(struct inode *inode, struct inode *dir, int mode),
-
-	TP_ARGS(inode, dir, mode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	ino_t,	dir			)
-		__field(	__u16,	mode			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->dir	= dir->i_ino;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu dir %lu mode 0%o",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->dir, __entry->mode)
-);
-
-TRACE_EVENT(ext4_evict_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	nlink			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->nlink	= inode->i_nlink;
-	),
-
-	TP_printk("dev %d,%d ino %lu nlink %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->nlink)
-);
-
-TRACE_EVENT(ext4_drop_inode,
-	TP_PROTO(struct inode *inode, int drop),
-
-	TP_ARGS(inode, drop),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	drop			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->drop	= drop;
-	),
-
-	TP_printk("dev %d,%d ino %lu drop %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->drop)
-);
-
-TRACE_EVENT(ext4_mark_inode_dirty,
-	TP_PROTO(struct inode *inode, unsigned long IP),
-
-	TP_ARGS(inode, IP),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(unsigned long,	ip			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->ip	= IP;
-	),
-
-	TP_printk("dev %d,%d ino %lu caller %pF",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, (void *)__entry->ip)
-);
-
-TRACE_EVENT(ext4_begin_ordered_truncate,
-	TP_PROTO(struct inode *inode, loff_t new_size),
-
-	TP_ARGS(inode, new_size),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	new_size		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->new_size	= new_size;
-	),
-
-	TP_printk("dev %d,%d ino %lu new_size %lld",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->new_size)
-);
-
-DECLARE_EVENT_CLASS(ext4__write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int, len		)
-		__field(	unsigned int, flags		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->pos	= pos;
-		__entry->len	= len;
-		__entry->flags	= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %u flags %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->flags)
-);
-
-DEFINE_EVENT(ext4__write_begin, ext4_write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags)
-);
-
-DEFINE_EVENT(ext4__write_begin, ext4_da_write_begin,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int flags),
-
-	TP_ARGS(inode, pos, len, flags)
-);
-
-DECLARE_EVENT_CLASS(ext4__write_end,
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-			unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int, len		)
-		__field(	unsigned int, copied		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->pos	= pos;
-		__entry->len	= len;
-		__entry->copied	= copied;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %u copied %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_ordered_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_writeback_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_journalled_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-DEFINE_EVENT(ext4__write_end, ext4_da_write_end,
-
-	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,
-		 unsigned int copied),
-
-	TP_ARGS(inode, pos, len, copied)
-);
-
-TRACE_EVENT(ext4_da_writepages,
-	TP_PROTO(struct inode *inode, struct writeback_control *wbc),
-
-	TP_ARGS(inode, wbc),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	long,	nr_to_write		)
-		__field(	long,	pages_skipped		)
-		__field(	loff_t,	range_start		)
-		__field(	loff_t,	range_end		)
-		__field(	int,	sync_mode		)
-		__field(	char,	for_kupdate		)
-		__field(	char,	range_cyclic		)
-		__field(       pgoff_t,	writeback_index		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->nr_to_write	= wbc->nr_to_write;
-		__entry->pages_skipped	= wbc->pages_skipped;
-		__entry->range_start	= wbc->range_start;
-		__entry->range_end	= wbc->range_end;
-		__entry->sync_mode	= wbc->sync_mode;
-		__entry->for_kupdate	= wbc->for_kupdate;
-		__entry->range_cyclic	= wbc->range_cyclic;
-		__entry->writeback_index = inode->i_mapping->writeback_index;
-	),
-
-	TP_printk("dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld "
-		  "range_start %lld range_end %lld sync_mode %d"
-		  "for_kupdate %d range_cyclic %d writeback_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->nr_to_write,
-		  __entry->pages_skipped, __entry->range_start,
-		  __entry->range_end, __entry->sync_mode,
-		  __entry->for_kupdate, __entry->range_cyclic,
-		  (unsigned long) __entry->writeback_index)
-);
-
-TRACE_EVENT(ext4_da_write_pages,
-	TP_PROTO(struct inode *inode, struct mpage_da_data *mpd),
-
-	TP_ARGS(inode, mpd),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	b_blocknr		)
-		__field(	__u32,	b_size			)
-		__field(	__u32,	b_state			)
-		__field(	unsigned long,	first_page	)
-		__field(	int,	io_done			)
-		__field(	int,	pages_written		)
-		__field(	int,	sync_mode		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->b_blocknr	= mpd->b_blocknr;
-		__entry->b_size		= mpd->b_size;
-		__entry->b_state	= mpd->b_state;
-		__entry->first_page	= mpd->first_page;
-		__entry->io_done	= mpd->io_done;
-		__entry->pages_written	= mpd->pages_written;
-		__entry->sync_mode	= mpd->wbc->sync_mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu b_blocknr %llu b_size %u b_state 0x%04x "
-		  "first_page %lu io_done %d pages_written %d sync_mode %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->b_blocknr, __entry->b_size,
-		  __entry->b_state, __entry->first_page,
-		  __entry->io_done, __entry->pages_written,
-		  __entry->sync_mode
-                  )
-);
-
-TRACE_EVENT(ext4_da_writepages_result,
-	TP_PROTO(struct inode *inode, struct writeback_control *wbc,
-			int ret, int pages_written),
-
-	TP_ARGS(inode, wbc, ret, pages_written),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	int,	ret			)
-		__field(	int,	pages_written		)
-		__field(	long,	pages_skipped		)
-		__field(	int,	sync_mode		)
-		__field(       pgoff_t,	writeback_index		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->ret		= ret;
-		__entry->pages_written	= pages_written;
-		__entry->pages_skipped	= wbc->pages_skipped;
-		__entry->sync_mode	= wbc->sync_mode;
-		__entry->writeback_index = inode->i_mapping->writeback_index;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d pages_written %d pages_skipped %ld "
-		  "sync_mode %d writeback_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->ret,
-		  __entry->pages_written, __entry->pages_skipped,
-		  __entry->sync_mode,
-		  (unsigned long) __entry->writeback_index)
-);
-
-DECLARE_EVENT_CLASS(ext4__page_op,
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page),
-
-	TP_STRUCT__entry(
-		__field(	pgoff_t, index			)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-
-	),
-
-	TP_fast_assign(
-		__entry->index	= page->index;
-		__entry->ino	= page->mapping->host->i_ino;
-		__entry->dev	= page->mapping->host->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu page_index %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->index)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_writepage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_readpage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-DEFINE_EVENT(ext4__page_op, ext4_releasepage,
-
-	TP_PROTO(struct page *page),
-
-	TP_ARGS(page)
-);
-
-TRACE_EVENT(ext4_invalidatepage,
-	TP_PROTO(struct page *page, unsigned long offset),
-
-	TP_ARGS(page, offset),
-
-	TP_STRUCT__entry(
-		__field(	pgoff_t, index			)
-		__field(	unsigned long, offset		)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-
-	),
-
-	TP_fast_assign(
-		__entry->index	= page->index;
-		__entry->offset	= offset;
-		__entry->ino	= page->mapping->host->i_ino;
-		__entry->dev	= page->mapping->host->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu page_index %lu offset %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->index, __entry->offset)
-);
-
-TRACE_EVENT(ext4_discard_blocks,
-	TP_PROTO(struct super_block *sb, unsigned long long blk,
-			unsigned long long count),
-
-	TP_ARGS(sb, blk, count),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u64,	blk			)
-		__field(	__u64,	count			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->blk	= blk;
-		__entry->count	= count;
-	),
-
-	TP_printk("dev %d,%d blk %llu count %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->blk, __entry->count)
-);
-
-DECLARE_EVENT_CLASS(ext4__mb_new_pa,
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	pa_pstart		)
-		__field(	__u32,	pa_len			)
-		__field(	__u64,	pa_lstart		)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->pa_pstart	= pa->pa_pstart;
-		__entry->pa_len		= pa->pa_len;
-		__entry->pa_lstart	= pa->pa_lstart;
-	),
-
-	TP_printk("dev %d,%d ino %lu pstart %llu len %u lstart %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pa_pstart, __entry->pa_len, __entry->pa_lstart)
-);
-
-DEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_inode_pa,
-
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa)
-);
-
-DEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_group_pa,
-
-	TP_PROTO(struct ext4_allocation_context *ac,
-		 struct ext4_prealloc_space *pa),
-
-	TP_ARGS(ac, pa)
-);
-
-TRACE_EVENT(ext4_mb_release_inode_pa,
-	TP_PROTO(struct ext4_prealloc_space *pa,
-		 unsigned long long block, unsigned int count),
-
-	TP_ARGS(pa, block, count),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	block			)
-		__field(	__u32,	count			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= pa->pa_inode->i_sb->s_dev;
-		__entry->ino		= pa->pa_inode->i_ino;
-		__entry->block		= block;
-		__entry->count		= count;
-	),
-
-	TP_printk("dev %d,%d ino %lu block %llu count %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->block, __entry->count)
-);
-
-TRACE_EVENT(ext4_mb_release_group_pa,
-	TP_PROTO(struct super_block *sb, struct ext4_prealloc_space *pa),
-
-	TP_ARGS(sb, pa),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u64,	pa_pstart		)
-		__field(	__u32,	pa_len			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev		= sb->s_dev;
-		__entry->pa_pstart	= pa->pa_pstart;
-		__entry->pa_len		= pa->pa_len;
-	),
-
-	TP_printk("dev %d,%d pstart %llu len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->pa_pstart, __entry->pa_len)
-);
-
-TRACE_EVENT(ext4_discard_preallocations,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-	),
-
-	TP_printk("dev %d,%d ino %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino)
-);
-
-TRACE_EVENT(ext4_mb_discard_preallocations,
-	TP_PROTO(struct super_block *sb, int needed),
-
-	TP_ARGS(sb, needed),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	int,	needed			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->needed	= needed;
-	),
-
-	TP_printk("dev %d,%d needed %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->needed)
-);
-
-TRACE_EVENT(ext4_request_blocks,
-	TP_PROTO(struct ext4_allocation_request *ar),
-
-	TP_ARGS(ar),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	unsigned int, flags		)
-		__field(	unsigned int, len		)
-		__field(	__u32,  logical			)
-		__field(	__u32,	lleft			)
-		__field(	__u32,	lright			)
-		__field(	__u64,	goal			)
-		__field(	__u64,	pleft			)
-		__field(	__u64,	pright			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= ar->inode->i_sb->s_dev;
-		__entry->ino	= ar->inode->i_ino;
-		__entry->flags	= ar->flags;
-		__entry->len	= ar->len;
-		__entry->logical = ar->logical;
-		__entry->goal	= ar->goal;
-		__entry->lleft	= ar->lleft;
-		__entry->lright	= ar->lright;
-		__entry->pleft	= ar->pleft;
-		__entry->pright	= ar->pright;
-	),
-
-	TP_printk("dev %d,%d ino %lu flags %u len %u lblk %u goal %llu "
-		  "lleft %u lright %u pleft %llu pright %llu ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->flags,
-		  __entry->len, __entry->logical, __entry->goal,
-		  __entry->lleft, __entry->lright, __entry->pleft,
-		  __entry->pright)
-);
-
-TRACE_EVENT(ext4_allocate_blocks,
-	TP_PROTO(struct ext4_allocation_request *ar, unsigned long long block),
-
-	TP_ARGS(ar, block),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u64,	block			)
-		__field(	unsigned int, flags		)
-		__field(	unsigned int, len		)
-		__field(	__u32,  logical			)
-		__field(	__u32,	lleft			)
-		__field(	__u32,	lright			)
-		__field(	__u64,	goal			)
-		__field(	__u64,	pleft			)
-		__field(	__u64,	pright			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= ar->inode->i_sb->s_dev;
-		__entry->ino	= ar->inode->i_ino;
-		__entry->block	= block;
-		__entry->flags	= ar->flags;
-		__entry->len	= ar->len;
-		__entry->logical = ar->logical;
-		__entry->goal	= ar->goal;
-		__entry->lleft	= ar->lleft;
-		__entry->lright	= ar->lright;
-		__entry->pleft	= ar->pleft;
-		__entry->pright	= ar->pright;
-	),
-
-	TP_printk("dev %d,%d ino %lu flags %u len %u block %llu lblk %u "
-		  "goal %llu lleft %u lright %u pleft %llu pright %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->flags,
-		  __entry->len, __entry->block, __entry->logical,
-		  __entry->goal,  __entry->lleft, __entry->lright,
-		  __entry->pleft, __entry->pright)
-);
-
-TRACE_EVENT(ext4_free_blocks,
-	TP_PROTO(struct inode *inode, __u64 block, unsigned long count,
-		 int flags),
-
-	TP_ARGS(inode, block, count, flags),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	__u64,	block			)
-		__field(	unsigned long,	count		)
-		__field(	int,	flags			)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ino		= inode->i_ino;
-		__entry->mode		= inode->i_mode;
-		__entry->block		= block;
-		__entry->count		= count;
-		__entry->flags		= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o block %llu count %lu flags %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->block, __entry->count,
-		  __entry->flags)
-);
-
-TRACE_EVENT(ext4_sync_file_enter,
-	TP_PROTO(struct file *file, int datasync),
-
-	TP_ARGS(file, datasync),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	ino_t,	parent			)
-		__field(	int,	datasync		)
-	),
-
-	TP_fast_assign(
-		struct dentry *dentry = file->f_path.dentry;
-
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->datasync	= datasync;
-		__entry->parent		= dentry->d_parent->d_inode->i_ino;
-	),
-
-	TP_printk("dev %d,%d ino %lu parent %lu datasync %d ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long) __entry->parent, __entry->datasync)
-);
-
-TRACE_EVENT(ext4_sync_file_exit,
-	TP_PROTO(struct inode *inode, int ret),
-
-	TP_ARGS(inode, ret),
-
-	TP_STRUCT__entry(
-		__field(	int,	ret			)
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-	),
-
-	TP_fast_assign(
-		__entry->ret		= ret;
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->ret)
-);
-
-TRACE_EVENT(ext4_sync_fs,
-	TP_PROTO(struct super_block *sb, int wait),
-
-	TP_ARGS(sb, wait),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	int,	wait			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->wait	= wait;
-	),
-
-	TP_printk("dev %d,%d wait %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->wait)
-);
-
-TRACE_EVENT(ext4_alloc_da_blocks,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field( unsigned int,	data_blocks	)
-		__field( unsigned int,	meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu data_blocks %u meta_blocks %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->data_blocks, __entry->meta_blocks)
-);
-
-TRACE_EVENT(ext4_mballoc_alloc,
-	TP_PROTO(struct ext4_allocation_context *ac),
-
-	TP_ARGS(ac),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	found			)
-		__field(	__u16,	groups			)
-		__field(	__u16,	buddy			)
-		__field(	__u16,	flags			)
-		__field(	__u16,	tail			)
-		__field(	__u8,	cr			)
-		__field(	__u32, 	orig_logical		)
-		__field(	  int,	orig_start		)
-		__field(	__u32, 	orig_group		)
-		__field(	  int,	orig_len		)
-		__field(	__u32, 	goal_logical		)
-		__field(	  int,	goal_start		)
-		__field(	__u32, 	goal_group		)
-		__field(	  int,	goal_len		)
-		__field(	__u32, 	result_logical		)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_inode->i_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->found		= ac->ac_found;
-		__entry->flags		= ac->ac_flags;
-		__entry->groups		= ac->ac_groups_scanned;
-		__entry->buddy		= ac->ac_buddy;
-		__entry->tail		= ac->ac_tail;
-		__entry->cr		= ac->ac_criteria;
-		__entry->orig_logical	= ac->ac_o_ex.fe_logical;
-		__entry->orig_start	= ac->ac_o_ex.fe_start;
-		__entry->orig_group	= ac->ac_o_ex.fe_group;
-		__entry->orig_len	= ac->ac_o_ex.fe_len;
-		__entry->goal_logical	= ac->ac_g_ex.fe_logical;
-		__entry->goal_start	= ac->ac_g_ex.fe_start;
-		__entry->goal_group	= ac->ac_g_ex.fe_group;
-		__entry->goal_len	= ac->ac_g_ex.fe_len;
-		__entry->result_logical	= ac->ac_f_ex.fe_logical;
-		__entry->result_start	= ac->ac_f_ex.fe_start;
-		__entry->result_group	= ac->ac_f_ex.fe_group;
-		__entry->result_len	= ac->ac_f_ex.fe_len;
-	),
-
-	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u "
-		  "result %u/%d/%u@%u blks %u grps %u cr %u flags 0x%04x "
-		  "tail %u broken %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->orig_group, __entry->orig_start,
-		  __entry->orig_len, __entry->orig_logical,
-		  __entry->goal_group, __entry->goal_start,
-		  __entry->goal_len, __entry->goal_logical,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len, __entry->result_logical,
-		  __entry->found, __entry->groups, __entry->cr,
-		  __entry->flags, __entry->tail,
-		  __entry->buddy ? 1 << __entry->buddy : 0)
-);
-
-TRACE_EVENT(ext4_mballoc_prealloc,
-	TP_PROTO(struct ext4_allocation_context *ac),
-
-	TP_ARGS(ac),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u32, 	orig_logical		)
-		__field(	  int,	orig_start		)
-		__field(	__u32, 	orig_group		)
-		__field(	  int,	orig_len		)
-		__field(	__u32, 	result_logical		)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= ac->ac_inode->i_sb->s_dev;
-		__entry->ino		= ac->ac_inode->i_ino;
-		__entry->orig_logical	= ac->ac_o_ex.fe_logical;
-		__entry->orig_start	= ac->ac_o_ex.fe_start;
-		__entry->orig_group	= ac->ac_o_ex.fe_group;
-		__entry->orig_len	= ac->ac_o_ex.fe_len;
-		__entry->result_logical	= ac->ac_b_ex.fe_logical;
-		__entry->result_start	= ac->ac_b_ex.fe_start;
-		__entry->result_group	= ac->ac_b_ex.fe_group;
-		__entry->result_len	= ac->ac_b_ex.fe_len;
-	),
-
-	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->orig_group, __entry->orig_start,
-		  __entry->orig_len, __entry->orig_logical,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len, __entry->result_logical)
-);
-
-DECLARE_EVENT_CLASS(ext4__mballoc,
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	  int,	result_start		)
-		__field(	__u32, 	result_group		)
-		__field(	  int,	result_len		)
-	),
-
-	TP_fast_assign(
-		__entry->dev		= sb->s_dev;
-		__entry->ino		= inode ? inode->i_ino : 0;
-		__entry->result_start	= start;
-		__entry->result_group	= group;
-		__entry->result_len	= len;
-	),
-
-	TP_printk("dev %d,%d inode %lu extent %u/%d/%d ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->result_group, __entry->result_start,
-		  __entry->result_len)
-);
-
-DEFINE_EVENT(ext4__mballoc, ext4_mballoc_discard,
-
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len)
-);
-
-DEFINE_EVENT(ext4__mballoc, ext4_mballoc_free,
-
-	TP_PROTO(struct super_block *sb,
-		 struct inode *inode,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, inode, group, start, len)
-);
-
-TRACE_EVENT(ext4_forget,
-	TP_PROTO(struct inode *inode, int is_metadata, __u64 block),
-
-	TP_ARGS(inode, is_metadata, block),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	int,	is_metadata		)
-		__field(	__u64,	block			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->is_metadata = is_metadata;
-		__entry->block	= block;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o is_metadata %d block %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->is_metadata, __entry->block)
-);
-
-TRACE_EVENT(ext4_da_update_reserve_space,
-	TP_PROTO(struct inode *inode, int used_blocks, int quota_claim),
-
-	TP_ARGS(inode, used_blocks, quota_claim),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,	mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	used_blocks		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-		__field(	int,	allocated_meta_blocks	)
-		__field(	int,	quota_claim		)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->used_blocks = used_blocks;
-		__entry->reserved_data_blocks =
-				EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks =
-				EXT4_I(inode)->i_reserved_meta_blocks;
-		__entry->allocated_meta_blocks =
-				EXT4_I(inode)->i_allocated_meta_blocks;
-		__entry->quota_claim = quota_claim;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu used_blocks %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d "
-		  "allocated_meta_blocks %d quota_claim %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->used_blocks, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks, __entry->allocated_meta_blocks,
-		  __entry->quota_claim)
-);
-
-TRACE_EVENT(ext4_da_reserve_space,
-	TP_PROTO(struct inode *inode, int md_needed),
-
-	TP_ARGS(inode, md_needed),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,  mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	md_needed		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->md_needed = md_needed;
-		__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu md_needed %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->md_needed, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks)
-);
-
-TRACE_EVENT(ext4_da_release_space,
-	TP_PROTO(struct inode *inode, int freed_blocks),
-
-	TP_ARGS(inode, freed_blocks),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	ino_t,	ino			)
-		__field(	__u16,  mode			)
-		__field(	__u64,	i_blocks		)
-		__field(	int,	freed_blocks		)
-		__field(	int,	reserved_data_blocks	)
-		__field(	int,	reserved_meta_blocks	)
-		__field(	int,	allocated_meta_blocks	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->ino	= inode->i_ino;
-		__entry->mode	= inode->i_mode;
-		__entry->i_blocks = inode->i_blocks;
-		__entry->freed_blocks = freed_blocks;
-		__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;
-		__entry->reserved_meta_blocks = EXT4_I(inode)->i_reserved_meta_blocks;
-		__entry->allocated_meta_blocks = EXT4_I(inode)->i_allocated_meta_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu freed_blocks %d "
-		  "reserved_data_blocks %d reserved_meta_blocks %d "
-		  "allocated_meta_blocks %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->mode, __entry->i_blocks,
-		  __entry->freed_blocks, __entry->reserved_data_blocks,
-		  __entry->reserved_meta_blocks, __entry->allocated_meta_blocks)
-);
-
-DECLARE_EVENT_CLASS(ext4__bitmap_load,
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	__u32,	group			)
-
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->group	= group;
-	),
-
-	TP_printk("dev %d,%d group %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_mb_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_mb_buddy_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_read_block_bitmap_load,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-DEFINE_EVENT(ext4__bitmap_load, ext4_load_inode_bitmap,
-
-	TP_PROTO(struct super_block *sb, unsigned long group),
-
-	TP_ARGS(sb, group)
-);
-
-TRACE_EVENT(ext4_direct_IO_enter,
-	TP_PROTO(struct inode *inode, loff_t offset, unsigned long len, int rw),
-
-	TP_ARGS(inode, offset, len, rw),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned long,	len		)
-		__field(	int,	rw			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->rw	= rw;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lu rw %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len, __entry->rw)
-);
-
-TRACE_EVENT(ext4_direct_IO_exit,
-	TP_PROTO(struct inode *inode, loff_t offset, unsigned long len,
-		 int rw, int ret),
-
-	TP_ARGS(inode, offset, len, rw, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned long,	len		)
-		__field(	int,	rw			)
-		__field(	int,	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->rw	= rw;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lu rw %d ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->len,
-		  __entry->rw, __entry->ret)
-);
-
-TRACE_EVENT(ext4_fallocate_enter,
-	TP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),
-
-	TP_ARGS(inode, offset, len, mode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	loff_t,	len			)
-		__field(	int,	mode			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->len	= len;
-		__entry->mode	= mode;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld len %lld mode %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->pos,
-		  __entry->len, __entry->mode)
-);
-
-TRACE_EVENT(ext4_fallocate_exit,
-	TP_PROTO(struct inode *inode, loff_t offset,
-		 unsigned int max_blocks, int ret),
-
-	TP_ARGS(inode, offset, max_blocks, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	loff_t,	pos			)
-		__field(	unsigned int,	blocks		)
-		__field(	int, 	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pos	= offset;
-		__entry->blocks	= max_blocks;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu pos %lld blocks %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->pos, __entry->blocks,
-		  __entry->ret)
-);
-
-TRACE_EVENT(ext4_unlink_enter,
-	TP_PROTO(struct inode *parent, struct dentry *dentry),
-
-	TP_ARGS(parent, dentry),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	parent			)
-		__field(	ino_t,	ino			)
-		__field(	loff_t,	size			)
-		__field(	dev_t,	dev			)
-	),
-
-	TP_fast_assign(
-		__entry->parent		= parent->i_ino;
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->size		= dentry->d_inode->i_size;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %lu size %lld parent %lu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->size,
-		  (unsigned long) __entry->parent)
-);
-
-TRACE_EVENT(ext4_unlink_exit,
-	TP_PROTO(struct dentry *dentry, int ret),
-
-	TP_ARGS(dentry, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino			)
-		__field(	dev_t,	dev			)
-		__field(	int,	ret			)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= dentry->d_inode->i_ino;
-		__entry->dev		= dentry->d_inode->i_sb->s_dev;
-		__entry->ret		= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->ret)
-);
-
-DECLARE_EVENT_CLASS(ext4__truncate,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,  	ino		)
-		__field(	dev_t,  	dev		)
-		__field(	__u64,		blocks		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->blocks	= inode->i_blocks;
-	),
-
-	TP_printk("dev %d,%d ino %lu blocks %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino, __entry->blocks)
-);
-
-DEFINE_EVENT(ext4__truncate, ext4_truncate_enter,
-
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode)
-);
-
-DEFINE_EVENT(ext4__truncate, ext4_truncate_exit,
-
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode)
-);
-
-/* 'ux' is the uninitialized extent. */
-TRACE_EVENT(ext4_ext_convert_to_initialized_enter,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 struct ext4_extent *ux),
-
-	TP_ARGS(inode, map, ux),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	m_lblk	)
-		__field(	unsigned,	m_len	)
-		__field(	ext4_lblk_t,	u_lblk	)
-		__field(	unsigned,	u_len	)
-		__field(	ext4_fsblk_t,	u_pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->m_lblk		= map->m_lblk;
-		__entry->m_len		= map->m_len;
-		__entry->u_lblk		= le32_to_cpu(ux->ee_block);
-		__entry->u_len		= ext4_ext_get_actual_len(ux);
-		__entry->u_pblk		= ext4_ext_pblock(ux);
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_len %u u_lblk %u u_len %u "
-		  "u_pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->m_lblk, __entry->m_len,
-		  __entry->u_lblk, __entry->u_len, __entry->u_pblk)
-);
-
-/*
- * 'ux' is the uninitialized extent.
- * 'ix' is the initialized extent to which blocks are transferred.
- */
-TRACE_EVENT(ext4_ext_convert_to_initialized_fastpath,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 struct ext4_extent *ux, struct ext4_extent *ix),
-
-	TP_ARGS(inode, map, ux, ix),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	m_lblk	)
-		__field(	unsigned,	m_len	)
-		__field(	ext4_lblk_t,	u_lblk	)
-		__field(	unsigned,	u_len	)
-		__field(	ext4_fsblk_t,	u_pblk	)
-		__field(	ext4_lblk_t,	i_lblk	)
-		__field(	unsigned,	i_len	)
-		__field(	ext4_fsblk_t,	i_pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->m_lblk		= map->m_lblk;
-		__entry->m_len		= map->m_len;
-		__entry->u_lblk		= le32_to_cpu(ux->ee_block);
-		__entry->u_len		= ext4_ext_get_actual_len(ux);
-		__entry->u_pblk		= ext4_ext_pblock(ux);
-		__entry->i_lblk		= le32_to_cpu(ix->ee_block);
-		__entry->i_len		= ext4_ext_get_actual_len(ix);
-		__entry->i_pblk		= ext4_ext_pblock(ix);
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_len %u "
-		  "u_lblk %u u_len %u u_pblk %llu "
-		  "i_lblk %u i_len %u i_pblk %llu ",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->m_lblk, __entry->m_len,
-		  __entry->u_lblk, __entry->u_len, __entry->u_pblk,
-		  __entry->i_lblk, __entry->i_len, __entry->i_pblk)
-);
-
-DECLARE_EVENT_CLASS(ext4__map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned int len, unsigned int flags),
-
-	TP_ARGS(inode, lblk, len, flags),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,  	ino		)
-		__field(	dev_t,  	dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	unsigned int,	len		)
-		__field(	unsigned int,	flags		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-		__entry->flags	= flags;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u flags %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->len, __entry->flags)
-);
-
-DEFINE_EVENT(ext4__map_blocks_enter, ext4_ext_map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned len, unsigned flags),
-
-	TP_ARGS(inode, lblk, len, flags)
-);
-
-DEFINE_EVENT(ext4__map_blocks_enter, ext4_ind_map_blocks_enter,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 unsigned len, unsigned flags),
-
-	TP_ARGS(inode, lblk, len, flags)
-);
-
-DECLARE_EVENT_CLASS(ext4__map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned int len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-		__field(	unsigned int,	len		)
-		__field(	int,		ret		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-		__entry->len	= len;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu len %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->pblk,
-		  __entry->len, __entry->ret)
-);
-
-DEFINE_EVENT(ext4__map_blocks_exit, ext4_ext_map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret)
-);
-
-DEFINE_EVENT(ext4__map_blocks_exit, ext4_ind_map_blocks_exit,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk,
-		 ext4_fsblk_t pblk, unsigned len, int ret),
-
-	TP_ARGS(inode, lblk, pblk, len, ret)
-);
-
-TRACE_EVENT(ext4_ext_load_extent,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk),
-
-	TP_ARGS(inode, lblk, pblk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-	),
-
-	TP_fast_assign(
-		__entry->ino    = inode->i_ino;
-		__entry->dev    = inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  __entry->lblk, __entry->pblk)
-);
-
-TRACE_EVENT(ext4_load_inode,
-	TP_PROTO(struct inode *inode),
-
-	TP_ARGS(inode),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,	ino		)
-		__field(	dev_t,	dev		)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-	),
-
-	TP_printk("dev %d,%d ino %ld",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino)
-);
-
-TRACE_EVENT(ext4_journal_start,
-	TP_PROTO(struct super_block *sb, int nblocks, unsigned long IP),
-
-	TP_ARGS(sb, nblocks, IP),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
-		__field(	  int, 	nblocks			)
-		__field(unsigned long,	ip			)
-	),
-
-	TP_fast_assign(
-		__entry->dev	 = sb->s_dev;
-		__entry->nblocks = nblocks;
-		__entry->ip	 = IP;
-	),
-
-	TP_printk("dev %d,%d nblocks %d caller %pF",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->nblocks, (void *)__entry->ip)
-);
-
-DECLARE_EVENT_CLASS(ext4__trim,
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len),
-
-	TP_STRUCT__entry(
-		__field(	int,	dev_major		)
-		__field(	int,	dev_minor		)
-		__field(	__u32, 	group			)
-		__field(	int,	start			)
-		__field(	int,	len			)
-	),
-
-	TP_fast_assign(
-		__entry->dev_major	= MAJOR(sb->s_dev);
-		__entry->dev_minor	= MINOR(sb->s_dev);
-		__entry->group		= group;
-		__entry->start		= start;
-		__entry->len		= len;
-	),
-
-	TP_printk("dev %d,%d group %u, start %d, len %d",
-		  __entry->dev_major, __entry->dev_minor,
-		  __entry->group, __entry->start, __entry->len)
-);
-
-DEFINE_EVENT(ext4__trim, ext4_trim_extent,
-
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len)
-);
-
-DEFINE_EVENT(ext4__trim, ext4_trim_all_free,
-
-	TP_PROTO(struct super_block *sb,
-		 ext4_group_t group,
-		 ext4_grpblk_t start,
-		 ext4_grpblk_t len),
-
-	TP_ARGS(sb, group, start, len)
-);
-
-TRACE_EVENT(ext4_ext_handle_uninitialized_extents,
-	TP_PROTO(struct inode *inode, struct ext4_map_blocks *map,
-		 unsigned int allocated, ext4_fsblk_t newblock),
-
-	TP_ARGS(inode, map, allocated, newblock),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	lblk		)
-		__field(	ext4_fsblk_t,	pblk		)
-		__field(	unsigned int,	len		)
-		__field(	int,		flags		)
-		__field(	unsigned int,	allocated	)
-		__field(	ext4_fsblk_t,	newblk		)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->lblk		= map->m_lblk;
-		__entry->pblk		= map->m_pblk;
-		__entry->len		= map->m_len;
-		__entry->flags		= map->m_flags;
-		__entry->allocated	= allocated;
-		__entry->newblk		= newblock;
-	),
-
-	TP_printk("dev %d,%d ino %lu m_lblk %u m_pblk %llu m_len %u flags %d"
-		  "allocated %d newblock %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk, (unsigned long long) __entry->pblk,
-		  __entry->len, __entry->flags,
-		  (unsigned int) __entry->allocated,
-		  (unsigned long long) __entry->newblk)
-);
-
-TRACE_EVENT(ext4_get_implied_cluster_alloc_exit,
-	TP_PROTO(struct super_block *sb, struct ext4_map_blocks *map, int ret),
-
-	TP_ARGS(sb, map, ret),
-
-	TP_STRUCT__entry(
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	ext4_fsblk_t,	pblk	)
-		__field(	unsigned int,	len	)
-		__field(	unsigned int,	flags	)
-		__field(	int,		ret	)
-	),
-
-	TP_fast_assign(
-		__entry->dev	= sb->s_dev;
-		__entry->lblk	= map->m_lblk;
-		__entry->pblk	= map->m_pblk;
-		__entry->len	= map->m_len;
-		__entry->flags	= map->m_flags;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d m_lblk %u m_pblk %llu m_len %u m_flags %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->lblk, (unsigned long long) __entry->pblk,
-		  __entry->len, __entry->flags, __entry->ret)
-);
-
-TRACE_EVENT(ext4_ext_put_in_cache,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len,
-		 ext4_fsblk_t start),
-
-	TP_ARGS(inode, lblk, len, start),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	unsigned int,	len	)
-		__field(	ext4_fsblk_t,	start	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-		__entry->start	= start;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u start %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->len,
-		  (unsigned long long) __entry->start)
-);
-
-TRACE_EVENT(ext4_ext_in_cache,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, int ret),
-
-	TP_ARGS(inode, lblk, ret),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	int,		ret	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->ret	= ret;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u ret %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->ret)
-
-);
-
-TRACE_EVENT(ext4_find_delalloc_range,
-	TP_PROTO(struct inode *inode, ext4_lblk_t from, ext4_lblk_t to,
-		int reverse, int found, ext4_lblk_t found_blk),
-
-	TP_ARGS(inode, from, to, reverse, found, found_blk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	from		)
-		__field(	ext4_lblk_t,	to		)
-		__field(	int,		reverse		)
-		__field(	int,		found		)
-		__field(	ext4_lblk_t,	found_blk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->from		= from;
-		__entry->to		= to;
-		__entry->reverse	= reverse;
-		__entry->found		= found;
-		__entry->found_blk	= found_blk;
-	),
-
-	TP_printk("dev %d,%d ino %lu from %u to %u reverse %d found %d "
-		  "(blk = %u)",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->from, (unsigned) __entry->to,
-		  __entry->reverse, __entry->found,
-		  (unsigned) __entry->found_blk)
-);
-
-TRACE_EVENT(ext4_get_reserved_cluster_alloc,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len),
-
-	TP_ARGS(inode, lblk, len),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	unsigned int,	len	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->len	= len;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  __entry->len)
-);
-
-TRACE_EVENT(ext4_ext_show_extent,
-	TP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,
-		 unsigned short len),
-
-	TP_ARGS(inode, lblk, pblk, len),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	lblk	)
-		__field(	ext4_fsblk_t,	pblk	)
-		__field(	unsigned short,	len	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->lblk	= lblk;
-		__entry->pblk	= pblk;
-		__entry->len	= len;
-	),
-
-	TP_printk("dev %d,%d ino %lu lblk %u pblk %llu len %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->lblk,
-		  (unsigned long long) __entry->pblk,
-		  (unsigned short) __entry->len)
-);
-
-TRACE_EVENT(ext4_remove_blocks,
-	    TP_PROTO(struct inode *inode, struct ext4_extent *ex,
-		ext4_lblk_t from, ext4_fsblk_t to,
-		ext4_fsblk_t partial_cluster),
-
-	TP_ARGS(inode, ex, from, to, partial_cluster),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	ee_lblk	)
-		__field(	ext4_fsblk_t,	ee_pblk	)
-		__field(	unsigned short,	ee_len	)
-		__field(	ext4_lblk_t,	from	)
-		__field(	ext4_lblk_t,	to	)
-		__field(	ext4_fsblk_t,	partial	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->ee_lblk	= cpu_to_le32(ex->ee_block);
-		__entry->ee_pblk	= ext4_ext_pblock(ex);
-		__entry->ee_len		= ext4_ext_get_actual_len(ex);
-		__entry->from		= from;
-		__entry->to		= to;
-		__entry->partial	= partial_cluster;
-	),
-
-	TP_printk("dev %d,%d ino %lu extent [%u(%llu), %u]"
-		  "from %u to %u partial_cluster %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->ee_lblk,
-		  (unsigned long long) __entry->ee_pblk,
-		  (unsigned short) __entry->ee_len,
-		  (unsigned) __entry->from,
-		  (unsigned) __entry->to,
-		  (unsigned) __entry->partial)
-);
-
-TRACE_EVENT(ext4_ext_rm_leaf,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start,
-		 struct ext4_extent *ex, ext4_fsblk_t partial_cluster),
-
-	TP_ARGS(inode, start, ex, partial_cluster),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	start	)
-		__field(	ext4_lblk_t,	ee_lblk	)
-		__field(	ext4_fsblk_t,	ee_pblk	)
-		__field(	short,		ee_len	)
-		__field(	ext4_fsblk_t,	partial	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->start		= start;
-		__entry->ee_lblk	= le32_to_cpu(ex->ee_block);
-		__entry->ee_pblk	= ext4_ext_pblock(ex);
-		__entry->ee_len		= ext4_ext_get_actual_len(ex);
-		__entry->partial	= partial_cluster;
-	),
-
-	TP_printk("dev %d,%d ino %lu start_lblk %u last_extent [%u(%llu), %u]"
-		  "partial_cluster %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  (unsigned) __entry->ee_lblk,
-		  (unsigned long long) __entry->ee_pblk,
-		  (unsigned short) __entry->ee_len,
-		  (unsigned) __entry->partial)
-);
-
-TRACE_EVENT(ext4_ext_rm_idx,
-	TP_PROTO(struct inode *inode, ext4_fsblk_t pblk),
-
-	TP_ARGS(inode, pblk),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_fsblk_t,	pblk	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->pblk	= pblk;
-	),
-
-	TP_printk("dev %d,%d ino %lu index_pblk %llu",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned long long) __entry->pblk)
-);
-
-TRACE_EVENT(ext4_ext_remove_space,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start, int depth),
-
-	TP_ARGS(inode, start, depth),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino	)
-		__field(	dev_t,		dev	)
-		__field(	ext4_lblk_t,	start	)
-		__field(	int,		depth	)
-	),
-
-	TP_fast_assign(
-		__entry->ino	= inode->i_ino;
-		__entry->dev	= inode->i_sb->s_dev;
-		__entry->start	= start;
-		__entry->depth	= depth;
-	),
-
-	TP_printk("dev %d,%d ino %lu since %u depth %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  __entry->depth)
-);
-
-TRACE_EVENT(ext4_ext_remove_space_done,
-	TP_PROTO(struct inode *inode, ext4_lblk_t start, int depth,
-		ext4_lblk_t partial, unsigned short eh_entries),
-
-	TP_ARGS(inode, start, depth, partial, eh_entries),
-
-	TP_STRUCT__entry(
-		__field(	ino_t,		ino		)
-		__field(	dev_t,		dev		)
-		__field(	ext4_lblk_t,	start		)
-		__field(	int,		depth		)
-		__field(	ext4_lblk_t,	partial		)
-		__field(	unsigned short,	eh_entries	)
-	),
-
-	TP_fast_assign(
-		__entry->ino		= inode->i_ino;
-		__entry->dev		= inode->i_sb->s_dev;
-		__entry->start		= start;
-		__entry->depth		= depth;
-		__entry->partial	= partial;
-		__entry->eh_entries	= eh_entries;
-	),
-
-	TP_printk("dev %d,%d ino %lu since %u depth %d partial %u "
-		  "remaining_entries %u",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  (unsigned long) __entry->ino,
-		  (unsigned) __entry->start,
-		  __entry->depth,
-		  (unsigned) __entry->partial,
-		  (unsigned short) __entry->eh_entries)
-);
-
-#endif /* _TRACE_EXT4_H */
-
-/* This part must be outside protection */
-#include <trace/define_trace.h>

-#include <linux/stat.h>
-#include <linux/sysctl.h>
-#include "../fs/xfs/xfs_sysctl.h"
-#include <linux/sunrpc/debug.h>
-#include <linux/string.h>
-#include <net/ip_vs.h>
-#include <linux/syscalls.h>
-#include <linux/namei.h>
-#include <linux/mount.h>
-#include <linux/fs.h>
-#include <linux/nsproxy.h>
-#include <linux/pid_namespace.h>
-#include <linux/file.h>
-#include <linux/ctype.h>
-#include <linux/netdevice.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-
-#ifdef CONFIG_SYSCTL_SYSCALL
-
-struct bin_table;
-typedef ssize_t bin_convert_t(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen);
-
-static bin_convert_t bin_dir;
-static bin_convert_t bin_string;
-static bin_convert_t bin_intvec;
-static bin_convert_t bin_ulongvec;
-static bin_convert_t bin_uuid;
-static bin_convert_t bin_dn_node_address;
-
-#define CTL_DIR   bin_dir
-#define CTL_STR   bin_string
-#define CTL_INT   bin_intvec
-#define CTL_ULONG bin_ulongvec
-#define CTL_UUID  bin_uuid
-#define CTL_DNADR bin_dn_node_address
-
-#define BUFSZ 256
-
-struct bin_table {
-	bin_convert_t		*convert;
-	int			ctl_name;
-	const char		*procname;
-	const struct bin_table	*child;
-};
-
-static const struct bin_table bin_random_table[] = {
-	{ CTL_INT,	RANDOM_POOLSIZE,	"poolsize" },
-	{ CTL_INT,	RANDOM_ENTROPY_COUNT,	"entropy_avail" },
-	{ CTL_INT,	RANDOM_READ_THRESH,	"read_wakeup_threshold" },
-	{ CTL_INT,	RANDOM_WRITE_THRESH,	"write_wakeup_threshold" },
-	{ CTL_UUID,	RANDOM_BOOT_ID,		"boot_id" },
-	{ CTL_UUID,	RANDOM_UUID,		"uuid" },
-	{}
-};
-
-static const struct bin_table bin_pty_table[] = {
-	{ CTL_INT,	PTY_MAX,	"max" },
-	{ CTL_INT,	PTY_NR,		"nr" },
-	{}
-};
-
-static const struct bin_table bin_kern_table[] = {
-	{ CTL_STR,	KERN_OSTYPE,			"ostype" },
-	{ CTL_STR,	KERN_OSRELEASE,			"osrelease" },
-	/* KERN_OSREV not used */
-	{ CTL_STR,	KERN_VERSION,			"version" },
-	/* KERN_SECUREMASK not used */
-	/* KERN_PROF not used */
-	{ CTL_STR,	KERN_NODENAME,			"hostname" },
-	{ CTL_STR,	KERN_DOMAINNAME,		"domainname" },
-
-	{ CTL_INT,	KERN_PANIC,			"panic" },
-	{ CTL_INT,	KERN_REALROOTDEV,		"real-root-dev" },
-
-	{ CTL_STR,	KERN_SPARC_REBOOT,		"reboot-cmd" },
-	{ CTL_INT,	KERN_CTLALTDEL,			"ctrl-alt-del" },
-	{ CTL_INT,	KERN_PRINTK,			"printk" },
-
-	/* KERN_NAMETRANS not used */
-	/* KERN_PPC_HTABRECLAIM not used */
-	/* KERN_PPC_ZEROPAGED not used */
-	{ CTL_INT,	KERN_PPC_POWERSAVE_NAP,		"powersave-nap" },
-
-	{ CTL_STR,	KERN_MODPROBE,			"modprobe" },
-	{ CTL_INT,	KERN_SG_BIG_BUFF,		"sg-big-buff" },
-	{ CTL_INT,	KERN_ACCT,			"acct" },
-	/* KERN_PPC_L2CR "l2cr" no longer used */
-
-	/* KERN_RTSIGNR not used */
-	/* KERN_RTSIGMAX not used */
-
-	{ CTL_ULONG,	KERN_SHMMAX,			"shmmax" },
-	{ CTL_INT,	KERN_MSGMAX,			"msgmax" },
-	{ CTL_INT,	KERN_MSGMNB,			"msgmnb" },
-	/* KERN_MSGPOOL not used*/
-	{ CTL_INT,	KERN_SYSRQ,			"sysrq" },
-	{ CTL_INT,	KERN_MAX_THREADS,		"threads-max" },
-	{ CTL_DIR,	KERN_RANDOM,			"random",	bin_random_table },
-	{ CTL_ULONG,	KERN_SHMALL,			"shmall" },
-	{ CTL_INT,	KERN_MSGMNI,			"msgmni" },
-	{ CTL_INT,	KERN_SEM,			"sem" },
-	{ CTL_INT,	KERN_SPARC_STOP_A,		"stop-a" },
-	{ CTL_INT,	KERN_SHMMNI,			"shmmni" },
-
-	{ CTL_INT,	KERN_OVERFLOWUID,		"overflowuid" },
-	{ CTL_INT,	KERN_OVERFLOWGID,		"overflowgid" },
-
-	{ CTL_STR,	KERN_HOTPLUG,			"hotplug", },
-	{ CTL_INT,	KERN_IEEE_EMULATION_WARNINGS,	"ieee_emulation_warnings" },
-
-	{ CTL_INT,	KERN_S390_USER_DEBUG_LOGGING,	"userprocess_debug" },
-	{ CTL_INT,	KERN_CORE_USES_PID,		"core_uses_pid" },
-	/* KERN_TAINTED "tainted" no longer used */
-	{ CTL_INT,	KERN_CADPID,			"cad_pid" },
-	{ CTL_INT,	KERN_PIDMAX,			"pid_max" },
-	{ CTL_STR,	KERN_CORE_PATTERN,		"core_pattern" },
-	{ CTL_INT,	KERN_PANIC_ON_OOPS,		"panic_on_oops" },
-	{ CTL_INT,	KERN_HPPA_PWRSW,		"soft-power" },
-	{ CTL_INT,	KERN_HPPA_UNALIGNED,		"unaligned-trap" },
-
-	{ CTL_INT,	KERN_PRINTK_RATELIMIT,		"printk_ratelimit" },
-	{ CTL_INT,	KERN_PRINTK_RATELIMIT_BURST,	"printk_ratelimit_burst" },
-
-	{ CTL_DIR,	KERN_PTY,			"pty",		bin_pty_table },
-	{ CTL_INT,	KERN_NGROUPS_MAX,		"ngroups_max" },
-	{ CTL_INT,	KERN_SPARC_SCONS_PWROFF,	"scons-poweroff" },
-	/* KERN_HZ_TIMER "hz_timer" no longer used */
-	{ CTL_INT,	KERN_UNKNOWN_NMI_PANIC,		"unknown_nmi_panic" },
-	{ CTL_INT,	KERN_BOOTLOADER_TYPE,		"bootloader_type" },
-	{ CTL_INT,	KERN_RANDOMIZE,			"randomize_va_space" },
-
-	{ CTL_INT,	KERN_SPIN_RETRY,		"spin_retry" },
-	/* KERN_ACPI_VIDEO_FLAGS "acpi_video_flags" no longer used */
-	{ CTL_INT,	KERN_IA64_UNALIGNED,		"ignore-unaligned-usertrap" },
-	{ CTL_INT,	KERN_COMPAT_LOG,		"compat-log" },
-	{ CTL_INT,	KERN_MAX_LOCK_DEPTH,		"max_lock_depth" },
-	{ CTL_INT,	KERN_PANIC_ON_NMI,		"panic_on_unrecovered_nmi" },
-	{ CTL_INT,	KERN_BOOT_REASON,		"boot_reason" },
-	{}
-};
-
-static const struct bin_table bin_vm_table[] = {
-	{ CTL_INT,	VM_OVERCOMMIT_MEMORY,		"overcommit_memory" },
-	{ CTL_INT,	VM_PAGE_CLUSTER,		"page-cluster" },
-	{ CTL_INT,	VM_DIRTY_BACKGROUND,		"dirty_background_ratio" },
-	{ CTL_INT,	VM_DIRTY_RATIO,			"dirty_ratio" },
-	/* VM_DIRTY_WB_CS "dirty_writeback_centisecs" no longer used */
-	/* VM_DIRTY_EXPIRE_CS "dirty_expire_centisecs" no longer used */
-	{ CTL_INT,	VM_NR_PDFLUSH_THREADS,		"nr_pdflush_threads" },
-	{ CTL_INT,	VM_OVERCOMMIT_RATIO,		"overcommit_ratio" },
-	/* VM_PAGEBUF unused */
-	/* VM_HUGETLB_PAGES "nr_hugepages" no longer used */
-	{ CTL_INT,	VM_SWAPPINESS,			"swappiness" },
-	{ CTL_INT,	VM_LOWMEM_RESERVE_RATIO,	"lowmem_reserve_ratio" },
-	{ CTL_INT,	VM_MIN_FREE_KBYTES,		"min_free_kbytes" },
-	{ CTL_INT,	VM_MAX_MAP_COUNT,		"max_map_count" },
-	{ CTL_INT,	VM_LAPTOP_MODE,			"laptop_mode" },
-	{ CTL_INT,	VM_BLOCK_DUMP,			"block_dump" },
-	{ CTL_INT,	VM_HUGETLB_GROUP,		"hugetlb_shm_group" },
-	{ CTL_INT,	VM_VFS_CACHE_PRESSURE,	"vfs_cache_pressure" },
-	{ CTL_INT,	VM_LEGACY_VA_LAYOUT,		"legacy_va_layout" },
-	/* VM_SWAP_TOKEN_TIMEOUT unused */
-	{ CTL_INT,	VM_DROP_PAGECACHE,		"drop_caches" },
-	{ CTL_INT,	VM_PERCPU_PAGELIST_FRACTION,	"percpu_pagelist_fraction" },
-	{ CTL_INT,	VM_ZONE_RECLAIM_MODE,		"zone_reclaim_mode" },
-	{ CTL_INT,	VM_MIN_UNMAPPED,		"min_unmapped_ratio" },
-	{ CTL_INT,	VM_PANIC_ON_OOM,		"panic_on_oom" },
-	{ CTL_INT,	VM_VDSO_ENABLED,		"vdso_enabled" },
-	{ CTL_INT,	VM_MIN_SLAB,			"min_slab_ratio" },
-
-	{}
-};
-
-static const struct bin_table bin_net_core_table[] = {
-	{ CTL_INT,	NET_CORE_WMEM_MAX,	"wmem_max" },
-	{ CTL_INT,	NET_CORE_RMEM_MAX,	"rmem_max" },
-	{ CTL_INT,	NET_CORE_WMEM_DEFAULT,	"wmem_default" },
-	{ CTL_INT,	NET_CORE_RMEM_DEFAULT,	"rmem_default" },
-	/* NET_CORE_DESTROY_DELAY unused */
-	{ CTL_INT,	NET_CORE_MAX_BACKLOG,	"netdev_max_backlog" },
-	/* NET_CORE_FASTROUTE unused */
-	{ CTL_INT,	NET_CORE_MSG_COST,	"message_cost" },
-	{ CTL_INT,	NET_CORE_MSG_BURST,	"message_burst" },
-	{ CTL_INT,	NET_CORE_OPTMEM_MAX,	"optmem_max" },
-	/* NET_CORE_HOT_LIST_LENGTH unused */
-	/* NET_CORE_DIVERT_VERSION unused */
-	/* NET_CORE_NO_CONG_THRESH unused */
-	/* NET_CORE_NO_CONG unused */
-	/* NET_CORE_LO_CONG unused */
-	/* NET_CORE_MOD_CONG unused */
-	{ CTL_INT,	NET_CORE_DEV_WEIGHT,	"dev_weight" },
-	{ CTL_INT,	NET_CORE_SOMAXCONN,	"somaxconn" },
-	{ CTL_INT,	NET_CORE_BUDGET,	"netdev_budget" },
-	{ CTL_INT,	NET_CORE_AEVENT_ETIME,	"xfrm_aevent_etime" },
-	{ CTL_INT,	NET_CORE_AEVENT_RSEQTH,	"xfrm_aevent_rseqth" },
-	{ CTL_INT,	NET_CORE_WARNINGS,	"warnings" },
-	{},
-};
-
-static const struct bin_table bin_net_unix_table[] = {
-	/* NET_UNIX_DESTROY_DELAY unused */
-	/* NET_UNIX_DELETE_DELAY unused */
-	{ CTL_INT,	NET_UNIX_MAX_DGRAM_QLEN,	"max_dgram_qlen" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_route_table[] = {
-	{ CTL_INT,	NET_IPV4_ROUTE_FLUSH,			"flush" },
-	/* NET_IPV4_ROUTE_MIN_DELAY "min_delay" no longer used */
-	/* NET_IPV4_ROUTE_MAX_DELAY "max_delay" no longer used */
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_THRESH,		"gc_thresh" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MAX_SIZE,		"max_size" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_MIN_INTERVAL,		"gc_min_interval" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS,	"gc_min_interval_ms" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_TIMEOUT,		"gc_timeout" },
-	/* NET_IPV4_ROUTE_GC_INTERVAL "gc_interval" no longer used */
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_LOAD,		"redirect_load" },
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_NUMBER,		"redirect_number" },
-	{ CTL_INT,	NET_IPV4_ROUTE_REDIRECT_SILENCE,	"redirect_silence" },
-	{ CTL_INT,	NET_IPV4_ROUTE_ERROR_COST,		"error_cost" },
-	{ CTL_INT,	NET_IPV4_ROUTE_ERROR_BURST,		"error_burst" },
-	{ CTL_INT,	NET_IPV4_ROUTE_GC_ELASTICITY,		"gc_elasticity" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MTU_EXPIRES,		"mtu_expires" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MIN_PMTU,		"min_pmtu" },
-	{ CTL_INT,	NET_IPV4_ROUTE_MIN_ADVMSS,		"min_adv_mss" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_conf_vars_table[] = {
-	{ CTL_INT,	NET_IPV4_CONF_FORWARDING,		"forwarding" },
-	{ CTL_INT,	NET_IPV4_CONF_MC_FORWARDING,		"mc_forwarding" },
-
-	{ CTL_INT,	NET_IPV4_CONF_ACCEPT_REDIRECTS,		"accept_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SECURE_REDIRECTS,		"secure_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SEND_REDIRECTS,		"send_redirects" },
-	{ CTL_INT,	NET_IPV4_CONF_SHARED_MEDIA,		"shared_media" },
-	{ CTL_INT,	NET_IPV4_CONF_RP_FILTER,		"rp_filter" },
-	{ CTL_INT,	NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE,	"accept_source_route" },
-	{ CTL_INT,	NET_IPV4_CONF_PROXY_ARP,		"proxy_arp" },
-	{ CTL_INT,	NET_IPV4_CONF_MEDIUM_ID,		"medium_id" },
-	{ CTL_INT,	NET_IPV4_CONF_BOOTP_RELAY,		"bootp_relay" },
-	{ CTL_INT,	NET_IPV4_CONF_LOG_MARTIANS,		"log_martians" },
-	{ CTL_INT,	NET_IPV4_CONF_TAG,			"tag" },
-	{ CTL_INT,	NET_IPV4_CONF_ARPFILTER,		"arp_filter" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_ANNOUNCE,		"arp_announce" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_IGNORE,		"arp_ignore" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_ACCEPT,		"arp_accept" },
-	{ CTL_INT,	NET_IPV4_CONF_ARP_NOTIFY,		"arp_notify" },
-
-	{ CTL_INT,	NET_IPV4_CONF_NOXFRM,			"disable_xfrm" },
-	{ CTL_INT,	NET_IPV4_CONF_NOPOLICY,			"disable_policy" },
-	{ CTL_INT,	NET_IPV4_CONF_FORCE_IGMP_VERSION,	"force_igmp_version" },
-	{ CTL_INT,	NET_IPV4_CONF_PROMOTE_SECONDARIES,	"promote_secondaries" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_conf_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_ALL,	"all",		bin_net_ipv4_conf_vars_table },
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT,	"default",	bin_net_ipv4_conf_vars_table },
-	{ CTL_DIR,	0, NULL, bin_net_ipv4_conf_vars_table },
-	{}
-};
-
-static const struct bin_table bin_net_neigh_vars_table[] = {
-	{ CTL_INT,	NET_NEIGH_MCAST_SOLICIT,	"mcast_solicit" },
-	{ CTL_INT,	NET_NEIGH_UCAST_SOLICIT,	"ucast_solicit" },
-	{ CTL_INT,	NET_NEIGH_APP_SOLICIT,		"app_solicit" },
-	/* NET_NEIGH_RETRANS_TIME "retrans_time" no longer used */
-	{ CTL_INT,	NET_NEIGH_REACHABLE_TIME,	"base_reachable_time" },
-	{ CTL_INT,	NET_NEIGH_DELAY_PROBE_TIME,	"delay_first_probe_time" },
-	{ CTL_INT,	NET_NEIGH_GC_STALE_TIME,	"gc_stale_time" },
-	{ CTL_INT,	NET_NEIGH_UNRES_QLEN,		"unres_qlen" },
-	{ CTL_INT,	NET_NEIGH_PROXY_QLEN,		"proxy_qlen" },
-	/* NET_NEIGH_ANYCAST_DELAY "anycast_delay" no longer used */
-	/* NET_NEIGH_PROXY_DELAY "proxy_delay" no longer used */
-	/* NET_NEIGH_LOCKTIME "locktime" no longer used */
-	{ CTL_INT,	NET_NEIGH_GC_INTERVAL,		"gc_interval" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH1,		"gc_thresh1" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH2,		"gc_thresh2" },
-	{ CTL_INT,	NET_NEIGH_GC_THRESH3,		"gc_thresh3" },
-	{ CTL_INT,	NET_NEIGH_RETRANS_TIME_MS,	"retrans_time_ms" },
-	{ CTL_INT,	NET_NEIGH_REACHABLE_TIME_MS,	"base_reachable_time_ms" },
-	{}
-};
-
-static const struct bin_table bin_net_neigh_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT, "default", bin_net_neigh_vars_table },
-	{ CTL_DIR,	0, NULL, bin_net_neigh_vars_table },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_netfilter_table[] = {
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_MAX,		"ip_conntrack_max" },
-
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT "ip_conntrack_tcp_timeout_syn_sent" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV "ip_conntrack_tcp_timeout_syn_recv" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED "ip_conntrack_tcp_timeout_established" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT "ip_conntrack_tcp_timeout_fin_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT	"ip_conntrack_tcp_timeout_close_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK "ip_conntrack_tcp_timeout_last_ack" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT "ip_conntrack_tcp_timeout_time_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE "ip_conntrack_tcp_timeout_close" no longer used */
-
-	/* NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT "ip_conntrack_udp_timeout" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM "ip_conntrack_udp_timeout_stream" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT "ip_conntrack_icmp_timeout" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT "ip_conntrack_generic_timeout" no longer used */
-
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_BUCKETS,		"ip_conntrack_buckets" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_LOG_INVALID,	"ip_conntrack_log_invalid" },
-	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS "ip_conntrack_tcp_timeout_max_retrans" no longer used */
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_LOOSE,	"ip_conntrack_tcp_loose" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL,	"ip_conntrack_tcp_be_liberal" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS,	"ip_conntrack_tcp_max_retrans" },
-
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED "ip_conntrack_sctp_timeout_closed" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT "ip_conntrack_sctp_timeout_cookie_wait" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED "ip_conntrack_sctp_timeout_cookie_echoed" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED "ip_conntrack_sctp_timeout_established" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT "ip_conntrack_sctp_timeout_shutdown_sent" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD "ip_conntrack_sctp_timeout_shutdown_recd" no longer used */
-	/* NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT "ip_conntrack_sctp_timeout_shutdown_ack_sent" no longer used */
-
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_COUNT,		"ip_conntrack_count" },
-	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_CHECKSUM,		"ip_conntrack_checksum" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv4_table[] = {
-	{CTL_INT,	NET_IPV4_FORWARD,			"ip_forward" },
-
-	{ CTL_DIR,	NET_IPV4_CONF,		"conf",		bin_net_ipv4_conf_table },
-	{ CTL_DIR,	NET_IPV4_NEIGH,		"neigh",	bin_net_neigh_table },
-	{ CTL_DIR,	NET_IPV4_ROUTE,		"route",	bin_net_ipv4_route_table },
-	/* NET_IPV4_FIB_HASH unused */
-	{ CTL_DIR,	NET_IPV4_NETFILTER,	"netfilter",	bin_net_ipv4_netfilter_table },
-
-	{ CTL_INT,	NET_IPV4_TCP_TIMESTAMPS,		"tcp_timestamps" },
-	{ CTL_INT,	NET_IPV4_TCP_WINDOW_SCALING,		"tcp_window_scaling" },
-	{ CTL_INT,	NET_IPV4_TCP_SACK,			"tcp_sack" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRANS_COLLAPSE,		"tcp_retrans_collapse" },
-	{ CTL_INT,	NET_IPV4_DEFAULT_TTL,			"ip_default_ttl" },
-	/* NET_IPV4_AUTOCONFIG unused */
-	{ CTL_INT,	NET_IPV4_NO_PMTU_DISC,			"ip_no_pmtu_disc" },
-	{ CTL_INT,	NET_IPV4_NONLOCAL_BIND,			"ip_nonlocal_bind" },
-	{ CTL_INT,	NET_IPV4_TCP_SYN_RETRIES,		"tcp_syn_retries" },
-	{ CTL_INT,	NET_TCP_SYNACK_RETRIES,			"tcp_synack_retries" },
-	{ CTL_INT,	NET_TCP_MAX_ORPHANS,			"tcp_max_orphans" },
-	{ CTL_INT,	NET_TCP_MAX_TW_BUCKETS,			"tcp_max_tw_buckets" },
-	{ CTL_INT,	NET_IPV4_DYNADDR,			"ip_dynaddr" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_TIME,		"tcp_keepalive_time" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_PROBES,		"tcp_keepalive_probes" },
-	{ CTL_INT,	NET_IPV4_TCP_KEEPALIVE_INTVL,		"tcp_keepalive_intvl" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRIES1,			"tcp_retries1" },
-	{ CTL_INT,	NET_IPV4_TCP_RETRIES2,			"tcp_retries2" },
-	{ CTL_INT,	NET_IPV4_TCP_FIN_TIMEOUT,		"tcp_fin_timeout" },
-	{ CTL_INT,	NET_TCP_SYNCOOKIES,			"tcp_syncookies" },
-	{ CTL_INT,	NET_TCP_TW_RECYCLE,			"tcp_tw_recycle" },
-	{ CTL_INT,	NET_TCP_ABORT_ON_OVERFLOW,		"tcp_abort_on_overflow" },
-	{ CTL_INT,	NET_TCP_STDURG,				"tcp_stdurg" },
-	{ CTL_INT,	NET_TCP_RFC1337,			"tcp_rfc1337" },
-	{ CTL_INT,	NET_TCP_MAX_SYN_BACKLOG,		"tcp_max_syn_backlog" },
-	{ CTL_INT,	NET_IPV4_LOCAL_PORT_RANGE,		"ip_local_port_range" },
-	{ CTL_INT,	NET_IPV4_IGMP_MAX_MEMBERSHIPS,		"igmp_max_memberships" },
-	{ CTL_INT,	NET_IPV4_IGMP_MAX_MSF,			"igmp_max_msf" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_THRESHOLD,		"inet_peer_threshold" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_MINTTL,		"inet_peer_minttl" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_MAXTTL,		"inet_peer_maxttl" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_GC_MINTIME,		"inet_peer_gc_mintime" },
-	{ CTL_INT,	NET_IPV4_INET_PEER_GC_MAXTIME,		"inet_peer_gc_maxtime" },
-	{ CTL_INT,	NET_TCP_ORPHAN_RETRIES,			"tcp_orphan_retries" },
-	{ CTL_INT,	NET_TCP_FACK,				"tcp_fack" },
-	{ CTL_INT,	NET_TCP_REORDERING,			"tcp_reordering" },
-	{ CTL_INT,	NET_TCP_ECN,				"tcp_ecn" },
-	{ CTL_INT,	NET_TCP_DSACK,				"tcp_dsack" },
-	{ CTL_INT,	NET_TCP_MEM,				"tcp_mem" },
-	{ CTL_INT,	NET_TCP_WMEM,				"tcp_wmem" },
-	{ CTL_INT,	NET_TCP_RMEM,				"tcp_rmem" },
-	{ CTL_INT,	NET_TCP_APP_WIN,			"tcp_app_win" },
-	{ CTL_INT,	NET_TCP_ADV_WIN_SCALE,			"tcp_adv_win_scale" },
-	{ CTL_INT,	NET_TCP_TW_REUSE,			"tcp_tw_reuse" },
-	{ CTL_INT,	NET_TCP_FRTO,				"tcp_frto" },
-	{ CTL_INT,	NET_TCP_FRTO_RESPONSE,			"tcp_frto_response" },
-	{ CTL_INT,	NET_TCP_LOW_LATENCY,			"tcp_low_latency" },
-	{ CTL_INT,	NET_TCP_NO_METRICS_SAVE,		"tcp_no_metrics_save" },
-	{ CTL_INT,	NET_TCP_MODERATE_RCVBUF,		"tcp_moderate_rcvbuf" },
-	{ CTL_INT,	NET_TCP_TSO_WIN_DIVISOR,		"tcp_tso_win_divisor" },
-	{ CTL_STR,	NET_TCP_CONG_CONTROL,			"tcp_congestion_control" },
-	{ CTL_INT,	NET_TCP_ABC,				"tcp_abc" },
-	{ CTL_INT,	NET_TCP_MTU_PROBING,			"tcp_mtu_probing" },
-	{ CTL_INT,	NET_TCP_BASE_MSS,			"tcp_base_mss" },
-	{ CTL_INT,	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS,	"tcp_workaround_signed_windows" },
-	{ CTL_INT,	NET_TCP_DMA_COPYBREAK,			"tcp_dma_copybreak" },
-	{ CTL_INT,	NET_TCP_SLOW_START_AFTER_IDLE,		"tcp_slow_start_after_idle" },
-	{ CTL_INT,	NET_CIPSOV4_CACHE_ENABLE,		"cipso_cache_enable" },
-	{ CTL_INT,	NET_CIPSOV4_CACHE_BUCKET_SIZE,		"cipso_cache_bucket_size" },
-	{ CTL_INT,	NET_CIPSOV4_RBM_OPTFMT,			"cipso_rbm_optfmt" },
-	{ CTL_INT,	NET_CIPSOV4_RBM_STRICTVALID,		"cipso_rbm_strictvalid" },
-	/* NET_TCP_AVAIL_CONG_CONTROL "tcp_available_congestion_control" no longer used */
-	{ CTL_STR,	NET_TCP_ALLOWED_CONG_CONTROL,		"tcp_allowed_congestion_control" },
-	{ CTL_INT,	NET_TCP_MAX_SSTHRESH,			"tcp_max_ssthresh" },
-
-	{ CTL_INT,	NET_IPV4_ICMP_ECHO_IGNORE_ALL,		"icmp_echo_ignore_all" },
-	{ CTL_INT,	NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS,	"icmp_echo_ignore_broadcasts" },
-	{ CTL_INT,	NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES,	"icmp_ignore_bogus_error_responses" },
-	{ CTL_INT,	NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR,	"icmp_errors_use_inbound_ifaddr" },
-	{ CTL_INT,	NET_IPV4_ICMP_RATELIMIT,		"icmp_ratelimit" },
-	{ CTL_INT,	NET_IPV4_ICMP_RATEMASK,			"icmp_ratemask" },
-
-	{ CTL_INT,	NET_IPV4_IPFRAG_HIGH_THRESH,		"ipfrag_high_thresh" },
-	{ CTL_INT,	NET_IPV4_IPFRAG_LOW_THRESH,		"ipfrag_low_thresh" },
-	{ CTL_INT,	NET_IPV4_IPFRAG_TIME,			"ipfrag_time" },
-
-	{ CTL_INT,	NET_IPV4_IPFRAG_SECRET_INTERVAL,	"ipfrag_secret_interval" },
-	/* NET_IPV4_IPFRAG_MAX_DIST "ipfrag_max_dist" no longer used */
-
-	{ CTL_INT,	2088 /* NET_IPQ_QMAX */,		"ip_queue_maxlen" },
-
-	/* NET_TCP_DEFAULT_WIN_SCALE unused */
-	/* NET_TCP_BIC_BETA unused */
-	/* NET_IPV4_TCP_MAX_KA_PROBES unused */
-	/* NET_IPV4_IP_MASQ_DEBUG unused */
-	/* NET_TCP_SYN_TAILDROP unused */
-	/* NET_IPV4_ICMP_SOURCEQUENCH_RATE unused */
-	/* NET_IPV4_ICMP_DESTUNREACH_RATE unused */
-	/* NET_IPV4_ICMP_TIMEEXCEED_RATE unused */
-	/* NET_IPV4_ICMP_PARAMPROB_RATE unused */
-	/* NET_IPV4_ICMP_ECHOREPLY_RATE unused */
-	/* NET_IPV4_ALWAYS_DEFRAG unused */
-	{}
-};
-
-static const struct bin_table bin_net_ipx_table[] = {
-	{ CTL_INT,	NET_IPX_PPROP_BROADCASTING,	"ipx_pprop_broadcasting" },
-	/* NET_IPX_FORWARDING unused */
-	{}
-};
-
-static const struct bin_table bin_net_atalk_table[] = {
-	{ CTL_INT,	NET_ATALK_AARP_EXPIRY_TIME,		"aarp-expiry-time" },
-	{ CTL_INT,	NET_ATALK_AARP_TICK_TIME,		"aarp-tick-time" },
-	{ CTL_INT,	NET_ATALK_AARP_RETRANSMIT_LIMIT,	"aarp-retransmit-limit" },
-	{ CTL_INT,	NET_ATALK_AARP_RESOLVE_TIME,		"aarp-resolve-time" },
-	{},
-};
-
-static const struct bin_table bin_net_netrom_table[] = {
-	{ CTL_INT,	NET_NETROM_DEFAULT_PATH_QUALITY,		"default_path_quality" },
-	{ CTL_INT,	NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER,	"obsolescence_count_initialiser" },
-	{ CTL_INT,	NET_NETROM_NETWORK_TTL_INITIALISER,		"network_ttl_initialiser" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_TIMEOUT,			"transport_timeout" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_MAXIMUM_TRIES,		"transport_maximum_tries" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY,		"transport_acknowledge_delay" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_BUSY_DELAY,		"transport_busy_delay" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE,	"transport_requested_window_size" },
-	{ CTL_INT,	NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT,	"transport_no_activity_timeout" },
-	{ CTL_INT,	NET_NETROM_ROUTING_CONTROL,			"routing_control" },
-	{ CTL_INT,	NET_NETROM_LINK_FAILS_COUNT,			"link_fails_count" },
-	{ CTL_INT,	NET_NETROM_RESET,				"reset" },
-	{}
-};
-
-static const struct bin_table bin_net_ax25_param_table[] = {
-	{ CTL_INT,	NET_AX25_IP_DEFAULT_MODE,	"ip_default_mode" },
-	{ CTL_INT,	NET_AX25_DEFAULT_MODE,		"ax25_default_mode" },
-	{ CTL_INT,	NET_AX25_BACKOFF_TYPE,		"backoff_type" },
-	{ CTL_INT,	NET_AX25_CONNECT_MODE,		"connect_mode" },
-	{ CTL_INT,	NET_AX25_STANDARD_WINDOW,	"standard_window_size" },
-	{ CTL_INT,	NET_AX25_EXTENDED_WINDOW,	"extended_window_size" },
-	{ CTL_INT,	NET_AX25_T1_TIMEOUT,		"t1_timeout" },
-	{ CTL_INT,	NET_AX25_T2_TIMEOUT,		"t2_timeout" },
-	{ CTL_INT,	NET_AX25_T3_TIMEOUT,		"t3_timeout" },
-	{ CTL_INT,	NET_AX25_IDLE_TIMEOUT,		"idle_timeout" },
-	{ CTL_INT,	NET_AX25_N2,			"maximum_retry_count" },
-	{ CTL_INT,	NET_AX25_PACLEN,		"maximum_packet_length" },
-	{ CTL_INT,	NET_AX25_PROTOCOL,		"protocol" },
-	{ CTL_INT,	NET_AX25_DAMA_SLAVE_TIMEOUT,	"dama_slave_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_ax25_table[] = {
-	{ CTL_DIR,	0, NULL, bin_net_ax25_param_table },
-	{}
-};
-
-static const struct bin_table bin_net_rose_table[] = {
-	{ CTL_INT,	NET_ROSE_RESTART_REQUEST_TIMEOUT,	"restart_request_timeout" },
-	{ CTL_INT,	NET_ROSE_CALL_REQUEST_TIMEOUT,		"call_request_timeout" },
-	{ CTL_INT,	NET_ROSE_RESET_REQUEST_TIMEOUT,		"reset_request_timeout" },
-	{ CTL_INT,	NET_ROSE_CLEAR_REQUEST_TIMEOUT,		"clear_request_timeout" },
-	{ CTL_INT,	NET_ROSE_ACK_HOLD_BACK_TIMEOUT,		"acknowledge_hold_back_timeout" },
-	{ CTL_INT,	NET_ROSE_ROUTING_CONTROL,		"routing_control" },
-	{ CTL_INT,	NET_ROSE_LINK_FAIL_TIMEOUT,		"link_fail_timeout" },
-	{ CTL_INT,	NET_ROSE_MAX_VCS,			"maximum_virtual_circuits" },
-	{ CTL_INT,	NET_ROSE_WINDOW_SIZE,			"window_size" },
-	{ CTL_INT,	NET_ROSE_NO_ACTIVITY_TIMEOUT,		"no_activity_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_conf_var_table[] = {
-	{ CTL_INT,	NET_IPV6_FORWARDING,			"forwarding" },
-	{ CTL_INT,	NET_IPV6_HOP_LIMIT,			"hop_limit" },
-	{ CTL_INT,	NET_IPV6_MTU,				"mtu" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA,			"accept_ra" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_REDIRECTS,		"accept_redirects" },
-	{ CTL_INT,	NET_IPV6_AUTOCONF,			"autoconf" },
-	{ CTL_INT,	NET_IPV6_DAD_TRANSMITS,			"dad_transmits" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICITS,			"router_solicitations" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICIT_INTERVAL,		"router_solicitation_interval" },
-	{ CTL_INT,	NET_IPV6_RTR_SOLICIT_DELAY,		"router_solicitation_delay" },
-	{ CTL_INT,	NET_IPV6_USE_TEMPADDR,			"use_tempaddr" },
-	{ CTL_INT,	NET_IPV6_TEMP_VALID_LFT,		"temp_valid_lft" },
-	{ CTL_INT,	NET_IPV6_TEMP_PREFERED_LFT,		"temp_prefered_lft" },
-	{ CTL_INT,	NET_IPV6_REGEN_MAX_RETRY,		"regen_max_retry" },
-	{ CTL_INT,	NET_IPV6_MAX_DESYNC_FACTOR,		"max_desync_factor" },
-	{ CTL_INT,	NET_IPV6_MAX_ADDRESSES,			"max_addresses" },
-	{ CTL_INT,	NET_IPV6_FORCE_MLD_VERSION,		"force_mld_version" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_DEFRTR,		"accept_ra_defrtr" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_PINFO,		"accept_ra_pinfo" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_RTR_PREF,		"accept_ra_rtr_pref" },
-	{ CTL_INT,	NET_IPV6_RTR_PROBE_INTERVAL,		"router_probe_interval" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN,	"accept_ra_rt_info_max_plen" },
-	{ CTL_INT,	NET_IPV6_PROXY_NDP,			"proxy_ndp" },
-	{ CTL_INT,	NET_IPV6_ACCEPT_SOURCE_ROUTE,		"accept_source_route" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_conf_table[] = {
-	{ CTL_DIR,	NET_PROTO_CONF_ALL,		"all",	bin_net_ipv6_conf_var_table },
-	{ CTL_DIR,	NET_PROTO_CONF_DEFAULT, 	"default", bin_net_ipv6_conf_var_table },
-	{ CTL_DIR,	0, NULL, bin_net_ipv6_conf_var_table },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_route_table[] = {
-	/* NET_IPV6_ROUTE_FLUSH	"flush"  no longer used */
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_THRESH,		"gc_thresh" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MAX_SIZE,		"max_size" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_MIN_INTERVAL,		"gc_min_interval" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_TIMEOUT,		"gc_timeout" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_INTERVAL,		"gc_interval" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_ELASTICITY,		"gc_elasticity" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MTU_EXPIRES,		"mtu_expires" },
-	{ CTL_INT,	NET_IPV6_ROUTE_MIN_ADVMSS,		"min_adv_mss" },
-	{ CTL_INT,	NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS,	"gc_min_interval_ms" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_icmp_table[] = {
-	{ CTL_INT,	NET_IPV6_ICMP_RATELIMIT,	"ratelimit" },
-	{}
-};
-
-static const struct bin_table bin_net_ipv6_table[] = {
-	{ CTL_DIR,	NET_IPV6_CONF,		"conf",		bin_net_ipv6_conf_table },
-	{ CTL_DIR,	NET_IPV6_NEIGH,		"neigh",	bin_net_neigh_table },
-	{ CTL_DIR,	NET_IPV6_ROUTE,		"route",	bin_net_ipv6_route_table },
-	{ CTL_DIR,	NET_IPV6_ICMP,		"icmp",		bin_net_ipv6_icmp_table },
-	{ CTL_INT,	NET_IPV6_BINDV6ONLY,		"bindv6only" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_HIGH_THRESH,	"ip6frag_high_thresh" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_LOW_THRESH,	"ip6frag_low_thresh" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_TIME,		"ip6frag_time" },
-	{ CTL_INT,	NET_IPV6_IP6FRAG_SECRET_INTERVAL,	"ip6frag_secret_interval" },
-	{ CTL_INT,	NET_IPV6_MLD_MAX_MSF,		"mld_max_msf" },
-	{ CTL_INT,	2088 /* IPQ_QMAX */,		"ip6_queue_maxlen" },
-	{}
-};
-
-static const struct bin_table bin_net_x25_table[] = {
-	{ CTL_INT,	NET_X25_RESTART_REQUEST_TIMEOUT,	"restart_request_timeout" },
-	{ CTL_INT,	NET_X25_CALL_REQUEST_TIMEOUT,		"call_request_timeout" },
-	{ CTL_INT,	NET_X25_RESET_REQUEST_TIMEOUT,	"reset_request_timeout" },
-	{ CTL_INT,	NET_X25_CLEAR_REQUEST_TIMEOUT,	"clear_request_timeout" },
-	{ CTL_INT,	NET_X25_ACK_HOLD_BACK_TIMEOUT,	"acknowledgement_hold_back_timeout" },
-	{ CTL_INT,	NET_X25_FORWARD,			"x25_forward" },
-	{}
-};
-
-static const struct bin_table bin_net_tr_table[] = {
-	{ CTL_INT,	NET_TR_RIF_TIMEOUT,	"rif_timeout" },
-	{}
-};
-
-
-static const struct bin_table bin_net_decnet_conf_vars[] = {
-	{ CTL_INT,	NET_DECNET_CONF_DEV_FORWARDING,	"forwarding" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_PRIORITY,	"priority" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_T2,		"t2" },
-	{ CTL_INT,	NET_DECNET_CONF_DEV_T3,		"t3" },
-	{}
-};
-
-static const struct bin_table bin_net_decnet_conf[] = {
-	{ CTL_DIR, NET_DECNET_CONF_ETHER,    "ethernet", bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_GRE,	     "ipgre",    bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_X25,	     "x25",      bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_PPP,	     "ppp",      bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_DDCMP,    "ddcmp",    bin_net_decnet_conf_vars },
-	{ CTL_DIR, NET_DECNET_CONF_LOOPBACK, "loopback", bin_net_decnet_conf_vars },
-	{ CTL_DIR, 0,			     NULL,	 bin_net_decnet_conf_vars },
-	{}
-};
-
-static const struct bin_table bin_net_decnet_table[] = {
-	{ CTL_DIR,	NET_DECNET_CONF,		"conf",	bin_net_decnet_conf },
-	{ CTL_DNADR,	NET_DECNET_NODE_ADDRESS,	"node_address" },
-	{ CTL_STR,	NET_DECNET_NODE_NAME,		"node_name" },
-	{ CTL_STR,	NET_DECNET_DEFAULT_DEVICE,	"default_device" },
-	{ CTL_INT,	NET_DECNET_TIME_WAIT,		"time_wait" },
-	{ CTL_INT,	NET_DECNET_DN_COUNT,		"dn_count" },
-	{ CTL_INT,	NET_DECNET_DI_COUNT,		"di_count" },
-	{ CTL_INT,	NET_DECNET_DR_COUNT,		"dr_count" },
-	{ CTL_INT,	NET_DECNET_DST_GC_INTERVAL,	"dst_gc_interval" },
-	{ CTL_INT,	NET_DECNET_NO_FC_MAX_CWND,	"no_fc_max_cwnd" },
-	{ CTL_INT,	NET_DECNET_MEM,		"decnet_mem" },
-	{ CTL_INT,	NET_DECNET_RMEM,		"decnet_rmem" },
-	{ CTL_INT,	NET_DECNET_WMEM,		"decnet_wmem" },
-	{ CTL_INT,	NET_DECNET_DEBUG_LEVEL,	"debug" },
-	{}
-};
-
-static const struct bin_table bin_net_sctp_table[] = {
-	{ CTL_INT,	NET_SCTP_RTO_INITIAL,		"rto_initial" },
-	{ CTL_INT,	NET_SCTP_RTO_MIN,		"rto_min" },
-	{ CTL_INT,	NET_SCTP_RTO_MAX,		"rto_max" },
-	{ CTL_INT,	NET_SCTP_RTO_ALPHA,		"rto_alpha_exp_divisor" },
-	{ CTL_INT,	NET_SCTP_RTO_BETA,		"rto_beta_exp_divisor" },
-	{ CTL_INT,	NET_SCTP_VALID_COOKIE_LIFE,	"valid_cookie_life" },
-	{ CTL_INT,	NET_SCTP_ASSOCIATION_MAX_RETRANS,	"association_max_retrans" },
-	{ CTL_INT,	NET_SCTP_PATH_MAX_RETRANS,	"path_max_retrans" },
-	{ CTL_INT,	NET_SCTP_MAX_INIT_RETRANSMITS,	"max_init_retransmits" },
-	{ CTL_INT,	NET_SCTP_HB_INTERVAL,		"hb_interval" },
-	{ CTL_INT,	NET_SCTP_PRESERVE_ENABLE,	"cookie_preserve_enable" },
-	{ CTL_INT,	NET_SCTP_MAX_BURST,		"max_burst" },
-	{ CTL_INT,	NET_SCTP_ADDIP_ENABLE,		"addip_enable" },
-	{ CTL_INT,	NET_SCTP_PRSCTP_ENABLE,		"prsctp_enable" },
-	{ CTL_INT,	NET_SCTP_SNDBUF_POLICY,		"sndbuf_policy" },
-	{ CTL_INT,	NET_SCTP_SACK_TIMEOUT,		"sack_timeout" },
-	{ CTL_INT,	NET_SCTP_RCVBUF_POLICY,		"rcvbuf_policy" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_llc2_timeout_table[] = {
-	{ CTL_INT,	NET_LLC2_ACK_TIMEOUT,	"ack" },
-	{ CTL_INT,	NET_LLC2_P_TIMEOUT,	"p" },
-	{ CTL_INT,	NET_LLC2_REJ_TIMEOUT,	"rej" },
-	{ CTL_INT,	NET_LLC2_BUSY_TIMEOUT,	"busy" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_station_table[] = {
-	{ CTL_INT,	NET_LLC_STATION_ACK_TIMEOUT,	"ack_timeout" },
-	{}
-};
-
-static const struct bin_table bin_net_llc_llc2_table[] = {
-	{ CTL_DIR,	NET_LLC2,		"timeout",	bin_net_llc_llc2_timeout_table },
-	{}
-};
-
-static const struct bin_table bin_net_llc_table[] = {
-	{ CTL_DIR,	NET_LLC2,		"llc2",		bin_net_llc_llc2_table },
-	{ CTL_DIR,	NET_LLC_STATION,	"station",	bin_net_llc_station_table },
-	{}
-};
-
-static const struct bin_table bin_net_netfilter_table[] = {
-	{ CTL_INT,	NET_NF_CONNTRACK_MAX,			"nf_conntrack_max" },
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT "nf_conntrack_tcp_timeout_syn_sent" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV "nf_conntrack_tcp_timeout_syn_recv" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED "nf_conntrack_tcp_timeout_established" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT "nf_conntrack_tcp_timeout_fin_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT "nf_conntrack_tcp_timeout_close_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK "nf_conntrack_tcp_timeout_last_ack" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT "nf_conntrack_tcp_timeout_time_wait" no longer used */
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE "nf_conntrack_tcp_timeout_close" no longer used */
-	/* NET_NF_CONNTRACK_UDP_TIMEOUT	"nf_conntrack_udp_timeout" no longer used */
-	/* NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM "nf_conntrack_udp_timeout_stream" no longer used */
-	/* NET_NF_CONNTRACK_ICMP_TIMEOUT "nf_conntrack_icmp_timeout" no longer used */
-	/* NET_NF_CONNTRACK_GENERIC_TIMEOUT "nf_conntrack_generic_timeout" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_BUCKETS,		"nf_conntrack_buckets" },
-	{ CTL_INT,	NET_NF_CONNTRACK_LOG_INVALID,		"nf_conntrack_log_invalid" },
-	/* NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS "nf_conntrack_tcp_timeout_max_retrans" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_LOOSE,		"nf_conntrack_tcp_loose" },
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_BE_LIBERAL,	"nf_conntrack_tcp_be_liberal" },
-	{ CTL_INT,	NET_NF_CONNTRACK_TCP_MAX_RETRANS,	"nf_conntrack_tcp_max_retrans" },
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED "nf_conntrack_sctp_timeout_closed" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT "nf_conntrack_sctp_timeout_cookie_wait" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED "nf_conntrack_sctp_timeout_cookie_echoed" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED "nf_conntrack_sctp_timeout_established" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT "nf_conntrack_sctp_timeout_shutdown_sent" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD "nf_conntrack_sctp_timeout_shutdown_recd" no longer used */
-	/* NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT "nf_conntrack_sctp_timeout_shutdown_ack_sent" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_COUNT,			"nf_conntrack_count" },
-	/* NET_NF_CONNTRACK_ICMPV6_TIMEOUT "nf_conntrack_icmpv6_timeout" no longer used */
-	/* NET_NF_CONNTRACK_FRAG6_TIMEOUT "nf_conntrack_frag6_timeout" no longer used */
-	{ CTL_INT,	NET_NF_CONNTRACK_FRAG6_LOW_THRESH,	"nf_conntrack_frag6_low_thresh" },
-	{ CTL_INT,	NET_NF_CONNTRACK_FRAG6_HIGH_THRESH,	"nf_conntrack_frag6_high_thresh" },
-	{ CTL_INT,	NET_NF_CONNTRACK_CHECKSUM,		"nf_conntrack_checksum" },
-
-	{}
-};
-
-static const struct bin_table bin_net_irda_table[] = {
-	{ CTL_INT,	NET_IRDA_DISCOVERY,		"discovery" },
-	{ CTL_STR,	NET_IRDA_DEVNAME,		"devname" },
-	{ CTL_INT,	NET_IRDA_DEBUG,			"debug" },
-	{ CTL_INT,	NET_IRDA_FAST_POLL,		"fast_poll_increase" },
-	{ CTL_INT,	NET_IRDA_DISCOVERY_SLOTS,	"discovery_slots" },
-	{ CTL_INT,	NET_IRDA_DISCOVERY_TIMEOUT,	"discovery_timeout" },
-	{ CTL_INT,	NET_IRDA_SLOT_TIMEOUT,		"slot_timeout" },
-	{ CTL_INT,	NET_IRDA_MAX_BAUD_RATE,		"max_baud_rate" },
-	{ CTL_INT,	NET_IRDA_MIN_TX_TURN_TIME,	"min_tx_turn_time" },
-	{ CTL_INT,	NET_IRDA_MAX_TX_DATA_SIZE,	"max_tx_data_size" },
-	{ CTL_INT,	NET_IRDA_MAX_TX_WINDOW,		"max_tx_window" },
-	{ CTL_INT,	NET_IRDA_MAX_NOREPLY_TIME,	"max_noreply_time" },
-	{ CTL_INT,	NET_IRDA_WARN_NOREPLY_TIME,	"warn_noreply_time" },
-	{ CTL_INT,	NET_IRDA_LAP_KEEPALIVE_TIME,	"lap_keepalive_time" },
-	{}
-};
-
-static const struct bin_table bin_net_table[] = {
-	{ CTL_DIR,	NET_CORE,		"core",		bin_net_core_table },
-	/* NET_ETHER not used */
-	/* NET_802 not used */
-	{ CTL_DIR,	NET_UNIX,		"unix",		bin_net_unix_table },
-	{ CTL_DIR,	NET_IPV4,		"ipv4",		bin_net_ipv4_table },
-	{ CTL_DIR,	NET_IPX,		"ipx",		bin_net_ipx_table },
-	{ CTL_DIR,	NET_ATALK,		"appletalk",	bin_net_atalk_table },
-	{ CTL_DIR,	NET_NETROM,		"netrom",	bin_net_netrom_table },
-	{ CTL_DIR,	NET_AX25,		"ax25",		bin_net_ax25_table },
-	/*  NET_BRIDGE "bridge" no longer used */
-	{ CTL_DIR,	NET_ROSE,		"rose",		bin_net_rose_table },
-	{ CTL_DIR,	NET_IPV6,		"ipv6",		bin_net_ipv6_table },
-	{ CTL_DIR,	NET_X25,		"x25",		bin_net_x25_table },
-	{ CTL_DIR,	NET_TR,			"token-ring",	bin_net_tr_table },
-	{ CTL_DIR,	NET_DECNET,		"decnet",	bin_net_decnet_table },
-	/*  NET_ECONET not used */
-	{ CTL_DIR,	NET_SCTP,		"sctp",		bin_net_sctp_table },
-	{ CTL_DIR,	NET_LLC,		"llc",		bin_net_llc_table },
-	{ CTL_DIR,	NET_NETFILTER,		"netfilter",	bin_net_netfilter_table },
-	/* NET_DCCP "dccp" no longer used */
-	{ CTL_DIR,	NET_IRDA,		"irda",		bin_net_irda_table },
-	{ CTL_INT,	2089,			"nf_conntrack_max" },
-	{}
-};
-
-static const struct bin_table bin_fs_quota_table[] = {
-	{ CTL_INT,	FS_DQ_LOOKUPS,		"lookups" },
-	{ CTL_INT,	FS_DQ_DROPS,		"drops" },
-	{ CTL_INT,	FS_DQ_READS,		"reads" },
-	{ CTL_INT,	FS_DQ_WRITES,		"writes" },
-	{ CTL_INT,	FS_DQ_CACHE_HITS,	"cache_hits" },
-	{ CTL_INT,	FS_DQ_ALLOCATED,	"allocated_dquots" },
-	{ CTL_INT,	FS_DQ_FREE,		"free_dquots" },
-	{ CTL_INT,	FS_DQ_SYNCS,		"syncs" },
-	{ CTL_INT,	FS_DQ_WARNINGS,		"warnings" },
-	{}
-};
-
-static const struct bin_table bin_fs_xfs_table[] = {
-	{ CTL_INT,	XFS_SGID_INHERIT,	"irix_sgid_inherit" },
-	{ CTL_INT,	XFS_SYMLINK_MODE,	"irix_symlink_mode" },
-	{ CTL_INT,	XFS_PANIC_MASK,		"panic_mask" },
-
-	{ CTL_INT,	XFS_ERRLEVEL,		"error_level" },
-	{ CTL_INT,	XFS_SYNCD_TIMER,	"xfssyncd_centisecs" },
-	{ CTL_INT,	XFS_INHERIT_SYNC,	"inherit_sync" },
-	{ CTL_INT,	XFS_INHERIT_NODUMP,	"inherit_nodump" },
-	{ CTL_INT,	XFS_INHERIT_NOATIME,	"inherit_noatime" },
-	{ CTL_INT,	XFS_BUF_TIMER,		"xfsbufd_centisecs" },
-	{ CTL_INT,	XFS_BUF_AGE,		"age_buffer_centisecs" },
-	{ CTL_INT,	XFS_INHERIT_NOSYM,	"inherit_nosymlinks" },
-	{ CTL_INT,	XFS_ROTORSTEP,	"rotorstep" },
-	{ CTL_INT,	XFS_INHERIT_NODFRG,	"inherit_nodefrag" },
-	{ CTL_INT,	XFS_FILESTREAM_TIMER,	"filestream_centisecs" },
-	{ CTL_INT,	XFS_STATS_CLEAR,	"stats_clear" },
-	{}
-};
-
-static const struct bin_table bin_fs_ocfs2_nm_table[] = {
-	{ CTL_STR,	1, "hb_ctl_path" },
-	{}
-};
-
-static const struct bin_table bin_fs_ocfs2_table[] = {
-	{ CTL_DIR,	1,	"nm",	bin_fs_ocfs2_nm_table },
-	{}
-};
-
-static const struct bin_table bin_inotify_table[] = {
-	{ CTL_INT,	INOTIFY_MAX_USER_INSTANCES,	"max_user_instances" },
-	{ CTL_INT,	INOTIFY_MAX_USER_WATCHES,	"max_user_watches" },
-	{ CTL_INT,	INOTIFY_MAX_QUEUED_EVENTS,	"max_queued_events" },
-	{}
-};
-
-static const struct bin_table bin_fs_table[] = {
-	{ CTL_INT,	FS_NRINODE,		"inode-nr" },
-	{ CTL_INT,	FS_STATINODE,		"inode-state" },
-	/* FS_MAXINODE unused */
-	/* FS_NRDQUOT unused */
-	/* FS_MAXDQUOT unused */
-	/* FS_NRFILE "file-nr" no longer used */
-	{ CTL_INT,	FS_MAXFILE,		"file-max" },
-	{ CTL_INT,	FS_DENTRY,		"dentry-state" },
-	/* FS_NRSUPER unused */
-	/* FS_MAXUPSER unused */
-	{ CTL_INT,	FS_OVERFLOWUID,		"overflowuid" },
-	{ CTL_INT,	FS_OVERFLOWGID,		"overflowgid" },
-	{ CTL_INT,	FS_LEASES,		"leases-enable" },
-	{ CTL_INT,	FS_DIR_NOTIFY,		"dir-notify-enable" },
-	{ CTL_INT,	FS_LEASE_TIME,		"lease-break-time" },
-	{ CTL_DIR,	FS_DQSTATS,		"quota",	bin_fs_quota_table },
-	{ CTL_DIR,	FS_XFS,			"xfs",		bin_fs_xfs_table },
-	{ CTL_ULONG,	FS_AIO_NR,		"aio-nr" },
-	{ CTL_ULONG,	FS_AIO_MAX_NR,		"aio-max-nr" },
-	{ CTL_DIR,	FS_INOTIFY,		"inotify",	bin_inotify_table },
-	{ CTL_DIR,	FS_OCFS2,		"ocfs2",	bin_fs_ocfs2_table },
-	{ CTL_INT,	KERN_SETUID_DUMPABLE,	"suid_dumpable" },
-	{}
-};
-
-static const struct bin_table bin_ipmi_table[] = {
-	{ CTL_INT,	DEV_IPMI_POWEROFF_POWERCYCLE,	"poweroff_powercycle" },
-	{}
-};
-
-static const struct bin_table bin_mac_hid_files[] = {
-	/* DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES unused */
-	/* DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES unused */
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON_EMULATION,	"mouse_button_emulation" },
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE,	"mouse_button2_keycode" },
-	{ CTL_INT,	DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE,	"mouse_button3_keycode" },
-	/* DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES unused */
-	{}
-};
-
-static const struct bin_table bin_raid_table[] = {
-	{ CTL_INT,	DEV_RAID_SPEED_LIMIT_MIN,	"speed_limit_min" },
-	{ CTL_INT,	DEV_RAID_SPEED_LIMIT_MAX,	"speed_limit_max" },
-	{}
-};
-
-static const struct bin_table bin_scsi_table[] = {
-	{ CTL_INT, DEV_SCSI_LOGGING_LEVEL, "logging_level" },
-	{}
-};
-
-static const struct bin_table bin_dev_table[] = {
-	/* DEV_CDROM	"cdrom" no longer used */
-	/* DEV_HWMON unused */
-	/* DEV_PARPORT	"parport" no longer used */
-	{ CTL_DIR,	DEV_RAID,	"raid",		bin_raid_table },
-	{ CTL_DIR,	DEV_MAC_HID,	"mac_hid",	bin_mac_hid_files },
-	{ CTL_DIR,	DEV_SCSI,	"scsi",		bin_scsi_table },
-	{ CTL_DIR,	DEV_IPMI,	"ipmi",		bin_ipmi_table },
-	{}
-};
-
-static const struct bin_table bin_bus_isa_table[] = {
-	{ CTL_INT,	BUS_ISA_MEM_BASE,	"membase" },
-	{ CTL_INT,	BUS_ISA_PORT_BASE,	"portbase" },
-	{ CTL_INT,	BUS_ISA_PORT_SHIFT,	"portshift" },
-	{}
-};
-
-static const struct bin_table bin_bus_table[] = {
-	{ CTL_DIR,	CTL_BUS_ISA,	"isa",	bin_bus_isa_table },
-	{}
-};
-
-
-static const struct bin_table bin_s390dbf_table[] = {
-	{ CTL_INT,	5678 /* CTL_S390DBF_STOPPABLE */, "debug_stoppable" },
-	{ CTL_INT,	5679 /* CTL_S390DBF_ACTIVE */,	  "debug_active" },
-	{}
-};
-
-static const struct bin_table bin_sunrpc_table[] = {
-	/* CTL_RPCDEBUG	"rpc_debug"  no longer used */
-	/* CTL_NFSDEBUG "nfs_debug"  no longer used */
-	/* CTL_NFSDDEBUG "nfsd_debug" no longer used  */
-	/* CTL_NLMDEBUG "nlm_debug" no longer used */
-
-	{ CTL_INT,	CTL_SLOTTABLE_UDP,	"udp_slot_table_entries" },
-	{ CTL_INT,	CTL_SLOTTABLE_TCP,	"tcp_slot_table_entries" },
-	{ CTL_INT,	CTL_MIN_RESVPORT,	"min_resvport" },
-	{ CTL_INT,	CTL_MAX_RESVPORT,	"max_resvport" },
-	{}
-};
-
-static const struct bin_table bin_pm_table[] = {
-	/* frv specific */
-	/* 1 == CTL_PM_SUSPEND	"suspend"  no longer used" */
-	{ CTL_INT,	2 /* CTL_PM_CMODE */,		"cmode" },
-	{ CTL_INT,	3 /* CTL_PM_P0 */,		"p0" },
-	{ CTL_INT,	4 /* CTL_PM_CM */,		"cm" },
-	{}
-};
-
-static const struct bin_table bin_root_table[] = {
-	{ CTL_DIR,	CTL_KERN,	"kernel",	bin_kern_table },
-	{ CTL_DIR,	CTL_VM,		"vm",		bin_vm_table },
-	{ CTL_DIR,	CTL_NET,	"net",		bin_net_table },
-	/* CTL_PROC not used */
-	{ CTL_DIR,	CTL_FS,		"fs",		bin_fs_table },
-	/* CTL_DEBUG "debug" no longer used */
-	{ CTL_DIR,	CTL_DEV,	"dev",		bin_dev_table },
-	{ CTL_DIR,	CTL_BUS,	"bus",		bin_bus_table },
-	{ CTL_DIR,	CTL_ABI,	"abi" },
-	/* CTL_CPU not used */
-	/* CTL_ARLAN "arlan" no longer used */
-	{ CTL_DIR,	CTL_S390DBF,	"s390dbf",	bin_s390dbf_table },
-	{ CTL_DIR,	CTL_SUNRPC,	"sunrpc",	bin_sunrpc_table },
-	{ CTL_DIR,	CTL_PM,		"pm",		bin_pm_table },
-	{}
-};
-
-static ssize_t bin_dir(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	return -ENOTDIR;
-}
-
-
-static ssize_t bin_string(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	ssize_t result, copied = 0;
-
-	if (oldval && oldlen) {
-		char __user *lastp;
-		loff_t pos = 0;
-		int ch;
-
-		result = vfs_read(file, oldval, oldlen, &pos);
-		if (result < 0)
-			goto out;
-
-		copied = result;
-		lastp = oldval + copied - 1;
-
-		result = -EFAULT;
-		if (get_user(ch, lastp))
-			goto out;
-
-		/* Trim off the trailing newline */
-		if (ch == '\n') {
-			result = -EFAULT;
-			if (put_user('\0', lastp))
-				goto out;
-			copied -= 1;
-		}
-	}
-
-	if (newval && newlen) {
-		loff_t pos = 0;
-
-		result = vfs_write(file, newval, newlen, &pos);
-		if (result < 0)
-			goto out;
-	}
-
-	result = copied;
-out:
-	return result;
-}
-
-static ssize_t bin_intvec(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t copied = 0;
-	char *buffer;
-	ssize_t result;
-
-	result = -ENOMEM;
-	buffer = kmalloc(BUFSZ, GFP_KERNEL);
-	if (!buffer)
-		goto out;
-
-	if (oldval && oldlen) {
-		unsigned __user *vec = oldval;
-		size_t length = oldlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-
-		str = buffer;
-		end = str + result;
-		*end++ = '\0';
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			value = simple_strtoul(str, &str, 10);
-			while (isspace(*str))
-				str++;
-			
-			result = -EFAULT;
-			if (put_user(value, vec + i))
-				goto out_kfree;
-
-			copied += sizeof(*vec);
-			if (!isdigit(*str))
-				break;
-		}
-	}
-
-	if (newval && newlen) {
-		unsigned __user *vec = newval;
-		size_t length = newlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		str = buffer;
-		end = str + BUFSZ;
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			result = -EFAULT;
-			if (get_user(value, vec + i))
-				goto out_kfree;
-
-			str += snprintf(str, end - str, "%lu\t", value);
-		}
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buffer, str - buffer, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-	}
-	result = copied;
-out_kfree:
-	kfree(buffer);
-out:
-	return result;
-}
-
-static ssize_t bin_ulongvec(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t copied = 0;
-	char *buffer;
-	ssize_t result;
-
-	result = -ENOMEM;
-	buffer = kmalloc(BUFSZ, GFP_KERNEL);
-	if (!buffer)
-		goto out;
-
-	if (oldval && oldlen) {
-		unsigned long __user *vec = oldval;
-		size_t length = oldlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-
-		str = buffer;
-		end = str + result;
-		*end++ = '\0';
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			value = simple_strtoul(str, &str, 10);
-			while (isspace(*str))
-				str++;
-			
-			result = -EFAULT;
-			if (put_user(value, vec + i))
-				goto out_kfree;
-
-			copied += sizeof(*vec);
-			if (!isdigit(*str))
-				break;
-		}
-	}
-
-	if (newval && newlen) {
-		unsigned long __user *vec = newval;
-		size_t length = newlen / sizeof(*vec);
-		loff_t pos = 0;
-		char *str, *end;
-		int i;
-
-		str = buffer;
-		end = str + BUFSZ;
-		for (i = 0; i < length; i++) {
-			unsigned long value;
-
-			result = -EFAULT;
-			if (get_user(value, vec + i))
-				goto out_kfree;
-
-			str += snprintf(str, end - str, "%lu\t", value);
-		}
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buffer, str - buffer, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out_kfree;
-	}
-	result = copied;
-out_kfree:
-	kfree(buffer);
-out:
-	return result;
-}
-
-static ssize_t bin_uuid(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t result, copied = 0;
-
-	/* Only supports reads */
-	if (oldval && oldlen) {
-		loff_t pos = 0;
-		char buf[40], *str = buf;
-		unsigned char uuid[16];
-		int i;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-
-		buf[result] = '\0';
-
-		/* Convert the uuid to from a string to binary */
-		for (i = 0; i < 16; i++) {
-			result = -EIO;
-			if (!isxdigit(str[0]) || !isxdigit(str[1]))
-				goto out;
-
-			uuid[i] = (hex_to_bin(str[0]) << 4) |
-					hex_to_bin(str[1]);
-			str += 2;
-			if (*str == '-')
-				str++;
-		}
-
-		if (oldlen > 16)
-			oldlen = 16;
-
-		result = -EFAULT;
-		if (copy_to_user(oldval, uuid, oldlen))
-			goto out;
-
-		copied = oldlen;
-	}
-	result = copied;
-out:
-	return result;
-}
-
-static ssize_t bin_dn_node_address(struct file *file,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	mm_segment_t old_fs = get_fs();
-	ssize_t result, copied = 0;
-
-	if (oldval && oldlen) {
-		loff_t pos = 0;
-		char buf[15], *nodep;
-		unsigned long area, node;
-		__le16 dnaddr;
-
-		set_fs(KERNEL_DS);
-		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-
-		buf[result] = '\0';
-
-		/* Convert the decnet address to binary */
-		result = -EIO;
-		nodep = strchr(buf, '.') + 1;
-		if (!nodep)
-			goto out;
-
-		area = simple_strtoul(buf, NULL, 10);
-		node = simple_strtoul(nodep, NULL, 10);
-
-		result = -EIO;
-		if ((area > 63)||(node > 1023))
-			goto out;
-
-		dnaddr = cpu_to_le16((area << 10) | node);
-
-		result = -EFAULT;
-		if (put_user(dnaddr, (__le16 __user *)oldval))
-			goto out;
-
-		copied = sizeof(dnaddr);
-	}
-
-	if (newval && newlen) {
-		loff_t pos = 0;
-		__le16 dnaddr;
-		char buf[15];
-		int len;
-
-		result = -EINVAL;
-		if (newlen != sizeof(dnaddr))
-			goto out;
-
-		result = -EFAULT;
-		if (get_user(dnaddr, (__le16 __user *)newval))
-			goto out;
-
-		len = snprintf(buf, sizeof(buf), "%hu.%hu",
-				le16_to_cpu(dnaddr) >> 10,
-				le16_to_cpu(dnaddr) & 0x3ff);
-
-		set_fs(KERNEL_DS);
-		result = vfs_write(file, buf, len, &pos);
-		set_fs(old_fs);
-		if (result < 0)
-			goto out;
-	}
-
-	result = copied;
-out:
-	return result;
-}
-
-static const struct bin_table *get_sysctl(const int *name, int nlen, char *path)
-{
-	const struct bin_table *table = &bin_root_table[0];
-	int ctl_name;
-
-	/* The binary sysctl tables have a small maximum depth so
-	 * there is no danger of overflowing our path as it PATH_MAX
-	 * bytes long.
-	 */
-	memcpy(path, "sys/", 4);
-	path += 4;
-
-repeat:
-	if (!nlen)
-		return ERR_PTR(-ENOTDIR);
-	ctl_name = *name;
-	name++;
-	nlen--;
-	for ( ; table->convert; table++) {
-		int len = 0;
-
-		/*
-		 * For a wild card entry map from ifindex to network
-		 * device name.
-		 */
-		if (!table->ctl_name) {
-#ifdef CONFIG_NET
-			struct net *net = current->nsproxy->net_ns;
-			struct net_device *dev;
-			dev = dev_get_by_index(net, ctl_name);
-			if (dev) {
-				len = strlen(dev->name);
-				memcpy(path, dev->name, len);
-				dev_put(dev);
-			}
-#endif
-		/* Use the well known sysctl number to proc name mapping */
-		} else if (ctl_name == table->ctl_name) {
-			len = strlen(table->procname);
-			memcpy(path, table->procname, len);
-		}
-		if (len) {
-			path += len;
-			if (table->child) {
-				*path++ = '/';
-				table = table->child;
-				goto repeat;
-			}
-			*path = '\0';
-			return table;
-		}
-	}
-	return ERR_PTR(-ENOTDIR);
-}
-
-static char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)
-{
-	char *tmp, *result;
-
-	result = ERR_PTR(-ENOMEM);
-	tmp = __getname();
-	if (tmp) {
-		const struct bin_table *table = get_sysctl(name, nlen, tmp);
-		result = tmp;
-		*tablep = table;
-		if (IS_ERR(table)) {
-			__putname(tmp);
-			result = ERR_CAST(table);
-		}
-	}
-	return result;
-}
-
-static ssize_t binary_sysctl(const int *name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	const struct bin_table *table = NULL;
-	struct vfsmount *mnt;
-	struct file *file;
-	ssize_t result;
-	char *pathname;
-	int flags;
-
-	pathname = sysctl_getname(name, nlen, &table);
-	result = PTR_ERR(pathname);
-	if (IS_ERR(pathname))
-		goto out;
-
-	/* How should the sysctl be accessed? */
-	if (oldval && oldlen && newval && newlen) {
-		flags = O_RDWR;
-	} else if (newval && newlen) {
-		flags = O_WRONLY;
-	} else if (oldval && oldlen) {
-		flags = O_RDONLY;
-	} else {
-		result = 0;
-		goto out_putname;
-	}
-
-	mnt = current->nsproxy->pid_ns->proc_mnt;
-	file = file_open_root(mnt->mnt_root, mnt, pathname, flags);
-	result = PTR_ERR(file);
-	if (IS_ERR(file))
-		goto out_putname;
-
-	result = table->convert(file, oldval, oldlen, newval, newlen);
-
-	fput(file);
-out_putname:
-	__putname(pathname);
-out:
-	return result;
-}
-
-
-#else /* CONFIG_SYSCTL_SYSCALL */
-
-static ssize_t binary_sysctl(const int *name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	return -ENOSYS;
-}
-
-#endif /* CONFIG_SYSCTL_SYSCALL */
-
-
-static void deprecated_sysctl_warning(const int *name, int nlen)
-{
-	int i;
-
-	/*
-	 * CTL_KERN/KERN_VERSION is used by older glibc and cannot
-	 * ever go away.
-	 */
-	if (name[0] == CTL_KERN && name[1] == KERN_VERSION)
-		return;
-
-	if (printk_ratelimit()) {
-		printk(KERN_INFO
-			"warning: process `%s' used the deprecated sysctl "
-			"system call with ", current->comm);
-		for (i = 0; i < nlen; i++)
-			printk("%d.", name[i]);
-		printk("\n");
-	}
-	return;
-}
-
-#define WARN_ONCE_HASH_BITS 8
-#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)
-
-static DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);
-
-#define FNV32_OFFSET 2166136261U
-#define FNV32_PRIME 0x01000193
-
-/*
- * Print each legacy sysctl (approximately) only once.
- * To avoid making the tables non-const use a external
- * hash-table instead.
- * Worst case hash collision: 6, but very rarely.
- * NOTE! We don't use the SMP-safe bit tests. We simply
- * don't care enough.
- */
-static void warn_on_bintable(const int *name, int nlen)
-{
-	int i;
-	u32 hash = FNV32_OFFSET;
-
-	for (i = 0; i < nlen; i++)
-		hash = (hash ^ name[i]) * FNV32_PRIME;
-	hash %= WARN_ONCE_HASH_SIZE;
-	if (__test_and_set_bit(hash, warn_once_bitmap))
-		return;
-	deprecated_sysctl_warning(name, nlen);
-}
-
-static ssize_t do_sysctl(int __user *args_name, int nlen,
-	void __user *oldval, size_t oldlen, void __user *newval, size_t newlen)
-{
-	int name[CTL_MAXNAME];
-	int i;
-
-	/* Check args->nlen. */
-	if (nlen < 0 || nlen > CTL_MAXNAME)
-		return -ENOTDIR;
-	/* Read in the sysctl name for simplicity */
-	for (i = 0; i < nlen; i++)
-		if (get_user(name[i], args_name + i))
-			return -EFAULT;
-
-	warn_on_bintable(name, nlen);
-
-	return binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);
-}
-
-SYSCALL_DEFINE1(sysctl, struct __sysctl_args __user *, args)
-{
-	struct __sysctl_args tmp;
-	size_t oldlen = 0;
-	ssize_t result;
-
-	if (copy_from_user(&tmp, args, sizeof(tmp)))
-		return -EFAULT;
-
-	if (tmp.oldval && !tmp.oldlenp)
-		return -EFAULT;
-
-	if (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))
-		return -EFAULT;
-
-	result = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,
-			   tmp.newval, tmp.newlen);
-
-	if (result >= 0) {
-		oldlen = result;
-		result = 0;
-	}
-
-	if (tmp.oldlenp && put_user(oldlen, tmp.oldlenp))
-		return -EFAULT;
-
-	return result;
-}
-
-
-#ifdef CONFIG_COMPAT
-#include <asm/compat.h>
-
-struct compat_sysctl_args {
-	compat_uptr_t	name;
-	int		nlen;
-	compat_uptr_t	oldval;
-	compat_uptr_t	oldlenp;
-	compat_uptr_t	newval;
-	compat_size_t	newlen;
-	compat_ulong_t	__unused[4];
-};
-
-asmlinkage long compat_sys_sysctl(struct compat_sysctl_args __user *args)
-{
-	struct compat_sysctl_args tmp;
-	compat_size_t __user *compat_oldlenp;
-	size_t oldlen = 0;
-	ssize_t result;
-
-	if (copy_from_user(&tmp, args, sizeof(tmp)))
-		return -EFAULT;
-
-	if (tmp.oldval && !tmp.oldlenp)
-		return -EFAULT;
-
-	compat_oldlenp = compat_ptr(tmp.oldlenp);
-	if (compat_oldlenp && get_user(oldlen, compat_oldlenp))
-		return -EFAULT;
-
-	result = do_sysctl(compat_ptr(tmp.name), tmp.nlen,
-			   compat_ptr(tmp.oldval), oldlen,
-			   compat_ptr(tmp.newval), tmp.newlen);
-
-	if (result >= 0) {
-		oldlen = result;
-		result = 0;
-	}
-
-	if (compat_oldlenp && put_user(oldlen, compat_oldlenp))
-		return -EFAULT;
-
-	return result;
-}
-
-#endif /* CONFIG_COMPAT */

-/*
- * linux/mm/mmzone.c
- *
- * management codes for pgdats and zones.
- */
-
-
-#include <linux/stddef.h>
-#include <linux/mm.h>
-#include <linux/mmzone.h>
-
-struct pglist_data *first_online_pgdat(void)
-{
-	return NODE_DATA(first_online_node);
-}
-
-struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)
-{
-	int nid = next_online_node(pgdat->node_id);
-
-	if (nid == MAX_NUMNODES)
-		return NULL;
-	return NODE_DATA(nid);
-}
-
-/*
- * next_zone - helper magic for for_each_zone()
- */
-struct zone *next_zone(struct zone *zone)
-{
-	pg_data_t *pgdat = zone->zone_pgdat;
-
-	if (zone < pgdat->node_zones + MAX_NR_ZONES - 1)
-		zone++;
-	else {
-		pgdat = next_online_pgdat(pgdat);
-		if (pgdat)
-			zone = pgdat->node_zones;
-		else
-			zone = NULL;
-	}
-	return zone;
-}
-
-static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)
-{
-#ifdef CONFIG_NUMA
-	return node_isset(zonelist_node_idx(zref), *nodes);
-#else
-	return 1;
-#endif /* CONFIG_NUMA */
-}
-
-/* Returns the next zone at or below highest_zoneidx in a zonelist */
-struct zoneref *next_zones_zonelist(struct zoneref *z,
-					enum zone_type highest_zoneidx,
-					nodemask_t *nodes,
-					struct zone **zone)
-{
-	/*
-	 * Find the next suitable zone to use for the allocation.
-	 * Only filter based on nodemask if it's set
-	 */
-	if (likely(nodes == NULL))
-		while (zonelist_zone_idx(z) > highest_zoneidx)
-			z++;
-	else
-		while (zonelist_zone_idx(z) > highest_zoneidx ||
-				(z->zone && !zref_in_nodemask(z, nodes)))
-			z++;
-
-	*zone = zonelist_zone(z);
-	return z;
-}
-
-#ifdef CONFIG_ARCH_HAS_HOLES_MEMORYMODEL
-int memmap_valid_within(unsigned long pfn,
-					struct page *page, struct zone *zone)
-{
-	if (page_to_pfn(page) != pfn)
-		return 0;
-
-	if (page_zone(page) != zone)
-		return 0;
-
-	return 1;
-}
-#endif /* CONFIG_ARCH_HAS_HOLES_MEMORYMODEL */
diff -urN flo-ElementalX-5.00/net/bluetooth/Kconfig flo-ElementalX-5.00-patched/net/bluetooth/Kconfig
--- flo-ElementalX-5.00/net/bluetooth/Kconfig	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/Kconfig	2016-06-02 00:28:55.000000000 +0000
@@ -11,8 +11,6 @@
 	select CRYPTO_BLKCIPHER
 	select CRYPTO_AES
 	select CRYPTO_ECB
-	select CRYPTO_HMAC
-	select CRYPTO_SHA256
 	help
 	  Bluetooth is low-cost, low-power, short-range wireless technology.
 	  It was designed as a replacement for cables and other short-range
diff -urN flo-ElementalX-5.00/net/bluetooth/Makefile flo-ElementalX-5.00-patched/net/bluetooth/Makefile
--- flo-ElementalX-5.00/net/bluetooth/Makefile	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/Makefile	2016-06-02 00:28:55.000000000 +0000
@@ -9,5 +9,4 @@
 obj-$(CONFIG_BT_HIDP)	+= hidp/
 
 bluetooth-y := af_bluetooth.o hci_core.o hci_conn.o hci_event.o mgmt.o \
-	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o \
-	amp.o
+	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o
diff -urN flo-ElementalX-5.00/net/bluetooth/af_bluetooth.c flo-ElementalX-5.00-patched/net/bluetooth/af_bluetooth.c
--- flo-ElementalX-5.00/net/bluetooth/af_bluetooth.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/af_bluetooth.c	2016-06-02 00:28:55.000000000 +0000
@@ -40,15 +40,6 @@
 
 #include <net/bluetooth/bluetooth.h>
 
-#ifdef CONFIG_ANDROID_PARANOID_NETWORK
-#include <linux/android_aid.h>
-#endif
-
-#ifndef CONFIG_BT_SOCK_DEBUG
-#undef  BT_DBG
-#define BT_DBG(D...)
-#endif
-
 #define VERSION "2.16"
 
 /* Bluetooth sockets */
@@ -80,19 +71,16 @@
 	"slock-AF_BLUETOOTH-BTPROTO_AVDTP",
 };
 
-static inline void bt_sock_reclassify_lock(struct socket *sock, int proto)
+void bt_sock_reclassify_lock(struct sock *sk, int proto)
 {
-	struct sock *sk = sock->sk;
-
-	if (!sk)
-		return;
-
+	BUG_ON(!sk);
 	BUG_ON(sock_owned_by_user(sk));
 
 	sock_lock_init_class_and_name(sk,
 			bt_slock_key_strings[proto], &bt_slock_key[proto],
 				bt_key_strings[proto], &bt_lock_key[proto]);
 }
+EXPORT_SYMBOL(bt_sock_reclassify_lock);
 
 int bt_sock_register(int proto, const struct net_proto_family *ops)
 {
@@ -134,40 +122,11 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
-#ifdef CONFIG_ANDROID_PARANOID_NETWORK
-static inline int current_has_bt_admin(void)
-{
-	return (!current_euid() || in_egroup_p(AID_NET_BT_ADMIN));
-}
-
-static inline int current_has_bt(void)
-{
-	return (current_has_bt_admin() || in_egroup_p(AID_NET_BT));
-}
-# else
-static inline int current_has_bt_admin(void)
-{
-	return 1;
-}
-
-static inline int current_has_bt(void)
-{
-	return 1;
-}
-#endif
-
 static int bt_sock_create(struct net *net, struct socket *sock, int proto,
 			  int kern)
 {
 	int err;
 
-	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
-			proto == BTPROTO_L2CAP) {
-		if (!current_has_bt())
-			return -EPERM;
-	} else if (!current_has_bt_admin())
-		return -EPERM;
-
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
@@ -183,7 +142,8 @@
 
 	if (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {
 		err = bt_proto[proto]->create(net, sock, proto, kern);
-		bt_sock_reclassify_lock(sock, proto);
+		if (!err)
+			bt_sock_reclassify_lock(sock->sk, proto);
 		module_put(bt_proto[proto]->owner);
 	}
 
@@ -194,17 +154,17 @@
 
 void bt_sock_link(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock_bh(&l->lock);
+	write_lock(&l->lock);
 	sk_add_node(sk, &l->head);
-	write_unlock_bh(&l->lock);
+	write_unlock(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_link);
 
 void bt_sock_unlink(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock_bh(&l->lock);
+	write_lock(&l->lock);
 	sk_del_node_init(sk);
-	write_unlock_bh(&l->lock);
+	write_unlock(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_unlink);
 
@@ -237,15 +197,14 @@
 
 	BT_DBG("parent %p", parent);
 
-	local_bh_disable();
 	list_for_each_safe(p, n, &bt_sk(parent)->accept_q) {
 		sk = (struct sock *) list_entry(p, struct bt_sock, accept_q);
 
-		bh_lock_sock(sk);
+		lock_sock(sk);
 
 		/* FIXME: Is this check still needed */
 		if (sk->sk_state == BT_CLOSED) {
-			bh_unlock_sock(sk);
+			release_sock(sk);
 			bt_accept_unlink(sk);
 			continue;
 		}
@@ -256,14 +215,12 @@
 			if (newsock)
 				sock_graft(sk, newsock);
 
-			bh_unlock_sock(sk);
-			local_bh_enable();
+			release_sock(sk);
 			return sk;
 		}
 
-		bh_unlock_sock(sk);
+		release_sock(sk);
 	}
-	local_bh_enable();
 
 	return NULL;
 }
@@ -290,8 +247,6 @@
 		return err;
 	}
 
-	msg->msg_namelen = 0;
-
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
@@ -349,8 +304,6 @@
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
-	msg->msg_namelen = 0;
-
 	BT_DBG("sk %p size %zu", sk, size);
 
 	lock_sock(sk);
@@ -493,7 +446,7 @@
 			sk->sk_state == BT_CONFIG)
 		return mask;
 
-	if (sock_writeable(sk))
+	if (!bt_sk(sk)->suspended && sock_writeable(sk))
 		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
 	else
 		set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
@@ -558,9 +511,8 @@
 	BT_DBG("sk %p", sk);
 
 	add_wait_queue(sk_sleep(sk), &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
 	while (sk->sk_state != state) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
 		if (!timeo) {
 			err = -EINPROGRESS;
 			break;
@@ -574,12 +526,13 @@
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
 			break;
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 	return err;
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/amp.c flo-ElementalX-5.00-patched/net/bluetooth/amp.c
--- flo-ElementalX-5.00/net/bluetooth/amp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/amp.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,2041 +0,0 @@
-/*
-   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 and
-   only version 2 as published by the Free Software Foundation.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-*/
-
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-
-#include <linux/skbuff.h>
-#include <linux/list.h>
-#include <linux/workqueue.h>
-#include <linux/timer.h>
-
-#include <linux/crypto.h>
-#include <linux/scatterlist.h>
-#include <linux/err.h>
-#include <crypto/hash.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
-#include <net/bluetooth/amp.h>
-
-static struct workqueue_struct *amp_workqueue;
-
-LIST_HEAD(amp_mgr_list);
-DEFINE_RWLOCK(amp_mgr_list_lock);
-
-static int send_a2mp(struct socket *sock, u8 *data, int len);
-
-static void ctx_timeout(unsigned long data);
-
-static void launch_ctx(struct amp_mgr *mgr);
-static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data);
-static int kill_ctx(struct amp_ctx *ctx);
-static int cancel_ctx(struct amp_ctx *ctx);
-
-static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst);
-
-static void remove_amp_mgr(struct amp_mgr *mgr)
-{
-	BT_DBG("mgr %p", mgr);
-
-	write_lock(&amp_mgr_list_lock);
-	list_del(&mgr->list);
-	write_unlock(&amp_mgr_list_lock);
-
-	read_lock(&mgr->ctx_list_lock);
-	while (!list_empty(&mgr->ctx_list)) {
-		struct amp_ctx *ctx;
-		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
-		read_unlock(&mgr->ctx_list_lock);
-		BT_DBG("kill ctx %p", ctx);
-		kill_ctx(ctx);
-		read_lock(&mgr->ctx_list_lock);
-	}
-	read_unlock(&mgr->ctx_list_lock);
-
-	kfree(mgr->ctrls);
-
-	kfree(mgr);
-}
-
-static struct amp_mgr *get_amp_mgr_sk(struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct amp_mgr *found = NULL;
-
-	read_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if ((mgr->a2mp_sock) && (mgr->a2mp_sock->sk == sk)) {
-			found = mgr;
-			break;
-		}
-	}
-	read_unlock(&amp_mgr_list_lock);
-	return found;
-}
-
-static struct amp_mgr *get_create_amp_mgr(struct hci_conn *hcon,
-						struct sk_buff *skb)
-{
-	struct amp_mgr *mgr;
-
-	write_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if (mgr->l2cap_conn == hcon->l2cap_data) {
-			BT_DBG("found %p", mgr);
-			write_unlock(&amp_mgr_list_lock);
-			goto gc_finished;
-		}
-	}
-	write_unlock(&amp_mgr_list_lock);
-
-	mgr = kzalloc(sizeof(*mgr), GFP_ATOMIC);
-	if (!mgr)
-		return NULL;
-
-	mgr->l2cap_conn = hcon->l2cap_data;
-	mgr->next_ident = 1;
-	INIT_LIST_HEAD(&mgr->ctx_list);
-	rwlock_init(&mgr->ctx_list_lock);
-	mgr->skb = skb;
-	BT_DBG("hcon %p mgr %p", hcon, mgr);
-	mgr->a2mp_sock = open_fixed_channel(&hcon->hdev->bdaddr, &hcon->dst);
-	if (!mgr->a2mp_sock) {
-		kfree(mgr);
-		return NULL;
-	}
-	write_lock(&amp_mgr_list_lock);
-	list_add(&(mgr->list), &amp_mgr_list);
-	write_unlock(&amp_mgr_list_lock);
-
-gc_finished:
-	return mgr;
-}
-
-static struct amp_ctrl *get_ctrl(struct amp_mgr *mgr, u8 remote_id)
-{
-	if ((mgr->ctrls) && (mgr->ctrls->id == remote_id))
-		return mgr->ctrls;
-	else
-		return NULL;
-}
-
-static struct amp_ctrl *get_create_ctrl(struct amp_mgr *mgr, u8 id)
-{
-	struct amp_ctrl *ctrl;
-
-	BT_DBG("mgr %p, id %d", mgr, id);
-	if ((mgr->ctrls) && (mgr->ctrls->id == id))
-		ctrl = mgr->ctrls;
-	else {
-		kfree(mgr->ctrls);
-		ctrl = kzalloc(sizeof(struct amp_ctrl), GFP_ATOMIC);
-		if (ctrl) {
-			ctrl->mgr = mgr;
-			ctrl->id = id;
-		}
-		mgr->ctrls = ctrl;
-	}
-
-	return ctrl;
-}
-
-static struct amp_ctx *create_ctx(u8 type, u8 state)
-{
-	struct amp_ctx *ctx = NULL;
-
-	ctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);
-	if (ctx) {
-		ctx->type = type;
-		ctx->state = state;
-		init_timer(&(ctx->timer));
-		ctx->timer.function = ctx_timeout;
-		ctx->timer.data = (unsigned long) ctx;
-	}
-	BT_DBG("ctx %p, type %d", ctx, type);
-	return ctx;
-}
-
-static inline void start_ctx(struct amp_mgr *mgr, struct amp_ctx *ctx)
-{
-	BT_DBG("ctx %p", ctx);
-	write_lock(&mgr->ctx_list_lock);
-	list_add(&ctx->list, &mgr->ctx_list);
-	write_unlock(&mgr->ctx_list_lock);
-	ctx->mgr = mgr;
-	execute_ctx(ctx, AMP_INIT, 0);
-}
-
-static void destroy_ctx(struct amp_ctx *ctx)
-{
-	struct amp_mgr *mgr = ctx->mgr;
-
-	BT_DBG("ctx %p deferred %p", ctx, ctx->deferred);
-	del_timer(&ctx->timer);
-	write_lock(&mgr->ctx_list_lock);
-	list_del(&ctx->list);
-	write_unlock(&mgr->ctx_list_lock);
-	if (ctx->deferred)
-		execute_ctx(ctx->deferred, AMP_INIT, 0);
-	kfree(ctx);
-}
-
-static struct amp_ctx *get_ctx_mgr(struct amp_mgr *mgr, u8 type)
-{
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if (ctx->type == type) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_type(struct amp_ctx *cur, u8 type)
-{
-	struct amp_mgr *mgr = cur->mgr;
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if ((ctx->type == type) && (ctx != cur)) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_a2mp(struct amp_mgr *mgr, u8 ident)
-{
-	struct amp_ctx *fnd = NULL;
-	struct amp_ctx *ctx;
-
-	read_lock(&mgr->ctx_list_lock);
-	list_for_each_entry(ctx, &mgr->ctx_list, list) {
-		if ((ctx->evt_type & AMP_A2MP_RSP) &&
-				(ctx->rsp_ident == ident)) {
-			fnd = ctx;
-			break;
-		}
-	}
-	read_unlock(&mgr->ctx_list_lock);
-	return fnd;
-}
-
-static struct amp_ctx *get_ctx_hdev(struct hci_dev *hdev, u8 evt_type,
-					u16 evt_value)
-{
-	struct amp_mgr *mgr;
-	struct amp_ctx *fnd = NULL;
-
-	read_lock(&amp_mgr_list_lock);
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		struct amp_ctx *ctx;
-		read_lock(&mgr->ctx_list_lock);
-		list_for_each_entry(ctx, &mgr->ctx_list, list) {
-			struct hci_dev *ctx_hdev;
-			ctx_hdev = hci_dev_get(ctx->id);
-			if ((ctx_hdev == hdev) && (ctx->evt_type & evt_type)) {
-				switch (evt_type) {
-				case AMP_HCI_CMD_STATUS:
-				case AMP_HCI_CMD_CMPLT:
-					if (ctx->opcode == evt_value)
-						fnd = ctx;
-					break;
-				case AMP_HCI_EVENT:
-					if (ctx->evt_code == (u8) evt_value)
-						fnd = ctx;
-					break;
-				}
-			}
-			if (ctx_hdev)
-				hci_dev_put(ctx_hdev);
-
-			if (fnd)
-				break;
-		}
-		read_unlock(&mgr->ctx_list_lock);
-	}
-	read_unlock(&amp_mgr_list_lock);
-	return fnd;
-}
-
-static inline u8 next_ident(struct amp_mgr *mgr)
-{
-	if (++mgr->next_ident == 0)
-		mgr->next_ident = 1;
-	return mgr->next_ident;
-}
-
-static inline void send_a2mp_cmd2(struct amp_mgr *mgr, u8 ident, u8 code,
-				u16 len, void *data, u16 len2, void *data2)
-{
-	struct a2mp_cmd_hdr *hdr;
-	int plen;
-	u8 *p, *cmd;
-
-	BT_DBG("ident %d code 0x%02x", ident, code);
-	if (!mgr->a2mp_sock)
-		return;
-	plen = sizeof(*hdr) + len + len2;
-	cmd = kzalloc(plen, GFP_ATOMIC);
-	if (!cmd)
-		return;
-	hdr = (struct a2mp_cmd_hdr *) cmd;
-	hdr->code  = code;
-	hdr->ident = ident;
-	hdr->len   = cpu_to_le16(len+len2);
-	p = cmd + sizeof(*hdr);
-	memcpy(p, data, len);
-	p += len;
-	memcpy(p, data2, len2);
-	send_a2mp(mgr->a2mp_sock, cmd, plen);
-	kfree(cmd);
-}
-
-static inline void send_a2mp_cmd(struct amp_mgr *mgr, u8 ident,
-				u8 code, u16 len, void *data)
-{
-	send_a2mp_cmd2(mgr, ident, code, len, data, 0, NULL);
-}
-
-static inline int command_rej(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_cmd_rej *rej;
-	struct amp_ctx *ctx;
-
-	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
-	rej = (struct a2mp_cmd_rej *) skb_pull(skb, sizeof(*hdr));
-	if (skb->len < sizeof(*rej))
-		return -EINVAL;
-	BT_DBG("reason %d", le16_to_cpu(rej->reason));
-	ctx = get_ctx_a2mp(mgr, hdr->ident);
-	if (ctx)
-		kill_ctx(ctx);
-	skb_pull(skb, sizeof(*rej));
-	return 0;
-}
-
-static int send_a2mp_cl(struct amp_mgr *mgr, u8 ident, u8 code, u16 len,
-			void *msg)
-{
-	struct a2mp_cl clist[16];
-	struct a2mp_cl *cl;
-	struct hci_dev *hdev;
-	int num_ctrls = 1, id;
-
-	cl = clist;
-	cl->id  = 0;
-	cl->type = 0;
-	cl->status = 1;
-
-	for (id = 0; id < 16; ++id) {
-		hdev = hci_dev_get(id);
-		if (hdev) {
-			if ((hdev->amp_type != HCI_BREDR) &&
-			test_bit(HCI_UP, &hdev->flags)) {
-				(cl + num_ctrls)->id  = hdev->id;
-				(cl + num_ctrls)->type = hdev->amp_type;
-				(cl + num_ctrls)->status = hdev->amp_status;
-				++num_ctrls;
-			}
-			hci_dev_put(hdev);
-		}
-	}
-	send_a2mp_cmd2(mgr, ident, code, len, msg,
-						num_ctrls*sizeof(*cl), clist);
-
-	return 0;
-}
-
-static void send_a2mp_change_notify(void)
-{
-	struct amp_mgr *mgr;
-
-	list_for_each_entry(mgr, &amp_mgr_list, list) {
-		if (mgr->discovered)
-			send_a2mp_cl(mgr, next_ident(mgr),
-					A2MP_CHANGE_NOTIFY, 0, NULL);
-	}
-}
-
-static inline int discover_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_discover_req *req;
-	u16 *efm;
-	struct a2mp_discover_rsp rsp;
-
-	req = (struct a2mp_discover_req *) skb_pull(skb, sizeof(*hdr));
-	if (skb->len < sizeof(*req))
-		return -EINVAL;
-	efm = (u16 *) skb_pull(skb, sizeof(*req));
-
-	BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(req->mtu),
-		le16_to_cpu(req->ext_feat));
-
-	while (le16_to_cpu(req->ext_feat) & 0x8000) {
-		if (skb->len < sizeof(*efm))
-			return -EINVAL;
-		req->ext_feat = *efm;
-		BT_DBG("efm 0x%4.4x", le16_to_cpu(req->ext_feat));
-		efm = (u16 *) skb_pull(skb, sizeof(*efm));
-	}
-
-	rsp.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
-	rsp.ext_feat = 0;
-
-	mgr->discovered = 1;
-
-	return send_a2mp_cl(mgr, hdr->ident, A2MP_DISCOVER_RSP,
-				sizeof(rsp), &rsp);
-}
-
-static inline int change_notify(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct a2mp_cl *cl;
-
-	cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*hdr));
-	while (skb->len >= sizeof(*cl)) {
-		struct amp_ctrl *ctrl;
-		if (cl->id != 0) {
-			ctrl = get_create_ctrl(mgr, cl->id);
-			if (ctrl != NULL) {
-				ctrl->type = cl->type;
-				ctrl->status = cl->status;
-			}
-		}
-		cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
-	}
-
-	/* TODO find controllers in manager that were not on received */
-	/*      controller list and destroy them */
-	send_a2mp_cmd(mgr, hdr->ident, A2MP_CHANGE_RSP, 0, NULL);
-
-	return 0;
-}
-
-static inline int getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	u8 *data;
-	int id;
-	struct hci_dev *hdev;
-	struct a2mp_getinfo_rsp rsp;
-
-	data = (u8 *) skb_pull(skb, sizeof(*hdr));
-	if (le16_to_cpu(hdr->len) < sizeof(*data))
-		return -EINVAL;
-	if (skb->len < sizeof(*data))
-		return -EINVAL;
-	id = *data;
-	skb_pull(skb, sizeof(*data));
-	rsp.id = id;
-	rsp.status = 1;
-
-	BT_DBG("id %d", id);
-	hdev = hci_dev_get(id);
-
-	if (hdev && hdev->amp_type != HCI_BREDR) {
-		rsp.status = 0;
-		rsp.total_bw = cpu_to_le32(hdev->amp_total_bw);
-		rsp.max_bw = cpu_to_le32(hdev->amp_max_bw);
-		rsp.min_latency = cpu_to_le32(hdev->amp_min_latency);
-		rsp.pal_cap = cpu_to_le16(hdev->amp_pal_cap);
-		rsp.assoc_size = cpu_to_le16(hdev->amp_assoc_size);
-	}
-
-	send_a2mp_cmd(mgr, hdr->ident, A2MP_GETINFO_RSP, sizeof(rsp), &rsp);
-
-	if (hdev)
-		hci_dev_put(hdev);
-
-	return 0;
-}
-
-static void create_physical(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct amp_ctx *ctx = NULL;
-
-	BT_DBG("conn %p", conn);
-	mgr = get_create_amp_mgr(conn->hcon, NULL);
-	if (!mgr)
-		goto cp_finished;
-	BT_DBG("mgr %p", mgr);
-	ctx = create_ctx(AMP_CREATEPHYSLINK, AMP_CPL_INIT);
-	if (!ctx)
-		goto cp_finished;
-	ctx->sk = sk;
-	sock_hold(sk);
-	start_ctx(mgr, ctx);
-	return;
-
-cp_finished:
-	l2cap_amp_physical_complete(-ENOMEM, 0, 0, sk);
-}
-
-static void accept_physical(struct l2cap_conn *lcon, u8 id, struct sock *sk)
-{
-	struct amp_mgr *mgr;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	struct amp_ctx *aplctx = NULL;
-	u8 remote_id = 0;
-	int result = -EINVAL;
-
-	BT_DBG("lcon %p", lcon);
-	hdev = hci_dev_get(id);
-	if (!hdev)
-		goto ap_finished;
-	BT_DBG("hdev %p", hdev);
-	mgr = get_create_amp_mgr(lcon->hcon, NULL);
-	if (!mgr)
-		goto ap_finished;
-	BT_DBG("mgr %p", mgr);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
-					&mgr->l2cap_conn->hcon->dst);
-	if (conn) {
-		BT_DBG("conn %p", hdev);
-		result = 0;
-		remote_id = conn->dst_id;
-		goto ap_finished;
-	}
-	aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
-	if (!aplctx)
-		goto ap_finished;
-	aplctx->sk = sk;
-	sock_hold(sk);
-	return;
-
-ap_finished:
-	if (hdev)
-		hci_dev_put(hdev);
-	l2cap_amp_physical_complete(result, id, remote_id, sk);
-}
-
-static int getampassoc_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct amp_ctx *ctx;
-	struct a2mp_getampassoc_req *req;
-
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (struct a2mp_getampassoc_req *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-
-	ctx = create_ctx(AMP_GETAMPASSOC, AMP_GAA_INIT);
-	if (!ctx)
-		return -ENOMEM;
-	ctx->id = req->id;
-	ctx->d.gaa.req_ident = hdr->ident;
-	ctx->hdev = hci_dev_get(ctx->id);
-	if (ctx->hdev)
-		ctx->d.gaa.assoc = kmalloc(ctx->hdev->amp_assoc_size,
-						GFP_ATOMIC);
-	start_ctx(mgr, ctx);
-	return 0;
-}
-
-static u8 getampassoc_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct sk_buff *skb = (struct sk_buff *) data;
-	struct hci_cp_read_local_amp_assoc cp;
-	struct hci_rp_read_local_amp_assoc *rp;
-	struct a2mp_getampassoc_rsp rsp;
-	u16 rem_len;
-	u16 frag_len;
-
-	rsp.status = 1;
-	if ((evt_type == AMP_KILLED) || (!ctx->hdev) || (!ctx->d.gaa.assoc))
-		goto gaa_finished;
-
-	switch (ctx->state) {
-	case AMP_GAA_INIT:
-		ctx->state = AMP_GAA_RLAA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
-		ctx->d.gaa.len_so_far = 0;
-		cp.phy_handle = 0;
-		cp.len_so_far = 0;
-		cp.max_len = ctx->hdev->amp_assoc_size;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		break;
-
-	case AMP_GAA_RLAA_COMPLETE:
-		if (skb->len < 4)
-			goto gaa_finished;
-		rp = (struct hci_rp_read_local_amp_assoc *) skb->data;
-		if (rp->status)
-			goto gaa_finished;
-		rem_len = le16_to_cpu(rp->rem_len);
-		skb_pull(skb, 4);
-		frag_len = skb->len;
-
-		if (ctx->d.gaa.len_so_far + rem_len <=
-				ctx->hdev->amp_assoc_size) {
-			struct hci_cp_read_local_amp_assoc cp;
-			u8 *assoc = ctx->d.gaa.assoc + ctx->d.gaa.len_so_far;
-			memcpy(assoc, rp->frag, frag_len);
-			ctx->d.gaa.len_so_far += rem_len;
-			rem_len -= frag_len;
-			if (rem_len == 0) {
-				rsp.status = 0;
-				goto gaa_finished;
-			}
-			/* more assoc data to read */
-			cp.phy_handle = 0;
-			cp.len_so_far = ctx->d.gaa.len_so_far;
-			cp.max_len = ctx->hdev->amp_assoc_size;
-			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		}
-		break;
-
-	default:
-		goto gaa_finished;
-		break;
-	}
-	return 0;
-
-gaa_finished:
-	rsp.id = ctx->id;
-	send_a2mp_cmd2(ctx->mgr, ctx->d.gaa.req_ident, A2MP_GETAMPASSOC_RSP,
-			sizeof(rsp), &rsp,
-			ctx->d.gaa.len_so_far, ctx->d.gaa.assoc);
-	kfree(ctx->d.gaa.assoc);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	return 1;
-}
-
-struct hmac_sha256_result {
-	struct completion completion;
-	int err;
-};
-
-static void hmac_sha256_final(struct crypto_async_request *req, int err)
-{
-	struct hmac_sha256_result *r = req->data;
-	if (err == -EINPROGRESS)
-		return;
-	r->err = err;
-	complete(&r->completion);
-}
-
-int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize,
-		u8 *output, u8 outlen)
-{
-	int ret = 0;
-	struct crypto_ahash *tfm;
-	struct scatterlist sg;
-	struct ahash_request *req;
-	struct hmac_sha256_result tresult;
-	void *hash_buff = NULL;
-
-	unsigned char hash_result[64];
-	int i;
-
-	memset(output, 0, outlen);
-
-	init_completion(&tresult.completion);
-
-	tfm = crypto_alloc_ahash("hmac(sha256)", CRYPTO_ALG_TYPE_AHASH,
-				CRYPTO_ALG_TYPE_AHASH_MASK);
-	if (IS_ERR(tfm)) {
-		BT_DBG("crypto_alloc_ahash failed");
-		ret = PTR_ERR(tfm);
-		goto err_tfm;
-	}
-
-	req = ahash_request_alloc(tfm, GFP_KERNEL);
-	if (!req) {
-		BT_DBG("failed to allocate request for hmac(sha256)");
-		ret = -ENOMEM;
-		goto err_req;
-	}
-
-	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
-					hmac_sha256_final, &tresult);
-
-	hash_buff = kzalloc(psize, GFP_KERNEL);
-	if (!hash_buff) {
-		BT_DBG("failed to kzalloc hash_buff");
-		ret = -ENOMEM;
-		goto err_hash_buf;
-	}
-
-	memset(hash_result, 0, 64);
-	memcpy(hash_buff, plaintext, psize);
-	sg_init_one(&sg, hash_buff, psize);
-
-	if (ksize) {
-		crypto_ahash_clear_flags(tfm, ~0);
-		ret = crypto_ahash_setkey(tfm, key, ksize);
-
-		if (ret) {
-			BT_DBG("crypto_ahash_setkey failed");
-			goto err_setkey;
-		}
-	}
-
-	ahash_request_set_crypt(req, &sg, hash_result, psize);
-	ret = crypto_ahash_digest(req);
-
-	BT_DBG("ret 0x%x", ret);
-
-	switch (ret) {
-	case 0:
-		for (i = 0; i < outlen; i++)
-			output[i] = hash_result[i];
-		break;
-	case -EINPROGRESS:
-	case -EBUSY:
-		ret = wait_for_completion_interruptible(&tresult.completion);
-		if (!ret && !tresult.err) {
-			INIT_COMPLETION(tresult.completion);
-			break;
-		} else {
-			BT_DBG("wait_for_completion_interruptible failed");
-			if (!ret)
-				ret = tresult.err;
-			goto out;
-		}
-	default:
-		goto out;
-	}
-
-out:
-err_setkey:
-	kfree(hash_buff);
-err_hash_buf:
-	ahash_request_free(req);
-err_req:
-	crypto_free_ahash(tfm);
-err_tfm:
-	return ret;
-}
-
-static void show_key(u8 *k)
-{
-	int i = 0;
-	for (i = 0; i < 32; i += 8)
-		BT_DBG("    %02x %02x %02x %02x %02x %02x %02x %02x",
-				*(k+i+0), *(k+i+1), *(k+i+2), *(k+i+3),
-				*(k+i+4), *(k+i+5), *(k+i+6), *(k+i+7));
-}
-
-static int physlink_security(struct hci_conn *conn, u8 *data, u8 *len, u8 *type)
-{
-	u8 bt2_key[32];
-	u8 gamp_key[32];
-	u8 b802_key[32];
-	int result;
-
-	if (!hci_conn_check_link_mode(conn))
-		return -EACCES;
-
-	BT_DBG("key_type %d", conn->key_type);
-	if (conn->key_type < 3)
-		return -EACCES;
-
-	*type = conn->key_type;
-	*len = 32;
-	memcpy(&bt2_key[0], conn->link_key, 16);
-	memcpy(&bt2_key[16], conn->link_key, 16);
-	result = hmac_sha256(bt2_key, 32, "gamp", 4, gamp_key, 32);
-	if (result)
-		goto ps_finished;
-
-	if (conn->key_type == 3) {
-		BT_DBG("gamp_key");
-		show_key(gamp_key);
-		memcpy(data, gamp_key, 32);
-		goto ps_finished;
-	}
-
-	result = hmac_sha256(gamp_key, 32, "802b", 4, b802_key, 32);
-	if (result)
-		goto ps_finished;
-
-	BT_DBG("802b_key");
-	show_key(b802_key);
-	memcpy(data, b802_key, 32);
-
-ps_finished:
-	return result;
-}
-
-static u8 amp_next_handle;
-static inline u8 physlink_handle(struct hci_dev *hdev)
-{
-	/* TODO amp_next_handle should be part of hci_dev */
-	if (amp_next_handle == 0)
-		amp_next_handle = 1;
-	return amp_next_handle++;
-}
-
-/* Start an Accept Physical Link sequence */
-static int createphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	struct amp_ctx *ctx = NULL;
-	struct a2mp_createphyslink_req *req;
-
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (struct a2mp_createphyslink_req *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-	BT_DBG("local_id %d, remote_id %d", req->local_id, req->remote_id);
-
-	/* initialize the context */
-	ctx = create_ctx(AMP_ACCEPTPHYSLINK, AMP_APL_INIT);
-	if (!ctx)
-		return -ENOMEM;
-	ctx->d.apl.req_ident = hdr->ident;
-	ctx->d.apl.remote_id = req->local_id;
-	ctx->id = req->remote_id;
-
-	/* add the supplied remote assoc to the context */
-	ctx->d.apl.remote_assoc = kmalloc(skb->len, GFP_ATOMIC);
-	if (ctx->d.apl.remote_assoc)
-		memcpy(ctx->d.apl.remote_assoc, skb->data, skb->len);
-	ctx->d.apl.len_so_far = 0;
-	ctx->d.apl.rem_len = skb->len;
-	skb_pull(skb, skb->len);
-	ctx->hdev = hci_dev_get(ctx->id);
-	start_ctx(mgr, ctx);
-	return 0;
-}
-
-static u8 acceptphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct sk_buff *skb = data;
-	struct hci_cp_accept_phys_link acp;
-	struct hci_cp_write_remote_amp_assoc wcp;
-	struct hci_rp_write_remote_amp_assoc *wrp;
-	struct hci_ev_cmd_status *cs = data;
-	struct hci_ev_phys_link_complete *ev;
-	struct a2mp_createphyslink_rsp rsp;
-	struct amp_ctx *cplctx;
-	struct amp_ctx *aplctx;
-	u16 frag_len;
-	struct hci_conn *conn;
-	int result;
-
-	BT_DBG("state %d", ctx->state);
-	result = -EINVAL;
-	rsp.status = 1;        /* Invalid Controller ID */
-	if (!ctx->hdev || !test_bit(HCI_UP, &ctx->hdev->flags))
-		goto apl_finished;
-	if (evt_type == AMP_KILLED) {
-		result = -EAGAIN;
-		rsp.status = 4;        /* Disconnect request received */
-		goto apl_finished;
-	}
-	if (!ctx->d.apl.remote_assoc) {
-		result = -ENOMEM;
-		rsp.status = 2;        /* Unable to Start */
-		goto apl_finished;
-	}
-
-	switch (ctx->state) {
-	case AMP_APL_INIT:
-		BT_DBG("local_id %d, remote_id %d",
-			ctx->id, ctx->d.apl.remote_id);
-		conn = hci_conn_hash_lookup_id(ctx->hdev,
-					&ctx->mgr->l2cap_conn->hcon->dst,
-					ctx->d.apl.remote_id);
-		if (conn) {
-			result = -EEXIST;
-			rsp.status = 5;   /* Already Exists */
-			goto apl_finished;
-		}
-
-		aplctx = get_ctx_type(ctx, AMP_ACCEPTPHYSLINK);
-		if ((aplctx) &&
-			(aplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
-			BT_DBG("deferred to %p", aplctx);
-			aplctx->deferred = ctx;
-			break;
-		}
-
-		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
-		if ((cplctx) &&
-			(cplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
-			struct hci_conn *bcon = ctx->mgr->l2cap_conn->hcon;
-			BT_DBG("local %s remote %s",
-				batostr(&bcon->hdev->bdaddr),
-				batostr(&bcon->dst));
-			if ((cplctx->state < AMP_CPL_PL_COMPLETE) ||
-				(bacmp(&bcon->hdev->bdaddr, &bcon->dst) < 0)) {
-				BT_DBG("COLLISION LOSER");
-				cplctx->deferred = ctx;
-				cancel_ctx(cplctx);
-				break;
-			} else {
-				BT_DBG("COLLISION WINNER");
-				result = -EISCONN;
-				rsp.status = 3;    /* Collision */
-				goto apl_finished;
-			}
-		}
-
-		result = physlink_security(ctx->mgr->l2cap_conn->hcon, acp.data,
-						&acp.key_len, &acp.type);
-		if (result) {
-			BT_DBG("SECURITY");
-			rsp.status = 6;    /* Security Violation */
-			goto apl_finished;
-		}
-
-		ctx->d.apl.phy_handle = physlink_handle(ctx->hdev);
-		ctx->state = AMP_APL_APL_STATUS;
-		ctx->evt_type = AMP_HCI_CMD_STATUS;
-		ctx->opcode = HCI_OP_ACCEPT_PHYS_LINK;
-		acp.phy_handle = ctx->d.apl.phy_handle;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(acp), &acp);
-		break;
-
-	case AMP_APL_APL_STATUS:
-		if (cs->status != 0)
-			goto apl_finished;
-		/* PAL will accept link, send a2mp response */
-		rsp.local_id = ctx->id;
-		rsp.remote_id = ctx->d.apl.remote_id;
-		rsp.status = 0;
-		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
-				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
-
-		/* send the first assoc fragment */
-		wcp.phy_handle = ctx->d.apl.phy_handle;
-		wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
-		wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
-		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-		memcpy(wcp.frag, ctx->d.apl.remote_assoc, frag_len);
-		ctx->state = AMP_APL_WRA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-		break;
-
-	case AMP_APL_WRA_COMPLETE:
-		/* received write remote amp assoc command complete event */
-		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
-		if (wrp->status != 0)
-			goto apl_finished;
-		if (wrp->phy_handle != ctx->d.apl.phy_handle)
-			goto apl_finished;
-		/* update progress */
-		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-		ctx->d.apl.len_so_far += frag_len;
-		ctx->d.apl.rem_len -= frag_len;
-		if (ctx->d.apl.rem_len > 0) {
-			u8 *assoc;
-			/* another assoc fragment to send */
-			wcp.phy_handle = ctx->d.apl.phy_handle;
-			wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
-			wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
-			frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
-			assoc = ctx->d.apl.remote_assoc + ctx->d.apl.len_so_far;
-			memcpy(wcp.frag, assoc, frag_len);
-			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-			break;
-		}
-		/* wait for physical link complete event */
-		ctx->state = AMP_APL_PL_COMPLETE;
-		ctx->evt_type = AMP_HCI_EVENT;
-		ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
-		break;
-
-	case AMP_APL_PL_COMPLETE:
-		/* physical link complete event received */
-		if (skb->len < sizeof(*ev))
-			goto apl_finished;
-		ev = (struct hci_ev_phys_link_complete *) skb->data;
-		if (ev->phy_handle != ctx->d.apl.phy_handle)
-			break;
-		if (ev->status != 0)
-			goto apl_finished;
-		conn = hci_conn_hash_lookup_handle(ctx->hdev, ev->phy_handle);
-		if (!conn)
-			goto apl_finished;
-		result = 0;
-		BT_DBG("PL_COMPLETE phy_handle %x", ev->phy_handle);
-		conn->dst_id = ctx->d.apl.remote_id;
-		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
-		goto apl_finished;
-		break;
-
-	default:
-		goto apl_finished;
-		break;
-	}
-	return 0;
-
-apl_finished:
-	if (ctx->sk)
-		l2cap_amp_physical_complete(result, ctx->id,
-					ctx->d.apl.remote_id, ctx->sk);
-	if ((result) && (ctx->state < AMP_APL_PL_COMPLETE)) {
-		rsp.local_id = ctx->id;
-		rsp.remote_id = ctx->d.apl.remote_id;
-		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
-				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
-	}
-	kfree(ctx->d.apl.remote_assoc);
-	if (ctx->sk)
-		sock_put(ctx->sk);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	return 1;
-}
-
-static void cancel_cpl_ctx(struct amp_ctx *ctx, u8 reason)
-{
-	struct hci_cp_disconn_phys_link dcp;
-
-	ctx->state = AMP_CPL_PL_CANCEL;
-	ctx->evt_type = AMP_HCI_EVENT;
-	ctx->evt_code = HCI_EV_DISCONN_PHYS_LINK_COMPLETE;
-	dcp.phy_handle = ctx->d.cpl.phy_handle;
-	dcp.reason = reason;
-	hci_send_cmd(ctx->hdev, HCI_OP_DISCONN_PHYS_LINK, sizeof(dcp), &dcp);
-}
-
-static u8 createphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct amp_ctrl *ctrl;
-	struct sk_buff *skb = data;
-	struct a2mp_cmd_hdr *hdr;
-	struct hci_ev_cmd_status *cs = data;
-	struct amp_ctx *cplctx;
-	struct a2mp_discover_req dreq;
-	struct a2mp_discover_rsp *drsp;
-	u16 *efm;
-	struct a2mp_getinfo_req greq;
-	struct a2mp_getinfo_rsp *grsp;
-	struct a2mp_cl *cl;
-	struct a2mp_getampassoc_req areq;
-	struct a2mp_getampassoc_rsp *arsp;
-	struct hci_cp_create_phys_link cp;
-	struct hci_cp_write_remote_amp_assoc wcp;
-	struct hci_rp_write_remote_amp_assoc *wrp;
-	struct hci_ev_channel_selected *cev;
-	struct hci_cp_read_local_amp_assoc rcp;
-	struct hci_rp_read_local_amp_assoc *rrp;
-	struct a2mp_createphyslink_req creq;
-	struct a2mp_createphyslink_rsp *crsp;
-	struct hci_ev_phys_link_complete *pev;
-	struct hci_ev_disconn_phys_link_complete *dev;
-	u8 *assoc, *rassoc, *lassoc;
-	u16 frag_len;
-	u16 rem_len;
-	int result = -EAGAIN;
-	struct hci_conn *conn;
-
-	BT_DBG("state %d", ctx->state);
-	if (evt_type == AMP_KILLED)
-		goto cpl_finished;
-
-	if (evt_type == AMP_CANCEL) {
-		if ((ctx->state < AMP_CPL_CPL_STATUS) ||
-			((ctx->state == AMP_CPL_PL_COMPLETE) &&
-			!(ctx->evt_type & AMP_HCI_EVENT)))
-			goto cpl_finished;
-
-		cancel_cpl_ctx(ctx, 0x16);
-		return 0;
-	}
-
-	switch (ctx->state) {
-	case AMP_CPL_INIT:
-		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
-		if (cplctx) {
-			BT_DBG("deferred to %p", cplctx);
-			cplctx->deferred = ctx;
-			break;
-		}
-		ctx->state = AMP_CPL_DISC_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		dreq.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
-		dreq.ext_feat = 0;
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_DISCOVER_REQ,
-							sizeof(dreq), &dreq);
-		break;
-
-	case AMP_CPL_DISC_RSP:
-		drsp = (struct a2mp_discover_rsp *) skb_pull(skb, sizeof(*hdr));
-		if (skb->len < (sizeof(*drsp))) {
-			result = -EINVAL;
-			goto cpl_finished;
-		}
-
-		efm = (u16 *) skb_pull(skb, sizeof(*drsp));
-		BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(drsp->mtu),
-						le16_to_cpu(drsp->ext_feat));
-
-		while (le16_to_cpu(drsp->ext_feat) & 0x8000) {
-			if (skb->len < sizeof(*efm)) {
-				result = -EINVAL;
-				goto cpl_finished;
-			}
-			drsp->ext_feat = *efm;
-			BT_DBG("efm 0x%4.4x", le16_to_cpu(drsp->ext_feat));
-			efm = (u16 *) skb_pull(skb, sizeof(*efm));
-		}
-		cl = (struct a2mp_cl *) efm;
-
-		/* find the first remote and local controller with the
-		 * same type
-		 */
-		greq.id = 0;
-		result = -ENODEV;
-		while (skb->len >= sizeof(*cl)) {
-			if ((cl->id != 0) && (greq.id == 0)) {
-				struct hci_dev *hdev;
-				hdev = hci_dev_get_type(cl->type);
-				if (hdev) {
-					struct hci_conn *conn;
-					ctx->hdev = hdev;
-					ctx->id = hdev->id;
-					ctx->d.cpl.remote_id = cl->id;
-					conn = hci_conn_hash_lookup_ba(hdev,
-					    ACL_LINK,
-					    &ctx->mgr->l2cap_conn->hcon->dst);
-					if (conn) {
-						BT_DBG("PL_COMPLETE exists %x",
-							(int) conn->handle);
-						result = 0;
-					}
-					ctrl = get_create_ctrl(ctx->mgr,
-								cl->id);
-					if (ctrl) {
-						ctrl->type = cl->type;
-						ctrl->status = cl->status;
-					}
-					greq.id = cl->id;
-				}
-			}
-			cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
-		}
-		if ((!greq.id) || (!result))
-			goto cpl_finished;
-		ctx->state = AMP_CPL_GETINFO_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETINFO_REQ,
-							sizeof(greq), &greq);
-		break;
-
-	case AMP_CPL_GETINFO_RSP:
-		if (skb->len < sizeof(*grsp))
-			goto cpl_finished;
-		grsp = (struct a2mp_getinfo_rsp *) skb_pull(skb, sizeof(*hdr));
-		skb_pull(skb, sizeof(*grsp));
-		if (grsp->status)
-			goto cpl_finished;
-		if (grsp->id != ctx->d.cpl.remote_id)
-			goto cpl_finished;
-		ctrl = get_ctrl(ctx->mgr, grsp->id);
-		if (!ctrl)
-			goto cpl_finished;
-		ctrl->status = grsp->status;
-		ctrl->total_bw = le32_to_cpu(grsp->total_bw);
-		ctrl->max_bw = le32_to_cpu(grsp->max_bw);
-		ctrl->min_latency = le32_to_cpu(grsp->min_latency);
-		ctrl->pal_cap = le16_to_cpu(grsp->pal_cap);
-		ctrl->max_assoc_size = le16_to_cpu(grsp->assoc_size);
-
-		ctx->d.cpl.max_len = ctrl->max_assoc_size;
-
-		/* setup up GAA request */
-		areq.id = ctx->d.cpl.remote_id;
-
-		/* advance context state */
-		ctx->state = AMP_CPL_GAA_RSP;
-		ctx->evt_type = AMP_A2MP_RSP;
-		ctx->rsp_ident = next_ident(ctx->mgr);
-		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETAMPASSOC_REQ,
-							sizeof(areq), &areq);
-		break;
-
-	case AMP_CPL_GAA_RSP:
-		if (skb->len < sizeof(*arsp))
-			goto cpl_finished;
-		hdr = (void *) skb->data;
-		arsp = (void *) skb_pull(skb, sizeof(*hdr));
-		if (arsp->status != 0)
-			goto cpl_finished;
-
-		/* store away remote assoc */
-		assoc = (u8 *) skb_pull(skb, sizeof(*arsp));
-		ctx->d.cpl.len_so_far = 0;
-		ctx->d.cpl.rem_len = hdr->len - sizeof(*arsp);
-		skb_pull(skb, ctx->d.cpl.rem_len);
-		rassoc = kmalloc(ctx->d.cpl.rem_len, GFP_ATOMIC);
-		if (!rassoc)
-			goto cpl_finished;
-		memcpy(rassoc, assoc, ctx->d.cpl.rem_len);
-		ctx->d.cpl.remote_assoc = rassoc;
-
-		/* set up CPL command */
-		ctx->d.cpl.phy_handle = physlink_handle(ctx->hdev);
-		cp.phy_handle = ctx->d.cpl.phy_handle;
-		if (physlink_security(ctx->mgr->l2cap_conn->hcon, cp.data,
-					&cp.key_len, &cp.type)) {
-			result = -EPERM;
-			goto cpl_finished;
-		}
-
-		/* advance context state */
-		ctx->state = AMP_CPL_CPL_STATUS;
-		ctx->evt_type = AMP_HCI_CMD_STATUS;
-		ctx->opcode = HCI_OP_CREATE_PHYS_LINK;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
-		break;
-
-	case AMP_CPL_CPL_STATUS:
-		/* received create physical link command status */
-		if (cs->status != 0)
-			goto cpl_finished;
-		/* send the first assoc fragment */
-		wcp.phy_handle = ctx->d.cpl.phy_handle;
-		wcp.len_so_far = ctx->d.cpl.len_so_far;
-		wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
-		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-		memcpy(wcp.frag, ctx->d.cpl.remote_assoc, frag_len);
-		ctx->state = AMP_CPL_WRA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-		break;
-
-	case AMP_CPL_WRA_COMPLETE:
-		/* received write remote amp assoc command complete event */
-		if (skb->len < sizeof(*wrp))
-			goto cpl_finished;
-		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
-		if (wrp->status != 0)
-			goto cpl_finished;
-		if (wrp->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-
-		/* update progress */
-		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-		ctx->d.cpl.len_so_far += frag_len;
-		ctx->d.cpl.rem_len -= frag_len;
-		if (ctx->d.cpl.rem_len > 0) {
-			/* another assoc fragment to send */
-			wcp.phy_handle = ctx->d.cpl.phy_handle;
-			wcp.len_so_far = cpu_to_le16(ctx->d.cpl.len_so_far);
-			wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
-			frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
-			memcpy(wcp.frag,
-				ctx->d.cpl.remote_assoc + ctx->d.cpl.len_so_far,
-				frag_len);
-			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
-			break;
-		}
-		/* now wait for channel selected event */
-		ctx->state = AMP_CPL_CHANNEL_SELECT;
-		ctx->evt_type = AMP_HCI_EVENT;
-		ctx->evt_code = HCI_EV_CHANNEL_SELECTED;
-		break;
-
-	case AMP_CPL_CHANNEL_SELECT:
-		/* received channel selection event */
-		if (skb->len < sizeof(*cev))
-			goto cpl_finished;
-		cev = (void *) skb->data;
-/* TODO - PK This check is valid but Libra PAL returns 0 for handle during
-			Create Physical Link collision scenario
-		if (cev->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-*/
-
-		/* request the first local assoc fragment */
-		rcp.phy_handle = ctx->d.cpl.phy_handle;
-		rcp.len_so_far = 0;
-		rcp.max_len = ctx->d.cpl.max_len;
-		lassoc = kmalloc(ctx->d.cpl.max_len, GFP_ATOMIC);
-		if (!lassoc)
-			goto cpl_finished;
-		ctx->d.cpl.local_assoc = lassoc;
-		ctx->d.cpl.len_so_far = 0;
-		ctx->state = AMP_CPL_RLA_COMPLETE;
-		ctx->evt_type = AMP_HCI_CMD_CMPLT;
-		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
-		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
-		break;
-
-	case AMP_CPL_RLA_COMPLETE:
-		/* received read local amp assoc command complete event */
-		if (skb->len < 4)
-			goto cpl_finished;
-		rrp = (struct hci_rp_read_local_amp_assoc *) skb->data;
-		if (rrp->status)
-			goto cpl_finished;
-		if (rrp->phy_handle != ctx->d.cpl.phy_handle)
-			goto cpl_finished;
-		rem_len = le16_to_cpu(rrp->rem_len);
-		skb_pull(skb, 4);
-		frag_len = skb->len;
-
-		if (ctx->d.cpl.len_so_far + rem_len > ctx->d.cpl.max_len)
-			goto cpl_finished;
-
-		/* save this fragment in context */
-		lassoc = ctx->d.cpl.local_assoc + ctx->d.cpl.len_so_far;
-		memcpy(lassoc, rrp->frag, frag_len);
-		ctx->d.cpl.len_so_far += frag_len;
-		rem_len -= frag_len;
-		if (rem_len > 0) {
-			/* request another local assoc fragment */
-			rcp.phy_handle = ctx->d.cpl.phy_handle;
-			rcp.len_so_far = ctx->d.cpl.len_so_far;
-			rcp.max_len = ctx->d.cpl.max_len;
-			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
-		} else {
-			creq.local_id = ctx->id;
-			creq.remote_id = ctx->d.cpl.remote_id;
-			/* wait for A2MP rsp AND phys link complete event */
-			ctx->state = AMP_CPL_PL_COMPLETE;
-			ctx->evt_type = AMP_A2MP_RSP | AMP_HCI_EVENT;
-			ctx->rsp_ident = next_ident(ctx->mgr);
-			ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
-			send_a2mp_cmd2(ctx->mgr, ctx->rsp_ident,
-				A2MP_CREATEPHYSLINK_REQ, sizeof(creq), &creq,
-				ctx->d.cpl.len_so_far, ctx->d.cpl.local_assoc);
-		}
-		break;
-
-	case AMP_CPL_PL_COMPLETE:
-		if (evt_type == AMP_A2MP_RSP) {
-			/* create physical link response received */
-			ctx->evt_type &= ~AMP_A2MP_RSP;
-			if (skb->len < sizeof(*crsp))
-				goto cpl_finished;
-			crsp = (void *) skb_pull(skb, sizeof(*hdr));
-			if ((crsp->local_id != ctx->d.cpl.remote_id) ||
-				(crsp->remote_id != ctx->id) ||
-				(crsp->status != 0)) {
-				cancel_cpl_ctx(ctx, 0x13);
-				break;
-			}
-
-			/* notify Qualcomm PAL */
-			if (ctx->hdev->manufacturer == 0x001d)
-				hci_send_cmd(ctx->hdev,
-					hci_opcode_pack(0x3f, 0x00), 0, NULL);
-		}
-		if (evt_type == AMP_HCI_EVENT) {
-			ctx->evt_type &= ~AMP_HCI_EVENT;
-			/* physical link complete event received */
-			if (skb->len < sizeof(*pev))
-				goto cpl_finished;
-			pev = (void *) skb->data;
-			if (pev->phy_handle != ctx->d.cpl.phy_handle)
-				break;
-			if (pev->status != 0)
-				goto cpl_finished;
-		}
-		if (ctx->evt_type)
-			break;
-		conn = hci_conn_hash_lookup_handle(ctx->hdev,
-							ctx->d.cpl.phy_handle);
-		if (!conn)
-			goto cpl_finished;
-		result = 0;
-		BT_DBG("PL_COMPLETE phy_handle %x", ctx->d.cpl.phy_handle);
-		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
-		conn->dst_id = ctx->d.cpl.remote_id;
-		conn->out = 1;
-		goto cpl_finished;
-		break;
-
-	case AMP_CPL_PL_CANCEL:
-		dev = (void *) skb->data;
-		BT_DBG("PL_COMPLETE cancelled %x", dev->phy_handle);
-		result = -EISCONN;
-		goto cpl_finished;
-		break;
-
-	default:
-		goto cpl_finished;
-		break;
-	}
-	return 0;
-
-cpl_finished:
-	l2cap_amp_physical_complete(result, ctx->id, ctx->d.cpl.remote_id,
-					ctx->sk);
-	if (ctx->sk)
-		sock_put(ctx->sk);
-	if (ctx->hdev)
-		hci_dev_put(ctx->hdev);
-	kfree(ctx->d.cpl.remote_assoc);
-	kfree(ctx->d.cpl.local_assoc);
-	return 1;
-}
-
-static int disconnphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (void *) skb->data;
-	struct a2mp_disconnphyslink_req *req;
-	struct a2mp_disconnphyslink_rsp rsp;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	struct amp_ctx *aplctx;
-
-	BT_DBG("mgr %p skb %p", mgr, skb);
-	if (hdr->len < sizeof(*req))
-		return -EINVAL;
-	req = (void *) skb_pull(skb, sizeof(*hdr));
-	skb_pull(skb, sizeof(*req));
-
-	rsp.local_id = req->remote_id;
-	rsp.remote_id = req->local_id;
-	rsp.status = 0;
-	BT_DBG("local_id %d remote_id %d",
-		(int) rsp.local_id, (int) rsp.remote_id);
-	hdev = hci_dev_get(rsp.local_id);
-	if (!hdev) {
-		rsp.status = 1; /* Invalid Controller ID */
-		goto dpl_finished;
-	}
-	BT_DBG("hdev %p", hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
-					&mgr->l2cap_conn->hcon->dst);
-	if (!conn) {
-		aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
-		if (aplctx) {
-			kill_ctx(aplctx);
-			rsp.status = 0;
-			goto dpl_finished;
-		}
-		rsp.status = 2;  /* No Physical Link exists */
-		goto dpl_finished;
-	}
-	BT_DBG("conn %p", conn);
-	hci_disconnect(conn, 0x13);
-
-dpl_finished:
-	send_a2mp_cmd(mgr, hdr->ident,
-				A2MP_DISCONNPHYSLINK_RSP, sizeof(rsp), &rsp);
-	if (hdev)
-		hci_dev_put(hdev);
-	return 0;
-}
-
-static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data)
-{
-	struct amp_mgr *mgr = ctx->mgr;
-	u8 finished = 0;
-
-	if (!mgr->connected)
-		return 0;
-
-	switch (ctx->type) {
-	case AMP_GETAMPASSOC:
-		finished = getampassoc_handler(ctx, evt_type, data);
-		break;
-	case AMP_CREATEPHYSLINK:
-		finished = createphyslink_handler(ctx, evt_type, data);
-		break;
-	case AMP_ACCEPTPHYSLINK:
-		finished = acceptphyslink_handler(ctx, evt_type, data);
-		break;
-	}
-
-	if (!finished)
-		mod_timer(&(ctx->timer), jiffies +
-			msecs_to_jiffies(A2MP_RSP_TIMEOUT));
-	else
-		destroy_ctx(ctx);
-	return finished;
-}
-
-static int cancel_ctx(struct amp_ctx *ctx)
-{
-	return execute_ctx(ctx, AMP_CANCEL, 0);
-}
-
-static int kill_ctx(struct amp_ctx *ctx)
-{
-	return execute_ctx(ctx, AMP_KILLED, 0);
-}
-
-static void ctx_timeout_worker(struct work_struct *w)
-{
-	struct amp_work_ctx_timeout *work = (struct amp_work_ctx_timeout *) w;
-	struct amp_ctx *ctx = work->ctx;
-	kill_ctx(ctx);
-	kfree(work);
-}
-
-static void ctx_timeout(unsigned long data)
-{
-	struct amp_ctx *ctx = (struct amp_ctx *) data;
-	struct amp_work_ctx_timeout *work;
-
-	BT_DBG("ctx %p", ctx);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, ctx_timeout_worker);
-		work->ctx = ctx;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void launch_ctx(struct amp_mgr *mgr)
-{
-	struct amp_ctx *ctx = NULL;
-
-	BT_DBG("mgr %p", mgr);
-	read_lock(&mgr->ctx_list_lock);
-	if (!list_empty(&mgr->ctx_list))
-		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
-	read_unlock(&mgr->ctx_list_lock);
-	BT_DBG("ctx %p", ctx);
-	if (ctx)
-		execute_ctx(ctx, AMP_INIT, NULL);
-}
-
-static inline int a2mp_rsp(struct amp_mgr *mgr, struct sk_buff *skb)
-{
-	struct amp_ctx *ctx;
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	u16 hdr_len = le16_to_cpu(hdr->len);
-
-	/* find context waiting for A2MP rsp with this rsp's identifier */
-	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
-	ctx = get_ctx_a2mp(mgr, hdr->ident);
-	if (ctx) {
-		execute_ctx(ctx, AMP_A2MP_RSP, skb);
-	} else {
-		BT_DBG("context not found");
-		skb_pull(skb, sizeof(*hdr));
-		if (hdr_len > skb->len)
-			hdr_len = skb->len;
-		skb_pull(skb, hdr_len);
-	}
-	return 0;
-}
-
-/* L2CAP-A2MP interface */
-
-static void a2mp_receive(struct sock *sk, struct sk_buff *skb)
-{
-	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-	int len;
-	int err = 0;
-	struct amp_mgr *mgr;
-
-	mgr = get_amp_mgr_sk(sk);
-	if (!mgr)
-		goto a2mp_finished;
-
-	len = skb->len;
-	while (len >= sizeof(*hdr)) {
-		struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
-		u16 clen = le16_to_cpu(hdr->len);
-
-		BT_DBG("code 0x%02x id %d len %d", hdr->code, hdr->ident, clen);
-		if (clen > len || !hdr->ident) {
-			err = -EINVAL;
-			break;
-		}
-		switch (hdr->code) {
-		case A2MP_COMMAND_REJ:
-			command_rej(mgr, skb);
-			break;
-		case A2MP_DISCOVER_REQ:
-			err = discover_req(mgr, skb);
-			break;
-		case A2MP_CHANGE_NOTIFY:
-			err = change_notify(mgr, skb);
-			break;
-		case A2MP_GETINFO_REQ:
-			err = getinfo_req(mgr, skb);
-			break;
-		case A2MP_GETAMPASSOC_REQ:
-			err = getampassoc_req(mgr, skb);
-			break;
-		case A2MP_CREATEPHYSLINK_REQ:
-			err = createphyslink_req(mgr, skb);
-			break;
-		case A2MP_DISCONNPHYSLINK_REQ:
-			err = disconnphyslink_req(mgr, skb);
-			break;
-		case A2MP_CHANGE_RSP:
-		case A2MP_DISCOVER_RSP:
-		case A2MP_GETINFO_RSP:
-		case A2MP_GETAMPASSOC_RSP:
-		case A2MP_CREATEPHYSLINK_RSP:
-		case A2MP_DISCONNPHYSLINK_RSP:
-			err = a2mp_rsp(mgr, skb);
-			break;
-		default:
-			BT_ERR("Unknown A2MP signaling command 0x%2.2x",
-				hdr->code);
-			skb_pull(skb, sizeof(*hdr));
-			err = -EINVAL;
-			break;
-		}
-		len = skb->len;
-	}
-
-a2mp_finished:
-	if (err && mgr) {
-		struct a2mp_cmd_rej rej;
-		rej.reason = cpu_to_le16(0);
-		send_a2mp_cmd(mgr, hdr->ident, A2MP_COMMAND_REJ,
-							sizeof(rej), &rej);
-	}
-}
-
-/* L2CAP-A2MP interface */
-
-static int send_a2mp(struct socket *sock, u8 *data, int len)
-{
-	struct kvec iv = { data, len };
-	struct msghdr msg;
-
-	memset(&msg, 0, sizeof(msg));
-
-	return kernel_sendmsg(sock, &msg, &iv, 1, len);
-}
-
-static void data_ready_worker(struct work_struct *w)
-{
-	struct amp_work_data_ready *work = (struct amp_work_data_ready *) w;
-	struct sock *sk = work->sk;
-	struct sk_buff *skb;
-
-	/* skb_dequeue() is thread-safe */
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		a2mp_receive(sk, skb);
-		kfree_skb(skb);
-	}
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void data_ready(struct sock *sk, int bytes)
-{
-	struct amp_work_data_ready *work;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, data_ready_worker);
-		sock_hold(sk);
-		work->sk = sk;
-		work->bytes = bytes;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			kfree(work);
-			sock_put(sk);
-		}
-	}
-}
-
-static void state_change_worker(struct work_struct *w)
-{
-	struct amp_work_state_change *work = (struct amp_work_state_change *) w;
-	struct amp_mgr *mgr;
-	switch (work->sk->sk_state) {
-	case BT_CONNECTED:
-		/* socket is up */
-		BT_DBG("CONNECTED");
-		mgr = get_amp_mgr_sk(work->sk);
-		if (mgr) {
-			mgr->connected = 1;
-			if (mgr->skb) {
-				l2cap_recv_deferred_frame(work->sk, mgr->skb);
-				mgr->skb = NULL;
-			}
-			launch_ctx(mgr);
-		}
-		break;
-
-	case BT_CLOSED:
-		/* connection is gone */
-		BT_DBG("CLOSED");
-		mgr = get_amp_mgr_sk(work->sk);
-		if (mgr) {
-			if (!sock_flag(work->sk, SOCK_DEAD))
-				sock_release(mgr->a2mp_sock);
-			mgr->a2mp_sock = NULL;
-			remove_amp_mgr(mgr);
-		}
-		break;
-
-	default:
-		/* something else happened */
-		break;
-	}
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void state_change(struct sock *sk)
-{
-	struct amp_work_state_change *work;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, state_change_worker);
-		sock_hold(sk);
-		work->sk = sk;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			kfree(work);
-			sock_put(sk);
-		}
-	}
-}
-
-static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst)
-{
-	int err;
-	struct socket *sock;
-	struct sockaddr_l2 addr;
-	struct sock *sk;
-	struct l2cap_options opts = {L2CAP_A2MP_DEFAULT_MTU,
-			L2CAP_A2MP_DEFAULT_MTU, L2CAP_DEFAULT_FLUSH_TO,
-			L2CAP_MODE_ERTM, 1, 0xFF, 1};
-
-
-	err = sock_create_kern(PF_BLUETOOTH, SOCK_SEQPACKET,
-					BTPROTO_L2CAP, &sock);
-
-	if (err) {
-		BT_ERR("sock_create_kern failed %d", err);
-		return NULL;
-	}
-
-	sk = sock->sk;
-	sk->sk_data_ready = data_ready;
-	sk->sk_state_change = state_change;
-
-	memset(&addr, 0, sizeof(addr));
-	bacpy(&addr.l2_bdaddr, src);
-	addr.l2_family = AF_BLUETOOTH;
-	addr.l2_cid = L2CAP_CID_A2MP;
-	err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
-	if (err) {
-		BT_ERR("kernel_bind failed %d", err);
-		sock_release(sock);
-		return NULL;
-	}
-
-	l2cap_fixed_channel_config(sk, &opts);
-
-	memset(&addr, 0, sizeof(addr));
-	bacpy(&addr.l2_bdaddr, dst);
-	addr.l2_family = AF_BLUETOOTH;
-	addr.l2_cid = L2CAP_CID_A2MP;
-	err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr),
-							O_NONBLOCK);
-	if ((err == 0) || (err == -EINPROGRESS))
-		return sock;
-	else {
-		BT_ERR("kernel_connect failed %d", err);
-		sock_release(sock);
-		return NULL;
-	}
-}
-
-static void conn_ind_worker(struct work_struct *w)
-{
-	struct amp_work_conn_ind *work = (struct amp_work_conn_ind *) w;
-	struct hci_conn *hcon = work->hcon;
-	struct sk_buff *skb = work->skb;
-	struct amp_mgr *mgr;
-
-	mgr = get_create_amp_mgr(hcon, skb);
-	BT_DBG("mgr %p", mgr);
-	hci_conn_put(hcon);
-	kfree(work);
-}
-
-static void create_physical_worker(struct work_struct *w)
-{
-	struct amp_work_create_physical *work =
-		(struct amp_work_create_physical *) w;
-
-	create_physical(work->conn, work->sk);
-	sock_put(work->sk);
-	kfree(work);
-}
-
-static void accept_physical_worker(struct work_struct *w)
-{
-	struct amp_work_accept_physical *work =
-		(struct amp_work_accept_physical *) w;
-
-	accept_physical(work->conn, work->id, work->sk);
-	sock_put(work->sk);
-	kfree(work);
-}
-
-/* L2CAP Fixed Channel interface */
-
-void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb)
-{
-	struct amp_work_conn_ind *work;
-	BT_DBG("hcon %p, skb %p", hcon, skb);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, conn_ind_worker);
-		hci_conn_hold(hcon);
-		work->hcon = hcon;
-		work->skb = skb;
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			hci_conn_put(hcon);
-			kfree(work);
-		}
-	}
-}
-
-/* L2CAP Physical Link interface */
-
-void amp_create_physical(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct amp_work_create_physical *work;
-	BT_DBG("conn %p", conn);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, create_physical_worker);
-		work->conn = conn;
-		work->sk = sk;
-		sock_hold(sk);
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			sock_put(sk);
-			kfree(work);
-		}
-	}
-}
-
-void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk)
-{
-	struct amp_work_accept_physical *work;
-	BT_DBG("conn %p", conn);
-
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, accept_physical_worker);
-		work->conn = conn;
-		work->sk = sk;
-		work->id = id;
-		sock_hold(sk);
-		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
-			sock_put(sk);
-			kfree(work);
-		}
-	}
-}
-
-/* HCI interface */
-
-static void amp_cmd_cmplt_worker(struct work_struct *w)
-{
-	struct amp_work_cmd_cmplt *work = (struct amp_work_cmd_cmplt *) w;
-	struct hci_dev *hdev = work->hdev;
-	u16 opcode = work->opcode;
-	struct sk_buff *skb = work->skb;
-	struct amp_ctx *ctx;
-
-	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_CMPLT, opcode);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_CMD_CMPLT, skb);
-	kfree_skb(skb);
-	kfree(w);
-}
-
-static void amp_cmd_cmplt_evt(struct hci_dev *hdev, u16 opcode,
-				struct sk_buff *skb)
-{
-	struct amp_work_cmd_cmplt *work;
-	struct sk_buff *skbc;
-	BT_DBG("hdev %p opcode 0x%x skb %p len %d",
-		hdev, opcode, skb, skb->len);
-	skbc = skb_clone(skb, GFP_ATOMIC);
-	if (!skbc)
-		return;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_cmd_cmplt_worker);
-		work->hdev = hdev;
-		work->opcode = opcode;
-		work->skb = skbc;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_cmd_status_worker(struct work_struct *w)
-{
-	struct amp_work_cmd_status *work = (struct amp_work_cmd_status *) w;
-	struct hci_dev *hdev = work->hdev;
-	u16 opcode = work->opcode;
-	u8 status = work->status;
-	struct amp_ctx *ctx;
-
-	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_STATUS, opcode);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_CMD_STATUS, &status);
-	kfree(w);
-}
-
-static void amp_cmd_status_evt(struct hci_dev *hdev, u16 opcode, u8 status)
-{
-	struct amp_work_cmd_status *work;
-	BT_DBG("hdev %p opcode 0x%x status %d", hdev, opcode, status);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_cmd_status_worker);
-		work->hdev = hdev;
-		work->opcode = opcode;
-		work->status = status;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_event_worker(struct work_struct *w)
-{
-	struct amp_work_event *work = (struct amp_work_event *) w;
-	struct hci_dev *hdev = work->hdev;
-	u8 event = work->event;
-	struct sk_buff *skb = work->skb;
-	struct amp_ctx *ctx;
-
-	if (event == HCI_EV_AMP_STATUS_CHANGE) {
-		struct hci_ev_amp_status_change *ev;
-		if (skb->len < sizeof(*ev))
-			goto amp_event_finished;
-		ev = (void *) skb->data;
-		if (ev->status != 0)
-			goto amp_event_finished;
-		if (ev->amp_status == hdev->amp_status)
-			goto amp_event_finished;
-		hdev->amp_status = ev->amp_status;
-		send_a2mp_change_notify();
-		goto amp_event_finished;
-	}
-	ctx = get_ctx_hdev(hdev, AMP_HCI_EVENT, (u16) event);
-	if (ctx)
-		execute_ctx(ctx, AMP_HCI_EVENT, skb);
-
-amp_event_finished:
-	kfree_skb(skb);
-	kfree(w);
-}
-
-static void amp_evt(struct hci_dev *hdev, u8 event, struct sk_buff *skb)
-{
-	struct amp_work_event *work;
-	struct sk_buff *skbc;
-	BT_DBG("hdev %p event 0x%x skb %p", hdev, event, skb);
-	skbc = skb_clone(skb, GFP_ATOMIC);
-	if (!skbc)
-		return;
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-	if (work) {
-		INIT_WORK((struct work_struct *) work, amp_event_worker);
-		work->hdev = hdev;
-		work->event = event;
-		work->skb = skbc;
-		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
-			kfree(work);
-	}
-}
-
-static void amp_dev_event_worker(struct work_struct *w)
-{
-	send_a2mp_change_notify();
-	kfree(w);
-}
-
-static int amp_dev_event(struct notifier_block *this, unsigned long event,
-			void *ptr)
-{
-	struct hci_dev *hdev = (struct hci_dev *) ptr;
-	struct amp_work_event *work;
-
-	if (hdev->amp_type == HCI_BREDR)
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case HCI_DEV_UNREG:
-	case HCI_DEV_REG:
-	case HCI_DEV_UP:
-	case HCI_DEV_DOWN:
-		BT_DBG("hdev %p event %ld", hdev, event);
-		work = kmalloc(sizeof(*work), GFP_ATOMIC);
-		if (work) {
-			INIT_WORK((struct work_struct *) work,
-				amp_dev_event_worker);
-			if (queue_work(amp_workqueue,
-				(struct work_struct *) work) == 0)
-				kfree(work);
-		}
-	}
-	return NOTIFY_DONE;
-}
-
-
-/* L2CAP module init continued */
-
-static struct notifier_block amp_notifier = {
-	.notifier_call = amp_dev_event
-};
-
-static struct amp_mgr_cb hci_amp = {
-	.amp_cmd_complete_event = amp_cmd_cmplt_evt,
-	.amp_cmd_status_event = amp_cmd_status_evt,
-	.amp_event = amp_evt
-};
-
-int amp_init(void)
-{
-	hci_register_amp(&hci_amp);
-	hci_register_notifier(&amp_notifier);
-	amp_next_handle = 1;
-	amp_workqueue = create_singlethread_workqueue("a2mp");
-	if (!amp_workqueue)
-		return -EPERM;
-	return 0;
-}
-
-void amp_exit(void)
-{
-	hci_unregister_amp(&hci_amp);
-	hci_unregister_notifier(&amp_notifier);
-	flush_workqueue(amp_workqueue);
-	destroy_workqueue(amp_workqueue);
-}
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/core.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/core.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -57,8 +56,8 @@
 
 #define VERSION "1.3"
 
-static bool compress_src = 1;
-static bool compress_dst = 1;
+static bool compress_src = true;
+static bool compress_dst = true;
 
 static LIST_HEAD(bnep_session_list);
 static DECLARE_RWSEM(bnep_session_sem);
@@ -66,31 +65,24 @@
 static struct bnep_session *__bnep_get_session(u8 *dst)
 {
 	struct bnep_session *s;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &bnep_session_list) {
-		s = list_entry(p, struct bnep_session, list);
+	list_for_each_entry(s, &bnep_session_list, list)
 		if (!compare_ether_addr(dst, s->eh.h_source))
 			return s;
-	}
+
 	return NULL;
 }
 
 static void __bnep_link_session(struct bnep_session *s)
 {
-	/* It's safe to call __module_get() here because sessions are added
-	   by the socket layer which has to hold the reference to this module.
-	 */
-	__module_get(THIS_MODULE);
 	list_add(&s->list, &bnep_session_list);
 }
 
 static void __bnep_unlink_session(struct bnep_session *s)
 {
 	list_del(&s->list);
-	module_put(THIS_MODULE);
 }
 
 static int bnep_send(struct bnep_session *s, void *data, size_t len)
@@ -510,7 +502,7 @@
 
 		schedule();
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	/* Cleanup session */
@@ -531,6 +523,7 @@
 
 	up_write(&bnep_session_sem);
 	free_netdev(dev);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -617,9 +610,11 @@
 
 	__bnep_link_session(s);
 
+	__module_get(THIS_MODULE);
 	s->task = kthread_run(bnep_session, s, "kbnepd %s", dev->name);
 	if (IS_ERR(s->task)) {
 		/* Session thread start failed, gotta cleanup. */
+		module_put(THIS_MODULE);
 		unregister_netdev(dev);
 		__bnep_unlink_session(s);
 		err = PTR_ERR(s->task);
@@ -668,17 +663,14 @@
 
 int bnep_get_connlist(struct bnep_connlist_req *req)
 {
-	struct list_head *p;
+	struct bnep_session *s;
 	int err = 0, n = 0;
 
 	down_read(&bnep_session_sem);
 
-	list_for_each(p, &bnep_session_list) {
-		struct bnep_session *s;
+	list_for_each_entry(s, &bnep_session_list, list) {
 		struct bnep_conninfo ci;
 
-		s = list_entry(p, struct bnep_session, list);
-
 		__bnep_copy_ci(&ci, s);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/netdev.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/netdev.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/netdev.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/netdev.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 #include <linux/slab.h>
 
 #include <linux/socket.h>
diff -urN flo-ElementalX-5.00/net/bluetooth/bnep/sock.c flo-ElementalX-5.00-patched/net/bluetooth/bnep/sock.c
--- flo-ElementalX-5.00/net/bluetooth/bnep/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/bnep/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -42,7 +42,6 @@
 #include <linux/uaccess.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 
 #include "bnep.h"
 
@@ -143,10 +142,10 @@
 {
 	if (cmd == BNEPGETCONNLIST) {
 		struct bnep_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -157,7 +156,7 @@
 
 		err = bnep_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/capi.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/capi.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/capi.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/capi.c	2016-06-02 00:28:55.000000000 +0000
@@ -326,7 +326,7 @@
 {
 	struct capi_ctr *ctrl = &session->ctrl;
 	struct cmtp_application *application;
-	__u16 cmd, appl;
+	__u16 appl;
 	__u32 contr;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
@@ -344,7 +344,6 @@
 		return;
 	}
 
-	cmd = CAPICMD(CAPIMSG_COMMAND(skb->data), CAPIMSG_SUBCOMMAND(skb->data));
 	appl = CAPIMSG_APPID(skb->data);
 	contr = CAPIMSG_CONTROL(skb->data);
 
@@ -387,7 +386,8 @@
 
 	capi_ctr_down(ctrl);
 
-	kthread_stop(session->task);
+	atomic_inc(&session->terminate);
+	wake_up_process(session->task);
 }
 
 static void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_params *rp)
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/cmtp.h flo-ElementalX-5.00-patched/net/bluetooth/cmtp/cmtp.h
--- flo-ElementalX-5.00/net/bluetooth/cmtp/cmtp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/cmtp.h	2016-06-02 00:28:55.000000000 +0000
@@ -81,6 +81,7 @@
 
 	char name[BTNAMSIZ];
 
+	atomic_t terminate;
 	struct task_struct *task;
 
 	wait_queue_head_t wait;
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/core.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/core.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -53,28 +53,24 @@
 static struct cmtp_session *__cmtp_get_session(bdaddr_t *bdaddr)
 {
 	struct cmtp_session *session;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &cmtp_session_list) {
-		session = list_entry(p, struct cmtp_session, list);
+	list_for_each_entry(session, &cmtp_session_list, list)
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
-	}
+
 	return NULL;
 }
 
 static void __cmtp_link_session(struct cmtp_session *session)
 {
-	__module_get(THIS_MODULE);
 	list_add(&session->list, &cmtp_session_list);
 }
 
 static void __cmtp_unlink_session(struct cmtp_session *session)
 {
 	list_del(&session->list);
-	module_put(THIS_MODULE);
 }
 
 static void __cmtp_copy_session(struct cmtp_session *session, struct cmtp_conninfo *ci)
@@ -292,9 +288,11 @@
 
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (!kthread_should_stop()) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
+		if (atomic_read(&session->terminate))
+			break;
 		if (sk->sk_state != BT_CONNECTED)
 			break;
 
@@ -310,7 +308,7 @@
 
 		schedule();
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	down_write(&cmtp_session_sem);
@@ -325,6 +323,7 @@
 	up_write(&cmtp_session_sem);
 
 	kfree(session);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -349,7 +348,8 @@
 
 	bacpy(&session->bdaddr, &bt_sk(sock->sk)->dst);
 
-	session->mtu = min_t(uint, l2cap_pi(sock->sk)->omtu, l2cap_pi(sock->sk)->imtu);
+	session->mtu = min_t(uint, l2cap_pi(sock->sk)->chan->omtu,
+					l2cap_pi(sock->sk)->chan->imtu);
 
 	BT_DBG("mtu %d", session->mtu);
 
@@ -373,25 +373,28 @@
 
 	__cmtp_link_session(session);
 
+	__module_get(THIS_MODULE);
 	session->task = kthread_run(cmtp_session, session, "kcmtpd_ctr_%d",
 								session->num);
 	if (IS_ERR(session->task)) {
+		module_put(THIS_MODULE);
 		err = PTR_ERR(session->task);
 		goto unlink;
 	}
 
 	if (!(session->flags & (1 << CMTP_LOOPBACK))) {
 		err = cmtp_attach_device(session);
-		if (err < 0)
-			goto detach;
+		if (err < 0) {
+			atomic_inc(&session->terminate);
+			wake_up_process(session->task);
+			up_write(&cmtp_session_sem);
+			return err;
+		}
 	}
 
 	up_write(&cmtp_session_sem);
 	return 0;
 
-detach:
-	cmtp_detach_device(session);
-
 unlink:
 	__cmtp_unlink_session(session);
 
@@ -416,7 +419,8 @@
 		skb_queue_purge(&session->transmit);
 
 		/* Stop session thread */
-		kthread_stop(session->task);
+		atomic_inc(&session->terminate);
+		wake_up_process(session->task);
 	} else
 		err = -ENOENT;
 
@@ -426,19 +430,16 @@
 
 int cmtp_get_connlist(struct cmtp_connlist_req *req)
 {
-	struct list_head *p;
+	struct cmtp_session *session;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&cmtp_session_sem);
 
-	list_for_each(p, &cmtp_session_list) {
-		struct cmtp_session *session;
+	list_for_each_entry(session, &cmtp_session_list, list) {
 		struct cmtp_conninfo ci;
 
-		session = list_entry(p, struct cmtp_session, list);
-
 		__cmtp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/cmtp/sock.c flo-ElementalX-5.00-patched/net/bluetooth/cmtp/sock.c
--- flo-ElementalX-5.00/net/bluetooth/cmtp/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/cmtp/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -39,7 +39,6 @@
 
 #include <linux/isdn/capilli.h>
 
-#include <asm/system.h>
 
 #include "cmtp.h"
 
@@ -137,10 +136,10 @@
 {
 	if (cmd == CMTPGETCONNLIST) {
 		struct cmtp_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -151,7 +150,7 @@
 
 		err = cmtp_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_conn.c flo-ElementalX-5.00-patched/net/bluetooth/hci_conn.c
--- flo-ElementalX-5.00/net/bluetooth/hci_conn.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_conn.c	2014-12-03 11:07:31.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -35,194 +35,54 @@
 #include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
+#include <net/bluetooth/smp.h>
 
-struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
-				bdaddr_t *dst, __u8 sec_level, __u8 auth_type,
-				struct bt_le_params *le_params)
+static void hci_le_connect(struct hci_conn *conn)
 {
-	struct hci_conn *le, *le_wlist_conn;
+	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_create_conn cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (le) {
-		le_wlist_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK,
-								BDADDR_ANY);
-		if (!le_wlist_conn) {
-			hci_conn_hold(le);
-			return le;
-		} else {
-			BT_DBG("remove wlist conn");
-			le->out = 1;
-			le->link_mode |= HCI_LM_MASTER;
-			le->sec_level = BT_SECURITY_LOW;
-			le->type = LE_LINK;
-			hci_proto_connect_cfm(le, 0);
-			hci_conn_del(le_wlist_conn);
-			return le;
-		}
-	}
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			le = hci_le_conn_add(hdev, dst,
-					entry->bdaddr_type);
-		else
-			le = hci_le_conn_add(hdev, dst, 0);
-	} else {
-		le = hci_le_conn_add(hdev, dst, key->addr_type);
-	}
-
-	if (!le)
-		return ERR_PTR(-ENOMEM);
-
-	hci_conn_hold(le);
 
-	le->state = BT_CONNECT;
-	le->out = 1;
-	le->link_mode |= HCI_LM_MASTER;
-	le->sec_level = BT_SECURITY_LOW;
-	le->type = LE_LINK;
+	conn->state = BT_CONNECT;
+	conn->out = true;
+	conn->link_mode |= HCI_LM_MASTER;
+	conn->sec_level = BT_SECURITY_LOW;
 
 	memset(&cp, 0, sizeof(cp));
-	if (l2cap_sock_le_params_valid(le_params)) {
-		cp.supervision_timeout =
-				cpu_to_le16(le_params->supervision_timeout);
-		cp.scan_interval = cpu_to_le16(le_params->scan_interval);
-		cp.scan_window = cpu_to_le16(le_params->scan_window);
-		cp.conn_interval_min = cpu_to_le16(le_params->interval_min);
-		cp.conn_interval_max = cpu_to_le16(le_params->interval_max);
-		cp.conn_latency = cpu_to_le16(le_params->latency);
-		cp.min_ce_len = cpu_to_le16(le_params->min_ce_len);
-		cp.max_ce_len = cpu_to_le16(le_params->max_ce_len);
-		le->conn_timeout = le_params->conn_timeout;
-	} else {
-		cp.supervision_timeout = cpu_to_le16(BT_LE_SUP_TO_DEFAULT);
-		cp.scan_interval = cpu_to_le16(BT_LE_SCAN_INTERVAL_DEF);
-		cp.scan_window = cpu_to_le16(BT_LE_SCAN_WINDOW_DEF);
-		cp.conn_interval_min = cpu_to_le16(BT_LE_CONN_INTERVAL_MIN_DEF);
-		cp.conn_interval_max = cpu_to_le16(BT_LE_CONN_INTERVAL_MAX_DEF);
-		cp.conn_latency = cpu_to_le16(BT_LE_LATENCY_DEF);
-		le->conn_timeout = 5;
-	}
-	if (!bacmp(&le->dst, BDADDR_ANY)) {
-		cp.filter_policy = 0x01;
-		le->conn_timeout = 0;
-	} else {
-		bacpy(&cp.peer_addr, &le->dst);
-		cp.peer_addr_type = le->dst_type;
-	}
+	cp.scan_interval = cpu_to_le16(0x0060);
+	cp.scan_window = cpu_to_le16(0x0030);
+	bacpy(&cp.peer_addr, &conn->dst);
+	cp.peer_addr_type = conn->dst_type;
+	cp.conn_interval_min = cpu_to_le16(0x0028);
+	cp.conn_interval_max = cpu_to_le16(0x0038);
+	cp.supervision_timeout = cpu_to_le16(0x002a);
+	cp.min_ce_len = cpu_to_le16(0x0000);
+	cp.max_ce_len = cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
-
-	return le;
 }
-EXPORT_SYMBOL(hci_le_connect);
 
 static void hci_le_connect_cancel(struct hci_conn *conn)
 {
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
-void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_conn *le;
-
-	BT_DBG("%p", hdev);
-
-	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (le) {
-		BT_DBG("send hci connect cancel");
-		hci_le_connect_cancel(le);
-		hci_conn_del(le);
-	}
-}
-EXPORT_SYMBOL(hci_le_cancel_create_connect);
-
-void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_cp_le_add_dev_white_list cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	bacpy(&cp.addr, dst);
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			cp.addr_type = entry->bdaddr_type;
-		else
-			cp.addr_type = 0x00;
-	} else {
-		cp.addr_type = key->addr_type;
-	}
-
-	hci_send_cmd(hdev, HCI_OP_LE_ADD_DEV_WHITE_LIST, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_le_add_dev_white_list);
-
-void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
-{
-	struct hci_cp_le_remove_dev_white_list cp;
-	struct adv_entry *entry;
-	struct link_key *key;
-
-	BT_DBG("%p", hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	bacpy(&cp.addr, dst);
-
-	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
-	if (!key) {
-		entry = hci_find_adv_entry(hdev, dst);
-		if (entry)
-			cp.addr_type = entry->bdaddr_type;
-		else
-			cp.addr_type = 0x00;
-	} else {
-		cp.addr_type = key->addr_type;
-	}
-
-	hci_send_cmd(hdev, HCI_OP_LE_REMOVE_DEV_WHITE_LIST, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_le_remove_dev_white_list);
-
-static inline bool is_role_switch_possible(struct hci_dev *hdev)
-{
-	if (hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECTED))
-		return false;
-	return true;
-}
-
 void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct inquiry_entry *ie;
 	struct hci_cp_create_conn cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->link_mode = HCI_LM_MASTER;
 
@@ -244,12 +104,12 @@
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
-		conn->ssp_mode = ie->data.ssp_mode;
+		if (ie->data.ssp_mode > 0)
+			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
-	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER)
-		&& is_role_switch_possible(hdev))
+	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch = 0x01;
 	else
 		cp.role_switch = 0x00;
@@ -263,7 +123,7 @@
 
 	BT_DBG("%p", conn);
 
-	if (conn->hdev->hci_ver < 2)
+	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
 		return;
 
 	bacpy(&cp.bdaddr, &conn->dst);
@@ -272,22 +132,15 @@
 
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 {
+	struct hci_cp_disconnect cp;
+
 	BT_DBG("%p", conn);
 
 	conn->state = BT_DISCONN;
 
-	if (conn->hdev->dev_type == HCI_BREDR) {
-		struct hci_cp_disconnect cp;
-		cp.handle = cpu_to_le16(conn->handle);
-		cp.reason = reason;
-		hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
-	} else {
-		struct hci_cp_disconn_phys_link cp;
-		cp.phy_handle = (u8) conn->handle;
-		cp.reason = reason;
-		hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHYS_LINK,
-				sizeof(cp), &cp);
-	}
+	cp.handle = cpu_to_le16(conn->handle);
+	cp.reason = reason;
+	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
 void hci_add_sco(struct hci_conn *conn, __u16 handle)
@@ -298,7 +151,7 @@
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 
@@ -316,28 +169,18 @@
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 
 	cp.handle   = cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	if (conn->hdev->is_wbs) {
-		/* Transparent Data */
-		uint16_t voice_setting = hdev->voice_setting | ACF_TRANS;
-		cp.max_latency    = cpu_to_le16(0x000D);
-		cp.pkt_type = cpu_to_le16(ESCO_WBS);
-		cp.voice_setting  = cpu_to_le16(voice_setting);
-		/* Retransmission Effort */
-		cp.retrans_effort = RE_LINK_QUALITY;
-	} else {
-		cp.max_latency    = cpu_to_le16(0x000A);
-		cp.pkt_type = cpu_to_le16(conn->pkt_type);
-		cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
-		cp.retrans_effort = RE_POWER_CONSUMP;
-	}
+	cp.max_latency    = cpu_to_le16(0xffff);
+	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
+	cp.retrans_effort = 0xff;
 
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
@@ -362,18 +205,6 @@
 }
 EXPORT_SYMBOL(hci_le_conn_update);
 
-void hci_read_rssi(struct hci_conn *conn)
-{
-	struct hci_cp_read_rssi cp;
-	struct hci_dev *hdev = conn->hdev;
-
-	memset(&cp, 0, sizeof(cp));
-	cp.handle   = cpu_to_le16(conn->handle);
-
-	hci_send_cmd(hdev, HCI_OP_READ_RSSI, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_read_rssi);
-
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16])
 {
@@ -393,7 +224,7 @@
 }
 EXPORT_SYMBOL(hci_le_start_enc);
 
-void hci_le_ltk_reply(struct hci_conn *conn, __u8 ltk[16])
+void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_ltk_reply cp;
@@ -403,7 +234,7 @@
 	memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
-	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
+	memcpy(cp.ltk, ltk, sizeof(ltk));
 
 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
 }
@@ -444,15 +275,16 @@
 	}
 }
 
-static void hci_conn_timeout(unsigned long arg)
+static void hci_conn_timeout(struct work_struct *work)
 {
-	struct hci_conn *conn = (void *) arg;
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+							disc_work.work);
 	__u8 reason;
 
-	BT_DBG("conn %p state %d", conn, conn->state);
+	BT_DBG("conn %p state %s", conn, state_to_string(conn->state));
 
-	hci_dev_lock(hdev);
+	if (atomic_read(&conn->refcnt))
+		return;
 
 	switch (conn->state) {
 	case BT_CONNECT:
@@ -466,67 +298,76 @@
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		if (!atomic_read(&conn->refcnt)) {
-			reason = hci_proto_disconn_ind(conn);
-			hci_acl_disconn(conn, reason);
-		}
+		reason = hci_proto_disconn_ind(conn);
+		hci_acl_disconn(conn, reason);
 		break;
 	default:
-		if (!atomic_read(&conn->refcnt))
-			conn->state = BT_CLOSED;
+		conn->state = BT_CLOSED;
 		break;
 	}
-
-	hci_dev_unlock(hdev);
 }
 
-static void hci_conn_idle(unsigned long arg)
+/* Enter sniff mode */
+static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 {
-	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	hci_conn_enter_sniff_mode(conn);
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
+		return;
+
+	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
+		return;
+
+	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
+		struct hci_cp_sniff_subrate cp;
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
+	}
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
+		struct hci_cp_sniff_mode cp;
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
+	}
 }
 
-static void hci_conn_rssi_update(struct work_struct *work)
+static void hci_conn_idle(unsigned long arg)
 {
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct hci_conn *conn =
-		container_of(delayed, struct hci_conn, rssi_update_work);
+	struct hci_conn *conn = (void *) arg;
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	hci_read_rssi(conn);
+	hci_conn_enter_sniff_mode(conn);
 }
 
-static void encryption_disabled_timeout(unsigned long userdata)
+static void hci_conn_auto_accept(unsigned long arg)
 {
-	struct hci_conn *conn = (struct hci_conn *)userdata;
-	BT_INFO("conn %p Grace Prd Exp ", conn);
-
-	hci_encrypt_cfm(conn, 0, 0);
-
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		struct hci_cp_set_conn_encrypt cp;
-		BT_INFO("HCI_CONN_ENCRYPT_PEND is set");
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
-						sizeof(cp), &cp);
-	}
+	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
 
+	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
+								&conn->dst);
 }
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst)
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	conn = kzalloc(sizeof(struct hci_conn), GFP_ATOMIC);
+	conn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);
 	if (!conn)
 		return NULL;
 
@@ -538,52 +379,40 @@
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
+	conn->key_type = 0xff;
 
-	conn->power_save = 1;
+	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-	conn->conn_valid = true;
-	spin_lock_init(&conn->lock);
-	wake_lock_init(&conn->idle_lock, WAKE_LOCK_SUSPEND, "bt_idle");
 
 	switch (type) {
 	case ACL_LINK:
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
-		conn->link_policy = hdev->link_policy;
 		break;
 	case SCO_LINK:
-		if (!pkt_type)
-			pkt_type = SCO_ESCO_MASK;
+		if (lmp_esco_capable(hdev))
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
+		else
+			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
+		break;
 	case ESCO_LINK:
-		if (!pkt_type)
-			pkt_type = ALL_ESCO_MASK;
-		if (lmp_esco_capable(hdev)) {
-			/* HCI Setup Synchronous Connection Command uses
-			   reverse logic on the EDR_ESCO_MASK bits */
-			conn->pkt_type = (pkt_type ^ EDR_ESCO_MASK) &
-					hdev->esco_type;
-		} else {
-			/* Legacy HCI Add Sco Connection Command uses a
-			   shifted bitmask */
-			conn->pkt_type = (pkt_type << 5) & hdev->pkt_type &
-					SCO_PTYPE_MASK;
-		}
+		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
 		break;
 	}
 
 	skb_queue_head_init(&conn->data_q);
 
-	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
+	INIT_LIST_HEAD(&conn->chan_list);
+
+	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
-	INIT_DELAYED_WORK(&conn->rssi_update_work, hci_conn_rssi_update);
-	setup_timer(&conn->encrypt_pause_timer, encryption_disabled_timeout,
-			(unsigned long)conn);
+	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
+							(unsigned long) conn);
 
 	atomic_set(&conn->refcnt, 0);
 
 	hci_dev_hold(hdev);
 
-	tasklet_disable(&hdev->tx_task);
-
 	hci_conn_hash_add(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
@@ -592,20 +421,6 @@
 
 	hci_conn_init_sysfs(conn);
 
-	tasklet_enable(&hdev->tx_task);
-
-	return conn;
-}
-
-struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
-							__u8 addr_type)
-{
-	struct hci_conn *conn = hci_conn_add(hdev, LE_LINK, 0, dst);
-	if (!conn)
-		return NULL;
-
-	conn->dst_type = addr_type;
-
 	return conn;
 }
 
@@ -615,17 +430,11 @@
 
 	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
 
-	spin_lock_bh(&conn->lock);
-	conn->conn_valid = false; /* conn data is being released */
-	spin_unlock_bh(&conn->lock);
-
-	/* Make sure no timers are running */
 	del_timer(&conn->idle_timer);
-	wake_lock_destroy(&conn->idle_lock);
-	del_timer(&conn->disc_timer);
-	del_timer(&conn->smp_timer);
-	__cancel_delayed_work(&conn->rssi_update_work);
-	del_timer(&conn->encrypt_pause_timer);
+
+	cancel_delayed_work_sync(&conn->disc_work);
+
+	del_timer(&conn->auto_accept_timer);
 
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
@@ -647,102 +456,35 @@
 		}
 	}
 
-	tasklet_disable(&hdev->tx_task);
+
+	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
-
 	skb_queue_purge(&conn->data_q);
 
 	hci_conn_put_device(conn);
 
 	hci_dev_put(hdev);
 
-	return 0;
-}
-
-struct hci_chan *hci_chan_add(struct hci_dev *hdev)
-{
-	struct hci_chan *chan;
-
-	BT_DBG("%s", hdev->name);
-
-	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
-	if (!chan)
-		return NULL;
-
-	atomic_set(&chan->refcnt, 0);
-
-	hci_dev_hold(hdev);
-
-	chan->hdev = hdev;
-
-	list_add(&chan->list, &hdev->chan_list.list);
-
-	return chan;
-}
-EXPORT_SYMBOL(hci_chan_add);
-
-int hci_chan_del(struct hci_chan *chan)
-{
-	BT_DBG("%s chan %p", chan->hdev->name, chan);
-
-	list_del(&chan->list);
-
-	hci_conn_put(chan->conn);
-	hci_dev_put(chan->hdev);
-
-	kfree(chan);
+	if (conn->handle == 0)
+		kfree(conn);
 
 	return 0;
 }
 
-int hci_chan_put(struct hci_chan *chan)
-{
-	struct hci_cp_disconn_logical_link cp;
-	struct hci_conn *hcon;
-	u16 ll_handle;
-
-	BT_DBG("chan %p refcnt %d", chan, atomic_read(&chan->refcnt));
-	if (!atomic_dec_and_test(&chan->refcnt))
-		return 0;
-
-	hcon = chan->conn;
-	ll_handle = chan->ll_handle;
-
-	hci_chan_del(chan);
-
-	BT_DBG("chan->conn->state %d", hcon->state);
-	if (hcon->state == BT_CONNECTED) {
-		cp.log_handle = cpu_to_le16(ll_handle);
-		hci_send_cmd(hcon->hdev, HCI_OP_DISCONN_LOGICAL_LINK,
-				sizeof(cp), &cp);
-	}
-
-	return 1;
-}
-EXPORT_SYMBOL(hci_chan_put);
-
 struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 {
 	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL;
-	struct list_head *p;
+	struct hci_dev *hdev = NULL, *d;
 
 	BT_DBG("%s -> %s", batostr(src), batostr(dst));
 
-	read_lock_bh(&hci_dev_list_lock);
+	read_lock(&hci_dev_list_lock);
 
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-
-		if (d->dev_type != HCI_BREDR)
-			continue;
+	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
 			continue;
 
@@ -765,83 +507,50 @@
 	if (hdev)
 		hdev = hci_dev_hold(hdev);
 
-	read_unlock_bh(&hci_dev_list_lock);
+	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
 EXPORT_SYMBOL(hci_get_route);
 
-struct hci_dev *hci_dev_get_type(u8 amp_type)
+/* Create SCO, ACL or LE connection.
+ * Device _must_ be locked */
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
 {
-	struct hci_dev *hdev = NULL;
-	struct hci_dev *d;
+	struct hci_conn *acl;
+	struct hci_conn *sco;
+	struct hci_conn *le;
 
-	BT_DBG("amp_type %d", amp_type);
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	read_lock_bh(&hci_dev_list_lock);
+	if (type == LE_LINK) {
+		struct adv_entry *entry;
 
-	list_for_each_entry(d, &hci_dev_list, list) {
-		if ((d->amp_type == amp_type) && test_bit(HCI_UP, &d->flags)) {
-			hdev = d;
-			break;
-		}
-	}
+		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+		if (le)
+			return ERR_PTR(-EBUSY);
 
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
+		entry = hci_find_adv_entry(hdev, dst);
+		if (!entry)
+			return ERR_PTR(-EHOSTUNREACH);
 
-	read_unlock_bh(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_dev_get_type);
+		le = hci_conn_add(hdev, LE_LINK, dst);
+		if (!le)
+			return ERR_PTR(-ENOMEM);
 
-struct hci_dev *hci_dev_get_amp(bdaddr_t *dst)
-{
-	struct hci_dev *d;
-	struct hci_dev *hdev = NULL;
+		le->dst_type = entry->bdaddr_type;
 
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+		hci_le_connect(le);
 
-	read_lock_bh(&hci_dev_list_lock);
+		hci_conn_hold(le);
 
-	list_for_each_entry(d, &hci_dev_list, list) {
-		struct hci_conn *conn;
-		if (d->dev_type == HCI_BREDR)
-			continue;
-		conn = hci_conn_hash_lookup_ba(d, ACL_LINK, dst);
-		if (conn) {
-			hdev = d;
-			break;
-		}
+		return le;
 	}
 
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
-
-	read_unlock_bh(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_dev_get_amp);
-
-/* Create SCO, ACL or LE connection.
- * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst,
-					__u8 sec_level, __u8 auth_type)
-{
-	struct hci_conn *acl;
-	struct hci_conn *sco;
-
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
-
-	if (type == LE_LINK)
-		return hci_le_connect(hdev, pkt_type, dst, sec_level,
-							auth_type, NULL);
-
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
-		acl = hci_conn_add(hdev, ACL_LINK, 0, dst);
+		acl = hci_conn_add(hdev, ACL_LINK, dst);
 		if (!acl)
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 	}
 
 	hci_conn_hold(acl);
@@ -856,23 +565,12 @@
 	if (type == ACL_LINK)
 		return acl;
 
-	/* type of connection already existing can be ESCO or SCO
-	 * so check for both types before creating new */
-
 	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
-
-	if (!sco && type == ESCO_LINK) {
-		sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst);
-	} else if (!sco && type == SCO_LINK) {
-		/* this case can be practically not possible */
-		sco = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, dst);
-	}
-
 	if (!sco) {
-		sco = hci_conn_add(hdev, type, pkt_type, dst);
+		sco = hci_conn_add(hdev, type, dst);
 		if (!sco) {
 			hci_conn_put(acl);
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 		}
 	}
 
@@ -883,12 +581,12 @@
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
-		acl->power_save = 1;
-		hci_conn_enter_active_mode(acl, 1);
+		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
+		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
-		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
+		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
 			/* defer SCO setup until mode change completed */
-			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->pend);
+			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);
 			return sco;
 		}
 
@@ -899,43 +597,12 @@
 }
 EXPORT_SYMBOL(hci_connect);
 
-void hci_disconnect(struct hci_conn *conn, __u8 reason)
-{
-	BT_DBG("conn %p", conn);
-
-	hci_proto_disconn_cfm(conn, reason, 0);
-}
-EXPORT_SYMBOL(hci_disconnect);
-
-void hci_disconnect_amp(struct hci_conn *conn, __u8 reason)
-{
-	struct hci_dev *hdev = NULL;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock_bh(&hci_dev_list_lock);
-
-	list_for_each_entry(hdev, &hci_dev_list, list) {
-		struct hci_conn *c;
-		if (hdev == conn->hdev)
-			continue;
-		if (hdev->amp_type == HCI_BREDR)
-			continue;
-		c = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &conn->dst);
-		if (c)
-			hci_disconnect(c, reason);
-	}
-
-	read_unlock_bh(&hci_dev_list_lock);
-}
-
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0 &&
-					!(conn->link_mode & HCI_LM_ENCRYPT))
+	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 
 	return 1;
@@ -957,71 +624,118 @@
 
 	/* Make sure we preserve an existing MITM requirement*/
 	auth_type |= (conn->auth_type & 0x01);
+
 	conn->auth_type = auth_type;
-	conn->auth_initiator = 1;
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 
 		/* encrypt must be pending if auth is also pending */
-		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
 
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
+		if (conn->key_type != 0xff)
+			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 	}
 
 	return 0;
 }
 
+/* Encrypt the the link */
+static void hci_conn_encrypt(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
+		struct hci_cp_set_conn_encrypt cp;
+		cp.handle  = cpu_to_le16(conn->handle);
+		cp.encrypt = 0x01;
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
+	}
+}
+
 /* Enable security */
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("conn %p %d %d", conn, sec_level, auth_type);
+	BT_DBG("conn %p", conn);
 
+	if (conn->type == LE_LINK)
+		return smp_conn_security(conn, sec_level);
+
+	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
-	if (sec_level == BT_SECURITY_LOW &&
-				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+	/* For non 2.1 devices and low security level we don't need the link
+	   key. */
+	if (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))
 		return 1;
 
-	if (conn->type == LE_LINK) {
-		if (conn->pending_sec_level > sec_level)
-			sec_level = conn->pending_sec_level;
-
-		if (sec_level > conn->sec_level)
-			conn->pending_sec_level = sec_level;
-		hci_proto_connect_cfm(conn, 0);
+	/* For other security levels we need the link key. */
+	if (!(conn->link_mode & HCI_LM_AUTH))
+		goto auth;
+
+	/* An authenticated combination key has sufficient security for any
+	   security level. */
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION)
+		goto encrypt;
+
+	/* An unauthenticated combination key has sufficient security for
+	   security level 1 and 2. */
+	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
+			(sec_level == BT_SECURITY_MEDIUM ||
+			sec_level == BT_SECURITY_LOW))
+		goto encrypt;
+
+	/* A combination key has always sufficient security for the security
+	   levels 1 or 2. High security level requires the combination key
+	   is generated using maximum PIN code length (16).
+	   For pre 2.1 units. */
+	if (conn->key_type == HCI_LK_COMBINATION &&
+			(sec_level != BT_SECURITY_HIGH ||
+			conn->pin_length == 16))
+		goto encrypt;
+
+auth:
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return 0;
-	} else if (conn->link_mode & HCI_LM_ENCRYPT) {
-		return hci_conn_auth(conn, sec_level, auth_type);
-	} else if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+
+	if (!hci_conn_auth(conn, sec_level, auth_type))
 		return 0;
-	}
 
-	if (hci_conn_auth(conn, sec_level, auth_type)) {
-		struct hci_cp_set_conn_encrypt cp;
-		if (timer_pending(&conn->encrypt_pause_timer)) {
-			BT_INFO("encrypt_pause_timer is pending");
-			return 0;
-		}
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
-							sizeof(cp), &cp);
-	}
+encrypt:
+	if (conn->link_mode & HCI_LM_ENCRYPT)
+		return 1;
 
+	hci_conn_encrypt(conn);
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_security);
 
+/* Check secure link requirement */
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
+{
+	BT_DBG("conn %p", conn);
+
+	if (sec_level != BT_SECURITY_HIGH)
+		return 1; /* Accept if non-secure is required */
+
+	if (conn->sec_level == BT_SECURITY_HIGH)
+		return 1;
+
+	return 0; /* Reject not secure link */
+}
+EXPORT_SYMBOL(hci_conn_check_secure);
+
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
@@ -1040,7 +754,7 @@
 	if (!role && conn->link_mode & HCI_LM_MASTER)
 		return 1;
 
-	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
 		struct hci_cp_switch_role cp;
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.role = role;
@@ -1061,187 +775,36 @@
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->type == LE_LINK)
-		return;
-
 	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 
-	if (!conn->power_save && !force_active)
+	if (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)
 		goto timer;
 
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 		struct hci_cp_exit_sniff_mode cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);
 	}
 
 timer:
-	if (hdev->idle_timeout > 0) {
-		spin_lock_bh(&conn->lock);
-		if (conn->conn_valid) {
-			mod_timer(&conn->idle_timer,
-				jiffies + msecs_to_jiffies(hdev->idle_timeout));
-			wake_lock(&conn->idle_lock);
-		}
-		spin_unlock_bh(&conn->lock);
-	}
+	if (hdev->idle_timeout > 0)
+		mod_timer(&conn->idle_timer,
+			jiffies + msecs_to_jiffies(hdev->idle_timeout));
 }
 
-static inline void hci_conn_stop_rssi_timer(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-	cancel_delayed_work(&conn->rssi_update_work);
-}
-
-static inline void hci_conn_start_rssi_timer(struct hci_conn *conn,
-	u16 interval)
-{
-	struct hci_dev *hdev = conn->hdev;
-	BT_DBG("conn %p, pending %d", conn,
-			delayed_work_pending(&conn->rssi_update_work));
-	if (!delayed_work_pending(&conn->rssi_update_work)) {
-		queue_delayed_work(hdev->workqueue, &conn->rssi_update_work,
-				msecs_to_jiffies(interval));
-	}
-}
-
-void hci_conn_set_rssi_reporter(struct hci_conn *conn,
-	s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed)
-{
-	if (conn) {
-		conn->rssi_threshold = rssi_threshold;
-		conn->rssi_update_interval = interval;
-		conn->rssi_update_thresh_exceed = updateOnThreshExceed;
-		hci_conn_start_rssi_timer(conn, interval);
-	}
-}
-
-void hci_conn_unset_rssi_reporter(struct hci_conn *conn)
-{
-	if (conn) {
-		BT_DBG("Deleting the rssi_update_timer");
-		hci_conn_stop_rssi_timer(conn);
-	}
-}
-
-/* Enter sniff mode */
-void hci_conn_enter_sniff_mode(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p mode %d", conn, conn->mode);
-
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
-	if (conn->type == LE_LINK)
-		return;
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE ||
-		!(conn->link_policy & HCI_LP_SNIFF) ||
-		(hci_find_link_key(hdev, &conn->dst) == NULL))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
-}
-
-struct hci_chan *hci_chan_create(struct hci_chan *chan,
-			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
-{
-	struct hci_cp_create_logical_link cp;
-
-	chan->state = BT_CONNECT;
-	chan->tx_fs = *tx_fs;
-	chan->rx_fs = *rx_fs;
-	cp.phy_handle = chan->conn->handle;
-	cp.tx_fs.id = chan->tx_fs.id;
-	cp.tx_fs.type = chan->tx_fs.type;
-	cp.tx_fs.max_sdu = cpu_to_le16(chan->tx_fs.max_sdu);
-	cp.tx_fs.sdu_arr_time = cpu_to_le32(chan->tx_fs.sdu_arr_time);
-	cp.tx_fs.acc_latency = cpu_to_le32(chan->tx_fs.acc_latency);
-	cp.tx_fs.flush_to = cpu_to_le32(chan->tx_fs.flush_to);
-	cp.rx_fs.id = chan->rx_fs.id;
-	cp.rx_fs.type = chan->rx_fs.type;
-	cp.rx_fs.max_sdu = cpu_to_le16(chan->rx_fs.max_sdu);
-	cp.rx_fs.sdu_arr_time = cpu_to_le32(chan->rx_fs.sdu_arr_time);
-	cp.rx_fs.acc_latency = cpu_to_le32(chan->rx_fs.acc_latency);
-	cp.rx_fs.flush_to = cpu_to_le32(chan->rx_fs.flush_to);
-	hci_conn_hold(chan->conn);
-	if (chan->conn->out)
-		hci_send_cmd(chan->conn->hdev, HCI_OP_CREATE_LOGICAL_LINK,
-							sizeof(cp), &cp);
-	else
-		hci_send_cmd(chan->conn->hdev, HCI_OP_ACCEPT_LOGICAL_LINK,
-							sizeof(cp), &cp);
-	return chan;
-}
-EXPORT_SYMBOL(hci_chan_create);
-
-void hci_chan_modify(struct hci_chan *chan,
-			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
-{
-	struct hci_cp_flow_spec_modify cp;
-
-	chan->tx_fs = *tx_fs;
-	chan->rx_fs = *rx_fs;
-	cp.log_handle = cpu_to_le16(chan->ll_handle);
-	cp.tx_fs.id = tx_fs->id;
-	cp.tx_fs.type = tx_fs->type;
-	cp.tx_fs.max_sdu = cpu_to_le16(tx_fs->max_sdu);
-	cp.tx_fs.sdu_arr_time = cpu_to_le32(tx_fs->sdu_arr_time);
-	cp.tx_fs.acc_latency = cpu_to_le32(tx_fs->acc_latency);
-	cp.tx_fs.flush_to = cpu_to_le32(tx_fs->flush_to);
-	cp.rx_fs.id = rx_fs->id;
-	cp.rx_fs.type = rx_fs->type;
-	cp.rx_fs.max_sdu = cpu_to_le16(rx_fs->max_sdu);
-	cp.rx_fs.sdu_arr_time = cpu_to_le32(rx_fs->sdu_arr_time);
-	cp.rx_fs.acc_latency = cpu_to_le32(rx_fs->acc_latency);
-	cp.rx_fs.flush_to = cpu_to_le32(rx_fs->flush_to);
-	hci_conn_hold(chan->conn);
-	hci_send_cmd(chan->conn->hdev, HCI_OP_FLOW_SPEC_MODIFY, sizeof(cp),
-									&cp);
-}
-EXPORT_SYMBOL(hci_chan_modify);
-
 /* Drop all connection on the device */
-void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process)
+void hci_conn_hash_flush(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
+	struct hci_conn *c, *n;
 
 	BT_DBG("hdev %s", hdev->name);
 
-	p = h->list.next;
-	while (p != &h->list) {
-		struct hci_conn *c;
-
-		c = list_entry(p, struct hci_conn, list);
-		p = p->next;
-
+	list_for_each_entry_safe(c, n, &h->list, list) {
 		c->state = BT_CLOSED;
 
-		hci_proto_disconn_cfm(c, 0x16, is_process);
+		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
 		hci_conn_del(c);
 	}
 }
@@ -1277,10 +840,10 @@
 
 int hci_get_conn_list(void __user *arg)
 {
+	register struct hci_conn *c;
 	struct hci_conn_list_req req, *cl;
 	struct hci_conn_info *ci;
 	struct hci_dev *hdev;
-	struct list_head *p;
 	int n = 0, size, err;
 
 	if (copy_from_user(&req, arg, sizeof(req)))
@@ -1303,30 +866,18 @@
 
 	ci = cl->conn_info;
 
-	hci_dev_lock_bh(hdev);
-	list_for_each(p, &hdev->conn_hash.list) {
-		register struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
-
+	hci_dev_lock(hdev);
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
 		bacpy(&(ci + n)->bdaddr, &c->dst);
 		(ci + n)->handle = c->handle;
 		(ci + n)->type  = c->type;
 		(ci + n)->out   = c->out;
 		(ci + n)->state = c->state;
 		(ci + n)->link_mode = c->link_mode;
-		if (c->type == SCO_LINK) {
-			(ci + n)->mtu = hdev->sco_mtu;
-			(ci + n)->cnt = hdev->sco_cnt;
-			(ci + n)->pkts = hdev->sco_pkts;
-		} else {
-			(ci + n)->mtu = hdev->acl_mtu;
-			(ci + n)->cnt = hdev->acl_cnt;
-			(ci + n)->pkts = hdev->acl_pkts;
-		}
 		if (++n >= req.conn_num)
 			break;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	cl->dev_id = hdev->id;
 	cl->conn_num = n;
@@ -1350,7 +901,7 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
 	if (conn) {
 		bacpy(&ci.bdaddr, &conn->dst);
@@ -1359,19 +910,8 @@
 		ci.out   = conn->out;
 		ci.state = conn->state;
 		ci.link_mode = conn->link_mode;
-		if (req.type == SCO_LINK) {
-			ci.mtu = hdev->sco_mtu;
-			ci.cnt = hdev->sco_cnt;
-			ci.pkts = hdev->sco_pkts;
-		} else {
-			ci.mtu = hdev->acl_mtu;
-			ci.cnt = hdev->acl_cnt;
-			ci.pkts = hdev->acl_pkts;
-		}
-		ci.pending_sec_level = conn->pending_sec_level;
-		ci.ssp_mode = conn->ssp_mode;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -1387,11 +927,11 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
 	if (conn)
 		req.type = conn->auth_type;
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -1399,38 +939,48 @@
 	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
 
-int hci_set_auth_info(struct hci_dev *hdev, void __user *arg)
+struct hci_chan *hci_chan_create(struct hci_conn *conn)
 {
-	struct hci_auth_info_req req;
-	struct hci_conn *conn;
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_chan *chan;
 
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
+	BT_DBG("%s conn %p", hdev->name, conn);
 
-	hci_dev_lock_bh(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
-	if (conn) {
-		conn->auth_type = req.type;
-		switch (conn->auth_type) {
-		case HCI_AT_NO_BONDING:
-			conn->pending_sec_level = BT_SECURITY_LOW;
-			break;
-		case HCI_AT_DEDICATED_BONDING:
-		case HCI_AT_GENERAL_BONDING:
-			conn->pending_sec_level = BT_SECURITY_MEDIUM;
-			break;
-		case HCI_AT_DEDICATED_BONDING_MITM:
-		case HCI_AT_GENERAL_BONDING_MITM:
-			conn->pending_sec_level = BT_SECURITY_HIGH;
-			break;
-		default:
-			break;
-		}
-	}
-	hci_dev_unlock_bh(hdev);
+	chan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);
+	if (!chan)
+		return NULL;
 
-	if (!conn)
-		return -ENOENT;
+	chan->conn = conn;
+	skb_queue_head_init(&chan->data_q);
 
-	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
+	list_add_rcu(&chan->list, &conn->chan_list);
+
+	return chan;
+}
+
+int hci_chan_del(struct hci_chan *chan)
+{
+	struct hci_conn *conn = chan->conn;
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
+
+	list_del_rcu(&chan->list);
+
+	synchronize_rcu();
+
+	skb_queue_purge(&chan->data_q);
+	kfree(chan);
+
+	return 0;
+}
+
+void hci_chan_list_flush(struct hci_conn *conn)
+{
+	struct hci_chan *chan, *n;
+
+	BT_DBG("conn %p", conn);
+
+	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
+		hci_chan_del(chan);
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_core.c flo-ElementalX-5.00-patched/net/bluetooth/hci_core.c
--- flo-ElementalX-5.00/net/bluetooth/hci_core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -39,13 +40,11 @@
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <linux/rfkill.h>
 #include <linux/timer.h>
 #include <linux/crypto.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -54,13 +53,9 @@
 
 #define AUTO_OFF_TIMEOUT 2000
 
-static void hci_cmd_task(unsigned long arg);
-static void hci_rx_task(unsigned long arg);
-static void hci_tx_task(unsigned long arg);
-
-static DEFINE_RWLOCK(hci_task_lock);
-
-static bool enable_smp = 1;
+static void hci_rx_work(struct work_struct *work);
+static void hci_cmd_work(struct work_struct *work);
+static void hci_tx_work(struct work_struct *work);
 
 /* HCI device list */
 LIST_HEAD(hci_dev_list);
@@ -70,32 +65,11 @@
 LIST_HEAD(hci_cb_list);
 DEFINE_RWLOCK(hci_cb_list_lock);
 
-/* AMP Manager event callbacks */
-LIST_HEAD(amp_mgr_cb_list);
-DEFINE_RWLOCK(amp_mgr_cb_list_lock);
-
-/* HCI protocols */
-#define HCI_MAX_PROTO	2
-struct hci_proto *hci_proto[HCI_MAX_PROTO];
-
-/* HCI notifiers list */
-static ATOMIC_NOTIFIER_HEAD(hci_notifier);
-
 /* ---- HCI notifications ---- */
 
-int hci_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&hci_notifier, nb);
-}
-
-int hci_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&hci_notifier, nb);
-}
-
 static void hci_notify(struct hci_dev *hdev, int event)
 {
-	atomic_notifier_call_chain(&hci_notifier, event, hdev);
+	hci_sock_dev_event(hdev, event);
 }
 
 /* ---- HCI requests ---- */
@@ -107,8 +81,28 @@
 	/* If this is the init phase check if the completed command matches
 	 * the last init command, and if not just return.
 	 */
-	if (test_bit(HCI_INIT, &hdev->flags) && hdev->init_last_cmd != cmd)
+	if (test_bit(HCI_INIT, &hdev->flags) && hdev->init_last_cmd != cmd) {
+		struct hci_command_hdr *sent = (void *) hdev->sent_cmd->data;
+		struct sk_buff *skb;
+
+		/* Some CSR based controllers generate a spontaneous
+		 * reset complete event during init and any pending
+		 * command will never be completed. In such a case we
+		 * need to resend whatever was the last sent
+		 * command.
+		 */
+
+		if (cmd != HCI_OP_RESET || sent->opcode == HCI_OP_RESET)
+			return;
+
+		skb = skb_clone(hdev->sent_cmd, GFP_ATOMIC);
+		if (skb) {
+			skb_queue_head(&hdev->cmd_q, skb);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
+		}
+
 		return;
+	}
 
 	if (hdev->req_status == HCI_REQ_PEND) {
 		hdev->req_result = result;
@@ -152,7 +146,7 @@
 
 	switch (hdev->req_status) {
 	case HCI_REQ_DONE:
-		err = -bt_err(hdev->req_result);
+		err = -bt_to_errno(hdev->req_result);
 		break;
 
 	case HCI_REQ_CANCELED:
@@ -193,110 +187,104 @@
 
 	/* Reset device */
 	set_bit(HCI_RESET, &hdev->flags);
-	memset(&hdev->features, 0, sizeof(hdev->features));
 	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 }
 
-static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
+static void bredr_init(struct hci_dev *hdev)
 {
 	struct hci_cp_delete_stored_link_key cp;
-	struct sk_buff *skb;
 	__le16 param;
 	__u8 flt_type;
 
-	BT_DBG("%s %ld", hdev->name, opt);
-
-	/* Driver initialization */
-
-	/* Special commands */
-	while ((skb = skb_dequeue(&hdev->driver_init))) {
-		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
-		skb->dev = (void *) hdev;
-
-		skb_queue_tail(&hdev->cmd_q, skb);
-		tasklet_schedule(&hdev->cmd_task);
-	}
-	skb_queue_purge(&hdev->driver_init);
+	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_PACKET_BASED;
 
 	/* Mandatory initialization */
 
 	/* Reset */
 	if (!test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
-			set_bit(HCI_RESET, &hdev->flags);
-			hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+		set_bit(HCI_RESET, &hdev->flags);
+		hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 	}
 
+	/* Read Local Supported Features */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
+
 	/* Read Local Version */
 	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
 
+	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
+	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
 
-	/* Set default HCI Flow Control Mode */
-	if (hdev->dev_type == HCI_BREDR)
-		hdev->flow_ctl_mode = HCI_PACKET_BASED_FLOW_CTL_MODE;
-	else
-		hdev->flow_ctl_mode = HCI_BLOCK_BASED_FLOW_CTL_MODE;
+	/* Read BD Address */
+	hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
 
-	/* Read HCI Flow Control Mode */
-	hci_send_cmd(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, 0, NULL);
+	/* Read Class of Device */
+	hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
 
-	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
+	/* Read Local Name */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
 
-	/* Read Data Block Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, 0, NULL);
+	/* Read Voice Setting */
+	hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
 
-#if 0
-	/* Host buffer size */
-	{
-		struct hci_cp_host_buffer_size cp;
-		cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
-		cp.sco_mtu = HCI_MAX_SCO_SIZE;
-		cp.acl_max_pkt = cpu_to_le16(0xffff);
-		cp.sco_max_pkt = cpu_to_le16(0xffff);
-		hci_send_cmd(hdev, HCI_OP_HOST_BUFFER_SIZE, sizeof(cp), &cp);
-	}
-#endif
-
-	if (hdev->dev_type == HCI_BREDR) {
-		/* BR-EDR initialization */
-
-		/* Read Local Supported Features */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
-
-		/* Read BD Address */
-		hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
-
-		/* Read Class of Device */
-		hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
-
-		/* Read Local Name */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
-
-		/* Read Voice Setting */
-		hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
-
-		/* Optional initialization */
-		/* Clear Event Filters */
-		flt_type = HCI_FLT_CLEAR_ALL;
-		hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
-
-		/* Connection accept timeout ~20 secs */
-		param = cpu_to_le16(0x7d00);
-		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
-
-		bacpy(&cp.bdaddr, BDADDR_ANY);
-		cp.delete_all = 1;
-		hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY,
-				sizeof(cp), &cp);
-	} else {
-		/* AMP initialization */
-		/* Connection accept timeout ~5 secs */
-		param = cpu_to_le16(0x1f40);
-		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
+	/* Optional initialization */
+
+	/* Clear Event Filters */
+	flt_type = HCI_FLT_CLEAR_ALL;
+	hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
+
+	/* Connection accept timeout ~20 secs */
+	param = cpu_to_le16(0x7d00);
+	hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
+
+	bacpy(&cp.bdaddr, BDADDR_ANY);
+	cp.delete_all = 1;
+	hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY, sizeof(cp), &cp);
+}
+
+static void amp_init(struct hci_dev *hdev)
+{
+	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_BLOCK_BASED;
+
+	/* Reset */
+	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+
+	/* Read Local Version */
+	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
+}
+
+static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct sk_buff *skb;
+
+	BT_DBG("%s %ld", hdev->name, opt);
+
+	/* Driver initialization */
+
+	/* Special commands */
+	while ((skb = skb_dequeue(&hdev->driver_init))) {
+		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+		skb->dev = (void *) hdev;
 
-		/* Read AMP Info */
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);
+		skb_queue_tail(&hdev->cmd_q, skb);
+		queue_work(hdev->workqueue, &hdev->cmd_work);
+	}
+	skb_queue_purge(&hdev->driver_init);
+
+	switch (hdev->dev_type) {
+	case HCI_BREDR:
+		bredr_init(hdev);
+		break;
+
+	case HCI_AMP:
+		amp_init(hdev);
+		break;
+
+	default:
+		BT_ERR("Unknown device type %d", hdev->dev_type);
+		break;
 	}
+
 }
 
 static void hci_le_init_req(struct hci_dev *hdev, unsigned long opt)
@@ -305,12 +293,6 @@
 
 	/* Read LE buffer size */
 	hci_send_cmd(hdev, HCI_OP_LE_READ_BUFFER_SIZE, 0, NULL);
-
-	/* Read LE clear white list */
-	hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
-
-	/* Read LE white list size */
-	hci_send_cmd(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, 0, NULL);
 }
 
 static void hci_scan_req(struct hci_dev *hdev, unsigned long opt)
@@ -357,8 +339,7 @@
  * Device is held on return. */
 struct hci_dev *hci_dev_get(int index)
 {
-	struct hci_dev *hdev = NULL;
-	struct list_head *p;
+	struct hci_dev *hdev = NULL, *d;
 
 	BT_DBG("%d", index);
 
@@ -366,8 +347,7 @@
 		return NULL;
 
 	read_lock(&hci_dev_list_lock);
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+	list_for_each_entry(d, &hci_dev_list, list) {
 		if (d->id == index) {
 			hdev = hci_dev_hold(d);
 			break;
@@ -376,75 +356,211 @@
 	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
-EXPORT_SYMBOL(hci_dev_get);
 
 /* ---- Inquiry support ---- */
-static void inquiry_cache_flush(struct hci_dev *hdev)
+
+bool hci_discovery_active(struct hci_dev *hdev)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
-	struct inquiry_entry *next  = cache->list, *e;
+	struct discovery_state *discov = &hdev->discovery;
+
+	switch (discov->state) {
+	case DISCOVERY_FINDING:
+	case DISCOVERY_RESOLVING:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+void hci_discovery_set_state(struct hci_dev *hdev, int state)
+{
+	BT_DBG("%s state %u -> %u", hdev->name, hdev->discovery.state, state);
+
+	if (hdev->discovery.state == state)
+		return;
+
+	switch (state) {
+	case DISCOVERY_STOPPED:
+		if (hdev->discovery.state != DISCOVERY_STARTING)
+			mgmt_discovering(hdev, 0);
+		hdev->discovery.type = 0;
+		break;
+	case DISCOVERY_STARTING:
+		break;
+	case DISCOVERY_FINDING:
+		mgmt_discovering(hdev, 1);
+		break;
+	case DISCOVERY_RESOLVING:
+		break;
+	case DISCOVERY_STOPPING:
+		break;
+	}
 
-	BT_DBG("cache %p", cache);
+	hdev->discovery.state = state;
+}
+
+static void inquiry_cache_flush(struct hci_dev *hdev)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *p, *n;
 
-	cache->list = NULL;
-	while ((e = next)) {
-		next = e->next;
-		kfree(e);
+	list_for_each_entry_safe(p, n, &cache->all, all) {
+		list_del(&p->all);
+		kfree(p);
 	}
+
+	INIT_LIST_HEAD(&cache->unknown);
+	INIT_LIST_HEAD(&cache->resolve);
 }
 
 struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	BT_DBG("cache %p, %s", cache, batostr(bdaddr));
+
+	list_for_each_entry(e, &cache->all, all) {
+		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr)
+{
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *e;
 
 	BT_DBG("cache %p, %s", cache, batostr(bdaddr));
 
-	for (e = cache->list; e; e = e->next)
+	list_for_each_entry(e, &cache->unknown, list) {
 		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
+						       bdaddr_t *bdaddr,
+						       int state)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	BT_DBG("cache %p bdaddr %s state %d", cache, batostr(bdaddr), state);
+
+	list_for_each_entry(e, &cache->resolve, list) {
+		if (!bacmp(bdaddr, BDADDR_ANY) && e->name_state == state)
+			return e;
+		if (!bacmp(&e->data.bdaddr, bdaddr))
+			return e;
+	}
+
+	return NULL;
+}
+
+void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
+				      struct inquiry_entry *ie)
+{
+	struct discovery_state *cache = &hdev->discovery;
+	struct list_head *pos = &cache->resolve;
+	struct inquiry_entry *p;
+
+	list_del(&ie->list);
+
+	list_for_each_entry(p, &cache->resolve, list) {
+		if (p->name_state != NAME_PENDING &&
+				abs(p->data.rssi) >= abs(ie->data.rssi))
 			break;
-	return e;
+		pos = &p->list;
+	}
+
+	list_add(&ie->list, pos);
 }
 
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data)
+bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+			      bool name_known, bool *ssp)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *ie;
 
 	BT_DBG("cache %p, %s", cache, batostr(&data->bdaddr));
 
+	if (ssp)
+		*ssp = data->ssp_mode;
+
 	ie = hci_inquiry_cache_lookup(hdev, &data->bdaddr);
-	if (!ie) {
-		/* Entry not in the cache. Add new one. */
-		ie = kzalloc(sizeof(struct inquiry_entry), GFP_ATOMIC);
-		if (!ie)
-			return;
+	if (ie) {
+		if (ie->data.ssp_mode && ssp)
+			*ssp = true;
+
+		if (ie->name_state == NAME_NEEDED &&
+						data->rssi != ie->data.rssi) {
+			ie->data.rssi = data->rssi;
+			hci_inquiry_cache_update_resolve(hdev, ie);
+		}
+
+		goto update;
+	}
 
-		ie->next = cache->list;
-		cache->list = ie;
+	/* Entry not in the cache. Add new one. */
+	ie = kzalloc(sizeof(struct inquiry_entry), GFP_ATOMIC);
+	if (!ie)
+		return false;
+
+	list_add(&ie->all, &cache->all);
+
+	if (name_known) {
+		ie->name_state = NAME_KNOWN;
+	} else {
+		ie->name_state = NAME_NOT_KNOWN;
+		list_add(&ie->list, &cache->unknown);
+	}
+
+update:
+	if (name_known && ie->name_state != NAME_KNOWN &&
+					ie->name_state != NAME_PENDING) {
+		ie->name_state = NAME_KNOWN;
+		list_del(&ie->list);
 	}
 
 	memcpy(&ie->data, data, sizeof(*data));
 	ie->timestamp = jiffies;
 	cache->timestamp = jiffies;
+
+	if (ie->name_state == NAME_NOT_KNOWN)
+		return false;
+
+	return true;
 }
 
 static int inquiry_cache_dump(struct hci_dev *hdev, int num, __u8 *buf)
 {
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_info *info = (struct inquiry_info *) buf;
 	struct inquiry_entry *e;
 	int copied = 0;
 
-	for (e = cache->list; e && copied < num; e = e->next, copied++) {
+	list_for_each_entry(e, &cache->all, all) {
 		struct inquiry_data *data = &e->data;
+
+		if (copied >= num)
+			break;
+
 		bacpy(&info->bdaddr, &data->bdaddr);
 		info->pscan_rep_mode	= data->pscan_rep_mode;
 		info->pscan_period_mode	= data->pscan_period_mode;
 		info->pscan_mode	= data->pscan_mode;
 		memcpy(info->dev_class, data->dev_class, 3);
 		info->clock_offset	= data->clock_offset;
+
 		info++;
+		copied++;
 	}
 
 	BT_DBG("cache %p, copied %d", cache, copied);
@@ -484,14 +600,14 @@
 	if (!hdev)
 		return -ENODEV;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	if (inquiry_cache_age(hdev) > INQUIRY_CACHE_AGE_MAX ||
 				inquiry_cache_empty(hdev) ||
 				ir.flags & IREQ_CACHE_FLUSH) {
 		inquiry_cache_flush(hdev);
 		do_inquiry = 1;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	timeo = ir.length * msecs_to_jiffies(2000);
 
@@ -513,9 +629,9 @@
 		goto done;
 	}
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	ir.num_rsp = inquiry_cache_dump(hdev, max_rsp, buf);
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	BT_DBG("num_rsp %d", ir.num_rsp);
 
@@ -549,6 +665,11 @@
 
 	hci_req_lock(hdev);
 
+	if (test_bit(HCI_UNREGISTER, &hdev->dev_flags)) {
+		ret = -ENODEV;
+		goto done;
+	}
+
 	if (hdev->rfkill && rfkill_blocked(hdev->rfkill)) {
 		ret = -ERFKILL;
 		goto done;
@@ -562,24 +683,16 @@
 	if (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))
 		set_bit(HCI_RAW, &hdev->flags);
 
+	/* Treat all non BR/EDR controllers as raw devices if
+	   enable_hs is not set */
+	if (hdev->dev_type != HCI_BREDR && !enable_hs)
+		set_bit(HCI_RAW, &hdev->flags);
+
 	if (hdev->open(hdev)) {
 		ret = -EIO;
 		goto done;
 	}
 
-	if (!skb_queue_empty(&hdev->cmd_q)) {
-		BT_ERR("command queue is not empty, purging");
-		skb_queue_purge(&hdev->cmd_q);
-	}
-	if (!skb_queue_empty(&hdev->rx_q)) {
-		BT_ERR("rx queue is not empty, purging");
-		skb_queue_purge(&hdev->rx_q);
-	}
-	if (!skb_queue_empty(&hdev->raw_q)) {
-		BT_ERR("raw queue is not empty, purging");
-		skb_queue_purge(&hdev->raw_q);
-	}
-
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		set_bit(HCI_INIT, &hdev->flags);
@@ -588,7 +701,7 @@
 		ret = __hci_request(hdev, hci_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
-		if (lmp_le_capable(hdev))
+		if (lmp_host_le_capable(hdev))
 			ret = __hci_request(hdev, hci_le_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
@@ -599,17 +712,16 @@
 		hci_dev_hold(hdev);
 		set_bit(HCI_UP, &hdev->flags);
 		hci_notify(hdev, HCI_DEV_UP);
-		if (!test_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR) {
-			hci_dev_lock_bh(hdev);
-			mgmt_powered(hdev->id, 1);
-			hci_dev_unlock_bh(hdev);
+		if (!test_bit(HCI_SETUP, &hdev->dev_flags)) {
+			hci_dev_lock(hdev);
+			mgmt_powered(hdev, 1);
+			hci_dev_unlock(hdev);
 		}
 	} else {
 		/* Init failed, cleanup */
-		tasklet_kill(&hdev->rx_task);
-		tasklet_kill(&hdev->tx_task);
-		tasklet_kill(&hdev->cmd_task);
+		flush_work(&hdev->tx_work);
+		flush_work(&hdev->cmd_work);
+		flush_work(&hdev->rx_work);
 
 		skb_queue_purge(&hdev->cmd_q);
 		skb_queue_purge(&hdev->rx_q);
@@ -632,12 +744,14 @@
 	return ret;
 }
 
-static int hci_dev_do_close(struct hci_dev *hdev, u8 is_process)
+static int hci_dev_do_close(struct hci_dev *hdev)
 {
-	unsigned long keepflags = 0;
-
 	BT_DBG("%s %p", hdev->name, hdev);
 
+	cancel_work_sync(&hdev->le_scan);
+
+	cancel_delayed_work(&hdev->power_off);
+
 	hci_req_cancel(hdev, ENODEV);
 	hci_req_lock(hdev);
 
@@ -647,38 +761,44 @@
 		return 0;
 	}
 
-	/* Kill RX and TX tasks */
-	tasklet_kill(&hdev->rx_task);
-	tasklet_kill(&hdev->tx_task);
+	/* Flush RX and TX works */
+	flush_work(&hdev->tx_work);
+	flush_work(&hdev->rx_work);
+
+	if (hdev->discov_timeout > 0) {
+		cancel_delayed_work(&hdev->discov_off);
+		hdev->discov_timeout = 0;
+		clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+	}
+
+	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		cancel_delayed_work(&hdev->service_cache);
 
-	hci_dev_lock_bh(hdev);
+	cancel_delayed_work_sync(&hdev->le_scan_disable);
+
+	hci_dev_lock(hdev);
 	inquiry_cache_flush(hdev);
-	hci_conn_hash_flush(hdev, is_process);
-	hci_dev_unlock_bh(hdev);
+	hci_conn_hash_flush(hdev);
+	hci_dev_unlock(hdev);
 
 	hci_notify(hdev, HCI_DEV_DOWN);
 
-	if (hdev->dev_type == HCI_BREDR) {
-		hci_dev_lock_bh(hdev);
-		mgmt_powered(hdev->id, 0);
-		hci_dev_unlock_bh(hdev);
-	}
-
 	if (hdev->flush)
 		hdev->flush(hdev);
 
 	/* Reset device */
 	skb_queue_purge(&hdev->cmd_q);
 	atomic_set(&hdev->cmd_cnt, 1);
-	if (!test_bit(HCI_RAW, &hdev->flags)) {
+	if (!test_bit(HCI_RAW, &hdev->flags) &&
+				test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
 		set_bit(HCI_INIT, &hdev->flags);
 		__hci_request(hdev, hci_reset_req, 0,
 					msecs_to_jiffies(250));
 		clear_bit(HCI_INIT, &hdev->flags);
 	}
 
-	/* Kill cmd task */
-	tasklet_kill(&hdev->cmd_task);
+	/* flush cmd  work */
+	flush_work(&hdev->cmd_work);
 
 	/* Drop queues */
 	skb_queue_purge(&hdev->rx_q);
@@ -696,15 +816,17 @@
 	 * and no tasks are scheduled. */
 	hdev->close(hdev);
 
-	/* Clear only non-persistent flags */
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		set_bit(HCI_MGMT, &keepflags);
-	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
-		set_bit(HCI_LINK_KEYS, &keepflags);
-	if (test_bit(HCI_DEBUG_KEYS, &hdev->flags))
-		set_bit(HCI_DEBUG_KEYS, &keepflags);
+	if (!test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags)) {
+		hci_dev_lock(hdev);
+		mgmt_powered(hdev, 0);
+		hci_dev_unlock(hdev);
+	}
+
+	/* Clear flags */
+	hdev->flags = 0;
 
-	hdev->flags = keepflags;
+	memset(hdev->eir, 0, sizeof(hdev->eir));
+	memset(hdev->dev_class, 0, sizeof(hdev->dev_class));
 
 	hci_req_unlock(hdev);
 
@@ -720,7 +842,12 @@
 	hdev = hci_dev_get(dev);
 	if (!hdev)
 		return -ENODEV;
-	err = hci_dev_do_close(hdev, 1);
+
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		cancel_delayed_work(&hdev->power_off);
+
+	err = hci_dev_do_close(hdev);
+
 	hci_dev_put(hdev);
 	return err;
 }
@@ -735,7 +862,6 @@
 		return -ENODEV;
 
 	hci_req_lock(hdev);
-	tasklet_disable(&hdev->tx_task);
 
 	if (!test_bit(HCI_UP, &hdev->flags))
 		goto done;
@@ -744,10 +870,10 @@
 	skb_queue_purge(&hdev->rx_q);
 	skb_queue_purge(&hdev->cmd_q);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	inquiry_cache_flush(hdev);
-	hci_conn_hash_flush(hdev, 0);
-	hci_dev_unlock_bh(hdev);
+	hci_conn_hash_flush(hdev);
+	hci_dev_unlock(hdev);
 
 	if (hdev->flush)
 		hdev->flush(hdev);
@@ -760,7 +886,6 @@
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
 done:
-	tasklet_enable(&hdev->tx_task);
 	hci_req_unlock(hdev);
 	hci_dev_put(hdev);
 	return ret;
@@ -859,9 +984,9 @@
 
 int hci_get_dev_list(void __user *arg)
 {
+	struct hci_dev *hdev;
 	struct hci_dev_list_req *dl;
 	struct hci_dev_req *dr;
-	struct list_head *p;
 	int n = 0, size, err;
 	__u16 dev_num;
 
@@ -879,16 +1004,13 @@
 
 	dr = dl->dev_req;
 
-	read_lock_bh(&hci_dev_list_lock);
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *hdev;
-
-		hdev = list_entry(p, struct hci_dev, list);
-
-		hci_del_off_timer(hdev);
+	read_lock(&hci_dev_list_lock);
+	list_for_each_entry(hdev, &hci_dev_list, list) {
+		if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+			cancel_delayed_work(&hdev->power_off);
 
-		if (!test_bit(HCI_MGMT, &hdev->flags))
-			set_bit(HCI_PAIRABLE, &hdev->flags);
+		if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+			set_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
 		(dr + n)->dev_id  = hdev->id;
 		(dr + n)->dev_opt = hdev->flags;
@@ -896,7 +1018,7 @@
 		if (++n >= dev_num)
 			break;
 	}
-	read_unlock_bh(&hci_dev_list_lock);
+	read_unlock(&hci_dev_list_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*dr);
@@ -920,10 +1042,11 @@
 	if (!hdev)
 		return -ENODEV;
 
-	hci_del_off_timer(hdev);
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		cancel_delayed_work_sync(&hdev->power_off);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
-		set_bit(HCI_PAIRABLE, &hdev->flags);
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		set_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
 	strcpy(di.name, hdev->name);
 	di.bdaddr   = hdev->bdaddr;
@@ -959,7 +1082,7 @@
 	if (!blocked)
 		return 0;
 
-	hci_dev_do_close(hdev, 0);
+	hci_dev_do_close(hdev);
 
 	return 0;
 }
@@ -977,6 +1100,7 @@
 	if (!hdev)
 		return NULL;
 
+	hci_init_sysfs(hdev);
 	skb_queue_head_init(&hdev->driver_init);
 
 	return hdev;
@@ -1001,45 +1125,45 @@
 	BT_DBG("%s", hdev->name);
 
 	err = hci_dev_open(hdev->id);
-	if (err && err != -EALREADY)
+	if (err < 0) {
+		mgmt_set_powered_failed(hdev, err);
 		return;
+	}
+
+	if (test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+		schedule_delayed_work(&hdev->power_off,
+					msecs_to_jiffies(AUTO_OFF_TIMEOUT));
 
-	if (test_bit(HCI_AUTO_OFF, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR)
-		mod_timer(&hdev->off_timer,
-				jiffies + msecs_to_jiffies(AUTO_OFF_TIMEOUT));
-
-	if (test_and_clear_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR)
-		mgmt_index_added(hdev->id);
+	if (test_and_clear_bit(HCI_SETUP, &hdev->dev_flags))
+		mgmt_index_added(hdev);
 }
 
 static void hci_power_off(struct work_struct *work)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, power_off);
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+							power_off.work);
 
 	BT_DBG("%s", hdev->name);
 
-	hci_dev_close(hdev->id);
+	hci_dev_do_close(hdev);
 }
 
-static void hci_auto_off(unsigned long data)
+static void hci_discov_off(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) data;
+	struct hci_dev *hdev;
+	u8 scan = SCAN_PAGE;
+
+	hdev = container_of(work, struct hci_dev, discov_off.work);
 
 	BT_DBG("%s", hdev->name);
 
-	clear_bit(HCI_AUTO_OFF, &hdev->flags);
+	hci_dev_lock(hdev);
 
-	queue_work(hdev->workqueue, &hdev->power_off);
-}
+	hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, sizeof(scan), &scan);
 
-void hci_del_off_timer(struct hci_dev *hdev)
-{
-	BT_DBG("%s", hdev->name);
+	hdev->discov_timeout = 0;
 
-	clear_bit(HCI_AUTO_OFF, &hdev->flags);
-	del_timer(&hdev->off_timer);
+	hci_dev_unlock(hdev);
 }
 
 int hci_uuids_clear(struct hci_dev *hdev)
@@ -1074,80 +1198,108 @@
 	return 0;
 }
 
-struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
+int hci_smp_ltks_clear(struct hci_dev *hdev)
 {
-	struct list_head *p;
+	struct smp_ltk *k, *tmp;
+
+	list_for_each_entry_safe(k, tmp, &hdev->long_term_keys, list) {
+		list_del(&k->list);
+		kfree(k);
+	}
 
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
+	return 0;
+}
 
-		k = list_entry(p, struct link_key, list);
+struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	struct link_key *k;
 
+	list_for_each_entry(k, &hdev->link_keys, list)
 		if (bacmp(bdaddr, &k->bdaddr) == 0)
 			return k;
-	}
 
 	return NULL;
 }
 
-struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
+static bool hci_persistent_key(struct hci_dev *hdev, struct hci_conn *conn,
+						u8 key_type, u8 old_key_type)
 {
-	struct list_head *p;
+	/* Legacy key */
+	if (key_type < 0x03)
+		return true;
 
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
-		struct key_master_id *id;
+	/* Debug keys are insecure so don't store them persistently */
+	if (key_type == HCI_LK_DEBUG_COMBINATION)
+		return false;
 
-		k = list_entry(p, struct link_key, list);
+	/* Changed combination key and there's no previous one */
+	if (key_type == HCI_LK_CHANGED_COMBINATION && old_key_type == 0xff)
+		return false;
 
-		if (k->key_type != KEY_TYPE_LTK)
-			continue;
+	/* Security mode 3 case */
+	if (!conn)
+		return true;
+
+	/* Neither local nor remote side had no-bonding as requirement */
+	if (conn->auth_type > 0x01 && conn->remote_auth > 0x01)
+		return true;
+
+	/* Local side had dedicated bonding as requirement */
+	if (conn->auth_type == 0x02 || conn->auth_type == 0x03)
+		return true;
 
-		if (k->dlen != sizeof(*id))
+	/* Remote side had dedicated bonding as requirement */
+	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03)
+		return true;
+
+	/* If none of the above criteria match, then don't store the key
+	 * persistently */
+	return false;
+}
+
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
+{
+	struct smp_ltk *k;
+
+	list_for_each_entry(k, &hdev->long_term_keys, list) {
+		if (k->ediv != ediv ||
+				memcmp(rand, k->rand, sizeof(k->rand)))
 			continue;
 
-		id = (void *) &k->data;
-		if (id->ediv == ediv &&
-				(memcmp(rand, id->rand, sizeof(id->rand)) == 0))
-			return k;
+		return k;
 	}
 
 	return NULL;
 }
 EXPORT_SYMBOL(hci_find_ltk);
 
-struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
-					bdaddr_t *bdaddr, u8 type)
+struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 addr_type)
 {
-	struct list_head *p;
-
-	list_for_each(p, &hdev->link_keys) {
-		struct link_key *k;
-
-		k = list_entry(p, struct link_key, list);
+	struct smp_ltk *k;
 
-		if ((k->key_type == type) && (bacmp(bdaddr, &k->bdaddr) == 0))
+	list_for_each_entry(k, &hdev->long_term_keys, list)
+		if (addr_type == k->bdaddr_type &&
+					bacmp(bdaddr, &k->bdaddr) == 0)
 			return k;
-	}
 
 	return NULL;
 }
-EXPORT_SYMBOL(hci_find_link_key_type);
+EXPORT_SYMBOL(hci_find_ltk_by_addr);
 
-int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-						u8 *val, u8 type, u8 pin_len)
+int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
+		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len)
 {
 	struct link_key *key, *old_key;
-	struct hci_conn *conn;
 	u8 old_key_type;
-	u8 bonded = 0;
+	bool persistent;
 
 	old_key = hci_find_link_key(hdev, bdaddr);
 	if (old_key) {
-		old_key_type = old_key->key_type;
+		old_key_type = old_key->type;
 		key = old_key;
 	} else {
-		old_key_type = 0xff;
+		old_key_type = conn ? conn->key_type : 0xff;
 		key = kzalloc(sizeof(*key), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
@@ -1156,76 +1308,72 @@
 
 	BT_DBG("%s key for %s type %u", hdev->name, batostr(bdaddr), type);
 
+	/* Some buggy controller combinations generate a changed
+	 * combination key for legacy pairing even when there's no
+	 * previous key */
+	if (type == HCI_LK_CHANGED_COMBINATION &&
+					(!conn || conn->remote_auth == 0xff) &&
+					old_key_type == 0xff) {
+		type = HCI_LK_COMBINATION;
+		if (conn)
+			conn->key_type = type;
+	}
+
 	bacpy(&key->bdaddr, bdaddr);
 	memcpy(key->val, val, 16);
-	key->auth = 0x01;
-	key->key_type = type;
 	key->pin_len = pin_len;
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
-	/* Store the link key persistently if one of the following is true:
-	 * 1. the remote side is using dedicated bonding since in that case
-	 *    also the local requirements are set to dedicated bonding
-	 * 2. the local side had dedicated bonding as a requirement
-	 * 3. this is a legacy link key
-	 * 4. this is a changed combination key and there was a previously
-	 *    stored one
-	 * If none of the above match only keep the link key around for
-	 * this connection and set the temporary flag for the device.
-	*/
+	if (type == HCI_LK_CHANGED_COMBINATION)
+		key->type = old_key_type;
+	else
+		key->type = type;
 
-	if (conn) {
-		if ((conn->remote_auth > 0x01) ||
-			(conn->auth_initiator && conn->auth_type > 0x01) ||
-			(key->key_type < 0x03) ||
-			(key->key_type == 0x06 && old_key_type != 0xff))
-			bonded = 1;
-	}
+	if (!new_key)
+		return 0;
 
-	if (new_key)
-		mgmt_new_key(hdev->id, key, bonded);
+	persistent = hci_persistent_key(hdev, conn, type, old_key_type);
 
-	if (type == 0x06)
-		key->key_type = old_key_type;
+	mgmt_new_link_key(hdev, key, persistent);
+
+	if (conn)
+		conn->flush_key = !persistent;
 
 	return 0;
 }
 
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 addr_type, u8 key_size, u8 auth,
-			__le16 ediv, u8 rand[8], u8 ltk[16])
+int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16
+		ediv, u8 rand[8])
 {
-	struct link_key *key, *old_key;
-	struct key_master_id *id;
+	struct smp_ltk *key, *old_key;
 
-	BT_DBG("%s Auth: %2.2X addr %s type: %d", hdev->name, auth,
-						batostr(bdaddr), addr_type);
+	if (!(type & HCI_SMP_STK) && !(type & HCI_SMP_LTK))
+		return 0;
 
-	old_key = hci_find_link_key_type(hdev, bdaddr, KEY_TYPE_LTK);
-	if (old_key) {
+	old_key = hci_find_ltk_by_addr(hdev, bdaddr, addr_type);
+	if (old_key)
 		key = old_key;
-	} else {
-		key = kzalloc(sizeof(*key) + sizeof(*id), GFP_ATOMIC);
+	else {
+		key = kzalloc(sizeof(*key), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
-		list_add(&key->list, &hdev->link_keys);
+		list_add(&key->list, &hdev->long_term_keys);
 	}
 
-	key->dlen = sizeof(*id);
-
 	bacpy(&key->bdaddr, bdaddr);
-	key->addr_type = addr_type;
-	memcpy(key->val, ltk, sizeof(key->val));
-	key->key_type = KEY_TYPE_LTK;
-	key->pin_len = key_size;
-	key->auth = auth;
-
-	id = (void *) &key->data;
-	id->ediv = ediv;
-	memcpy(id->rand, rand, sizeof(id->rand));
+	key->bdaddr_type = addr_type;
+	memcpy(key->val, tk, sizeof(key->val));
+	key->authenticated = authenticated;
+	key->ediv = ediv;
+	key->enc_size = enc_size;
+	key->type = type;
+	memcpy(key->rand, rand, sizeof(key->rand));
 
-	if (new_key)
-		mgmt_new_key(hdev->id, key, auth & 0x01);
+	if (!new_key)
+		return 0;
+
+	if (type & HCI_SMP_LTK)
+		mgmt_new_ltk(hdev, key, 1);
 
 	return 0;
 }
@@ -1246,6 +1394,23 @@
 	return 0;
 }
 
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	struct smp_ltk *k, *tmp;
+
+	list_for_each_entry_safe(k, tmp, &hdev->long_term_keys, list) {
+		if (bacmp(bdaddr, &k->bdaddr))
+			continue;
+
+		BT_DBG("%s removing %s", hdev->name, batostr(bdaddr));
+
+		list_del(&k->list);
+		kfree(k);
+	}
+
+	return 0;
+}
+
 /* HCI command timer function */
 static void hci_cmd_timer(unsigned long arg)
 {
@@ -1253,12 +1418,11 @@
 
 	BT_ERR("%s command tx timeout", hdev->name);
 	atomic_set(&hdev->cmd_cnt, 1);
-	clear_bit(HCI_RESET, &hdev->flags);
-	tasklet_schedule(&hdev->cmd_task);
+	queue_work(hdev->workqueue, &hdev->cmd_work);
 }
 
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
-							bdaddr_t *bdaddr)
+					  bdaddr_t *bdaddr)
 {
 	struct oob_data *data;
 
@@ -1297,158 +1461,282 @@
 	return 0;
 }
 
-static void hci_adv_clear(unsigned long arg)
-{
-	struct hci_dev *hdev = (void *) arg;
-
-	hci_adv_entries_clear(hdev);
-}
-
-int hci_adv_entries_clear(struct hci_dev *hdev)
+int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
+			    u8 *randomizer)
 {
-	struct list_head *p, *n;
-
-	BT_DBG("");
-	write_lock_bh(&hdev->adv_entries_lock);
+	struct oob_data *data;
 
-	list_for_each_safe(p, n, &hdev->adv_entries) {
-		struct adv_entry *entry;
+	data = hci_find_remote_oob_data(hdev, bdaddr);
 
-		entry = list_entry(p, struct adv_entry, list);
+	if (!data) {
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
 
-		list_del(p);
-		kfree(entry);
+		bacpy(&data->bdaddr, bdaddr);
+		list_add(&data->list, &hdev->remote_oob_data);
 	}
 
-	write_unlock_bh(&hdev->adv_entries_lock);
+	memcpy(data->hash, hash, sizeof(data->hash));
+	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
+
+	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
 
 	return 0;
 }
 
-struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
+struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct list_head *p;
-	struct adv_entry *res = NULL;
+	struct bdaddr_list *b;
 
-	BT_DBG("");
-	read_lock_bh(&hdev->adv_entries_lock);
+	list_for_each_entry(b, &hdev->blacklist, list)
+		if (bacmp(bdaddr, &b->bdaddr) == 0)
+			return b;
 
-	list_for_each(p, &hdev->adv_entries) {
-		struct adv_entry *entry;
+	return NULL;
+}
 
-		entry = list_entry(p, struct adv_entry, list);
+int hci_blacklist_clear(struct hci_dev *hdev)
+{
+	struct list_head *p, *n;
 
-		if (bacmp(bdaddr, &entry->bdaddr) == 0) {
-			res = entry;
-			goto out;
-		}
+	list_for_each_safe(p, n, &hdev->blacklist) {
+		struct bdaddr_list *b;
+
+		b = list_entry(p, struct bdaddr_list, list);
+
+		list_del(p);
+		kfree(b);
 	}
-out:
-	read_unlock_bh(&hdev->adv_entries_lock);
-	return res;
+
+	return 0;
 }
 
-static inline int is_connectable_adv(u8 evt_type)
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
-		return 1;
+	struct bdaddr_list *entry;
 
-	return 0;
+	if (bacmp(bdaddr, BDADDR_ANY) == 0)
+		return -EBADF;
+
+	if (hci_blacklist_lookup(hdev, bdaddr))
+		return -EEXIST;
+
+	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	bacpy(&entry->bdaddr, bdaddr);
+
+	list_add(&entry->list, &hdev->blacklist);
+
+	return mgmt_device_blocked(hdev, bdaddr, type);
 }
 
-int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
-								u8 *randomizer)
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct oob_data *data;
+	struct bdaddr_list *entry;
 
-	data = hci_find_remote_oob_data(hdev, bdaddr);
+	if (bacmp(bdaddr, BDADDR_ANY) == 0)
+		return hci_blacklist_clear(hdev);
 
-	if (!data) {
-		data = kmalloc(sizeof(*data), GFP_ATOMIC);
-		if (!data)
-			return -ENOMEM;
+	entry = hci_blacklist_lookup(hdev, bdaddr);
+	if (!entry)
+		return -ENOENT;
 
-		bacpy(&data->bdaddr, bdaddr);
-		list_add(&data->list, &hdev->remote_oob_data);
-	}
+	list_del(&entry->list);
+	kfree(entry);
 
-	memcpy(data->hash, hash, sizeof(data->hash));
-	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
+	return mgmt_device_unblocked(hdev, bdaddr, type);
+}
 
-	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
+static void hci_clear_adv_cache(struct work_struct *work)
+{
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    adv_work.work);
+
+	hci_dev_lock(hdev);
+
+	hci_adv_entries_clear(hdev);
+
+	hci_dev_unlock(hdev);
+}
+
+int hci_adv_entries_clear(struct hci_dev *hdev)
+{
+	struct adv_entry *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &hdev->adv_entries, list) {
+		list_del(&entry->list);
+		kfree(entry);
+	}
+
+	BT_DBG("%s adv cache cleared", hdev->name);
 
 	return 0;
 }
 
-int hci_add_adv_entry(struct hci_dev *hdev,
-					struct hci_ev_le_advertising_info *ev)
+struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	struct adv_entry *entry;
-	u8 flags = 0;
-	int i;
 
-	BT_DBG("");
+	list_for_each_entry(entry, &hdev->adv_entries, list)
+		if (bacmp(bdaddr, &entry->bdaddr) == 0)
+			return entry;
 
-	if (!is_connectable_adv(ev->evt_type))
-		return -EINVAL;
+	return NULL;
+}
 
-	if (ev->data && ev->length) {
-		for (i = 0; (i + 2) < ev->length; i++)
-			if (ev->data[i+1] == 0x01) {
-				flags = ev->data[i+2];
-				BT_DBG("flags: %2.2x", flags);
-				break;
-			} else {
-				i += ev->data[i];
-			}
-	}
+static inline int is_connectable_adv(u8 evt_type)
+{
+	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
+		return 1;
+
+	return 0;
+}
+
+int hci_add_adv_entry(struct hci_dev *hdev,
+					struct hci_ev_le_advertising_info *ev) { struct adv_entry *entry; if (!is_connectable_adv(ev->evt_type))
+		return -EINVAL;
 
-	entry = hci_find_adv_entry(hdev, &ev->bdaddr);
 	/* Only new entries should be added to adv_entries. So, if
 	 * bdaddr was found, don't add it. */
-	if (entry) {
-		entry->flags = flags;
+	if (hci_find_adv_entry(hdev, &ev->bdaddr))
 		return 0;
-	}
 
-	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
 
 	bacpy(&entry->bdaddr, &ev->bdaddr);
 	entry->bdaddr_type = ev->bdaddr_type;
-	entry->flags = flags;
 
-	write_lock(&hdev->adv_entries_lock);
 	list_add(&entry->list, &hdev->adv_entries);
-	write_unlock(&hdev->adv_entries_lock);
+
+	BT_DBG("%s adv entry added: address %s type %u", hdev->name,
+				batostr(&entry->bdaddr), entry->bdaddr_type);
+
+	return 0;
+}
+
+static void le_scan_param_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct le_scan_params *param =  (struct le_scan_params *) opt;
+	struct hci_cp_le_set_scan_param cp;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.type = param->type;
+	cp.interval = cpu_to_le16(param->interval);
+	cp.window = cpu_to_le16(param->window);
+
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_PARAM, sizeof(cp), &cp);
+}
+
+static void le_scan_enable_req(struct hci_dev *hdev, unsigned long opt)
+{
+	struct hci_cp_le_set_scan_enable cp;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.enable = 1;
+
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
+}
+
+static int hci_do_le_scan(struct hci_dev *hdev, u8 type, u16 interval,
+			  u16 window, int timeout)
+{
+	long timeo = msecs_to_jiffies(3000);
+	struct le_scan_params param;
+	int err;
+
+	BT_DBG("%s", hdev->name);
+
+	if (test_bit(HCI_LE_SCAN, &hdev->dev_flags))
+		return -EINPROGRESS;
+
+	param.type = type;
+	param.interval = interval;
+	param.window = window;
+
+	hci_req_lock(hdev);
+
+	err = __hci_request(hdev, le_scan_param_req, (unsigned long) &param,
+			    timeo);
+	if (!err)
+		err = __hci_request(hdev, le_scan_enable_req, 0, timeo);
+
+	hci_req_unlock(hdev);
+
+	if (err < 0)
+		return err;
+
+	schedule_delayed_work(&hdev->le_scan_disable,
+			      msecs_to_jiffies(timeout));
 
 	return 0;
 }
 
-static struct crypto_blkcipher *alloc_cypher(void)
+static void le_scan_disable_work(struct work_struct *work)
 {
-	if (enable_smp)
-		return crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    le_scan_disable.work);
+	struct hci_cp_le_set_scan_enable cp;
+
+	BT_DBG("%s", hdev->name);
+
+	memset(&cp, 0, sizeof(cp));
 
-	return ERR_PTR(-ENOTSUPP);
+	hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
+}
+
+static void le_scan_work(struct work_struct *work)
+{
+	struct hci_dev *hdev = container_of(work, struct hci_dev, le_scan);
+	struct le_scan_params *param = &hdev->le_scan_params;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_do_le_scan(hdev, param->type, param->interval, param->window,
+		       param->timeout);
+}
+
+int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
+		int timeout)
+{
+	struct le_scan_params *param = &hdev->le_scan_params;
+
+	BT_DBG("%s", hdev->name);
+
+	if (work_busy(&hdev->le_scan))
+		return -EINPROGRESS;
+
+	param->type = type;
+	param->interval = interval;
+	param->window = window;
+	param->timeout = timeout;
+
+	queue_work(system_long_wq, &hdev->le_scan);
+
+	return 0;
 }
 
 /* Register HCI device */
 int hci_register_dev(struct hci_dev *hdev)
 {
 	struct list_head *head = &hci_dev_list, *p;
-	int i, id;
+	int i, id, error;
 
-	BT_DBG("%p name %s bus %d owner %p", hdev, hdev->name,
-						hdev->bus, hdev->owner);
+	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	if (!hdev->open || !hdev->close || !hdev->destruct)
+	if (!hdev->open || !hdev->close)
 		return -EINVAL;
 
+	/* Do not allow HCI_AMP devices to register at index 0,
+	 * so the index can be used as the AMP controller ID.
+	 */
 	id = (hdev->dev_type == HCI_BREDR) ? 0 : 1;
 
-	write_lock_bh(&hci_dev_list_lock);
+	write_lock(&hci_dev_list_lock);
 
 	/* Find first available device id */
 	list_for_each(p, &hci_dev_list) {
@@ -1459,12 +1747,12 @@
 
 	sprintf(hdev->name, "hci%d", id);
 	hdev->id = id;
-	list_add(&hdev->list, head);
+	list_add_tail(&hdev->list, head);
 
-	atomic_set(&hdev->refcnt, 1);
-	spin_lock_init(&hdev->lock);
+	mutex_init(&hdev->lock);
 
 	hdev->flags = 0;
+	hdev->dev_flags = 0;
 	hdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);
 	hdev->esco_type = (ESCO_HV1);
 	hdev->link_mode = (HCI_LM_ACCEPT);
@@ -1474,19 +1762,16 @@
 	hdev->sniff_max_interval = 800;
 	hdev->sniff_min_interval = 80;
 
-	tasklet_init(&hdev->cmd_task, hci_cmd_task, (unsigned long) hdev);
-	tasklet_init(&hdev->rx_task, hci_rx_task, (unsigned long) hdev);
-	tasklet_init(&hdev->tx_task, hci_tx_task, (unsigned long) hdev);
+	INIT_WORK(&hdev->rx_work, hci_rx_work);
+	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
+	INIT_WORK(&hdev->tx_work, hci_tx_work);
+
 
 	skb_queue_head_init(&hdev->rx_q);
 	skb_queue_head_init(&hdev->cmd_q);
 	skb_queue_head_init(&hdev->raw_q);
 
 	setup_timer(&hdev->cmd_timer, hci_cmd_timer, (unsigned long) hdev);
-	setup_timer(&hdev->disco_timer, mgmt_disco_timeout,
-						(unsigned long) hdev);
-	setup_timer(&hdev->disco_le_timer, mgmt_disco_le_timeout,
-						(unsigned long) hdev);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		hdev->reassembly[i] = NULL;
@@ -1494,43 +1779,49 @@
 	init_waitqueue_head(&hdev->req_wait_q);
 	mutex_init(&hdev->req_lock);
 
-	inquiry_cache_init(hdev);
+	discovery_init(hdev);
 
 	hci_conn_hash_init(hdev);
-	hci_chan_list_init(hdev);
+
+	INIT_LIST_HEAD(&hdev->mgmt_pending);
 
 	INIT_LIST_HEAD(&hdev->blacklist);
 
 	INIT_LIST_HEAD(&hdev->uuids);
 
 	INIT_LIST_HEAD(&hdev->link_keys);
+	INIT_LIST_HEAD(&hdev->long_term_keys);
 
 	INIT_LIST_HEAD(&hdev->remote_oob_data);
 
 	INIT_LIST_HEAD(&hdev->adv_entries);
-	rwlock_init(&hdev->adv_entries_lock);
-	setup_timer(&hdev->adv_timer, hci_adv_clear, (unsigned long) hdev);
 
+	INIT_DELAYED_WORK(&hdev->adv_work, hci_clear_adv_cache);
 	INIT_WORK(&hdev->power_on, hci_power_on);
-	INIT_WORK(&hdev->power_off, hci_power_off);
-	setup_timer(&hdev->off_timer, hci_auto_off, (unsigned long) hdev);
+	INIT_DELAYED_WORK(&hdev->power_off, hci_power_off);
+
+	INIT_DELAYED_WORK(&hdev->discov_off, hci_discov_off);
 
 	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	atomic_set(&hdev->promisc, 0);
 
-	write_unlock_bh(&hci_dev_list_lock);
+	INIT_WORK(&hdev->le_scan, le_scan_work);
+
+	INIT_DELAYED_WORK(&hdev->le_scan_disable, le_scan_disable_work);
 
-	hdev->workqueue = create_singlethread_workqueue(hdev->name);
-	if (!hdev->workqueue)
-		goto nomem;
-
-	hdev->tfm = alloc_cypher();
-	if (IS_ERR(hdev->tfm))
-		BT_INFO("Failed to load transform for ecb(aes): %ld",
-							PTR_ERR(hdev->tfm));
+	write_unlock(&hci_dev_list_lock);
 
-	hci_register_sysfs(hdev);
+	hdev->workqueue = alloc_workqueue(hdev->name, WQ_HIGHPRI | WQ_UNBOUND |
+							WQ_MEM_RECLAIM, 1);
+	if (!hdev->workqueue) {
+		error = -ENOMEM;
+		goto err;
+	}
+
+	error = hci_add_sysfs(hdev);
+	if (error < 0)
+		goto err_wqueue;
 
 	hdev->rfkill = rfkill_alloc(hdev->name, &hdev->dev,
 				RFKILL_TYPE_BLUETOOTH, &hci_rfkill_ops, hdev);
@@ -1541,49 +1832,56 @@
 		}
 	}
 
-	set_bit(HCI_AUTO_OFF, &hdev->flags);
-	set_bit(HCI_SETUP, &hdev->flags);
-	queue_work(hdev->workqueue, &hdev->power_on);
+	set_bit(HCI_AUTO_OFF, &hdev->dev_flags);
+	set_bit(HCI_SETUP, &hdev->dev_flags);
+	schedule_work(&hdev->power_on);
 
 	hci_notify(hdev, HCI_DEV_REG);
+	hci_dev_hold(hdev);
 
 	return id;
 
-nomem:
-	write_lock_bh(&hci_dev_list_lock);
+err_wqueue:
+	destroy_workqueue(hdev->workqueue);
+err:
+	write_lock(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock_bh(&hci_dev_list_lock);
+	write_unlock(&hci_dev_list_lock);
 
-	return -ENOMEM;
+	return error;
 }
 EXPORT_SYMBOL(hci_register_dev);
 
 /* Unregister HCI device */
-int hci_unregister_dev(struct hci_dev *hdev)
+void hci_unregister_dev(struct hci_dev *hdev)
 {
 	int i;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	write_lock_bh(&hci_dev_list_lock);
+	set_bit(HCI_UNREGISTER, &hdev->dev_flags);
+
+	write_lock(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock_bh(&hci_dev_list_lock);
+	write_unlock(&hci_dev_list_lock);
 
-	hci_dev_do_close(hdev, hdev->bus == HCI_SMD);
+	hci_dev_do_close(hdev);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		kfree_skb(hdev->reassembly[i]);
 
+	cancel_work_sync(&hdev->power_on);
+
 	if (!test_bit(HCI_INIT, &hdev->flags) &&
-				!test_bit(HCI_SETUP, &hdev->flags) &&
-				hdev->dev_type == HCI_BREDR) {
-		hci_dev_lock_bh(hdev);
-		mgmt_index_removed(hdev->id);
-		hci_dev_unlock_bh(hdev);
+				!test_bit(HCI_SETUP, &hdev->dev_flags)) {
+		hci_dev_lock(hdev);
+		mgmt_index_removed(hdev);
+		hci_dev_unlock(hdev);
 	}
 
-	if (!IS_ERR(hdev->tfm))
-		crypto_free_blkcipher(hdev->tfm);
+	/* mgmt_index_removed should take care of emptying the
+	 * pending list */
+	BUG_ON(!list_empty(&hdev->mgmt_pending));
 
 	hci_notify(hdev, HCI_DEV_UNREG);
 
@@ -1592,28 +1890,22 @@
 		rfkill_destroy(hdev->rfkill);
 	}
 
-	hci_unregister_sysfs(hdev);
+	hci_del_sysfs(hdev);
 
-	/* Disable all timers */
-	hci_del_off_timer(hdev);
-	del_timer(&hdev->adv_timer);
-	del_timer(&hdev->cmd_timer);
-	del_timer(&hdev->disco_timer);
-	del_timer(&hdev->disco_le_timer);
+	cancel_delayed_work_sync(&hdev->adv_work);
 
 	destroy_workqueue(hdev->workqueue);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	hci_blacklist_clear(hdev);
 	hci_uuids_clear(hdev);
 	hci_link_keys_clear(hdev);
+	hci_smp_ltks_clear(hdev);
 	hci_remote_oob_data_clear(hdev);
 	hci_adv_entries_clear(hdev);
-	hci_dev_unlock_bh(hdev);
-
-	__hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
-	return 0;
+	hci_dev_put(hdev);
 }
 EXPORT_SYMBOL(hci_unregister_dev);
 
@@ -1649,9 +1941,8 @@
 	/* Time stamp */
 	__net_timestamp(skb);
 
-	/* Queue frame for rx task */
 	skb_queue_tail(&hdev->rx_q, skb);
-	tasklet_schedule(&hdev->rx_task);
+	queue_work(hdev->workqueue, &hdev->rx_work);
 
 	return 0;
 }
@@ -1702,7 +1993,7 @@
 
 	while (count) {
 		scb = (void *) skb->cb;
-		len = min(scb->expect, (__u16)count);
+		len = min_t(uint, scb->expect, count);
 
 		memcpy(skb_put(skb, len), data, len);
 
@@ -1780,7 +2071,7 @@
 
 		data += (count - rem);
 		count = rem;
-	};
+	}
 
 	return rem;
 }
@@ -1815,7 +2106,7 @@
 
 		data += (count - rem);
 		count = rem;
-	};
+	}
 
 	return rem;
 }
@@ -1823,59 +2114,13 @@
 
 /* ---- Interface to upper protocols ---- */
 
-/* Register/Unregister protocols.
- * hci_task_lock is used to ensure that no tasks are running. */
-int hci_register_proto(struct hci_proto *hp)
-{
-	int err = 0;
-
-	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
-
-	if (hp->id >= HCI_MAX_PROTO)
-		return -EINVAL;
-
-	write_lock_bh(&hci_task_lock);
-
-	if (!hci_proto[hp->id])
-		hci_proto[hp->id] = hp;
-	else
-		err = -EEXIST;
-
-	write_unlock_bh(&hci_task_lock);
-
-	return err;
-}
-EXPORT_SYMBOL(hci_register_proto);
-
-int hci_unregister_proto(struct hci_proto *hp)
-{
-	int err = 0;
-
-	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
-
-	if (hp->id >= HCI_MAX_PROTO)
-		return -EINVAL;
-
-	write_lock_bh(&hci_task_lock);
-
-	if (hci_proto[hp->id])
-		hci_proto[hp->id] = NULL;
-	else
-		err = -ENOENT;
-
-	write_unlock_bh(&hci_task_lock);
-
-	return err;
-}
-EXPORT_SYMBOL(hci_unregister_proto);
-
 int hci_register_cb(struct hci_cb *cb)
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock_bh(&hci_cb_list_lock);
+	write_lock(&hci_cb_list_lock);
 	list_add(&cb->list, &hci_cb_list);
-	write_unlock_bh(&hci_cb_list_lock);
+	write_unlock(&hci_cb_list_lock);
 
 	return 0;
 }
@@ -1885,82 +2130,14 @@
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock_bh(&hci_cb_list_lock);
+	write_lock(&hci_cb_list_lock);
 	list_del(&cb->list);
-	write_unlock_bh(&hci_cb_list_lock);
+	write_unlock(&hci_cb_list_lock);
 
 	return 0;
 }
 EXPORT_SYMBOL(hci_unregister_cb);
 
-int hci_register_amp(struct amp_mgr_cb *cb)
-{
-	BT_DBG("%p", cb);
-
-	write_lock_bh(&amp_mgr_cb_list_lock);
-	list_add(&cb->list, &amp_mgr_cb_list);
-	write_unlock_bh(&amp_mgr_cb_list_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_register_amp);
-
-int hci_unregister_amp(struct amp_mgr_cb *cb)
-{
-	BT_DBG("%p", cb);
-
-	write_lock_bh(&amp_mgr_cb_list_lock);
-	list_del(&cb->list);
-	write_unlock_bh(&amp_mgr_cb_list_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_unregister_amp);
-
-void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
-			struct sk_buff *skb)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("opcode 0x%x", opcode);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_cmd_complete_event)
-			cb->amp_cmd_complete_event(hdev, opcode, skb);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
-void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("opcode 0x%x, status %d", opcode, status);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_cmd_status_event)
-			cb->amp_cmd_status_event(hdev, opcode, status);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
-void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
-			struct sk_buff *skb)
-{
-	struct amp_mgr_cb *cb;
-
-	BT_DBG("ev_code 0x%x", ev_code);
-
-	read_lock_bh(&amp_mgr_cb_list_lock);
-	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
-		if (cb->amp_event)
-			cb->amp_event(hdev, ev_code, skb);
-	}
-	read_unlock_bh(&amp_mgr_cb_list_lock);
-}
-
 static int hci_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
@@ -1972,17 +2149,20 @@
 
 	BT_DBG("%s type %d len %d", hdev->name, bt_cb(skb)->pkt_type, skb->len);
 
-	if (atomic_read(&hdev->promisc)) {
-		/* Time stamp */
-		__net_timestamp(skb);
+	/* Time stamp */
+	__net_timestamp(skb);
 
-		hci_send_to_sock(hdev, skb, NULL);
+	/* Send copy to monitor */
+	hci_send_to_monitor(hdev, skb);
+
+	if (atomic_read(&hdev->promisc)) {
+		/* Send copy to the sockets */
+		hci_send_to_sock(hdev, skb);
 	}
 
 	/* Get rid of skb owner, prior to sending to the driver. */
 	skb_orphan(skb);
 
-	hci_notify(hdev, HCI_DEV_WRITE);
 	return hdev->send(skb);
 }
 
@@ -2017,11 +2197,10 @@
 		hdev->init_last_cmd = opcode;
 
 	skb_queue_tail(&hdev->cmd_q, skb);
-	tasklet_schedule(&hdev->cmd_task);
+	queue_work(hdev->workqueue, &hdev->cmd_work);
 
 	return 0;
 }
-EXPORT_SYMBOL(hci_send_cmd);
 
 /* Get data from the previously sent command */
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)
@@ -2054,27 +2233,18 @@
 	hdr->dlen   = cpu_to_le16(len);
 }
 
-void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
-		struct sk_buff *skb, __u16 flags)
+static void hci_queue_acl(struct hci_conn *conn, struct sk_buff_head *queue,
+				struct sk_buff *skb, __u16 flags)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct sk_buff *list;
 
-	BT_DBG("%s conn %p chan %p flags 0x%x", hdev->name, conn, chan, flags);
-
-	skb->dev = (void *) hdev;
-	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-	if (hdev->dev_type == HCI_BREDR)
-		hci_add_acl_hdr(skb, conn->handle, flags);
-	else
-		hci_add_acl_hdr(skb, chan->ll_handle, flags);
-
 	list = skb_shinfo(skb)->frag_list;
 	if (!list) {
 		/* Non fragmented */
 		BT_DBG("%s nonfrag skb %p len %d", hdev->name, skb, skb->len);
 
-		skb_queue_tail(&conn->data_q, skb);
+		skb_queue_tail(queue, skb);
 	} else {
 		/* Fragmented */
 		BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
@@ -2082,10 +2252,11 @@
 		skb_shinfo(skb)->frag_list = NULL;
 
 		/* Queue all fragments atomically */
-		spin_lock_bh(&conn->data_q.lock);
+		spin_lock(&queue->lock);
 
-		__skb_queue_tail(&conn->data_q, skb);
-		flags &= ~ACL_PB_MASK;
+		__skb_queue_tail(queue, skb);
+
+		flags &= ~ACL_START;
 		flags |= ACL_CONT;
 		do {
 			skb = list; list = list->next;
@@ -2096,13 +2267,27 @@
 
 			BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
 
-			__skb_queue_tail(&conn->data_q, skb);
+			__skb_queue_tail(queue, skb);
 		} while (list);
 
-		spin_unlock_bh(&conn->data_q.lock);
+		spin_unlock(&queue->lock);
 	}
+}
 
-	tasklet_schedule(&hdev->tx_task);
+void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags)
+{
+	struct hci_conn *conn = chan->conn;
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s chan %p flags 0x%x", hdev->name, chan, flags);
+
+	skb->dev = (void *) hdev;
+	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
+	hci_add_acl_hdr(skb, conn->handle, flags);
+
+	hci_queue_acl(conn, &chan->data_q, skb, flags);
+
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 EXPORT_SYMBOL(hci_send_acl);
 
@@ -2125,75 +2310,25 @@
 	bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
 
 	skb_queue_tail(&conn->data_q, skb);
-	tasklet_schedule(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 EXPORT_SYMBOL(hci_send_sco);
 
 /* ---- HCI TX task (outgoing data) ---- */
-/* HCI ACL Connection scheduler */
-static inline struct hci_conn *hci_low_sent_acl(struct hci_dev *hdev,
-								int *quote)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn = NULL;
-	int num = 0, min = ~0, conn_num = 0;
-	struct list_head *p;
-
-	/* We don't have to lock device here. Connections are always
-	 * added and removed with TX task disabled. */
-	list_for_each(p, &h->list) {
-		struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == ACL_LINK)
-			conn_num++;
-
-		if (skb_queue_empty(&c->data_q))
-			continue;
-
-		if (c->state != BT_CONNECTED && c->state != BT_CONFIG)
-			continue;
-
-		num++;
-
-		if (c->sent < min) {
-			min  = c->sent;
-			conn = c;
-		}
-	}
-
-	if (conn) {
-		int cnt, q;
-		cnt = hdev->acl_cnt;
-		q = cnt / num;
-		*quote = q ? q : 1;
-	} else
-		*quote = 0;
-
-	if ((*quote == hdev->acl_cnt) &&
-		(conn->sent == (hdev->acl_pkts - 1)) &&
-		(conn_num > 1)) {
-			*quote = 0;
-			conn = NULL;
-	}
-
-	BT_DBG("conn %p quote %d", conn, *quote);
-	return conn;
-}
 
 /* HCI Connection scheduler */
 static inline struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type, int *quote)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn = NULL;
+	struct hci_conn *conn = NULL, *c;
 	int num = 0, min = ~0;
-	struct list_head *p;
 
 	/* We don't have to lock device here. Connections are always
 	 * added and removed with TX task disabled. */
-	list_for_each(p, &h->list) {
-		struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
 
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
 		if (c->type != type || skb_queue_empty(&c->data_q))
 			continue;
 
@@ -2206,8 +2341,13 @@
 			min  = c->sent;
 			conn = c;
 		}
+
+		if (hci_conn_num(hdev, type) == num)
+			break;
 	}
 
+	rcu_read_unlock();
+
 	if (conn) {
 		int cnt, q;
 
@@ -2239,69 +2379,270 @@
 static inline void hci_link_tx_to(struct hci_dev *hdev, __u8 type)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
-	struct hci_conn  *c;
+	struct hci_conn *c;
 
 	BT_ERR("%s link tx timeout", hdev->name);
 
+	rcu_read_lock();
+
 	/* Kill stalled connections */
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
+	list_for_each_entry_rcu(c, &h->list, list) {
 		if (c->type == type && c->sent) {
 			BT_ERR("%s killing stalled connection %s",
 				hdev->name, batostr(&c->dst));
 			hci_acl_disconn(c, 0x13);
 		}
 	}
+
+	rcu_read_unlock();
 }
 
-static inline void hci_sched_acl(struct hci_dev *hdev)
+static inline struct hci_chan *hci_chan_sent(struct hci_dev *hdev, __u8 type,
+						int *quote)
 {
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_chan *chan = NULL;
+	int num = 0, min = ~0, cur_prio = 0;
 	struct hci_conn *conn;
-	struct sk_buff *skb;
-	int quote;
+	int cnt, q, conn_num = 0;
+
+	BT_DBG("%s", hdev->name);
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(conn, &h->list, list) {
+		struct hci_chan *tmp;
+
+		if (conn->type != type)
+			continue;
+
+		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
+			continue;
+
+		conn_num++;
+
+		list_for_each_entry_rcu(tmp, &conn->chan_list, list) {
+			struct sk_buff *skb;
+
+			if (skb_queue_empty(&tmp->data_q))
+				continue;
+
+			skb = skb_peek(&tmp->data_q);
+			if (skb->priority < cur_prio)
+				continue;
+
+			if (skb->priority > cur_prio) {
+				num = 0;
+				min = ~0;
+				cur_prio = skb->priority;
+			}
+
+			num++;
+
+			if (conn->sent < min) {
+				min  = conn->sent;
+				chan = tmp;
+			}
+		}
+
+		if (hci_conn_num(hdev, type) == conn_num)
+			break;
+	}
+
+	rcu_read_unlock();
+
+	if (!chan)
+		return NULL;
+
+	switch (chan->conn->type) {
+	case ACL_LINK:
+		cnt = hdev->acl_cnt;
+		break;
+	case SCO_LINK:
+	case ESCO_LINK:
+		cnt = hdev->sco_cnt;
+		break;
+	case LE_LINK:
+		cnt = hdev->le_mtu ? hdev->le_cnt : hdev->acl_cnt;
+		break;
+	default:
+		cnt = 0;
+		BT_ERR("Unknown link type");
+	}
+
+	q = cnt / num;
+	*quote = q ? q : 1;
+	BT_DBG("chan %p quote %d", chan, *quote);
+	return chan;
+}
+
+static void hci_prio_recalculate(struct hci_dev *hdev, __u8 type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn *conn;
+	int num = 0;
 
 	BT_DBG("%s", hdev->name);
 
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(conn, &h->list, list) {
+		struct hci_chan *chan;
+
+		if (conn->type != type)
+			continue;
+
+		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
+			continue;
+
+		num++;
+
+		list_for_each_entry_rcu(chan, &conn->chan_list, list) {
+			struct sk_buff *skb;
+
+			if (chan->sent) {
+				chan->sent = 0;
+				continue;
+			}
+
+			if (skb_queue_empty(&chan->data_q))
+				continue;
+
+			skb = skb_peek(&chan->data_q);
+			if (skb->priority >= HCI_PRIO_MAX - 1)
+				continue;
+
+			skb->priority = HCI_PRIO_MAX - 1;
+
+			BT_DBG("chan %p skb %p promoted to %d", chan, skb,
+								skb->priority);
+		}
+
+		if (hci_conn_num(hdev, type) == num)
+			break;
+	}
+
+	rcu_read_unlock();
+
+}
+
+static inline int __get_blocks(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	/* Calculate count of blocks used by this packet */
+	return DIV_ROUND_UP(skb->len - HCI_ACL_HDR_SIZE, hdev->block_len);
+}
+
+static inline void __check_timeout(struct hci_dev *hdev, unsigned int cnt)
+{
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* ACL tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
-		if (hdev->acl_cnt <= 0 &&
-			time_after(jiffies, hdev->acl_last_tx + HZ * 45))
+		if (!cnt && time_after(jiffies, hdev->acl_last_tx +
+					msecs_to_jiffies(HCI_ACL_TX_TIMEOUT)))
 			hci_link_tx_to(hdev, ACL_LINK);
 	}
+}
 
-	while (hdev->acl_cnt > 0 &&
-		((conn = hci_low_sent_acl(hdev, &quote)) != NULL)) {
+static inline void hci_sched_acl_pkt(struct hci_dev *hdev)
+{
+	unsigned int cnt = hdev->acl_cnt;
+	struct hci_chan *chan;
+	struct sk_buff *skb;
+	int quote;
 
-		while (quote > 0 &&
-			  (skb = skb_dequeue(&conn->data_q))) {
-			int count = 1;
+	__check_timeout(hdev, cnt);
 
-			BT_DBG("skb %p len %d", skb, skb->len);
+	while (hdev->acl_cnt &&
+			(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote-- && (skb = skb_peek(&chan->data_q))) {
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+					skb->len, skb->priority);
 
-			if (hdev->flow_ctl_mode ==
-				HCI_BLOCK_BASED_FLOW_CTL_MODE)
-				/* Calculate count of blocks used by
-				 * this packet
-				 */
-				count = ((skb->len - HCI_ACL_HDR_SIZE - 1) /
-					hdev->data_block_len) + 1;
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
+
+			skb = skb_dequeue(&chan->data_q);
+
+			hci_conn_enter_active_mode(chan->conn,
+						   bt_cb(skb)->force_active);
+
+			hci_send_frame(skb);
+			hdev->acl_last_tx = jiffies;
+
+			hdev->acl_cnt--;
+			chan->sent++;
+			chan->conn->sent++;
+		}
+	}
+
+	if (cnt != hdev->acl_cnt)
+		hci_prio_recalculate(hdev, ACL_LINK);
+}
+
+static inline void hci_sched_acl_blk(struct hci_dev *hdev)
+{
+	unsigned int cnt = hdev->block_cnt;
+	struct hci_chan *chan;
+	struct sk_buff *skb;
+	int quote;
+
+	__check_timeout(hdev, cnt);
+
+	while (hdev->block_cnt > 0 &&
+			(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote > 0 && (skb = skb_peek(&chan->data_q))) {
+			int blocks;
+
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+						skb->len, skb->priority);
+
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
 
-			if (count > hdev->acl_cnt)
+			skb = skb_dequeue(&chan->data_q);
+
+			blocks = __get_blocks(hdev, skb);
+			if (blocks > hdev->block_cnt)
 				return;
 
-			hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
+			hci_conn_enter_active_mode(chan->conn,
+						bt_cb(skb)->force_active);
 
 			hci_send_frame(skb);
 			hdev->acl_last_tx = jiffies;
 
-			hdev->acl_cnt -= count;
-			quote -= count;
+			hdev->block_cnt -= blocks;
+			quote -= blocks;
 
-			conn->sent += count;
+			chan->sent += blocks;
+			chan->conn->sent += blocks;
 		}
 	}
+
+	if (cnt != hdev->block_cnt)
+		hci_prio_recalculate(hdev, ACL_LINK);
+}
+
+static inline void hci_sched_acl(struct hci_dev *hdev)
+{
+	BT_DBG("%s", hdev->name);
+
+	if (!hci_conn_num(hdev, ACL_LINK))
+		return;
+
+	switch (hdev->flow_ctl_mode) {
+	case HCI_FLOW_CTL_MODE_PACKET_BASED:
+		hci_sched_acl_pkt(hdev);
+		break;
+
+	case HCI_FLOW_CTL_MODE_BLOCK_BASED:
+		hci_sched_acl_blk(hdev);
+		break;
+	}
 }
 
 /* Schedule SCO */
@@ -2313,6 +2654,9 @@
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, SCO_LINK))
+		return;
+
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, SCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2333,6 +2677,9 @@
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, ESCO_LINK))
+		return;
+
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, ESCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2347,12 +2694,15 @@
 
 static inline void hci_sched_le(struct hci_dev *hdev)
 {
-	struct hci_conn *conn;
+	struct hci_chan *chan;
 	struct sk_buff *skb;
-	int quote, cnt;
+	int quote, cnt, tmp;
 
 	BT_DBG("%s", hdev->name);
 
+	if (!hci_conn_num(hdev, LE_LINK))
+		return;
+
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* LE tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
@@ -2362,30 +2712,42 @@
 	}
 
 	cnt = hdev->le_pkts ? hdev->le_cnt : hdev->acl_cnt;
-	while (cnt && (conn = hci_low_sent(hdev, LE_LINK, &quote))) {
-		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
-			BT_DBG("skb %p len %d", skb, skb->len);
+	tmp = cnt;
+	while (cnt && (chan = hci_chan_sent(hdev, LE_LINK, &quote))) {
+		u32 priority = (skb_peek(&chan->data_q))->priority;
+		while (quote-- && (skb = skb_peek(&chan->data_q))) {
+			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
+					skb->len, skb->priority);
+
+			/* Stop if priority has changed */
+			if (skb->priority < priority)
+				break;
+
+			skb = skb_dequeue(&chan->data_q);
 
 			hci_send_frame(skb);
 			hdev->le_last_tx = jiffies;
 
 			cnt--;
-			conn->sent++;
+			chan->sent++;
+			chan->conn->sent++;
 		}
 	}
+
 	if (hdev->le_pkts)
 		hdev->le_cnt = cnt;
 	else
 		hdev->acl_cnt = cnt;
+
+	if (cnt != tmp)
+		hci_prio_recalculate(hdev, LE_LINK);
 }
 
-static void hci_tx_task(unsigned long arg)
+static void hci_tx_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, tx_work);
 	struct sk_buff *skb;
 
-	read_lock(&hci_task_lock);
-
 	BT_DBG("%s acl %d sco %d le %d", hdev->name, hdev->acl_cnt,
 		hdev->sco_cnt, hdev->le_cnt);
 
@@ -2402,11 +2764,9 @@
 	/* Send next queued raw (unknown type) packet */
 	while ((skb = skb_dequeue(&hdev->raw_q)))
 		hci_send_frame(skb);
-
-	read_unlock(&hci_task_lock);
 }
 
-/* ----- HCI RX task (incoming data proccessing) ----- */
+/* ----- HCI RX task (incoming data processing) ----- */
 
 /* ACL data packet */
 static inline void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2430,16 +2790,19 @@
 	hci_dev_unlock(hdev);
 
 	if (conn) {
-		register struct hci_proto *hp;
+		hci_conn_enter_active_mode(conn, BT_POWER_FORCE_ACTIVE_OFF);
 
-		hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
+		hci_dev_lock(hdev);
+		if (test_bit(HCI_MGMT, &hdev->dev_flags) &&
+		    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+			mgmt_device_connected(hdev, &conn->dst, conn->type,
+					      conn->dst_type, 0, NULL, 0,
+					      conn->dev_class);
+		hci_dev_unlock(hdev);
 
 		/* Send to upper protocol */
-		hp = hci_proto[HCI_PROTO_L2CAP];
-		if (hp && hp->recv_acldata) {
-			hp->recv_acldata(conn, skb, flags);
-			return;
-		}
+		l2cap_recv_acldata(conn, skb, flags);
+		return;
 	} else {
 		BT_ERR("%s ACL packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2468,14 +2831,9 @@
 	hci_dev_unlock(hdev);
 
 	if (conn) {
-		register struct hci_proto *hp;
-
 		/* Send to upper protocol */
-		hp = hci_proto[HCI_PROTO_SCO];
-		if (hp && hp->recv_scodata) {
-			hp->recv_scodata(conn, skb);
-			return;
-		}
+		sco_recv_scodata(conn, skb);
+		return;
 	} else {
 		BT_ERR("%s SCO packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2484,19 +2842,20 @@
 	kfree_skb(skb);
 }
 
-static void hci_rx_task(unsigned long arg)
+static void hci_rx_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, rx_work);
 	struct sk_buff *skb;
 
 	BT_DBG("%s", hdev->name);
 
-	read_lock(&hci_task_lock);
-
 	while ((skb = skb_dequeue(&hdev->rx_q))) {
+		/* Send copy to monitor */
+		hci_send_to_monitor(hdev, skb);
+
 		if (atomic_read(&hdev->promisc)) {
 			/* Send copy to the sockets */
-			hci_send_to_sock(hdev, skb, NULL);
+			hci_send_to_sock(hdev, skb);
 		}
 
 		if (test_bit(HCI_RAW, &hdev->flags)) {
@@ -2517,6 +2876,7 @@
 		/* Process frame */
 		switch (bt_cb(skb)->pkt_type) {
 		case HCI_EVENT_PKT:
+			BT_DBG("%s Event packet", hdev->name);
 			hci_event_packet(hdev, skb);
 			break;
 
@@ -2535,13 +2895,11 @@
 			break;
 		}
 	}
-
-	read_unlock(&hci_task_lock);
 }
 
-static void hci_cmd_task(unsigned long arg)
+static void hci_cmd_work(struct work_struct *work)
 {
-	struct hci_dev *hdev = (struct hci_dev *) arg;
+	struct hci_dev *hdev = container_of(work, struct hci_dev, cmd_work);
 	struct sk_buff *skb;
 
 	BT_DBG("%s cmd %d", hdev->name, atomic_read(&hdev->cmd_cnt));
@@ -2558,14 +2916,44 @@
 		if (hdev->sent_cmd) {
 			atomic_dec(&hdev->cmd_cnt);
 			hci_send_frame(skb);
-			mod_timer(&hdev->cmd_timer,
+			if (test_bit(HCI_RESET, &hdev->flags))
+				del_timer(&hdev->cmd_timer);
+			else
+				mod_timer(&hdev->cmd_timer,
 				  jiffies + msecs_to_jiffies(HCI_CMD_TIMEOUT));
 		} else {
 			skb_queue_head(&hdev->cmd_q, skb);
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 		}
 	}
 }
 
-module_param(enable_smp, bool, 0644);
-MODULE_PARM_DESC(enable_smp, "Enable SMP support (LE only)");
+int hci_do_inquiry(struct hci_dev *hdev, u8 length)
+{
+	/* General inquiry access code (GIAC) */
+	u8 lap[3] = { 0x33, 0x8b, 0x9e };
+	struct hci_cp_inquiry cp;
+
+	BT_DBG("%s", hdev->name);
+
+	if (test_bit(HCI_INQUIRY, &hdev->flags))
+		return -EINPROGRESS;
+
+	inquiry_cache_flush(hdev);
+
+	memset(&cp, 0, sizeof(cp));
+	memcpy(&cp.lap, lap, sizeof(cp.lap));
+	cp.length  = length;
+
+	return hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+}
+
+int hci_cancel_inquiry(struct hci_dev *hdev)
+{
+	BT_DBG("%s", hdev->name);
+
+	if (!test_bit(HCI_INQUIRY, &hdev->flags))
+		return -EPERM;
+
+	return hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
+}
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_event.c flo-ElementalX-5.00-patched/net/bluetooth/hci_event.c
--- flo-ElementalX-5.00/net/bluetooth/hci_event.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_event.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -35,10 +35,8 @@
 #include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -53,11 +51,19 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
+	if (status) {
+		hci_dev_lock(hdev);
+		mgmt_stop_discovery_failed(hdev, status);
+		hci_dev_unlock(hdev);
 		return;
+	}
 
 	clear_bit(HCI_INQUIRY, &hdev->flags);
 
+	hci_dev_lock(hdev);
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+	hci_dev_unlock(hdev);
+
 	hci_req_complete(hdev, HCI_OP_INQUIRY_CANCEL, status);
 
 	hci_conn_check_pending(hdev);
@@ -72,36 +78,9 @@
 	if (status)
 		return;
 
-	clear_bit(HCI_INQUIRY, &hdev->flags);
-
 	hci_conn_check_pending(hdev);
 }
 
-static void hci_cc_link_key_reply(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	struct hci_rp_link_key_reply *rp = (void *) skb->data;
-	struct hci_conn *conn;
-	struct hci_cp_link_key_reply *cp;
-
-	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-	if (rp->status)
-		return;
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_LINK_KEY_REPLY);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn) {
-		hci_conn_hold(conn);
-		memcpy(conn->link_key, cp->link_key, sizeof(conn->link_key));
-		conn->key_type = 5;
-		hci_conn_put(conn);
-	}
-	hci_dev_unlock(hdev);
-}
-
 static void hci_cc_remote_name_req_cancel(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	BT_DBG("%s", hdev->name);
@@ -211,6 +190,11 @@
 	clear_bit(HCI_RESET, &hdev->flags);
 
 	hci_req_complete(hdev, HCI_OP_RESET, status);
+
+	/* Reset all non-persistent flags */
+	hdev->dev_flags &= ~(BIT(HCI_LE_SCAN) | BIT(HCI_PENDING_CLASS));
+
+	hdev->discovery.state = DISCOVERY_STOPPED;
 }
 
 static void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -223,13 +207,17 @@
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LOCAL_NAME);
 	if (!sent)
 		return;
+
 	hci_dev_lock(hdev);
-	if (!status)
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_set_local_name_complete(hdev, sent, status);
+	else if (!status)
 		memcpy(hdev->dev_name, sent, HCI_MAX_NAME_LENGTH);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_set_local_name_complete(hdev->id, sent, status);
 	hci_dev_unlock(hdev);
+
+	hci_req_complete(hdev, HCI_OP_WRITE_LOCAL_NAME, status);
 }
 
 static void hci_cc_read_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -241,7 +229,8 @@
 	if (rp->status)
 		return;
 
-	memcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);
+	if (test_bit(HCI_SETUP, &hdev->dev_flags))
+		memcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);
 }
 
 static void hci_cc_write_auth_enable(struct hci_dev *hdev, struct sk_buff *skb)
@@ -264,6 +253,9 @@
 			clear_bit(HCI_AUTH, &hdev->flags);
 	}
 
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_auth_enable_complete(hdev, status);
+
 	hci_req_complete(hdev, HCI_OP_WRITE_AUTH_ENABLE, status);
 }
 
@@ -292,7 +284,8 @@
 
 static void hci_cc_write_scan_enable(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	__u8 status = *((__u8 *) skb->data);
+	__u8 param, status = *((__u8 *) skb->data);
+	int old_pscan, old_iscan;
 	void *sent;
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
@@ -301,30 +294,40 @@
 	if (!sent)
 		return;
 
-	if (!status) {
-		__u8 param = *((__u8 *) sent);
-		int old_pscan, old_iscan;
-		hci_dev_lock(hdev);
+	param = *((__u8 *) sent);
 
-		old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
-		old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
+	hci_dev_lock(hdev);
 
-		if (param & SCAN_INQUIRY) {
-			set_bit(HCI_ISCAN, &hdev->flags);
-			if (!old_iscan)
-				mgmt_discoverable(hdev->id, 1);
-		} else if (old_iscan)
-			mgmt_discoverable(hdev->id, 0);
-
-		if (param & SCAN_PAGE) {
-			set_bit(HCI_PSCAN, &hdev->flags);
-			if (!old_pscan)
-				mgmt_connectable(hdev->id, 1);
-		} else if (old_pscan)
-			mgmt_connectable(hdev->id, 0);
-		hci_dev_unlock(hdev);
+	if (status != 0) {
+		mgmt_write_scan_failed(hdev, param, status);
+		hdev->discov_timeout = 0;
+		goto done;
 	}
 
+	old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
+	old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
+
+	if (param & SCAN_INQUIRY) {
+		set_bit(HCI_ISCAN, &hdev->flags);
+		if (!old_iscan)
+			mgmt_discoverable(hdev, 1);
+		if (hdev->discov_timeout > 0) {
+			int to = msecs_to_jiffies(hdev->discov_timeout * 1000);
+			queue_delayed_work(hdev->workqueue, &hdev->discov_off,
+									to);
+		}
+	} else if (old_iscan)
+		mgmt_discoverable(hdev, 0);
+
+	if (param & SCAN_PAGE) {
+		set_bit(HCI_PSCAN, &hdev->flags);
+		if (!old_pscan)
+			mgmt_connectable(hdev, 1);
+	} else if (old_pscan)
+		mgmt_connectable(hdev, 0);
+
+done:
+	hci_dev_unlock(hdev);
 	hci_req_complete(hdev, HCI_OP_WRITE_SCAN_ENABLE, status);
 }
 
@@ -350,14 +353,19 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
-		return;
-
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_CLASS_OF_DEV);
 	if (!sent)
 		return;
 
-	memcpy(hdev->dev_class, sent, 3);
+	hci_dev_lock(hdev);
+
+	if (status == 0)
+		memcpy(hdev->dev_class, sent, 3);
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_set_class_of_dev_complete(hdev, sent, status);
+
+	hci_dev_unlock(hdev);
 }
 
 static void hci_cc_read_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
@@ -379,11 +387,8 @@
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
-		tasklet_enable(&hdev->tx_task);
-	}
 }
 
 static void hci_cc_write_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
@@ -410,11 +415,8 @@
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
-		tasklet_enable(&hdev->tx_task);
-	}
 }
 
 static void hci_cc_host_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -426,28 +428,6 @@
 	hci_req_complete(hdev, HCI_OP_HOST_BUFFER_SIZE, status);
 }
 
-static void hci_cc_le_clear_white_list(struct hci_dev *hdev,
-							struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	hci_req_complete(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, status);
-}
-
-static void hci_cc_read_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	struct hci_rp_read_ssp_mode *rp = (void *) skb->data;
-
-	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
-	if (rp->status)
-		return;
-
-	hdev->ssp_mode = rp->mode;
-}
-
 static void hci_cc_write_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	__u8 status = *((__u8 *) skb->data);
@@ -455,14 +435,18 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status)
-		return;
-
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_MODE);
 	if (!sent)
 		return;
 
-	hdev->ssp_mode = *((__u8 *) sent);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_ssp_enable_complete(hdev, *((u8 *) sent), status);
+	else if (!status) {
+		if (*((u8 *) sent))
+			set_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+		else
+			clear_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+	}
 }
 
 static u8 hci_get_inquiry_mode(struct hci_dev *hdev)
@@ -509,16 +493,16 @@
 	 * command otherwise */
 	u8 events[8] = { 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00 };
 
-	BT_DBG("");
+	/* CSR 1.1 dongles does not accept any bitfield so don't try to set
+	 * any event mask for pre 1.2 devices */
+	if (hdev->hci_ver < BLUETOOTH_VER_1_2)
+		return;
 
-	/* Events for 1.2 and newer controllers */
-	if (hdev->lmp_ver > 1) {
-		events[4] |= 0x01; /* Flow Specification Complete */
-		events[4] |= 0x02; /* Inquiry Result with RSSI */
-		events[4] |= 0x04; /* Read Remote Extended Features Complete */
-		events[5] |= 0x08; /* Synchronous Connection Complete */
-		events[5] |= 0x10; /* Synchronous Connection Changed */
-	}
+	events[4] |= 0x01; /* Flow Specification Complete */
+	events[4] |= 0x02; /* Inquiry Result with RSSI */
+	events[4] |= 0x04; /* Read Remote Extended Features Complete */
+	events[5] |= 0x08; /* Synchronous Connection Complete */
+	events[5] |= 0x10; /* Synchronous Connection Changed */
 
 	if (hdev->features[3] & LMP_RSSI_INQ)
 		events[4] |= 0x04; /* Inquiry Result with RSSI */
@@ -559,12 +543,27 @@
 
 static void hci_setup(struct hci_dev *hdev)
 {
-	if (hdev->lmp_ver > 1)
+	if (hdev->dev_type != HCI_BREDR)
+		return;
+
+	hci_setup_event_mask(hdev);
+
+	if (hdev->hci_ver > BLUETOOTH_VER_1_1)
 		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_COMMANDS, 0, NULL);
 
 	if (hdev->features[6] & LMP_SIMPLE_PAIR) {
-		u8 mode = 0x01;
-		hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, sizeof(mode), &mode);
+		if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			u8 mode = 0x01;
+			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE,
+				     sizeof(mode), &mode);
+		} else {
+			struct hci_cp_write_eir cp;
+
+			memset(hdev->eir, 0, sizeof(hdev->eir));
+			memset(&cp, 0, sizeof(cp));
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+		}
 	}
 
 	if (hdev->features[3] & LMP_RSSI_INQ)
@@ -572,6 +571,20 @@
 
 	if (hdev->features[7] & LMP_INQ_TX_PWR)
 		hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER, 0, NULL);
+
+	if (hdev->features[7] & LMP_EXTFEATURES) {
+		struct hci_cp_read_local_ext_features cp;
+
+		cp.page = 0x01;
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, sizeof(cp),
+			     &cp);
+	}
+
+	if (test_bit(HCI_LINK_SECURITY, &hdev->dev_flags)) {
+		u8 enable = 1;
+		hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(enable),
+			     &enable);
+	}
 }
 
 static void hci_cc_read_local_version(struct hci_dev *hdev, struct sk_buff *skb)
@@ -581,7 +594,7 @@
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
 	if (rp->status)
-		return;
+		goto done;
 
 	hdev->hci_ver = rp->hci_ver;
 	hdev->hci_rev = __le16_to_cpu(rp->hci_rev);
@@ -593,8 +606,11 @@
 					hdev->manufacturer,
 					hdev->hci_ver, hdev->hci_rev);
 
-	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags))
+	if (test_bit(HCI_INIT, &hdev->flags))
 		hci_setup(hdev);
+
+done:
+	hci_req_complete(hdev, HCI_OP_READ_LOCAL_VERSION, rp->status);
 }
 
 static void hci_setup_link_policy(struct hci_dev *hdev)
@@ -611,8 +627,8 @@
 		link_policy |= HCI_LP_PARK;
 
 	link_policy = cpu_to_le16(link_policy);
-	hci_send_cmd(hdev, HCI_OP_WRITE_DEF_LINK_POLICY,
-					sizeof(link_policy), &link_policy);
+	hci_send_cmd(hdev, HCI_OP_WRITE_DEF_LINK_POLICY, sizeof(link_policy),
+		     &link_policy);
 }
 
 static void hci_cc_read_local_commands(struct hci_dev *hdev, struct sk_buff *skb)
@@ -644,23 +660,6 @@
 
 	memcpy(hdev->features, rp->features, 8);
 
-	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags)) {
-		if (hdev->features[6] & LMP_SIMPLE_PAIR) {
-			u8 mode = 0x01;
-			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE,
-					sizeof(mode), &mode);
-		}
-
-		if (hdev->features[3] & LMP_RSSI_INQ)
-			hci_setup_inquiry_mode(hdev);
-
-		if (hdev->features[7] & LMP_INQ_TX_PWR)
-			hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER,
-								0, NULL);
-
-		hci_setup_event_mask(hdev);
-	}
-
 	/* Adjust default settings according to features
 	 * supported by device. */
 
@@ -705,8 +704,50 @@
 					hdev->features[6], hdev->features[7]);
 }
 
+static void hci_set_le_support(struct hci_dev *hdev)
+{
+	struct hci_cp_write_le_host_supported cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	if (enable_le && test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+		cp.le = 1;
+		cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+	}
+
+	if (cp.le != !!(hdev->host_features[0] & LMP_HOST_LE))
+		hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(cp),
+			     &cp);
+}
+
+static void hci_cc_read_local_ext_features(struct hci_dev *hdev,
+							struct sk_buff *skb)
+{
+	struct hci_rp_read_local_ext_features *rp = (void *) skb->data;
+
+	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
+	if (rp->status)
+		goto done;
+
+	switch (rp->page) {
+	case 0:
+		memcpy(hdev->features, rp->features, 8);
+		break;
+	case 1:
+		memcpy(hdev->host_features, rp->features, 8);
+		break;
+	}
+
+	if (test_bit(HCI_INIT, &hdev->flags) && hdev->features[4] & LMP_LE)
+		hci_set_le_support(hdev);
+
+done:
+	hci_req_complete(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, rp->status);
+}
+
 static void hci_cc_read_flow_control_mode(struct hci_dev *hdev,
-					struct sk_buff *skb)
+						struct sk_buff *skb)
 {
 	struct hci_rp_read_flow_control_mode *rp = (void *) skb->data;
 
@@ -716,6 +757,8 @@
 		return;
 
 	hdev->flow_ctl_mode = rp->mode;
+
+	hci_req_complete(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, rp->status);
 }
 
 static void hci_cc_read_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -727,20 +770,18 @@
 	if (rp->status)
 		return;
 
-	if (hdev->flow_ctl_mode == HCI_PACKET_BASED_FLOW_CTL_MODE) {
-		hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
-		hdev->sco_mtu  = rp->sco_mtu;
-		hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
-		hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
-		hdev->acl_cnt = hdev->acl_pkts;
-		hdev->sco_cnt = hdev->sco_pkts;
-	}
+	hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
+	hdev->sco_mtu  = rp->sco_mtu;
+	hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
+	hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
 
 	if (test_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks)) {
 		hdev->sco_mtu  = 64;
 		hdev->sco_pkts = 8;
 	}
 
+	hdev->acl_cnt = hdev->acl_pkts;
+	hdev->sco_cnt = hdev->sco_pkts;
 
 	BT_DBG("%s acl mtu %d:%d sco mtu %d:%d", hdev->name,
 					hdev->acl_mtu, hdev->acl_pkts,
@@ -759,17 +800,8 @@
 	hci_req_complete(hdev, HCI_OP_READ_BD_ADDR, rp->status);
 }
 
-static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
-}
-
 static void hci_cc_read_data_block_size(struct hci_dev *hdev,
-					struct sk_buff *skb)
+							struct sk_buff *skb)
 {
 	struct hci_rp_read_data_block_size *rp = (void *) skb->data;
 
@@ -778,23 +810,29 @@
 	if (rp->status)
 		return;
 
-	if (hdev->flow_ctl_mode == HCI_BLOCK_BASED_FLOW_CTL_MODE) {
-		hdev->acl_mtu  = __le16_to_cpu(rp->max_acl_len);
-		hdev->sco_mtu = 0;
-		hdev->data_block_len = __le16_to_cpu(rp->data_block_len);
-		/* acl_pkts indicates the number of blocks */
-		hdev->acl_pkts = __le16_to_cpu(rp->num_blocks);
-		hdev->sco_pkts = 0;
-		hdev->acl_cnt = hdev->acl_pkts;
-		hdev->sco_cnt = 0;
-	}
+	hdev->block_mtu = __le16_to_cpu(rp->max_acl_len);
+	hdev->block_len = __le16_to_cpu(rp->block_len);
+	hdev->num_blocks = __le16_to_cpu(rp->num_blocks);
+
+	hdev->block_cnt = hdev->num_blocks;
+
+	BT_DBG("%s blk mtu %d cnt %d len %d", hdev->name, hdev->block_mtu,
+					hdev->block_cnt, hdev->block_len);
+
+	hci_req_complete(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, rp->status);
+}
+
+static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	BT_DBG("%s acl mtu %d:%d, data block len %d", hdev->name,
-			hdev->acl_mtu, hdev->acl_cnt, hdev->data_block_len);
+	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
 }
 
 static void hci_cc_read_local_amp_info(struct hci_dev *hdev,
-				struct sk_buff *skb)
+		struct sk_buff *skb)
 {
 	struct hci_rp_read_local_amp_info *rp = (void *) skb->data;
 
@@ -872,10 +910,11 @@
 	struct hci_conn *conn;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_reply_complete(hdev->id, &rp->bdaddr, rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_pin_code_reply_complete(hdev, &rp->bdaddr, rp->status);
 
 	if (rp->status != 0)
 		goto unlock;
@@ -887,6 +926,7 @@
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
 	if (conn)
 		conn->pin_length = cp->pin_len;
+
 unlock:
 	hci_dev_unlock(hdev);
 }
@@ -896,13 +936,16 @@
 	struct hci_rp_pin_code_neg_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_neg_reply_complete(hdev->id, &rp->bdaddr,
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_pin_code_neg_reply_complete(hdev, &rp->bdaddr,
 								rp->status);
+
 	hci_dev_unlock(hdev);
 }
+
 static void hci_cc_le_read_buffer_size(struct hci_dev *hdev,
 				       struct sk_buff *skb)
 {
@@ -923,63 +966,66 @@
 	hci_req_complete(hdev, HCI_OP_LE_READ_BUFFER_SIZE, rp->status);
 }
 
-static void hci_cc_le_read_white_list_size(struct hci_dev *hdev,
-				       struct sk_buff *skb)
+static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_rp_le_read_white_list_size *rp = (void *) skb->data;
+	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	if (rp->status)
-		return;
-
-	hdev->le_white_list_size = rp->size;
+	hci_dev_lock(hdev);
 
-	BT_DBG("%s le white list %d", hdev->name, hdev->le_white_list_size);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_confirm_reply_complete(hdev, &rp->bdaddr, ACL_LINK, 0,
+						 rp->status);
 
-	hci_req_complete(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, rp->status);
+	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_reply_complete(hdev->id, &rp->bdaddr,
-								rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_confirm_neg_reply_complete(hdev, &rp->bdaddr,
+						     ACL_LINK, 0, rp->status);
+
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static void hci_cc_user_passkey_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_neg_reply_complete(hdev->id, &rp->bdaddr,
-								rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_reply_complete(hdev, &rp->bdaddr, ACL_LINK,
+						 0, rp->status);
+
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_read_rssi(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_user_passkey_neg_reply(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
-	struct hci_conn *conn;
-	struct hci_rp_read_rssi *rp = (void *) skb->data;
+	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	BT_DBG("%s rssi : %d handle : %d", hdev->name, rp->rssi, rp->handle);
+	hci_dev_lock(hdev);
 
-	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));
-	if (conn)
-		mgmt_read_rssi_complete(hdev->id, rp->rssi, &conn->dst,
-			__le16_to_cpu(rp->handle), rp->status);
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_neg_reply_complete(hdev, &rp->bdaddr,
+						     ACL_LINK, 0, rp->status);
+
+	hci_dev_unlock(hdev);
 }
 
 static void hci_cc_read_local_oob_data_reply(struct hci_dev *hdev,
@@ -988,13 +1034,86 @@
 	struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-	hci_dev_lock(hdev);
 
-	mgmt_read_local_oob_data_reply_complete(hdev->id, rp->hash,
+	hci_dev_lock(hdev);
+	mgmt_read_local_oob_data_reply_complete(hdev, rp->hash,
 						rp->randomizer, rp->status);
 	hci_dev_unlock(hdev);
 }
 
+static void hci_cc_le_set_scan_param(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	hci_req_complete(hdev, HCI_OP_LE_SET_SCAN_PARAM, status);
+
+	if (status) {
+		hci_dev_lock(hdev);
+		mgmt_start_discovery_failed(hdev, status);
+		hci_dev_unlock(hdev);
+		return;
+	}
+}
+
+static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_cp_le_set_scan_enable *cp;
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
+	if (!cp)
+		return;
+
+	switch (cp->enable) {
+	case LE_SCANNING_ENABLED:
+		hci_req_complete(hdev, HCI_OP_LE_SET_SCAN_ENABLE, status);
+
+		if (status) {
+			hci_dev_lock(hdev);
+			mgmt_start_discovery_failed(hdev, status);
+			hci_dev_unlock(hdev);
+			return;
+		}
+
+		set_bit(HCI_LE_SCAN, &hdev->dev_flags);
+
+		cancel_delayed_work_sync(&hdev->adv_work);
+
+		hci_dev_lock(hdev);
+		hci_adv_entries_clear(hdev);
+		hci_discovery_set_state(hdev, DISCOVERY_FINDING);
+		hci_dev_unlock(hdev);
+		break;
+
+	case LE_SCANNING_DISABLED:
+		if (status)
+			return;
+
+		clear_bit(HCI_LE_SCAN, &hdev->dev_flags);
+
+		schedule_delayed_work(&hdev->adv_work, ADV_CLEAR_TIMEOUT);
+
+		if (hdev->discovery.type == DISCOV_TYPE_INTERLEAVED) {
+			mgmt_interleaved_discovery(hdev);
+		} else {
+			hci_dev_lock(hdev);
+			hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+			hci_dev_unlock(hdev);
+		}
+
+		break;
+
+	default:
+		BT_ERR("Used reserved LE_Scan_Enable param %d", cp->enable);
+		break;
+	}
+}
+
 static void hci_cc_le_ltk_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_le_ltk_reply *rp = (void *) skb->data;
@@ -1019,26 +1138,30 @@
 	hci_req_complete(hdev, HCI_OP_LE_LTK_NEG_REPLY, rp->status);
 }
 
-static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
-					struct sk_buff *skb)
+static inline void hci_cc_write_le_host_supported(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
-	void *sent;
-	__u8 param_scan_enable;
+	struct hci_cp_write_le_host_supported *sent;
 	__u8 status = *((__u8 *) skb->data);
 
-	if (status)
-		return;
+	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
+	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED);
 	if (!sent)
 		return;
 
-	param_scan_enable = *((__u8 *) sent);
-	if (param_scan_enable == 0x01) {
-		del_timer(&hdev->adv_timer);
-	} else if (param_scan_enable == 0x00) {
-		mod_timer(&hdev->adv_timer, jiffies + ADV_CLEAR_TIMEOUT);
+	if (!status) {
+		if (sent->le)
+			hdev->host_features[0] |= LMP_HOST_LE;
+		else
+			hdev->host_features[0] &= ~LMP_HOST_LE;
 	}
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags) &&
+					!test_bit(HCI_INIT, &hdev->flags))
+		mgmt_le_enable_complete(hdev, sent->le, status);
+
+	hci_req_complete(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, status);
 }
 
 static inline void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)
@@ -1047,15 +1170,19 @@
 
 	if (status) {
 		hci_req_complete(hdev, HCI_OP_INQUIRY, status);
-
 		hci_conn_check_pending(hdev);
-	} else {
-		set_bit(HCI_INQUIRY, &hdev->flags);
 		hci_dev_lock(hdev);
-		if (test_bit(HCI_MGMT, &hdev->flags))
-			mgmt_inquiry_started(hdev->id);
+		if (test_bit(HCI_MGMT, &hdev->dev_flags))
+			mgmt_start_discovery_failed(hdev, status);
 		hci_dev_unlock(hdev);
+		return;
 	}
+
+	set_bit(HCI_INQUIRY, &hdev->flags);
+
+	hci_dev_lock(hdev);
+	hci_discovery_set_state(hdev, DISCOVERY_FINDING);
+	hci_dev_unlock(hdev);
 }
 
 static inline void hci_cs_create_conn(struct hci_dev *hdev, __u8 status)
@@ -1086,9 +1213,9 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_conn_add(hdev, ACL_LINK, 0, &cp->bdaddr);
+			conn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr);
 			if (conn) {
-				conn->out = 1;
+				conn->out = true;
 				conn->link_mode |= HCI_LM_MASTER;
 			} else
 				BT_ERR("No memory for new connection");
@@ -1140,6 +1267,9 @@
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
+	if (!status)
+		return;
+
 	cp = hci_sent_cmd_data(hdev, HCI_OP_AUTH_REQUESTED);
 	if (!cp)
 		return;
@@ -1148,27 +1278,10 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		if (status) {
-			mgmt_auth_failed(hdev->id, &conn->dst, status);
-			clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
-
-			if (conn->state == BT_CONFIG) {
-				conn->state = BT_CONNECTED;
-				hci_proto_connect_cfm(conn, status);
-				hci_conn_put(conn);
-			} else {
-				hci_auth_cfm(conn, status);
-				hci_conn_hold(conn);
-				conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-				hci_conn_put(conn);
-			}
-
-			if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
-				hci_encrypt_cfm(conn, status, 0x00);
-			}
+		if (conn->state == BT_CONFIG) {
+			hci_proto_connect_cfm(conn, status);
+			hci_conn_put(conn);
 		}
-		conn->auth_initiator = 1;
 	}
 
 	hci_dev_unlock(hdev);
@@ -1211,15 +1324,93 @@
 		return 0;
 
 	/* Only request authentication for SSP connections or non-SSP
-	 * devices with sec_level >= BT_SECURITY_MEDIUM*/
-	 BT_DBG("Pending sec level is %d", conn->pending_sec_level);
-	if (!(hdev->ssp_mode > 0 && conn->ssp_mode > 0) &&
-				conn->pending_sec_level < BT_SECURITY_MEDIUM)
+	 * devices with sec_level HIGH or if MITM protection is requested */
+	if (!hci_conn_ssp_enabled(conn) &&
+				conn->pending_sec_level != BT_SECURITY_HIGH &&
+				!(conn->auth_type & 0x01))
 		return 0;
 
 	return 1;
 }
 
+static inline int hci_resolve_name(struct hci_dev *hdev,
+				   struct inquiry_entry *e)
+{
+	struct hci_cp_remote_name_req cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	bacpy(&cp.bdaddr, &e->data.bdaddr);
+	cp.pscan_rep_mode = e->data.pscan_rep_mode;
+	cp.pscan_mode = e->data.pscan_mode;
+	cp.clock_offset = e->data.clock_offset;
+
+	return hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
+}
+
+static bool hci_resolve_next_name(struct hci_dev *hdev)
+{
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	if (list_empty(&discov->resolve))
+		return false;
+
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);
+	if (!e)
+		return false;
+
+	if (hci_resolve_name(hdev, e) == 0) {
+		e->name_state = NAME_PENDING;
+		return true;
+	}
+
+	return false;
+}
+
+static void hci_check_pending_name(struct hci_dev *hdev, struct hci_conn *conn,
+				   bdaddr_t *bdaddr, u8 *name, u8 name_len)
+{
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
+
+	if (conn && !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, bdaddr, ACL_LINK, 0x00, 0, name,
+				      name_len, conn->dev_class);
+
+	if (discov->state == DISCOVERY_STOPPED)
+		return;
+
+	if (discov->state == DISCOVERY_STOPPING)
+		goto discov_complete;
+
+	if (discov->state != DISCOVERY_RESOLVING)
+		return;
+
+	e = hci_inquiry_cache_lookup_resolve(hdev, bdaddr, NAME_PENDING);
+	/* If the device was not found in a list of found devices names of which
+	 * are pending. there is no need to continue resolving a next name as it
+	 * will be done upon receiving another Remote Name Request Complete
+	 * Event */
+	if (!e)
+		return;
+
+	list_del(&e->list);
+	if (name) {
+		e->name_state = NAME_KNOWN;
+		mgmt_remote_name(hdev, bdaddr, ACL_LINK, 0x00,
+				 e->data.rssi, name, name_len);
+	} else {
+		e->name_state = NAME_NOT_KNOWN;
+	}
+
+	if (hci_resolve_next_name(hdev))
+		return;
+
+discov_complete:
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+}
+
 static void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)
 {
 	struct hci_cp_remote_name_req *cp;
@@ -1239,12 +1430,23 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		hci_check_pending_name(hdev, conn, &cp->bdaddr, NULL, 0);
+
+	if (!conn)
+		goto unlock;
+
+	if (!hci_outgoing_auth_needed(hdev, conn))
+		goto unlock;
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1355,9 +1557,9 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend);
+		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, status);
 	}
 
@@ -1382,20 +1584,41 @@
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend);
+		clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, status);
 	}
 
 	hci_dev_unlock(hdev);
 }
 
+static void hci_cs_disconnect(struct hci_dev *hdev, u8 status)
+{
+	struct hci_cp_disconnect *cp;
+	struct hci_conn *conn;
+
+	if (!status)
+		return;
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONNECT);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
+	if (conn)
+		mgmt_disconnect_failed(hdev, &conn->dst, conn->type,
+				       conn->dst_type, status);
+
+	hci_dev_unlock(hdev);
+}
+
 static void hci_cs_le_create_conn(struct hci_dev *hdev, __u8 status)
 {
 	struct hci_cp_le_create_conn *cp;
 	struct hci_conn *conn;
-	unsigned long exp = msecs_to_jiffies(5000);
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
@@ -1418,176 +1641,62 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_le_conn_add(hdev, &cp->peer_addr,
-						cp->peer_addr_type);
-			if (conn)
-				conn->out = 1;
-			else
+			conn = hci_conn_add(hdev, LE_LINK, &cp->peer_addr);
+			if (conn) {
+				conn->dst_type = cp->peer_addr_type;
+				conn->out = true;
+			} else {
 				BT_ERR("No memory for new connection");
-		} else
-			exp = msecs_to_jiffies(conn->conn_timeout * 1000);
-
-		if (conn && exp)
-			mod_timer(&conn->disc_timer, jiffies + exp);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_accept_logical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_create_logical_link *ap;
-	struct hci_chan *chan;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	ap = hci_sent_cmd_data(hdev, HCI_OP_ACCEPT_LOGICAL_LINK);
-	if (!ap)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, ap->phy_handle);
-
-	BT_DBG("%s chan %p", hdev->name, chan);
-
-	if (status) {
-		if (chan && chan->state == BT_CONNECT) {
-			chan->state = BT_CLOSED;
-			hci_proto_create_cfm(chan, status);
+			}
 		}
-	} else if (chan) {
-		chan->state = BT_CONNECT2;
 	}
 
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cs_create_logical_link(struct hci_dev *hdev, __u8 status)
+static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
 {
-	struct hci_cp_create_logical_link *cp;
-	struct hci_chan *chan;
-
 	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_LOGICAL_LINK);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, cp->phy_handle);
-
-	BT_DBG("%s chan %p", hdev->name, chan);
-
-	if (status) {
-		if (chan && chan->state == BT_CONNECT) {
-			chan->state = BT_CLOSED;
-			hci_proto_create_cfm(chan, status);
-		}
-	} else if (chan)
-			chan->state = BT_CONNECT2;
-
-	hci_dev_unlock(hdev);
 }
 
-static void hci_cs_flow_spec_modify(struct hci_dev *hdev, __u8 status)
+static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_cp_flow_spec_modify *cp;
-	struct hci_chan *chan;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_FLOW_SPEC_MODIFY);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
+	__u8 status = *((__u8 *) skb->data);
+	struct discovery_state *discov = &hdev->discovery;
+	struct inquiry_entry *e;
 
-	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
-	if (chan) {
-		if (status)
-			hci_proto_modify_cfm(chan, status);
-		else {
-			chan->tx_fs = cp->tx_fs;
-			chan->rx_fs = cp->rx_fs;
-		}
-	}
+	BT_DBG("%s status %d", hdev->name, status);
 
-	hci_dev_unlock(hdev);
-}
+	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
 
-static void hci_cs_disconn_logical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_disconn_logical_link *cp;
-	struct hci_chan *chan;
+	hci_conn_check_pending(hdev);
 
-	if (!status)
+	if (!test_and_clear_bit(HCI_INQUIRY, &hdev->flags))
 		return;
 
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_LOGICAL_LINK);
-	if (!cp)
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		return;
 
 	hci_dev_lock(hdev);
 
-	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
-	if (chan)
-		hci_chan_del(chan);
-
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_disconn_physical_link(struct hci_dev *hdev, __u8 status)
-{
-	struct hci_cp_disconn_phys_link *cp;
-	struct hci_conn *conn;
-
-	if (!status)
-		return;
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_PHYS_LINK);
-	if (!cp)
-		return;
-
-	hci_dev_lock(hdev);
+	if (discov->state != DISCOVERY_FINDING)
+		goto unlock;
 
-	conn = hci_conn_hash_lookup_handle(hdev, cp->phy_handle);
-	if (conn) {
-		conn->state = BT_CLOSED;
-		hci_conn_del(conn);
+	if (list_empty(&discov->resolve)) {
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+		goto unlock;
 	}
 
-	hci_dev_unlock(hdev);
-}
-
-static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
-{
-	BT_DBG("%s status 0x%x", hdev->name, status);
-}
-
-static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status %d", hdev->name, status);
-
-	if (!hdev->disco_state)
-		clear_bit(HCI_INQUIRY, &hdev->flags);
-
-	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
-	hci_dev_lock(hdev);
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);
+	if (e && hci_resolve_name(hdev, e) == 0) {
+		e->name_state = NAME_PENDING;
+		hci_discovery_set_state(hdev, DISCOVERY_RESOLVING);
+	} else {
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+	}
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_inquiry_complete_evt(hdev->id, status);
+unlock:
 	hci_dev_unlock(hdev);
-
-	if (!lmp_le_capable(hdev))
-		hci_conn_check_pending(hdev);
 }
 
 static inline void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -1604,6 +1713,8 @@
 	hci_dev_lock(hdev);
 
 	for (; num_rsp; num_rsp--, info++) {
+		bool name_known, ssp;
+
 		bacpy(&data.bdaddr, &info->bdaddr);
 		data.pscan_rep_mode	= info->pscan_rep_mode;
 		data.pscan_period_mode	= info->pscan_period_mode;
@@ -1612,9 +1723,11 @@
 		data.clock_offset	= info->clock_offset;
 		data.rssi		= 0x00;
 		data.ssp_mode		= 0x00;
-		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-					info->dev_class, 0, 0, NULL);
+
+		name_known = hci_inquiry_cache_update(hdev, &data, false, &ssp);
+		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+				  info->dev_class, 0, !name_known, ssp, NULL,
+				  0);
 	}
 
 	hci_dev_unlock(hdev);
@@ -1647,12 +1760,12 @@
 		if (conn->type == ACL_LINK) {
 			conn->state = BT_CONFIG;
 			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-			mgmt_connected(hdev->id, &ev->bdaddr, 0);
-		} else if (conn->type == LE_LINK) {
-			conn->state = BT_CONNECTED;
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-			mgmt_connected(hdev->id, &ev->bdaddr, 1);
+
+			if (!conn->out && !hci_conn_ssp_enabled(conn) &&
+			    !hci_find_link_key(hdev, &ev->bdaddr))
+				conn->disc_timeout = HCI_PAIRING_TIMEOUT;
+			else
+				conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 		} else
 			conn->state = BT_CONNECTED;
 
@@ -1665,28 +1778,27 @@
 		if (test_bit(HCI_ENCRYPT, &hdev->flags))
 			conn->link_mode |= HCI_LM_ENCRYPT;
 
-		/* Get remote version */
+		/* Get remote features */
 		if (conn->type == ACL_LINK) {
-			struct hci_cp_read_remote_version cp;
+			struct hci_cp_read_remote_features cp;
 			cp.handle = ev->handle;
-			hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET,
-				sizeof(cp), &cp);
-			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_VERSION,
-				sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
+				     sizeof(cp), &cp);
 		}
 
 		/* Set packet type for incoming connection */
-		if (!conn->out && hdev->hci_ver < 3) {
+		if (!conn->out && hdev->hci_ver < BLUETOOTH_VER_2_0) {
 			struct hci_cp_change_conn_ptype cp;
 			cp.handle = ev->handle;
 			cp.pkt_type = cpu_to_le16(conn->pkt_type);
-			hci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE,
-							sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE, sizeof(cp),
+				     &cp);
 		}
 	} else {
 		conn->state = BT_CLOSED;
-		if (conn->type == ACL_LINK || conn->type == LE_LINK)
-			mgmt_connect_failed(hdev->id, &ev->bdaddr, ev->status);
+		if (conn->type == ACL_LINK)
+			mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
+					    conn->dst_type, ev->status);
 	}
 
 	if (conn->type == ACL_LINK)
@@ -1704,15 +1816,6 @@
 	hci_conn_check_pending(hdev);
 }
 
-static inline bool is_sco_active(struct hci_dev *hdev)
-{
-	if (hci_conn_hash_lookup_state(hdev, SCO_LINK, BT_CONNECTED) ||
-			(hci_conn_hash_lookup_state(hdev, ESCO_LINK,
-						    BT_CONNECTED)))
-		return true;
-	return false;
-}
-
 static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_conn_request *ev = (void *) skb->data;
@@ -1737,8 +1840,7 @@
 
 		conn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);
 		if (!conn) {
-			/* pkt_type not yet used for incoming connections */
-			conn = hci_conn_add(hdev, ev->link_type, 0, &ev->bdaddr);
+			conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr);
 			if (!conn) {
 				BT_ERR("No memory for new connection");
 				hci_dev_unlock(hdev);
@@ -1747,8 +1849,6 @@
 		}
 
 		memcpy(conn->dev_class, ev->dev_class, 3);
-		/* For incoming connection update remote class to userspace */
-		mgmt_remote_class(hdev->id, &ev->bdaddr, ev->dev_class);
 		conn->state = BT_CONNECT;
 
 		hci_dev_unlock(hdev);
@@ -1758,14 +1858,13 @@
 
 			bacpy(&cp.bdaddr, &ev->bdaddr);
 
-			if (lmp_rswitch_capable(hdev) && ((mask & HCI_LM_MASTER)
-						|| is_sco_active(hdev)))
+			if (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))
 				cp.role = 0x00; /* Become master */
 			else
 				cp.role = 0x01; /* Remain slave */
 
-			hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ,
-							sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp),
+				     &cp);
 		} else {
 			struct hci_cp_accept_sync_conn_req cp;
 
@@ -1774,19 +1873,19 @@
 
 			cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 			cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-			cp.max_latency    = cpu_to_le16(0x000A);
+			cp.max_latency    = cpu_to_le16(0xffff);
 			cp.content_format = cpu_to_le16(hdev->voice_setting);
-			cp.retrans_effort = 0x01;
+			cp.retrans_effort = 0xff;
 
 			hci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,
-							sizeof(cp), &cp);
+				     sizeof(cp), &cp);
 		}
 	} else {
 		/* Connection rejected */
 		struct hci_cp_reject_conn_req cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = 0x0f;
+		cp.reason = HCI_ERROR_REJ_BAD_ADDR;
 		hci_send_cmd(hdev, HCI_OP_REJECT_CONN_REQ, sizeof(cp), &cp);
 	}
 }
@@ -1796,14 +1895,7 @@
 	struct hci_ev_disconn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
 
-	BT_DBG("%s status %d reason %d", hdev->name, ev->status, ev->reason);
-
-	if (ev->status) {
-		hci_dev_lock(hdev);
-		mgmt_disconnect_failed(hdev->id);
-		hci_dev_unlock(hdev);
-		return;
-	}
+	BT_DBG("%s status %d", hdev->name, ev->status);
 
 	hci_dev_lock(hdev);
 
@@ -1811,16 +1903,25 @@
 	if (!conn)
 		goto unlock;
 
-	conn->state = BT_CLOSED;
-
-	if (conn->type == ACL_LINK || conn->type == LE_LINK)
-		mgmt_disconnected(hdev->id, &conn->dst, ev->reason);
+	if (ev->status == 0)
+		conn->state = BT_CLOSED;
 
-	if (conn->type == LE_LINK)
-		del_timer(&conn->smp_timer);
+	if (test_and_clear_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags) &&
+			(conn->type == ACL_LINK || conn->type == LE_LINK)) {
+		if (ev->status != 0)
+			mgmt_disconnect_failed(hdev, &conn->dst, conn->type,
+						conn->dst_type, ev->status);
+		else
+			mgmt_device_disconnected(hdev, &conn->dst, conn->type,
+						 conn->dst_type);
+	}
 
-	hci_proto_disconn_cfm(conn, ev->reason, 0);
-	hci_conn_del(conn);
+	if (ev->status == 0) {
+		if (conn->type == ACL_LINK && conn->flush_key)
+			hci_remove_link_key(hdev, &conn->dst);
+		hci_proto_disconn_cfm(conn, ev->reason);
+		hci_conn_del(conn);
+	}
 
 unlock:
 	hci_dev_unlock(hdev);
@@ -1836,82 +1937,59 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
-	if (conn) {
-		if (ev->status == 0x06 && hdev->ssp_mode > 0 &&
-							conn->ssp_mode > 0) {
-			struct hci_cp_auth_requested cp;
-			hci_remove_link_key(hdev, &conn->dst);
-			cp.handle = cpu_to_le16(conn->handle);
-			hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
-							sizeof(cp), &cp);
-			hci_dev_unlock(hdev);
-			BT_INFO("Pin or key missing");
-			return;
-		}
+	if (!conn)
+		goto unlock;
 
-		if (!ev->status) {
+	if (!ev->status) {
+		if (!hci_conn_ssp_enabled(conn) &&
+				test_bit(HCI_CONN_REAUTH_PEND, &conn->flags)) {
+			BT_INFO("re-auth of legacy device is not possible.");
+		} else {
 			conn->link_mode |= HCI_LM_AUTH;
 			conn->sec_level = conn->pending_sec_level;
-		} else {
-			mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
-			conn->sec_level = BT_SECURITY_LOW;
 		}
+	} else {
+		mgmt_auth_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+				 ev->status);
+	}
 
-		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
+	clear_bit(HCI_CONN_AUTH_PEND, &conn->flags);
+	clear_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 
-		if (conn->state == BT_CONFIG) {
-			if (!ev->status && hdev->ssp_mode > 0 &&
-							conn->ssp_mode > 0) {
-				struct hci_cp_set_conn_encrypt cp;
-				cp.handle  = ev->handle;
-				cp.encrypt = 0x01;
-				hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT,
-							sizeof(cp), &cp);
-			} else {
-				conn->state = BT_CONNECTED;
-				hci_proto_connect_cfm(conn, ev->status);
-				hci_conn_put(conn);
-			}
+	if (conn->state == BT_CONFIG) {
+		if (!ev->status && hci_conn_ssp_enabled(conn)) {
+			struct hci_cp_set_conn_encrypt cp;
+			cp.handle  = ev->handle;
+			cp.encrypt = 0x01;
+			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
 		} else {
-			hci_auth_cfm(conn, ev->status);
-
-			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+			conn->state = BT_CONNECTED;
+			hci_proto_connect_cfm(conn, ev->status);
 			hci_conn_put(conn);
 		}
+	} else {
+		hci_auth_cfm(conn, ev->status);
 
-		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-			if (!ev->status) {
-				if (conn->link_mode & HCI_LM_ENCRYPT) {
-					/* Encryption implies authentication */
-					conn->link_mode |= HCI_LM_AUTH;
-					conn->link_mode |= HCI_LM_ENCRYPT;
-					conn->sec_level =
-						conn->pending_sec_level;
-					clear_bit(HCI_CONN_ENCRYPT_PEND,
-							&conn->pend);
-					hci_encrypt_cfm(conn, ev->status, 1);
-
-					if (test_bit(HCI_MGMT, &hdev->flags))
-						mgmt_encrypt_change(hdev->id,
-							&conn->dst,
-							ev->status);
-
-				} else {
-					struct hci_cp_set_conn_encrypt cp;
-					cp.handle  = ev->handle;
-					cp.encrypt = 0x01;
-					hci_send_cmd(hdev,
-						HCI_OP_SET_CONN_ENCRYPT,
-						sizeof(cp), &cp);
-				}
-			} else {
-				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
-				hci_encrypt_cfm(conn, ev->status, 0x00);
-			}
+		hci_conn_hold(conn);
+		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+		hci_conn_put(conn);
+	}
+
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
+		if (!ev->status) {
+			struct hci_cp_set_conn_encrypt cp;
+			cp.handle  = ev->handle;
+			cp.encrypt = 0x01;
+			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
+		} else {
+			clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
+			hci_encrypt_cfm(conn, ev->status, 0x00);
 		}
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1926,16 +2004,31 @@
 
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_remote_name(hdev->id, &ev->bdaddr, ev->status, ev->name);
-
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
+
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		goto check_auth;
+
+	if (ev->status == 0)
+		hci_check_pending_name(hdev, conn, &ev->bdaddr, ev->name,
+				       strnlen(ev->name, HCI_MAX_NAME_LENGTH));
+	else
+		hci_check_pending_name(hdev, conn, &ev->bdaddr, NULL, 0);
+
+check_auth:
+	if (!conn)
+		goto unlock;
+
+	if (!hci_outgoing_auth_needed(hdev, conn))
+		goto unlock;
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1960,7 +2053,13 @@
 				conn->link_mode &= ~HCI_LM_ENCRYPT;
 		}
 
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
+
+		if (ev->status && conn->state == BT_CONNECTED) {
+			hci_acl_disconn(conn, 0x13);
+			hci_conn_put(conn);
+			goto unlock;
+		}
 
 		if (conn->state == BT_CONFIG) {
 			if (!ev->status)
@@ -1968,30 +2067,11 @@
 
 			hci_proto_connect_cfm(conn, ev->status);
 			hci_conn_put(conn);
-		} else {
-			/*
-			* If the remote device does not support
-			* Pause Encryption, usually during the
-			* roleSwitch we see Encryption disable
-			* for short duration. Allow remote device
-			* to disable encryption
-			* for short duration in this case.
-			*/
-			if ((ev->encrypt == 0) && (ev->status == 0) &&
-				((conn->features[5] & LMP_PAUSE_ENC) == 0)) {
-				mod_timer(&conn->encrypt_pause_timer,
-					jiffies + msecs_to_jiffies(500));
-				BT_INFO("enc pause timer, enc_pend_flag set");
-			} else {
-				del_timer(&conn->encrypt_pause_timer);
-				hci_encrypt_cfm(conn, ev->status, ev->encrypt);
-			}
-		}
-
-		if (test_bit(HCI_MGMT, &hdev->flags))
-			mgmt_encrypt_change(hdev->id, &conn->dst, ev->status);
+		} else
+			hci_encrypt_cfm(conn, ev->status, ev->encrypt);
 	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -2009,7 +2089,7 @@
 		if (!ev->status)
 			conn->link_mode |= HCI_LM_SECURE;
 
-		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
+		clear_bit(HCI_CONN_AUTH_PEND, &conn->flags);
 
 		hci_key_change_cfm(conn, ev->status);
 	}
@@ -2030,10 +2110,8 @@
 	if (!conn)
 		goto unlock;
 
-	if (!ev->status) {
+	if (!ev->status)
 		memcpy(conn->features, ev->features, 8);
-		mgmt_remote_features(hdev->id, &conn->dst, ev->features);
-	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
@@ -2045,18 +2123,18 @@
 		hci_send_cmd(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES,
 							sizeof(cp), &cp);
 		goto unlock;
-	} else  if (!(lmp_ssp_capable(conn)) && conn->auth_initiator &&
-		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH)) {
-		conn->pending_sec_level = BT_SECURITY_MEDIUM;
 	}
 
-	if (!ev->status) {
+	if (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {
 		struct hci_cp_remote_name_req cp;
 		memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
-	}
+	} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &conn->dst, conn->type,
+				      conn->dst_type, 0, NULL, 0,
+				      conn->dev_class);
 
 	if (!hci_outgoing_auth_needed(hdev, conn)) {
 		conn->state = BT_CONNECTED;
@@ -2070,24 +2148,7 @@
 
 static inline void hci_remote_version_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_ev_remote_version *ev = (void *) skb->data;
-	struct hci_cp_read_remote_features cp;
-	struct hci_conn *conn;
-	BT_DBG("%s status %d", hdev->name, ev->status);
-
-	hci_dev_lock(hdev);
-	cp.handle = ev->handle;
-	hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
-				sizeof(cp), &cp);
-
-	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
-	if (!conn)
-		goto unlock;
-	if (!ev->status)
-		mgmt_remote_version(hdev->id, &conn->dst, ev->lmp_ver,
-				ev->manufacturer, ev->lmp_subver);
-unlock:
-	hci_dev_unlock(hdev);
+	BT_DBG("%s", hdev->name);
 }
 
 static inline void hci_qos_setup_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2104,9 +2165,6 @@
 
 	opcode = __le16_to_cpu(ev->opcode);
 
-	if (test_bit(HCI_RESET, &hdev->flags) && (opcode != HCI_OP_RESET))
-		return;
-
 	switch (opcode) {
 	case HCI_OP_INQUIRY_CANCEL:
 		hci_cc_inquiry_cancel(hdev, skb);
@@ -2116,10 +2174,6 @@
 		hci_cc_exit_periodic_inq(hdev, skb);
 		break;
 
-	case HCI_OP_LINK_KEY_REPLY:
-		hci_cc_link_key_reply(hdev, skb);
-		break;
-
 	case HCI_OP_REMOTE_NAME_REQ_CANCEL:
 		hci_cc_remote_name_req_cancel(hdev, skb);
 		break;
@@ -2188,10 +2242,6 @@
 		hci_cc_host_buffer_size(hdev, skb);
 		break;
 
-	case HCI_OP_READ_SSP_MODE:
-		hci_cc_read_ssp_mode(hdev, skb);
-		break;
-
 	case HCI_OP_WRITE_SSP_MODE:
 		hci_cc_write_ssp_mode(hdev, skb);
 		break;
@@ -2208,6 +2258,10 @@
 		hci_cc_read_local_features(hdev, skb);
 		break;
 
+	case HCI_OP_READ_LOCAL_EXT_FEATURES:
+		hci_cc_read_local_ext_features(hdev, skb);
+		break;
+
 	case HCI_OP_READ_BUFFER_SIZE:
 		hci_cc_read_buffer_size(hdev, skb);
 		break;
@@ -2216,6 +2270,10 @@
 		hci_cc_read_bd_addr(hdev, skb);
 		break;
 
+	case HCI_OP_READ_DATA_BLOCK_SIZE:
+		hci_cc_read_data_block_size(hdev, skb);
+		break;
+
 	case HCI_OP_WRITE_CA_TIMEOUT:
 		hci_cc_write_ca_timeout(hdev, skb);
 		break;
@@ -2224,19 +2282,10 @@
 		hci_cc_read_flow_control_mode(hdev, skb);
 		break;
 
-	case HCI_OP_READ_DATA_BLOCK_SIZE:
-		hci_cc_read_data_block_size(hdev, skb);
-		break;
-
 	case HCI_OP_READ_LOCAL_AMP_INFO:
 		hci_cc_read_local_amp_info(hdev, skb);
 		break;
 
-	case HCI_OP_READ_LOCAL_AMP_ASSOC:
-	case HCI_OP_WRITE_REMOTE_AMP_ASSOC:
-		hci_amp_cmd_complete(hdev, opcode, skb);
-		break;
-
 	case HCI_OP_DELETE_STORED_LINK_KEY:
 		hci_cc_delete_stored_link_key(hdev, skb);
 		break;
@@ -2273,24 +2322,28 @@
 		hci_cc_le_read_buffer_size(hdev, skb);
 		break;
 
-	case HCI_OP_LE_READ_WHITE_LIST_SIZE:
-		hci_cc_le_read_white_list_size(hdev, skb);
+	case HCI_OP_USER_CONFIRM_REPLY:
+		hci_cc_user_confirm_reply(hdev, skb);
 		break;
 
-	case HCI_OP_LE_CLEAR_WHITE_LIST:
-		hci_cc_le_clear_white_list(hdev, skb);
+	case HCI_OP_USER_CONFIRM_NEG_REPLY:
+		hci_cc_user_confirm_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_READ_RSSI:
-		hci_cc_read_rssi(hdev, skb);
+	case HCI_OP_USER_PASSKEY_REPLY:
+		hci_cc_user_passkey_reply(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_REPLY:
-		hci_cc_user_confirm_reply(hdev, skb);
+	case HCI_OP_USER_PASSKEY_NEG_REPLY:
+		hci_cc_user_passkey_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_NEG_REPLY:
-		hci_cc_user_confirm_neg_reply(hdev, skb);
+	case HCI_OP_LE_SET_SCAN_PARAM:
+		hci_cc_le_set_scan_param(hdev, skb);
+		break;
+
+	case HCI_OP_LE_SET_SCAN_ENABLE:
+		hci_cc_le_set_scan_enable(hdev, skb);
 		break;
 
 	case HCI_OP_LE_LTK_REPLY:
@@ -2301,8 +2354,8 @@
 		hci_cc_le_ltk_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_LE_SET_SCAN_ENABLE:
-		hci_cc_le_set_scan_enable(hdev, skb);
+	case HCI_OP_WRITE_LE_HOST_SUPPORTED:
+		hci_cc_write_le_host_supported(hdev, skb);
 		break;
 
 	default:
@@ -2313,10 +2366,10 @@
 	if (ev->opcode != HCI_OP_NOP)
 		del_timer(&hdev->cmd_timer);
 
-	if (ev->ncmd) {
+	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 	}
 }
 
@@ -2367,40 +2420,15 @@
 		break;
 
 	case HCI_OP_SNIFF_MODE:
-		hci_cs_sniff_mode(hdev, ev->status);
-		break;
-
-	case HCI_OP_EXIT_SNIFF_MODE:
-		hci_cs_exit_sniff_mode(hdev, ev->status);
-		break;
-
-	case HCI_OP_CREATE_LOGICAL_LINK:
-		hci_cs_create_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_ACCEPT_LOGICAL_LINK:
-		hci_cs_accept_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_DISCONN_LOGICAL_LINK:
-		hci_cs_disconn_logical_link(hdev, ev->status);
-		break;
-
-	case HCI_OP_FLOW_SPEC_MODIFY:
-		hci_cs_flow_spec_modify(hdev, ev->status);
+		hci_cs_sniff_mode(hdev, ev->status);
 		break;
 
-	case HCI_OP_CREATE_PHYS_LINK:
-	case HCI_OP_ACCEPT_PHYS_LINK:
-		hci_amp_cmd_status(hdev, opcode, ev->status);
+	case HCI_OP_EXIT_SNIFF_MODE:
+		hci_cs_exit_sniff_mode(hdev, ev->status);
 		break;
 
-	case HCI_OP_DISCONN_PHYS_LINK:
-		hci_cs_disconn_physical_link(hdev, ev->status);
-
 	case HCI_OP_DISCONNECT:
-		if (ev->status != 0)
-			mgmt_disconnect_failed(hdev->id);
+		hci_cs_disconnect(hdev, ev->status);
 		break;
 
 	case HCI_OP_LE_CREATE_CONN:
@@ -2422,7 +2450,7 @@
 	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 	}
 }
 
@@ -2444,7 +2472,7 @@
 				conn->link_mode |= HCI_LM_MASTER;
 		}
 
-		clear_bit(HCI_CONN_RSWITCH_PEND, &conn->pend);
+		clear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);
 
 		hci_role_switch_cfm(conn, ev->status, ev->role);
 	}
@@ -2455,125 +2483,117 @@
 static inline void hci_num_comp_pkts_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_num_comp_pkts *ev = (void *) skb->data;
-	__le16 *ptr;
 	int i;
 
-	skb_pull(skb, sizeof(*ev));
-
-	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
+	if (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_PACKET_BASED) {
+		BT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);
+		return;
+	}
 
-	if (skb->len < ev->num_hndl * 4) {
+	if (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +
+			ev->num_hndl * sizeof(struct hci_comp_pkts_info)) {
 		BT_DBG("%s bad parameters", hdev->name);
 		return;
 	}
 
-	tasklet_disable(&hdev->tx_task);
+	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
 
-	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
-		struct hci_conn *conn = NULL;
-		struct hci_chan *chan;
+	for (i = 0; i < ev->num_hndl; i++) {
+		struct hci_comp_pkts_info *info = &ev->handles[i];
+		struct hci_conn *conn;
 		__u16  handle, count;
 
-		handle = get_unaligned_le16(ptr++);
-		count  = get_unaligned_le16(ptr++);
+		handle = __le16_to_cpu(info->handle);
+		count  = __le16_to_cpu(info->count);
 
-		if (hdev->dev_type == HCI_BREDR)
-			conn = hci_conn_hash_lookup_handle(hdev, handle);
-		else {
-			chan = hci_chan_list_lookup_handle(hdev, handle);
-			if (chan)
-				conn = chan->conn;
-		}
-		if (conn) {
-			conn->sent -= count;
+		conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (!conn)
+			continue;
 
-			if (conn->type == ACL_LINK) {
+		conn->sent -= count;
+
+		switch (conn->type) {
+		case ACL_LINK:
+			hdev->acl_cnt += count;
+			if (hdev->acl_cnt > hdev->acl_pkts)
+				hdev->acl_cnt = hdev->acl_pkts;
+			break;
+
+		case LE_LINK:
+			if (hdev->le_pkts) {
+				hdev->le_cnt += count;
+				if (hdev->le_cnt > hdev->le_pkts)
+					hdev->le_cnt = hdev->le_pkts;
+			} else {
 				hdev->acl_cnt += count;
 				if (hdev->acl_cnt > hdev->acl_pkts)
 					hdev->acl_cnt = hdev->acl_pkts;
-			} else if (conn->type == LE_LINK) {
-				if (hdev->le_pkts) {
-					hdev->le_cnt += count;
-					if (hdev->le_cnt > hdev->le_pkts)
-						hdev->le_cnt = hdev->le_pkts;
-				} else {
-					hdev->acl_cnt += count;
-					if (hdev->acl_cnt > hdev->acl_pkts)
-						hdev->acl_cnt = hdev->acl_pkts;
-				}
-			} else {
-				hdev->sco_cnt += count;
-				if (hdev->sco_cnt > hdev->sco_pkts)
-					hdev->sco_cnt = hdev->sco_pkts;
 			}
+			break;
+
+		case SCO_LINK:
+			hdev->sco_cnt += count;
+			if (hdev->sco_cnt > hdev->sco_pkts)
+				hdev->sco_cnt = hdev->sco_pkts;
+			break;
+
+		default:
+			BT_ERR("Unknown type %d conn %p", conn->type, conn);
+			break;
 		}
 	}
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 
 static inline void hci_num_comp_blocks_evt(struct hci_dev *hdev,
-					struct sk_buff *skb)
+					   struct sk_buff *skb)
 {
 	struct hci_ev_num_comp_blocks *ev = (void *) skb->data;
-	__le16 *ptr;
 	int i;
 
-	skb_pull(skb, sizeof(*ev));
-
-	BT_DBG("%s total_num_blocks %d num_hndl %d",
-		hdev->name, ev->total_num_blocks, ev->num_hndl);
+	if (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_BLOCK_BASED) {
+		BT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);
+		return;
+	}
 
-	if (skb->len < ev->num_hndl * 6) {
+	if (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +
+			ev->num_hndl * sizeof(struct hci_comp_blocks_info)) {
 		BT_DBG("%s bad parameters", hdev->name);
 		return;
 	}
 
-	tasklet_disable(&hdev->tx_task);
+	BT_DBG("%s num_blocks %d num_hndl %d", hdev->name, ev->num_blocks,
+								ev->num_hndl);
 
-	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
-		struct hci_conn *conn = NULL;
-		struct hci_chan *chan;
+	for (i = 0; i < ev->num_hndl; i++) {
+		struct hci_comp_blocks_info *info = &ev->handles[i];
+		struct hci_conn *conn;
 		__u16  handle, block_count;
 
-		handle = get_unaligned_le16(ptr++);
+		handle = __le16_to_cpu(info->handle);
+		block_count = __le16_to_cpu(info->blocks);
 
-		/* Skip packet count */
-		ptr++;
-		block_count  = get_unaligned_le16(ptr++);
-
-		BT_DBG("%s handle %d count %d", hdev->name, handle,
-			block_count);
-
-		if (hdev->dev_type == HCI_BREDR)
-			conn = hci_conn_hash_lookup_handle(hdev, handle);
-		else {
-			chan = hci_chan_list_lookup_handle(hdev, handle);
-			if (chan)
-				conn = chan->conn;
-		}
-		if (conn) {
-			BT_DBG("%s conn %p sent %d", hdev->name,
-				conn, conn->sent);
+		conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (!conn)
+			continue;
 
-			conn->sent -= block_count;
+		conn->sent -= block_count;
 
-			if (conn->type == ACL_LINK) {
-				hdev->acl_cnt += block_count;
-				if (hdev->acl_cnt > hdev->acl_pkts)
-					hdev->acl_cnt = hdev->acl_pkts;
-			} else {
-				/* We should not find ourselves here */
-				BT_DBG("Unexpected event for SCO connection");
-			}
+		switch (conn->type) {
+		case ACL_LINK:
+			hdev->block_cnt += block_count;
+			if (hdev->block_cnt > hdev->num_blocks)
+				hdev->block_cnt = hdev->num_blocks;
+			break;
+
+		default:
+			BT_ERR("Unknown type %d conn %p", conn->type, conn);
+			break;
 		}
 	}
 
-	tasklet_schedule(&hdev->tx_task);
-
-	tasklet_enable(&hdev->tx_task);
+	queue_work(hdev->workqueue, &hdev->tx_work);
 }
 
 static inline void hci_mode_change_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2590,17 +2610,14 @@
 		conn->mode = ev->mode;
 		conn->interval = __le16_to_cpu(ev->interval);
 
-		if (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		if (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 			if (conn->mode == HCI_CM_ACTIVE)
-				conn->power_save = 1;
+				set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 			else
-				conn->power_save = 0;
+				clear_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 		}
-		if (conn->mode == HCI_CM_SNIFF)
-			if (wake_lock_active(&conn->idle_lock))
-				wake_unlock(&conn->idle_lock);
 
-		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->pend))
+		if (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))
 			hci_sco_setup(conn, ev->status);
 	}
 
@@ -2617,20 +2634,30 @@
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (conn && conn->state == BT_CONNECTED) {
+	if (!conn)
+		goto unlock;
+
+	if (conn->state == BT_CONNECTED) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_PAIRING_TIMEOUT;
 		hci_conn_put(conn);
-		hci_conn_enter_active_mode(conn, 0);
 	}
 
-	if (!test_bit(HCI_PAIRABLE, &hdev->flags))
+	if (!test_bit(HCI_PAIRABLE, &hdev->dev_flags))
 		hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,
 					sizeof(ev->bdaddr), &ev->bdaddr);
+	else if (test_bit(HCI_MGMT, &hdev->dev_flags)) {
+		u8 secure;
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_request(hdev->id, &ev->bdaddr);
+		if (conn->pending_sec_level == BT_SECURITY_HIGH)
+			secure = 1;
+		else
+			secure = 0;
+
+		mgmt_pin_code_request(hdev, &ev->bdaddr, secure);
+	}
 
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -2643,7 +2670,7 @@
 
 	BT_DBG("%s", hdev->name);
 
-	if (!test_bit(HCI_LINK_KEYS, &hdev->flags))
+	if (!test_bit(HCI_LINK_KEYS, &hdev->dev_flags))
 		return;
 
 	hci_dev_lock(hdev);
@@ -2655,31 +2682,33 @@
 		goto not_found;
 	}
 
-	BT_DBG("%s found key type %u for %s", hdev->name, key->key_type,
+	BT_DBG("%s found key type %u for %s", hdev->name, key->type,
 							batostr(&ev->bdaddr));
 
-	if (!test_bit(HCI_DEBUG_KEYS, &hdev->flags) && key->key_type == 0x03) {
+	if (!test_bit(HCI_DEBUG_KEYS, &hdev->dev_flags) &&
+				key->type == HCI_LK_DEBUG_COMBINATION) {
 		BT_DBG("%s ignoring debug key", hdev->name);
 		goto not_found;
 	}
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-
 	if (conn) {
-		BT_DBG("Conn pending sec level is %d, ssp is %d, key len is %d",
-			conn->pending_sec_level, conn->ssp_mode, key->pin_len);
-	}
-	if (conn && (conn->ssp_mode == 0) &&
-		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH) &&
-		(key->pin_len != 16)) {
-		BT_DBG("Security is high ignoring this key");
-		goto not_found;
-	}
+		if (key->type == HCI_LK_UNAUTH_COMBINATION &&
+				conn->auth_type != 0xff &&
+				(conn->auth_type & 0x01)) {
+			BT_DBG("%s ignoring unauthenticated key", hdev->name);
+			goto not_found;
+		}
+
+		if (key->type == HCI_LK_COMBINATION && key->pin_len < 16 &&
+				conn->pending_sec_level == BT_SECURITY_HIGH) {
+			BT_DBG("%s ignoring key unauthenticated for high \
+							security", hdev->name);
+			goto not_found;
+		}
 
-	if (key->key_type == 0x04 && conn && conn->auth_type != 0xff &&
-						(conn->auth_type & 0x01)) {
-		BT_DBG("%s ignoring unauthenticated key", hdev->name);
-		goto not_found;
+		conn->key_type = key->type;
+		conn->pin_length = key->pin_len;
 	}
 
 	bacpy(&cp.bdaddr, &ev->bdaddr);
@@ -2702,7 +2731,7 @@
 	struct hci_conn *conn;
 	u8 pin_len = 0;
 
-	BT_DBG("%s type %d", hdev->name, ev->key_type);
+	BT_DBG("%s", hdev->name);
 
 	hci_dev_lock(hdev);
 
@@ -2710,19 +2739,16 @@
 	if (conn) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+		pin_len = conn->pin_length;
 
-		memcpy(conn->link_key, ev->link_key, 16);
-		conn->key_type = ev->key_type;
-		hci_disconnect_amp(conn, 0x06);
+		if (ev->key_type != HCI_LK_CHANGED_COMBINATION)
+			conn->key_type = ev->key_type;
 
-		conn->link_mode &= ~HCI_LM_ENCRYPT;
-		pin_len = conn->pin_length;
 		hci_conn_put(conn);
-		hci_conn_enter_active_mode(conn, 0);
 	}
 
-	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
-		hci_add_link_key(hdev, 1, &ev->bdaddr, ev->link_key,
+	if (test_bit(HCI_LINK_KEYS, &hdev->dev_flags))
+		hci_add_link_key(hdev, conn, 1, &ev->bdaddr, ev->link_key,
 							ev->key_type, pin_len);
 
 	hci_dev_unlock(hdev);
@@ -2789,6 +2815,7 @@
 {
 	struct inquiry_data data;
 	int num_rsp = *((__u8 *) skb->data);
+	bool name_known, ssp;
 
 	BT_DBG("%s num_rsp %d", hdev->name, num_rsp);
 
@@ -2810,10 +2837,12 @@
 			data.clock_offset	= info->clock_offset;
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
-			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-						info->dev_class, info->rssi,
-						0, NULL);
+
+			name_known = hci_inquiry_cache_update(hdev, &data,
+							      false, &ssp);
+			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+					  info->dev_class, info->rssi,
+					  !name_known, ssp, NULL, 0);
 		}
 	} else {
 		struct inquiry_info_with_rssi *info = (void *) (skb->data + 1);
@@ -2827,10 +2856,11 @@
 			data.clock_offset	= info->clock_offset;
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
-			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-						info->dev_class, info->rssi,
-						0, NULL);
+			name_known = hci_inquiry_cache_update(hdev, &data,
+							      false, &ssp);
+			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+					  info->dev_class, info->rssi,
+					  !name_known, ssp, NULL, 0);
 		}
 	}
 
@@ -2855,32 +2885,25 @@
 
 		ie = hci_inquiry_cache_lookup(hdev, &conn->dst);
 		if (ie)
-			ie->data.ssp_mode = (ev->features[0] & 0x01);
+			ie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);
 
-		conn->ssp_mode = (ev->features[0] & 0x01);
-		/*In case if remote device ssp supported/2.0 device
-		reduce the security level to MEDIUM if it is VERY HIGH*/
-		if (!conn->ssp_mode && conn->auth_initiator &&
-			(conn->pending_sec_level == BT_SECURITY_VERY_HIGH))
-			conn->pending_sec_level = BT_SECURITY_MEDIUM;
-
-		if (conn->ssp_mode && conn->auth_initiator &&
-			conn->io_capability != 0x03) {
-			conn->pending_sec_level = BT_SECURITY_VERY_HIGH;
-			conn->auth_type = HCI_AT_DEDICATED_BONDING_MITM;
-		}
+		if (ev->features[0] & LMP_HOST_SSP)
+			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
 
-	if (!ev->status) {
+	if (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {
 		struct hci_cp_remote_name_req cp;
 		memset(&cp, 0, sizeof(cp));
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.pscan_rep_mode = 0x02;
 		hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);
-	}
+	} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &conn->dst, conn->type,
+				      conn->dst_type, 0, NULL, 0,
+				      conn->dev_class);
 
 	if (!hci_outgoing_auth_needed(hdev, conn)) {
 		conn->state = BT_CONNECTED;
@@ -2927,9 +2950,7 @@
 	case 0x1a:	/* Unsupported Remote Feature */
 	case 0x1f:	/* Unspecified error */
 		if (conn->out && conn->attempt < 2) {
-			if (!conn->hdev->is_wbs)
-				conn->pkt_type =
-					(hdev->esco_type & SCO_ESCO_MASK) |
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
 					(hdev->esco_type & EDR_ESCO_MASK);
 			hci_setup_sync(conn, conn->link->handle);
 			goto unlock;
@@ -2957,16 +2978,8 @@
 static inline void hci_sniff_subrate_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_sniff_subrate *ev = (void *) skb->data;
-	struct hci_conn *conn =
-		hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
-	if (conn && (ev->max_rx_latency > hdev->sniff_max_interval)) {
-		BT_ERR("value of rx_latency:%d", ev->max_rx_latency);
-		hci_dev_lock(hdev);
-		hci_conn_enter_active_mode(conn, 1);
-		hci_dev_unlock(hdev);
-	}
 }
 
 static inline void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2983,6 +2996,8 @@
 	hci_dev_lock(hdev);
 
 	for (; num_rsp; num_rsp--, info++) {
+		bool name_known, ssp;
+
 		bacpy(&data.bdaddr, &info->bdaddr);
 		data.pscan_rep_mode	= info->pscan_rep_mode;
 		data.pscan_period_mode	= info->pscan_period_mode;
@@ -2991,10 +3006,19 @@
 		data.clock_offset	= info->clock_offset;
 		data.rssi		= info->rssi;
 		data.ssp_mode		= 0x01;
-		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
-				info->dev_class, info->rssi,
-				HCI_MAX_EIR_LENGTH, info->data);
+
+		if (test_bit(HCI_MGMT, &hdev->dev_flags))
+			name_known = eir_has_data_type(info->data,
+						       sizeof(info->data),
+						       EIR_NAME_COMPLETE);
+		else
+			name_known = true;
+
+		name_known = hci_inquiry_cache_update(hdev, &data, name_known,
+						      &ssp);
+		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+				  info->dev_class, info->rssi, !name_known,
+				  ssp, info->data, sizeof(info->data));
 	}
 
 	hci_dev_unlock(hdev);
@@ -3002,23 +3026,19 @@
 
 static inline u8 hci_get_auth_req(struct hci_conn *conn)
 {
-	BT_DBG("%p", conn);
-
 	/* If remote requests dedicated bonding follow that lead */
 	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03) {
 		/* If both remote and local IO capabilities allow MITM
 		 * protection then require it, otherwise don't */
-		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03) {
+		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03)
 			return 0x02;
-		} else {
-			conn->auth_type |= 0x01;
+		else
 			return 0x03;
-		}
 	}
 
 	/* If remote requests no-bonding follow that lead */
-	if (conn->remote_auth <= 0x01)
-		return 0x00;
+	if (conn->remote_auth == 0x00 || conn->remote_auth == 0x01)
+		return conn->remote_auth | (conn->auth_type & 0x01);
 
 	return conn->auth_type;
 }
@@ -3038,23 +3058,22 @@
 
 	hci_conn_hold(conn);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		goto unlock;
 
-	if (test_bit(HCI_PAIRABLE, &hdev->flags) ||
+	if (test_bit(HCI_PAIRABLE, &hdev->dev_flags) ||
 			(conn->remote_auth & ~0x01) == HCI_AT_NO_BONDING) {
 		struct hci_cp_io_capability_reply cp;
-		u8 io_cap = conn->io_capability;
 
-		/* ACL-SSP does not support IO CAP 0x04 */
-		cp.capability = (io_cap == 0x04) ? 0x01 : io_cap;
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		if (conn->auth_initiator)
-			cp.authentication = conn->auth_type;
-		else
-			cp.authentication = hci_get_auth_req(conn);
+		/* Change the IO capability from KeyboardDisplay
+		 * to DisplayYesNo as it is not supported by BT spec. */
+		cp.capability = (conn->io_capability == 0x04) ?
+						0x01 : conn->io_capability;
+		conn->auth_type = hci_get_auth_req(conn);
+		cp.authentication = conn->auth_type;
 
-		if ((conn->out == 0x01 || conn->remote_oob == 0x01) &&
+		if ((conn->out || test_bit(HCI_CONN_REMOTE_OOB, &conn->flags)) &&
 				hci_find_remote_oob_data(hdev, &conn->dst))
 			cp.oob_data = 0x01;
 		else
@@ -3066,7 +3085,7 @@
 		struct hci_cp_io_capability_neg_reply cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = 0x16; /* Pairing not allowed */
+		cp.reason = HCI_ERROR_PAIRING_NOT_ALLOWED;
 
 		hci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_NEG_REPLY,
 							sizeof(cp), &cp);
@@ -3090,31 +3109,94 @@
 		goto unlock;
 
 	conn->remote_cap = ev->capability;
-	conn->remote_oob = ev->oob_data;
 	conn->remote_auth = ev->authentication;
+	if (ev->oob_data)
+		set_bit(HCI_CONN_REMOTE_OOB, &conn->flags);
 
 unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_user_ssp_confirmation_evt(struct hci_dev *hdev,
-						u8 event, struct sk_buff *skb)
+static inline void hci_user_confirm_request_evt(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
 	struct hci_ev_user_confirm_req *ev = (void *) skb->data;
+	int loc_mitm, rem_mitm, confirm_hint = 0;
+	struct hci_conn *conn;
 
 	BT_DBG("%s", hdev->name);
 
 	hci_dev_lock(hdev);
 
-	if (test_bit(HCI_MGMT, &hdev->flags)) {
-		if (event == HCI_EV_USER_PASSKEY_REQUEST)
-			mgmt_user_confirm_request(hdev->id, event,
-							&ev->bdaddr, 0);
-		else
-			mgmt_user_confirm_request(hdev->id, event,
-						&ev->bdaddr, ev->passkey);
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		goto unlock;
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
+	if (!conn)
+		goto unlock;
+
+	loc_mitm = (conn->auth_type & 0x01);
+	rem_mitm = (conn->remote_auth & 0x01);
+
+	/* If we require MITM but the remote device can't provide that
+	 * (it has NoInputNoOutput) then reject the confirmation
+	 * request. The only exception is when we're dedicated bonding
+	 * initiators (connect_cfm_cb set) since then we always have the MITM
+	 * bit set. */
+	if (!conn->connect_cfm_cb && loc_mitm && conn->remote_cap == 0x03) {
+		BT_DBG("Rejecting request: remote device can't provide MITM");
+		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_NEG_REPLY,
+					sizeof(ev->bdaddr), &ev->bdaddr);
+		goto unlock;
+	}
+
+	/* If no side requires MITM protection; auto-accept */
+	if ((!loc_mitm || conn->remote_cap == 0x03) &&
+				(!rem_mitm || conn->io_capability == 0x03)) {
+
+		/* If we're not the initiators request authorization to
+		 * proceed from user space (mgmt_user_confirm with
+		 * confirm_hint set to 1). */
+		if (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
+			BT_DBG("Confirming auto-accept as acceptor");
+			confirm_hint = 1;
+			goto confirm;
+		}
+
+		BT_DBG("Auto-accept of user confirmation with %ums delay",
+						hdev->auto_accept_delay);
+
+		if (hdev->auto_accept_delay > 0) {
+			int delay = msecs_to_jiffies(hdev->auto_accept_delay);
+			mod_timer(&conn->auto_accept_timer, jiffies + delay);
+			goto unlock;
+		}
+
+		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY,
+						sizeof(ev->bdaddr), &ev->bdaddr);
+		goto unlock;
 	}
 
+confirm:
+	mgmt_user_confirm_request(hdev, &ev->bdaddr, ACL_LINK, 0, ev->passkey,
+				  confirm_hint);
+
+unlock:
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_user_passkey_request_evt(struct hci_dev *hdev,
+							struct sk_buff *skb)
+{
+	struct hci_ev_user_passkey_req *ev = (void *) skb->data;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	if (test_bit(HCI_MGMT, &hdev->dev_flags))
+		mgmt_user_passkey_request(hdev, &ev->bdaddr, ACL_LINK, 0);
+
 	hci_dev_unlock(hdev);
 }
 
@@ -3136,8 +3218,9 @@
 	 * initiated the authentication. A traditional auth_complete
 	 * event gets always produced as initiator and is also mapped to
 	 * the mgmt_auth_failed event */
-	if (!test_bit(HCI_CONN_AUTH_PEND, &conn->pend) && ev->status != 0)
-		mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
+	if (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) && ev->status != 0)
+		mgmt_auth_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+				 ev->status);
 
 	hci_conn_put(conn);
 
@@ -3156,13 +3239,13 @@
 
 	ie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);
 	if (ie)
-		ie->data.ssp_mode = (ev->features[0] & 0x01);
+		ie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);
 
 	hci_dev_unlock(hdev);
 }
 
 static inline void hci_remote_oob_data_request_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
+						   struct sk_buff *skb)
 {
 	struct hci_ev_remote_oob_data_request *ev = (void *) skb->data;
 	struct oob_data *data;
@@ -3171,7 +3254,7 @@
 
 	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
 		goto unlock;
 
 	data = hci_find_remote_oob_data(hdev, &ev->bdaddr);
@@ -3200,89 +3283,70 @@
 {
 	struct hci_ev_le_conn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
-	u8 white_list;
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
 
 	hci_dev_lock(hdev);
 
-	/* Ignore event for LE cancel create conn whitelist */
-	if (ev->status && !bacmp(&ev->bdaddr, BDADDR_ANY))
-		goto unlock;
-
-	if (hci_conn_hash_lookup_ba(hdev, LE_LINK, BDADDR_ANY))
-		white_list = 1;
-	else
-		white_list = 0;
-
-	BT_DBG("w_list %d", white_list);
-
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &ev->bdaddr);
 	if (!conn) {
-		conn = hci_le_conn_add(hdev, &ev->bdaddr, ev->bdaddr_type);
+		conn = hci_conn_add(hdev, LE_LINK, &ev->bdaddr);
 		if (!conn) {
 			BT_ERR("No memory for new connection");
 			hci_dev_unlock(hdev);
 			return;
 		}
+
+		conn->dst_type = ev->bdaddr_type;
 	}
 
 	if (ev->status) {
+		mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
+						conn->dst_type, ev->status);
 		hci_proto_connect_cfm(conn, ev->status);
 		conn->state = BT_CLOSED;
 		hci_conn_del(conn);
 		goto unlock;
 	}
 
+	if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))
+		mgmt_device_connected(hdev, &ev->bdaddr, conn->type,
+				      conn->dst_type, 0, NULL, 0, NULL);
+
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->handle = __le16_to_cpu(ev->handle);
 	conn->state = BT_CONNECTED;
-	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-	mgmt_connected(hdev->id, &ev->bdaddr, 1);
-	mgmt_le_conn_params(hdev->id, &ev->bdaddr,
-			__le16_to_cpu(ev->interval),
-			__le16_to_cpu(ev->latency),
-			__le16_to_cpu(ev->supervision_timeout));
 
-	hci_conn_hold(conn);
 	hci_conn_hold_device(conn);
 	hci_conn_add_sysfs(conn);
 
-	if (!white_list)
-		hci_proto_connect_cfm(conn, ev->status);
+	hci_proto_connect_cfm(conn, ev->status);
 
 unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_le_conn_update_complete_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
+						struct sk_buff *skb)
 {
-	struct hci_ev_le_conn_update_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s status %d", hdev->name, ev->status);
+	u8 num_reports = skb->data[0];
+	void *ptr = &skb->data[1];
+	s8 rssi;
 
 	hci_dev_lock(hdev);
 
-	conn = hci_conn_hash_lookup_handle(hdev,
-				__le16_to_cpu(ev->handle));
-	if (conn == NULL) {
-		BT_ERR("Unknown connection update");
-		goto unlock;
-	}
+	while (num_reports--) {
+		struct hci_ev_le_advertising_info *ev = ptr;
 
-	if (ev->status) {
-		BT_ERR("Connection update unsuccessful");
-		goto unlock;
-	}
+		hci_add_adv_entry(hdev, ev);
 
-	mgmt_le_conn_params(hdev->id, &conn->dst,
-			__le16_to_cpu(ev->interval),
-			__le16_to_cpu(ev->latency),
-			__le16_to_cpu(ev->supervision_timeout));
+		rssi = ev->data[ev->length];
+		mgmt_device_found(hdev, &ev->bdaddr, LE_LINK, ev->bdaddr_type,
+				  NULL, rssi, 0, 1, ev->data, ev->length);
+
+		ptr += sizeof(*ev) + ev->length + 1;
+	}
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -3293,7 +3357,7 @@
 	struct hci_cp_le_ltk_reply cp;
 	struct hci_cp_le_ltk_neg_reply neg;
 	struct hci_conn *conn;
-	struct link_key *ltk;
+	struct smp_ltk *ltk;
 
 	BT_DBG("%s handle %d", hdev->name, cpu_to_le16(ev->handle));
 
@@ -3309,10 +3373,21 @@
 
 	memcpy(cp.ltk, ltk->val, sizeof(ltk->val));
 	cp.handle = cpu_to_le16(conn->handle);
-	conn->pin_length = ltk->pin_len;
+
+	if (ltk->authenticated)
+		conn->pending_sec_level = BT_SECURITY_HIGH;
+	else
+		conn->pending_sec_level = BT_SECURITY_MEDIUM;
+
+	conn->enc_key_size = ltk->enc_size;
 
 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
 
+	if (ltk->type & HCI_SMP_STK) {
+		list_del(&ltk->list);
+		kfree(ltk);
+	}
+
 	hci_dev_unlock(hdev);
 
 	return;
@@ -3323,27 +3398,6 @@
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_le_advertising_info *ev;
-	u8 num_reports;
-
-	num_reports = skb->data[0];
-	ev = (void *) &skb->data[1];
-
-	hci_dev_lock(hdev);
-
-	while (num_reports--) {
-		mgmt_device_found(hdev->id, &ev->bdaddr, ev->bdaddr_type,
-				1, NULL, 0, ev->length, ev->data);
-		hci_add_adv_entry(hdev, ev);
-		ev = (void *) (ev->data + ev->length + 1);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
 static inline void hci_le_meta_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_le_meta *le_ev = (void *) skb->data;
@@ -3355,150 +3409,24 @@
 		hci_le_conn_complete_evt(hdev, skb);
 		break;
 
-	case HCI_EV_LE_CONN_UPDATE_COMPLETE:
-		hci_le_conn_update_complete_evt(hdev, skb);
+	case HCI_EV_LE_ADVERTISING_REPORT:
+		hci_le_adv_report_evt(hdev, skb);
 		break;
 
 	case HCI_EV_LE_LTK_REQ:
 		hci_le_ltk_request_evt(hdev, skb);
 		break;
 
-	case HCI_EV_LE_ADVERTISING_REPORT:
-		hci_le_adv_report_evt(hdev, skb);
-		break;
-
 	default:
 		break;
 	}
 }
 
-static inline void hci_phy_link_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_phys_link_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s handle %d status %d", hdev->name, ev->phy_handle,
-		ev->status);
-
-	hci_dev_lock(hdev);
-
-	if (ev->status == 0) {
-		conn = hci_conn_add(hdev, ACL_LINK, 0, BDADDR_ANY);
-		if (conn) {
-			conn->handle = ev->phy_handle;
-			conn->state = BT_CONNECTED;
-
-			hci_conn_hold(conn);
-			conn->disc_timeout = HCI_DISCONN_TIMEOUT/2;
-			hci_conn_put(conn);
-
-			hci_conn_hold_device(conn);
-			hci_conn_add_sysfs(conn);
-		} else
-			BT_ERR("No memory for new connection");
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_log_link_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_log_link_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_id(hdev, ev->phy_handle);
-
-	if (chan) {
-		if (ev->status == 0) {
-			chan->ll_handle = __le16_to_cpu(ev->log_handle);
-			chan->state = BT_CONNECTED;
-		} else {
-			chan->state = BT_CLOSED;
-		}
-
-		hci_proto_create_cfm(chan, ev->status);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_flow_spec_modify_complete(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_ev_flow_spec_modify_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_handle(hdev, ev->log_handle);
-	if (chan)
-		hci_proto_modify_cfm(chan, ev->status);
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_disconn_log_link_complete_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_disconn_log_link_complete *ev = (void *) skb->data;
-	struct hci_chan *chan;
-
-	BT_DBG("%s handle %d status %d", hdev->name,
-		__le16_to_cpu(ev->log_handle), ev->status);
-
-	if (ev->status)
-		return;
-
-	hci_dev_lock(hdev);
-
-	chan = hci_chan_list_lookup_handle(hdev, __le16_to_cpu(ev->log_handle));
-	if (chan)
-		hci_proto_destroy_cfm(chan, ev->reason);
-
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_disconn_phy_link_complete_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
-{
-	struct hci_ev_disconn_phys_link_complete *ev = (void *) skb->data;
-	struct hci_conn *conn;
-
-	BT_DBG("%s status %d", hdev->name, ev->status);
-
-	if (ev->status)
-		return;
-
-	hci_dev_lock(hdev);
-
-	conn = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);
-	if (conn) {
-		conn->state = BT_CLOSED;
-
-		hci_proto_disconn_cfm(conn, ev->reason, 0);
-		hci_conn_del(conn);
-	}
-
-	hci_dev_unlock(hdev);
-}
-
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_event_hdr *hdr = (void *) skb->data;
 	__u8 event = hdr->evt;
 
-	BT_DBG("");
-
 	skb_pull(skb, HCI_EVENT_HDR_SIZE);
 
 	switch (event) {
@@ -3626,10 +3554,12 @@
 		hci_io_capa_reply_evt(hdev, skb);
 		break;
 
-	case HCI_EV_USER_PASSKEY_REQUEST:
-	case HCI_EV_USER_PASSKEY_NOTIFICATION:
 	case HCI_EV_USER_CONFIRM_REQUEST:
-		hci_user_ssp_confirmation_evt(hdev, event, skb);
+		hci_user_confirm_request_evt(hdev, skb);
+		break;
+
+	case HCI_EV_USER_PASSKEY_REQUEST:
+		hci_user_passkey_request_evt(hdev, skb);
 		break;
 
 	case HCI_EV_SIMPLE_PAIR_COMPLETE:
@@ -3648,40 +3578,10 @@
 		hci_remote_oob_data_request_evt(hdev, skb);
 		break;
 
-	case HCI_EV_PHYS_LINK_COMPLETE:
-		hci_phy_link_complete(hdev, skb);
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
-	case HCI_EV_LOG_LINK_COMPLETE:
-		hci_log_link_complete(hdev, skb);
-		break;
-
-	case HCI_EV_FLOW_SPEC_MODIFY_COMPLETE:
-		hci_flow_spec_modify_complete(hdev, skb);
-		break;
-
-	case HCI_EV_DISCONN_LOG_LINK_COMPLETE:
-		hci_disconn_log_link_complete_evt(hdev, skb);
-		break;
-
-	case HCI_EV_DISCONN_PHYS_LINK_COMPLETE:
-		hci_disconn_phy_link_complete_evt(hdev, skb);
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
 	case HCI_EV_NUM_COMP_BLOCKS:
 		hci_num_comp_blocks_evt(hdev, skb);
 		break;
 
-	case HCI_EV_CHANNEL_SELECTED:
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
-	case HCI_EV_AMP_STATUS_CHANGE:
-		hci_amp_event_packet(hdev, event, skb);
-		break;
-
 	default:
 		BT_DBG("%s event 0x%x", hdev->name, event);
 		break;
@@ -3690,31 +3590,3 @@
 	kfree_skb(skb);
 	hdev->stat.evt_rx++;
 }
-
-/* Generate internal stack event */
-void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)
-{
-	struct hci_event_hdr *hdr;
-	struct hci_ev_stack_internal *ev;
-	struct sk_buff *skb;
-
-	skb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);
-	if (!skb)
-		return;
-
-	hdr = (void *) skb_put(skb, HCI_EVENT_HDR_SIZE);
-	hdr->evt  = HCI_EV_STACK_INTERNAL;
-	hdr->plen = sizeof(*ev) + dlen;
-
-	ev  = (void *) skb_put(skb, sizeof(*ev) + dlen);
-	ev->type = type;
-	memcpy(ev->data, data, dlen);
-
-	bt_cb(skb)->incoming = 1;
-	__net_timestamp(skb);
-
-	bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
-	skb->dev = (void *) hdev;
-	hci_send_to_sock(hdev, skb, NULL);
-	kfree_skb(skb);
-}
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_sock.c flo-ElementalX-5.00-patched/net/bluetooth/hci_sock.c
--- flo-ElementalX-5.00/net/bluetooth/hci_sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2011, The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -42,14 +42,14 @@
 #include <linux/ioctl.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/hci_mon.h>
 
-static bool enable_mgmt = 1;
+static atomic_t monitor_promisc = ATOMIC_INIT(0);
 
 /* ----- HCI socket interface ----- */
 
@@ -85,22 +85,20 @@
 };
 
 /* Send frame to RAW socket */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
-							struct sock *skip_sk)
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct sock *sk;
 	struct hlist_node *node;
+	struct sk_buff *skb_copy = NULL;
 
 	BT_DBG("hdev %p len %d", hdev, skb->len);
 
 	read_lock(&hci_sk_list.lock);
+
 	sk_for_each(sk, node, &hci_sk_list.head) {
 		struct hci_filter *flt;
 		struct sk_buff *nskb;
 
-		if (sk == skip_sk)
-			continue;
-
 		if (sk->sk_state != BT_BOUND || hci_pi(sk)->hdev != hdev)
 			continue;
 
@@ -108,12 +106,9 @@
 		if (skb->sk == sk)
 			continue;
 
-		if (bt_cb(skb)->channel != hci_pi(sk)->channel)
+		if (hci_pi(sk)->channel != HCI_CHANNEL_RAW)
 			continue;
 
-		if (bt_cb(skb)->channel == HCI_CHANNEL_CONTROL)
-			goto clone;
-
 		/* Apply filter */
 		flt = &hci_pi(sk)->filter;
 
@@ -137,125 +132,366 @@
 				continue;
 		}
 
-clone:
+		if (!skb_copy) {
+			/* Create a private copy with headroom */
+			skb_copy = __pskb_copy(skb, 1, GFP_ATOMIC);
+			if (!skb_copy)
+				continue;
+
+			/* Put type byte before the data */
+			memcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);
+		}
+
+		nskb = skb_clone(skb_copy, GFP_ATOMIC);
+		if (!nskb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
+	}
+
+	read_unlock(&hci_sk_list.lock);
+
+	kfree_skb(skb_copy);
+}
+
+/* Send frame to control socket */
+void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk)
+{
+	struct sock *sk;
+	struct hlist_node *node;
+
+	BT_DBG("len %d", skb->len);
+
+	read_lock(&hci_sk_list.lock);
+
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
+
+		/* Skip the original socket */
+		if (sk == skip_sk)
+			continue;
+
+		if (sk->sk_state != BT_BOUND)
+			continue;
+
+		if (hci_pi(sk)->channel != HCI_CHANNEL_CONTROL)
+			continue;
+
 		nskb = skb_clone(skb, GFP_ATOMIC);
 		if (!nskb)
 			continue;
 
-		/* Put type byte before the data */
-		if (bt_cb(skb)->channel == HCI_CHANNEL_RAW)
-			memcpy(skb_push(nskb, 1), &bt_cb(nskb)->pkt_type, 1);
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
+	}
+
+	read_unlock(&hci_sk_list.lock);
+}
+
+/* Send frame to monitor socket */
+void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	struct sock *sk;
+	struct hlist_node *node;
+	struct sk_buff *skb_copy = NULL;
+	__le16 opcode;
+
+	if (!atomic_read(&monitor_promisc))
+		return;
+
+	BT_DBG("hdev %p len %d", hdev, skb->len);
+
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_COMMAND_PKT:
+		opcode = __constant_cpu_to_le16(HCI_MON_COMMAND_PKT);
+		break;
+	case HCI_EVENT_PKT:
+		opcode = __constant_cpu_to_le16(HCI_MON_EVENT_PKT);
+		break;
+	case HCI_ACLDATA_PKT:
+		if (bt_cb(skb)->incoming)
+			opcode = __constant_cpu_to_le16(HCI_MON_ACL_RX_PKT);
+		else
+			opcode = __constant_cpu_to_le16(HCI_MON_ACL_TX_PKT);
+		break;
+	case HCI_SCODATA_PKT:
+		if (bt_cb(skb)->incoming)
+			opcode = __constant_cpu_to_le16(HCI_MON_SCO_RX_PKT);
+		else
+			opcode = __constant_cpu_to_le16(HCI_MON_SCO_TX_PKT);
+		break;
+	default:
+		return;
+	}
+
+	read_lock(&hci_sk_list.lock);
+
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
+
+		if (sk->sk_state != BT_BOUND)
+			continue;
+
+		if (hci_pi(sk)->channel != HCI_CHANNEL_MONITOR)
+			continue;
+
+		if (!skb_copy) {
+			struct hci_mon_hdr *hdr;
+
+			/* Create a private copy with headroom */
+			skb_copy = __pskb_copy(skb, HCI_MON_HDR_SIZE, GFP_ATOMIC);
+			if (!skb_copy)
+				continue;
+
+			/* Put header before the data */
+			hdr = (void *) skb_push(skb_copy, HCI_MON_HDR_SIZE);
+			hdr->opcode = opcode;
+			hdr->index = cpu_to_le16(hdev->id);
+			hdr->len = cpu_to_le16(skb->len);
+		}
+
+		nskb = skb_clone(skb_copy, GFP_ATOMIC);
+		if (!nskb)
+			continue;
 
 		if (sock_queue_rcv_skb(sk, nskb))
 			kfree_skb(nskb);
 	}
+
 	read_unlock(&hci_sk_list.lock);
+
+	kfree_skb(skb_copy);
 }
 
-static int hci_sock_release(struct socket *sock)
+static void send_monitor_event(struct sk_buff *skb)
 {
-	struct sock *sk = sock->sk;
-	struct hci_dev *hdev;
+	struct sock *sk;
+	struct hlist_node *node;
 
-	BT_DBG("sock %p sk %p", sock, sk);
+	BT_DBG("len %d", skb->len);
 
-	if (!sk)
-		return 0;
+	read_lock(&hci_sk_list.lock);
 
-	hdev = hci_pi(sk)->hdev;
+	sk_for_each(sk, node, &hci_sk_list.head) {
+		struct sk_buff *nskb;
 
-	bt_sock_unlink(&hci_sk_list, sk);
+		if (sk->sk_state != BT_BOUND)
+			continue;
 
-	if (hdev) {
-		atomic_dec(&hdev->promisc);
-		hci_dev_put(hdev);
+		if (hci_pi(sk)->channel != HCI_CHANNEL_MONITOR)
+			continue;
+
+		nskb = skb_clone(skb, GFP_ATOMIC);
+		if (!nskb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
 	}
 
-	sock_orphan(sk);
+	read_unlock(&hci_sk_list.lock);
+}
 
-	skb_queue_purge(&sk->sk_receive_queue);
-	skb_queue_purge(&sk->sk_write_queue);
+static struct sk_buff *create_monitor_event(struct hci_dev *hdev, int event)
+{
+	struct hci_mon_hdr *hdr;
+	struct hci_mon_new_index *ni;
+	struct sk_buff *skb;
+	__le16 opcode;
 
-	sock_put(sk);
-	return 0;
+	switch (event) {
+	case HCI_DEV_REG:
+		skb = bt_skb_alloc(HCI_MON_NEW_INDEX_SIZE, GFP_ATOMIC);
+		if (!skb)
+			return NULL;
+
+		ni = (void *) skb_put(skb, HCI_MON_NEW_INDEX_SIZE);
+		ni->type = hdev->dev_type;
+		ni->bus = hdev->bus;
+		bacpy(&ni->bdaddr, &hdev->bdaddr);
+		memcpy(ni->name, hdev->name, 8);
+
+		opcode = __constant_cpu_to_le16(HCI_MON_NEW_INDEX);
+		break;
+
+	case HCI_DEV_UNREG:
+		skb = bt_skb_alloc(0, GFP_ATOMIC);
+		if (!skb)
+			return NULL;
+
+		opcode = __constant_cpu_to_le16(HCI_MON_DEL_INDEX);
+		break;
+
+	default:
+		return NULL;
+	}
+
+	__net_timestamp(skb);
+
+	hdr = (void *) skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr->opcode = opcode;
+	hdr->index = cpu_to_le16(hdev->id);
+	hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
+
+	return skb;
 }
 
-struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
+static void send_monitor_replay(struct sock *sk)
 {
-	struct list_head *p;
+	struct hci_dev *hdev;
 
-	list_for_each(p, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	read_lock(&hci_dev_list_lock);
 
-		b = list_entry(p, struct bdaddr_list, list);
+	list_for_each_entry(hdev, &hci_dev_list, list) {
+		struct sk_buff *skb;
 
-		if (bacmp(bdaddr, &b->bdaddr) == 0)
-			return b;
+		skb = create_monitor_event(hdev, HCI_DEV_REG);
+		if (!skb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, skb))
+			kfree_skb(skb);
 	}
 
-	return NULL;
+	read_unlock(&hci_dev_list_lock);
 }
 
-static int hci_blacklist_add(struct hci_dev *hdev, void __user *arg)
+/* Generate internal stack event */
+static void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)
 {
-	bdaddr_t bdaddr;
-	struct bdaddr_list *entry;
+	struct hci_event_hdr *hdr;
+	struct hci_ev_stack_internal *ev;
+	struct sk_buff *skb;
 
-	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
-		return -EFAULT;
+	skb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);
+	if (!skb)
+		return;
 
-	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
-		return -EBADF;
+	hdr = (void *) skb_put(skb, HCI_EVENT_HDR_SIZE);
+	hdr->evt  = HCI_EV_STACK_INTERNAL;
+	hdr->plen = sizeof(*ev) + dlen;
 
-	if (hci_blacklist_lookup(hdev, &bdaddr))
-		return -EEXIST;
+	ev  = (void *) skb_put(skb, sizeof(*ev) + dlen);
+	ev->type = type;
+	memcpy(ev->data, data, dlen);
 
-	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
-	if (!entry)
-		return -ENOMEM;
+	bt_cb(skb)->incoming = 1;
+	__net_timestamp(skb);
+
+	bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
+	skb->dev = (void *) hdev;
+	hci_send_to_sock(hdev, skb);
+	kfree_skb(skb);
+}
 
-	bacpy(&entry->bdaddr, &bdaddr);
+void hci_sock_dev_event(struct hci_dev *hdev, int event)
+{
+	struct hci_ev_si_device ev;
 
-	list_add(&entry->list, &hdev->blacklist);
+	BT_DBG("hdev %s event %d", hdev->name, event);
 
-	return 0;
+	/* Send event to monitor */
+	if (atomic_read(&monitor_promisc)) {
+		struct sk_buff *skb;
+
+		skb = create_monitor_event(hdev, event);
+		if (skb) {
+			send_monitor_event(skb);
+			kfree_skb(skb);
+		}
+	}
+
+	/* Send event to sockets */
+	ev.event  = event;
+	ev.dev_id = hdev->id;
+	hci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);
+
+	if (event == HCI_DEV_UNREG) {
+		struct sock *sk;
+		struct hlist_node *node;
+
+		/* Detach sockets from device */
+		read_lock(&hci_sk_list.lock);
+		sk_for_each(sk, node, &hci_sk_list.head) {
+			bh_lock_sock_nested(sk);
+			if (hci_pi(sk)->hdev == hdev) {
+				hci_pi(sk)->hdev = NULL;
+				sk->sk_err = EPIPE;
+				sk->sk_state = BT_OPEN;
+				sk->sk_state_change(sk);
+
+				hci_dev_put(hdev);
+			}
+			bh_unlock_sock(sk);
+		}
+		read_unlock(&hci_sk_list.lock);
+	}
 }
 
-int hci_blacklist_clear(struct hci_dev *hdev)
+static int hci_sock_release(struct socket *sock)
 {
-	struct list_head *p, *n;
+	struct sock *sk = sock->sk;
+	struct hci_dev *hdev;
 
-	list_for_each_safe(p, n, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	BT_DBG("sock %p sk %p", sock, sk);
 
-		b = list_entry(p, struct bdaddr_list, list);
+	if (!sk)
+		return 0;
+
+	hdev = hci_pi(sk)->hdev;
 
-		list_del(p);
-		kfree(b);
+	if (hci_pi(sk)->channel == HCI_CHANNEL_MONITOR)
+		atomic_dec(&monitor_promisc);
+
+	bt_sock_unlink(&hci_sk_list, sk);
+
+	if (hdev) {
+		atomic_dec(&hdev->promisc);
+		hci_dev_put(hdev);
 	}
 
+	sock_orphan(sk);
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	skb_queue_purge(&sk->sk_write_queue);
+
+	sock_put(sk);
 	return 0;
 }
 
-static int hci_blacklist_del(struct hci_dev *hdev, void __user *arg)
+static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
-	struct bdaddr_list *entry;
+	int err;
 
 	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
 		return -EFAULT;
 
-	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
-		return hci_blacklist_clear(hdev);
+	hci_dev_lock(hdev);
 
-	entry = hci_blacklist_lookup(hdev, &bdaddr);
-	if (!entry)
-		return -ENOENT;
+	err = hci_blacklist_add(hdev, &bdaddr, 0);
 
-	list_del(&entry->list);
-	kfree(entry);
+	hci_dev_unlock(hdev);
 
-	return 0;
+	return err;
+}
+
+static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
+{
+	bdaddr_t bdaddr;
+	int err;
+
+	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
+		return -EFAULT;
+
+	hci_dev_lock(hdev);
+
+	err = hci_blacklist_del(hdev, &bdaddr, 0);
+
+	hci_dev_unlock(hdev);
+
+	return err;
 }
 
 /* Ioctls that require bound socket */
@@ -290,15 +526,12 @@
 	case HCIBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_blacklist_add(hdev, (void __user *) arg);
+		return hci_sock_blacklist_add(hdev, (void __user *) arg);
 
 	case HCIUNBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_blacklist_del(hdev, (void __user *) arg);
-
-	case HCISETAUTHINFO:
-		return hci_set_auth_info(hdev, (void __user *) arg);
+		return hci_sock_blacklist_del(hdev, (void __user *) arg);
 
 	default:
 		if (hdev->ioctl)
@@ -328,12 +561,7 @@
 	case HCIDEVUP:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-
-		err =  hci_dev_open(arg);
-		if (!err || err == -EALREADY)
-			return 0;
-		else
-			return err;
+		return hci_dev_open(arg);
 
 	case HCIDEVDOWN:
 		if (!capable(CAP_NET_ADMIN))
@@ -392,31 +620,69 @@
 	if (haddr.hci_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	if (haddr.hci_channel > HCI_CHANNEL_CONTROL)
-		return -EINVAL;
-
-	if (haddr.hci_channel == HCI_CHANNEL_CONTROL && !enable_mgmt)
-		return -EINVAL;
-
 	lock_sock(sk);
 
-	if (sk->sk_state == BT_BOUND || hci_pi(sk)->hdev) {
+	if (sk->sk_state == BT_BOUND) {
 		err = -EALREADY;
 		goto done;
 	}
 
-	if (haddr.hci_dev != HCI_DEV_NONE) {
-		hdev = hci_dev_get(haddr.hci_dev);
-		if (!hdev) {
-			err = -ENODEV;
+	switch (haddr.hci_channel) {
+	case HCI_CHANNEL_RAW:
+		if (hci_pi(sk)->hdev) {
+			err = -EALREADY;
 			goto done;
 		}
 
-		atomic_inc(&hdev->promisc);
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			hdev = hci_dev_get(haddr.hci_dev);
+			if (!hdev) {
+				err = -ENODEV;
+				goto done;
+			}
+
+			atomic_inc(&hdev->promisc);
+		}
+
+		hci_pi(sk)->hdev = hdev;
+		break;
+
+	case HCI_CHANNEL_CONTROL:
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			err = -EINVAL;
+			goto done;
+		}
+
+		if (!capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			goto done;
+		}
+
+		break;
+
+	case HCI_CHANNEL_MONITOR:
+		if (haddr.hci_dev != HCI_DEV_NONE) {
+			err = -EINVAL;
+			goto done;
+		}
+
+		if (!capable(CAP_NET_RAW)) {
+			err = -EPERM;
+			goto done;
+		}
+
+		send_monitor_replay(sk);
+
+		atomic_inc(&monitor_promisc);
+		break;
+
+	default:
+		err = -EINVAL;
+		goto done;
 	}
 
+
 	hci_pi(sk)->channel = haddr.hci_channel;
-	hci_pi(sk)->hdev = hdev;
 	sk->sk_state = BT_BOUND;
 
 done:
@@ -440,6 +706,7 @@
 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
+	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;
@@ -467,7 +734,8 @@
 		data = &tv;
 		len = sizeof(tv);
 #ifdef CONFIG_COMPAT
-		if (msg->msg_flags & MSG_CMSG_COMPAT) {
+		if (!COMPAT_USE_64BIT_TIME &&
+		    (msg->msg_flags & MSG_CMSG_COMPAT)) {
 			ctv.tv_sec = tv.tv_sec;
 			ctv.tv_usec = tv.tv_usec;
 			data = &ctv;
@@ -499,8 +767,6 @@
 	if (!skb)
 		return err;
 
-	msg->msg_namelen = 0;
-
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
@@ -510,7 +776,15 @@
 	skb_reset_transport_header(skb);
 	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 
-	hci_sock_cmsg(sk, msg, skb);
+	switch (hci_pi(sk)->channel) {
+	case HCI_CHANNEL_RAW:
+		hci_sock_cmsg(sk, msg, skb);
+		break;
+	case HCI_CHANNEL_CONTROL:
+	case HCI_CHANNEL_MONITOR:
+		sock_recv_timestamp(msg, sk, skb);
+		break;
+	}
 
 	skb_free_datagram(sk, skb);
 
@@ -523,7 +797,6 @@
 	struct sock *sk = sock->sk;
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
-	int reserve = 0;
 	int err;
 
 	BT_DBG("sock %p sk %p", sock, sk);
@@ -545,6 +818,9 @@
 	case HCI_CHANNEL_CONTROL:
 		err = mgmt_control(sk, msg, len);
 		goto done;
+	case HCI_CHANNEL_MONITOR:
+		err = -EOPNOTSUPP;
+		goto done;
 	default:
 		err = -EINVAL;
 		goto done;
@@ -561,18 +837,10 @@
 		goto done;
 	}
 
-	/* Allocate extra headroom for Qualcomm PAL */
-	if (hdev->dev_type == HCI_AMP && hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
-
-	skb = bt_skb_send_alloc(sk, len + reserve,
-					msg->msg_flags & MSG_DONTWAIT, &err);
+	skb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		goto done;
 
-	if (reserve)
-		skb_reserve(skb, reserve);
-
 	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 		err = -EFAULT;
 		goto drop;
@@ -596,10 +864,10 @@
 
 		if (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {
 			skb_queue_tail(&hdev->raw_q, skb);
-			tasklet_schedule(&hdev->tx_task);
+			queue_work(hdev->workqueue, &hdev->tx_work);
 		} else {
 			skb_queue_tail(&hdev->cmd_q, skb);
-			tasklet_schedule(&hdev->cmd_task);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
 		}
 	} else {
 		if (!capable(CAP_NET_RAW)) {
@@ -608,7 +876,7 @@
 		}
 
 		skb_queue_tail(&hdev->raw_q, skb);
-		tasklet_schedule(&hdev->tx_task);
+		queue_work(hdev->workqueue, &hdev->tx_work);
 	}
 
 	err = len;
@@ -632,6 +900,11 @@
 
 	lock_sock(sk);
 
+	if (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	switch (optname) {
 	case HCI_DATA_DIR:
 		if (get_user(opt, (int __user *)optval)) {
@@ -694,6 +967,7 @@
 		break;
 	}
 
+done:
 	release_sock(sk);
 	return err;
 }
@@ -702,11 +976,20 @@
 {
 	struct hci_ufilter uf;
 	struct sock *sk = sock->sk;
-	int len, opt;
+	int len, opt, err = 0;
+
+	BT_DBG("sk %p, opt %d", sk, optname);
 
 	if (get_user(len, optlen))
 		return -EFAULT;
 
+	lock_sock(sk);
+
+	if (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
+
 	switch (optname) {
 	case HCI_DATA_DIR:
 		if (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)
@@ -715,7 +998,7 @@
 			opt = 0;
 
 		if (put_user(opt, optval))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	case HCI_TIME_STAMP:
@@ -725,13 +1008,14 @@
 			opt = 0;
 
 		if (put_user(opt, optval))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	case HCI_FILTER:
 		{
 			struct hci_filter *f = &hci_pi(sk)->filter;
 
+			memset(&uf, 0, sizeof(uf));
 			uf.type_mask = f->type_mask;
 			uf.opcode    = f->opcode;
 			uf.event_mask[0] = *((u32 *) f->event_mask + 0);
@@ -740,15 +1024,17 @@
 
 		len = min_t(unsigned int, len, sizeof(uf));
 		if (copy_to_user(optval, &uf, len))
-			return -EFAULT;
+			err = -EFAULT;
 		break;
 
 	default:
-		return -ENOPROTOOPT;
+		err = -ENOPROTOOPT;
 		break;
 	}
 
-	return 0;
+done:
+	release_sock(sk);
+	return err;
 }
 
 static const struct proto_ops hci_sock_ops = {
@@ -806,54 +1092,12 @@
 	return 0;
 }
 
-static int hci_sock_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
-{
-	struct hci_dev *hdev = (struct hci_dev *) ptr;
-	struct hci_ev_si_device ev;
-
-	BT_DBG("hdev %s event %ld", hdev->name, event);
-
-	/* Send event to sockets */
-	ev.event  = event;
-	ev.dev_id = hdev->id;
-	hci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);
-
-	if (event == HCI_DEV_UNREG) {
-		struct sock *sk;
-		struct hlist_node *node;
-
-		/* Detach sockets from device */
-		read_lock(&hci_sk_list.lock);
-		sk_for_each(sk, node, &hci_sk_list.head) {
-			local_bh_disable();
-			bh_lock_sock_nested(sk);
-			if (hci_pi(sk)->hdev == hdev) {
-				hci_pi(sk)->hdev = NULL;
-				sk->sk_err = EPIPE;
-				sk->sk_state = BT_OPEN;
-				sk->sk_state_change(sk);
-
-				hci_dev_put(hdev);
-			}
-			bh_unlock_sock(sk);
-			local_bh_enable();
-		}
-		read_unlock(&hci_sk_list.lock);
-	}
-
-	return NOTIFY_DONE;
-}
-
 static const struct net_proto_family hci_sock_family_ops = {
 	.family	= PF_BLUETOOTH,
 	.owner	= THIS_MODULE,
 	.create	= hci_sock_create,
 };
 
-static struct notifier_block hci_sock_nblock = {
-	.notifier_call = hci_sock_dev_event
-};
-
 int __init hci_sock_init(void)
 {
 	int err;
@@ -866,8 +1110,6 @@
 	if (err < 0)
 		goto error;
 
-	hci_register_notifier(&hci_sock_nblock);
-
 	BT_INFO("HCI socket layer initialized");
 
 	return 0;
@@ -883,10 +1125,5 @@
 	if (bt_sock_unregister(BTPROTO_HCI) < 0)
 		BT_ERR("HCI socket unregistration failed");
 
-	hci_unregister_notifier(&hci_sock_nblock);
-
 	proto_unregister(&hci_sk_proto);
 }
-
-module_param(enable_mgmt, bool, 0644);
-MODULE_PARM_DESC(enable_mgmt, "Enable Management interface");
diff -urN flo-ElementalX-5.00/net/bluetooth/hci_sysfs.c flo-ElementalX-5.00-patched/net/bluetooth/hci_sysfs.c
--- flo-ElementalX-5.00/net/bluetooth/hci_sysfs.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hci_sysfs.c	2016-06-02 00:28:55.000000000 +0000
@@ -5,7 +5,6 @@
 #include <linux/init.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -25,6 +24,8 @@
 		return "SCO";
 	case ESCO_LINK:
 		return "eSCO";
+	case LE_LINK:
+		return "LE";
 	default:
 		return "UNKNOWN";
 	}
@@ -32,19 +33,19 @@
 
 static ssize_t show_link_type(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 	return sprintf(buf, "%s\n", link_typetostr(conn->type));
 }
 
 static ssize_t show_link_address(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 	return sprintf(buf, "%s\n", batostr(&conn->dst));
 }
 
 static ssize_t show_link_features(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_conn *conn = dev_get_drvdata(dev);
+	struct hci_conn *conn = to_hci_conn(dev);
 
 	return sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 				conn->features[0], conn->features[1],
@@ -78,8 +79,8 @@
 
 static void bt_link_release(struct device *dev)
 {
-	void *data = dev_get_drvdata(dev);
-	kfree(data);
+	struct hci_conn *conn = to_hci_conn(dev);
+	kfree(conn);
 }
 
 static struct device_type bt_link = {
@@ -88,14 +89,36 @@
 	.release = bt_link_release,
 };
 
-static void add_conn(struct work_struct *work)
+/*
+ * The rfcomm tty device will possibly retain even when conn
+ * is down, and sysfs doesn't support move zombie device,
+ * so we should move the device before conn device is destroyed.
+ */
+static int __match_tty(struct device *dev, void *data)
+{
+	return !strncmp(dev_name(dev), "rfcomm", 6);
+}
+
+void hci_conn_init_sysfs(struct hci_conn *conn)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work_add);
 	struct hci_dev *hdev = conn->hdev;
 
-	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
+	BT_DBG("conn %p", conn);
+
+	conn->dev.type = &bt_link;
+	conn->dev.class = bt_class;
+	conn->dev.parent = &hdev->dev;
+
+	device_initialize(&conn->dev);
+}
+
+void hci_conn_add_sysfs(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p", conn);
 
-	dev_set_drvdata(&conn->dev, conn);
+	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
 
 	if (device_add(&conn->dev) < 0) {
 		BT_ERR("Failed to register connection device");
@@ -105,19 +128,8 @@
 	hci_dev_hold(hdev);
 }
 
-/*
- * The rfcomm tty device will possibly retain even when conn
- * is down, and sysfs doesn't support move zombie device,
- * so we should move the device before conn device is destroyed.
- */
-static int __match_tty(struct device *dev, void *data)
-{
-	return !strncmp(dev_name(dev), "rfcomm", 6);
-}
-
-static void del_conn(struct work_struct *work)
+void hci_conn_del_sysfs(struct hci_conn *conn)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work_del);
 	struct hci_dev *hdev = conn->hdev;
 
 	if (!device_is_registered(&conn->dev))
@@ -139,37 +151,6 @@
 	hci_dev_put(hdev);
 }
 
-void hci_conn_init_sysfs(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p", conn);
-
-	conn->dev.type = &bt_link;
-	conn->dev.class = bt_class;
-	conn->dev.parent = &hdev->dev;
-
-	device_initialize(&conn->dev);
-
-	INIT_WORK(&conn->work_add, add_conn);
-	INIT_WORK(&conn->work_del, del_conn);
-}
-
-void hci_conn_add_sysfs(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-
-	queue_work(conn->hdev->workqueue, &conn->work_add);
-}
-
-void hci_conn_del_sysfs(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-
-	if (conn->hdev)
-		queue_work(conn->hdev->workqueue, &conn->work_del);
-}
-
 static inline char *host_bustostr(int bus)
 {
 	switch (bus) {
@@ -206,19 +187,19 @@
 
 static ssize_t show_bus(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", host_bustostr(hdev->bus));
 }
 
 static ssize_t show_type(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", host_typetostr(hdev->dev_type));
 }
 
 static ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	char name[HCI_MAX_NAME_LENGTH + 1];
 	int i;
 
@@ -231,20 +212,20 @@
 
 static ssize_t show_class(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "0x%.2x%.2x%.2x\n",
 			hdev->dev_class[2], hdev->dev_class[1], hdev->dev_class[0]);
 }
 
 static ssize_t show_address(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%s\n", batostr(&hdev->bdaddr));
 }
 
 static ssize_t show_features(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 
 	return sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 				hdev->features[0], hdev->features[1],
@@ -255,31 +236,31 @@
 
 static ssize_t show_manufacturer(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->manufacturer);
 }
 
 static ssize_t show_hci_version(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->hci_ver);
 }
 
 static ssize_t show_hci_revision(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->hci_rev);
 }
 
 static ssize_t show_idle_timeout(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->idle_timeout);
 }
 
 static ssize_t store_idle_timeout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	unsigned int val;
 	int rv;
 
@@ -297,13 +278,13 @@
 
 static ssize_t show_sniff_max_interval(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->sniff_max_interval);
 }
 
 static ssize_t store_sniff_max_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	u16 val;
 	int rv;
 
@@ -321,13 +302,13 @@
 
 static ssize_t show_sniff_min_interval(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	return sprintf(buf, "%d\n", hdev->sniff_min_interval);
 }
 
 static ssize_t store_sniff_min_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct hci_dev *hdev = dev_get_drvdata(dev);
+	struct hci_dev *hdev = to_hci_dev(dev);
 	u16 val;
 	int rv;
 
@@ -387,8 +368,9 @@
 
 static void bt_host_release(struct device *dev)
 {
-	void *data = dev_get_drvdata(dev);
-	kfree(data);
+	struct hci_dev *hdev = to_hci_dev(dev);
+	kfree(hdev);
+	module_put(THIS_MODULE);
 }
 
 static struct device_type bt_host = {
@@ -400,12 +382,12 @@
 static int inquiry_cache_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct inquiry_cache *cache = &hdev->inq_cache;
+	struct discovery_state *cache = &hdev->discovery;
 	struct inquiry_entry *e;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	for (e = cache->list; e; e = e->next) {
+	list_for_each_entry(e, &cache->all, all) {
 		struct inquiry_data *data = &e->data;
 		seq_printf(f, "%s %d %d %d 0x%.2x%.2x%.2x 0x%.4x %d %d %u\n",
 			   batostr(&data->bdaddr),
@@ -416,7 +398,7 @@
 			   data->rssi, data->ssp_mode, e->timestamp);
 	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -436,19 +418,14 @@
 static int blacklist_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct list_head *l;
-
-	hci_dev_lock_bh(hdev);
-
-	list_for_each(l, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	struct bdaddr_list *b;
 
-		b = list_entry(l, struct bdaddr_list, list);
+	hci_dev_lock(hdev);
 
+	list_for_each_entry(b, &hdev->blacklist, list)
 		seq_printf(f, "%s\n", batostr(&b->bdaddr));
-	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -485,19 +462,14 @@
 static int uuids_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct list_head *l;
-
-	hci_dev_lock_bh(hdev);
-
-	list_for_each(l, &hdev->uuids) {
-		struct bt_uuid *uuid;
+	struct bt_uuid *uuid;
 
-		uuid = list_entry(l, struct bt_uuid, list);
+	hci_dev_lock(hdev);
 
+	list_for_each_entry(uuid, &hdev->uuids, list)
 		print_bt_uuid(f, uuid->uuid);
-	}
 
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
@@ -514,22 +486,57 @@
 	.release	= single_release,
 };
 
-int hci_register_sysfs(struct hci_dev *hdev)
+static int auto_accept_delay_set(void *data, u64 val)
+{
+	struct hci_dev *hdev = data;
+
+	hci_dev_lock(hdev);
+
+	hdev->auto_accept_delay = val;
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+static int auto_accept_delay_get(void *data, u64 *val)
+{
+	struct hci_dev *hdev = data;
+
+	hci_dev_lock(hdev);
+
+	*val = hdev->auto_accept_delay;
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(auto_accept_delay_fops, auto_accept_delay_get,
+					auto_accept_delay_set, "%llu\n");
+
+void hci_init_sysfs(struct hci_dev *hdev)
+{
+	struct device *dev = &hdev->dev;
+
+	dev->type = &bt_host;
+	dev->class = bt_class;
+
+	__module_get(THIS_MODULE);
+	device_initialize(dev);
+}
+
+int hci_add_sysfs(struct hci_dev *hdev)
 {
 	struct device *dev = &hdev->dev;
 	int err;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	dev->type = &bt_host;
-	dev->class = bt_class;
 	dev->parent = hdev->parent;
-
 	dev_set_name(dev, "%s", hdev->name);
 
-	dev_set_drvdata(dev, hdev);
-
-	err = device_register(dev);
+	err = device_add(dev);
 	if (err < 0)
 		return err;
 
@@ -548,10 +555,12 @@
 
 	debugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);
 
+	debugfs_create_file("auto_accept_delay", 0444, hdev->debugfs, hdev,
+						&auto_accept_delay_fops);
 	return 0;
 }
 
-void hci_unregister_sysfs(struct hci_dev *hdev)
+void hci_del_sysfs(struct hci_dev *hdev)
 {
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/core.c flo-ElementalX-5.00-patched/net/bluetooth/hidp/core.c
--- flo-ElementalX-5.00/net/bluetooth/hidp/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    HIDP implementation for Linux Bluetooth stack (BlueZ).
    Copyright (C) 2003-2004 Marcel Holtmann <marcel@holtmann.org>
-   Copyright (c) 2012 The Linux Foundation.  All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -22,7 +21,6 @@
 */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -38,6 +36,8 @@
 #include <linux/file.h>
 #include <linux/init.h>
 #include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/kthread.h>
 #include <net/sock.h>
 
 #include <linux/input.h>
@@ -81,31 +81,27 @@
 static struct hidp_session *__hidp_get_session(bdaddr_t *bdaddr)
 {
 	struct hidp_session *session;
-	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each(p, &hidp_session_list) {
-		session = list_entry(p, struct hidp_session, list);
+	list_for_each_entry(session, &hidp_session_list, list) {
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
 	}
+
 	return NULL;
 }
 
 static void __hidp_link_session(struct hidp_session *session)
 {
-	__module_get(THIS_MODULE);
 	list_add(&session->list, &hidp_session_list);
 }
 
 static void __hidp_unlink_session(struct hidp_session *session)
 {
-	if (session->conn)
-		hci_conn_put_device(session->conn);
+	hci_conn_put_device(session->conn);
 
 	list_del(&session->list);
-	module_put(THIS_MODULE);
 }
 
 static void __hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)
@@ -254,6 +250,9 @@
 
 	BT_DBG("session %p data %p size %d", session, data, size);
 
+	if (atomic_read(&session->terminate))
+		return -EIO;
+
 	skb = alloc_skb(size + 1, GFP_ATOMIC);
 	if (!skb) {
 		BT_ERR("Can't allocate memory for new frame");
@@ -319,24 +318,143 @@
 	return hidp_queue_report(session, buf, rsize);
 }
 
+static int hidp_get_raw_report(struct hid_device *hid,
+		unsigned char report_number,
+		unsigned char *data, size_t count,
+		unsigned char report_type)
+{
+	struct hidp_session *session = hid->driver_data;
+	struct sk_buff *skb;
+	size_t len;
+	int numbered_reports = hid->report_enum[report_type].numbered;
+	int ret;
+
+	switch (report_type) {
+	case HID_FEATURE_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_FEATURE;
+		break;
+	case HID_INPUT_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_INPUT;
+		break;
+	case HID_OUTPUT_REPORT:
+		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_OUPUT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (mutex_lock_interruptible(&session->report_mutex))
+		return -ERESTARTSYS;
+
+	/* Set up our wait, and send the report request to the device. */
+	session->waiting_report_type = report_type & HIDP_DATA_RTYPE_MASK;
+	session->waiting_report_number = numbered_reports ? report_number : -1;
+	set_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	data[0] = report_number;
+	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data, 1);
+	if (ret)
+		goto err;
+
+	/* Wait for the return of the report. The returned report
+	   gets put in session->report_return.  */
+	while (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags)) {
+		int res;
+
+		res = wait_event_interruptible_timeout(session->report_queue,
+			!test_bit(HIDP_WAITING_FOR_RETURN, &session->flags),
+			5*HZ);
+		if (res == 0) {
+			/* timeout */
+			ret = -EIO;
+			goto err;
+		}
+		if (res < 0) {
+			/* signal */
+			ret = -ERESTARTSYS;
+			goto err;
+		}
+	}
+
+	skb = session->report_return;
+	if (skb) {
+		len = skb->len < count ? skb->len : count;
+		memcpy(data, skb->data, len);
+
+		kfree_skb(skb);
+		session->report_return = NULL;
+	} else {
+		/* Device returned a HANDSHAKE, indicating  protocol error. */
+		len = -EIO;
+	}
+
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	mutex_unlock(&session->report_mutex);
+
+	return len;
+
+err:
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	mutex_unlock(&session->report_mutex);
+	return ret;
+}
+
 static int hidp_output_raw_report(struct hid_device *hid, unsigned char *data, size_t count,
 		unsigned char report_type)
 {
+	struct hidp_session *session = hid->driver_data;
+	int ret;
+
 	switch (report_type) {
 	case HID_FEATURE_REPORT:
 		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_FEATURE;
 		break;
 	case HID_OUTPUT_REPORT:
-		report_type = HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT;
+		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_OUPUT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (hidp_send_ctrl_message(hid->driver_data, report_type,
-			data, count))
-		return -ENOMEM;
-	return count;
+	if (mutex_lock_interruptible(&session->report_mutex))
+		return -ERESTARTSYS;
+
+	/* Set up our wait, and send the report request to the device. */
+	set_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data,
+									count);
+	if (ret)
+		goto err;
+
+	/* Wait for the ACK from the device. */
+	while (test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags)) {
+		int res;
+
+		res = wait_event_interruptible_timeout(session->report_queue,
+			!test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags),
+			10*HZ);
+		if (res == 0) {
+			/* timeout */
+			ret = -EIO;
+			goto err;
+		}
+		if (res < 0) {
+			/* signal */
+			ret = -ERESTARTSYS;
+			goto err;
+		}
+	}
+
+	if (!session->output_report_success) {
+		ret = -EIO;
+		goto err;
+	}
+
+	ret = count;
+
+err:
+	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	mutex_unlock(&session->report_mutex);
+	return ret;
 }
 
 static void hidp_idle_timeout(unsigned long arg)
@@ -344,7 +462,7 @@
 	struct hidp_session *session = (struct hidp_session *) arg;
 
 	atomic_inc(&session->terminate);
-	hidp_schedule(session);
+	wake_up_process(session->task);
 }
 
 static void hidp_set_timer(struct hidp_session *session)
@@ -363,16 +481,21 @@
 					unsigned char param)
 {
 	BT_DBG("session %p param 0x%02x", session, param);
+	session->output_report_success = 0; /* default condition */
 
 	switch (param) {
 	case HIDP_HSHK_SUCCESSFUL:
 		/* FIXME: Call into SET_ GET_ handlers here */
+		session->output_report_success = 1;
 		break;
 
 	case HIDP_HSHK_NOT_READY:
 	case HIDP_HSHK_ERR_INVALID_REPORT_ID:
 	case HIDP_HSHK_ERR_UNSUPPORTED_REQUEST:
 	case HIDP_HSHK_ERR_INVALID_PARAMETER:
+		if (test_and_clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags))
+			wake_up_interruptible(&session->report_queue);
+
 		/* FIXME: Call into SET_ GET_ handlers here */
 		break;
 
@@ -391,6 +514,10 @@
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 		break;
 	}
+
+	/* Wake up the waiting thread. */
+	if (test_and_clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags))
+		wake_up_interruptible(&session->report_queue);
 }
 
 static void hidp_process_hid_control(struct hidp_session *session,
@@ -403,15 +530,16 @@
 		skb_queue_purge(&session->ctrl_transmit);
 		skb_queue_purge(&session->intr_transmit);
 
-		/* Kill session thread */
 		atomic_inc(&session->terminate);
-		hidp_schedule(session);
+		wake_up_process(current);
 	}
 }
 
-static void hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
+/* Returns true if the passed-in skb should be freed by the caller. */
+static int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
 				unsigned char param)
 {
+	int done_with_skb = 1;
 	BT_DBG("session %p skb %p len %d param 0x%02x", session, skb, skb->len, param);
 
 	switch (param) {
@@ -423,7 +551,6 @@
 
 		if (session->hid)
 			hid_input_report(session->hid, HID_INPUT_REPORT, skb->data, skb->len, 0);
-
 		break;
 
 	case HIDP_DATA_RTYPE_OTHER:
@@ -435,12 +562,27 @@
 		__hidp_send_ctrl_message(session,
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 	}
+
+	if (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags) &&
+				param == session->waiting_report_type) {
+		if (session->waiting_report_number < 0 ||
+		    session->waiting_report_number == skb->data[0]) {
+			/* hidp_get_raw_report() is waiting on this report. */
+			session->report_return = skb;
+			done_with_skb = 0;
+			clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+			wake_up_interruptible(&session->report_queue);
+		}
+	}
+
+	return done_with_skb;
 }
 
 static void hidp_recv_ctrl_frame(struct hidp_session *session,
 					struct sk_buff *skb)
 {
 	unsigned char hdr, type, param;
+	int free_skb = 1;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
 
@@ -460,7 +602,7 @@
 		break;
 
 	case HIDP_TRANS_DATA:
-		hidp_process_data(session, skb, param);
+		free_skb = hidp_process_data(session, skb, param);
 		break;
 
 	default:
@@ -469,7 +611,8 @@
 		break;
 	}
 
-	kfree_skb(skb);
+	if (free_skb)
+		kfree_skb(skb);
 }
 
 static void hidp_recv_intr_frame(struct hidp_session *session,
@@ -514,25 +657,32 @@
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
 
-static void hidp_process_transmit(struct hidp_session *session)
+static void hidp_process_intr_transmit(struct hidp_session *session)
 {
 	struct sk_buff *skb;
 
 	BT_DBG("session %p", session);
 
-	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
-		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->ctrl_transmit, skb);
+	while ((skb = skb_dequeue(&session->intr_transmit))) {
+		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->intr_transmit, skb);
 			break;
 		}
 
 		hidp_set_timer(session);
 		kfree_skb(skb);
 	}
+}
 
-	while ((skb = skb_dequeue(&session->intr_transmit))) {
-		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->intr_transmit, skb);
+static void hidp_process_ctrl_transmit(struct hidp_session *session)
+{
+	struct sk_buff *skb;
+
+	BT_DBG("session %p", session);
+
+	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
+		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->ctrl_transmit, skb);
 			break;
 		}
 
@@ -547,59 +697,56 @@
 	struct sock *ctrl_sk = session->ctrl_sock->sk;
 	struct sock *intr_sk = session->intr_sock->sk;
 	struct sk_buff *skb;
-	int vendor = 0x0000, product = 0x0000;
 	wait_queue_t ctrl_wait, intr_wait;
 
 	BT_DBG("session %p", session);
 
-	if (session->input) {
-		vendor  = session->input->id.vendor;
-		product = session->input->id.product;
-	}
-
-	if (session->hid) {
-		vendor  = session->hid->vendor;
-		product = session->hid->product;
-	}
-
-	daemonize("khidpd_%04x%04x", vendor, product);
+	__module_get(THIS_MODULE);
 	set_user_nice(current, -15);
 
 	init_waitqueue_entry(&ctrl_wait, current);
 	init_waitqueue_entry(&intr_wait, current);
 	add_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 	add_wait_queue(sk_sleep(intr_sk), &intr_wait);
+	session->waiting_for_startup = 0;
+	wake_up_interruptible(&session->startup_queue);
+	set_current_state(TASK_INTERRUPTIBLE);
 	while (!atomic_read(&session->terminate)) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
 		if (ctrl_sk->sk_state != BT_CONNECTED ||
 				intr_sk->sk_state != BT_CONNECTED)
 			break;
 
-		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
+		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_ctrl_frame(session, skb);
+				hidp_recv_intr_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
+		hidp_process_intr_transmit(session);
+
+		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_intr_frame(session, skb);
+				hidp_recv_ctrl_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		hidp_process_transmit(session);
+		hidp_process_ctrl_transmit(session);
 
 		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(intr_sk), &intr_wait);
 	remove_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 
+	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
+	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
+	wake_up_interruptible(&session->report_queue);
+
 	down_write(&hidp_session_sem);
 
 	hidp_del_timer(session);
@@ -631,7 +778,9 @@
 
 	up_write(&hidp_session_sem);
 
+	kfree(session->rd_data);
 	kfree(session);
+	module_put_and_exit(0);
 	return 0;
 }
 
@@ -646,11 +795,11 @@
 	if (!hdev)
 		return NULL;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (conn)
 		hci_conn_hold_device(conn);
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	hci_dev_put(hdev);
 
@@ -661,7 +810,7 @@
 				struct hidp_connadd_req *req)
 {
 	struct input_dev *input;
-	int err, i;
+	int i;
 
 	input = input_allocate_device();
 	if (!input)
@@ -708,12 +857,6 @@
 
 	input->event = hidp_input_event;
 
-	err = input_register_device(input);
-	if (err < 0) {
-		hci_conn_put_device(session->conn);
-		return err;
-	}
-
 	return 0;
 }
 
@@ -739,6 +882,9 @@
 	struct hidp_session *session = hid->driver_data;
 	struct hid_report *report;
 
+	if (hid->quirks & HID_QUIRK_NO_INIT_REPORTS)
+		return 0;
+
 	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].
 			report_list, list)
 		hidp_send_report(session, report);
@@ -769,6 +915,8 @@
 	.hidinput_input_event = hidp_hidinput_event,
 };
 
+/* This function sets up the hid device. It does not add it
+   to the HID system. That is done in hidp_add_connection(). */
 static int hidp_setup_hid(struct hidp_session *session,
 				struct hidp_connadd_req *req)
 {
@@ -801,25 +949,18 @@
 	hid->version = req->version;
 	hid->country = req->country;
 
-	strncpy(hid->name, req->name, 128);
+	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 	strncpy(hid->phys, batostr(&bt_sk(session->ctrl_sock->sk)->src), 64);
 	strncpy(hid->uniq, batostr(&bt_sk(session->ctrl_sock->sk)->dst), 64);
 
 	hid->dev.parent = &session->conn->dev;
 	hid->ll_driver = &hidp_hid_driver;
 
+	hid->hid_get_raw_report = hidp_get_raw_report;
 	hid->hid_output_raw_report = hidp_output_raw_report;
 
-	err = hid_add_device(hid);
-	if (err < 0)
-		goto failed;
-
 	return 0;
 
-failed:
-	hid_destroy_device(hid);
-	session->hid = NULL;
-
 fault:
 	kfree(session->rd_data);
 	session->rd_data = NULL;
@@ -830,6 +971,7 @@
 int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock, struct socket *intr_sock)
 {
 	struct hidp_session *session, *s;
+	int vendor, product;
 	int err;
 
 	BT_DBG("");
@@ -838,24 +980,28 @@
 			bacmp(&bt_sk(ctrl_sock->sk)->dst, &bt_sk(intr_sock->sk)->dst))
 		return -ENOTUNIQ;
 
-	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
-	if (!session)
-		return -ENOMEM;
-
 	BT_DBG("rd_data %p rd_size %d", req->rd_data, req->rd_size);
 
 	down_write(&hidp_session_sem);
 
 	s = __hidp_get_session(&bt_sk(ctrl_sock->sk)->dst);
 	if (s && s->state == BT_CONNECTED) {
-		err = -EEXIST;
-		goto failed;
+		up_write(&hidp_session_sem);
+		return -EEXIST;
+	}
+
+	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
+	if (!session) {
+		up_write(&hidp_session_sem);
+		return -ENOMEM;
 	}
 
 	bacpy(&session->bdaddr, &bt_sk(ctrl_sock->sk)->dst);
 
-	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->omtu, l2cap_pi(ctrl_sock->sk)->imtu);
-	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->omtu, l2cap_pi(intr_sock->sk)->imtu);
+	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->chan->omtu,
+					l2cap_pi(ctrl_sock->sk)->chan->imtu);
+	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->chan->omtu,
+					l2cap_pi(intr_sock->sk)->chan->imtu);
 
 	BT_DBG("ctrl mtu %d intr mtu %d", session->ctrl_mtu, session->intr_mtu);
 
@@ -874,6 +1020,10 @@
 	skb_queue_head_init(&session->ctrl_transmit);
 	skb_queue_head_init(&session->intr_transmit);
 
+	mutex_init(&session->report_mutex);
+	init_waitqueue_head(&session->report_queue);
+	init_waitqueue_head(&session->startup_queue);
+	session->waiting_for_startup = 1;
 	session->flags   = req->flags & (1 << HIDP_BLUETOOTH_VENDOR_ID);
 	session->idle_to = req->idle_to;
 
@@ -881,7 +1031,7 @@
 
 	if (req->rd_size > 0) {
 		err = hidp_setup_hid(session, req);
-		if (err && err != -ENODEV)
+		if (err)
 			goto purge;
 	}
 
@@ -893,9 +1043,40 @@
 
 	hidp_set_timer(session);
 
-	err = kernel_thread(hidp_session, session, CLONE_KERNEL);
-	if (err < 0)
+	if (session->hid) {
+		vendor  = session->hid->vendor;
+		product = session->hid->product;
+	} else if (session->input) {
+		vendor  = session->input->id.vendor;
+		product = session->input->id.product;
+	} else {
+		vendor = 0x0000;
+		product = 0x0000;
+	}
+
+	session->task = kthread_run(hidp_session, session, "khidpd_%04x%04x",
+							vendor, product);
+	if (IS_ERR(session->task)) {
+		err = PTR_ERR(session->task);
 		goto unlink;
+	}
+
+	while (session->waiting_for_startup) {
+		wait_event_interruptible(session->startup_queue,
+			!session->waiting_for_startup);
+	}
+
+	if (session->hid)
+		err = hid_add_device(session->hid);
+	else
+		err = input_register_device(session->input);
+
+	if (err < 0) {
+		atomic_inc(&session->terminate);
+		wake_up_process(session->task);
+		up_write(&hidp_session_sem);
+		return err;
+	}
 
 	if (session->input) {
 		hidp_send_ctrl_message(session,
@@ -934,7 +1115,6 @@
 failed:
 	up_write(&hidp_session_sem);
 
-	input_free_device(session->input);
 	kfree(session);
 	return err;
 }
@@ -958,13 +1138,8 @@
 			skb_queue_purge(&session->ctrl_transmit);
 			skb_queue_purge(&session->intr_transmit);
 
-			/* Wakeup user-space polling for socket errors */
-			session->intr_sock->sk->sk_err = EUNATCH;
-			session->ctrl_sock->sk->sk_err = EUNATCH;
-
-			/* Kill session thread */
 			atomic_inc(&session->terminate);
-			hidp_schedule(session);
+			wake_up_process(session->task);
 		}
 	} else
 		err = -ENOENT;
@@ -975,19 +1150,16 @@
 
 int hidp_get_connlist(struct hidp_connlist_req *req)
 {
-	struct list_head *p;
+	struct hidp_session *session;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&hidp_session_sem);
 
-	list_for_each(p, &hidp_session_list) {
-		struct hidp_session *session;
+	list_for_each_entry(session, &hidp_session_list, list) {
 		struct hidp_conninfo ci;
 
-		session = list_entry(p, struct hidp_session, list);
-
 		__hidp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/hidp.h flo-ElementalX-5.00-patched/net/bluetooth/hidp/hidp.h
--- flo-ElementalX-5.00/net/bluetooth/hidp/hidp.h	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/hidp.h	2016-06-02 00:28:55.000000000 +0000
@@ -80,6 +80,8 @@
 #define HIDP_VIRTUAL_CABLE_UNPLUG	0
 #define HIDP_BOOT_PROTOCOL_MODE		1
 #define HIDP_BLUETOOTH_VENDOR_ID	9
+#define HIDP_WAITING_FOR_RETURN		10
+#define HIDP_WAITING_FOR_SEND_ACK	11
 
 struct hidp_connadd_req {
 	int   ctrl_sock;	/* Connected control socket */
@@ -141,6 +143,7 @@
 	uint intr_mtu;
 
 	atomic_t terminate;
+	struct task_struct *task;
 
 	unsigned char keys[8];
 	unsigned char leds;
@@ -154,9 +157,22 @@
 	struct sk_buff_head ctrl_transmit;
 	struct sk_buff_head intr_transmit;
 
+	/* Used in hidp_get_raw_report() */
+	int waiting_report_type; /* HIDP_DATA_RTYPE_* */
+	int waiting_report_number; /* -1 for not numbered */
+	struct mutex report_mutex;
+	struct sk_buff *report_return;
+	wait_queue_head_t report_queue;
+
+	/* Used in hidp_output_raw_report() */
+	int output_report_success; /* boolean */
+
 	/* Report descriptor */
 	__u8 *rd_data;
 	uint rd_size;
+
+	wait_queue_head_t startup_queue;
+	int waiting_for_startup;
 };
 
 static inline void hidp_schedule(struct hidp_session *session)
diff -urN flo-ElementalX-5.00/net/bluetooth/hidp/sock.c flo-ElementalX-5.00-patched/net/bluetooth/hidp/sock.c
--- flo-ElementalX-5.00/net/bluetooth/hidp/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/hidp/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -160,10 +160,10 @@
 {
 	if (cmd == HIDPGETCONNLIST) {
 		struct hidp_connlist_req cl;
-		uint32_t uci;
+		u32 uci;
 		int err;
 
-		if (get_user(cl.cnum, (uint32_t __user *) arg) ||
+		if (get_user(cl.cnum, (u32 __user *) arg) ||
 				get_user(uci, (u32 __user *) (arg + 4)))
 			return -EFAULT;
 
@@ -174,7 +174,7 @@
 
 		err = hidp_get_connlist(&cl);
 
-		if (!err && put_user(cl.cnum, (uint32_t __user *) arg))
+		if (!err && put_user(cl.cnum, (u32 __user *) arg))
 			err = -EFAULT;
 
 		return err;
diff -urN flo-ElementalX-5.00/net/bluetooth/l2cap_core.c flo-ElementalX-5.00-patched/net/bluetooth/l2cap_core.c
--- flo-ElementalX-5.00/net/bluetooth/l2cap_core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/l2cap_core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,8 +1,9 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -46,544 +47,340 @@
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/crc16.h>
-#include <linux/math64.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
-#include <net/bluetooth/amp.h>
 
 bool disable_ertm;
-bool enable_hs;
-bool enable_reconfig;
 
 static u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;
-static u8 l2cap_fc_mask = L2CAP_FC_L2CAP;
+static u8 l2cap_fixed_chan[8] = { L2CAP_FC_L2CAP, };
 
-struct workqueue_struct *_l2cap_wq;
-
-struct bt_sock_list l2cap_sk_list = {
-	.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)
-};
-
-static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id);
-static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u16 result);
-static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
-			u16 icid, u16 result);
-
-static void l2cap_amp_move_setup(struct sock *sk);
-static void l2cap_amp_move_success(struct sock *sk);
-static void l2cap_amp_move_revert(struct sock *sk);
-
-static int l2cap_ertm_rx_queued_iframes(struct sock *sk);
+static LIST_HEAD(chan_list);
+static DEFINE_RWLOCK(chan_list_lock);
 
 static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
 				u8 code, u8 ident, u16 dlen, void *data);
-static int l2cap_answer_move_poll(struct sock *sk);
-static int l2cap_create_cfm(struct hci_chan *chan, u8 status);
-static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi);
-static void l2cap_chan_ready(struct sock *sk);
-static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process);
-static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l);
-static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to);
-static void l2cap_queue_acl_data(struct work_struct *worker);
-static struct att_channel_parameters{
-	struct sk_buff *skb;
-	struct l2cap_conn *conn;
-	__le16 cid;
-	int dir;
-} att_chn_params;
+static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
+								void *data);
+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);
+static void l2cap_send_disconn_req(struct l2cap_conn *conn,
+				struct l2cap_chan *chan, int err);
 
 /* ---- L2CAP channels ---- */
-static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)
+
+static struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->dcid == cid)
-			break;
+	struct l2cap_chan *c;
+
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->dcid == cid)
+			return c;
 	}
-	return s;
+	return NULL;
 }
 
-/* Find channel with given DCID.
- * Returns locked socket */
-static inline struct sock *l2cap_get_chan_by_dcid(struct l2cap_chan_list *l,
-						u16 cid)
+static struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_dcid(l, cid);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
+	struct l2cap_chan *c;
 
-static struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->scid == cid)
-			break;
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->scid == cid)
+			return c;
 	}
-	return s;
+	return NULL;
 }
 
 /* Find channel with given SCID.
  * Returns locked socket */
-static inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
+static struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
 {
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_scid(l, cid);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
+	struct l2cap_chan *c;
 
-static struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->ident == ident)
-			break;
-	}
-	return s;
-}
+	mutex_lock(&conn->chan_lock);
+	c = __l2cap_get_chan_by_scid(conn, cid);
+	mutex_unlock(&conn->chan_lock);
 
-static inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_ident(l, ident);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
+	return c;
 }
 
-static inline struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,
-						u16 seq)
+static struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
 {
-	struct sk_buff *skb;
+	struct l2cap_chan *c;
 
-	skb_queue_walk(head, skb) {
-		if (bt_cb(skb)->control.txseq == seq)
-			return skb;
+	list_for_each_entry(c, &conn->chan_l, list) {
+		if (c->ident == ident)
+			return c;
 	}
-
 	return NULL;
 }
 
-static int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)
+static inline struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
 {
-	u16 allocSize = 1;
-	int err = 0;
-	int i;
+	struct l2cap_chan *c;
 
-	/* Actual allocated size must be a power of 2 */
-	while (allocSize && allocSize <= size)
-		allocSize <<= 1;
-	if (!allocSize)
-		return -ENOMEM;
-
-	seq_list->list = kzalloc(sizeof(u16) * allocSize, GFP_ATOMIC);
-	if (!seq_list->list)
-		return -ENOMEM;
-
-	seq_list->size = allocSize;
-	seq_list->mask = allocSize - 1;
-	seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-	seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-	for (i = 0; i < allocSize; i++)
-		seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
+	mutex_lock(&conn->chan_lock);
+	c = __l2cap_get_chan_by_ident(conn, ident);
+	mutex_unlock(&conn->chan_lock);
 
-	return err;
+	return c;
 }
 
-static inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)
+static struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src)
 {
-	kfree(seq_list->list);
-}
+	struct l2cap_chan *c;
 
-static inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,
-					u16 seq)
-{
-	return seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;
+	list_for_each_entry(c, &chan_list, global_l) {
+		if (c->sport == psm && !bacmp(&bt_sk(c->sk)->src, src))
+			return c;
+	}
+	return NULL;
 }
 
-static u16 l2cap_seq_list_remove(struct l2cap_seq_list *seq_list, u16 seq)
+int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)
 {
-	u16 mask = seq_list->mask;
+	int err;
 
-	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
+	write_lock(&chan_list_lock);
 
-	if (seq_list->head == L2CAP_SEQ_LIST_CLEAR) {
-		/* In case someone tries to pop the head of an empty list */
-		BT_DBG("List empty");
-		return L2CAP_SEQ_LIST_CLEAR;
-	} else if (seq_list->head == seq) {
-		/* Head can be removed quickly */
-		BT_DBG("Remove head");
-		seq_list->head = seq_list->list[seq & mask];
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
+	if (psm && __l2cap_global_chan_by_addr(psm, src)) {
+		err = -EADDRINUSE;
+		goto done;
+	}
 
-		if (seq_list->head == L2CAP_SEQ_LIST_TAIL) {
-			seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-			seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-		}
+	if (psm) {
+		chan->psm = psm;
+		chan->sport = psm;
+		err = 0;
 	} else {
-		/* Non-head item must be found first */
-		u16 prev = seq_list->head;
-		BT_DBG("Find and remove");
-		while (seq_list->list[prev & mask] != seq) {
-			prev = seq_list->list[prev & mask];
-			if (prev == L2CAP_SEQ_LIST_TAIL) {
-				BT_DBG("seq %d not in list", (int) seq);
-				return L2CAP_SEQ_LIST_CLEAR;
-			}
-		}
+		u16 p;
 
-		seq_list->list[prev & mask] = seq_list->list[seq & mask];
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
-		if (seq_list->tail == seq)
-			seq_list->tail = prev;
+		err = -EINVAL;
+		for (p = 0x1001; p < 0x1100; p += 2)
+			if (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src)) {
+				chan->psm   = cpu_to_le16(p);
+				chan->sport = cpu_to_le16(p);
+				err = 0;
+				break;
+			}
 	}
-	return seq;
-}
-
-static inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)
-{
-	return l2cap_seq_list_remove(seq_list, seq_list->head);
-}
-
-static void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)
-{
-	if (seq_list->head != L2CAP_SEQ_LIST_CLEAR) {
-		u16 i;
-		for (i = 0; i < seq_list->size; i++)
-			seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
 
-		seq_list->head = L2CAP_SEQ_LIST_CLEAR;
-		seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
-	}
+done:
+	write_unlock(&chan_list_lock);
+	return err;
 }
 
-static void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)
+int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)
 {
-	u16 mask = seq_list->mask;
+	write_lock(&chan_list_lock);
 
-	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
+	chan->scid = scid;
 
-	if (seq_list->list[seq & mask] == L2CAP_SEQ_LIST_CLEAR) {
-		if (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)
-			seq_list->head = seq;
-		else
-			seq_list->list[seq_list->tail & mask] = seq;
+	write_unlock(&chan_list_lock);
 
-		seq_list->tail = seq;
-		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;
-	}
+	return 0;
 }
 
-static u16 __pack_enhanced_control(struct bt_l2cap_control *control)
+static u16 l2cap_alloc_cid(struct l2cap_conn *conn)
 {
-	u16 packed;
-
-	packed = (control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT) &
-		L2CAP_CTRL_REQSEQ;
-	packed |= (control->final << L2CAP_CTRL_FINAL_SHIFT) &
-		L2CAP_CTRL_FINAL;
+	u16 cid = L2CAP_CID_DYN_START;
 
-	if (control->frame_type == 's') {
-		packed |= (control->poll << L2CAP_CTRL_POLL_SHIFT) &
-			L2CAP_CTRL_POLL;
-		packed |= (control->super << L2CAP_CTRL_SUPERVISE_SHIFT) &
-			L2CAP_CTRL_SUPERVISE;
-		packed |= L2CAP_CTRL_FRAME_TYPE;
-	} else {
-		packed |= (control->sar << L2CAP_CTRL_SAR_SHIFT) &
-			L2CAP_CTRL_SAR;
-		packed |= (control->txseq << L2CAP_CTRL_TXSEQ_SHIFT) &
-			L2CAP_CTRL_TXSEQ;
+	for (; cid < L2CAP_CID_DYN_END; cid++) {
+		if (!__l2cap_get_chan_by_scid(conn, cid))
+			return cid;
 	}
 
-	return packed;
+	return 0;
 }
 
-static void __get_enhanced_control(u16 enhanced,
-					struct bt_l2cap_control *control)
+static void __l2cap_state_change(struct l2cap_chan *chan, int state)
 {
-	control->reqseq = (enhanced & L2CAP_CTRL_REQSEQ) >>
-		L2CAP_CTRL_REQSEQ_SHIFT;
-	control->final = (enhanced & L2CAP_CTRL_FINAL) >>
-		L2CAP_CTRL_FINAL_SHIFT;
+	BT_DBG("chan %p %s -> %s", chan, state_to_string(chan->state),
+						state_to_string(state));
 
-	if (enhanced & L2CAP_CTRL_FRAME_TYPE) {
-		control->frame_type = 's';
-		control->poll = (enhanced & L2CAP_CTRL_POLL) >>
-			L2CAP_CTRL_POLL_SHIFT;
-		control->super = (enhanced & L2CAP_CTRL_SUPERVISE) >>
-			L2CAP_CTRL_SUPERVISE_SHIFT;
-
-		control->sar = 0;
-		control->txseq = 0;
-	} else {
-		control->frame_type = 'i';
-		control->sar = (enhanced & L2CAP_CTRL_SAR) >>
-			L2CAP_CTRL_SAR_SHIFT;
-		control->txseq = (enhanced & L2CAP_CTRL_TXSEQ) >>
-			L2CAP_CTRL_TXSEQ_SHIFT;
-
-		control->poll = 0;
-		control->super = 0;
-	}
+	chan->state = state;
+	chan->ops->state_change(chan->data, state);
 }
 
-static u32 __pack_extended_control(struct bt_l2cap_control *control)
+static void l2cap_state_change(struct l2cap_chan *chan, int state)
 {
-	u32 packed;
+	struct sock *sk = chan->sk;
 
-	packed = (control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
-		L2CAP_EXT_CTRL_REQSEQ;
-	packed |= (control->final << L2CAP_EXT_CTRL_FINAL_SHIFT) &
-		L2CAP_EXT_CTRL_FINAL;
-
-	if (control->frame_type == 's') {
-		packed |= (control->poll << L2CAP_EXT_CTRL_POLL_SHIFT) &
-			L2CAP_EXT_CTRL_POLL;
-		packed |= (control->super << L2CAP_EXT_CTRL_SUPERVISE_SHIFT) &
-			L2CAP_EXT_CTRL_SUPERVISE;
-		packed |= L2CAP_EXT_CTRL_FRAME_TYPE;
-	} else {
-		packed |= (control->sar << L2CAP_EXT_CTRL_SAR_SHIFT) &
-			L2CAP_EXT_CTRL_SAR;
-		packed |= (control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
-			L2CAP_EXT_CTRL_TXSEQ;
-	}
-
-	return packed;
+	lock_sock(sk);
+	__l2cap_state_change(chan, state);
+	release_sock(sk);
 }
 
-static void __get_extended_control(u32 extended,
-				struct bt_l2cap_control *control)
+static inline void __l2cap_chan_set_err(struct l2cap_chan *chan, int err)
 {
-	control->reqseq = (extended & L2CAP_EXT_CTRL_REQSEQ) >>
-		L2CAP_EXT_CTRL_REQSEQ_SHIFT;
-	control->final = (extended & L2CAP_EXT_CTRL_FINAL) >>
-		L2CAP_EXT_CTRL_FINAL_SHIFT;
-
-	if (extended & L2CAP_EXT_CTRL_FRAME_TYPE) {
-		control->frame_type = 's';
-		control->poll = (extended & L2CAP_EXT_CTRL_POLL) >>
-			L2CAP_EXT_CTRL_POLL_SHIFT;
-		control->super = (extended & L2CAP_EXT_CTRL_SUPERVISE) >>
-			L2CAP_EXT_CTRL_SUPERVISE_SHIFT;
-
-		control->sar = 0;
-		control->txseq = 0;
-	} else {
-		control->frame_type = 'i';
-		control->sar = (extended & L2CAP_EXT_CTRL_SAR) >>
-			L2CAP_EXT_CTRL_SAR_SHIFT;
-		control->txseq = (extended & L2CAP_EXT_CTRL_TXSEQ) >>
-			L2CAP_EXT_CTRL_TXSEQ_SHIFT;
+	struct sock *sk = chan->sk;
 
-		control->poll = 0;
-		control->super = 0;
-	}
+	sk->sk_err = err;
 }
 
-static inline void l2cap_ertm_stop_ack_timer(struct l2cap_pinfo *pi)
+static inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)
 {
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->ack_work);
-}
+	struct sock *sk = chan->sk;
 
-static inline void l2cap_ertm_start_ack_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p, pending %d", pi, delayed_work_pending(&pi->ack_work));
-	if (!delayed_work_pending(&pi->ack_work)) {
-		queue_delayed_work(_l2cap_wq, &pi->ack_work,
-				msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
-	}
+	lock_sock(sk);
+	__l2cap_chan_set_err(chan, err);
+	release_sock(sk);
 }
 
-static inline void l2cap_ertm_stop_retrans_timer(struct l2cap_pinfo *pi)
+static void l2cap_chan_timeout(struct work_struct *work)
 {
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->retrans_work);
-}
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							chan_timer.work);
+	struct l2cap_conn *conn = chan->conn;
+	int reason;
+
+	BT_DBG("chan %p state %s", chan, state_to_string(chan->state));
+
+	mutex_lock(&conn->chan_lock);
+	l2cap_chan_lock(chan);
+
+	if (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)
+		reason = ECONNREFUSED;
+	else if (chan->state == BT_CONNECT &&
+					chan->sec_level != BT_SECURITY_SDP)
+		reason = ECONNREFUSED;
+	else
+		reason = ETIMEDOUT;
 
-static inline void l2cap_ertm_start_retrans_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	if (!delayed_work_pending(&pi->monitor_work) && pi->retrans_timeout) {
-		__cancel_delayed_work(&pi->retrans_work);
-		queue_delayed_work(_l2cap_wq, &pi->retrans_work,
-			msecs_to_jiffies(pi->retrans_timeout));
-	}
-}
+	l2cap_chan_close(chan, reason);
 
-static inline void l2cap_ertm_stop_monitor_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	__cancel_delayed_work(&pi->monitor_work);
-}
+	l2cap_chan_unlock(chan);
 
-static inline void l2cap_ertm_start_monitor_timer(struct l2cap_pinfo *pi)
-{
-	BT_DBG("pi %p", pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	__cancel_delayed_work(&pi->monitor_work);
-	if (pi->monitor_timeout) {
-		queue_delayed_work(_l2cap_wq, &pi->monitor_work,
-				msecs_to_jiffies(pi->monitor_timeout));
-	}
+	chan->ops->close(chan->data);
+	mutex_unlock(&conn->chan_lock);
+
+	l2cap_chan_put(chan);
 }
 
-static u16 l2cap_alloc_cid(struct l2cap_chan_list *l)
+struct l2cap_chan *l2cap_chan_create(struct sock *sk)
 {
-	u16 cid = L2CAP_CID_DYN_START;
+	struct l2cap_chan *chan;
 
-	for (; cid < L2CAP_CID_DYN_END; cid++) {
-		if (!__l2cap_get_chan_by_scid(l, cid))
-			return cid;
-	}
+	chan = kzalloc(sizeof(*chan), GFP_ATOMIC);
+	if (!chan)
+		return NULL;
 
-	return 0;
-}
+	mutex_init(&chan->lock);
 
-static inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)
-{
-	sock_hold(sk);
+	chan->sk = sk;
 
-	if (l->head)
-		l2cap_pi(l->head)->prev_c = sk;
+	write_lock(&chan_list_lock);
+	list_add(&chan->global_l, &chan_list);
+	write_unlock(&chan_list_lock);
 
-	l2cap_pi(sk)->next_c = l->head;
-	l2cap_pi(sk)->prev_c = NULL;
-	l->head = sk;
-}
+	INIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);
 
-static inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)
-{
-	struct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;
+	chan->state = BT_OPEN;
 
-	write_lock_bh(&l->lock);
-	if (sk == l->head)
-		l->head = next;
+	atomic_set(&chan->refcnt, 1);
 
-	if (next)
-		l2cap_pi(next)->prev_c = prev;
-	if (prev)
-		l2cap_pi(prev)->next_c = next;
-	write_unlock_bh(&l->lock);
+	BT_DBG("sk %p chan %p", sk, chan);
 
-	__sock_put(sk);
+	return chan;
 }
 
-static void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
+void l2cap_chan_destroy(struct l2cap_chan *chan)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
+	write_lock(&chan_list_lock);
+	list_del(&chan->global_l);
+	write_unlock(&chan_list_lock);
+
+	l2cap_chan_put(chan);
+}
 
+void __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)
+{
 	BT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn,
-			l2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);
+			chan->psm, chan->dcid);
 
-	conn->disc_reason = 0x13;
+	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
 
-	l2cap_pi(sk)->conn = conn;
+	chan->conn = conn;
 
-	if (!l2cap_pi(sk)->fixed_channel &&
-		(sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)) {
+	switch (chan->chan_type) {
+	case L2CAP_CHAN_CONN_ORIENTED:
 		if (conn->hcon->type == LE_LINK) {
 			/* LE connection */
-			if (l2cap_pi(sk)->imtu < L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->imtu = L2CAP_LE_DEFAULT_MTU;
-			if (l2cap_pi(sk)->omtu < L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->omtu = L2CAP_LE_DEFAULT_MTU;
-
-			l2cap_pi(sk)->scid = L2CAP_CID_LE_DATA;
-			l2cap_pi(sk)->dcid = L2CAP_CID_LE_DATA;
+			chan->omtu = L2CAP_LE_DEFAULT_MTU;
+			chan->scid = L2CAP_CID_LE_DATA;
+			chan->dcid = L2CAP_CID_LE_DATA;
 		} else {
 			/* Alloc CID for connection-oriented socket */
-			l2cap_pi(sk)->scid = l2cap_alloc_cid(l);
-			l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
+			chan->scid = l2cap_alloc_cid(conn);
+			chan->omtu = L2CAP_DEFAULT_MTU;
 		}
-	} else if (sk->sk_type == SOCK_DGRAM) {
+		break;
+
+	case L2CAP_CHAN_CONN_LESS:
 		/* Connectionless socket */
-		l2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
-	} else if (sk->sk_type == SOCK_RAW) {
+		chan->scid = L2CAP_CID_CONN_LESS;
+		chan->dcid = L2CAP_CID_CONN_LESS;
+		chan->omtu = L2CAP_DEFAULT_MTU;
+		break;
+
+	default:
 		/* Raw socket can send/recv signalling messages only */
-		l2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
+		chan->scid = L2CAP_CID_SIGNALING;
+		chan->dcid = L2CAP_CID_SIGNALING;
+		chan->omtu = L2CAP_DEFAULT_MTU;
 	}
 
-	if (l2cap_get_smallest_flushto(l) > l2cap_pi(sk)->flush_to) {
-		/*if flush timeout of the channel is lesser than existing */
-		l2cap_set_acl_flushto(conn->hcon, l2cap_pi(sk)->flush_to);
-	}
-	/* Otherwise, do not set scid/dcid/omtu.  These will be set up
-	 * by l2cap_fixed_channel_config()
-	 */
+	chan->local_id		= L2CAP_BESTEFFORT_ID;
+	chan->local_stype	= L2CAP_SERV_BESTEFFORT;
+	chan->local_msdu	= L2CAP_DEFAULT_MAX_SDU_SIZE;
+	chan->local_sdu_itime	= L2CAP_DEFAULT_SDU_ITIME;
+	chan->local_acc_lat	= L2CAP_DEFAULT_ACC_LAT;
+	chan->local_flush_to	= L2CAP_DEFAULT_FLUSH_TO;
 
-	__l2cap_chan_link(l, sk);
+	l2cap_chan_hold(chan);
+
+	list_add(&chan->list, &conn->chan_l);
+}
+
+void l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)
+{
+	mutex_lock(&conn->chan_lock);
+	__l2cap_chan_add(conn, chan);
+	mutex_unlock(&conn->chan_lock);
 }
 
-/* Delete channel.
- * Must be called on the locked socket. */
-void l2cap_chan_del(struct sock *sk, int err)
+static void l2cap_chan_del(struct l2cap_chan *chan, int err)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct sock *sk = chan->sk;
+	struct l2cap_conn *conn = chan->conn;
 	struct sock *parent = bt_sk(sk)->parent;
 
-	l2cap_sock_clear_timer(sk);
+	__clear_chan_timer(chan);
 
-	BT_DBG("sk %p, conn %p, err %d", sk, conn, err);
+	BT_DBG("chan %p, conn %p, err %d", chan, conn, err);
 
 	if (conn) {
-		struct l2cap_chan_list *l = &conn->chan_list;
-		/* Unlink from channel list */
-		l2cap_chan_unlink(l, sk);
-		l2cap_pi(sk)->conn = NULL;
-		if (!l2cap_pi(sk)->fixed_channel)
-			hci_conn_put(conn->hcon);
-
-		read_lock(&l->lock);
-		if (l2cap_pi(sk)->flush_to < l2cap_get_smallest_flushto(l))
-			l2cap_set_acl_flushto(conn->hcon,
-				l2cap_get_smallest_flushto(l));
-		read_unlock(&l->lock);
-	}
-
-	if (l2cap_pi(sk)->ampchan) {
-		struct hci_chan *ampchan = l2cap_pi(sk)->ampchan;
-		struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
-		l2cap_pi(sk)->ampchan = NULL;
-		l2cap_pi(sk)->ampcon = NULL;
-		l2cap_pi(sk)->amp_id = 0;
-		if (hci_chan_put(ampchan))
-			ampcon->l2cap_data = NULL;
-		else
-			l2cap_deaggregate(ampchan, l2cap_pi(sk));
+		/* Delete from channel list */
+		list_del(&chan->list);
+
+		l2cap_chan_put(chan);
+
+		chan->conn = NULL;
+		hci_conn_put(conn->hcon);
 	}
 
-	sk->sk_state = BT_CLOSED;
+	lock_sock(sk);
+
+	__l2cap_state_change(chan, BT_CLOSED);
 	sock_set_flag(sk, SOCK_ZAPPED);
 
 	if (err)
-		sk->sk_err = err;
+		__l2cap_chan_set_err(chan, err);
 
 	if (parent) {
 		bt_accept_unlink(sk);
@@ -591,26 +388,118 @@
 	} else
 		sk->sk_state_change(sk);
 
-	sk->sk_send_head = NULL;
-	skb_queue_purge(TX_QUEUE(sk));
+	release_sock(sk);
+
+	if (!(test_bit(CONF_OUTPUT_DONE, &chan->conf_state) &&
+			test_bit(CONF_INPUT_DONE, &chan->conf_state)))
+		return;
+
+	skb_queue_purge(&chan->tx_q);
+
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		struct srej_list *l, *tmp;
+
+		__clear_retrans_timer(chan);
+		__clear_monitor_timer(chan);
+		__clear_ack_timer(chan);
+
+		skb_queue_purge(&chan->srej_q);
 
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		if (l2cap_pi(sk)->sdu)
-			kfree_skb(l2cap_pi(sk)->sdu);
+		list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
+			list_del(&l->list);
+			kfree(l);
+		}
+	}
+}
+
+static void l2cap_chan_cleanup_listen(struct sock *parent)
+{
+	struct sock *sk;
+
+	BT_DBG("parent %p", parent);
+
+	/* Close not yet accepted channels */
+	while ((sk = bt_accept_dequeue(parent, NULL))) {
+		struct l2cap_chan *chan = l2cap_pi(sk)->chan;
+
+		l2cap_chan_lock(chan);
+		__clear_chan_timer(chan);
+		l2cap_chan_close(chan, ECONNRESET);
+		l2cap_chan_unlock(chan);
+
+		chan->ops->close(chan->data);
+	}
+}
+
+void l2cap_chan_close(struct l2cap_chan *chan, int reason)
+{
+	struct l2cap_conn *conn = chan->conn;
+	struct sock *sk = chan->sk;
+
+	BT_DBG("chan %p state %s sk %p", chan,
+					state_to_string(chan->state), sk);
+
+	switch (chan->state) {
+	case BT_LISTEN:
+		lock_sock(sk);
+		l2cap_chan_cleanup_listen(sk);
+
+		__l2cap_state_change(chan, BT_CLOSED);
+		sock_set_flag(sk, SOCK_ZAPPED);
+		release_sock(sk);
+		break;
+
+	case BT_CONNECTED:
+	case BT_CONFIG:
+		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
+					conn->hcon->type == ACL_LINK) {
+			__clear_chan_timer(chan);
+			__set_chan_timer(chan, sk->sk_sndtimeo);
+			l2cap_send_disconn_req(conn, chan, reason);
+		} else
+			l2cap_chan_del(chan, reason);
+		break;
+
+	case BT_CONNECT2:
+		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
+					conn->hcon->type == ACL_LINK) {
+			struct l2cap_conn_rsp rsp;
+			__u16 result;
+
+			if (bt_sk(sk)->defer_setup)
+				result = L2CAP_CR_SEC_BLOCK;
+			else
+				result = L2CAP_CR_BAD_PSM;
+			l2cap_state_change(chan, BT_DISCONN);
+
+			rsp.scid   = cpu_to_le16(chan->dcid);
+			rsp.dcid   = cpu_to_le16(chan->scid);
+			rsp.result = cpu_to_le16(result);
+			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
+		}
+
+		l2cap_chan_del(chan, reason);
+		break;
 
-		skb_queue_purge(SREJ_QUEUE(sk));
+	case BT_CONNECT:
+	case BT_DISCONN:
+		l2cap_chan_del(chan, reason);
+		break;
 
-		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
+	default:
+		lock_sock(sk);
+		sock_set_flag(sk, SOCK_ZAPPED);
+		release_sock(sk);
+		break;
 	}
 }
 
-static inline u8 l2cap_get_auth_type(struct sock *sk)
+static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
 {
-	if (sk->sk_type == SOCK_RAW) {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_VERY_HIGH:
+	if (chan->chan_type == L2CAP_CHAN_RAW) {
+		switch (chan->sec_level) {
 		case BT_SECURITY_HIGH:
 			return HCI_AT_DEDICATED_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -618,18 +507,16 @@
 		default:
 			return HCI_AT_NO_BONDING;
 		}
-	} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
+	} else if (chan->psm == cpu_to_le16(0x0001)) {
+		if (chan->sec_level == BT_SECURITY_LOW)
+			chan->sec_level = BT_SECURITY_SDP;
 
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
-			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
+		if (chan->sec_level == BT_SECURITY_HIGH)
 			return HCI_AT_NO_BONDING_MITM;
 		else
 			return HCI_AT_NO_BONDING;
 	} else {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_VERY_HIGH:
+		switch (chan->sec_level) {
 		case BT_SECURITY_HIGH:
 			return HCI_AT_GENERAL_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -641,18 +528,17 @@
 }
 
 /* Service level security */
-static inline int l2cap_check_security(struct sock *sk)
+int l2cap_chan_check_security(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	__u8 auth_type;
 
-	auth_type = l2cap_get_auth_type(sk);
+	auth_type = l2cap_get_auth_type(chan);
 
-	return hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,
-								auth_type);
+	return hci_conn_security(conn->hcon, chan->sec_level, auth_type);
 }
 
-u8 l2cap_get_ident(struct l2cap_conn *conn)
+static u8 l2cap_get_ident(struct l2cap_conn *conn)
 {
 	u8 id;
 
@@ -662,118 +548,150 @@
 	 *  200 - 254 are used by utilities like l2ping, etc.
 	 */
 
-	spin_lock_bh(&conn->lock);
+	spin_lock(&conn->lock);
 
 	if (++conn->tx_ident > 128)
 		conn->tx_ident = 1;
 
 	id = conn->tx_ident;
 
-	spin_unlock_bh(&conn->lock);
+	spin_unlock(&conn->lock);
 
 	return id;
 }
 
-static void apply_fcs(struct sk_buff *skb)
+static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
 {
-	size_t len;
-	u16 partial_crc;
-	struct sk_buff *iter;
-	struct sk_buff *final_frag = skb;
+	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
+	u8 flags;
+
+	BT_DBG("code 0x%2.2x", code);
+
+	if (!skb)
+		return;
 
-	if (skb_has_frag_list(skb))
-		len = skb_headlen(skb);
+	if (lmp_no_flush_capable(conn->hcon->hdev))
+		flags = ACL_START_NO_FLUSH;
 	else
-		len = skb->len - L2CAP_FCS_SIZE;
+		flags = ACL_START;
 
-	partial_crc = crc16(0, (u8 *) skb->data, len);
+	bt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;
+	skb->priority = HCI_PRIO_MAX;
 
-	skb_walk_frags(skb, iter) {
-		len = iter->len;
-		if (!iter->next)
-			len -= L2CAP_FCS_SIZE;
+	hci_send_acl(conn->hchan, skb, flags);
+}
 
-		partial_crc = crc16(partial_crc, iter->data, len);
-		final_frag = iter;
-	}
+static void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)
+{
+	struct hci_conn *hcon = chan->conn->hcon;
+	u16 flags;
+
+	BT_DBG("chan %p, skb %p len %d priority %u", chan, skb, skb->len,
+							skb->priority);
+
+	if (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&
+					lmp_no_flush_capable(hcon->hdev))
+		flags = ACL_START_NO_FLUSH;
+	else
+		flags = ACL_START;
 
-	put_unaligned_le16(partial_crc,
-		final_frag->data + final_frag->len - L2CAP_FCS_SIZE);
+	bt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+	hci_send_acl(chan->conn->hchan, skb, flags);
 }
 
-void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
+static inline void l2cap_send_sframe(struct l2cap_chan *chan, u32 control)
 {
-	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
-	u8 flags;
+	struct sk_buff *skb;
+	struct l2cap_hdr *lh;
+	struct l2cap_conn *conn = chan->conn;
+	int count, hlen;
 
-	BT_DBG("code 0x%2.2x", code);
+	if (chan->state != BT_CONNECTED)
+		return;
+
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hlen = L2CAP_EXT_HDR_SIZE;
+	else
+		hlen = L2CAP_ENH_HDR_SIZE;
+
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		hlen += L2CAP_FCS_SIZE;
 
+	BT_DBG("chan %p, control 0x%8.8x", chan, control);
+
+	count = min_t(unsigned int, conn->mtu, hlen);
+
+	control |= __set_sframe(chan);
+
+	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+		control |= __set_ctrl_final(chan);
+
+	if (test_and_clear_bit(CONN_SEND_PBIT, &chan->conn_state))
+		control |= __set_ctrl_poll(chan);
+
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
 	if (!skb)
 		return;
 
-	if (conn->hcon == NULL || conn->hcon->hdev == NULL)
-		return;
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);
+	lh->cid = cpu_to_le16(chan->dcid);
 
-	if (lmp_no_flush_capable(conn->hcon->hdev))
-		flags = ACL_START_NO_FLUSH;
-	else
-		flags = ACL_START;
+	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
 
-	bt_cb(skb)->force_active = 1;
+	if (chan->fcs == L2CAP_FCS_CRC16) {
+		u16 fcs = crc16(0, (u8 *)lh, count - L2CAP_FCS_SIZE);
+		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
+	}
 
-	hci_send_acl(conn->hcon, NULL, skb, flags);
+	skb->priority = HCI_PRIO_MAX;
+	l2cap_do_send(chan, skb);
 }
 
-static inline int __l2cap_no_conn_pending(struct sock *sk)
+static inline void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, u32 control)
 {
-	return !(l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND);
-}
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+	} else
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
 
-static void l2cap_send_conn_req(struct sock *sk)
-{
-	struct l2cap_conn_req req;
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-	req.psm  = l2cap_pi(sk)->psm;
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
+	l2cap_send_sframe(chan, control);
+}
 
-	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-			L2CAP_CONN_REQ, sizeof(req), &req);
+static inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)
+{
+	return !test_bit(CONF_CONNECT_PEND, &chan->conf_state);
 }
 
-static void l2cap_send_create_chan_req(struct sock *sk, u8 amp_id)
+static void l2cap_send_conn_req(struct l2cap_chan *chan)
 {
-	struct l2cap_create_chan_req req;
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-	req.psm  = l2cap_pi(sk)->psm;
-	req.amp_id = amp_id;
+	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn_req req;
+
+	req.scid = cpu_to_le16(chan->scid);
+	req.psm  = chan->psm;
 
-	l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
-	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
+	chan->ident = l2cap_get_ident(conn);
 
-	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-			L2CAP_CREATE_CHAN_REQ, sizeof(req), &req);
+	set_bit(CONF_CONNECT_PEND, &chan->conf_state);
+
+	l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);
 }
 
-static void l2cap_do_start(struct sock *sk)
+static void l2cap_do_start(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 
 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
 		if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
 			return;
 
-		if (l2cap_check_security(sk) && __l2cap_no_conn_pending(sk)) {
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-
-			if (l2cap_pi(sk)->amp_pref ==
-					BT_AMP_POLICY_PREFER_AMP &&
-					enable_hs &&
-					conn->fc_mask & L2CAP_FC_A2MP)
-				amp_create_physical(conn, sk);
-			else
-				l2cap_send_conn_req(sk);
-		}
+		if (l2cap_chan_check_security(chan) &&
+				__l2cap_no_conn_pending(chan))
+			l2cap_send_conn_req(chan);
 	} else {
 		struct l2cap_info_req req;
 		req.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
@@ -781,8 +699,7 @@
 		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
 		conn->info_ident = l2cap_get_ident(conn);
 
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
+		schedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);
 
 		l2cap_send_cmd(conn, conn->info_ident,
 					L2CAP_INFO_REQ, sizeof(req), &req);
@@ -805,91 +722,75 @@
 	}
 }
 
-void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err)
+static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err)
 {
+	struct sock *sk = chan->sk;
 	struct l2cap_disconn_req req;
 
 	if (!conn)
 		return;
 
-	sk->sk_send_head = NULL;
-	skb_queue_purge(TX_QUEUE(sk));
-
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		skb_queue_purge(SREJ_QUEUE(sk));
-
-		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		__clear_retrans_timer(chan);
+		__clear_monitor_timer(chan);
+		__clear_ack_timer(chan);
 	}
 
-	req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
+	req.dcid = cpu_to_le16(chan->dcid);
+	req.scid = cpu_to_le16(chan->scid);
 	l2cap_send_cmd(conn, l2cap_get_ident(conn),
 			L2CAP_DISCONN_REQ, sizeof(req), &req);
 
-	sk->sk_state = BT_DISCONN;
-	sk->sk_err = err;
+	lock_sock(sk);
+	__l2cap_state_change(chan, BT_DISCONN);
+	__l2cap_chan_set_err(chan, err);
+	release_sock(sk);
 }
 
 /* ---- L2CAP connections ---- */
 static void l2cap_conn_start(struct l2cap_conn *conn)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock_del_list del, *tmp1, *tmp2;
-	struct sock *sk;
+	struct l2cap_chan *chan, *tmp;
 
 	BT_DBG("conn %p", conn);
 
-	INIT_LIST_HEAD(&del.list);
+	mutex_lock(&conn->chan_lock);
 
-	read_lock(&l->lock);
+	list_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {
+		struct sock *sk = chan->sk;
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
+		l2cap_chan_lock(chan);
 
-		if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-			bh_unlock_sock(sk);
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (sk->sk_state == BT_CONNECT) {
-			if (!l2cap_check_security(sk) ||
-					!__l2cap_no_conn_pending(sk)) {
-				bh_unlock_sock(sk);
+		if (chan->state == BT_CONNECT) {
+			if (!l2cap_chan_check_security(chan) ||
+					!__l2cap_no_conn_pending(chan)) {
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			if (!l2cap_mode_supported(l2cap_pi(sk)->mode,
-					conn->feat_mask)
-					&& l2cap_pi(sk)->conf_state &
-					L2CAP_CONF_STATE2_DEVICE) {
-				tmp1 = kzalloc(sizeof(struct sock_del_list),
-						GFP_ATOMIC);
-				tmp1->sk = sk;
-				list_add_tail(&tmp1->list, &del.list);
-				bh_unlock_sock(sk);
+			if (!l2cap_mode_supported(chan->mode, conn->feat_mask)
+					&& test_bit(CONF_STATE2_DEVICE,
+					&chan->conf_state)) {
+				l2cap_chan_close(chan, ECONNRESET);
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
+			l2cap_send_conn_req(chan);
 
-			if (l2cap_pi(sk)->amp_pref ==
-					BT_AMP_POLICY_PREFER_AMP &&
-					enable_hs &&
-					conn->fc_mask & L2CAP_FC_A2MP)
-				amp_create_physical(conn, sk);
-			else
-				l2cap_send_conn_req(sk);
-
-		} else if (sk->sk_state == BT_CONNECT2) {
+		} else if (chan->state == BT_CONNECT2) {
 			struct l2cap_conn_rsp rsp;
 			char buf[128];
-			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+			rsp.scid = cpu_to_le16(chan->dcid);
+			rsp.dcid = cpu_to_le16(chan->scid);
 
-			if (l2cap_check_security(sk)) {
+			if (l2cap_chan_check_security(chan)) {
+				lock_sock(sk);
 				if (bt_sk(sk)->defer_setup) {
 					struct sock *parent = bt_sk(sk)->parent;
 					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
@@ -898,133 +799,86 @@
 						parent->sk_data_ready(parent, 0);
 
 				} else {
-					sk->sk_state = BT_CONFIG;
+					__l2cap_state_change(chan, BT_CONFIG);
 					rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
 					rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
 				}
+				release_sock(sk);
 			} else {
 				rsp.result = cpu_to_le16(L2CAP_CR_PEND);
 				rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);
 			}
 
-			if (rsp.result == cpu_to_le16(L2CAP_CR_SUCCESS) &&
-					l2cap_pi(sk)->amp_id) {
-				amp_accept_physical(conn,
-						l2cap_pi(sk)->amp_id, sk);
-				bh_unlock_sock(sk);
-				continue;
-			}
-
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
 
-			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT ||
+			if (test_bit(CONF_REQ_SENT, &chan->conf_state) ||
 					rsp.result != L2CAP_CR_SUCCESS) {
-				bh_unlock_sock(sk);
+				l2cap_chan_unlock(chan);
 				continue;
 			}
 
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+			set_bit(CONF_REQ_SENT, &chan->conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-						l2cap_build_conf_req(sk, buf), buf);
-			l2cap_pi(sk)->num_conf_req++;
+						l2cap_build_conf_req(chan, buf), buf);
+			chan->num_conf_req++;
 		}
 
-		bh_unlock_sock(sk);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	list_for_each_entry_safe(tmp1, tmp2, &del.list, list) {
-		bh_lock_sock(tmp1->sk);
-		__l2cap_sock_close(tmp1->sk, ECONNRESET);
-		bh_unlock_sock(tmp1->sk);
-		list_del(&tmp1->list);
-		kfree(tmp1);
-	}
+	mutex_unlock(&conn->chan_lock);
 }
 
-/* Find socket with fixed cid with given source and destination bdaddrs.
- * Direction of the req/rsp must match.
+/* Find socket with cid and source bdaddr.
+ * Returns closest match, locked.
  */
-struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
-						bdaddr_t *dst, int incoming)
+static struct l2cap_chan *l2cap_global_chan_by_scid(int state, __le16 cid, bdaddr_t *src)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
+	struct l2cap_chan *c, *c1 = NULL;
 
-	BT_DBG(" %d", incoming);
+	read_lock(&chan_list_lock);
 
-	read_lock(&l2cap_sk_list.lock);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-
-		if (incoming && !l2cap_pi(sk)->incoming)
-			continue;
-
-		if (!incoming && l2cap_pi(sk)->incoming)
+		if (state && c->state != state)
 			continue;
 
-		if (l2cap_pi(sk)->scid == cid && !bacmp(&bt_sk(sk)->dst, dst)) {
+		if (c->scid == cid) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
+			if (!bacmp(&bt_sk(sk)->src, src)) {
+				read_unlock(&chan_list_lock);
+				return c;
+			}
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
+				c1 = c;
 		}
 	}
 
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
-	return node ? sk : sk1;
+	return c1;
 }
 
-/* Find socket with cid and source bdaddr.
- * Returns closest match, locked.
- */
-static struct sock *l2cap_get_sock_by_scid(int state, __le16 cid, bdaddr_t *src)
+static void l2cap_le_conn_ready(struct l2cap_conn *conn)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
-
-	read_lock(&l2cap_sk_list.lock);
+	struct sock *parent, *sk;
+	struct l2cap_chan *chan, *pchan;
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (state && sk->sk_state != state)
-			continue;
-
-		if (l2cap_pi(sk)->scid == cid) {
-			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
-
-			/* Closest match */
-			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
-		}
-	}
-
-	read_unlock(&l2cap_sk_list.lock);
-
-	return node ? sk : sk1;
-}
-
-static void l2cap_le_conn_ready(struct l2cap_conn *conn)
-{
-	struct l2cap_chan_list *list = &conn->chan_list;
-	struct sock *parent, *uninitialized_var(sk);
-
-	BT_DBG("");
+	BT_DBG("");
 
 	/* Check if we have socket listening on cid */
-	parent = l2cap_get_sock_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
+	pchan = l2cap_global_chan_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
 							conn->src);
-	if (!parent)
+	if (!pchan)
 		return;
 
-	bh_lock_sock(parent);
+	parent = pchan->sk;
+
+	lock_sock(parent);
 
 	/* Check for backlog size */
 	if (sk_acceptq_is_full(parent)) {
@@ -1032,101 +886,115 @@
 		goto clean;
 	}
 
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
-	if (!sk)
+	chan = pchan->ops->new_connection(pchan->data);
+	if (!chan)
 		goto clean;
 
-	write_lock_bh(&list->lock);
+	sk = chan->sk;
 
 	hci_conn_hold(conn->hcon);
+	conn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;
 
-	l2cap_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, conn->src);
 	bacpy(&bt_sk(sk)->dst, conn->dst);
-	l2cap_pi(sk)->incoming = 1;
 
 	bt_accept_enqueue(parent, sk);
 
-	__l2cap_chan_add(conn, sk);
+	l2cap_chan_add(conn, chan);
 
-	sk->sk_state = BT_CONNECTED;
-	parent->sk_data_ready(parent, 0);
+	__set_chan_timer(chan, sk->sk_sndtimeo);
 
-	write_unlock_bh(&list->lock);
+	__l2cap_state_change(chan, BT_CONNECTED);
+	parent->sk_data_ready(parent, 0);
 
 clean:
-	bh_unlock_sock(parent);
+	release_sock(parent);
+}
+
+static void l2cap_chan_ready(struct l2cap_chan *chan)
+{
+	struct sock *sk = chan->sk;
+	struct sock *parent;
+
+	lock_sock(sk);
+
+	parent = bt_sk(sk)->parent;
+
+	BT_DBG("sk %p, parent %p", sk, parent);
+
+	chan->conf_state = 0;
+	__clear_chan_timer(chan);
+
+	__l2cap_state_change(chan, BT_CONNECTED);
+	sk->sk_state_change(sk);
+
+	if (parent)
+		parent->sk_data_ready(parent, 0);
+
+	release_sock(sk);
 }
 
 static void l2cap_conn_ready(struct l2cap_conn *conn)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
+	struct l2cap_chan *chan;
+	struct hci_conn *hcon = conn->hcon;
 
 	BT_DBG("conn %p", conn);
 
-	if (!conn->hcon->out && conn->hcon->type == LE_LINK)
+	if (!hcon->out && hcon->type == LE_LINK)
 		l2cap_le_conn_ready(conn);
 
-	read_lock(&l->lock);
+	if (hcon->out && hcon->type == LE_LINK)
+		smp_conn_security(hcon, hcon->pending_sec_level);
 
-	if (l->head) {
-		for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-			bh_lock_sock(sk);
+	mutex_lock(&conn->chan_lock);
 
-			if (conn->hcon->type == LE_LINK) {
-				u8 sec_level = l2cap_pi(sk)->sec_level;
-				u8 pending_sec = conn->hcon->pending_sec_level;
+	list_for_each_entry(chan, &conn->chan_l, list) {
 
-				if (pending_sec > sec_level)
-					sec_level = pending_sec;
+		l2cap_chan_lock(chan);
 
-				if (smp_conn_security(conn, sec_level))
-					l2cap_chan_ready(sk);
+		if (hcon->type == LE_LINK) {
+			if (smp_conn_security(hcon, chan->sec_level))
+				l2cap_chan_ready(chan);
 
-				hci_conn_put(conn->hcon);
+		} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			struct sock *sk = chan->sk;
+			__clear_chan_timer(chan);
+			lock_sock(sk);
+			__l2cap_state_change(chan, BT_CONNECTED);
+			sk->sk_state_change(sk);
+			release_sock(sk);
 
-			} else if (sk->sk_type != SOCK_SEQPACKET &&
-					sk->sk_type != SOCK_STREAM) {
-				l2cap_sock_clear_timer(sk);
-				sk->sk_state = BT_CONNECTED;
-				sk->sk_state_change(sk);
-			} else if (sk->sk_state == BT_CONNECT)
-				l2cap_do_start(sk);
+		} else if (chan->state == BT_CONNECT)
+			l2cap_do_start(chan);
 
-			bh_unlock_sock(sk);
-		}
-	} else if (conn->hcon->type == LE_LINK) {
-		smp_conn_security(conn, BT_SECURITY_HIGH);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	if (conn->hcon->out && conn->hcon->type == LE_LINK)
-		l2cap_le_conn_ready(conn);
+	mutex_unlock(&conn->chan_lock);
 }
 
 /* Notify sockets that we cannot guaranty reliability anymore */
 static void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)
 {
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
+	struct l2cap_chan *chan;
 
 	BT_DBG("conn %p", conn);
 
-	read_lock(&l->lock);
+	mutex_lock(&conn->chan_lock);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (l2cap_pi(sk)->force_reliable)
-			sk->sk_err = err;
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
+			__l2cap_chan_set_err(chan, err);
 	}
 
-	read_unlock(&l->lock);
+	mutex_unlock(&conn->chan_lock);
 }
 
-static void l2cap_info_timeout(unsigned long arg)
+static void l2cap_info_timeout(struct work_struct *work)
 {
-	struct l2cap_conn *conn = (void *) arg;
+	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
+							info_timer.work);
 
 	conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
 	conn->info_ident = 0;
@@ -1134,21 +1002,78 @@
 	l2cap_conn_start(conn);
 }
 
+static void l2cap_conn_del(struct hci_conn *hcon, int err)
+{
+	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct l2cap_chan *chan, *l;
+
+	if (!conn)
+		return;
+
+	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
+
+	kfree_skb(conn->rx_skb);
+
+	mutex_lock(&conn->chan_lock);
+
+	/* Kill channels */
+	list_for_each_entry_safe(chan, l, &conn->chan_l, list) {
+		l2cap_chan_lock(chan);
+
+		l2cap_chan_del(chan, err);
+
+		l2cap_chan_unlock(chan);
+
+		chan->ops->close(chan->data);
+	}
+
+	mutex_unlock(&conn->chan_lock);
+
+	hci_chan_del(conn->hchan);
+
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
+		cancel_delayed_work_sync(&conn->info_timer);
+
+	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags)) {
+		cancel_delayed_work_sync(&conn->security_timer);
+		smp_chan_destroy(conn);
+	}
+
+	hcon->l2cap_data = NULL;
+	kfree(conn);
+}
+
+static void security_timeout(struct work_struct *work)
+{
+	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
+						security_timer.work);
+
+	l2cap_conn_del(conn->hcon, ETIMEDOUT);
+}
+
 static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct hci_chan *hchan;
 
 	if (conn || status)
 		return conn;
 
+	hchan = hci_chan_create(hcon);
+	if (!hchan)
+		return NULL;
+
 	conn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);
-	if (!conn)
+	if (!conn) {
+		hci_chan_del(hchan);
 		return NULL;
+	}
 
 	hcon->l2cap_data = conn;
 	conn->hcon = hcon;
+	conn->hchan = hchan;
 
-	BT_DBG("hcon %p conn %p", hcon, conn);
+	BT_DBG("hcon %p conn %p hchan %p", hcon, conn, hchan);
 
 	if (hcon->hdev->le_mtu && hcon->type == LE_LINK)
 		conn->mtu = hcon->hdev->le_mtu;
@@ -1161,112 +1086,59 @@
 	conn->feat_mask = 0;
 
 	spin_lock_init(&conn->lock);
-	rwlock_init(&conn->chan_list.lock);
+	mutex_init(&conn->chan_lock);
+
+	INIT_LIST_HEAD(&conn->chan_l);
 
 	if (hcon->type == LE_LINK)
-		setup_timer(&hcon->smp_timer, smp_timeout,
-						(unsigned long) conn);
+		INIT_DELAYED_WORK(&conn->security_timer, security_timeout);
 	else
-		setup_timer(&conn->info_timer, l2cap_info_timeout,
-						(unsigned long) conn);
+		INIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);
 
-	conn->disc_reason = 0x13;
+	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
 
 	return conn;
 }
 
-static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-	struct sock *next;
-
-	if (!conn)
-		return;
-
-	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
-
-	if ((conn->hcon == hcon) && (conn->rx_skb))
-		kfree_skb(conn->rx_skb);
-
-	BT_DBG("conn->hcon %p", conn->hcon);
-
-	/* Kill channels */
-	for (sk = conn->chan_list.head; sk; ) {
-		BT_DBG("ampcon %p", l2cap_pi(sk)->ampcon);
-		if ((conn->hcon == hcon) || (l2cap_pi(sk)->ampcon == hcon)) {
-			next = l2cap_pi(sk)->next_c;
-			if (is_process)
-				lock_sock(sk);
-			else
-				bh_lock_sock(sk);
-			l2cap_chan_del(sk, err);
-			if (is_process)
-				release_sock(sk);
-			else
-				bh_unlock_sock(sk);
-			l2cap_sock_kill(sk);
-			sk = next;
-		} else
-			sk = l2cap_pi(sk)->next_c;
-	}
-
-	if (conn->hcon == hcon) {
-		if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
-			del_timer_sync(&conn->info_timer);
-
-		hcon->l2cap_data = NULL;
-
-		kfree(conn);
-	}
-	att_chn_params.conn = NULL;
-	BT_DBG("att_chn_params.conn set to NULL");
-}
-
-static inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	write_lock_bh(&l->lock);
-	__l2cap_chan_add(conn, sk);
-	write_unlock_bh(&l->lock);
-}
-
 /* ---- Socket interface ---- */
 
 /* Find socket with psm and source bdaddr.
  * Returns closest match.
  */
-static struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)
+static struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm, bdaddr_t *src)
 {
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
+	struct l2cap_chan *c, *c1 = NULL;
 
-	read_lock(&l2cap_sk_list.lock);
+	read_lock(&chan_list_lock);
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (state && sk->sk_state != state)
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
+
+		if (state && c->state != state)
 			continue;
 
-		if (l2cap_pi(sk)->psm == psm) {
+		if (c->psm == psm) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
+			if (!bacmp(&bt_sk(sk)->src, src)) {
+				read_unlock(&chan_list_lock);
+				return c;
+			}
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
+				c1 = c;
 		}
 	}
 
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
-	return node ? sk : sk1;
+	return c1;
 }
 
-int l2cap_do_connect(struct sock *sk)
+int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid, bdaddr_t *dst)
 {
+	struct sock *sk = chan->sk;
 	bdaddr_t *src = &bt_sk(sk)->src;
-	bdaddr_t *dst = &bt_sk(sk)->dst;
 	struct l2cap_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev *hdev;
@@ -1274,104 +1146,136 @@
 	int err;
 
 	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst),
-							l2cap_pi(sk)->psm);
+							chan->psm);
 
 	hdev = hci_get_route(dst, src);
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	auth_type = l2cap_get_auth_type(sk);
+	l2cap_chan_lock(chan);
 
-	if (l2cap_pi(sk)->fixed_channel) {
-		/* Fixed channels piggyback on existing ACL connections */
-		hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
-		if (!hcon || !hcon->l2cap_data) {
-			err = -ENOTCONN;
-			goto done;
-		}
+	/* PSM must be odd and lsb of upper byte must be 0 */
+	if ((__le16_to_cpu(psm) & 0x0101) != 0x0001 && !cid &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
+		err = -EINVAL;
+		goto done;
+	}
 
-		conn = hcon->l2cap_data;
-	} else {
-		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA)
-			hcon = hci_le_connect(hdev, 0, dst,
-					l2cap_pi(sk)->sec_level, auth_type,
-					&bt_sk(sk)->le_params);
-		else
-			hcon = hci_connect(hdev, ACL_LINK, 0, dst,
-					l2cap_pi(sk)->sec_level, auth_type);
+	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !(psm || cid)) {
+		err = -EINVAL;
+		goto done;
+	}
 
-		if (IS_ERR(hcon)) {
-			err = PTR_ERR(hcon);
-			goto done;
-		}
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		break;
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+		if (!disable_ertm)
+			break;
+		/* fall through */
+	default:
+		err = -ENOTSUPP;
+		goto done;
+	}
 
-		conn = l2cap_conn_add(hcon, 0);
-		if (!conn) {
-			hci_conn_put(hcon);
-			err = -ENOMEM;
-			goto done;
-		}
+	lock_sock(sk);
+
+	switch (sk->sk_state) {
+	case BT_CONNECT:
+	case BT_CONNECT2:
+	case BT_CONFIG:
+		/* Already connecting */
+		err = 0;
+		release_sock(sk);
+		goto done;
+
+	case BT_CONNECTED:
+		/* Already connected */
+		err = -EISCONN;
+		release_sock(sk);
+		goto done;
+
+	case BT_OPEN:
+	case BT_BOUND:
+		/* Can connect */
+		break;
+
+	default:
+		err = -EBADFD;
+		release_sock(sk);
+		goto done;
 	}
 
-	/* Update source addr of the socket */
-	bacpy(src, conn->src);
+	/* Set destination address and psm */
+	bacpy(&bt_sk(sk)->dst, dst);
 
-	l2cap_chan_add(conn, sk);
+	release_sock(sk);
 
-	if ((l2cap_pi(sk)->fixed_channel) ||
-			(l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
-				hcon->state == BT_CONNECTED)) {
-		sk->sk_state = BT_CONNECTED;
-		sk->sk_state_change(sk);
-	} else {
-		sk->sk_state = BT_CONNECT;
-		/* If we have valid LE Params, let timeout override default */
-		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
-			l2cap_sock_le_params_valid(&bt_sk(sk)->le_params)) {
-			u16 timeout = bt_sk(sk)->le_params.conn_timeout;
-
-			if (timeout)
-				l2cap_sock_set_timer(sk,
-						msecs_to_jiffies(timeout*1000));
-		} else
-			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
+	chan->psm = psm;
+	chan->dcid = cid;
 
-		sk->sk_state_change(sk);
+	auth_type = l2cap_get_auth_type(chan);
 
-		if (hcon->state == BT_CONNECTED) {
-			if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-				l2cap_sock_clear_timer(sk);
-				if (l2cap_check_security(sk)) {
-					sk->sk_state = BT_CONNECTED;
-					sk->sk_state_change(sk);
-				}
-			} else
-				l2cap_do_start(sk);
-		}
+	if (chan->dcid == L2CAP_CID_LE_DATA)
+		hcon = hci_connect(hdev, LE_LINK, dst,
+					chan->sec_level, auth_type);
+	else
+		hcon = hci_connect(hdev, ACL_LINK, dst,
+					chan->sec_level, auth_type);
+
+	if (IS_ERR(hcon)) {
+		err = PTR_ERR(hcon);
+		goto done;
+	}
+
+	conn = l2cap_conn_add(hcon, 0);
+	if (!conn) {
+		hci_conn_put(hcon);
+		err = -ENOMEM;
+		goto done;
+	}
+
+	/* Update source addr of the socket */
+	bacpy(src, conn->src);
+
+	l2cap_chan_unlock(chan);
+	l2cap_chan_add(conn, chan);
+	l2cap_chan_lock(chan);
+
+	l2cap_state_change(chan, BT_CONNECT);
+	__set_chan_timer(chan, sk->sk_sndtimeo);
+
+	if (hcon->state == BT_CONNECTED) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+			__clear_chan_timer(chan);
+			if (l2cap_chan_check_security(chan))
+				l2cap_state_change(chan, BT_CONNECTED);
+		} else
+			l2cap_do_start(chan);
 	}
 
 	err = 0;
 
 done:
-	hci_dev_unlock_bh(hdev);
+	l2cap_chan_unlock(chan);
+	hci_dev_unlock(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
 
 int __l2cap_wait_ack(struct sock *sk)
 {
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	DECLARE_WAITQUEUE(wait, current);
 	int err = 0;
 	int timeo = HZ/5;
 
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (l2cap_pi(sk)->unacked_frames > 0 && l2cap_pi(sk)->conn &&
-		atomic_read(&l2cap_pi(sk)->ertm_queued)) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (chan->unacked_frames > 0 && chan->conn) {
 		if (!timeo)
 			timeo = HZ/5;
 
@@ -1383,6 +1287,7 @@
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
@@ -1393,354 +1298,325 @@
 	return err;
 }
 
-static void l2cap_ertm_tx_worker(struct work_struct *work)
+static void l2cap_monitor_timeout(struct work_struct *work)
 {
-	struct l2cap_pinfo *pi =
-		container_of(work, struct l2cap_pinfo, tx_work);
-	struct sock *sk = (struct sock *)pi;
-	BT_DBG("%p", pi);
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							monitor_timer.work);
 
-	lock_sock(sk);
-	l2cap_ertm_send(sk);
-	release_sock(sk);
-	sock_put(sk);
-}
+	BT_DBG("chan %p", chan);
 
-static void l2cap_skb_destructor(struct sk_buff *skb)
-{
-	struct sock *sk = skb->sk;
-	int queued;
-	int keep_sk = 0;
+	l2cap_chan_lock(chan);
+
+	if (chan->retry_count >= chan->remote_max_tx) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+		l2cap_chan_unlock(chan);
+		l2cap_chan_put(chan);
+		return;
+	}
 
-	queued = atomic_sub_return(1, &l2cap_pi(sk)->ertm_queued);
-	if (queued < L2CAP_MIN_ERTM_QUEUED)
-		keep_sk = queue_work(_l2cap_wq, &l2cap_pi(sk)->tx_work);
+	chan->retry_count++;
+	__set_monitor_timer(chan);
 
-	if (!keep_sk)
-		sock_put(sk);
+	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
+	l2cap_chan_unlock(chan);
+	l2cap_chan_put(chan);
 }
 
-void l2cap_do_send(struct sock *sk, struct sk_buff *skb)
+static void l2cap_retrans_timeout(struct work_struct *work)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							retrans_timer.work);
 
-	BT_DBG("sk %p, skb %p len %d", sk, skb, skb->len);
+	BT_DBG("chan %p", chan);
 
-	if (pi->ampcon && (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
-			pi->amp_move_state == L2CAP_AMP_STATE_WAIT_PREPARE)) {
-		BT_DBG("Sending on AMP connection %p %p",
-			pi->ampcon, pi->ampchan);
-		if (pi->ampchan)
-			hci_send_acl(pi->ampcon, pi->ampchan, skb,
-					ACL_COMPLETE);
-		else
-			kfree_skb(skb);
-	} else {
-		u16 flags;
+	l2cap_chan_lock(chan);
 
-		if (!(pi->conn)) {
-			kfree_skb(skb);
-			return;
-		}
+	chan->retry_count = 1;
+	__set_monitor_timer(chan);
 
-		bt_cb(skb)->force_active = pi->force_active;
-		BT_DBG("Sending on BR/EDR connection %p", pi->conn->hcon);
+	set_bit(CONN_WAIT_F, &chan->conn_state);
 
-		if (lmp_no_flush_capable(pi->conn->hcon->hdev) &&
-			!l2cap_pi(sk)->flushable)
-			flags = ACL_START_NO_FLUSH;
-		else
-			flags = ACL_START;
+	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
 
-		hci_send_acl(pi->conn->hcon, NULL, skb, flags);
-	}
+	l2cap_chan_unlock(chan);
+	l2cap_chan_put(chan);
 }
 
-int l2cap_ertm_send(struct sock *sk)
+static void l2cap_drop_acked_frames(struct l2cap_chan *chan)
 {
-	struct sk_buff *skb, *tx_skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control *control;
-	int sent = 0;
+	struct sk_buff *skb;
 
-	BT_DBG("sk %p", sk);
+	while ((skb = skb_peek(&chan->tx_q)) &&
+			chan->unacked_frames) {
+		if (bt_cb(skb)->tx_seq == chan->expected_ack_seq)
+			break;
 
-	if (sk->sk_state != BT_CONNECTED)
-		return -ENOTCONN;
+		skb = skb_dequeue(&chan->tx_q);
+		kfree_skb(skb);
 
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return 0;
+		chan->unacked_frames--;
+	}
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return 0;
+	if (!chan->unacked_frames)
+		__clear_retrans_timer(chan);
+}
 
-	while (sk->sk_send_head && (pi->unacked_frames < pi->remote_tx_win) &&
-		atomic_read(&pi->ertm_queued) < L2CAP_MAX_ERTM_QUEUED &&
-		(pi->tx_state == L2CAP_ERTM_TX_STATE_XMIT)) {
-
-		skb = sk->sk_send_head;
-
-		bt_cb(skb)->retries = 1;
-		control = &bt_cb(skb)->control;
-
-		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-			control->final = 1;
-			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-		}
-		control->reqseq = pi->buffer_seq;
-		pi->last_acked_seq = pi->buffer_seq;
-		control->txseq = pi->next_tx_seq;
-
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		}
+static void l2cap_streaming_send(struct l2cap_chan *chan)
+{
+	struct sk_buff *skb;
+	u32 control;
+	u16 fcs;
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(skb);
+	while ((skb = skb_dequeue(&chan->tx_q))) {
+		control = __get_control(chan, skb->data + L2CAP_HDR_SIZE);
+		control |= __set_txseq(chan, chan->next_tx_seq);
+		__put_control(chan, control, skb->data + L2CAP_HDR_SIZE);
 
-		/* Clone after data has been modified. Data is assumed to be
-		   read-only (for locking purposes) on cloned sk_buffs.
-		 */
-		tx_skb = skb_clone(skb, GFP_ATOMIC);
+		if (chan->fcs == L2CAP_FCS_CRC16) {
+			fcs = crc16(0, (u8 *)skb->data,
+						skb->len - L2CAP_FCS_SIZE);
+			put_unaligned_le16(fcs,
+					skb->data + skb->len - L2CAP_FCS_SIZE);
+		}
 
-		if (!tx_skb)
-			break;
+		l2cap_do_send(chan, skb);
 
-		sock_hold(sk);
-		tx_skb->sk = sk;
-		tx_skb->destructor = l2cap_skb_destructor;
-		atomic_inc(&pi->ertm_queued);
+		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
+	}
+}
 
-		l2cap_ertm_start_retrans_timer(pi);
+static void l2cap_retransmit_one_frame(struct l2cap_chan *chan, u16 tx_seq)
+{
+	struct sk_buff *skb, *tx_skb;
+	u16 fcs;
+	u32 control;
 
-		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
-		pi->unacked_frames += 1;
-		pi->frames_sent += 1;
-		sent += 1;
+	skb = skb_peek(&chan->tx_q);
+	if (!skb)
+		return;
 
-		if (skb_queue_is_last(TX_QUEUE(sk), skb))
-			sk->sk_send_head = NULL;
-		else
-			sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);
+	while (bt_cb(skb)->tx_seq != tx_seq) {
+		if (skb_queue_is_last(&chan->tx_q, skb))
+			return;
 
-		l2cap_do_send(sk, tx_skb);
-		BT_DBG("Sent txseq %d", (int)control->txseq);
+		skb = skb_queue_next(&chan->tx_q, skb);
 	}
 
-	BT_DBG("Sent %d, %d unacked, %d in ERTM queue, %d in HCI queue", sent,
-		(int) pi->unacked_frames, skb_queue_len(TX_QUEUE(sk)),
-		atomic_read(&pi->ertm_queued));
+	if (chan->remote_max_tx &&
+			bt_cb(skb)->retries == chan->remote_max_tx) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+		return;
+	}
 
-	return sent;
+	tx_skb = skb_clone(skb, GFP_ATOMIC);
+	bt_cb(skb)->retries++;
+
+	control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
+	control &= __get_sar_mask(chan);
+
+	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+		control |= __set_ctrl_final(chan);
+
+	control |= __set_reqseq(chan, chan->buffer_seq);
+	control |= __set_txseq(chan, tx_seq);
+
+	__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
+
+	if (chan->fcs == L2CAP_FCS_CRC16) {
+		fcs = crc16(0, (u8 *)tx_skb->data,
+						tx_skb->len - L2CAP_FCS_SIZE);
+		put_unaligned_le16(fcs,
+				tx_skb->data + tx_skb->len - L2CAP_FCS_SIZE);
+	}
+
+	l2cap_do_send(chan, tx_skb);
 }
 
-int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs)
+static int l2cap_ertm_send(struct l2cap_chan *chan)
 {
-	struct sk_buff *skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control *control;
-	int sent = 0;
-
-	BT_DBG("sk %p, skbs %p", sk, skbs);
+	struct sk_buff *skb, *tx_skb;
+	u16 fcs;
+	u32 control;
+	int nsent = 0;
 
-	if (sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_CONNECTED)
 		return -ENOTCONN;
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return 0;
+	while ((skb = chan->tx_send_head) && (!l2cap_tx_window_full(chan))) {
 
-	skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
+		if (chan->remote_max_tx &&
+				bt_cb(skb)->retries == chan->remote_max_tx) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+			break;
+		}
 
-	BT_DBG("skb queue empty 0x%2.2x", skb_queue_empty(TX_QUEUE(sk)));
-	while (!skb_queue_empty(TX_QUEUE(sk))) {
+		tx_skb = skb_clone(skb, GFP_ATOMIC);
 
-		skb = skb_dequeue(TX_QUEUE(sk));
+		bt_cb(skb)->retries++;
 
-		BT_DBG("skb %p", skb);
+		control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
+		control &= __get_sar_mask(chan);
 
-		bt_cb(skb)->retries = 1;
-		control = &bt_cb(skb)->control;
+		if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
+			control |= __set_ctrl_final(chan);
 
-		BT_DBG("control %p", control);
+		control |= __set_reqseq(chan, chan->buffer_seq);
+		control |= __set_txseq(chan, chan->next_tx_seq);
 
-		control->reqseq = 0;
-		control->txseq = pi->next_tx_seq;
+		__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
 
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(control),
-					skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(control),
-					skb->data + L2CAP_HDR_SIZE);
+		if (chan->fcs == L2CAP_FCS_CRC16) {
+			fcs = crc16(0, (u8 *)skb->data,
+						tx_skb->len - L2CAP_FCS_SIZE);
+			put_unaligned_le16(fcs, skb->data +
+						tx_skb->len - L2CAP_FCS_SIZE);
 		}
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(skb);
-
-		l2cap_do_send(sk, skb);
+		l2cap_do_send(chan, tx_skb);
 
-		BT_DBG("Sent txseq %d", (int)control->txseq);
+		__set_retrans_timer(chan);
 
-		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
-		pi->frames_sent += 1;
-		sent += 1;
-	}
+		bt_cb(skb)->tx_seq = chan->next_tx_seq;
 
-	BT_DBG("Sent %d", sent);
+		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
 
-	return 0;
-}
+		if (bt_cb(skb)->retries == 1) {
+			chan->unacked_frames++;
 
-static int memcpy_fromkvec(unsigned char *kdata, struct kvec *iv, int len)
-{
-	while (len > 0) {
-		if (iv->iov_len) {
-			int copy = min_t(unsigned int, len, iv->iov_len);
-			memcpy(kdata, iv->iov_base, copy);
-			len -= copy;
-			kdata += copy;
-			iv->iov_base += copy;
-			iv->iov_len -= copy;
+			if (!nsent++)
+				__clear_ack_timer(chan);
 		}
-		iv++;
+
+		chan->frames_sent++;
+
+		if (skb_queue_is_last(&chan->tx_q, skb))
+			chan->tx_send_head = NULL;
+		else
+			chan->tx_send_head = skb_queue_next(&chan->tx_q, skb);
 	}
 
-	return 0;
+	return nsent;
 }
 
-static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg,
-					int len, int count, struct sk_buff *skb,
-					int reseg)
+static int l2cap_retransmit_frames(struct l2cap_chan *chan)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff **frag;
-	struct sk_buff *final;
-	int err, sent = 0;
+	int ret;
 
-	BT_DBG("sk %p, msg %p, len %d, count %d, skb %p", sk,
-		msg, (int)len, (int)count, skb);
+	if (!skb_queue_empty(&chan->tx_q))
+		chan->tx_send_head = chan->tx_q.next;
 
-	if (!conn)
-		return -ENOTCONN;
+	chan->next_tx_seq = chan->expected_ack_seq;
+	ret = l2cap_ertm_send(chan);
+	return ret;
+}
 
-	/* When resegmenting, data is copied from kernel space */
-	if (reseg) {
-		err = memcpy_fromkvec(skb_put(skb, count),
-				(struct kvec *) msg->msg_iov, count);
-	} else {
-		err = memcpy_fromiovec(skb_put(skb, count), msg->msg_iov,
-					count);
-	}
+static void __l2cap_send_ack(struct l2cap_chan *chan)
+{
+	u32 control = 0;
 
-	if (err)
-		return -EFAULT;
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-	sent += count;
-	len  -= count;
-	final = skb;
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+		l2cap_send_sframe(chan, control);
+		return;
+	}
 
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		int skblen;
-		count = min_t(unsigned int, conn->mtu, len);
+	if (l2cap_ertm_send(chan) > 0)
+		return;
 
-		/* Add room for the FCS if it fits */
-		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16 &&
-			len + L2CAP_FCS_SIZE <= conn->mtu)
-			skblen = count + L2CAP_FCS_SIZE;
-		else
-			skblen = count;
+	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+	l2cap_send_sframe(chan, control);
+}
 
-		/* Don't use bt_skb_send_alloc() while resegmenting, since
-		 * it is not ok to block.
-		 */
-		if (reseg) {
-			*frag = bt_skb_alloc(skblen, GFP_ATOMIC);
-			if (*frag)
-				skb_set_owner_w(*frag, sk);
-		} else {
-			*frag = bt_skb_send_alloc(sk, skblen,
-					msg->msg_flags & MSG_DONTWAIT, &err);
-		}
+static void l2cap_send_ack(struct l2cap_chan *chan)
+{
+	__clear_ack_timer(chan);
+	__l2cap_send_ack(chan);
+}
 
-		if (!*frag)
-			return -EFAULT;
+static void l2cap_send_srejtail(struct l2cap_chan *chan)
+{
+	struct srej_list *tail;
+	u32 control;
 
-		/* When resegmenting, data is copied from kernel space */
-		if (reseg) {
-			err = memcpy_fromkvec(skb_put(*frag, count),
-						(struct kvec *) msg->msg_iov,
-						count);
-		} else {
-			err = memcpy_fromiovec(skb_put(*frag, count),
-						msg->msg_iov, count);
-		}
+	control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+	control |= __set_ctrl_final(chan);
 
-		if (err)
-			return -EFAULT;
+	tail = list_entry((&chan->srej_l)->prev, struct srej_list, list);
+	control |= __set_reqseq(chan, tail->tx_seq);
 
-		sent += count;
-		len  -= count;
+	l2cap_send_sframe(chan, control);
+}
+
+static inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,
+					 struct msghdr *msg, int len,
+					 int count, struct sk_buff *skb)
+{
+	struct l2cap_conn *conn = chan->conn;
+	struct sk_buff **frag;
+	int err, sent = 0;
 
-		final = *frag;
+	if (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count))
+		return -EFAULT;
 
-		frag = &(*frag)->next;
-	}
+	sent += count;
+	len  -= count;
 
-	if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16) {
-		if (skb_tailroom(final) < L2CAP_FCS_SIZE) {
-			if (reseg) {
-				*frag = bt_skb_alloc(L2CAP_FCS_SIZE,
-						GFP_ATOMIC);
-				if (*frag)
-					skb_set_owner_w(*frag, sk);
-			} else {
-				*frag = bt_skb_send_alloc(sk, L2CAP_FCS_SIZE,
-						msg->msg_flags & MSG_DONTWAIT,
-						&err);
-			}
+	/* Continuation fragments (no L2CAP header) */
+	frag = &skb_shinfo(skb)->frag_list;
+	while (len) {
+		count = min_t(unsigned int, conn->mtu, len);
 
-			if (!*frag)
-				return -EFAULT;
+		*frag = chan->ops->alloc_skb(chan, count,
+					     msg->msg_flags & MSG_DONTWAIT,
+					     &err);
 
-			final = *frag;
-		}
+		if (!*frag)
+			return err;
+		if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count))
+			return -EFAULT;
+
+		(*frag)->priority = skb->priority;
 
-		skb_put(final, L2CAP_FCS_SIZE);
+		sent += count;
+		len  -= count;
+
+		frag = &(*frag)->next;
 	}
 
 	return sent;
 }
 
-struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len)
+static struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 priority)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE + 2;
+	int err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;
 	struct l2cap_hdr *lh;
 
-	BT_DBG("sk %p len %d", sk, (int)len);
+	BT_DBG("chan %p len %d priority %u", chan, (int)len, priority);
 
 	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
+
+	skb = chan->ops->alloc_skb(chan, count + hlen,
+				   msg->msg_flags & MSG_DONTWAIT, &err);
+
 	if (!skb)
 		return ERR_PTR(err);
 
+	skb->priority = priority;
+
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->cid = cpu_to_le16(chan->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-	put_unaligned_le16(l2cap_pi(sk)->psm, skb_put(skb, 2));
+	put_unaligned_le16(chan->psm, skb_put(skb, 2));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1748,27 +1624,33 @@
 	return skb;
 }
 
-struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len)
+static struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 priority)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
 	int err, count, hlen = L2CAP_HDR_SIZE;
 	struct l2cap_hdr *lh;
 
-	BT_DBG("sk %p len %d", sk, (int)len);
+	BT_DBG("chan %p len %d", chan, (int)len);
 
 	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
+
+	skb = chan->ops->alloc_skb(chan, count + hlen,
+				   msg->msg_flags & MSG_DONTWAIT, &err);
+
 	if (!skb)
 		return ERR_PTR(err);
 
+	skb->priority = priority;
+
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->cid = cpu_to_le16(chan->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1776,3919 +1658,1753 @@
 	return skb;
 }
 
-struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk,
-					struct msghdr *msg, size_t len,
-					u16 sdulen, int reseg)
+static struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,
+						struct msghdr *msg, size_t len,
+						u32 control, u16 sdulen)
 {
+	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
-	int err = 0, count = 0, hlen = 0;
-	int reserve = 0;
+	int err, count, hlen;
 	struct l2cap_hdr *lh;
-	u8 fcs = l2cap_pi(sk)->fcs;
 
-	if (l2cap_pi(sk)->extended_control)
-		hlen = L2CAP_EXTENDED_HDR_SIZE;
+	BT_DBG("chan %p len %d", chan, (int)len);
+
+	if (!conn)
+		return ERR_PTR(-ENOTCONN);
+
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hlen = L2CAP_EXT_HDR_SIZE;
 	else
-		hlen = L2CAP_ENHANCED_HDR_SIZE;
+		hlen = L2CAP_ENH_HDR_SIZE;
 
 	if (sdulen)
 		hlen += L2CAP_SDULEN_SIZE;
 
-	if (fcs == L2CAP_FCS_CRC16)
+	if (chan->fcs == L2CAP_FCS_CRC16)
 		hlen += L2CAP_FCS_SIZE;
 
-	BT_DBG("sk %p, msg %p, len %d, sdulen %d, hlen %d",
-		sk, msg, (int)len, (int)sdulen, hlen);
-
-	count = min_t(unsigned int, (l2cap_pi(sk)->conn->mtu - hlen), len);
-
-	/* Allocate extra headroom for Qualcomm PAL.  This is only
-	 * necessary in two places (here and when creating sframes)
-	 * because only unfragmented iframes and sframes are sent
-	 * using AMP controllers.
-	 */
-	if (l2cap_pi(sk)->ampcon &&
-			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
+	count = min_t(unsigned int, (conn->mtu - hlen), len);
 
-	/* Don't use bt_skb_send_alloc() while resegmenting, since
-	 * it is not ok to block.
-	 */
-	if (reseg) {
-		skb = bt_skb_alloc(count + hlen + reserve, GFP_ATOMIC);
-		if (skb)
-			skb_set_owner_w(skb, sk);
-	} else {
-		skb = bt_skb_send_alloc(sk, count + hlen + reserve,
+	skb = chan->ops->alloc_skb(chan, count + hlen,
 					msg->msg_flags & MSG_DONTWAIT, &err);
-	}
+
 	if (!skb)
 		return ERR_PTR(err);
 
-	if (reserve)
-		skb_reserve(skb, reserve);
-
-	bt_cb(skb)->control.fcs = fcs;
-
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len + hlen - L2CAP_HDR_SIZE);
+	lh->cid = cpu_to_le16(chan->dcid);
+	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
-	/* Control header is populated later */
-	if (l2cap_pi(sk)->extended_control)
-		put_unaligned_le32(0, skb_put(skb, 4));
-	else
-		put_unaligned_le16(0, skb_put(skb, 2));
+	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
 
 	if (sdulen)
 		put_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, reseg);
+	err = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);
 	if (unlikely(err < 0)) {
-		BT_DBG("err %d", err);
 		kfree_skb(skb);
 		return ERR_PTR(err);
 	}
 
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		put_unaligned_le16(0, skb_put(skb, L2CAP_FCS_SIZE));
+
 	bt_cb(skb)->retries = 0;
 	return skb;
 }
 
-static void l2cap_ertm_process_reqseq(struct sock *sk, u16 reqseq)
+static int l2cap_sar_segment_sdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *acked_skb;
-	u16 ackseq;
-
-	BT_DBG("sk %p, reqseq %d", sk, (int) reqseq);
-
-	pi = l2cap_pi(sk);
-
-	if (pi->unacked_frames == 0 || reqseq == pi->expected_ack_seq)
-		return;
-
-	BT_DBG("expected_ack_seq %d, unacked_frames %d",
-		(int) pi->expected_ack_seq, (int) pi->unacked_frames);
+	struct sk_buff *skb;
+	struct sk_buff_head sar_queue;
+	u32 control;
+	size_t size = 0;
+
+	skb_queue_head_init(&sar_queue);
+	control = __set_ctrl_sar(chan, L2CAP_SAR_START);
+	skb = l2cap_create_iframe_pdu(chan, msg, chan->remote_mps, control, len);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	__skb_queue_tail(&sar_queue, skb);
+	len -= chan->remote_mps;
+	size += chan->remote_mps;
 
-	for (ackseq = pi->expected_ack_seq; ackseq != reqseq;
-		ackseq = __next_seq(ackseq, pi)) {
+	while (len > 0) {
+		size_t buflen;
 
-		acked_skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), ackseq);
-		if (acked_skb) {
-			skb_unlink(acked_skb, TX_QUEUE(sk));
-			kfree_skb(acked_skb);
-			pi->unacked_frames--;
+		if (len > chan->remote_mps) {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_CONTINUE);
+			buflen = chan->remote_mps;
+		} else {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_END);
+			buflen = len;
 		}
-	}
 
-	pi->expected_ack_seq = reqseq;
+		skb = l2cap_create_iframe_pdu(chan, msg, buflen, control, 0);
+		if (IS_ERR(skb)) {
+			skb_queue_purge(&sar_queue);
+			return PTR_ERR(skb);
+		}
 
-	if (pi->unacked_frames == 0)
-		l2cap_ertm_stop_retrans_timer(pi);
+		__skb_queue_tail(&sar_queue, skb);
+		len -= buflen;
+		size += buflen;
+	}
+	skb_queue_splice_tail(&sar_queue, &chan->tx_q);
+	if (chan->tx_send_head == NULL)
+		chan->tx_send_head = sar_queue.next;
 
-	BT_DBG("unacked_frames %d", (int) pi->unacked_frames);
+	return size;
 }
 
-static struct sk_buff *l2cap_create_sframe_pdu(struct sock *sk, u32 control)
+int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
+								u32 priority)
 {
 	struct sk_buff *skb;
-	int len;
-	int reserve = 0;
-	struct l2cap_hdr *lh;
+	u32 control;
+	int err;
 
-	if (l2cap_pi(sk)->extended_control)
-		len = L2CAP_EXTENDED_HDR_SIZE;
-	else
-		len = L2CAP_ENHANCED_HDR_SIZE;
+	/* Connectionless channel */
+	if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
+		skb = l2cap_create_connless_pdu(chan, msg, len, priority);
+		if (IS_ERR(skb))
+			return PTR_ERR(skb);
 
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16)
-		len += L2CAP_FCS_SIZE;
+		l2cap_do_send(chan, skb);
+		return len;
+	}
 
-	/* Allocate extra headroom for Qualcomm PAL */
-	if (l2cap_pi(sk)->ampcon &&
-			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
-		reserve = BT_SKB_RESERVE_80211;
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		/* Check outgoing MTU */
+		if (len > chan->omtu)
+			return -EMSGSIZE;
+
+		/* Create a basic PDU */
+		skb = l2cap_create_basic_pdu(chan, msg, len, priority);
+		if (IS_ERR(skb))
+			return PTR_ERR(skb);
 
-	skb = bt_skb_alloc(len + reserve, GFP_ATOMIC);
+		l2cap_do_send(chan, skb);
+		err = len;
+		break;
 
-	if (!skb)
-		return ERR_PTR(-ENOMEM);
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+		/* Entire SDU fits into one PDU */
+		if (len <= chan->remote_mps) {
+			control = __set_ctrl_sar(chan, L2CAP_SAR_UNSEGMENTED);
+			skb = l2cap_create_iframe_pdu(chan, msg, len, control,
+									0);
+			if (IS_ERR(skb))
+				return PTR_ERR(skb);
 
-	if (reserve)
-		skb_reserve(skb, reserve);
+			__skb_queue_tail(&chan->tx_q, skb);
 
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len - L2CAP_HDR_SIZE);
+			if (chan->tx_send_head == NULL)
+				chan->tx_send_head = skb;
 
-	if (l2cap_pi(sk)->extended_control)
-		put_unaligned_le32(control, skb_put(skb, 4));
-	else
-		put_unaligned_le16(control, skb_put(skb, 2));
+		} else {
+			/* Segment SDU into multiples PDUs */
+			err = l2cap_sar_segment_sdu(chan, msg, len);
+			if (err < 0)
+				return err;
+		}
 
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16) {
-		u16 fcs = crc16(0, (u8 *) skb->data, skb->len);
-		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
-	}
+		if (chan->mode == L2CAP_MODE_STREAMING) {
+			l2cap_streaming_send(chan);
+			err = len;
+			break;
+		}
 
-	return skb;
-}
+		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+				test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			err = len;
+			break;
+		}
 
-static void l2cap_ertm_send_sframe(struct sock *sk,
-				struct bt_l2cap_control *control)
-{
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-	u32 control_field;
+		err = l2cap_ertm_send(chan);
+		if (err >= 0)
+			err = len;
 
-	BT_DBG("sk %p, control %p", sk, control);
+		break;
 
-	if (control->frame_type != 's')
-		return;
+	default:
+		BT_DBG("bad state %1.1x", chan->mode);
+		err = -EBADFD;
+	}
 
-	pi = l2cap_pi(sk);
+	return err;
+}
 
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
-		BT_DBG("AMP error - attempted S-Frame send during AMP move");
-		return;
-	}
+/* Copy frame to all raw sockets on that connection */
+static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+	struct l2cap_chan *chan;
 
-	if ((pi->conn_state & L2CAP_CONN_SEND_FBIT) && !control->poll) {
-		control->final = 1;
-		pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-	}
+	BT_DBG("conn %p", conn);
 
-	if (control->super == L2CAP_SFRAME_RR)
-		pi->conn_state &= ~L2CAP_CONN_SENT_RNR;
-	else if (control->super == L2CAP_SFRAME_RNR)
-		pi->conn_state |= L2CAP_CONN_SENT_RNR;
+	mutex_lock(&conn->chan_lock);
 
-	if (control->super != L2CAP_SFRAME_SREJ) {
-		pi->last_acked_seq = control->reqseq;
-		l2cap_ertm_stop_ack_timer(pi);
-	}
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		struct sock *sk = chan->sk;
+		if (chan->chan_type != L2CAP_CHAN_RAW)
+			continue;
 
-	BT_DBG("reqseq %d, final %d, poll %d, super %d", (int) control->reqseq,
-		(int) control->final, (int) control->poll,
-		(int) control->super);
+		/* Don't send frame to the socket it came from */
+		if (skb->sk == sk)
+			continue;
+		nskb = skb_clone(skb, GFP_ATOMIC);
+		if (!nskb)
+			continue;
 
-	if (pi->extended_control)
-		control_field = __pack_extended_control(control);
-	else
-		control_field = __pack_enhanced_control(control);
+		if (chan->ops->recv(chan->data, nskb))
+			kfree_skb(nskb);
+	}
 
-	skb = l2cap_create_sframe_pdu(sk, control_field);
-	if (!IS_ERR(skb))
-		l2cap_do_send(sk, skb);
+	mutex_unlock(&conn->chan_lock);
 }
 
-static void l2cap_ertm_send_ack(struct sock *sk)
+/* ---- L2CAP signalling commands ---- */
+static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
+				u8 code, u8 ident, u16 dlen, void *data)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct bt_l2cap_control control;
-	u16 frames_to_ack = __delta_seq(pi->buffer_seq, pi->last_acked_seq, pi);
-	int threshold;
+	struct sk_buff *skb, **frag;
+	struct l2cap_cmd_hdr *cmd;
+	struct l2cap_hdr *lh;
+	int len, count;
 
-	BT_DBG("sk %p", sk);
-	BT_DBG("last_acked_seq %d, buffer_seq %d", (int)pi->last_acked_seq,
-		(int)pi->buffer_seq);
+	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
+			conn, code, ident, dlen);
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
+	if (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)
+		return NULL;
 
-	if ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-		pi->rx_state == L2CAP_ERTM_RX_STATE_RECV) {
-		l2cap_ertm_stop_ack_timer(pi);
-		control.super = L2CAP_SFRAME_RNR;
-		control.reqseq = pi->buffer_seq;
-		l2cap_ertm_send_sframe(sk, &control);
-	} else {
-		if (!(pi->conn_state & L2CAP_CONN_REMOTE_BUSY)) {
-			l2cap_ertm_send(sk);
-			/* If any i-frames were sent, they included an ack */
-			if (pi->buffer_seq == pi->last_acked_seq)
-				frames_to_ack = 0;
-		}
+	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
+	count = min_t(unsigned int, conn->mtu, len);
 
-		/* Ack now if the window is 3/4ths full.
-		 * Calculate without mul or div
-		 */
-		threshold = pi->ack_win;
-		threshold += threshold << 1;
-		threshold >>= 2;
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
+	if (!skb)
+		return NULL;
 
-		BT_DBG("frames_to_ack %d, threshold %d", (int)frames_to_ack,
-			threshold);
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
 
-		if (frames_to_ack >= threshold) {
-			l2cap_ertm_stop_ack_timer(pi);
-			control.super = L2CAP_SFRAME_RR;
-			control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &control);
-			frames_to_ack = 0;
-		}
+	if (conn->hcon->type == LE_LINK)
+		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
+	else
+		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
+
+	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
+	cmd->code  = code;
+	cmd->ident = ident;
+	cmd->len   = cpu_to_le16(dlen);
 
-		if (frames_to_ack)
-			l2cap_ertm_start_ack_timer(pi);
+	if (dlen) {
+		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
+		memcpy(skb_put(skb, count), data, count);
+		data += count;
 	}
-}
 
-static void l2cap_ertm_send_rr_or_rnr(struct sock *sk, bool poll)
-{
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
+	len -= skb->len;
+
+	/* Continuation fragments (no L2CAP header) */
+	frag = &skb_shinfo(skb)->frag_list;
+	while (len) {
+		count = min_t(unsigned int, conn->mtu, len);
+
+		*frag = bt_skb_alloc(count, GFP_ATOMIC);
+		if (!*frag)
+			goto fail;
 
-	BT_DBG("sk %p, poll %d", sk, (int) poll);
+		memcpy(skb_put(*frag, count), data, count);
 
-	pi = l2cap_pi(sk);
+		len  -= count;
+		data += count;
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.poll = poll;
+		frag = &(*frag)->next;
+	}
 
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
-		control.super = L2CAP_SFRAME_RNR;
-	else
-		control.super = L2CAP_SFRAME_RR;
+	return skb;
 
-	control.reqseq = pi->buffer_seq;
-	l2cap_ertm_send_sframe(sk, &control);
+fail:
+	kfree_skb(skb);
+	return NULL;
 }
 
-static void l2cap_ertm_send_i_or_rr_or_rnr(struct sock *sk)
+static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
 {
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
+	struct l2cap_conf_opt *opt = *ptr;
+	int len;
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.final = 1;
-	control.reqseq = pi->buffer_seq;
-	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+	len = L2CAP_CONF_OPT_SIZE + opt->len;
+	*ptr += len;
 
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		control.super = L2CAP_SFRAME_RNR;
-		l2cap_ertm_send_sframe(sk, &control);
-	}
+	*type = opt->type;
+	*olen = opt->len;
 
-	if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-		(pi->unacked_frames > 0))
-		l2cap_ertm_start_retrans_timer(pi);
+	switch (opt->len) {
+	case 1:
+		*val = *((u8 *) opt->val);
+		break;
 
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	case 2:
+		*val = get_unaligned_le16(opt->val);
+		break;
 
-	/* Send pending iframes */
-	l2cap_ertm_send(sk);
+	case 4:
+		*val = get_unaligned_le32(opt->val);
+		break;
 
-	if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-		/* F-bit wasn't sent in an s-frame or i-frame yet, so
-		 * send it now.
-		 */
-		control.super = L2CAP_SFRAME_RR;
-		l2cap_ertm_send_sframe(sk, &control);
+	default:
+		*val = (unsigned long) opt->val;
+		break;
 	}
+
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
+	return len;
 }
 
-static void l2cap_ertm_send_srej(struct sock *sk, u16 txseq)
+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	u16 seq;
+	struct l2cap_conf_opt *opt = *ptr;
 
-	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
 
-	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
+	opt->type = type;
+	opt->len  = len;
 
-	for (seq = pi->expected_tx_seq; seq != txseq;
-		seq = __next_seq(seq, pi)) {
-		if (!l2cap_ertm_seq_in_queue(SREJ_QUEUE(pi), seq)) {
-			control.reqseq = seq;
-			l2cap_ertm_send_sframe(sk, &control);
-			l2cap_seq_list_append(&pi->srej_list, seq);
-		}
+	switch (len) {
+	case 1:
+		*((u8 *) opt->val)  = val;
+		break;
+
+	case 2:
+		put_unaligned_le16(val, opt->val);
+		break;
+
+	case 4:
+		put_unaligned_le32(val, opt->val);
+		break;
+
+	default:
+		memcpy(opt->val, (void *) val, len);
+		break;
 	}
 
-	pi->expected_tx_seq = __next_seq(txseq, pi);
+	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
-static void l2cap_ertm_send_srej_tail(struct sock *sk)
+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
+	struct l2cap_conf_efs efs;
 
-	BT_DBG("sk %p", sk);
+	switch (chan->mode) {
+	case L2CAP_MODE_ERTM:
+		efs.id		= chan->local_id;
+		efs.stype	= chan->local_stype;
+		efs.msdu	= cpu_to_le16(chan->local_msdu);
+		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
+		efs.acc_lat	= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);
+		efs.flush_to	= cpu_to_le32(L2CAP_DEFAULT_FLUSH_TO);
+		break;
 
-	pi = l2cap_pi(sk);
+	case L2CAP_MODE_STREAMING:
+		efs.id		= 1;
+		efs.stype	= L2CAP_SERV_BESTEFFORT;
+		efs.msdu	= cpu_to_le16(chan->local_msdu);
+		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
+		efs.acc_lat	= 0;
+		efs.flush_to	= 0;
+		break;
 
-	if (pi->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)
+	default:
 		return;
+	}
 
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
-	control.reqseq = pi->srej_list.tail;
-	l2cap_ertm_send_sframe(sk, &control);
+	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
+							(unsigned long) &efs);
 }
 
-static void l2cap_ertm_send_srej_list(struct sock *sk, u16 txseq)
+static void l2cap_ack_timeout(struct work_struct *work)
 {
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	u16 initial_head;
-	u16 seq;
+	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
+							ack_timer.work);
 
-	BT_DBG("sk %p, txseq %d", sk, (int) txseq);
+	BT_DBG("chan %p", chan);
 
-	pi = l2cap_pi(sk);
-	memset(&control, 0, sizeof(control));
-	control.frame_type = 's';
-	control.super = L2CAP_SFRAME_SREJ;
+	l2cap_chan_lock(chan);
 
-	/* Capture initial list head to allow only one pass through the list. */
-	initial_head = pi->srej_list.head;
+	__l2cap_send_ack(chan);
 
-	do {
-		seq = l2cap_seq_list_pop(&pi->srej_list);
-		if ((seq == txseq) || (seq == L2CAP_SEQ_LIST_CLEAR))
-			break;
+	l2cap_chan_unlock(chan);
 
-		control.reqseq = seq;
-		l2cap_ertm_send_sframe(sk, &control);
-		l2cap_seq_list_append(&pi->srej_list, seq);
-	} while (pi->srej_list.head != initial_head);
+	l2cap_chan_put(chan);
 }
 
-static void l2cap_ertm_abort_rx_srej_sent(struct sock *sk)
+static inline void l2cap_ertm_init(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	BT_DBG("sk %p", sk);
+	chan->expected_ack_seq = 0;
+	chan->unacked_frames = 0;
+	chan->buffer_seq = 0;
+	chan->num_acked = 0;
+	chan->frames_sent = 0;
 
-	pi->expected_tx_seq = pi->buffer_seq;
-	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
-	skb_queue_purge(SREJ_QUEUE(sk));
-	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-}
+	INIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);
+	INIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);
+	INIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);
 
-static int l2cap_ertm_tx_state_xmit(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff_head *skbs, u8 event)
-{
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	skb_queue_head_init(&chan->srej_q);
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_DATA_REQUEST:
-		if (sk->sk_send_head == NULL)
-			sk->sk_send_head = skb_peek(skbs);
-
-		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
-		l2cap_ertm_send(sk);
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
-		BT_DBG("Enter LOCAL_BUSY");
-		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-			/* The SREJ_SENT state must be aborted if we are to
-			 * enter the LOCAL_BUSY state.
-			 */
-			l2cap_ertm_abort_rx_srej_sent(sk);
-		}
-
-		l2cap_ertm_send_ack(sk);
-
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
-		BT_DBG("Exit LOCAL_BUSY");
-		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_LOCAL_BUSY) {
-			if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(pi->conn, pi,
-						pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			} else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_RESPONDER) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-						pi->amp_move_cmd_ident,
-						pi->dcid,
-						L2CAP_MOVE_CHAN_SUCCESS);
-			}
-			break;
-		}
+	INIT_LIST_HEAD(&chan->srej_l);
+}
 
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_NONE &&
-			(pi->conn_state & L2CAP_CONN_SENT_RNR)) {
-			struct bt_l2cap_control local_control;
-
-			memset(&local_control, 0, sizeof(local_control));
-			local_control.frame_type = 's';
-			local_control.super = L2CAP_SFRAME_RR;
-			local_control.poll = 1;
-			local_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &local_control);
-
-			pi->retry_count = 1;
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-		break;
-	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
-		l2cap_ertm_send_rr_or_rnr(sk, 1);
-		pi->retry_count = 1;
-		l2cap_ertm_start_monitor_timer(pi);
-		l2cap_ertm_stop_ack_timer(pi);
-		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		break;
-	case L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES:
-		l2cap_ertm_send_rr_or_rnr(sk, 1);
-		pi->retry_count = 1;
-		l2cap_ertm_start_monitor_timer(pi);
-		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		break;
-	case L2CAP_ERTM_EVENT_RECV_FBIT:
-		/* Nothing to process */
-		break;
+static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
+{
+	switch (mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (l2cap_mode_supported(mode, remote_feat_mask))
+			return mode;
+		/* fall through */
 	default:
-		break;
+		return L2CAP_MODE_BASIC;
 	}
-
-	return err;
 }
 
-static int l2cap_ertm_tx_state_wait_f(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff_head *skbs, u8 event)
+static inline bool __l2cap_ews_supported(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW;
+}
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_DATA_REQUEST:
-		if (sk->sk_send_head == NULL)
-			sk->sk_send_head = skb_peek(skbs);
-		/* Queue data, but don't send. */
-		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
-		BT_DBG("Enter LOCAL_BUSY");
-		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-			/* The SREJ_SENT state must be aborted if we are to
-			 * enter the LOCAL_BUSY state.
-			 */
-			l2cap_ertm_abort_rx_srej_sent(sk);
-		}
-
-		l2cap_ertm_send_ack(sk);
-
-		break;
-	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
-		BT_DBG("Exit LOCAL_BUSY");
-		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
-
-		if (pi->conn_state & L2CAP_CONN_SENT_RNR) {
-			struct bt_l2cap_control local_control;
-			memset(&local_control, 0, sizeof(local_control));
-			local_control.frame_type = 's';
-			local_control.super = L2CAP_SFRAME_RR;
-			local_control.poll = 1;
-			local_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &local_control);
-
-			pi->retry_count = 1;
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-
-		/* Fall through */
-
-	case L2CAP_ERTM_EVENT_RECV_FBIT:
-		if (control && control->final) {
-			l2cap_ertm_stop_monitor_timer(pi);
-			if (pi->unacked_frames > 0)
-				l2cap_ertm_start_retrans_timer(pi);
-			pi->retry_count = 0;
-			pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-			BT_DBG("recv fbit tx_state 0x2.2%x", pi->tx_state);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
-		/* Ignore */
-		break;
-	case L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES:
-		if ((pi->max_tx == 0) || (pi->retry_count < pi->max_tx)) {
-			l2cap_ertm_send_rr_or_rnr(sk, 1);
-			l2cap_ertm_start_monitor_timer(pi);
-			pi->retry_count += 1;
-		} else
-			l2cap_send_disconn_req(pi->conn, sk, ECONNABORTED);
-		break;
-	default:
-		break;
-	}
+static inline bool __l2cap_efs_supported(struct l2cap_chan *chan)
+{
+	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_FLOW;
+}
 
-	return err;
+static inline void l2cap_txwin_setup(struct l2cap_chan *chan)
+{
+	if (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&
+						__l2cap_ews_supported(chan)) {
+		/* use extended control field */
+		set_bit(FLAG_EXT_CTRL, &chan->flags);
+		chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
+	} else {
+		chan->tx_win = min_t(u16, chan->tx_win,
+						L2CAP_DEFAULT_TX_WINDOW);
+		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
+	}
 }
 
-int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff_head *skbs, u8 event)
+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	struct l2cap_conf_req *req = data;
+	struct l2cap_conf_rfc rfc = { .mode = chan->mode };
+	void *ptr = req->data;
+	u16 size;
+
+	BT_DBG("chan %p", chan);
 
-	BT_DBG("sk %p, control %p, skbs %p, event %d, state %d",
-		sk, control, skbs, (int)event, l2cap_pi(sk)->tx_state);
+	if (chan->num_conf_req || chan->num_conf_rsp)
+		goto done;
+
+	switch (chan->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))
+			break;
 
-	pi = l2cap_pi(sk);
+		if (__l2cap_efs_supported(chan))
+			set_bit(FLAG_EFS_ENABLE, &chan->flags);
 
-	switch (pi->tx_state) {
-	case L2CAP_ERTM_TX_STATE_XMIT:
-		err = l2cap_ertm_tx_state_xmit(sk, control, skbs, event);
-		break;
-	case L2CAP_ERTM_TX_STATE_WAIT_F:
-		err = l2cap_ertm_tx_state_wait_f(sk, control, skbs, event);
-		break;
+		/* fall through */
 	default:
-		/* Ignore event */
+		chan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);
 		break;
 	}
 
-	return err;
-}
+done:
+	if (chan->imtu != L2CAP_DEFAULT_MTU)
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
 
-int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
-			struct msghdr *msg, size_t len, int reseg)
-{
-	struct sk_buff *skb;
-	u16 sdu_len;
-	size_t pdu_len;
-	int err = 0;
-	u8 sar;
+	switch (chan->mode) {
+	case L2CAP_MODE_BASIC:
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&
+				!(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))
+			break;
 
-	BT_DBG("sk %p, msg %p, len %d", sk, msg, (int)len);
+		rfc.mode            = L2CAP_MODE_BASIC;
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+		rfc.max_pdu_size    = 0;
 
-	/* It is critical that ERTM PDUs fit in a single HCI fragment,
-	 * so fragmented skbs are not used.  The HCI layer's handling
-	 * of fragmented skbs is not compatible with ERTM's queueing.
-	 */
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+		break;
 
-	/* PDU size is derived from the HCI MTU */
-	pdu_len = l2cap_pi(sk)->conn->mtu;
+	case L2CAP_MODE_ERTM:
+		rfc.mode            = L2CAP_MODE_ERTM;
+		rfc.max_transmit    = chan->max_tx;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
 
-	/* Constrain BR/EDR PDU size to fit within the largest radio packet */
-	if (!l2cap_pi(sk)->ampcon)
-		pdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);
-
-	/* Adjust for largest possible L2CAP overhead. */
-	pdu_len -= L2CAP_EXTENDED_HDR_SIZE + L2CAP_FCS_SIZE;
-
-	/* Remote device may have requested smaller PDUs */
-	pdu_len = min_t(size_t, pdu_len, l2cap_pi(sk)->remote_mps);
-
-	if (len <= pdu_len) {
-		sar = L2CAP_SAR_UNSEGMENTED;
-		sdu_len = 0;
-		pdu_len = len;
-	} else {
-		sar = L2CAP_SAR_START;
-		sdu_len = len;
-		pdu_len -= L2CAP_SDULEN_SIZE;
-	}
+		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+		rfc.max_pdu_size = cpu_to_le16(size);
 
-	while (len) {
-		skb = l2cap_create_iframe_pdu(sk, msg, pdu_len, sdu_len, reseg);
+		l2cap_txwin_setup(chan);
 
-		BT_DBG("iframe skb %p", skb);
+		rfc.txwin_size = min_t(u16, chan->tx_win,
+						L2CAP_DEFAULT_TX_WINDOW);
 
-		if (IS_ERR(skb)) {
-			__skb_queue_purge(seg_queue);
-			return PTR_ERR(skb);
-		}
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
+			l2cap_add_opt_efs(&ptr, chan);
 
-		bt_cb(skb)->control.sar = sar;
-		__skb_queue_tail(seg_queue, skb);
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
 
-		len -= pdu_len;
-		if (sdu_len) {
-			sdu_len = 0;
-			pdu_len += L2CAP_SDULEN_SIZE;
+		if (chan->fcs == L2CAP_FCS_NONE ||
+				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
+			chan->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
 		}
 
-		if (len <= pdu_len) {
-			sar = L2CAP_SAR_END;
-			pdu_len = len;
-		} else {
-			sar = L2CAP_SAR_CONTINUE;
+		if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
+								chan->tx_win);
+		break;
+
+	case L2CAP_MODE_STREAMING:
+		rfc.mode            = L2CAP_MODE_STREAMING;
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+
+		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+		rfc.max_pdu_size = cpu_to_le16(size);
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
+			l2cap_add_opt_efs(&ptr, chan);
+
+		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
+
+		if (chan->fcs == L2CAP_FCS_NONE ||
+				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
+			chan->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
 		}
+		break;
 	}
 
-	return err;
-}
+	req->dcid  = cpu_to_le16(chan->dcid);
+	req->flags = cpu_to_le16(0);
 
-static inline int is_initial_frame(u8 sar)
-{
-	return (sar == L2CAP_SAR_UNSEGMENTED ||
-		sar == L2CAP_SAR_START);
+	return ptr - data;
 }
 
-static inline int l2cap_skbuff_to_kvec(struct sk_buff *skb, struct kvec *iv,
-					size_t veclen)
+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)
 {
-	struct sk_buff *frag_iter;
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = chan->conf_req;
+	int len = chan->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_efs efs;
+	u8 remote_efs = 0;
+	u16 mtu = L2CAP_DEFAULT_MTU;
+	u16 result = L2CAP_CONF_SUCCESS;
+	u16 size;
 
-	BT_DBG("skb %p (len %d), iv %p", skb, (int)skb->len, iv);
+	BT_DBG("chan %p", chan);
 
-	if (iv->iov_len + skb->len > veclen)
-		return -ENOMEM;
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
 
-	memcpy(iv->iov_base + iv->iov_len, skb->data, skb->len);
-	iv->iov_len += skb->len;
+		hint  = type & L2CAP_CONF_HINT;
+		type &= L2CAP_CONF_MASK;
 
-	skb_walk_frags(skb, frag_iter) {
-		if (iv->iov_len + skb->len > veclen)
-			return -ENOMEM;
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			mtu = val;
+			break;
 
-		BT_DBG("Copying %d bytes", (int)frag_iter->len);
-		memcpy(iv->iov_base + iv->iov_len, frag_iter->data,
-			frag_iter->len);
-		iv->iov_len += frag_iter->len;
-	}
+		case L2CAP_CONF_FLUSH_TO:
+			chan->flush_to = val;
+			break;
 
-	return 0;
-}
+		case L2CAP_CONF_QOS:
+			break;
 
-int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue)
-{
-	void *buf;
-	int buflen;
-	int err = 0;
-	struct sk_buff *skb;
-	struct msghdr msg;
-	struct kvec iv;
-	struct sk_buff_head old_frames;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *) val, olen);
+			break;
 
-	BT_DBG("sk %p", sk);
+		case L2CAP_CONF_FCS:
+			if (val == L2CAP_FCS_NONE)
+				set_bit(CONF_NO_FCS_RECV, &chan->conf_state);
+			break;
 
-	if (skb_queue_empty(queue))
-		return 0;
+		case L2CAP_CONF_EFS:
+			remote_efs = 1;
+			if (olen == sizeof(efs))
+				memcpy(&efs, (void *) val, olen);
+			break;
+
+		case L2CAP_CONF_EWS:
+			if (!enable_hs)
+				return -ECONNREFUSED;
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = (struct iovec *) &iv;
+			set_bit(FLAG_EXT_CTRL, &chan->flags);
+			set_bit(CONF_EWS_RECV, &chan->conf_state);
+			chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
+			chan->remote_tx_win = val;
+			break;
 
-	buflen = pi->omtu + L2CAP_FCS_SIZE;
-	buf = kzalloc(buflen, GFP_TEMPORARY);
+		default:
+			if (hint)
+				break;
 
-	if (!buf) {
-		BT_DBG("Could not allocate resegmentation buffer");
-		return -ENOMEM;
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+		}
 	}
 
-	/* Move current frames off the original queue */
-	__skb_queue_head_init(&old_frames);
-	skb_queue_splice_tail_init(queue, &old_frames);
+	if (chan->num_conf_rsp || chan->num_conf_req > 1)
+		goto done;
 
-	while (!skb_queue_empty(&old_frames)) {
-		struct sk_buff_head current_sdu;
-		u8 original_sar;
+	switch (chan->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {
+			chan->mode = l2cap_select_mode(rfc.mode,
+					chan->conn->feat_mask);
+			break;
+		}
 
-		/* Reassemble each SDU from one or more PDUs */
+		if (remote_efs) {
+			if (__l2cap_efs_supported(chan))
+				set_bit(FLAG_EFS_ENABLE, &chan->flags);
+			else
+				return -ECONNREFUSED;
+		}
 
-		iv.iov_base = buf;
-		iv.iov_len = 0;
+		if (chan->mode != rfc.mode)
+			return -ECONNREFUSED;
 
-		skb = skb_peek(&old_frames);
-		original_sar = bt_cb(skb)->control.sar;
+		break;
+	}
 
-		__skb_unlink(skb, &old_frames);
+done:
+	if (chan->mode != rfc.mode) {
+		result = L2CAP_CONF_UNACCEPT;
+		rfc.mode = chan->mode;
 
-		/* Append data to SDU */
-		if (pi->extended_control)
-			skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
-		else
-			skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
+		if (chan->num_conf_rsp == 1)
+			return -ECONNREFUSED;
 
-		if (original_sar == L2CAP_SAR_START)
-			skb_pull(skb, L2CAP_SDULEN_SIZE);
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+	}
 
-		err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
 
-		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
-			iv.iov_len -= L2CAP_FCS_SIZE;
+		if (mtu < L2CAP_DEFAULT_MIN_MTU)
+			result = L2CAP_CONF_UNACCEPT;
+		else {
+			chan->omtu = mtu;
+			set_bit(CONF_MTU_DONE, &chan->conf_state);
+		}
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu);
 
-		/* Free skb */
-		kfree_skb(skb);
+		if (remote_efs) {
+			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != chan->local_stype) {
 
-		if (err)
-			break;
+				result = L2CAP_CONF_UNACCEPT;
 
-		while (!skb_queue_empty(&old_frames) && !err) {
-			/* Check next frame */
-			skb = skb_peek(&old_frames);
+				if (chan->num_conf_req >= 1)
+					return -ECONNREFUSED;
 
-			if (is_initial_frame(bt_cb(skb)->control.sar))
-				break;
+				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+							sizeof(efs),
+							(unsigned long) &efs);
+			} else {
+				/* Send PENDING Conf Rsp */
+				result = L2CAP_CONF_PENDING;
+				set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+			}
+		}
 
-			__skb_unlink(skb, &old_frames);
+		switch (rfc.mode) {
+		case L2CAP_MODE_BASIC:
+			chan->fcs = L2CAP_FCS_NONE;
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
+			break;
 
-			/* Append data to SDU */
-			if (pi->extended_control)
-				skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
+		case L2CAP_MODE_ERTM:
+			if (!test_bit(CONF_EWS_RECV, &chan->conf_state))
+				chan->remote_tx_win = rfc.txwin_size;
 			else
-				skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
+				rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;
 
-			if (bt_cb(skb)->control.sar == L2CAP_SAR_START)
-				skb_pull(skb, L2CAP_SDULEN_SIZE);
+			chan->remote_max_tx = rfc.max_transmit;
 
-			err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
+			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
+						chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+			rfc.max_pdu_size = cpu_to_le16(size);
+			chan->remote_mps = size;
+
+			rfc.retrans_timeout =
+				le16_to_cpu(L2CAP_DEFAULT_RETRANS_TO);
+			rfc.monitor_timeout =
+				le16_to_cpu(L2CAP_DEFAULT_MONITOR_TO);
 
-			if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
-				iv.iov_len -= L2CAP_FCS_SIZE;
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
 
-			/* Free skb */
-			kfree_skb(skb);
-		}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
 
-		if (err)
+			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
+				chan->remote_id = efs.id;
+				chan->remote_stype = efs.stype;
+				chan->remote_msdu = le16_to_cpu(efs.msdu);
+				chan->remote_flush_to =
+						le32_to_cpu(efs.flush_to);
+				chan->remote_acc_lat =
+						le32_to_cpu(efs.acc_lat);
+				chan->remote_sdu_itime =
+					le32_to_cpu(efs.sdu_itime);
+				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+					sizeof(efs), (unsigned long) &efs);
+			}
 			break;
 
-		/* Segment data */
+		case L2CAP_MODE_STREAMING:
+			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
+						chan->conn->mtu -
+						L2CAP_EXT_HDR_SIZE -
+						L2CAP_SDULEN_SIZE -
+						L2CAP_FCS_SIZE);
+			rfc.max_pdu_size = cpu_to_le16(size);
+			chan->remote_mps = size;
 
-		__skb_queue_head_init(&current_sdu);
+			set_bit(CONF_MODE_DONE, &chan->conf_state);
 
-		/* skbs for the SDU were just freed, but the
-		 * resegmenting process could produce more, smaller
-		 * skbs due to smaller PDUs and reduced HCI MTU.  The
-		 * overhead from the sk_buff structs could put us over
-		 * the sk_sndbuf limit.
-		 *
-		 * Since this code is running in response to a
-		 * received poll/final packet, it cannot block.
-		 * Therefore, memory allocation needs to be allowed by
-		 * falling back to bt_skb_alloc() (with
-		 * skb_set_owner_w() to maintain sk_wmem_alloc
-		 * correctly).
-		 */
-		msg.msg_iovlen = iv.iov_len;
-		err = l2cap_segment_sdu(sk, &current_sdu, &msg,
-					msg.msg_iovlen, 1);
-
-		if (err || skb_queue_empty(&current_sdu)) {
-			BT_DBG("Error %d resegmenting data for socket %p",
-				err, sk);
-			__skb_queue_purge(&current_sdu);
-			break;
-		}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
 
-		/* Fix up first PDU SAR bits */
-		if (!is_initial_frame(original_sar)) {
-			BT_DBG("Changing SAR bits, %d PDUs",
-				skb_queue_len(&current_sdu));
-			skb = skb_peek(&current_sdu);
-
-			if (skb_queue_len(&current_sdu) == 1) {
-				/* Change SAR from 'unsegmented' to 'end' */
-				bt_cb(skb)->control.sar = L2CAP_SAR_END;
-			} else {
-				struct l2cap_hdr *lh;
-				size_t hdrlen;
+			break;
 
-				/* Change SAR from 'start' to 'continue' */
-				bt_cb(skb)->control.sar = L2CAP_SAR_CONTINUE;
+		default:
+			result = L2CAP_CONF_UNACCEPT;
 
-				/* Start frames contain 2 bytes for
-				 * sdulen and continue frames don't.
-				 * Must rewrite header to eliminate
-				 * sdulen and then adjust l2cap frame
-				 * length.
-				 */
-				if (pi->extended_control)
-					hdrlen = L2CAP_EXTENDED_HDR_SIZE;
-				else
-					hdrlen = L2CAP_ENHANCED_HDR_SIZE;
-
-				memmove(skb->data + L2CAP_SDULEN_SIZE,
-					skb->data, hdrlen);
-				skb_pull(skb, L2CAP_SDULEN_SIZE);
-				lh = (struct l2cap_hdr *)skb->data;
-				lh->len = cpu_to_le16(le16_to_cpu(lh->len) -
-							L2CAP_SDULEN_SIZE);
-			}
+			memset(&rfc, 0, sizeof(rfc));
+			rfc.mode = chan->mode;
 		}
 
-		/* Add to queue */
-		skb_queue_splice_tail(&current_sdu, queue);
+		if (result == L2CAP_CONF_SUCCESS)
+			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
 	}
+	rsp->scid   = cpu_to_le16(chan->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
 
-	__skb_queue_purge(&old_frames);
-	if (err)
-		__skb_queue_purge(queue);
-
-	kfree(buf);
-
-	BT_DBG("Queue resegmented, err=%d", err);
-	return err;
+	return ptr - data;
 }
 
-static void l2cap_resegment_worker(struct work_struct *work)
+static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, u16 *result)
 {
-	int err = 0;
-	struct l2cap_resegment_work *seg_work =
-		container_of(work, struct l2cap_resegment_work, work);
-	struct sock *sk = seg_work->sk;
+	struct l2cap_conf_req *req = data;
+	void *ptr = req->data;
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_efs efs;
 
-	kfree(seg_work);
+	BT_DBG("chan %p, rsp %p, len %d, req %p", chan, rsp, len, data);
 
-	BT_DBG("sk %p", sk);
-	lock_sock(sk);
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
 
-	if (l2cap_pi(sk)->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
-		release_sock(sk);
-		sock_put(sk);
-		return;
-	}
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			if (val < L2CAP_DEFAULT_MIN_MTU) {
+				*result = L2CAP_CONF_UNACCEPT;
+				chan->imtu = L2CAP_DEFAULT_MIN_MTU;
+			} else
+				chan->imtu = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
+			break;
 
-	err = l2cap_resegment_queue(sk, TX_QUEUE(sk));
+		case L2CAP_CONF_FLUSH_TO:
+			chan->flush_to = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
+							2, chan->flush_to);
+			break;
 
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *)val, olen);
 
-	if (skb_queue_empty(TX_QUEUE(sk)))
-		sk->sk_send_head = NULL;
-	else
-		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
+			if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&
+							rfc.mode != chan->mode)
+				return -ECONNREFUSED;
 
-	if (err)
-		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
-	else
-		l2cap_ertm_send(sk);
+			chan->fcs = 0;
 
-	release_sock(sk);
-	sock_put(sk);
-}
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+			break;
 
-static int l2cap_setup_resegment(struct sock *sk)
-{
-	struct l2cap_resegment_work *seg_work;
+		case L2CAP_CONF_EWS:
+			chan->tx_win = min_t(u16, val,
+						L2CAP_DEFAULT_EXT_WINDOW);
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
+							chan->tx_win);
+			break;
 
-	BT_DBG("sk %p", sk);
+		case L2CAP_CONF_EFS:
+			if (olen == sizeof(efs))
+				memcpy(&efs, (void *)val, olen);
+
+			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != L2CAP_SERV_NOTRAFIC &&
+					efs.stype != chan->local_stype)
+				return -ECONNREFUSED;
 
-	if (skb_queue_empty(TX_QUEUE(sk)))
-		return 0;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
+					sizeof(efs), (unsigned long) &efs);
+			break;
+		}
+	}
 
-	seg_work = kzalloc(sizeof(*seg_work), GFP_ATOMIC);
-	if (!seg_work)
-		return -ENOMEM;
+	if (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)
+		return -ECONNREFUSED;
+
+	chan->mode = rfc.mode;
 
-	INIT_WORK(&seg_work->work, l2cap_resegment_worker);
-	sock_hold(sk);
-	seg_work->sk = sk;
+	if (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {
+		switch (rfc.mode) {
+		case L2CAP_MODE_ERTM:
+			chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+			chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+
+			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
+				chan->local_msdu = le16_to_cpu(efs.msdu);
+				chan->local_sdu_itime =
+						le32_to_cpu(efs.sdu_itime);
+				chan->local_acc_lat = le32_to_cpu(efs.acc_lat);
+				chan->local_flush_to =
+						le32_to_cpu(efs.flush_to);
+			}
+			break;
 
-	if (!queue_work(_l2cap_wq, &seg_work->work)) {
-		kfree(seg_work);
-		sock_put(sk);
-		return -ENOMEM;
+		case L2CAP_MODE_STREAMING:
+			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+		}
 	}
 
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_RESEGMENT;
+	req->dcid   = cpu_to_le16(chan->dcid);
+	req->flags  = cpu_to_le16(0x0000);
 
-	return 0;
+	return ptr - data;
 }
 
-static inline int l2cap_rmem_available(struct sock *sk)
+static int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data, u16 result, u16 flags)
 {
-	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
-		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
-	return atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf / 3;
-}
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
 
-static inline int l2cap_rmem_full(struct sock *sk)
-{
-	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
-		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
-	return atomic_read(&sk->sk_rmem_alloc) > (2 * sk->sk_rcvbuf) / 3;
+	BT_DBG("chan %p", chan);
+
+	rsp->scid   = cpu_to_le16(chan->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(flags);
+
+	return ptr - data;
 }
 
-void l2cap_amp_move_init(struct sock *sk)
+void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)
 {
-	BT_DBG("sk %p", sk);
+	struct l2cap_conn_rsp rsp;
+	struct l2cap_conn *conn = chan->conn;
+	u8 buf[128];
 
-	if (!l2cap_pi(sk)->conn)
-		return;
+	rsp.scid   = cpu_to_le16(chan->dcid);
+	rsp.dcid   = cpu_to_le16(chan->scid);
+	rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+	rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+	l2cap_send_cmd(conn, chan->ident,
+				L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
-	if (!(l2cap_pi(sk)->conn->fc_mask & L2CAP_FC_A2MP) || !enable_hs)
+	if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
 		return;
 
-	if (l2cap_pi(sk)->amp_id == 0) {
-		if (l2cap_pi(sk)->amp_pref != BT_AMP_POLICY_PREFER_AMP)
-			return;
-		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
-		l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
-		amp_create_physical(l2cap_pi(sk)->conn, sk);
-	} else {
-		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
-		l2cap_pi(sk)->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-		l2cap_pi(sk)->amp_move_id = 0;
-		l2cap_amp_move_setup(sk);
-		l2cap_send_move_chan_req(l2cap_pi(sk)->conn,
-					l2cap_pi(sk), l2cap_pi(sk)->scid, 0);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-	}
+	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+			l2cap_build_conf_req(chan, buf), buf);
+	chan->num_conf_req++;
 }
 
-static void l2cap_chan_ready(struct sock *sk)
+static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)
 {
-	struct sock *parent = bt_sk(sk)->parent;
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc;
 
-	BT_DBG("sk %p, parent %p", sk, parent);
+	BT_DBG("chan %p, rsp %p, len %d", chan, rsp, len);
 
-	l2cap_pi(sk)->conf_state = 0;
-	l2cap_sock_clear_timer(sk);
+	if ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))
+		return;
 
-	if (!parent) {
-		/* Outgoing channel.
-		 * Wake up socket sleeping on connect.
-		 */
-		sk->sk_state = BT_CONNECTED;
-		sk->sk_state_change(sk);
-	} else {
-		/* Incoming channel.
-		 * Wake up socket sleeping on accept.
-		 */
-		parent->sk_data_ready(parent, 0);
-	}
-}
-
-/* Copy frame to all raw sockets on that connection */
-static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sk_buff *nskb;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (sk->sk_type != SOCK_RAW)
-			continue;
-
-		/* Don't send frame to the socket it came from */
-		if (skb->sk == sk)
-			continue;
-		nskb = skb_clone(skb, GFP_ATOMIC);
-		if (!nskb)
-			continue;
-
-		if (sock_queue_rcv_skb(sk, nskb))
-			kfree_skb(nskb);
-	}
-	read_unlock(&l->lock);
-}
-
-/* ---- L2CAP signalling commands ---- */
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data)
-{
-	struct sk_buff *skb, **frag;
-	struct l2cap_cmd_hdr *cmd;
-	struct l2cap_hdr *lh;
-	int len, count;
-	unsigned int mtu = conn->hcon->hdev->acl_mtu;
-
-	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
-			conn, code, ident, dlen);
-
-	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
-	count = min_t(unsigned int, mtu, len);
-
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return NULL;
-
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
-
-	if (conn->hcon->type == LE_LINK)
-		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
-	else
-		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
-
-	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
-	cmd->code  = code;
-	cmd->ident = ident;
-	cmd->len   = cpu_to_le16(dlen);
-
-	if (dlen) {
-		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
-		memcpy(skb_put(skb, count), data, count);
-		data += count;
-	}
-
-	len -= skb->len;
-
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		count = min_t(unsigned int, mtu, len);
-
-		*frag = bt_skb_alloc(count, GFP_ATOMIC);
-		if (!*frag)
-			goto fail;
-
-		memcpy(skb_put(*frag, count), data, count);
-
-		len  -= count;
-		data += count;
-
-		frag = &(*frag)->next;
-	}
-
-	return skb;
-
-fail:
-	kfree_skb(skb);
-	return NULL;
-}
-
-static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-	int len;
-
-	len = L2CAP_CONF_OPT_SIZE + opt->len;
-	*ptr += len;
-
-	*type = opt->type;
-	*olen = opt->len;
-
-	switch (opt->len) {
-	case 1:
-		*val = *((u8 *) opt->val);
-		break;
-
-	case 2:
-		*val = get_unaligned_le16(opt->val);
-		break;
-
-	case 4:
-		*val = get_unaligned_le32(opt->val);
-		break;
-
-	default:
-		*val = (unsigned long) opt->val;
-		break;
-	}
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
-	return len;
-}
-
-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
-
-	opt->type = type;
-	opt->len  = len;
-
-	switch (len) {
-	case 1:
-		*((u8 *) opt->val)  = val;
-		break;
-
-	case 2:
-		put_unaligned_le16(val, opt->val);
-		break;
-
-	case 4:
-		put_unaligned_le32(val, opt->val);
-		break;
-
-	default:
-		memcpy(opt->val, (void *) val, len);
-		break;
-	}
-
-	*ptr += L2CAP_CONF_OPT_SIZE + len;
-}
-
-static void l2cap_ertm_ack_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, ack_work);
-	struct sock *sk = (struct sock *)pi;
-	u16 frames_to_ack;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	frames_to_ack = __delta_seq(l2cap_pi(sk)->buffer_seq,
-				    l2cap_pi(sk)->last_acked_seq,
-				    l2cap_pi(sk));
-
-	if (frames_to_ack)
-		l2cap_ertm_send_rr_or_rnr(sk, 0);
-
-	release_sock(sk);
-}
-
-static void l2cap_ertm_retrans_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, retrans_work);
-	struct sock *sk = (struct sock *)pi;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES);
-	release_sock(sk);
-}
-
-static void l2cap_ertm_monitor_timeout(struct work_struct *work)
-{
-	struct delayed_work *delayed =
-		container_of(work, struct delayed_work, work);
-	struct l2cap_pinfo *pi =
-		container_of(delayed, struct l2cap_pinfo, monitor_work);
-	struct sock *sk = (struct sock *)pi;
-
-	BT_DBG("sk %p", sk);
-
-	if (!sk)
-		return;
-
-	lock_sock(sk);
-
-	if (!l2cap_pi(sk)->conn) {
-		release_sock(sk);
-		return;
-	}
-
-	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES);
-
-	release_sock(sk);
-}
-
-static inline void l2cap_ertm_init(struct sock *sk)
-{
-	l2cap_pi(sk)->next_tx_seq = 0;
-	l2cap_pi(sk)->expected_tx_seq = 0;
-	l2cap_pi(sk)->expected_ack_seq = 0;
-	l2cap_pi(sk)->unacked_frames = 0;
-	l2cap_pi(sk)->buffer_seq = 0;
-	l2cap_pi(sk)->frames_sent = 0;
-	l2cap_pi(sk)->last_acked_seq = 0;
-	l2cap_pi(sk)->sdu = NULL;
-	l2cap_pi(sk)->sdu_last_frag = NULL;
-	l2cap_pi(sk)->sdu_len = 0;
-	atomic_set(&l2cap_pi(sk)->ertm_queued, 0);
-
-	l2cap_pi(sk)->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-	l2cap_pi(sk)->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-
-	BT_DBG("tx_state 0x2.2%x rx_state 0x2.2%x", l2cap_pi(sk)->tx_state,
-		l2cap_pi(sk)->rx_state);
-
-	l2cap_pi(sk)->amp_id = 0;
-	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
-	l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	l2cap_pi(sk)->amp_move_reqseq = 0;
-	l2cap_pi(sk)->amp_move_event = 0;
-
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->ack_work, l2cap_ertm_ack_timeout);
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->retrans_work,
-			l2cap_ertm_retrans_timeout);
-	INIT_DELAYED_WORK(&l2cap_pi(sk)->monitor_work,
-			l2cap_ertm_monitor_timeout);
-	INIT_WORK(&l2cap_pi(sk)->tx_work, l2cap_ertm_tx_worker);
-	skb_queue_head_init(SREJ_QUEUE(sk));
-	skb_queue_head_init(TX_QUEUE(sk));
-
-	l2cap_seq_list_init(&l2cap_pi(sk)->srej_list, l2cap_pi(sk)->tx_win);
-	l2cap_seq_list_init(&l2cap_pi(sk)->retrans_list,
-			l2cap_pi(sk)->remote_tx_win);
-}
-
-void l2cap_ertm_destruct(struct sock *sk)
-{
-	l2cap_seq_list_free(&l2cap_pi(sk)->srej_list);
-	l2cap_seq_list_free(&l2cap_pi(sk)->retrans_list);
-}
-
-void l2cap_ertm_shutdown(struct sock *sk)
-{
-	l2cap_ertm_stop_ack_timer(l2cap_pi(sk));
-	l2cap_ertm_stop_retrans_timer(l2cap_pi(sk));
-	l2cap_ertm_stop_monitor_timer(l2cap_pi(sk));
-}
-
-void l2cap_ertm_recv_done(struct sock *sk)
-{
-	lock_sock(sk);
-
-	if (l2cap_pi(sk)->mode != L2CAP_MODE_ERTM ||
-			sk->sk_state != BT_CONNECTED) {
-		release_sock(sk);
-		return;
-	}
-
-	/* Consume any queued incoming frames and update local busy status */
-	if (l2cap_pi(sk)->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT &&
-			l2cap_ertm_rx_queued_iframes(sk))
-		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
-	else if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-			l2cap_rmem_available(sk))
-		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
-
-	release_sock(sk);
-}
-
-static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
-{
-	switch (mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (l2cap_mode_supported(mode, remote_feat_mask))
-			return mode;
-		/* fall through */
-	default:
-		return L2CAP_MODE_BASIC;
-	}
-}
-
-static void l2cap_setup_txwin(struct l2cap_pinfo *pi)
-{
-	if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED &&
-		(pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW)) {
-		pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
-		pi->extended_control = 1;
-	} else {
-		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
-			pi->tx_win = L2CAP_TX_WIN_MAX_ENHANCED;
-
-		pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
-		pi->extended_control = 0;
-	}
-	pi->ack_win = pi->tx_win;
-}
-
-static void l2cap_aggregate_fs(struct hci_ext_fs *cur,
-		struct hci_ext_fs *new,
-		struct hci_ext_fs *agg)
-{
-	*agg = *cur;
-	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
-		/* current flow spec has known rate */
-		if ((new->max_sdu == 0xFFFF) ||
-				(new->sdu_arr_time == 0xFFFFFFFF)) {
-			/* new fs has unknown rate, so aggregate is unknown */
-			agg->max_sdu = 0xFFFF;
-			agg->sdu_arr_time = 0xFFFFFFFF;
-		} else {
-			/* new fs has known rate, so aggregate is known */
-			u64 cur_rate;
-			u64 new_rate;
-			cur_rate = cur->max_sdu * 1000000ULL;
-			if (cur->sdu_arr_time)
-				cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
-			new_rate = new->max_sdu * 1000000ULL;
-			if (new->sdu_arr_time)
-				new_rate = div_u64(new_rate, new->sdu_arr_time);
-			cur_rate = cur_rate + new_rate;
-			if (cur_rate)
-				agg->sdu_arr_time = div64_u64(
-					agg->max_sdu * 1000000ULL, cur_rate);
-		}
-	}
-}
-
-static int l2cap_aggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
-{
-	struct hci_ext_fs tx_fs;
-	struct hci_ext_fs rx_fs;
-
-	BT_DBG("chan %p", chan);
-
-	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
-			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
-			((chan->rx_fs.max_sdu == 0xFFFF) ||
-			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
-		return 0;
-
-	l2cap_aggregate_fs(&chan->tx_fs,
-				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
-	l2cap_aggregate_fs(&chan->rx_fs,
-				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
-	hci_chan_modify(chan, &tx_fs, &rx_fs);
-	return 1;
-}
-
-static void l2cap_deaggregate_fs(struct hci_ext_fs *cur,
-		struct hci_ext_fs *old,
-		struct hci_ext_fs *agg)
-{
-	*agg = *cur;
-	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
-		u64 cur_rate;
-		u64 old_rate;
-		cur_rate = cur->max_sdu * 1000000ULL;
-		if (cur->sdu_arr_time)
-			cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
-		old_rate = old->max_sdu * 1000000ULL;
-		if (old->sdu_arr_time)
-			old_rate = div_u64(old_rate, old->sdu_arr_time);
-		cur_rate = cur_rate - old_rate;
-		if (cur_rate)
-			agg->sdu_arr_time = div64_u64(
-				agg->max_sdu * 1000000ULL, cur_rate);
-	}
-}
-
-static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
-{
-	struct hci_ext_fs tx_fs;
-	struct hci_ext_fs rx_fs;
-
-	BT_DBG("chan %p", chan);
-
-	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
-			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
-			((chan->rx_fs.max_sdu == 0xFFFF) ||
-			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
-		return 0;
-
-	l2cap_deaggregate_fs(&chan->tx_fs,
-				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
-	l2cap_deaggregate_fs(&chan->rx_fs,
-				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
-	hci_chan_modify(chan, &tx_fs, &rx_fs);
-	return 1;
-}
-
-static struct hci_chan *l2cap_chan_admit(u8 amp_id, struct sock *sk)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct hci_dev *hdev;
-	struct hci_conn *hcon;
-	struct hci_chan *chan;
-
-	hdev = hci_dev_get(amp_id);
-	if (!hdev)
-		return NULL;
-
-	BT_DBG("hdev %s", hdev->name);
-
-	hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, pi->conn->dst);
-	if (!hcon) {
-		chan = NULL;
-		goto done;
-	}
-
-	chan = hci_chan_list_lookup_id(hdev, hcon->handle);
-	if (chan) {
-		l2cap_aggregate(chan, pi);
-		sock_hold(sk);
-		chan->l2cap_sk = sk;
-		hci_chan_hold(chan);
-		pi->ampchan = chan;
-		goto done;
-	}
-
-	chan = hci_chan_add(hdev);
-	if (chan) {
-		chan->conn = hcon;
-		sock_hold(sk);
-		chan->l2cap_sk = sk;
-		hci_chan_hold(chan);
-		pi->ampchan = chan;
-		hci_chan_create(chan,
-			(struct hci_ext_fs *) &pi->local_fs,
-			(struct hci_ext_fs *) &pi->remote_fs);
-	}
-done:
-	hci_dev_put(hdev);
-	return chan;
-}
-
-static void l2cap_get_ertm_timeouts(struct l2cap_conf_rfc *rfc,
-						struct l2cap_pinfo *pi)
-{
-	if (pi->amp_id && pi->ampcon) {
-		u64 ertm_to = pi->ampcon->hdev->amp_be_flush_to;
-
-		/* Class 1 devices have must have ERTM timeouts
-		 * exceeding the Link Supervision Timeout.  The
-		 * default Link Supervision Timeout for AMP
-		 * controllers is 10 seconds.
-		 *
-		 * Class 1 devices use 0xffffffff for their
-		 * best-effort flush timeout, so the clamping logic
-		 * will result in a timeout that meets the above
-		 * requirement.  ERTM timeouts are 16-bit values, so
-		 * the maximum timeout is 65.535 seconds.
-		 */
-
-		/* Convert timeout to milliseconds and round */
-		ertm_to = div_u64(ertm_to + 999, 1000);
-
-		/* This is the recommended formula for class 2 devices
-		 * that start ERTM timers when packets are sent to the
-		 * controller.
-		 */
-		ertm_to = 3 * ertm_to + 500;
-
-		if (ertm_to > 0xffff)
-			ertm_to = 0xffff;
-
-		rfc->retrans_timeout = cpu_to_le16((u16) ertm_to);
-		rfc->monitor_timeout = rfc->retrans_timeout;
-	} else {
-		rfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-		rfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	}
-}
-
-int l2cap_build_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
-	void *ptr = req->data;
-
-	BT_DBG("sk %p mode %d", sk, pi->mode);
-
-	if (pi->num_conf_req || pi->num_conf_rsp)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (pi->conf_state & L2CAP_CONF_STATE2_DEVICE)
-			break;
-
-		/* fall through */
-	default:
-		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
-		break;
-	}
-
-done:
-	if (pi->imtu != L2CAP_DEFAULT_MTU)
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_ERTM) &&
-				!(pi->conn->feat_mask & L2CAP_FEAT_STREAMING))
-			break;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = 0;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-		break;
-
-	case L2CAP_MODE_ERTM:
-		l2cap_setup_txwin(pi);
-		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
-			rfc.txwin_size = L2CAP_TX_WIN_MAX_ENHANCED;
-		else
-			rfc.txwin_size = pi->tx_win;
-		rfc.max_transmit = pi->max_tx;
-		rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		l2cap_get_ertm_timeouts(&rfc, pi);
-
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
-			pi->extended_control) {
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
-					pi->tx_win);
-		}
-
-		if (pi->amp_id) {
-			/* default best effort extended flow spec */
-			struct l2cap_conf_ext_fs fs = {1, 1, 0xFFFF,
-					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
-				sizeof(fs), (unsigned long) &fs);
-		}
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-
-	case L2CAP_MODE_STREAMING:
-		l2cap_setup_txwin(pi);
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
-			pi->extended_control) {
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2, 0);
-		}
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-	}
-
-	req->dcid  = cpu_to_le16(pi->dcid);
-	req->flags = cpu_to_le16(0);
-
-	return ptr - data;
-}
-
-
-static int l2cap_build_amp_reconf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
-	void *ptr = req->data;
-
-	BT_DBG("sk %p", sk);
-
-	switch (pi->mode) {
-	case L2CAP_MODE_ERTM:
-		rfc.mode            = L2CAP_MODE_ERTM;
-		rfc.txwin_size      = pi->tx_win;
-		rfc.max_transmit    = pi->max_tx;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		l2cap_get_ertm_timeouts(&rfc, pi);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
-			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
-
-		break;
-
-	default:
-		return -ECONNREFUSED;
-	}
-
-	l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-						(unsigned long) &rfc);
-
-	if (pi->conn->feat_mask & L2CAP_FEAT_FCS) {
-		/* TODO assign fcs for br/edr based on socket config option */
-		/* FCS is not used with AMP because it is redundant - lower
-		 * layers already include a checksum. */
-		if (pi->amp_id)
-			pi->local_conf.fcs = L2CAP_FCS_NONE;
-		else
-			pi->local_conf.fcs = L2CAP_FCS_CRC16;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->local_conf.fcs);
-		pi->fcs = pi->local_conf.fcs | pi->remote_conf.fcs;
-	}
-
-	req->dcid  = cpu_to_le16(pi->dcid);
-	req->flags = cpu_to_le16(0);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = pi->conf_req;
-	int len = pi->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_ext_fs fs;
-	u16 mtu = L2CAP_DEFAULT_MTU;
-	u16 result = L2CAP_CONF_SUCCESS;
-
-	BT_DBG("sk %p", sk);
-
-	if (pi->omtu > mtu)
-		mtu = pi->omtu;
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
-
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				result = L2CAP_CONF_UNACCEPT;
-			else
-				pi->remote_conf.flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				result = L2CAP_CONF_UNACCEPT;
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
-
-		case L2CAP_CONF_FCS:
-			if (val == L2CAP_FCS_NONE)
-				pi->conf_state |= L2CAP_CONF_NO_FCS_RECV;
-			pi->remote_conf.fcs = val;
-			break;
-
-		case L2CAP_CONF_EXT_FS:
-			if (olen == sizeof(fs)) {
-				pi->conf_state |= L2CAP_CONF_EFS_RECV;
-				if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
-					result = L2CAP_CONF_UNACCEPT;
-					break;
-				}
-				memcpy(&fs, (void *) val, olen);
-				if (fs.type != L2CAP_SERVICE_BEST_EFFORT) {
-					result = L2CAP_CONF_FLOW_SPEC_REJECT;
-					break;
-				}
-				pi->remote_conf.flush_to =
-						le32_to_cpu(fs.flush_to);
-				pi->remote_fs.id = fs.id;
-				pi->remote_fs.type = fs.type;
-				pi->remote_fs.max_sdu =
-						le16_to_cpu(fs.max_sdu);
-				pi->remote_fs.sdu_arr_time =
-						le32_to_cpu(fs.sdu_arr_time);
-				pi->remote_fs.acc_latency =
-						le32_to_cpu(fs.acc_latency);
-				pi->remote_fs.flush_to =
-						le32_to_cpu(fs.flush_to);
-			}
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			pi->extended_control = 1;
-			pi->remote_tx_win = val;
-			pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
-			pi->conf_state |= L2CAP_CONF_EXT_WIN_RECV;
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-		}
-	}
-
-	if (pi->num_conf_rsp || pi->num_conf_req > 1)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {
-			pi->mode = l2cap_select_mode(rfc.mode,
-					pi->conn->feat_mask);
-			break;
-		}
-
-		if (pi->mode != rfc.mode)
-			return -ECONNREFUSED;
-
-		break;
-	}
-
-done:
-	if (pi->mode != rfc.mode) {
-		result = L2CAP_CONF_UNACCEPT;
-		rfc.mode = pi->mode;
-		if (mtu > L2CAP_DEFAULT_MTU)
-			pi->omtu = mtu;
-
-		if (pi->num_conf_rsp == 1)
-			return -ECONNREFUSED;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
-
-
-	if ((pi->conf_state & L2CAP_CONF_LOCKSTEP) &&
-			!(pi->conf_state & L2CAP_CONF_EFS_RECV))
-		return -ECONNREFUSED;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
-
-		if (mtu < L2CAP_DEFAULT_MIN_MTU) {
-			result = L2CAP_CONF_UNACCEPT;
-			pi->omtu = L2CAP_DEFAULT_MIN_MTU;
-		} else {
-			pi->omtu = mtu;
-			pi->conf_state |= L2CAP_CONF_MTU_DONE;
-		}
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
-
-		switch (rfc.mode) {
-		case L2CAP_MODE_BASIC:
-			pi->fcs = L2CAP_FCS_NONE;
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-			break;
-
-		case L2CAP_MODE_ERTM:
-			if (!(pi->conf_state & L2CAP_CONF_EXT_WIN_RECV))
-				pi->remote_tx_win = rfc.txwin_size;
-			pi->remote_max_tx = rfc.max_transmit;
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-			l2cap_get_ertm_timeouts(&rfc, pi);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
-				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
-					sizeof(fs), (unsigned long) &fs);
-
-			break;
-
-		case L2CAP_MODE_STREAMING:
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			break;
-
-		default:
-			result = L2CAP_CONF_UNACCEPT;
-
-			memset(&rfc, 0, sizeof(rfc));
-			rfc.mode = pi->mode;
-		}
-
-		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
-				!(pi->conf_state & L2CAP_CONF_PEND_SENT)) {
-			pi->conf_state |= L2CAP_CONF_PEND_SENT;
-			result = L2CAP_CONF_PENDING;
-
-			if (pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND &&
-					pi->amp_id) {
-				struct hci_chan *chan;
-				/* Trigger logical link creation only on AMP */
-
-				chan = l2cap_chan_admit(pi->amp_id, sk);
-				if (!chan)
-					return -ECONNREFUSED;
-
-				if (chan->state == BT_CONNECTED)
-					l2cap_create_cfm(chan, 0);
-			}
-		}
-
-		if (result == L2CAP_CONF_SUCCESS)
-			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
-	}
-	rsp->scid   = cpu_to_le16(pi->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_amp_move_reconf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = pi->conf_req;
-	int len = pi->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_ext_fs fs;
-	u16 mtu = pi->omtu;
-	u16 tx_win = pi->remote_tx_win;
-	u16 result = L2CAP_CONF_SUCCESS;
-
-	BT_DBG("sk %p", sk);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
-
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			if (pi->amp_move_id)
-				result = L2CAP_CONF_UNACCEPT;
-			else
-				pi->remote_conf.flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			if (pi->amp_move_id)
-				result = L2CAP_CONF_UNACCEPT;
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
-
-		case L2CAP_CONF_FCS:
-			pi->remote_conf.fcs = val;
-			break;
-
-		case L2CAP_CONF_EXT_FS:
-			if (olen == sizeof(fs)) {
-				memcpy(&fs, (void *) val, olen);
-				if (fs.type != L2CAP_SERVICE_BEST_EFFORT)
-					result = L2CAP_CONF_FLOW_SPEC_REJECT;
-				else {
-					pi->remote_conf.flush_to =
-						le32_to_cpu(fs.flush_to);
-				}
-			}
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			tx_win = val;
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-			}
-	}
-
-	BT_DBG("result 0x%2.2x cur mode 0x%2.2x req  mode 0x%2.2x",
-		result, pi->mode, rfc.mode);
-
-	if (pi->mode != rfc.mode || rfc.mode == L2CAP_MODE_BASIC)
-		result = L2CAP_CONF_UNACCEPT;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
-
-		/* Don't allow mtu to decrease. */
-		if (mtu < pi->omtu)
-			result = L2CAP_CONF_UNACCEPT;
-
-		BT_DBG("mtu %d omtu %d", mtu, pi->omtu);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
-
-		/* Don't allow extended transmit window to change. */
-		if (tx_win != pi->remote_tx_win) {
-			result = L2CAP_CONF_UNACCEPT;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
-					pi->remote_tx_win);
-		}
-
-		pi->remote_mps = rfc.max_pdu_size;
-
-		if (rfc.mode == L2CAP_MODE_ERTM) {
-			l2cap_get_ertm_timeouts(&rfc, pi);
-		} else {
-			rfc.retrans_timeout = 0;
-			rfc.monitor_timeout = 0;
-		}
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
-
-	if (result != L2CAP_CONF_SUCCESS)
-		goto done;
-
-	pi->fcs = pi->remote_conf.fcs | pi->local_conf.fcs;
-
-	if (pi->rx_state == L2CAP_ERTM_RX_STATE_WAIT_F_FLAG)
-		pi->flush_to = pi->remote_conf.flush_to;
-
-done:
-	rsp->scid   = cpu_to_le16(pi->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	void *ptr = req->data;
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-
-	BT_DBG("sk %p, rsp %p, len %d, req %p", sk, rsp, len, data);
-
-	/* Initialize rfc in case no rfc option is received */
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			if (val < L2CAP_DEFAULT_MIN_MTU) {
-				*result = L2CAP_CONF_UNACCEPT;
-				pi->imtu = L2CAP_DEFAULT_MIN_MTU;
-			} else
-				pi->imtu = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
-							2, pi->flush_to);
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-
-			if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
-							rfc.mode != pi->mode)
-				return -ECONNREFUSED;
-
-			pi->fcs = 0;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-			break;
-
-		case L2CAP_CONF_EXT_WINDOW:
-			pi->ack_win = min_t(u16, val, pi->ack_win);
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW,
-					2, pi->tx_win);
-			break;
-
-		default:
-			break;
-		}
-	}
-
-	if (pi->mode == L2CAP_MODE_BASIC && pi->mode != rfc.mode)
-		return -ECONNREFUSED;
-
-	pi->mode = rfc.mode;
-
-	if (*result == L2CAP_CONF_SUCCESS) {
-		switch (rfc.mode) {
-		case L2CAP_MODE_ERTM:
-			pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-			pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-			if (!pi->extended_control) {
-				pi->ack_win = min_t(u16, pi->ack_win,
-						    rfc.txwin_size);
-			}
-			break;
-		case L2CAP_MODE_STREAMING:
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		}
-	}
-
-	req->dcid   = cpu_to_le16(pi->dcid);
-	req->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
-{
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-
-	BT_DBG("sk %p", sk);
-
-	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(flags);
-
-	return ptr - data;
-}
-
-static void l2cap_conf_rfc_get(struct sock *sk, void *rsp, int len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-	u16 txwin_ext = pi->ack_win;
-
-	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
-
-	/* Initialize rfc in case no rfc option is received */
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-	rfc.txwin_size = min_t(u16, pi->ack_win, L2CAP_DEFAULT_TX_WINDOW);
-
-	if ((pi->mode != L2CAP_MODE_ERTM) && (pi->mode != L2CAP_MODE_STREAMING))
-		return;
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-			break;
-		case L2CAP_CONF_EXT_WINDOW:
-			txwin_ext = val;
-			break;
-		}
-	}
-
-	switch (rfc.mode) {
-	case L2CAP_MODE_ERTM:
-		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		if (pi->extended_control)
-			pi->ack_win = min_t(u16, pi->ack_win, txwin_ext);
-		else
-			pi->ack_win = min_t(u16, pi->ack_win, rfc.txwin_size);
-		break;
-	case L2CAP_MODE_STREAMING:
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-	}
-}
-
-static void l2cap_conf_ext_fs_get(struct sock *sk, void *rsp, int len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_ext_fs fs;
-
-	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-		if ((type == L2CAP_CONF_EXT_FS) &&
-				(olen == sizeof(struct l2cap_conf_ext_fs))) {
-			memcpy(&fs, (void *)val, olen);
-			pi->local_fs.id = fs.id;
-			pi->local_fs.type = fs.type;
-			pi->local_fs.max_sdu = le16_to_cpu(fs.max_sdu);
-			pi->local_fs.sdu_arr_time =
-						le32_to_cpu(fs.sdu_arr_time);
-			pi->local_fs.acc_latency = le32_to_cpu(fs.acc_latency);
-			pi->local_fs.flush_to = le32_to_cpu(fs.flush_to);
-			break;
-		}
-	}
-
-}
-
-static int l2cap_finish_amp_move(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	int err =0;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
-
-	pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-
-	if (pi->ampcon)
-		pi->conn->mtu = pi->ampcon->hdev->acl_mtu;
-	else
-		pi->conn->mtu = pi->conn->hcon->hdev->acl_mtu;
-
-	err = l2cap_setup_resegment(sk);
-
-	return err;
-}
-
-static int l2cap_amp_move_reconf_rsp(struct sock *sk, void *rsp, int len,
-					u16 result)
-{
-	int err = 0;
-	struct l2cap_conf_rfc rfc = {.mode = L2CAP_MODE_BASIC};
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-	BT_DBG("sk %p, rsp %p, len %d, res 0x%2.2x", sk, rsp, len, result);
-
-	if (pi->reconf_state == L2CAP_RECONF_NONE)
-		return -ECONNREFUSED;
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		while (len >= L2CAP_CONF_OPT_SIZE) {
-			int type, olen;
-			unsigned long val;
-
-			len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-			if (type == L2CAP_CONF_RFC) {
-				if (olen == sizeof(rfc))
-					memcpy(&rfc, (void *)val, olen);
-
-				if (rfc.mode != pi->mode) {
-					l2cap_send_disconn_req(pi->conn, sk,
-								ECONNRESET);
-					return -ECONNRESET;
-				}
-
-				goto done;
-			}
-		}
-	}
-
-	BT_ERR("Expected RFC option was missing, using existing values");
-
-	rfc.mode = pi->mode;
-	rfc.retrans_timeout = cpu_to_le16(pi->retrans_timeout);
-	rfc.monitor_timeout = cpu_to_le16(pi->monitor_timeout);
-
-done:
-	l2cap_ertm_stop_ack_timer(pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	l2cap_ertm_stop_monitor_timer(pi);
-
-	pi->mps = le16_to_cpu(rfc.max_pdu_size);
-	if (pi->mode == L2CAP_MODE_ERTM) {
-		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-	}
-
-	if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_ACC) {
-		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_NONE;
-
-		/* Respond to poll */
-		err = l2cap_answer_move_poll(sk);
-	} else if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_INT) {
-		if (pi->mode == L2CAP_MODE_ERTM) {
-			l2cap_ertm_tx(sk, NULL, NULL,
-					L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-			pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-		}
-	}
-
-	return err;
-}
-
-
-static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;
-
-	if (rej->reason != 0x0000)
-		return 0;
-
-	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
-					cmd->ident == conn->info_ident) {
-		del_timer(&conn->info_timer);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
-
-		l2cap_conn_start(conn);
-	}
-
-	return 0;
-}
-
-static struct sock *l2cap_create_connect(struct l2cap_conn *conn,
-						struct l2cap_cmd_hdr *cmd,
-						u8 *data, u8 rsp_code,
-						u8 amp_id)
-{
-	struct l2cap_chan_list *list = &conn->chan_list;
-	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
-	struct l2cap_conn_rsp rsp;
-	struct sock *parent, *sk = NULL;
-	int result, status = L2CAP_CS_NO_INFO;
-
-	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
-	__le16 psm = req->psm;
-
-	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
-
-	/* Check if we have socket listening on psm */
-	parent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);
-	if (!parent) {
-		result = L2CAP_CR_BAD_PSM;
-		goto sendresp;
-	}
-
-	bh_lock_sock(parent);
-
-	/* Check if the ACL is secure enough (if not SDP) */
-	if (psm != cpu_to_le16(0x0001) &&
-				!hci_conn_check_link_mode(conn->hcon)) {
-		conn->disc_reason = 0x05;
-		result = L2CAP_CR_SEC_BLOCK;
-		goto response;
-	}
-
-	result = L2CAP_CR_NO_MEM;
-
-	/* Check for backlog size */
-	if (sk_acceptq_is_full(parent)) {
-		BT_DBG("backlog full %d", parent->sk_ack_backlog);
-		goto response;
-	}
-
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
-	if (!sk)
-		goto response;
-
-	write_lock_bh(&list->lock);
-
-	/* Check if we already have channel with that dcid */
-	if (__l2cap_get_chan_by_dcid(list, scid)) {
-		write_unlock_bh(&list->lock);
-		sock_set_flag(sk, SOCK_ZAPPED);
-		l2cap_sock_kill(sk);
-		sk = NULL;
-		goto response;
-	}
-
-	hci_conn_hold(conn->hcon);
-
-	l2cap_sock_init(sk, parent);
-	bacpy(&bt_sk(sk)->src, conn->src);
-	bacpy(&bt_sk(sk)->dst, conn->dst);
-	l2cap_pi(sk)->psm  = psm;
-	l2cap_pi(sk)->dcid = scid;
-
-	bt_accept_enqueue(parent, sk);
-
-	__l2cap_chan_add(conn, sk);
-	dcid = l2cap_pi(sk)->scid;
-	l2cap_pi(sk)->amp_id = amp_id;
-
-	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-
-	l2cap_pi(sk)->ident = cmd->ident;
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
-		if (l2cap_check_security(sk)) {
-			if (bt_sk(sk)->defer_setup) {
-				sk->sk_state = BT_CONNECT2;
-				result = L2CAP_CR_PEND;
-				status = L2CAP_CS_AUTHOR_PEND;
-				parent->sk_data_ready(parent, 0);
-			} else {
-				/* Force pending result for AMP controllers.
-				 * The connection will succeed after the
-				 * physical link is up. */
-				if (amp_id) {
-					sk->sk_state = BT_CONNECT2;
-					result = L2CAP_CR_PEND;
-				} else {
-					sk->sk_state = BT_CONFIG;
-					result = L2CAP_CR_SUCCESS;
-				}
-				status = L2CAP_CS_NO_INFO;
-			}
-		} else {
-			sk->sk_state = BT_CONNECT2;
-			result = L2CAP_CR_PEND;
-			status = L2CAP_CS_AUTHEN_PEND;
-		}
-	} else {
-		sk->sk_state = BT_CONNECT2;
-		result = L2CAP_CR_PEND;
-		status = L2CAP_CS_NO_INFO;
-	}
-
-	write_unlock_bh(&list->lock);
-
-response:
-	bh_unlock_sock(parent);
-
-sendresp:
-	rsp.scid   = cpu_to_le16(scid);
-	rsp.dcid   = cpu_to_le16(dcid);
-	rsp.result = cpu_to_le16(result);
-	rsp.status = cpu_to_le16(status);
-	l2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);
-
-	if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)) {
-		struct l2cap_info_req info;
-		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
-		conn->info_ident = l2cap_get_ident(conn);
-
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
-
-		l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(info), &info);
-	}
-
-	if (sk && !(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
-				result == L2CAP_CR_SUCCESS) {
-		u8 buf[128];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-	return sk;
-}
-
-static inline int l2cap_connect_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	l2cap_create_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);
-	return 0;
-}
-
-static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
-	u16 scid, dcid, result, status;
-	struct sock *sk;
-	u8 req[128];
-
-	scid   = __le16_to_cpu(rsp->scid);
-	dcid   = __le16_to_cpu(rsp->dcid);
-	result = __le16_to_cpu(rsp->result);
-	status = __le16_to_cpu(rsp->status);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
-
-	if (scid) {
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-		if (!sk)
-			return -EFAULT;
-	} else {
-		sk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
-		if (!sk)
-			return -EFAULT;
-	}
-
-	switch (result) {
-	case L2CAP_CR_SUCCESS:
-		sk->sk_state = BT_CONFIG;
-		l2cap_pi(sk)->ident = 0;
-		l2cap_pi(sk)->dcid = dcid;
-		l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)
-			break;
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, req), req);
-		l2cap_pi(sk)->num_conf_req++;
-		break;
-
-	case L2CAP_CR_PEND:
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-		break;
-
-	default:
-		/* don't delete l2cap channel if sk is owned by user */
-		if (sock_owned_by_user(sk)) {
-			sk->sk_state = BT_DISCONN;
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ / 5);
-			break;
-		}
-
-		l2cap_chan_del(sk, ECONNREFUSED);
-		break;
-	}
-
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline void set_default_fcs(struct l2cap_pinfo *pi)
-{
-	/* FCS is enabled only in ERTM or streaming mode, if one or both
-	 * sides request it.
-	 */
-	if (pi->mode != L2CAP_MODE_ERTM && pi->mode != L2CAP_MODE_STREAMING)
-		pi->fcs = L2CAP_FCS_NONE;
-	else if (!(pi->conf_state & L2CAP_CONF_NO_FCS_RECV))
-		pi->fcs = L2CAP_FCS_CRC16;
-}
-
-static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
-{
-	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
-	u16 dcid, flags;
-	u8 rspbuf[64];
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *) rspbuf;
-	struct sock *sk;
-	int len;
-	u8 amp_move_reconf = 0;
-
-	dcid  = __le16_to_cpu(req->dcid);
-	flags = __le16_to_cpu(req->flags);
-
-	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return -ENOENT;
-
-	BT_DBG("sk_state 0x%2.2x rx_state 0x%2.2x "
-		"reconf_state 0x%2.2x amp_id 0x%2.2x amp_move_id 0x%2.2x",
-		sk->sk_state, l2cap_pi(sk)->rx_state,
-		l2cap_pi(sk)->reconf_state, l2cap_pi(sk)->amp_id,
-		l2cap_pi(sk)->amp_move_id);
-
-	/* Detect a reconfig request due to channel move between
-	 * BR/EDR and AMP
-	 */
-	if (sk->sk_state == BT_CONNECTED &&
-		l2cap_pi(sk)->rx_state ==
-			L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE)
-		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_ACC;
-
-	if (l2cap_pi(sk)->reconf_state != L2CAP_RECONF_NONE)
-		amp_move_reconf = 1;
-
-	if (sk->sk_state != BT_CONFIG && !amp_move_reconf) {
-		struct l2cap_cmd_rej rej;
-
-		rej.reason = cpu_to_le16(0x0002);
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
-				sizeof(rej), &rej);
-		goto unlock;
-	}
-
-	/* Reject if config buffer is too small. */
-	len = cmd_len - sizeof(*req);
-	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rspbuf,
-					L2CAP_CONF_REJECT, flags), rspbuf);
-		goto unlock;
-	}
-
-	/* Store config. */
-	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
-	l2cap_pi(sk)->conf_len += len;
-
-	if (flags & 0x0001) {
-		/* Incomplete config. Send empty response. */
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rspbuf,
-					L2CAP_CONF_SUCCESS, 0x0001), rspbuf);
-		goto unlock;
-	}
-
-	/* Complete config. */
-	if (!amp_move_reconf)
-		len = l2cap_parse_conf_req(sk, rspbuf);
-	else
-		len = l2cap_parse_amp_move_reconf_req(sk, rspbuf);
-
-	if (len < 0) {
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
-		goto unlock;
-	}
-
-	l2cap_pi(sk)->conf_ident = cmd->ident;
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_LOCKSTEP &&
-			rsp->result == cpu_to_le16(L2CAP_CONF_PENDING) &&
-			!l2cap_pi(sk)->amp_id) {
-		/* Send success response right after pending if using
-		 * lockstep config on BR/EDR
-		 */
-		rsp->result = cpu_to_le16(L2CAP_CONF_SUCCESS);
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_OUTPUT_DONE;
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
-	}
-
-	/* Reset config buffer. */
-	l2cap_pi(sk)->conf_len = 0;
-
-	if (amp_move_reconf)
-		goto unlock;
-
-	l2cap_pi(sk)->num_conf_rsp++;
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))
-		goto unlock;
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
-		set_default_fcs(l2cap_pi(sk));
-
-		sk->sk_state = BT_CONNECTED;
-
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
-			l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-			l2cap_ertm_init(sk);
-
-		l2cap_chan_ready(sk);
-		goto unlock;
-	}
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {
-		u8 buf[64];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-unlock:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
-	u16 scid, flags, result;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	int len = cmd->len - sizeof(*rsp);
-
-	scid   = __le16_to_cpu(rsp->scid);
-	flags  = __le16_to_cpu(rsp->flags);
-	result = __le16_to_cpu(rsp->result);
-
-	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
-			scid, flags, result);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
-
-	pi = l2cap_pi(sk);
-
-	if (pi->reconf_state != L2CAP_RECONF_NONE)  {
-		l2cap_amp_move_reconf_rsp(sk, rsp->data, len, result);
-		goto done;
-	}
-
-	switch (result) {
-	case L2CAP_CONF_SUCCESS:
-		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
-				!(pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND)) {
-			/* Lockstep procedure requires a pending response
-			 * before success.
-			 */
-			l2cap_send_disconn_req(conn, sk, ECONNRESET);
-			goto done;
-		}
-
-		l2cap_conf_rfc_get(sk, rsp->data, len);
-		break;
-
-	case L2CAP_CONF_PENDING:
-		if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
-			l2cap_send_disconn_req(conn, sk, ECONNRESET);
-			goto done;
-		}
-
-		l2cap_conf_rfc_get(sk, rsp->data, len);
-
-		pi->conf_state |= L2CAP_CONF_LOCKSTEP_PEND;
-
-		l2cap_conf_ext_fs_get(sk, rsp->data, len);
-
-		if (pi->amp_id && pi->conf_state & L2CAP_CONF_PEND_SENT) {
-			struct hci_chan *chan;
-
-			/* Already sent a 'pending' response, so set up
-			 * the logical link now
-			 */
-			chan = l2cap_chan_admit(pi->amp_id, sk);
-			if (!chan) {
-				l2cap_send_disconn_req(pi->conn, sk,
-							ECONNRESET);
-				goto done;
-			}
-
-			if (chan->state == BT_CONNECTED)
-				l2cap_create_cfm(chan, 0);
-		}
-
-		goto done;
-
-	case L2CAP_CONF_UNACCEPT:
-		if (pi->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
-			char req[64];
-
-			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
 
-			/* throw out any old stored conf requests */
-			result = L2CAP_CONF_SUCCESS;
-			len = l2cap_parse_conf_rsp(sk, rsp->data,
-							len, req, &result);
-			if (len < 0) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
+		if (type != L2CAP_CONF_RFC)
+			continue;
 
-			l2cap_send_cmd(conn, l2cap_get_ident(conn),
-						L2CAP_CONF_REQ, len, req);
-			pi->num_conf_req++;
-			if (result != L2CAP_CONF_SUCCESS)
-				goto done;
+		if (olen != sizeof(rfc))
 			break;
-		}
 
-	default:
-		sk->sk_err = ECONNRESET;
-		l2cap_sock_set_timer(sk, HZ * 5);
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
+		memcpy(&rfc, (void *)val, olen);
 		goto done;
 	}
 
-	if (flags & 0x01)
-		goto done;
-
-	pi->conf_state |= L2CAP_CONF_INPUT_DONE;
-
-	if (pi->conf_state & L2CAP_CONF_OUTPUT_DONE) {
-		set_default_fcs(pi);
-
-		sk->sk_state = BT_CONNECTED;
-
-		if (pi->mode == L2CAP_MODE_ERTM ||
-			pi->mode == L2CAP_MODE_STREAMING)
-			l2cap_ertm_init(sk);
+	/* Use sane default values in case a misbehaving remote device
+	 * did not send an RFC option.
+	 */
+	rfc.mode = chan->mode;
+	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
+	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
+	rfc.max_pdu_size = cpu_to_le16(chan->imtu);
 
-		l2cap_chan_ready(sk);
-	}
+	BT_ERR("Expected RFC option was not found, using defaults");
 
 done:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
-	struct l2cap_disconn_rsp rsp;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(req->scid);
-	dcid = __le16_to_cpu(req->dcid);
-
-	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return 0;
-
-	rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
-	rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
-
-	/* Only do cleanup if a disconnect request was not sent already */
-	if (sk->sk_state != BT_DISCONN) {
-		sk->sk_shutdown = SHUTDOWN_MASK;
-
-		sk->sk_send_head = NULL;
-		skb_queue_purge(TX_QUEUE(sk));
-
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-			skb_queue_purge(SREJ_QUEUE(sk));
-
-			__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
-			__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
-			__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
-		}
-	}
-
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		return 0;
+	switch (rfc.mode) {
+	case L2CAP_MODE_ERTM:
+		chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+		chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+		break;
+	case L2CAP_MODE_STREAMING:
+		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
 	}
-
-	l2cap_chan_del(sk, ECONNRESET);
-
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
 }
 
-static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(rsp->scid);
-	dcid = __le16_to_cpu(rsp->dcid);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
+	struct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;
 
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
+	if (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)
 		return 0;
-	}
-
-	l2cap_chan_del(sk, 0);
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
-}
-
-static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
-	u16 type;
-
-	type = __le16_to_cpu(req->type);
-
-	BT_DBG("type 0x%4.4x", type);
-
-	if (type == L2CAP_IT_FEAT_MASK) {
-		u8 buf[8];
-		u32 feat_mask = l2cap_feat_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (!disable_ertm)
-			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
-				| L2CAP_FEAT_FCS | L2CAP_FEAT_EXT_WINDOW;
-		put_unaligned_le32(feat_mask, rsp->data);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		u8 buf[12];
-		u8 fc_mask = l2cap_fc_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (enable_hs)
-			fc_mask |= L2CAP_FC_A2MP;
-		memset(rsp->data, 0, 8);
-		rsp->data[0] = fc_mask;
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else {
-		struct l2cap_info_rsp rsp;
-		rsp.type   = cpu_to_le16(type);
-		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
+
+	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
+					cmd->ident == conn->info_ident) {
+		cancel_delayed_work(&conn->info_timer);
+
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
 	}
 
 	return 0;
 }
 
-static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
-	u16 type, result;
-
-	type   = __le16_to_cpu(rsp->type);
-	result = __le16_to_cpu(rsp->result);
+	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
+	struct l2cap_conn_rsp rsp;
+	struct l2cap_chan *chan = NULL, *pchan;
+	struct sock *parent, *sk = NULL;
+	int result, status = L2CAP_CS_NO_INFO;
 
-	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
+	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
+	__le16 psm = req->psm;
 
-	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
-	if (cmd->ident != conn->info_ident ||
-			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
-		return 0;
+	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
 
-	del_timer(&conn->info_timer);
+	/* Check if we have socket listening on psm */
+	pchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, conn->src);
+	if (!pchan) {
+		result = L2CAP_CR_BAD_PSM;
+		goto sendresp;
+	}
 
-	if (result != L2CAP_IR_SUCCESS) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	parent = pchan->sk;
 
-		l2cap_conn_start(conn);
+	mutex_lock(&conn->chan_lock);
+	lock_sock(parent);
 
-		return 0;
+	/* Check if the ACL is secure enough (if not SDP) */
+	if (psm != cpu_to_le16(0x0001) &&
+				!hci_conn_check_link_mode(conn->hcon)) {
+		conn->disc_reason = HCI_ERROR_AUTH_FAILURE;
+		result = L2CAP_CR_SEC_BLOCK;
+		goto response;
 	}
 
-	if (type == L2CAP_IT_FEAT_MASK) {
-		conn->feat_mask = get_unaligned_le32(rsp->data);
-
-		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
-			struct l2cap_info_req req;
-			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+	result = L2CAP_CR_NO_MEM;
 
-			conn->info_ident = l2cap_get_ident(conn);
+	/* Check for backlog size */
+	if (sk_acceptq_is_full(parent)) {
+		BT_DBG("backlog full %d", parent->sk_ack_backlog);
+		goto response;
+	}
 
-			l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(req), &req);
-		} else {
-			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-			conn->info_ident = 0;
+	chan = pchan->ops->new_connection(pchan->data);
+	if (!chan)
+		goto response;
 
-			l2cap_conn_start(conn);
-		}
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		conn->fc_mask = rsp->data[0];
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	sk = chan->sk;
 
-		l2cap_conn_start(conn);
+	/* Check if we already have channel with that dcid */
+	if (__l2cap_get_chan_by_dcid(conn, scid)) {
+		sock_set_flag(sk, SOCK_ZAPPED);
+		chan->ops->close(chan->data);
+		goto response;
 	}
 
-	return 0;
-}
+	hci_conn_hold(conn->hcon);
 
-static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
-			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id)
-{
-	struct l2cap_move_chan_req req;
-	u8 ident;
+	bacpy(&bt_sk(sk)->src, conn->src);
+	bacpy(&bt_sk(sk)->dst, conn->dst);
+	chan->psm  = psm;
+	chan->dcid = scid;
 
-	BT_DBG("pi %p, icid %d, dest_amp_id %d", pi, (int) icid,
-		(int) dest_amp_id);
+	bt_accept_enqueue(parent, sk);
 
-	ident = l2cap_get_ident(conn);
-	if (pi)
-		pi->ident = ident;
+	__l2cap_chan_add(conn, chan);
 
-	req.icid = cpu_to_le16(icid);
-	req.dest_amp_id = dest_amp_id;
+	dcid = chan->scid;
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req), &req);
-}
+	__set_chan_timer(chan, sk->sk_sndtimeo);
 
-static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
-				u16 icid, u16 result)
-{
-	struct l2cap_move_chan_rsp rsp;
+	chan->ident = cmd->ident;
+
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
+		if (l2cap_chan_check_security(chan)) {
+			if (bt_sk(sk)->defer_setup) {
+				__l2cap_state_change(chan, BT_CONNECT2);
+				result = L2CAP_CR_PEND;
+				status = L2CAP_CS_AUTHOR_PEND;
+				parent->sk_data_ready(parent, 0);
+			} else {
+				__l2cap_state_change(chan, BT_CONFIG);
+				result = L2CAP_CR_SUCCESS;
+				status = L2CAP_CS_NO_INFO;
+			}
+		} else {
+			__l2cap_state_change(chan, BT_CONNECT2);
+			result = L2CAP_CR_PEND;
+			status = L2CAP_CS_AUTHEN_PEND;
+		}
+	} else {
+		__l2cap_state_change(chan, BT_CONNECT2);
+		result = L2CAP_CR_PEND;
+		status = L2CAP_CS_NO_INFO;
+	}
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+response:
+	release_sock(parent);
+	mutex_unlock(&conn->chan_lock);
 
-	rsp.icid = cpu_to_le16(icid);
+sendresp:
+	rsp.scid   = cpu_to_le16(scid);
+	rsp.dcid   = cpu_to_le16(dcid);
 	rsp.result = cpu_to_le16(result);
+	rsp.status = cpu_to_le16(status);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
-}
+	if (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {
+		struct l2cap_info_req info;
+		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
 
-static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
-				struct l2cap_pinfo *pi, u16 icid, u16 result)
-{
-	struct l2cap_move_chan_cfm cfm;
-	u8 ident;
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
+		conn->info_ident = l2cap_get_ident(conn);
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+		schedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);
 
-	ident = l2cap_get_ident(conn);
-	if (pi)
-		pi->ident = ident;
+		l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(info), &info);
+	}
 
-	cfm.icid = cpu_to_le16(icid);
-	cfm.result = cpu_to_le16(result);
+	if (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&
+				result == L2CAP_CR_SUCCESS) {
+		u8 buf[128];
+		set_bit(CONF_REQ_SENT, &chan->conf_state);
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, buf), buf);
+		chan->num_conf_req++;
+	}
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
+	return 0;
 }
 
-static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
-					u16 icid)
+static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm_rsp rsp;
+	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
+	u16 scid, dcid, result, status;
+	struct l2cap_chan *chan;
+	u8 req[128];
+	int err;
 
-	BT_DBG("icid %d", (int) icid);
+	scid   = __le16_to_cpu(rsp->scid);
+	dcid   = __le16_to_cpu(rsp->dcid);
+	result = __le16_to_cpu(rsp->result);
+	status = __le16_to_cpu(rsp->status);
 
-	rsp.icid = cpu_to_le16(icid);
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
-}
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x",
+						dcid, scid, result, status);
 
-static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_create_chan_req *req =
-		(struct l2cap_create_chan_req *) data;
-	struct sock *sk;
-	u16 psm, scid;
+	mutex_lock(&conn->chan_lock);
 
-	psm = le16_to_cpu(req->psm);
-	scid = le16_to_cpu(req->scid);
+	if (scid) {
+		chan = __l2cap_get_chan_by_scid(conn, scid);
+		if (!chan) {
+			err = -EFAULT;
+			goto unlock;
+		}
+	} else {
+		chan = __l2cap_get_chan_by_ident(conn, cmd->ident);
+		if (!chan) {
+			err = -EFAULT;
+			goto unlock;
+		}
+	}
 
-	BT_DBG("psm %d, scid %d, amp_id %d", (int) psm, (int) scid,
-		(int) req->amp_id);
+	err = 0;
 
-	if (req->amp_id) {
-		struct hci_dev *hdev;
+	l2cap_chan_lock(chan);
 
-		/* Validate AMP controller id */
-		hdev = hci_dev_get(req->amp_id);
-		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
-			struct l2cap_create_chan_rsp rsp;
-
-			rsp.dcid = 0;
-			rsp.scid = cpu_to_le16(scid);
-			rsp.result = L2CAP_CREATE_CHAN_REFUSED_CONTROLLER;
-			rsp.status = L2CAP_CREATE_CHAN_STATUS_NONE;
+	switch (result) {
+	case L2CAP_CR_SUCCESS:
+		l2cap_state_change(chan, BT_CONFIG);
+		chan->ident = 0;
+		chan->dcid = dcid;
+		clear_bit(CONF_CONNECT_PEND, &chan->conf_state);
 
-			l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
-				       sizeof(rsp), &rsp);
+		if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
+			break;
 
-			if (hdev)
-				hci_dev_put(hdev);
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, req), req);
+		chan->num_conf_req++;
+		break;
 
-			return 0;
-		}
+	case L2CAP_CR_PEND:
+		set_bit(CONF_CONNECT_PEND, &chan->conf_state);
+		break;
 
-		hci_dev_put(hdev);
+	default:
+		l2cap_chan_del(chan, ECONNREFUSED);
+		break;
 	}
 
-	sk = l2cap_create_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,
-					req->amp_id);
-
-	if (sk)
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
+	l2cap_chan_unlock(chan);
 
-	if (sk && req->amp_id &&
-			(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
-		amp_accept_physical(conn, req->amp_id, sk);
+unlock:
+	mutex_unlock(&conn->chan_lock);
 
-	return 0;
+	return err;
 }
 
-static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline void set_default_fcs(struct l2cap_chan *chan)
 {
-	BT_DBG("conn %p", conn);
-
-	return l2cap_connect_rsp(conn, cmd, data);
+	/* FCS is enabled only in ERTM or streaming mode, if one or both
+	 * sides request it.
+	 */
+	if (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)
+		chan->fcs = L2CAP_FCS_NONE;
+	else if (!test_bit(CONF_NO_FCS_RECV, &chan->conf_state))
+		chan->fcs = L2CAP_FCS_CRC16;
 }
 
-static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
 {
-	struct l2cap_move_chan_req *req = (struct l2cap_move_chan_req *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid = 0;
-	u16 result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
+	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
+	u16 dcid, flags;
+	u8 rsp[64];
+	struct l2cap_chan *chan;
+	int len;
 
-	icid = le16_to_cpu(req->icid);
+	dcid  = __le16_to_cpu(req->dcid);
+	flags = __le16_to_cpu(req->flags);
 
-	BT_DBG("icid %d, dest_amp_id %d", (int) icid, (int) req->dest_amp_id);
+	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
+
+	chan = l2cap_get_chan_by_scid(conn, dcid);
+	if (!chan)
+		return -ENOENT;
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
+	l2cap_chan_lock(chan);
 
-	if (!sk)
-		goto send_move_response;
+	if (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {
+		struct l2cap_cmd_rej_cid rej;
 
-	lock_sock(sk);
-	pi = l2cap_pi(sk);
+		rej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);
+		rej.scid = cpu_to_le16(chan->scid);
+		rej.dcid = cpu_to_le16(chan->dcid);
 
-	if (pi->scid < L2CAP_CID_DYN_START ||
-		(pi->mode != L2CAP_MODE_ERTM &&
-		 pi->mode != L2CAP_MODE_STREAMING)) {
-		goto send_move_response;
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
+				sizeof(rej), &rej);
+		goto unlock;
 	}
 
-	if (pi->amp_id == req->dest_amp_id) {
-		result = L2CAP_MOVE_CHAN_REFUSED_SAME_ID;
-		goto send_move_response;
+	/* Reject if config buffer is too small. */
+	len = cmd_len - sizeof(*req);
+	if (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_REJECT, flags), rsp);
+		goto unlock;
 	}
 
-	if (req->dest_amp_id) {
-		struct hci_dev *hdev;
-		hdev = hci_dev_get(req->dest_amp_id);
-		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
-			if (hdev)
-				hci_dev_put(hdev);
+	/* Store config. */
+	memcpy(chan->conf_req + chan->conf_len, req->data, len);
+	chan->conf_len += len;
 
-			result = L2CAP_MOVE_CHAN_REFUSED_CONTROLLER;
-			goto send_move_response;
-		}
-		hci_dev_put(hdev);
+	if (flags & 0x0001) {
+		/* Incomplete config. Send empty response. */
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_SUCCESS, 0x0001), rsp);
+		goto unlock;
 	}
 
-	if (((pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE) ||
-		pi->amp_move_role != L2CAP_AMP_MOVE_NONE) &&
-		bacmp(conn->src, conn->dst) > 0) {
-		result = L2CAP_MOVE_CHAN_REFUSED_COLLISION;
-		goto send_move_response;
+	/* Complete config. */
+	len = l2cap_parse_conf_req(chan, rsp);
+	if (len < 0) {
+		l2cap_send_disconn_req(conn, chan, ECONNRESET);
+		goto unlock;
 	}
 
-	if (pi->amp_pref == BT_AMP_POLICY_REQUIRE_BR_EDR) {
-		result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
-		goto send_move_response;
-	}
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
+	chan->num_conf_rsp++;
 
-	pi->amp_move_cmd_ident = cmd->ident;
-	pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
-	l2cap_amp_move_setup(sk);
-	pi->amp_move_id = req->dest_amp_id;
-	icid = pi->dcid;
+	/* Reset config buffer. */
+	chan->conf_len = 0;
 
-	if (req->dest_amp_id == 0) {
-		/* Moving to BR/EDR */
-		if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			result = L2CAP_MOVE_CHAN_PENDING;
-		} else {
-			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-			result = L2CAP_MOVE_CHAN_SUCCESS;
-		}
-	} else {
-		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
-		amp_accept_physical(pi->conn, req->dest_amp_id, sk);
-		result = L2CAP_MOVE_CHAN_PENDING;
+	if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
+		goto unlock;
+
+	if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
+		set_default_fcs(chan);
+
+		l2cap_state_change(chan, BT_CONNECTED);
+
+		chan->next_tx_seq = 0;
+		chan->expected_tx_seq = 0;
+		skb_queue_head_init(&chan->tx_q);
+		if (chan->mode == L2CAP_MODE_ERTM)
+			l2cap_ertm_init(chan);
+
+		l2cap_chan_ready(chan);
+		goto unlock;
 	}
 
-send_move_response:
-	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
+	if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
+		u8 buf[64];
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(chan, buf), buf);
+		chan->num_conf_req++;
+	}
 
-	if (sk)
-		release_sock(sk);
+	/* Got Conf Rsp PENDING from remote side and asume we sent
+	   Conf Rsp PENDING in the code above */
+	if (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&
+			test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
 
+		/* check compatibility */
+
+		clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+		set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
+
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+					l2cap_build_conf_rsp(chan, rsp,
+					L2CAP_CONF_SUCCESS, 0x0000), rsp);
+	}
+
+unlock:
+	l2cap_chan_unlock(chan);
 	return 0;
 }
 
-static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_rsp *rsp = (struct l2cap_move_chan_rsp *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid, result;
+	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
+	u16 scid, flags, result;
+	struct l2cap_chan *chan;
+	int len = cmd->len - sizeof(*rsp);
+
+	scid   = __le16_to_cpu(rsp->scid);
+	flags  = __le16_to_cpu(rsp->flags);
+	result = __le16_to_cpu(rsp->result);
+
+	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
+			scid, flags, result);
+
+	chan = l2cap_get_chan_by_scid(conn, scid);
+	if (!chan)
+		return 0;
+
+	l2cap_chan_lock(chan);
+
+	switch (result) {
+	case L2CAP_CONF_SUCCESS:
+		l2cap_conf_rfc_get(chan, rsp->data, len);
+		clear_bit(CONF_REM_CONF_PEND, &chan->conf_state);
+		break;
+
+	case L2CAP_CONF_PENDING:
+		set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
+
+		if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
+			char buf[64];
+
+			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
+								buf, &result);
+			if (len < 0) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
+			}
 
-	icid = le16_to_cpu(rsp->icid);
-	result = le16_to_cpu(rsp->result);
+			/* check compatibility */
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+			clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
 
-	switch (result) {
-	case L2CAP_MOVE_CHAN_SUCCESS:
-	case L2CAP_MOVE_CHAN_PENDING:
-		read_lock(&conn->chan_list.lock);
-		sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
-		read_unlock(&conn->chan_list.lock);
-
-		if (!sk) {
-			l2cap_send_move_chan_cfm(conn, NULL, icid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			break;
+			l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+						l2cap_build_conf_rsp(chan, buf,
+						L2CAP_CONF_SUCCESS, 0x0000), buf);
 		}
+		goto done;
 
-		lock_sock(sk);
-		pi = l2cap_pi(sk);
+	case L2CAP_CONF_UNACCEPT:
+		if (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
+			char req[64];
 
-		l2cap_sock_clear_timer(sk);
-		if (result == L2CAP_MOVE_CHAN_PENDING)
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_ERTX_TIMEOUT);
-
-		if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
-			/* Move confirm will be sent when logical link
-			 * is complete.
-			 */
-			pi->amp_move_state =
-				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) {
-			if (result == L2CAP_MOVE_CHAN_PENDING) {
-				break;
-			} else if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			} else {
-				/* Logical link is up or moving to BR/EDR,
-				 * proceed with move */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			}
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP) {
-			struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
-					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-			struct hci_chan *chan;
-			/* Moving to AMP */
-			if (result == L2CAP_MOVE_CHAN_SUCCESS) {
-				/* Remote is ready, send confirm immediately
-				 * after logical link is ready
-				 */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-			} else {
-				/* Both logical link and move success
-				 * are required to confirm
-				 */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE;
-			}
-			pi->remote_fs = default_fs;
-			pi->local_fs = default_fs;
-			chan = l2cap_chan_admit(pi->amp_move_id, sk);
-			if (!chan) {
-				/* Logical link not available */
-				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-				break;
+			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
 			}
 
-			if (chan->state == BT_CONNECTED) {
-				/* Logical link is already ready to go */
-				pi->ampcon = chan->conn;
-				pi->ampcon->l2cap_data = pi->conn;
-				if (result == L2CAP_MOVE_CHAN_SUCCESS) {
-					/* Can confirm now */
-					l2cap_send_move_chan_cfm(conn, pi,
-						pi->scid,
-						L2CAP_MOVE_CHAN_CONFIRMED);
-				} else {
-					/* Now only need move success
-					 * required to confirm
-					 */
-					pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-				}
-
-				l2cap_create_cfm(chan, 0);
+			/* throw out any old stored conf requests */
+			result = L2CAP_CONF_SUCCESS;
+			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
+								req, &result);
+			if (len < 0) {
+				l2cap_send_disconn_req(conn, chan, ECONNRESET);
+				goto done;
 			}
-		} else {
-			/* Any other amp move state means the move failed. */
-			pi->amp_move_id = pi->amp_id;
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			l2cap_amp_move_revert(sk);
-			pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		}
-		break;
-	default:
-		/* Failed (including collision case) */
-		read_lock(&conn->chan_list.lock);
-		sk = __l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
-		read_unlock(&conn->chan_list.lock);
-
-		if (!sk) {
-			/* Could not locate channel, icid is best guess */
-			l2cap_send_move_chan_cfm(conn, NULL, icid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
+
+			l2cap_send_cmd(conn, l2cap_get_ident(conn),
+						L2CAP_CONF_REQ, len, req);
+			chan->num_conf_req++;
+			if (result != L2CAP_CONF_SUCCESS)
+				goto done;
 			break;
 		}
 
-		lock_sock(sk);
-		pi = l2cap_pi(sk);
+	default:
+		l2cap_chan_set_err(chan, ECONNRESET);
 
-		l2cap_sock_clear_timer(sk);
+		__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);
+		l2cap_send_disconn_req(conn, chan, ECONNRESET);
+		goto done;
+	}
 
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-			if (result == L2CAP_MOVE_CHAN_REFUSED_COLLISION)
-				pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
-			else {
-				/* Cleanup - cancel move */
-				pi->amp_move_id = pi->amp_id;
-				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-				l2cap_amp_move_revert(sk);
-				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			}
-		}
+	if (flags & 0x01)
+		goto done;
 
-		l2cap_send_move_chan_cfm(conn, pi, pi->scid,
-					L2CAP_MOVE_CHAN_UNCONFIRMED);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		break;
-	}
+	set_bit(CONF_INPUT_DONE, &chan->conf_state);
 
-	if (sk)
-		release_sock(sk);
+	if (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {
+		set_default_fcs(chan);
+
+		l2cap_state_change(chan, BT_CONNECTED);
+		chan->next_tx_seq = 0;
+		chan->expected_tx_seq = 0;
+		skb_queue_head_init(&chan->tx_q);
+		if (chan->mode ==  L2CAP_MODE_ERTM)
+			l2cap_ertm_init(chan);
+
+		l2cap_chan_ready(chan);
+	}
 
+done:
+	l2cap_chan_unlock(chan);
 	return 0;
 }
 
-static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm *cfm = (struct l2cap_move_chan_cfm *) data;
+	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
+	struct l2cap_disconn_rsp rsp;
+	u16 dcid, scid;
+	struct l2cap_chan *chan;
 	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 icid, result;
 
-	icid = le16_to_cpu(cfm->icid);
-	result = le16_to_cpu(cfm->result);
+	scid = __le16_to_cpu(req->scid);
+	dcid = __le16_to_cpu(req->dcid);
+
+	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
 
-	BT_DBG("icid %d, result %d", (int) icid, (int) result);
+	mutex_lock(&conn->chan_lock);
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
-
-	if (!sk) {
-		BT_DBG("Bad channel (%d)", (int) icid);
-		goto send_move_confirm_response;
+	chan = __l2cap_get_chan_by_scid(conn, dcid);
+	if (!chan) {
+		mutex_unlock(&conn->chan_lock);
+		return 0;
 	}
 
+	l2cap_chan_lock(chan);
+
+	sk = chan->sk;
+
+	rsp.dcid = cpu_to_le16(chan->scid);
+	rsp.scid = cpu_to_le16(chan->dcid);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
+
 	lock_sock(sk);
-	pi = l2cap_pi(sk);
+	sk->sk_shutdown = SHUTDOWN_MASK;
+	release_sock(sk);
 
-	if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) {
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		if (result == L2CAP_MOVE_CHAN_CONFIRMED) {
-			pi->amp_id = pi->amp_move_id;
-			if (!pi->amp_id && pi->ampchan) {
-				struct hci_chan *ampchan = pi->ampchan;
-				struct hci_conn *ampcon = pi->ampcon;
-				/* Have moved off of AMP, free the channel */
-				pi->ampchan = NULL;
-				pi->ampcon = NULL;
-				if (hci_chan_put(ampchan))
-					ampcon->l2cap_data = NULL;
-				else
-					l2cap_deaggregate(ampchan, pi);
-			}
-			l2cap_amp_move_success(sk);
-		} else {
-			pi->amp_move_id = pi->amp_id;
-			l2cap_amp_move_revert(sk);
-		}
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	} else if (pi->amp_move_state ==
-			L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
-		BT_DBG("Bad AMP_MOVE_STATE (%d)", pi->amp_move_state);
-	}
+	l2cap_chan_del(chan, ECONNRESET);
 
-send_move_confirm_response:
-	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
+	l2cap_chan_unlock(chan);
 
-	if (sk)
-		release_sock(sk);
+	chan->ops->close(chan->data);
+
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_move_chan_cfm_rsp *rsp =
-		(struct l2cap_move_chan_cfm_rsp *) data;
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-
-	u16 icid;
+	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
+	u16 dcid, scid;
+	struct l2cap_chan *chan;
 
-	icid = le16_to_cpu(rsp->icid);
+	scid = __le16_to_cpu(rsp->scid);
+	dcid = __le16_to_cpu(rsp->dcid);
 
-	BT_DBG("icid %d", (int) icid);
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
 
-	read_lock(&conn->chan_list.lock);
-	sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
-	read_unlock(&conn->chan_list.lock);
+	mutex_lock(&conn->chan_lock);
 
-	if (!sk)
+	chan = __l2cap_get_chan_by_scid(conn, scid);
+	if (!chan) {
+		mutex_unlock(&conn->chan_lock);
 		return 0;
+	}
 
-	lock_sock(sk);
-	pi = l2cap_pi(sk);
-
-	l2cap_sock_clear_timer(sk);
+	l2cap_chan_lock(chan);
 
-	if (pi->amp_move_state ==
-			L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP) {
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		pi->amp_id = pi->amp_move_id;
-
-		if (!pi->amp_id && pi->ampchan) {
-			struct hci_chan *ampchan = pi->ampchan;
-			struct hci_conn *ampcon = pi->ampcon;
-			/* Have moved off of AMP, free the channel */
-			pi->ampchan = NULL;
-			pi->ampcon = NULL;
-			if (hci_chan_put(ampchan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(ampchan, pi);
-		}
+	l2cap_chan_del(chan, 0);
 
-		l2cap_amp_move_success(sk);
+	l2cap_chan_unlock(chan);
 
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-	}
+	chan->ops->close(chan->data);
 
-	release_sock(sk);
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static void l2cap_amp_signal_worker(struct work_struct *work)
+static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	int err = 0;
-	struct l2cap_amp_signal_work *ampwork =
-		container_of(work, struct l2cap_amp_signal_work, work);
-
-	switch (ampwork->cmd.code) {
-	case L2CAP_MOVE_CHAN_REQ:
-		err = l2cap_move_channel_req(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
+	u16 type;
 
-	case L2CAP_MOVE_CHAN_RSP:
-		err = l2cap_move_channel_rsp(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	type = __le16_to_cpu(req->type);
 
-	case L2CAP_MOVE_CHAN_CFM:
-		err = l2cap_move_channel_confirm(ampwork->conn, &ampwork->cmd,
-						ampwork->data);
-		break;
+	BT_DBG("type 0x%4.4x", type);
 
-	case L2CAP_MOVE_CHAN_CFM_RSP:
-		err = l2cap_move_channel_confirm_rsp(ampwork->conn,
-						&ampwork->cmd, ampwork->data);
-		break;
+	if (type == L2CAP_IT_FEAT_MASK) {
+		u8 buf[8];
+		u32 feat_mask = l2cap_feat_mask;
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		if (!disable_ertm)
+			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
+							 | L2CAP_FEAT_FCS;
+		if (enable_hs)
+			feat_mask |= L2CAP_FEAT_EXT_FLOW
+						| L2CAP_FEAT_EXT_WINDOW;
 
-	default:
-		BT_ERR("Unknown signaling command 0x%2.2x", ampwork->cmd.code);
-		err = -EINVAL;
-		break;
-	}
+		put_unaligned_le32(feat_mask, rsp->data);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		u8 buf[12];
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
 
-	if (err) {
-		struct l2cap_cmd_rej rej;
-		BT_DBG("error %d", err);
+		if (enable_hs)
+			l2cap_fixed_chan[0] |= L2CAP_FC_A2MP;
+		else
+			l2cap_fixed_chan[0] &= ~L2CAP_FC_A2MP;
 
-		/* In this context, commands are only rejected with
-		 * "command not understood", code 0.
-		 */
-		rej.reason = cpu_to_le16(0);
-		l2cap_send_cmd(ampwork->conn, ampwork->cmd.ident,
-				L2CAP_COMMAND_REJ, sizeof(rej), &rej);
+		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		memcpy(rsp->data, l2cap_fixed_chan, sizeof(l2cap_fixed_chan));
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else {
+		struct l2cap_info_rsp rsp;
+		rsp.type   = cpu_to_le16(type);
+		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
 	}
 
-	kfree_skb(ampwork->skb);
-	kfree(ampwork);
+	return 0;
 }
 
-void l2cap_amp_physical_complete(int result, u8 local_id, u8 remote_id,
-				struct sock *sk)
+static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_pinfo *pi;
+	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
+	u16 type, result;
 
-	BT_DBG("result %d, local_id %d, remote_id %d, sk %p", result,
-		(int) local_id, (int) remote_id, sk);
+	type   = __le16_to_cpu(rsp->type);
+	result = __le16_to_cpu(rsp->result);
 
-	lock_sock(sk);
+	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
 
-	if (sk->sk_state == BT_DISCONN || sk->sk_state == BT_CLOSED) {
-		release_sock(sk);
-		return;
+	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
+	if (cmd->ident != conn->info_ident ||
+			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
+		return 0;
+
+	cancel_delayed_work(&conn->info_timer);
+
+	if (result != L2CAP_IR_SUCCESS) {
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
+
+		return 0;
 	}
 
-	pi = l2cap_pi(sk);
+	switch (type) {
+	case L2CAP_IT_FEAT_MASK:
+		conn->feat_mask = get_unaligned_le32(rsp->data);
 
-	if (sk->sk_state != BT_CONNECTED) {
-		if (bt_sk(sk)->parent) {
-			struct l2cap_conn_rsp rsp;
-			char buf[128];
-			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
+			struct l2cap_info_req req;
+			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
 
-			/* Incoming channel on AMP */
-			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
-				/* Send successful response */
-				rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			} else {
-				/* Send negative response */
-				rsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);
-				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			}
+			conn->info_ident = l2cap_get_ident(conn);
 
-			l2cap_send_cmd(pi->conn, pi->ident,
-					L2CAP_CREATE_CHAN_RSP,
-					sizeof(rsp), &rsp);
-
-			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
-				sk->sk_state = BT_CONFIG;
-				pi->conf_state |= L2CAP_CONF_REQ_SENT;
-				l2cap_send_cmd(pi->conn,
-					l2cap_get_ident(pi->conn),
-					L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-				l2cap_pi(sk)->num_conf_req++;
-			}
+			l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(req), &req);
 		} else {
-			/* Outgoing channel on AMP */
-			if (result != L2CAP_CREATE_CHAN_SUCCESS) {
-				/* Revert to BR/EDR connect */
-				l2cap_send_conn_req(sk);
-			} else {
-				pi->amp_id = local_id;
-				l2cap_send_create_chan_req(sk, remote_id);
-			}
-		}
-	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
-		pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		l2cap_amp_move_setup(sk);
-		pi->amp_move_id = local_id;
-		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_RSP;
-
-		l2cap_send_move_chan_req(pi->conn, pi, pi->scid, remote_id);
-		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
-		pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-		struct hci_chan *chan;
-		struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
-				0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-		pi->remote_fs = default_fs;
-		pi->local_fs = default_fs;
-		chan = l2cap_chan_admit(local_id, sk);
-		if (chan) {
-			if (chan->state == BT_CONNECTED) {
-				/* Logical link is ready to go */
-				pi->ampcon = chan->conn;
-				pi->ampcon->l2cap_data = pi->conn;
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_SUCCESS);
+			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+			conn->info_ident = 0;
 
-				l2cap_create_cfm(chan, 0);
-			} else {
-				/* Wait for logical link to be ready */
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
-			}
-		} else {
-			/* Logical link not available */
-			l2cap_send_move_chan_rsp(pi->conn,
-				pi->amp_move_cmd_ident, pi->dcid,
-				L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
-		}
-	} else {
-		BT_DBG("result %d, role %d, local_busy %d", result,
-			(int) pi->amp_move_role,
-			(int) ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) != 0));
-
-		if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-			if (result == -EINVAL)
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_CONTROLLER);
-			else
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
+			l2cap_conn_start(conn);
 		}
+		break;
 
-		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-
-		if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-			l2cap_rmem_available(sk))
-			l2cap_ertm_tx(sk, 0, 0,
-					L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
+	case L2CAP_IT_FIXED_CHAN:
+		conn->fixed_chan_mask = rsp->data[0];
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
 
-		/* Restart data transmission */
-		l2cap_ertm_send(sk);
+		l2cap_conn_start(conn);
+		break;
 	}
 
-	release_sock(sk);
+	return 0;
 }
 
-static void l2cap_logical_link_complete(struct hci_chan *chan, u8 status)
+static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u16 cmd_len,
+					void *data)
 {
-	struct l2cap_pinfo *pi;
-	struct sock *sk;
-	struct hci_chan *ampchan;
-	struct hci_conn *ampcon;
+	struct l2cap_create_chan_req *req = data;
+	struct l2cap_create_chan_rsp rsp;
+	u16 psm, scid;
 
-	BT_DBG("status %d, chan %p, conn %p", (int) status, chan, chan->conn);
+	if (cmd_len != sizeof(*req))
+		return -EPROTO;
 
-	sk = chan->l2cap_sk;
-	chan->l2cap_sk = NULL;
+	if (!enable_hs)
+		return -EINVAL;
 
-	BT_DBG("sk %p", sk);
+	psm = le16_to_cpu(req->psm);
+	scid = le16_to_cpu(req->scid);
 
-	lock_sock(sk);
+	BT_DBG("psm %d, scid %d, amp_id %d", psm, scid, req->amp_id);
 
-	if (sk->sk_state != BT_CONNECTED && !l2cap_pi(sk)->amp_id) {
-		release_sock(sk);
-		return;
-	}
+	/* Placeholder: Always reject */
+	rsp.dcid = 0;
+	rsp.scid = cpu_to_le16(scid);
+	rsp.result = L2CAP_CR_NO_MEM;
+	rsp.status = L2CAP_CS_NO_INFO;
 
-	pi = l2cap_pi(sk);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
+		       sizeof(rsp), &rsp);
 
-	if ((!status) && (chan != NULL)) {
-		pi->ampcon = chan->conn;
-		pi->ampcon->l2cap_data = pi->conn;
+	return 0;
+}
 
-		BT_DBG("amp_move_state %d", pi->amp_move_state);
+static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, void *data)
+{
+	BT_DBG("conn %p", conn);
 
-		if (sk->sk_state != BT_CONNECTED) {
-			struct l2cap_conf_rsp rsp;
+	return l2cap_connect_rsp(conn, cmd, data);
+}
 
-			/* Must use spinlock to prevent concurrent
-			 * execution of l2cap_config_rsp()
-			 */
-			bh_lock_sock(sk);
-			l2cap_send_cmd(pi->conn, pi->conf_ident, L2CAP_CONF_RSP,
-					l2cap_build_conf_rsp(sk, &rsp,
-						L2CAP_CONF_SUCCESS, 0), &rsp);
-			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
+static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
+							u16 icid, u16 result)
+{
+	struct l2cap_move_chan_rsp rsp;
 
-			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
-				set_default_fcs(l2cap_pi(sk));
+	BT_DBG("icid %d, result %d", icid, result);
 
-				sk->sk_state = BT_CONNECTED;
+	rsp.icid = cpu_to_le16(icid);
+	rsp.result = cpu_to_le16(result);
 
-				if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
-				    l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-					l2cap_ertm_init(sk);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
+}
 
-				l2cap_chan_ready(sk);
-			}
-			bh_unlock_sock(sk);
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
-			/* Move confirm will be sent after a success
-			 * response is received
-			 */
-			pi->amp_move_state =
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
-		} else if (pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
-			else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_INITIATOR) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
-				l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
-					L2CAP_MOVE_CHAN_SUCCESS);
-				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-			} else if (pi->amp_move_role ==
-					L2CAP_AMP_MOVE_RESPONDER) {
-				pi->amp_move_state =
-					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
-				l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_SUCCESS);
-			}
-		} else if ((pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) &&
-			(pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) &&
-			(pi->amp_move_state !=
-				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP)) {
-			/* Move was not in expected state, free the channel */
-			ampchan = pi->ampchan;
-			ampcon = pi->ampcon;
-			pi->ampchan = NULL;
-			pi->ampcon = NULL;
-			if (ampchan) {
-				if (hci_chan_put(ampchan))
-					ampcon->l2cap_data = NULL;
-				else
-					l2cap_deaggregate(ampchan, pi);
-			}
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-		}
-	} else {
-		/* Logical link setup failed. */
+static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
+				struct l2cap_chan *chan, u16 icid, u16 result)
+{
+	struct l2cap_move_chan_cfm cfm;
+	u8 ident;
 
-		if (sk->sk_state != BT_CONNECTED)
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-			l2cap_amp_move_revert(sk);
-			l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
-			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			l2cap_send_move_chan_rsp(pi->conn,
-					pi->amp_move_cmd_ident, pi->dcid,
-					L2CAP_MOVE_CHAN_REFUSED_CONFIG);
-		} else if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-			if ((pi->amp_move_state ==
-				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) ||
-				(pi->amp_move_state ==
-				    L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM)) {
-				/* Remote has only sent pending or
-				 * success responses, clean up
-				 */
-				l2cap_amp_move_revert(sk);
-				l2cap_pi(sk)->amp_move_role =
-					L2CAP_AMP_MOVE_NONE;
-				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
-			}
+	BT_DBG("icid %d, result %d", icid, result);
 
-			/* Other amp move states imply that the move
-			 * has already aborted
-			 */
-			l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
-						L2CAP_MOVE_CHAN_UNCONFIRMED);
-			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
-		}
-		ampchan = pi->ampchan;
-		ampcon = pi->ampcon;
-		pi->ampchan = NULL;
-		pi->ampcon = NULL;
-		if (ampchan) {
-			if (hci_chan_put(ampchan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(ampchan, pi);
-		}
-	}
+	ident = l2cap_get_ident(conn);
+	if (chan)
+		chan->ident = ident;
 
-	release_sock(sk);
+	cfm.icid = cpu_to_le16(icid);
+	cfm.result = cpu_to_le16(result);
+
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
 }
 
-static void l2cap_logical_link_worker(struct work_struct *work)
+static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
+								u16 icid)
 {
-	struct l2cap_logical_link_work *log_link_work =
-		container_of(work, struct l2cap_logical_link_work, work);
-	struct sock *sk = log_link_work->chan->l2cap_sk;
+	struct l2cap_move_chan_cfm_rsp rsp;
 
-	if (sk) {
-		l2cap_logical_link_complete(log_link_work->chan,
-							log_link_work->status);
-		sock_put(sk);
-	}
-	hci_chan_put(log_link_work->chan);
-	kfree(log_link_work);
+	BT_DBG("icid %d", icid);
+
+	rsp.icid = cpu_to_le16(icid);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
 }
 
-static int l2cap_create_cfm(struct hci_chan *chan, u8 status)
+static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_logical_link_work *amp_work;
+	struct l2cap_move_chan_req *req = data;
+	u16 icid = 0;
+	u16 result = L2CAP_MR_NOT_ALLOWED;
 
-	if (!chan->l2cap_sk) {
-		BT_ERR("Expected l2cap_sk to point to connecting socket");
-		return -EFAULT;
-	}
+	if (cmd_len != sizeof(*req))
+		return -EPROTO;
 
-	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
-	if (!amp_work) {
-		sock_put(chan->l2cap_sk);
-		return -ENOMEM;
-	}
-
-	INIT_WORK(&amp_work->work, l2cap_logical_link_worker);
-	amp_work->chan = chan;
-	amp_work->status = status;
-
-	hci_chan_hold(chan);
-
-	if (!queue_work(_l2cap_wq, &amp_work->work)) {
-		kfree(amp_work);
-		sock_put(chan->l2cap_sk);
-		hci_chan_put(chan);
-		return -ENOMEM;
-	}
+	icid = le16_to_cpu(req->icid);
 
-	return 0;
-}
+	BT_DBG("icid %d, dest_amp_id %d", icid, req->dest_amp_id);
 
-int l2cap_modify_cfm(struct hci_chan *chan, u8 status)
-{
-	struct l2cap_conn *conn = chan->conn->l2cap_data;
+	if (!enable_hs)
+		return -EINVAL;
 
-	BT_DBG("chan %p conn %p status %d", chan, conn, status);
+	/* Placeholder: Always refuse */
+	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
 
-	/* TODO: if failed status restore previous fs */
 	return 0;
 }
 
-int l2cap_destroy_cfm(struct hci_chan *chan, u8 reason)
+static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_chan_list *l;
-	struct l2cap_conn *conn = chan->conn->l2cap_data;
-	struct sock *sk;
+	struct l2cap_move_chan_rsp *rsp = data;
+	u16 icid, result;
 
-	BT_DBG("chan %p conn %p", chan, conn);
+	if (cmd_len != sizeof(*rsp))
+		return -EPROTO;
 
-	if (!conn)
-		return 0;
+	icid = le16_to_cpu(rsp->icid);
+	result = le16_to_cpu(rsp->result);
 
-	l = &conn->chan_list;
+	BT_DBG("icid %d, result %d", icid, result);
 
-	read_lock(&l->lock);
+	/* Placeholder: Always unconfirmed */
+	l2cap_send_move_chan_cfm(conn, NULL, icid, L2CAP_MC_UNCONFIRMED);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
-		/* TODO MM/PK - What to do if connection is LOCAL_BUSY?  */
-		if (l2cap_pi(sk)->ampchan == chan) {
-			struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
-			l2cap_pi(sk)->ampchan = NULL;
-			l2cap_pi(sk)->ampcon = NULL;
-			if (hci_chan_put(chan))
-				ampcon->l2cap_data = NULL;
-			else
-				l2cap_deaggregate(chan, l2cap_pi(sk));
+	return 0;
+}
 
-			l2cap_amp_move_init(sk);
-		}
-		bh_unlock_sock(sk);
-	}
+static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+{
+	struct l2cap_move_chan_cfm *cfm = data;
+	u16 icid, result;
+
+	if (cmd_len != sizeof(*cfm))
+		return -EPROTO;
 
-	read_unlock(&l->lock);
+	icid = le16_to_cpu(cfm->icid);
+	result = le16_to_cpu(cfm->result);
 
-	return 0;
+	BT_DBG("icid %d, result %d", icid, result);
 
+	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
 
+	return 0;
 }
 
-static int l2cap_sig_amp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd,
-			u8 *data, struct sk_buff *skb)
+static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
 {
-	struct l2cap_amp_signal_work *amp_work;
+	struct l2cap_move_chan_cfm_rsp *rsp = data;
+	u16 icid;
 
-	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
-	if (!amp_work)
-		return -ENOMEM;
-
-	INIT_WORK(&amp_work->work, l2cap_amp_signal_worker);
-	amp_work->conn = conn;
-	amp_work->cmd = *cmd;
-	amp_work->data = data;
-	amp_work->skb = skb_clone(skb, GFP_ATOMIC);
-	if (!amp_work->skb) {
-		kfree(amp_work);
-		return -ENOMEM;
-	}
-
-	if (!queue_work(_l2cap_wq, &amp_work->work)) {
-		kfree_skb(amp_work->skb);
-		kfree(amp_work);
-		return -ENOMEM;
-	}
+	if (cmd_len != sizeof(*rsp))
+		return -EPROTO;
+
+	icid = le16_to_cpu(rsp->icid);
+
+	BT_DBG("icid %d", icid);
 
 	return 0;
 }
@@ -5720,8 +3436,7 @@
 	struct hci_conn *hcon = conn->hcon;
 	struct l2cap_conn_param_update_req *req;
 	struct l2cap_conn_param_update_rsp rsp;
-	struct sock *sk;
-	u16 min, max, latency, timeout, cmd_len;
+	u16 min, max, latency, to_multiplier, cmd_len;
 	int err;
 
 	if (!(hcon->link_mode & HCI_LM_MASTER))
@@ -5731,39 +3446,34 @@
 	if (cmd_len != sizeof(struct l2cap_conn_param_update_req))
 		return -EPROTO;
 
-	memset(&rsp, 0, sizeof(rsp));
-	rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
+	req = (struct l2cap_conn_param_update_req *) data;
+	min		= __le16_to_cpu(req->min);
+	max		= __le16_to_cpu(req->max);
+	latency		= __le16_to_cpu(req->latency);
+	to_multiplier	= __le16_to_cpu(req->to_multiplier);
 
-	sk = l2cap_find_sock_by_fixed_cid_and_dir(4, conn->src, conn->dst, 0);
+	BT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",
+						min, max, latency, to_multiplier);
 
-	if (sk && !bt_sk(sk)->le_params.prohibit_remote_chg) {
-		req = (struct l2cap_conn_param_update_req *) data;
-		min = __le16_to_cpu(req->min);
-		max = __le16_to_cpu(req->max);
-		latency = __le16_to_cpu(req->latency);
-		timeout = __le16_to_cpu(req->to_multiplier);
+	memset(&rsp, 0, sizeof(rsp));
 
-		err = l2cap_check_conn_param(min, max, latency, timeout);
-		if (!err) {
-			rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
-			hci_le_conn_update(hcon, min, max, latency, timeout);
-			bt_sk(sk)->le_params.interval_min = min;
-			bt_sk(sk)->le_params.interval_max = max;
-			bt_sk(sk)->le_params.latency = latency;
-			bt_sk(sk)->le_params.supervision_timeout = timeout;
-		}
-	}
+	err = l2cap_check_conn_param(min, max, latency, to_multiplier);
+	if (err)
+		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
+	else
+		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
 
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,
 							sizeof(rsp), &rsp);
 
+	if (!err)
+		hci_le_conn_update(hcon, min, max, latency, to_multiplier);
 
 	return 0;
 }
 
 static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data,
-			struct sk_buff *skb)
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
 {
 	int err = 0;
 
@@ -5812,7 +3522,7 @@
 		break;
 
 	case L2CAP_CREATE_CHAN_REQ:
-		err = l2cap_create_channel_req(conn, cmd, data);
+		err = l2cap_create_channel_req(conn, cmd, cmd_len, data);
 		break;
 
 	case L2CAP_CREATE_CHAN_RSP:
@@ -5820,11 +3530,21 @@
 		break;
 
 	case L2CAP_MOVE_CHAN_REQ:
+		err = l2cap_move_channel_req(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_RSP:
+		err = l2cap_move_channel_rsp(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_CFM:
+		err = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);
+		break;
+
 	case L2CAP_MOVE_CHAN_CFM_RSP:
-		err = l2cap_sig_amp(conn, cmd, data, skb);
+		err = l2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);
 		break;
+
 	default:
 		BT_ERR("Unknown BR/EDR signaling command 0x%2.2x", cmd->code);
 		err = -EINVAL;
@@ -5881,16 +3601,15 @@
 		if (conn->hcon->type == LE_LINK)
 			err = l2cap_le_sig_cmd(conn, &cmd, data);
 		else
-			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len,
-							data, skb);
+			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len, data);
 
 		if (err) {
-			struct l2cap_cmd_rej rej;
+			struct l2cap_cmd_rej_unk rej;
 
 			BT_ERR("Wrong link type (%d)", err);
 
 			/* FIXME: Map err to a valid reason */
-			rej.reason = cpu_to_le16(0);
+			rej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);
 			l2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);
 		}
 
@@ -5901,183 +3620,94 @@
 	kfree_skb(skb);
 }
 
-static int l2cap_check_fcs(struct l2cap_pinfo *pi,  struct sk_buff *skb)
+static int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)
 {
 	u16 our_fcs, rcv_fcs;
 	int hdr_size;
 
-	if (pi->extended_control)
-		hdr_size = L2CAP_EXTENDED_HDR_SIZE;
+	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
+		hdr_size = L2CAP_EXT_HDR_SIZE;
 	else
-		hdr_size = L2CAP_ENHANCED_HDR_SIZE;
+		hdr_size = L2CAP_ENH_HDR_SIZE;
 
-	if (pi->fcs == L2CAP_FCS_CRC16) {
+	if (chan->fcs == L2CAP_FCS_CRC16) {
 		skb_trim(skb, skb->len - L2CAP_FCS_SIZE);
 		rcv_fcs = get_unaligned_le16(skb->data + skb->len);
 		our_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);
 
-		if (our_fcs != rcv_fcs) {
-			BT_DBG("Bad FCS");
+		if (our_fcs != rcv_fcs)
 			return -EBADMSG;
-		}
 	}
 	return 0;
 }
 
-static void l2cap_ertm_pass_to_tx(struct sock *sk,
-				struct bt_l2cap_control *control)
-{
-	BT_DBG("sk %p, control %p", sk, control);
-	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT);
-}
-
-static void l2cap_ertm_pass_to_tx_fbit(struct sock *sk,
-				struct bt_l2cap_control *control)
+static inline void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)
 {
-	BT_DBG("sk %p, control %p", sk, control);
-	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_FBIT);
-}
-
-static void l2cap_ertm_resend(struct sock *sk)
-{
-	struct bt_l2cap_control control;
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-	struct sk_buff *tx_skb;
-	u16 seq;
-
-	BT_DBG("sk %p", sk);
-
-	pi = l2cap_pi(sk);
-
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return;
-
-	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
-			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
-		return;
-
-	while (pi->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {
-		seq = l2cap_seq_list_pop(&pi->retrans_list);
-
-		skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), seq);
-		if (!skb) {
-			BT_DBG("Error: Can't retransmit seq %d, frame missing",
-				(int) seq);
-			continue;
-		}
-
-		bt_cb(skb)->retries += 1;
-		control = bt_cb(skb)->control;
-
-		if ((pi->max_tx != 0) && (bt_cb(skb)->retries > pi->max_tx)) {
-			BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			l2cap_seq_list_clear(&pi->retrans_list);
-			break;
-		}
-
-		control.reqseq = pi->buffer_seq;
-		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-			control.final = 1;
-			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-		} else {
-			control.final = 0;
-		}
-
-		if (skb_cloned(skb)) {
-			/* Cloned sk_buffs are read-only, so we need a
-			 * writeable copy
-			 */
-			tx_skb = skb_copy(skb, GFP_ATOMIC);
-		} else {
-			tx_skb = skb_clone(skb, GFP_ATOMIC);
-		}
+	u32 control = 0;
 
-		if (!tx_skb) {
-			l2cap_seq_list_clear(&pi->retrans_list);
-			break;
-		}
-
-		/* Update skb contents */
-		if (pi->extended_control) {
-			put_unaligned_le32(__pack_extended_control(&control),
-					tx_skb->data + L2CAP_HDR_SIZE);
-		} else {
-			put_unaligned_le16(__pack_enhanced_control(&control),
-					tx_skb->data + L2CAP_HDR_SIZE);
-		}
+	chan->frames_sent = 0;
 
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			apply_fcs(tx_skb);
+	control |= __set_reqseq(chan, chan->buffer_seq);
 
-		sock_hold(sk);
-		tx_skb->sk = sk;
-		tx_skb->destructor = l2cap_skb_destructor;
-		atomic_inc(&pi->ertm_queued);
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
+		l2cap_send_sframe(chan, control);
+		set_bit(CONN_RNR_SENT, &chan->conn_state);
+	}
 
-		l2cap_do_send(sk, tx_skb);
+	if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))
+		l2cap_retransmit_frames(chan);
 
-		BT_DBG("Resent txseq %d", (int)control.txseq);
+	l2cap_ertm_send(chan);
 
-		pi->last_acked_seq = pi->buffer_seq;
+	if (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&
+			chan->frames_sent == 0) {
+		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+		l2cap_send_sframe(chan, control);
 	}
 }
 
-static inline void l2cap_ertm_retransmit(struct sock *sk,
-					struct bt_l2cap_control *control)
-{
-	BT_DBG("sk %p, control %p", sk, control);
-
-	l2cap_seq_list_append(&l2cap_pi(sk)->retrans_list, control->reqseq);
-	l2cap_ertm_resend(sk);
-}
-
-static void l2cap_ertm_retransmit_all(struct sock *sk,
-				struct bt_l2cap_control *control)
+static int l2cap_add_to_srej_queue(struct l2cap_chan *chan, struct sk_buff *skb, u16 tx_seq, u8 sar)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
+	struct sk_buff *next_skb;
+	int tx_seq_offset, next_tx_seq_offset;
 
-	BT_DBG("sk %p, control %p", sk, control);
+	bt_cb(skb)->tx_seq = tx_seq;
+	bt_cb(skb)->sar = sar;
 
-	pi = l2cap_pi(sk);
+	next_skb = skb_peek(&chan->srej_q);
 
-	if (control->poll)
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
 
-	l2cap_seq_list_clear(&pi->retrans_list);
+	while (next_skb) {
+		if (bt_cb(next_skb)->tx_seq == tx_seq)
+			return -EINVAL;
 
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		return;
+		next_tx_seq_offset = __seq_offset(chan,
+				bt_cb(next_skb)->tx_seq, chan->buffer_seq);
 
-	if (pi->unacked_frames) {
-		skb_queue_walk(TX_QUEUE(sk), skb) {
-			if ((bt_cb(skb)->control.txseq == control->reqseq) ||
-				skb == sk->sk_send_head)
-				break;
+		if (next_tx_seq_offset > tx_seq_offset) {
+			__skb_queue_before(&chan->srej_q, next_skb, skb);
+			return 0;
 		}
 
-		skb_queue_walk_from(TX_QUEUE(sk), skb) {
-			if (skb == sk->sk_send_head)
-				break;
+		if (skb_queue_is_last(&chan->srej_q, next_skb))
+			next_skb = NULL;
+		else
+			next_skb = skb_queue_next(&chan->srej_q, next_skb);
+	}
 
-			l2cap_seq_list_append(&pi->retrans_list,
-					bt_cb(skb)->control.txseq);
-		}
+	__skb_queue_tail(&chan->srej_q, skb);
 
-		l2cap_ertm_resend(sk);
-	}
+	return 0;
 }
 
-static inline void append_skb_frag(struct sk_buff *skb,
+static void append_skb_frag(struct sk_buff *skb,
 			struct sk_buff *new_frag, struct sk_buff **last_frag)
 {
 	/* skb->len reflects data in skb as well as all fragments
-	   skb->data_len reflects only data in fragments
+	 * skb->data_len reflects only data in fragments
 	 */
-	BT_DBG("skb %p, new_frag %p, *last_frag %p", skb, new_frag, *last_frag);
-
 	if (!skb_has_frag_list(skb))
 		skb_shinfo(skb)->frag_list = new_frag;
 
@@ -6091,1147 +3721,651 @@
 	skb->truesize += new_frag->truesize;
 }
 
-static int l2cap_ertm_rx_expected_iframe(struct sock *sk,
-			struct bt_l2cap_control *control, struct sk_buff *skb)
+static int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb, u32 control)
 {
-	struct l2cap_pinfo *pi;
 	int err = -EINVAL;
 
-	BT_DBG("sk %p, control %p, skb %p len %d truesize %d", sk, control,
-		skb, skb->len, skb->truesize);
-
-	if (!control)
-		return err;
-
-	pi = l2cap_pi(sk);
-
-	BT_DBG("type %c, sar %d, txseq %d, reqseq %d, final %d",
-		control->frame_type, control->sar, control->txseq,
-		control->reqseq, control->final);
-
-	switch (control->sar) {
+	switch (__get_ctrl_sar(chan, control)) {
 	case L2CAP_SAR_UNSEGMENTED:
-		if (pi->sdu) {
-			BT_DBG("Unexpected unsegmented PDU during reassembly");
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-			pi->sdu_last_frag = NULL;
-			pi->sdu_len = 0;
-		}
+		if (chan->sdu)
+			break;
 
-		BT_DBG("Unsegmented");
-		err = sock_queue_rcv_skb(sk, skb);
+		err = chan->ops->recv(chan->data, skb);
 		break;
 
 	case L2CAP_SAR_START:
-		if (pi->sdu) {
-			BT_DBG("Unexpected start PDU during reassembly");
-			kfree_skb(pi->sdu);
-		}
+		if (chan->sdu)
+			break;
 
-		pi->sdu_len = get_unaligned_le16(skb->data);
-		skb_pull(skb, 2);
+		chan->sdu_len = get_unaligned_le16(skb->data);
+		skb_pull(skb, L2CAP_SDULEN_SIZE);
 
-		if (pi->sdu_len > pi->imtu) {
+		if (chan->sdu_len > chan->imtu) {
 			err = -EMSGSIZE;
 			break;
 		}
 
-		if (skb->len >= pi->sdu_len)
+		if (skb->len >= chan->sdu_len)
 			break;
 
-		pi->sdu = skb;
-		pi->sdu_last_frag = skb;
-
-		BT_DBG("Start");
+		chan->sdu = skb;
+		chan->sdu_last_frag = skb;
 
 		skb = NULL;
 		err = 0;
 		break;
 
 	case L2CAP_SAR_CONTINUE:
-		if (!pi->sdu)
+		if (!chan->sdu)
 			break;
 
-		append_skb_frag(pi->sdu, skb,
-				&pi->sdu_last_frag);
+		append_skb_frag(chan->sdu, skb,
+				&chan->sdu_last_frag);
 		skb = NULL;
 
-		if (pi->sdu->len >= pi->sdu_len)
+		if (chan->sdu->len >= chan->sdu_len)
 			break;
 
-		BT_DBG("Continue, reassembled %d", pi->sdu->len);
-
 		err = 0;
 		break;
 
 	case L2CAP_SAR_END:
-		if (!pi->sdu)
+		if (!chan->sdu)
 			break;
 
-		append_skb_frag(pi->sdu, skb,
-				&pi->sdu_last_frag);
+		append_skb_frag(chan->sdu, skb,
+				&chan->sdu_last_frag);
 		skb = NULL;
 
-		if (pi->sdu->len != pi->sdu_len)
+		if (chan->sdu->len != chan->sdu_len)
 			break;
 
-		BT_DBG("End, reassembled %d", pi->sdu->len);
-		/* If the sender used tiny PDUs, the rcv queuing could fail.
-		 * Applications that have issues here should use a larger
-		 * sk_rcvbuf.
-		 */
-		err = sock_queue_rcv_skb(sk, pi->sdu);
+		err = chan->ops->recv(chan->data, chan->sdu);
 
 		if (!err) {
 			/* Reassembly complete */
-			pi->sdu = NULL;
-			pi->sdu_last_frag = NULL;
-			pi->sdu_len = 0;
+			chan->sdu = NULL;
+			chan->sdu_last_frag = NULL;
+			chan->sdu_len = 0;
 		}
 		break;
-
-	default:
-		BT_DBG("Bad SAR value");
-		break;
 	}
 
 	if (err) {
-		BT_DBG("Reassembly error %d, sk_rcvbuf %d, sk_rmem_alloc %d",
-			err, sk->sk_rcvbuf, atomic_read(&sk->sk_rmem_alloc));
-		if (pi->sdu) {
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-		}
-		pi->sdu_last_frag = NULL;
-		pi->sdu_len = 0;
-		if (skb)
-			kfree_skb(skb);
+		kfree_skb(skb);
+		kfree_skb(chan->sdu);
+		chan->sdu = NULL;
+		chan->sdu_last_frag = NULL;
+		chan->sdu_len = 0;
 	}
 
-	/* Update local busy state */
-	if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY) && l2cap_rmem_full(sk))
-		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED);
-
 	return err;
 }
 
-static int l2cap_ertm_rx_queued_iframes(struct sock *sk)
+static void l2cap_ertm_enter_local_busy(struct l2cap_chan *chan)
 {
-	int err = 0;
-	/* Pass sequential frames to l2cap_ertm_rx_expected_iframe()
-	 * until a gap is encountered.
-	 */
-
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p", sk);
-	pi = l2cap_pi(sk);
-
-	while (l2cap_rmem_available(sk)) {
-		struct sk_buff *skb;
-		BT_DBG("Searching for skb with txseq %d (queue len %d)",
-			(int) pi->buffer_seq, skb_queue_len(SREJ_QUEUE(sk)));
-
-		skb = l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), pi->buffer_seq);
+	BT_DBG("chan %p, Enter local busy", chan);
 
-		if (!skb)
-			break;
-
-		skb_unlink(skb, SREJ_QUEUE(sk));
-		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
-		err = l2cap_ertm_rx_expected_iframe(sk,
-						&bt_cb(skb)->control, skb);
-		if (err)
-			break;
-	}
-
-	if (skb_queue_empty(SREJ_QUEUE(sk))) {
-		pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-		l2cap_ertm_send_ack(sk);
-	}
+	set_bit(CONN_LOCAL_BUSY, &chan->conn_state);
 
-	return err;
+	__set_ack_timer(chan);
 }
 
-static void l2cap_ertm_handle_srej(struct sock *sk,
-				struct bt_l2cap_control *control)
+static void l2cap_ertm_exit_local_busy(struct l2cap_chan *chan)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-
-	BT_DBG("sk %p, control %p", sk, control);
-
-	pi = l2cap_pi(sk);
-
-	if (control->reqseq == pi->next_tx_seq) {
-		BT_DBG("Invalid reqseq %d, disconnecting",
-			(int) control->reqseq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
+	u32 control;
 
-	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
-
-	if (skb == NULL) {
-		BT_DBG("Seq %d not available for retransmission",
-			(int) control->reqseq);
-		return;
-	}
+	if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
+		goto done;
 
-	if ((pi->max_tx != 0) && (bt_cb(skb)->retries >= pi->max_tx)) {
-		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
+	control = __set_reqseq(chan, chan->buffer_seq);
+	control |= __set_ctrl_poll(chan);
+	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
+	l2cap_send_sframe(chan, control);
+	chan->retry_count = 1;
 
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	__clear_retrans_timer(chan);
+	__set_monitor_timer(chan);
 
-	if (control->poll) {
-		l2cap_ertm_pass_to_tx(sk, control);
+	set_bit(CONN_WAIT_F, &chan->conn_state);
 
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-		l2cap_ertm_retransmit(sk, control);
-		l2cap_ertm_send(sk);
-
-		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
-			pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-			pi->srej_save_reqseq = control->reqseq;
-		}
-	} else {
-		l2cap_ertm_pass_to_tx_fbit(sk, control);
+done:
+	clear_bit(CONN_LOCAL_BUSY, &chan->conn_state);
+	clear_bit(CONN_RNR_SENT, &chan->conn_state);
 
-		if (control->final) {
-			if ((pi->conn_state & L2CAP_CONN_SREJ_ACT) &&
-				(pi->srej_save_reqseq == control->reqseq)) {
-				pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
-			} else {
-				l2cap_ertm_retransmit(sk, control);
-			}
-		} else {
-			l2cap_ertm_retransmit(sk, control);
-			if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
-				pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-				pi->srej_save_reqseq = control->reqseq;
-			}
-		}
-	}
+	BT_DBG("chan %p, Exit local busy", chan);
 }
 
-static void l2cap_ertm_handle_rej(struct sock *sk,
-				struct bt_l2cap_control *control)
+void l2cap_chan_busy(struct l2cap_chan *chan, int busy)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
-
-	BT_DBG("sk %p, control %p", sk, control);
-
-	pi = l2cap_pi(sk);
-
-	if (control->reqseq == pi->next_tx_seq) {
-		BT_DBG("Invalid reqseq %d, disconnecting",
-			(int) control->reqseq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
-
-	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
-
-	if (pi->max_tx && skb && bt_cb(skb)->retries >= pi->max_tx) {
-		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		return;
-	}
-
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-	l2cap_ertm_pass_to_tx(sk, control);
-
-	if (control->final) {
-		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+	if (chan->mode == L2CAP_MODE_ERTM) {
+		if (busy)
+			l2cap_ertm_enter_local_busy(chan);
 		else
-			l2cap_ertm_retransmit_all(sk, control);
-	} else {
-		l2cap_ertm_retransmit_all(sk, control);
-		l2cap_ertm_send(sk);
-		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F)
-			pi->conn_state |= L2CAP_CONN_REJ_ACT;
+			l2cap_ertm_exit_local_busy(chan);
 	}
 }
 
-static u8 l2cap_ertm_classify_txseq(struct sock *sk, u16 txseq)
+static void l2cap_check_srej_gap(struct l2cap_chan *chan, u16 tx_seq)
 {
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
-	pi = l2cap_pi(sk);
+	struct sk_buff *skb;
+	u32 control;
 
-	BT_DBG("last_acked_seq %d, expected_tx_seq %d", (int)pi->last_acked_seq,
-		(int)pi->expected_tx_seq);
+	while ((skb = skb_peek(&chan->srej_q)) &&
+			!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		int err;
 
-	if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
-		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-			/* See notes below regarding "double poll" and
-			 * invalid packets.
-			 */
-			if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
-				BT_DBG("Invalid/Ignore - txseq outside "
-					"tx window after SREJ sent");
-				return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
-			} else {
-				BT_DBG("Invalid - bad txseq within tx "
-					"window after SREJ sent");
-				return L2CAP_ERTM_TXSEQ_INVALID;
-			}
-		}
+		if (bt_cb(skb)->tx_seq != tx_seq)
+			break;
 
-		if (pi->srej_list.head == txseq) {
-			BT_DBG("Expected SREJ");
-			return L2CAP_ERTM_TXSEQ_EXPECTED_SREJ;
-		}
+		skb = skb_dequeue(&chan->srej_q);
+		control = __set_ctrl_sar(chan, bt_cb(skb)->sar);
+		err = l2cap_reassemble_sdu(chan, skb, control);
 
-		if (l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), txseq)) {
-			BT_DBG("Duplicate SREJ - txseq already stored");
-			return L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ;
+		if (err < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			break;
 		}
 
-		if (l2cap_seq_list_contains(&pi->srej_list, txseq)) {
-			BT_DBG("Unexpected SREJ - txseq not requested "
-				"with SREJ");
-			return L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ;
-		}
+		chan->buffer_seq_srej = __next_seq(chan, chan->buffer_seq_srej);
+		tx_seq = __next_seq(chan, tx_seq);
 	}
+}
 
-	if (pi->expected_tx_seq == txseq) {
-		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-			BT_DBG("Invalid - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID;
-		} else {
-			BT_DBG("Expected");
-			return L2CAP_ERTM_TXSEQ_EXPECTED;
-		}
-	}
+static void l2cap_resend_srejframe(struct l2cap_chan *chan, u16 tx_seq)
+{
+	struct srej_list *l, *tmp;
+	u32 control;
 
-	if (__delta_seq(txseq, pi->last_acked_seq, pi) <
-		__delta_seq(pi->expected_tx_seq, pi->last_acked_seq, pi)) {
-		BT_DBG("Duplicate - expected_tx_seq later than txseq");
-		return L2CAP_ERTM_TXSEQ_DUPLICATE;
-	}
-
-	if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
-		/* A source of invalid packets is a "double poll" condition,
-		 * where delays cause us to send multiple poll packets.  If
-		 * the remote stack receives and processes both polls,
-		 * sequence numbers can wrap around in such a way that a
-		 * resent frame has a sequence number that looks like new data
-		 * with a sequence gap.  This would trigger an erroneous SREJ
-		 * request.
-		 *
-		 * Fortunately, this is impossible with a tx window that's
-		 * less than half of the maximum sequence number, which allows
-		 * invalid frames to be safely ignored.
-		 *
-		 * With tx window sizes greater than half of the tx window
-		 * maximum, the frame is invalid and cannot be ignored.  This
-		 * causes a disconnect.
-		 */
-
-		if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
-			BT_DBG("Invalid/Ignore - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
-		} else {
-			BT_DBG("Invalid - txseq outside tx window");
-			return L2CAP_ERTM_TXSEQ_INVALID;
+	list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
+		if (l->tx_seq == tx_seq) {
+			list_del(&l->list);
+			kfree(l);
+			return;
 		}
-	} else {
-		BT_DBG("Unexpected - txseq indicates missing frames");
-		return L2CAP_ERTM_TXSEQ_UNEXPECTED;
+		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+		control |= __set_reqseq(chan, l->tx_seq);
+		l2cap_send_sframe(chan, control);
+		list_del(&l->list);
+		list_add_tail(&l->list, &chan->srej_l);
 	}
 }
 
-static int l2cap_ertm_rx_state_recv(struct sock *sk,
-				struct bt_l2cap_control *control,
-				struct sk_buff *skb, u8 event)
+static int l2cap_send_srejframe(struct l2cap_chan *chan, u16 tx_seq)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
-	bool skb_in_use = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		switch (l2cap_ertm_classify_txseq(sk, control->txseq)) {
-		case L2CAP_ERTM_TXSEQ_EXPECTED:
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding expected seq %d",
-					control->txseq);
-				break;
-			}
+	struct srej_list *new;
+	u32 control;
 
-			pi->expected_tx_seq = __next_seq(control->txseq, pi);
-			pi->buffer_seq = pi->expected_tx_seq;
-			skb_in_use = 1;
+	while (tx_seq != chan->expected_tx_seq) {
+		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
+		control |= __set_reqseq(chan, chan->expected_tx_seq);
+		l2cap_send_sframe(chan, control);
 
-			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
-			if (err)
-				break;
-
-			if (control->final) {
-				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-				else {
-					control->final = 0;
-					l2cap_ertm_retransmit_all(sk, control);
-					l2cap_ertm_send(sk);
-				}
-			}
-
-			if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY))
-				l2cap_ertm_send_ack(sk);
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			/* Can't issue SREJ frames in the local busy state.
-			 * Drop this frame, it will be seen as missing
-			 * when local busy is exited.
-			 */
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding unexpected seq %d",
-					control->txseq);
-				break;
-			}
+		new = kzalloc(sizeof(struct srej_list), GFP_ATOMIC);
+		if (!new)
+			return -ENOMEM;
 
-			/* There was a gap in the sequence, so an SREJ
-			 * must be sent for each missing frame.  The
-			 * current frame is stored for later use.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
-			l2cap_seq_list_clear(&pi->srej_list);
-			l2cap_ertm_send_srej(sk, control->txseq);
+		new->tx_seq = chan->expected_tx_seq;
 
-			pi->rx_state = L2CAP_ERTM_RX_STATE_SREJ_SENT;
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE:
-			l2cap_ertm_pass_to_tx(sk, control);
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID:
-		default:
-			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
-					ECONNRESET);
-			break;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->final) {
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-			else if (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
-				pi->amp_move_state ==
-						L2CAP_AMP_STATE_WAIT_PREPARE) {
-				control->final = 0;
-				l2cap_ertm_retransmit_all(sk, control);
-			}
+		chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-			l2cap_ertm_send(sk);
-		} else if (control->poll) {
-			l2cap_ertm_send_i_or_rr_or_rnr(sk);
-		} else {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames)
-				l2cap_ertm_start_retrans_timer(pi);
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			l2cap_ertm_send(sk);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control && control->poll) {
-			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-			l2cap_ertm_send_rr_or_rnr(sk, 0);
-		}
-		l2cap_ertm_stop_retrans_timer(pi);
-		l2cap_seq_list_clear(&pi->retrans_list);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_handle_rej(sk, control);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		l2cap_ertm_handle_srej(sk, control);
-		break;
-	default:
-		break;
+		list_add_tail(&new->list, &chan->srej_l);
 	}
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
-	}
+	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-	return err;
+	return 0;
 }
 
-static int l2cap_ertm_rx_state_srej_sent(struct sock *sk,
-					struct bt_l2cap_control *control,
-					struct sk_buff *skb, u8 event)
+static inline int l2cap_data_channel_iframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
+	u16 tx_seq = __get_txseq(chan, rx_control);
+	u16 req_seq = __get_reqseq(chan, rx_control);
+	u8 sar = __get_ctrl_sar(chan, rx_control);
+	int tx_seq_offset, expected_tx_seq_offset;
+	int num_to_ack = (chan->tx_win/6) + 1;
 	int err = 0;
-	u16 txseq = control->txseq;
-	bool skb_in_use = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		switch (l2cap_ertm_classify_txseq(sk, txseq)) {
-		case L2CAP_ERTM_TXSEQ_EXPECTED:
-			/* Keep frame for reassembly later */
-			l2cap_ertm_pass_to_tx(sk, control);
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			pi->expected_tx_seq = __next_seq(txseq, pi);
-			break;
-		case L2CAP_ERTM_TXSEQ_EXPECTED_SREJ:
-			l2cap_seq_list_pop(&pi->srej_list);
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
 
-			err = l2cap_ertm_rx_queued_iframes(sk);
-			if (err)
-				break;
+	BT_DBG("chan %p len %d tx_seq %d rx_control 0x%8.8x", chan, skb->len,
+							tx_seq, rx_control);
 
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
-			/* Got a frame that can't be reassembled yet.
-			 * Save it for later, and send SREJs to cover
-			 * the missing frames.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			l2cap_ertm_send_srej(sk, control->txseq);
-			break;
-		case L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ:
-			/* This frame was requested with an SREJ, but
-			 * some expected retransmitted frames are
-			 * missing.  Request retransmission of missing
-			 * SREJ'd frames.
-			 */
-			skb_queue_tail(SREJ_QUEUE(sk), skb);
-			skb_in_use = 1;
-			BT_DBG("Queued %p (queue len %d)", skb,
-			       skb_queue_len(SREJ_QUEUE(sk)));
-
-			l2cap_ertm_pass_to_tx(sk, control);
-			l2cap_ertm_send_srej_list(sk, control->txseq);
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ:
-			/* We've already queued this frame.  Drop this copy. */
-			l2cap_ertm_pass_to_tx(sk, control);
-			break;
-		case L2CAP_ERTM_TXSEQ_DUPLICATE:
-			/* Expecting a later sequence number, so this frame
-			 * was already received.  Ignore it completely.
-			 */
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
-			break;
-		case L2CAP_ERTM_TXSEQ_INVALID:
-		default:
-			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
-					ECONNRESET);
-			break;
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->final) {
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+	if (__is_ctrl_final(chan, rx_control) &&
+			test_bit(CONN_WAIT_F, &chan->conn_state)) {
+		__clear_monitor_timer(chan);
+		if (chan->unacked_frames > 0)
+			__set_retrans_timer(chan);
+		clear_bit(CONN_WAIT_F, &chan->conn_state);
+	}
 
-			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-			else {
-				control->final = 0;
-				l2cap_ertm_retransmit_all(sk, control);
-			}
+	chan->expected_ack_seq = req_seq;
+	l2cap_drop_acked_frames(chan);
 
-			l2cap_ertm_send(sk);
-		} else if (control->poll) {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames) {
-				l2cap_ertm_start_retrans_timer(pi);
-			}
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-			l2cap_ertm_send_srej_tail(sk);
-		} else {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				pi->unacked_frames) {
-				l2cap_ertm_start_retrans_timer(pi);
-			}
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			l2cap_ertm_send_ack(sk);
-		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-		l2cap_ertm_pass_to_tx(sk, control);
-		if (control->poll)
-			l2cap_ertm_send_srej_tail(sk);
-		else {
-			struct bt_l2cap_control rr_control;
-			memset(&rr_control, 0, sizeof(rr_control));
-			rr_control.frame_type = 's';
-			rr_control.super = L2CAP_SFRAME_RR;
-			rr_control.reqseq = pi->buffer_seq;
-			l2cap_ertm_send_sframe(sk, &rr_control);
-		}
+	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
 
-		break;
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_handle_rej(sk, control);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		l2cap_ertm_handle_srej(sk, control);
-		break;
+	/* invalid tx_seq */
+	if (tx_seq_offset >= chan->tx_win) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
 	}
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
+	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
+		if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
+			l2cap_send_ack(chan);
+		goto drop;
 	}
 
-	return err;
-}
+	if (tx_seq == chan->expected_tx_seq)
+		goto expected;
 
-static int l2cap_ertm_rx_state_amp_move(struct sock *sk,
-					struct bt_l2cap_control *control,
-					struct sk_buff *skb, u8 event)
-{
-	struct l2cap_pinfo *pi;
-	int err = 0;
-	bool skb_in_use = 0;
+	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		struct srej_list *first;
 
-	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
-		(int)event);
-	pi = l2cap_pi(sk);
-
-	/* Only handle expected frames, to avoid state changes. */
-
-	switch (event) {
-	case L2CAP_ERTM_EVENT_RECV_IFRAME:
-		if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
-				L2CAP_ERTM_TXSEQ_EXPECTED) {
-			l2cap_ertm_pass_to_tx(sk, control);
-
-			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-				BT_DBG("Busy, discarding expected seq %d",
-					control->txseq);
-				break;
+		first = list_first_entry(&chan->srej_l,
+				struct srej_list, list);
+		if (tx_seq == first->tx_seq) {
+			l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
+			l2cap_check_srej_gap(chan, tx_seq);
+
+			list_del(&first->list);
+			kfree(first);
+
+			if (list_empty(&chan->srej_l)) {
+				chan->buffer_seq = chan->buffer_seq_srej;
+				clear_bit(CONN_SREJ_SENT, &chan->conn_state);
+				l2cap_send_ack(chan);
+				BT_DBG("chan %p, Exit SREJ_SENT", chan);
 			}
+		} else {
+			struct srej_list *l;
 
-			pi->expected_tx_seq = __next_seq(control->txseq, pi);
-			pi->buffer_seq = pi->expected_tx_seq;
-			skb_in_use = 1;
+			/* duplicated tx_seq */
+			if (l2cap_add_to_srej_queue(chan, skb, tx_seq, sar) < 0)
+				goto drop;
 
-			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
-			if (err)
-				break;
+			list_for_each_entry(l, &chan->srej_l, list) {
+				if (l->tx_seq == tx_seq) {
+					l2cap_resend_srejframe(chan, tx_seq);
+					return 0;
+				}
+			}
 
-			if (control->final) {
-				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-				else
-					control->final = 0;
+			err = l2cap_send_srejframe(chan, tx_seq);
+			if (err < 0) {
+				l2cap_send_disconn_req(chan->conn, chan, -err);
+				return err;
 			}
 		}
-		break;
-	case L2CAP_ERTM_EVENT_RECV_RR:
-	case L2CAP_ERTM_EVENT_RECV_RNR:
-	case L2CAP_ERTM_EVENT_RECV_REJ:
-		l2cap_ertm_process_reqseq(sk, control->reqseq);
-		break;
-	case L2CAP_ERTM_EVENT_RECV_SREJ:
-		/* Ignore */
-		break;
-	default:
-		break;
-	}
+	} else {
+		expected_tx_seq_offset = __seq_offset(chan,
+				chan->expected_tx_seq, chan->buffer_seq);
+
+		/* duplicated tx_seq */
+		if (tx_seq_offset < expected_tx_seq_offset)
+			goto drop;
 
-	if (skb && !skb_in_use) {
-		BT_DBG("Freeing %p", skb);
-		kfree_skb(skb);
-	}
+		set_bit(CONN_SREJ_SENT, &chan->conn_state);
 
-	return err;
-}
+		BT_DBG("chan %p, Enter SREJ", chan);
 
-static int l2cap_answer_move_poll(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control control;
-	int err = 0;
+		INIT_LIST_HEAD(&chan->srej_l);
+		chan->buffer_seq_srej = chan->buffer_seq;
 
-	BT_DBG("sk %p", sk);
+		__skb_queue_head_init(&chan->srej_q);
+		l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
 
-	pi = l2cap_pi(sk);
+		/* Set P-bit only if there are some I-frames to ack. */
+		if (__clear_ack_timer(chan))
+			set_bit(CONN_SEND_PBIT, &chan->conn_state);
 
-	l2cap_ertm_process_reqseq(sk, pi->amp_move_reqseq);
+		err = l2cap_send_srejframe(chan, tx_seq);
+		if (err < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, -err);
+			return err;
+		}
+	}
+	return 0;
 
-	if (!skb_queue_empty(TX_QUEUE(sk)))
-		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
-	else
-		sk->sk_send_head = NULL;
+expected:
+	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
 
-	/* Rewind next_tx_seq to the point expected
-	 * by the receiver.
-	 */
-	pi->next_tx_seq = pi->amp_move_reqseq;
-	pi->unacked_frames = 0;
+	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		bt_cb(skb)->tx_seq = tx_seq;
+		bt_cb(skb)->sar = sar;
+		__skb_queue_tail(&chan->srej_q, skb);
+		return 0;
+	}
 
-	err = l2cap_finish_amp_move(sk);
+	err = l2cap_reassemble_sdu(chan, skb, rx_control);
+	chan->buffer_seq = __next_seq(chan, chan->buffer_seq);
 
-	if (err)
+	if (err < 0) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
 		return err;
+	}
 
-	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-	l2cap_ertm_send_i_or_rr_or_rnr(sk);
+	if (__is_ctrl_final(chan, rx_control)) {
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+	}
 
-	memset(&control, 0, sizeof(control));
-	control.reqseq = pi->amp_move_reqseq;
 
-	if (pi->amp_move_event == L2CAP_ERTM_EVENT_RECV_IFRAME)
-		err = -EPROTO;
+	chan->num_acked = (chan->num_acked + 1) % num_to_ack;
+	if (chan->num_acked == num_to_ack - 1)
+		l2cap_send_ack(chan);
 	else
-		err = l2cap_ertm_rx_state_recv(sk, &control, NULL,
-					pi->amp_move_event);
+		__set_ack_timer(chan);
 
-	return err;
+	return 0;
+
+drop:
+	kfree_skb(skb);
+	return 0;
 }
 
-static void l2cap_amp_move_setup(struct sock *sk)
+static inline void l2cap_data_channel_rrframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
-	struct sk_buff *skb;
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan,
+				__get_reqseq(chan, rx_control), rx_control);
 
-	BT_DBG("sk %p", sk);
+	chan->expected_ack_seq = __get_reqseq(chan, rx_control);
+	l2cap_drop_acked_frames(chan);
 
-	pi = l2cap_pi(sk);
+	if (__is_ctrl_poll(chan, rx_control)) {
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+		if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+			if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+					(chan->unacked_frames > 0))
+				__set_retrans_timer(chan);
 
-	l2cap_ertm_stop_ack_timer(pi);
-	l2cap_ertm_stop_retrans_timer(pi);
-	l2cap_ertm_stop_monitor_timer(pi);
-
-	pi->retry_count = 0;
-	skb_queue_walk(TX_QUEUE(sk), skb) {
-		if (bt_cb(skb)->retries)
-			bt_cb(skb)->retries = 1;
+			clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+			l2cap_send_srejtail(chan);
+		} else {
+			l2cap_send_i_or_rr_or_rnr(chan);
+		}
+
+	} else if (__is_ctrl_final(chan, rx_control)) {
+		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+
+	} else {
+		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
+				(chan->unacked_frames > 0))
+			__set_retrans_timer(chan);
+
+		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+		if (test_bit(CONN_SREJ_SENT, &chan->conn_state))
+			l2cap_send_ack(chan);
 		else
-			break;
+			l2cap_ertm_send(chan);
 	}
+}
 
-	pi->expected_tx_seq = pi->buffer_seq;
+static inline void l2cap_data_channel_rejframe(struct l2cap_chan *chan, u32 rx_control)
+{
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	pi->conn_state &= ~(L2CAP_CONN_REJ_ACT | L2CAP_CONN_SREJ_ACT);
-	l2cap_seq_list_clear(&pi->retrans_list);
-	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
-	skb_queue_purge(SREJ_QUEUE(sk));
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
-	pi->rx_state = L2CAP_ERTM_RX_STATE_AMP_MOVE;
+	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
 
-	BT_DBG("tx_state 0x2.2%x rx_state  0x2.2%x", pi->tx_state,
-		pi->rx_state);
+	chan->expected_ack_seq = tx_seq;
+	l2cap_drop_acked_frames(chan);
 
-	pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-}
+	if (__is_ctrl_final(chan, rx_control)) {
+		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
+			l2cap_retransmit_frames(chan);
+	} else {
+		l2cap_retransmit_frames(chan);
 
-static void l2cap_amp_move_revert(struct sock *sk)
+		if (test_bit(CONN_WAIT_F, &chan->conn_state))
+			set_bit(CONN_REJ_ACT, &chan->conn_state);
+	}
+}
+static inline void l2cap_data_channel_srejframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
-
-	BT_DBG("sk %p", sk);
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	pi = l2cap_pi(sk);
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		l2cap_ertm_tx(sk, NULL, NULL, L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER)
-		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_P_FLAG;
-}
+	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
 
-static int l2cap_amp_move_reconf(struct sock *sk)
-{
-	struct l2cap_pinfo *pi;
-	u8 buf[64];
-	int err = 0;
+	if (__is_ctrl_poll(chan, rx_control)) {
+		chan->expected_ack_seq = tx_seq;
+		l2cap_drop_acked_frames(chan);
 
-	BT_DBG("sk %p", sk);
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+		l2cap_retransmit_one_frame(chan, tx_seq);
 
-	pi = l2cap_pi(sk);
+		l2cap_ertm_send(chan);
 
-	l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn), L2CAP_CONF_REQ,
-				l2cap_build_amp_reconf_req(sk, buf), buf);
-	return err;
+		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			chan->srej_save_reqseq = tx_seq;
+			set_bit(CONN_SREJ_ACT, &chan->conn_state);
+		}
+	} else if (__is_ctrl_final(chan, rx_control)) {
+		if (test_bit(CONN_SREJ_ACT, &chan->conn_state) &&
+				chan->srej_save_reqseq == tx_seq)
+			clear_bit(CONN_SREJ_ACT, &chan->conn_state);
+		else
+			l2cap_retransmit_one_frame(chan, tx_seq);
+	} else {
+		l2cap_retransmit_one_frame(chan, tx_seq);
+		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
+			chan->srej_save_reqseq = tx_seq;
+			set_bit(CONN_SREJ_ACT, &chan->conn_state);
+		}
+	}
 }
 
-static void l2cap_amp_move_success(struct sock *sk)
+static inline void l2cap_data_channel_rnrframe(struct l2cap_chan *chan, u32 rx_control)
 {
-	struct l2cap_pinfo *pi;
+	u16 tx_seq = __get_reqseq(chan, rx_control);
 
-	BT_DBG("sk %p", sk);
+	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	pi = l2cap_pi(sk);
+	set_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+	chan->expected_ack_seq = tx_seq;
+	l2cap_drop_acked_frames(chan);
 
-	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
-		int err = 0;
-		/* Send reconfigure request */
-		if (pi->mode == L2CAP_MODE_ERTM) {
-			pi->reconf_state = L2CAP_RECONF_INT;
-			if (enable_reconfig)
-				err = l2cap_amp_move_reconf(sk);
-
-			if (err || !enable_reconfig) {
-				pi->reconf_state = L2CAP_RECONF_NONE;
-				l2cap_ertm_tx(sk, NULL, NULL,
-						L2CAP_ERTM_EVENT_EXPLICIT_POLL);
-				pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
-			}
-		} else
-			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
-		if (pi->mode == L2CAP_MODE_ERTM)
-			pi->rx_state =
-				L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE;
-		else
-			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+	if (__is_ctrl_poll(chan, rx_control))
+		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+
+	if (!test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
+		__clear_retrans_timer(chan);
+		if (__is_ctrl_poll(chan, rx_control))
+			l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_FINAL);
+		return;
 	}
-}
 
-static inline bool __valid_reqseq(struct l2cap_pinfo *pi, u16 reqseq)
-{
-	/* Make sure reqseq is for a packet that has been sent but not acked */
-	u16 unacked = __delta_seq(pi->next_tx_seq, pi->expected_ack_seq, pi);
-	return __delta_seq(pi->next_tx_seq, reqseq, pi) <= unacked;
+	if (__is_ctrl_poll(chan, rx_control)) {
+		l2cap_send_srejtail(chan);
+	} else {
+		rx_control = __set_ctrl_super(chan, L2CAP_SUPER_RR);
+		l2cap_send_sframe(chan, rx_control);
+	}
 }
 
-static int l2cap_strm_rx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff *skb)
+static inline int l2cap_data_channel_sframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
-
-	BT_DBG("sk %p, control %p, skb %p, state %d",
-		sk, control, skb, l2cap_pi(sk)->rx_state);
+	BT_DBG("chan %p rx_control 0x%8.8x len %d", chan, rx_control, skb->len);
 
-	pi = l2cap_pi(sk);
-
-	if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
-		L2CAP_ERTM_TXSEQ_EXPECTED) {
-		l2cap_ertm_pass_to_tx(sk, control);
+	if (__is_ctrl_final(chan, rx_control) &&
+			test_bit(CONN_WAIT_F, &chan->conn_state)) {
+		__clear_monitor_timer(chan);
+		if (chan->unacked_frames > 0)
+			__set_retrans_timer(chan);
+		clear_bit(CONN_WAIT_F, &chan->conn_state);
+	}
 
-		BT_DBG("buffer_seq %d->%d", pi->buffer_seq,
-			   __next_seq(pi->buffer_seq, pi));
+	switch (__get_ctrl_super(chan, rx_control)) {
+	case L2CAP_SUPER_RR:
+		l2cap_data_channel_rrframe(chan, rx_control);
+		break;
 
-		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
+	case L2CAP_SUPER_REJ:
+		l2cap_data_channel_rejframe(chan, rx_control);
+		break;
 
-		l2cap_ertm_rx_expected_iframe(sk, control, skb);
-	} else {
-		if (pi->sdu) {
-			kfree_skb(pi->sdu);
-			pi->sdu = NULL;
-		}
-		pi->sdu_last_frag = NULL;
-		pi->sdu_len = 0;
+	case L2CAP_SUPER_SREJ:
+		l2cap_data_channel_srejframe(chan, rx_control);
+		break;
 
-		if (skb) {
-			BT_DBG("Freeing %p", skb);
-			kfree_skb(skb);
-		}
+	case L2CAP_SUPER_RNR:
+		l2cap_data_channel_rnrframe(chan, rx_control);
+		break;
 	}
 
-	pi->last_acked_seq = control->txseq;
-	pi->expected_tx_seq = __next_seq(control->txseq, pi);
-
-	return err;
+	kfree_skb(skb);
+	return 0;
 }
 
-static int l2cap_ertm_rx(struct sock *sk, struct bt_l2cap_control *control,
-			struct sk_buff *skb, u8 event)
+static int l2cap_ertm_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	int err = 0;
+	u32 control;
+	u16 req_seq;
+	int len, next_tx_seq_offset, req_seq_offset;
+
+	control = __get_control(chan, skb->data);
+	skb_pull(skb, __ctrl_size(chan));
+	len = skb->len;
+
+	/*
+	 * We can just drop the corrupted I-frame here.
+	 * Receiver will miss it and start proper recovery
+	 * procedures and ask retransmission.
+	 */
+	if (l2cap_check_fcs(chan, skb))
+		goto drop;
 
-	BT_DBG("sk %p, control %p, skb %p, event %d, state %d",
-		sk, control, skb, (int)event, l2cap_pi(sk)->rx_state);
+	if (__is_sar_start(chan, control) && !__is_sframe(chan, control))
+		len -= L2CAP_SDULEN_SIZE;
 
-	pi = l2cap_pi(sk);
+	if (chan->fcs == L2CAP_FCS_CRC16)
+		len -= L2CAP_FCS_SIZE;
 
-	if (__valid_reqseq(pi, control->reqseq)) {
-		switch (pi->rx_state) {
-		case L2CAP_ERTM_RX_STATE_RECV:
-			err = l2cap_ertm_rx_state_recv(sk, control, skb, event);
-			break;
-		case L2CAP_ERTM_RX_STATE_SREJ_SENT:
-			err = l2cap_ertm_rx_state_srej_sent(sk, control, skb,
-							event);
-			break;
-		case L2CAP_ERTM_RX_STATE_AMP_MOVE:
-			err = l2cap_ertm_rx_state_amp_move(sk, control, skb,
-							event);
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_F_FLAG:
-			if (control->final) {
-				pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
-
-				pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
-				l2cap_ertm_process_reqseq(sk, control->reqseq);
-
-				if (!skb_queue_empty(TX_QUEUE(sk)))
-					sk->sk_send_head =
-						skb_peek(TX_QUEUE(sk));
-				else
-					sk->sk_send_head = NULL;
-
-				/* Rewind next_tx_seq to the point expected
-				 * by the receiver.
-				 */
-				pi->next_tx_seq = control->reqseq;
-				pi->unacked_frames = 0;
-
-				if (pi->ampcon)
-					pi->conn->mtu =
-						pi->ampcon->hdev->acl_mtu;
-				else
-					pi->conn->mtu =
-						pi->conn->hcon->hdev->acl_mtu;
+	if (len > chan->mps) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
+	}
 
-				err = l2cap_setup_resegment(sk);
+	req_seq = __get_reqseq(chan, control);
 
-				if (err)
-					break;
+	req_seq_offset = __seq_offset(chan, req_seq, chan->expected_ack_seq);
 
-				err = l2cap_ertm_rx_state_recv(sk, control, skb,
-							event);
-			}
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG:
-			if (control->poll) {
-				pi->amp_move_reqseq = control->reqseq;
-				pi->amp_move_event = event;
-				err = l2cap_answer_move_poll(sk);
-			}
-			break;
-		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE:
-			if (control->poll) {
-				pi->amp_move_reqseq = control->reqseq;
-				pi->amp_move_event = event;
-
-				BT_DBG("amp_move_role 0x%2.2x, "
-					"reconf_state 0x%2.2x",
-					pi->amp_move_role, pi->reconf_state);
-
-				if (pi->reconf_state == L2CAP_RECONF_ACC)
-					err = l2cap_amp_move_reconf(sk);
-				else
-					err = l2cap_answer_move_poll(sk);
-			}
-			break;
-		default:
-			/* shut it down */
-			break;
-		}
-	} else {
-		BT_DBG("Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d",
-			control->reqseq, pi->next_tx_seq, pi->expected_ack_seq);
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-	}
+	next_tx_seq_offset = __seq_offset(chan, chan->next_tx_seq,
+						chan->expected_ack_seq);
 
-	return err;
-}
+	/* check for invalid req-seq */
+	if (req_seq_offset > next_tx_seq_offset) {
+		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+		goto drop;
+	}
 
-void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt)
-{
-	lock_sock(sk);
+	if (!__is_sframe(chan, control)) {
+		if (len < 0) {
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			goto drop;
+		}
 
-	l2cap_pi(sk)->fixed_channel = 1;
+		l2cap_data_channel_iframe(chan, control, skb);
+	} else {
+		if (len != 0) {
+			BT_ERR("%d", len);
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			goto drop;
+		}
 
-	l2cap_pi(sk)->imtu = opt->imtu;
-	l2cap_pi(sk)->omtu = opt->omtu;
-	l2cap_pi(sk)->remote_mps = opt->omtu;
-	l2cap_pi(sk)->mps = opt->omtu;
-	l2cap_pi(sk)->flush_to = opt->flush_to;
-	l2cap_pi(sk)->mode = opt->mode;
-	l2cap_pi(sk)->fcs = opt->fcs;
-	l2cap_pi(sk)->max_tx = opt->max_tx;
-	l2cap_pi(sk)->remote_max_tx = opt->max_tx;
-	l2cap_pi(sk)->tx_win = opt->txwin_size;
-	l2cap_pi(sk)->remote_tx_win = opt->txwin_size;
-	l2cap_pi(sk)->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
-	l2cap_pi(sk)->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;
-
-	if (opt->mode == L2CAP_MODE_ERTM ||
-		l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
-		l2cap_ertm_init(sk);
+		l2cap_data_channel_sframe(chan, control, skb);
+	}
 
-	release_sock(sk);
+	return 0;
 
-	return;
+drop:
+	kfree_skb(skb);
+	return 0;
 }
 
-static const u8 l2cap_ertm_rx_func_to_event[4] = {
-	L2CAP_ERTM_EVENT_RECV_RR, L2CAP_ERTM_EVENT_RECV_REJ,
-	L2CAP_ERTM_EVENT_RECV_RNR, L2CAP_ERTM_EVENT_RECV_SREJ
-};
-
-int l2cap_data_channel(struct sock *sk, struct sk_buff *skb)
+static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)
 {
-	struct l2cap_pinfo *pi;
-	struct bt_l2cap_control *control;
-	u16 len;
-	u8 event;
-	pi = l2cap_pi(sk);
+	struct l2cap_chan *chan;
+	u32 control;
+	u16 tx_seq;
+	int len;
+
+	chan = l2cap_get_chan_by_scid(conn, cid);
+	if (!chan) {
+		BT_DBG("unknown cid 0x%4.4x", cid);
+		/* Drop packet and return */
+		kfree_skb(skb);
+		return 0;
+	}
+
+	l2cap_chan_lock(chan);
 
-	BT_DBG("sk %p, len %d, mode %d", sk, skb->len, pi->mode);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	if (sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_CONNECTED)
 		goto drop;
 
-	switch (pi->mode) {
+	switch (chan->mode) {
 	case L2CAP_MODE_BASIC:
 		/* If socket recv buffers overflows we drop data here
 		 * which is *bad* because L2CAP has to be reliable.
 		 * But we don't have any other choice. L2CAP doesn't
 		 * provide flow control mechanism. */
 
-		if (pi->imtu < skb->len)
+		if (chan->imtu < skb->len)
 			goto drop;
 
-		if (!sock_queue_rcv_skb(sk, skb))
+		if (!chan->ops->recv(chan->data, skb))
 			goto done;
 		break;
 
 	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		control = &bt_cb(skb)->control;
-		if (pi->extended_control) {
-			__get_extended_control(get_unaligned_le32(skb->data),
-						control);
-			skb_pull(skb, 4);
-		} else {
-			__get_enhanced_control(get_unaligned_le16(skb->data),
-						control);
-			skb_pull(skb, 2);
-		}
+		l2cap_ertm_data_rcv(chan, skb);
+
+		goto done;
 
+	case L2CAP_MODE_STREAMING:
+		control = __get_control(chan, skb->data);
+		skb_pull(skb, __ctrl_size(chan));
 		len = skb->len;
 
-		if (l2cap_check_fcs(pi, skb))
+		if (l2cap_check_fcs(chan, skb))
 			goto drop;
 
-		if ((control->frame_type == 'i') &&
-			(control->sar == L2CAP_SAR_START))
-			len -= 2;
-
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			len -= 2;
-
-		/*
-		 * We can just drop the corrupted I-frame here.
-		 * Receiver will miss it and start proper recovery
-		 * procedures and ask for retransmission.
-		 */
-		if (len > pi->mps) {
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			goto drop;
-		}
+		if (__is_sar_start(chan, control))
+			len -= L2CAP_SDULEN_SIZE;
 
-		if (control->frame_type == 'i') {
+		if (chan->fcs == L2CAP_FCS_CRC16)
+			len -= L2CAP_FCS_SIZE;
 
-			int err;
+		if (len > chan->mps || len < 0 || __is_sframe(chan, control))
+			goto drop;
 
-			BT_DBG("iframe sar %d, reqseq %d, final %d, txseq %d",
-				control->sar, control->reqseq, control->final,
-				control->txseq);
-
-			/* Validate F-bit - F=0 always valid, F=1 only
-			 * valid in TX WAIT_F
-			 */
-			if (control->final && (pi->tx_state !=
-					L2CAP_ERTM_TX_STATE_WAIT_F))
-				goto drop;
+		tx_seq = __get_txseq(chan, control);
 
-			if (pi->mode != L2CAP_MODE_STREAMING) {
-				event = L2CAP_ERTM_EVENT_RECV_IFRAME;
-				err = l2cap_ertm_rx(sk, control, skb, event);
-			} else
-				err = l2cap_strm_rx(sk, control, skb);
-			if (err)
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-		} else {
-			/* Only I-frames are expected in streaming mode */
-			if (pi->mode == L2CAP_MODE_STREAMING)
-				goto drop;
+		if (chan->expected_tx_seq != tx_seq) {
+			/* Frame(s) missing - must discard partial SDU */
+			kfree_skb(chan->sdu);
+			chan->sdu = NULL;
+			chan->sdu_last_frag = NULL;
+			chan->sdu_len = 0;
 
-			BT_DBG("sframe reqseq %d, final %d, poll %d, super %d",
-				control->reqseq, control->final, control->poll,
-				control->super);
-
-			if (len != 0) {
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-				goto drop;
-			}
+			/* TODO: Notify userland of missing data */
+		}
 
-			/* Validate F and P bits */
-			if (control->final &&
-				((pi->tx_state != L2CAP_ERTM_TX_STATE_WAIT_F)
-					|| control->poll))
-				goto drop;
+		chan->expected_tx_seq = __next_seq(chan, tx_seq);
 
-			event = l2cap_ertm_rx_func_to_event[control->super];
-			if (l2cap_ertm_rx(sk, control, skb, event))
-				l2cap_send_disconn_req(pi->conn, sk,
-						ECONNRESET);
-		}
+		if (l2cap_reassemble_sdu(chan, skb, control) == -EMSGSIZE)
+			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
 
 		goto done;
 
 	default:
-		BT_DBG("sk %p: bad mode 0x%2.2x", sk, pi->mode);
+		BT_DBG("chan %p: bad mode 0x%2.2x", chan, chan->mode);
 		break;
 	}
 
@@ -7239,158 +4373,64 @@
 	kfree_skb(skb);
 
 done:
-	return 0;
-}
+	l2cap_chan_unlock(chan);
 
-void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb)
-{
-	lock_sock(sk);
-	l2cap_data_channel(sk, skb);
-	release_sock(sk);
+	return 0;
 }
 
 static inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)
 {
-	struct sock *sk;
+	struct l2cap_chan *chan;
 
-	sk = l2cap_get_sock_by_psm(0, psm, conn->src);
-	if (!sk)
+	chan = l2cap_global_chan_by_psm(0, psm, conn->src);
+	if (!chan)
 		goto drop;
 
-	bh_lock_sock(sk);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	BT_DBG("sk %p, len %d", sk, skb->len);
-
-	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
+	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
 		goto drop;
 
-	if (l2cap_pi(sk)->imtu < skb->len)
+	if (chan->imtu < skb->len)
 		goto drop;
 
-	if (!sock_queue_rcv_skb(sk, skb))
-		goto done;
+	if (!chan->ops->recv(chan->data, skb))
+		return 0;
 
 drop:
 	kfree_skb(skb);
 
-done:
-	if (sk)
-		bh_unlock_sock(sk);
 	return 0;
 }
 
-static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid,
-							struct sk_buff *skb)
+static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid, struct sk_buff *skb)
 {
-	struct sock *sk = NULL;
-	struct sk_buff *skb_rsp;
-	struct l2cap_hdr *lh;
-	int dir;
-	struct work_struct *open_worker;
-	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
-						L2CAP_ATT_NOT_SUPPORTED};
-
-	if (skb->data[0] == L2CAP_ATT_MTU_REQ) {
-		u8 mtu_rsp[] = {L2CAP_ATT_MTU_RSP, 23, 0};
-
-		skb_rsp = bt_skb_alloc(sizeof(mtu_rsp) + L2CAP_HDR_SIZE,
-								GFP_ATOMIC);
-		if (!skb_rsp)
-			goto drop;
-
-		lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-		lh->len = cpu_to_le16(sizeof(mtu_rsp));
-		lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-		memcpy(skb_put(skb_rsp, sizeof(mtu_rsp)), mtu_rsp,
-							sizeof(mtu_rsp));
-		hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-
-		goto free_skb;
-	}
+	struct l2cap_chan *chan;
 
-	dir = (skb->data[0] & L2CAP_ATT_RESPONSE_BIT) ? 0 : 1;
-
-	sk = l2cap_find_sock_by_fixed_cid_and_dir(cid, conn->src,
-							conn->dst, dir);
-
-	BT_DBG("sk %p, dir:%d", sk, dir);
-
-	if (!sk)
+	chan = l2cap_global_chan_by_scid(0, cid, conn->src);
+	if (!chan)
 		goto drop;
 
-	bh_lock_sock(sk);
-
-	BT_DBG("sk %p, len %d", sk, skb->len);
+	BT_DBG("chan %p, len %d", chan, skb->len);
 
-	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED) {
-		att_chn_params.cid = cid;
-		att_chn_params.conn = conn;
-		att_chn_params.dir = dir;
-		att_chn_params.skb = skb;
-		open_worker = kzalloc(sizeof(*open_worker), GFP_ATOMIC);
-		if (!open_worker)
-			BT_ERR("Out of memory");
-		INIT_WORK(open_worker, l2cap_queue_acl_data);
-		schedule_work(open_worker);
-		goto done;
-	}
+	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
+		goto drop;
 
-	if (l2cap_pi(sk)->imtu < skb->len)
+	if (chan->imtu < skb->len)
 		goto drop;
 
-	if (!sock_queue_rcv_skb(sk, skb))
-		goto done;
+	if (!chan->ops->recv(chan->data, skb))
+		return 0;
 
 drop:
-	if (skb->data[0] != L2CAP_ATT_INDICATE)
-		goto not_indicate;
-
-	/* If this is an incoming Indication, we are required to confirm */
-
-	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(u8));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[0] = L2CAP_ATT_CONFIRM;
-	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
-	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-	goto free_skb;
-
-not_indicate:
-	if (skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
-			skb->data[0] == L2CAP_ATT_CONFIRM)
-		goto free_skb;
-
-	/* If this is an incoming PDU that requires a response, respond with
-	 * a generic error so remote device doesn't hang */
-
-	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(err_rsp));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[1] = skb->data[0];
-	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
-	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
-
-free_skb:
 	kfree_skb(skb);
 
-done:
-	if (sk)
-		bh_unlock_sock(sk);
 	return 0;
 }
 
 static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 {
 	struct l2cap_hdr *lh = (void *) skb->data;
-	struct sock *sk;
 	u16 cid, len;
 	__le16 psm;
 
@@ -7423,246 +4463,204 @@
 
 	case L2CAP_CID_SMP:
 		if (smp_sig_channel(conn, skb))
-			l2cap_conn_del(conn->hcon, EACCES, 0);
+			l2cap_conn_del(conn->hcon, EACCES);
 		break;
 
 	default:
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);
-		if (sk) {
-			if (sock_owned_by_user(sk)) {
-				BT_DBG("backlog sk %p", sk);
-				if (sk_add_backlog(sk, skb))
-					kfree_skb(skb);
-			} else
-				l2cap_data_channel(sk, skb);
-
-			bh_unlock_sock(sk);
-		} else if ((cid == L2CAP_CID_A2MP) && enable_hs) {
-			BT_DBG("A2MP");
-			amp_conn_ind(conn->hcon, skb);
-		} else {
-			BT_DBG("unknown cid 0x%4.4x", cid);
-			kfree_skb(skb);
-		}
-
+		l2cap_data_channel(conn, cid, skb);
 		break;
 	}
 }
 
 /* ---- L2CAP interface with lower layer (HCI) ---- */
 
-static int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
+int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	int exact = 0, lm1 = 0, lm2 = 0;
-	register struct sock *sk;
-	struct hlist_node *node;
-
-	if (type != ACL_LINK)
-		return 0;
+	struct l2cap_chan *c;
 
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets and check their link_mode */
-	read_lock(&l2cap_sk_list.lock);
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (sk->sk_state != BT_LISTEN)
+	read_lock(&chan_list_lock);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
+
+		if (c->state != BT_LISTEN)
 			continue;
 
 		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {
 			lm1 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
+			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
 				lm1 |= HCI_LM_MASTER;
 			exact++;
 		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
 			lm2 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
+			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
 				lm2 |= HCI_LM_MASTER;
 		}
 	}
-	read_unlock(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
 	return exact ? lm1 : lm2;
 }
 
-static int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
+int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn;
 
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
 
-	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
-		return -EINVAL;
-
 	if (!status) {
 		conn = l2cap_conn_add(hcon, status);
 		if (conn)
 			l2cap_conn_ready(conn);
 	} else
-		l2cap_conn_del(hcon, bt_err(status), 0);
+		l2cap_conn_del(hcon, bt_to_errno(status));
 
 	return 0;
 }
 
-static int l2cap_disconn_ind(struct hci_conn *hcon)
+int l2cap_disconn_ind(struct hci_conn *hcon)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
 	BT_DBG("hcon %p", hcon);
 
-	if (hcon->type != ACL_LINK || !conn)
-		return 0x13;
-
+	if (!conn)
+		return HCI_ERROR_REMOTE_USER_TERM;
 	return conn->disc_reason;
 }
 
-static int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason, u8 is_process)
+int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
-		return -EINVAL;
-
-	l2cap_conn_del(hcon, bt_err(reason), is_process);
-
+	l2cap_conn_del(hcon, bt_to_errno(reason));
 	return 0;
 }
 
-static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)
+static inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)
 {
-	if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)
+	if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)
 		return;
 
 	if (encrypt == 0x00) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ * 5);
-		} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
-			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
-			__l2cap_sock_close(sk, ECONNREFUSED);
+		if (chan->sec_level == BT_SECURITY_MEDIUM) {
+			__clear_chan_timer(chan);
+			__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);
+		} else if (chan->sec_level == BT_SECURITY_HIGH)
+			l2cap_chan_close(chan, ECONNREFUSED);
 	} else {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)
-			l2cap_sock_clear_timer(sk);
+		if (chan->sec_level == BT_SECURITY_MEDIUM)
+			__clear_chan_timer(chan);
 	}
 }
 
-static int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
+int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
 {
-	struct l2cap_chan_list *l;
 	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-	int smp = 0;
+	struct l2cap_chan *chan;
 
 	if (!conn)
 		return 0;
 
-	l = &conn->chan_list;
-
 	BT_DBG("conn %p", conn);
 
-	read_lock(&l->lock);
+	if (hcon->type == LE_LINK) {
+		smp_distribute_keys(conn, 0);
+		cancel_delayed_work(&conn->security_timer);
+	}
+
+	mutex_lock(&conn->chan_lock);
 
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
+	list_for_each_entry(chan, &conn->chan_l, list) {
+		l2cap_chan_lock(chan);
 
-		BT_DBG("sk->scid %d", l2cap_pi(sk)->scid);
+		BT_DBG("chan->scid %d", chan->scid);
 
-		if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
+		if (chan->scid == L2CAP_CID_LE_DATA) {
 			if (!status && encrypt) {
-				l2cap_pi(sk)->sec_level = hcon->sec_level;
-				l2cap_chan_ready(sk);
+				chan->sec_level = hcon->sec_level;
+				l2cap_chan_ready(chan);
 			}
 
-			smp = 1;
-			bh_unlock_sock(sk);
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {
-			bh_unlock_sock(sk);
+		if (test_bit(CONF_CONNECT_PEND, &chan->conf_state)) {
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (!status && (sk->sk_state == BT_CONNECTED ||
-						sk->sk_state == BT_CONFIG)) {
-			l2cap_check_encryption(sk, encrypt);
-			bh_unlock_sock(sk);
+		if (!status && (chan->state == BT_CONNECTED ||
+						chan->state == BT_CONFIG)) {
+			struct sock *sk = chan->sk;
+
+			bt_sk(sk)->suspended = false;
+			sk->sk_state_change(sk);
+
+			l2cap_check_encryption(chan, encrypt);
+			l2cap_chan_unlock(chan);
 			continue;
 		}
 
-		if (sk->sk_state == BT_CONNECT) {
+		if (chan->state == BT_CONNECT) {
 			if (!status) {
-				l2cap_pi(sk)->conf_state |=
-						L2CAP_CONF_CONNECT_PEND;
-				if ((l2cap_pi(sk)->amp_pref ==
-						BT_AMP_POLICY_PREFER_AMP) &&
-						enable_hs) {
-					amp_create_physical(l2cap_pi(sk)->conn,
-								sk);
-				} else
-					l2cap_send_conn_req(sk);
+				l2cap_send_conn_req(chan);
 			} else {
-				l2cap_sock_clear_timer(sk);
-				l2cap_sock_set_timer(sk, HZ / 10);
+				__clear_chan_timer(chan);
+				__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);
 			}
-		} else if (sk->sk_state == BT_CONNECT2) {
+		} else if (chan->state == BT_CONNECT2) {
+			struct sock *sk = chan->sk;
 			struct l2cap_conn_rsp rsp;
-			__u16 result;
+			__u16 res, stat;
+
+			lock_sock(sk);
 
 			if (!status) {
-				if (l2cap_pi(sk)->amp_id) {
-					amp_accept_physical(conn,
-						l2cap_pi(sk)->amp_id, sk);
-					bh_unlock_sock(sk);
-					continue;
+				if (bt_sk(sk)->defer_setup) {
+					struct sock *parent = bt_sk(sk)->parent;
+					res = L2CAP_CR_PEND;
+					stat = L2CAP_CS_AUTHOR_PEND;
+					if (parent)
+						parent->sk_data_ready(parent, 0);
+				} else {
+					__l2cap_state_change(chan, BT_CONFIG);
+					res = L2CAP_CR_SUCCESS;
+					stat = L2CAP_CS_NO_INFO;
 				}
-
-				sk->sk_state = BT_CONFIG;
-				result = L2CAP_CR_SUCCESS;
 			} else {
-				sk->sk_state = BT_DISCONN;
-				l2cap_sock_set_timer(sk, HZ / 10);
-				result = L2CAP_CR_SEC_BLOCK;
+				__l2cap_state_change(chan, BT_DISCONN);
+				__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);
+				res = L2CAP_CR_SEC_BLOCK;
+				stat = L2CAP_CS_NO_INFO;
 			}
 
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-			if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
-				result == L2CAP_CR_SUCCESS) {
-				char buf[128];
-				l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-				l2cap_send_cmd(conn, l2cap_get_ident(conn),
-					       L2CAP_CONF_REQ,
-					       l2cap_build_conf_req(sk, buf),
-					       buf);
-				l2cap_pi(sk)->num_conf_req++;
-			}
+			release_sock(sk);
+
+			rsp.scid   = cpu_to_le16(chan->dcid);
+			rsp.dcid   = cpu_to_le16(chan->scid);
+			rsp.result = cpu_to_le16(res);
+			rsp.status = cpu_to_le16(stat);
+			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
+							sizeof(rsp), &rsp);
 		}
 
-		bh_unlock_sock(sk);
+		l2cap_chan_unlock(chan);
 	}
 
-	read_unlock(&l->lock);
-
-	if (smp) {
-		del_timer(&hcon->smp_timer);
-		smp_link_encrypt_cmplt(conn, status, encrypt);
-	}
+	mutex_unlock(&conn->chan_lock);
 
 	return 0;
 }
 
-static int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
+int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
-	if (!conn && hcon->hdev->dev_type != HCI_BREDR)
-		goto drop;
-
 	if (!conn)
 		conn = l2cap_conn_add(hcon, 0);
 
@@ -7671,8 +4669,10 @@
 
 	BT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);
 
-	if (flags & ACL_START) {
+	if (!(flags & ACL_CONT)) {
 		struct l2cap_hdr *hdr;
+		struct l2cap_chan *chan;
+		u16 cid;
 		int len;
 
 		if (conn->rx_len) {
@@ -7692,6 +4692,7 @@
 
 		hdr = (struct l2cap_hdr *) skb->data;
 		len = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;
+		cid = __le16_to_cpu(hdr->cid);
 
 		if (len == skb->len) {
 			/* Complete frame received */
@@ -7699,14 +4700,6 @@
 			return 0;
 		}
 
-		if (flags & ACL_CONT) {
-			BT_ERR("Complete frame is incomplete "
-				"(len %d, expected len %d)",
-				skb->len, len);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
 		BT_DBG("Start: total len %d, frag len %d", len, skb->len);
 
 		if (skb->len > len) {
@@ -7716,6 +4709,23 @@
 			goto drop;
 		}
 
+		chan = l2cap_get_chan_by_scid(conn, cid);
+
+		if (chan && chan->sk) {
+			struct sock *sk = chan->sk;
+			lock_sock(sk);
+
+			if (chan->imtu < len - L2CAP_HDR_SIZE) {
+				BT_ERR("Frame exceeding recv MTU (len %d, "
+							"MTU %d)", len,
+							chan->imtu);
+				release_sock(sk);
+				l2cap_conn_unreliable(conn, ECOMM);
+				goto drop;
+			}
+			release_sock(sk);
+		}
+
 		/* Allocate skb for the complete frame (with header) */
 		conn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);
 		if (!conn->rx_skb)
@@ -7759,131 +4769,28 @@
 	return 0;
 }
 
-static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to)
-{
-	struct hci_cp_write_automatic_flush_timeout flush_tm;
-	if (hcon && hcon->hdev) {
-		flush_tm.handle = hcon->handle;
-		if (flush_to == L2CAP_DEFAULT_FLUSH_TO)
-			flush_to = 0;
-		flush_tm.timeout = (flush_to < L2CAP_MAX_FLUSH_TO) ?
-				flush_to : L2CAP_MAX_FLUSH_TO;
-		hci_send_cmd(hcon->hdev,
-			HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT,
-			4, &(flush_tm));
-	}
-}
-
-static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l)
-{
-	int ret_flush_to = L2CAP_DEFAULT_FLUSH_TO;
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->flush_to > 0 &&
-				l2cap_pi(s)->flush_to < ret_flush_to)
-			ret_flush_to = l2cap_pi(s)->flush_to;
-	}
-	return ret_flush_to;
-}
-
 static int l2cap_debugfs_show(struct seq_file *f, void *p)
 {
-	struct sock *sk;
-	struct hlist_node *node;
+	struct l2cap_chan *c;
 
-	read_lock_bh(&l2cap_sk_list.lock);
+	read_lock(&chan_list_lock);
 
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		struct l2cap_pinfo *pi = l2cap_pi(sk);
+	list_for_each_entry(c, &chan_list, global_l) {
+		struct sock *sk = c->sk;
 
 		seq_printf(f, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d %d\n",
 					batostr(&bt_sk(sk)->src),
 					batostr(&bt_sk(sk)->dst),
-					sk->sk_state, __le16_to_cpu(pi->psm),
-					pi->scid, pi->dcid,
-					pi->imtu, pi->omtu, pi->sec_level,
-					pi->mode);
+					c->state, __le16_to_cpu(c->psm),
+					c->scid, c->dcid, c->imtu, c->omtu,
+					c->sec_level, c->mode);
 	}
 
-	read_unlock_bh(&l2cap_sk_list.lock);
+	read_unlock(&chan_list_lock);
 
 	return 0;
 }
 
-static void l2cap_queue_acl_data(struct work_struct *worker)
-{
-	struct sock *sk = NULL;
-	int attempts = 0;
-	struct sk_buff *skb_rsp;
-	struct l2cap_hdr *lh;
-	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
-						L2CAP_ATT_NOT_SUPPORTED};
-
-	for (attempts = 0; attempts < 40; attempts++) {
-		msleep(50);
-		if (!att_chn_params.conn) {
-			BT_DBG("att_chn_params.conn is NULL");
-			return;
-		}
-		sk = l2cap_find_sock_by_fixed_cid_and_dir
-				(att_chn_params.cid,
-				att_chn_params.conn->src,
-				att_chn_params.conn->dst,
-				att_chn_params.dir);
-		bh_lock_sock(sk);
-		if (sk->sk_state == BT_CONNECTED) {
-			sock_queue_rcv_skb(sk, att_chn_params.skb);
-			if (sk)
-				bh_unlock_sock(sk);
-			return;
-		}
-		bh_unlock_sock(sk);
-	}
-	bh_lock_sock(sk);
-
-	if (att_chn_params.skb->data[0] != L2CAP_ATT_INDICATE)
-		goto not_indicate;
-
-	/* If this is an incoming Indication, we are required to confirm */
-	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(u8));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[0] = L2CAP_ATT_CONFIRM;
-	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
-	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
-	goto free_skb;
-
-not_indicate:
-	if (att_chn_params.skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
-			att_chn_params.skb->data[0] == L2CAP_ATT_CONFIRM)
-		goto free_skb;
-
-	/* If this is an incoming PDU that requires a response, respond with
-	 * a generic error so remote device doesn't hang */
-
-	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
-	if (!skb_rsp)
-		goto free_skb;
-
-	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(sizeof(err_rsp));
-	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
-	err_rsp[1] = att_chn_params.skb->data[0];
-	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
-	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
-
-free_skb:
-	kfree_skb(att_chn_params.skb);
-
-	if (sk)
-		bh_unlock_sock(sk);
-
-}
-
 static int l2cap_debugfs_open(struct inode *inode, struct file *file)
 {
 	return single_open(file, l2cap_debugfs_show, inode->i_private);
@@ -7898,20 +4805,6 @@
 
 static struct dentry *l2cap_debugfs;
 
-static struct hci_proto l2cap_hci_proto = {
-	.name		= "L2CAP",
-	.id		= HCI_PROTO_L2CAP,
-	.connect_ind	= l2cap_connect_ind,
-	.connect_cfm	= l2cap_connect_cfm,
-	.disconn_ind	= l2cap_disconn_ind,
-	.disconn_cfm	= l2cap_disconn_cfm,
-	.security_cfm	= l2cap_security_cfm,
-	.recv_acldata	= l2cap_recv_acldata,
-	.create_cfm	= l2cap_create_cfm,
-	.modify_cfm	= l2cap_modify_cfm,
-	.destroy_cfm	= l2cap_destroy_cfm,
-};
-
 int __init l2cap_init(void)
 {
 	int err;
@@ -7920,19 +4813,6 @@
 	if (err < 0)
 		return err;
 
-	_l2cap_wq = create_singlethread_workqueue("l2cap");
-	if (!_l2cap_wq) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	err = hci_register_proto(&l2cap_hci_proto);
-	if (err < 0) {
-		BT_ERR("L2CAP protocol registration failed");
-		bt_sock_unregister(BTPROTO_L2CAP);
-		goto error;
-	}
-
 	if (bt_debugfs) {
 		l2cap_debugfs = debugfs_create_file("l2cap", 0444,
 					bt_debugfs, NULL, &l2cap_debugfs_fops);
@@ -7940,39 +4820,14 @@
 			BT_ERR("Failed to create L2CAP debug file");
 	}
 
-	if (amp_init() < 0) {
-		BT_ERR("AMP Manager initialization failed");
-		goto error;
-	}
-
 	return 0;
-
-error:
-	destroy_workqueue(_l2cap_wq);
-	l2cap_cleanup_sockets();
-	return err;
 }
 
 void l2cap_exit(void)
 {
-	amp_exit();
-
 	debugfs_remove(l2cap_debugfs);
-
-	flush_workqueue(_l2cap_wq);
-	destroy_workqueue(_l2cap_wq);
-
-	if (hci_unregister_proto(&l2cap_hci_proto) < 0)
-		BT_ERR("L2CAP protocol unregistration failed");
-
 	l2cap_cleanup_sockets();
 }
 
 module_param(disable_ertm, bool, 0644);
 MODULE_PARM_DESC(disable_ertm, "Disable enhanced retransmission mode");
-
-module_param(enable_hs, bool, 0644);
-MODULE_PARM_DESC(enable_hs, "Enable A2MP protocol");
-
-module_param(enable_reconfig, bool, 0644);
-MODULE_PARM_DESC(enable_reconfig, "Enable reconfig after initiating AMP move");
diff -urN flo-ElementalX-5.00/net/bluetooth/l2cap_sock.c flo-ElementalX-5.00-patched/net/bluetooth/l2cap_sock.c
--- flo-ElementalX-5.00/net/bluetooth/l2cap_sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/l2cap_sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,8 +1,9 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2011-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2000-2001 Qualcomm Incorporated
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
+   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -26,107 +27,22 @@
 
 /* Bluetooth L2CAP sockets. */
 
-#include <linux/interrupt.h>
-#include <linux/module.h>
+#include <linux/security.h>
+#include <linux/export.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
-#include <net/bluetooth/amp.h>
 
-/* ---- L2CAP timers ---- */
-static void l2cap_sock_timeout(unsigned long arg)
-{
-	struct sock *sk = (struct sock *) arg;
-	int reason;
-
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-
-	bh_lock_sock(sk);
-
-	if (sock_owned_by_user(sk)) {
-		/* sk is owned by user. Try again later */
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		sock_put(sk);
-		return;
-	}
-
-	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
-		reason = ECONNREFUSED;
-	else if (sk->sk_state == BT_CONNECT &&
-				l2cap_pi(sk)->sec_level != BT_SECURITY_SDP)
-		reason = ECONNREFUSED;
-	else
-		reason = ETIMEDOUT;
-
-	__l2cap_sock_close(sk, reason);
-
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	sock_put(sk);
-}
-
-void l2cap_sock_set_timer(struct sock *sk, long timeout)
-{
-	BT_DBG("sk %p state %d timeout %ld", sk, sk->sk_state, timeout);
-	sk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);
-}
-
-void l2cap_sock_clear_timer(struct sock *sk)
-{
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-	sk_stop_timer(sk, &sk->sk_timer);
-}
-
-int l2cap_sock_le_params_valid(struct bt_le_params *le_params)
-{
-	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
-			le_params->scan_window > BT_LE_SCAN_WINDOW_MAX ||
-			le_params->scan_interval < BT_LE_SCAN_INTERVAL_MIN ||
-			le_params->scan_window > le_params->scan_interval ||
-			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
-			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
-			le_params->interval_min > le_params->interval_max ||
-			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
-			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
-		return 0;
-	}
-
-	return 1;
-}
-
-int l2cap_sock_le_conn_update_params_valid(struct bt_le_params *le_params)
-{
-	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
-			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
-			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
-			le_params->interval_min > le_params->interval_max ||
-			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
-			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
-		return 0;
-	}
-
-	return 1;
-}
-
-static struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)
-{
-	struct sock *sk;
-	struct hlist_node *node;
-	sk_for_each(sk, node, &l2cap_sk_list.head)
-		if (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))
-			goto found;
-	sk = NULL;
-found:
-	return sk;
-}
+static const struct proto_ops l2cap_sock_ops;
+static void l2cap_sock_init(struct sock *sk, struct sock *parent);
+static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio);
 
 static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
@@ -165,26 +81,22 @@
 		}
 	}
 
-	write_lock_bh(&l2cap_sk_list.lock);
+	if (la.l2_cid)
+		err = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));
+	else
+		err = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);
 
-	if (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {
-		err = -EADDRINUSE;
-	} else {
-		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
-		l2cap_pi(sk)->psm   = la.l2_psm;
-		l2cap_pi(sk)->sport = la.l2_psm;
-		sk->sk_state = BT_BOUND;
-
-		if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
-					__le16_to_cpu(la.l2_psm) == 0x0003)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
-	}
+	if (err < 0)
+		goto done;
 
-	if (la.l2_cid)
-		l2cap_pi(sk)->scid = la.l2_cid;
+	if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
+				__le16_to_cpu(la.l2_psm) == 0x0003)
+		chan->sec_level = BT_SECURITY_SDP;
 
-	write_unlock_bh(&l2cap_sk_list.lock);
+	bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
+
+	chan->state = BT_BOUND;
+	sk->sk_state = BT_BOUND;
 
 done:
 	release_sock(sk);
@@ -194,14 +106,14 @@
 static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
-	BT_DBG("sk %p type %d mode %d state %d", sk, sk->sk_type,
-		l2cap_pi(sk)->mode, sk->sk_state);
+	BT_DBG("sk %p", sk);
 
 	if (!addr || alen < sizeof(addr->sa_family) ||
-		addr->sa_family != AF_BLUETOOTH)
+	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
 	memset(&la, 0, sizeof(la));
@@ -211,80 +123,25 @@
 	if (la.l2_cid && la.l2_psm)
 		return -EINVAL;
 
-	lock_sock(sk);
-
-	if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)
-		&& !(la.l2_psm || la.l2_cid || l2cap_pi(sk)->fixed_channel)) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	switch (l2cap_pi(sk)->mode) {
-	case L2CAP_MODE_BASIC:
-		break;
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		if (!disable_ertm)
-			break;
-		/* fall through */
-	default:
-		err = -ENOTSUPP;
-		goto done;
-	}
-
-	switch (sk->sk_state) {
-	case BT_CONNECT:
-	case BT_CONNECT2:
-	case BT_CONFIG:
-		/* Already connecting */
-		goto wait;
-
-	case BT_CONNECTED:
-		/* Already connected */
-		err = -EISCONN;
-		goto done;
-
-	case BT_OPEN:
-	case BT_BOUND:
-		/* Can connect */
-		break;
-
-	default:
-		err = -EBADFD;
-		goto done;
-	}
-
-	/* PSM must be odd and lsb of upper byte must be 0 */
-	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 &&
-		!l2cap_pi(sk)->fixed_channel &&
-				sk->sk_type != SOCK_RAW && !la.l2_cid) {
-		BT_DBG("Bad PSM 0x%x", (int)__le16_to_cpu(la.l2_psm));
-		err = -EINVAL;
-		goto done;
-	}
-
-	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);
-	l2cap_pi(sk)->psm = la.l2_psm;
-	l2cap_pi(sk)->dcid = la.l2_cid;
-
-	err = l2cap_do_connect(sk);
+	err = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),
+				&la.l2_bdaddr);
 	if (err)
-		goto done;
+		return err;
+
+	lock_sock(sk);
 
-wait:
 	err = bt_sock_wait_state(sk, BT_CONNECTED,
 			sock_sndtimeo(sk, flags & O_NONBLOCK));
-done:
-	if (err)
-		BT_ERR("failed %d", err);
+
 	release_sock(sk);
+
 	return err;
 }
 
 static int l2cap_sock_listen(struct socket *sock, int backlog)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err = 0;
 
 	BT_DBG("sk %p backlog %d", sk, backlog);
@@ -297,7 +154,7 @@
 		goto done;
 	}
 
-	switch (l2cap_pi(sk)->mode) {
+	switch (chan->mode) {
 	case L2CAP_MODE_BASIC:
 		break;
 	case L2CAP_MODE_ERTM:
@@ -310,30 +167,10 @@
 		goto done;
 	}
 
-	if (!l2cap_pi(sk)->psm && !l2cap_pi(sk)->scid) {
-		bdaddr_t *src = &bt_sk(sk)->src;
-		u16 psm;
-
-		err = -EINVAL;
-
-		write_lock_bh(&l2cap_sk_list.lock);
-
-		for (psm = 0x1001; psm < 0x1100; psm += 2)
-			if (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {
-				l2cap_pi(sk)->psm   = cpu_to_le16(psm);
-				l2cap_pi(sk)->sport = cpu_to_le16(psm);
-				err = 0;
-				break;
-			}
-
-		write_unlock_bh(&l2cap_sk_list.lock);
-
-		if (err < 0)
-			goto done;
-	}
-
 	sk->sk_max_ack_backlog = backlog;
 	sk->sk_ack_backlog = 0;
+
+	chan->state = BT_LISTEN;
 	sk->sk_state = BT_LISTEN;
 
 done:
@@ -350,30 +187,26 @@
 
 	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
+		nsk = bt_accept_dequeue(sk, newsock);
+		if (nsk)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -381,8 +214,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -401,20 +238,22 @@
 {
 	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
+	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
 	if (peer) {
-		la->l2_psm = l2cap_pi(sk)->psm;
+		la->l2_psm = chan->psm;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+		la->l2_cid = cpu_to_le16(chan->dcid);
 	} else {
-		la->l2_psm = l2cap_pi(sk)->sport;
+		la->l2_psm = chan->sport;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);
+		la->l2_cid = cpu_to_le16(chan->scid);
 	}
 
 	return 0;
@@ -423,6 +262,7 @@
 static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
 	struct l2cap_conninfo cinfo;
 	int len, err = 0;
@@ -438,13 +278,13 @@
 	switch (optname) {
 	case L2CAP_OPTIONS:
 		memset(&opts, 0, sizeof(opts));
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = l2cap_pi(sk)->tx_win;
+		opts.imtu     = chan->imtu;
+		opts.omtu     = chan->omtu;
+		opts.flush_to = chan->flush_to;
+		opts.mode     = chan->mode;
+		opts.fcs      = chan->fcs;
+		opts.max_tx   = chan->max_tx;
+		opts.txwin_size = chan->tx_win;
 
 		len = min_t(unsigned int, len, sizeof(opts));
 		if (copy_to_user(optval, (char *) &opts, len))
@@ -453,7 +293,7 @@
 		break;
 
 	case L2CAP_LM:
-		switch (l2cap_pi(sk)->sec_level) {
+		switch (chan->sec_level) {
 		case BT_SECURITY_LOW:
 			opt = L2CAP_LM_AUTH;
 			break;
@@ -469,15 +309,12 @@
 			break;
 		}
 
-		if (l2cap_pi(sk)->role_switch)
+		if (test_bit(FLAG_ROLE_SWITCH, &chan->flags))
 			opt |= L2CAP_LM_MASTER;
 
-		if (l2cap_pi(sk)->force_reliable)
+		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
 			opt |= L2CAP_LM_RELIABLE;
 
-		if (l2cap_pi(sk)->flushable)
-			opt |= L2CAP_LM_FLUSHABLE;
-
 		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
@@ -490,8 +327,9 @@
 			break;
 		}
 
-		cinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;
-		memcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);
+		memset(&cinfo, 0, sizeof(cinfo));
+		cinfo.hci_handle = chan->conn->hcon->handle;
+		memcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -511,6 +349,7 @@
 static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
 	int len, err = 0;
@@ -530,19 +369,17 @@
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
 
 		memset(&sec, 0, sizeof(sec));
-		sec.level = l2cap_pi(sk)->sec_level;
+		sec.level = chan->sec_level;
 
-		if (sk->sk_state == BT_CONNECTED) {
-			sec.key_size = l2cap_pi(sk)->conn->hcon->enc_key_size;
-			sec.level = l2cap_pi(sk)->conn->hcon->sec_level;
-		}
+		if (sk->sk_state == BT_CONNECTED)
+			sec.key_size = chan->conn->hcon->enc_key_size;
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))
@@ -561,6 +398,13 @@
 
 		break;
 
+	case BT_FLUSHABLE:
+		if (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),
+						(u32 __user *) optval))
+			err = -EFAULT;
+
+		break;
+
 	case BT_POWER:
 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
 				&& sk->sk_type != SOCK_RAW) {
@@ -568,7 +412,7 @@
 			break;
 		}
 
-		pwr.force_active = l2cap_pi(sk)->force_active;
+		pwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 
 		len = min_t(unsigned int, len, sizeof(pwr));
 		if (copy_to_user(optval, (char *) &pwr, len))
@@ -576,19 +420,13 @@
 
 		break;
 
-	case BT_AMP_POLICY:
-		if (put_user(l2cap_pi(sk)->amp_pref, (u32 __user *) optval))
-			err = -EFAULT;
-		break;
-
-	case BT_LE_PARAMS:
-		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			err = -EINVAL;
+	case BT_CHANNEL_POLICY:
+		if (!enable_hs) {
+			err = -ENOPROTOOPT;
 			break;
 		}
 
-		if (copy_to_user(optval, (char *) &bt_sk(sk)->le_params,
-						sizeof(bt_sk(sk)->le_params)))
+		if (put_user(chan->chan_policy, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
 
@@ -604,30 +442,29 @@
 static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
-	int len, le_sock, err = 0;
+	int len, err = 0;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
 
 	lock_sock(sk);
 
-	le_sock = l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA;
-
 	switch (optname) {
 	case L2CAP_OPTIONS:
-		if (sk->sk_state == BT_CONNECTED && !le_sock) {
+		if (sk->sk_state == BT_CONNECTED) {
 			err = -EINVAL;
 			break;
 		}
 
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = l2cap_pi(sk)->tx_win;
+		opts.imtu     = chan->imtu;
+		opts.omtu     = chan->omtu;
+		opts.flush_to = chan->flush_to;
+		opts.mode     = chan->mode;
+		opts.fcs      = chan->fcs;
+		opts.max_tx   = chan->max_tx;
+		opts.txwin_size = chan->tx_win;
 
 		len = min_t(unsigned int, sizeof(opts), optlen);
 		if (copy_from_user((char *) &opts, optval, len)) {
@@ -635,39 +472,18 @@
 			break;
 		}
 
-		if ((opts.imtu || opts.omtu) && le_sock &&
-				(sk->sk_state == BT_CONNECTED)) {
-			if (opts.imtu >= L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->imtu = opts.imtu;
-			if (opts.omtu >= L2CAP_LE_DEFAULT_MTU)
-				l2cap_pi(sk)->omtu = opts.omtu;
-			if (opts.imtu < L2CAP_LE_DEFAULT_MTU ||
-					opts.omtu < L2CAP_LE_DEFAULT_MTU)
-				err = -EINVAL;
-			break;
-		}
-
-		if (opts.txwin_size < 1 ||
-			opts.txwin_size > L2CAP_TX_WIN_MAX_EXTENDED) {
+		if (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {
 			err = -EINVAL;
 			break;
 		}
 
-		l2cap_pi(sk)->mode = opts.mode;
-		switch (l2cap_pi(sk)->mode) {
+		chan->mode = opts.mode;
+		switch (chan->mode) {
 		case L2CAP_MODE_BASIC:
-			l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;
-			break;
-		case L2CAP_MODE_STREAMING:
-			if (!disable_ertm) {
-				/* No fallback to ERTM or Basic mode */
-				l2cap_pi(sk)->conf_state |=
-						L2CAP_CONF_STATE2_DEVICE;
-				break;
-			}
-			err = -EINVAL;
+			clear_bit(CONF_STATE2_DEVICE, &chan->conf_state);
 			break;
 		case L2CAP_MODE_ERTM:
+		case L2CAP_MODE_STREAMING:
 			if (!disable_ertm)
 				break;
 			/* fall through */
@@ -676,12 +492,11 @@
 			break;
 		}
 
-		l2cap_pi(sk)->imtu = opts.imtu;
-		l2cap_pi(sk)->omtu = opts.omtu;
-		l2cap_pi(sk)->fcs  = opts.fcs;
-		l2cap_pi(sk)->max_tx = opts.max_tx;
-		l2cap_pi(sk)->tx_win = opts.txwin_size;
-		l2cap_pi(sk)->flush_to = opts.flush_to;
+		chan->imtu = opts.imtu;
+		chan->omtu = opts.omtu;
+		chan->fcs  = opts.fcs;
+		chan->max_tx = opts.max_tx;
+		chan->tx_win = opts.txwin_size;
 		break;
 
 	case L2CAP_LM:
@@ -691,15 +506,21 @@
 		}
 
 		if (opt & L2CAP_LM_AUTH)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_LOW;
+			chan->sec_level = BT_SECURITY_LOW;
 		if (opt & L2CAP_LM_ENCRYPT)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
+			chan->sec_level = BT_SECURITY_MEDIUM;
 		if (opt & L2CAP_LM_SECURE)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;
+			chan->sec_level = BT_SECURITY_HIGH;
 
-		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
-		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
-		l2cap_pi(sk)->flushable = (opt & L2CAP_LM_FLUSHABLE);
+		if (opt & L2CAP_LM_MASTER)
+			set_bit(FLAG_ROLE_SWITCH, &chan->flags);
+		else
+			clear_bit(FLAG_ROLE_SWITCH, &chan->flags);
+
+		if (opt & L2CAP_LM_RELIABLE)
+			set_bit(FLAG_FORCE_RELIABLE, &chan->flags);
+		else
+			clear_bit(FLAG_FORCE_RELIABLE, &chan->flags);
 		break;
 
 	default:
@@ -714,9 +535,9 @@
 static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
-	struct bt_le_params le_params;
 	struct l2cap_conn *conn;
 	int len, err = 0;
 	u32 opt;
@@ -733,8 +554,8 @@
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
@@ -753,20 +574,35 @@
 			break;
 		}
 
-		l2cap_pi(sk)->sec_level = sec.level;
+		chan->sec_level = sec.level;
 
-		conn = l2cap_pi(sk)->conn;
-		if (conn && l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
+		if (!chan->conn)
+			break;
+
+		conn = chan->conn;
+
+		/*change security for LE channels */
+		if (chan->scid == L2CAP_CID_LE_DATA) {
 			if (!conn->hcon->out) {
 				err = -EINVAL;
 				break;
 			}
 
-			if (smp_conn_security(conn, sec.level))
+			if (smp_conn_security(conn->hcon, sec.level))
 				break;
-
-			err = 0;
 			sk->sk_state = BT_CONFIG;
+			chan->state = BT_CONFIG;
+
+		/* or for ACL link */
+		} else if ((sk->sk_state == BT_CONNECT2 &&
+			   bt_sk(sk)->defer_setup) ||
+			   sk->sk_state == BT_CONNECTED) {
+			if (!l2cap_chan_check_security(chan))
+				bt_sk(sk)->suspended = true;
+			else
+				sk->sk_state_change(sk);
+		} else {
+			err = -EINVAL;
 		}
 		break;
 
@@ -784,88 +620,77 @@
 		bt_sk(sk)->defer_setup = opt;
 		break;
 
-	case BT_POWER:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
+	case BT_FLUSHABLE:
+		if (get_user(opt, (u32 __user *) optval)) {
+			err = -EFAULT;
 			break;
 		}
 
-		pwr.force_active = 1;
-
-		len = min_t(unsigned int, sizeof(pwr), optlen);
-		if (copy_from_user((char *) &pwr, optval, len)) {
-			err = -EFAULT;
+		if (opt > BT_FLUSHABLE_ON) {
+			err = -EINVAL;
 			break;
 		}
-		l2cap_pi(sk)->force_active = pwr.force_active;
-		break;
 
-	case BT_AMP_POLICY:
-		if (get_user(opt, (u32 __user *) optval)) {
-			err = -EFAULT;
-			break;
+		if (opt == BT_FLUSHABLE_OFF) {
+			struct l2cap_conn *conn = chan->conn;
+			/* proceed further only when we have l2cap_conn and
+			   No Flush support in the LM */
+			if (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {
+				err = -EINVAL;
+				break;
+			}
 		}
 
-		if ((opt > BT_AMP_POLICY_PREFER_AMP) ||
-			((l2cap_pi(sk)->mode != L2CAP_MODE_ERTM) &&
-			 (l2cap_pi(sk)->mode != L2CAP_MODE_STREAMING))) {
+		if (opt)
+			set_bit(FLAG_FLUSHABLE, &chan->flags);
+		else
+			clear_bit(FLAG_FLUSHABLE, &chan->flags);
+		break;
+
+	case BT_POWER:
+		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
+					chan->chan_type != L2CAP_CHAN_RAW) {
 			err = -EINVAL;
 			break;
 		}
 
-		l2cap_pi(sk)->amp_pref = (u8) opt;
-		BT_DBG("BT_AMP_POLICY now %d", opt);
-
-		if ((sk->sk_state == BT_CONNECTED) &&
-			(l2cap_pi(sk)->amp_move_role == L2CAP_AMP_MOVE_NONE))
-			l2cap_amp_move_init(sk);
-
-		break;
+		pwr.force_active = BT_POWER_FORCE_ACTIVE_ON;
 
-	case BT_FLUSHABLE:
-		if (get_user(opt, (u32 __user *) optval)) {
+		len = min_t(unsigned int, sizeof(pwr), optlen);
+		if (copy_from_user((char *) &pwr, optval, len)) {
 			err = -EFAULT;
 			break;
 		}
-		l2cap_pi(sk)->flushable = opt;
 
+		if (pwr.force_active)
+			set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+		else
+			clear_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 		break;
 
-	case BT_LE_PARAMS:
-		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			err = -EINVAL;
+	case BT_CHANNEL_POLICY:
+		if (!enable_hs) {
+			err = -ENOPROTOOPT;
 			break;
 		}
 
-		if (copy_from_user((char *) &le_params, optval,
-					sizeof(struct bt_le_params))) {
+		if (get_user(opt, (u32 __user *) optval)) {
 			err = -EFAULT;
 			break;
 		}
 
-		conn = l2cap_pi(sk)->conn;
-		if (!conn || !conn->hcon ||
-				l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
-			memcpy(&bt_sk(sk)->le_params, &le_params,
-							sizeof(le_params));
+		if (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {
+			err = -EINVAL;
 			break;
 		}
 
-		if (!conn->hcon->out ||
-				!l2cap_sock_le_conn_update_params_valid(
-					&le_params)) {
-			err = -EINVAL;
+		if (chan->mode != L2CAP_MODE_ERTM &&
+				chan->mode != L2CAP_MODE_STREAMING) {
+			err = -EOPNOTSUPP;
 			break;
 		}
 
-		memcpy(&bt_sk(sk)->le_params, &le_params, sizeof(le_params));
-
-		hci_le_conn_update(conn->hcon,
-				le_params.interval_min,
-				le_params.interval_max,
-				le_params.latency,
-				le_params.supervision_timeout);
+		chan->chan_policy = (u8) opt;
 		break;
 
 	default:
@@ -880,11 +705,8 @@
 static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb;
-	struct sk_buff_head seg_queue;
+	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err;
-	u8 amp_id;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
@@ -898,102 +720,12 @@
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_CONNECTED) {
-		err = -ENOTCONN;
-		goto done;
-	}
-
-	/* Connectionless channel */
-	if (sk->sk_type == SOCK_DGRAM) {
-		skb = l2cap_create_connless_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-		} else {
-			l2cap_do_send(sk, skb);
-			err = len;
-		}
-		goto done;
+		release_sock(sk);
+		return -ENOTCONN;
 	}
 
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		/* Check outgoing MTU */
-		if (len > pi->omtu) {
-			err = -EMSGSIZE;
-			goto done;
-		}
+	err = l2cap_chan_send(chan, msg, len, sk->sk_priority);
 
-		/* Create a basic PDU */
-		skb = l2cap_create_basic_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-			goto done;
-		}
-
-		l2cap_do_send(sk, skb);
-		err = len;
-		break;
-
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-
-		/* Check outgoing MTU */
-		if (len > pi->omtu) {
-			err = -EMSGSIZE;
-			goto done;
-		}
-
-		__skb_queue_head_init(&seg_queue);
-
-		/* Do segmentation before calling in to the state machine,
-		 * since it's possible to block while waiting for memory
-		 * allocation.
-		 */
-		amp_id = pi->amp_id;
-		err = l2cap_segment_sdu(sk, &seg_queue, msg, len, 0);
-
-		/* The socket lock is released while segmenting, so check
-		 * that the socket is still connected
-		 */
-		if (sk->sk_state != BT_CONNECTED) {
-			__skb_queue_purge(&seg_queue);
-			err = -ENOTCONN;
-		}
-
-		if (err) {
-			BT_DBG("Error %d, sk_sndbuf %d, sk_wmem_alloc %d",
-				err, sk->sk_sndbuf,
-				atomic_read(&sk->sk_wmem_alloc));
-			break;
-		}
-
-		if (pi->amp_id != amp_id) {
-			/* Channel moved while unlocked. Resegment. */
-			err = l2cap_resegment_queue(sk, &seg_queue);
-
-			if (err)
-				break;
-		}
-
-		if (pi->mode != L2CAP_MODE_STREAMING)
-			err = l2cap_ertm_tx(sk, 0, &seg_queue,
-				L2CAP_ERTM_EVENT_DATA_REQUEST);
-		else
-			err = l2cap_strm_tx(sk, &seg_queue);
-		if (!err)
-			err = len;
-
-		/* If the skbs were not queued for sending, they'll still be in
-		 * seg_queue and need to be purged.
-		 */
-		__skb_queue_purge(&seg_queue);
-		break;
-
-	default:
-		BT_DBG("bad state %1.1x", pi->mode);
-		err = -EBADFD;
-	}
-
-done:
 	release_sock(sk);
 	return err;
 }
@@ -1001,43 +733,16 @@
 static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
 	int err;
 
 	lock_sock(sk);
 
 	if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {
-		struct l2cap_conn_rsp rsp;
-		struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-		u8 buf[128];
-
-		if (l2cap_pi(sk)->amp_id) {
-			/* Physical link must be brought up before connection
-			 * completes.
-			 */
-			amp_accept_physical(conn, l2cap_pi(sk)->amp_id, sk);
-			release_sock(sk);
-			return 0;
-		}
-
 		sk->sk_state = BT_CONFIG;
+		pi->chan->state = BT_CONFIG;
 
-		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-		rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-		rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-		l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) {
-			release_sock(sk);
-			return 0;
-		}
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-				l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-
+		__l2cap_connect_rsp_defer(pi->chan);
 		release_sock(sk);
 		return 0;
 	}
@@ -1049,112 +754,57 @@
 	else
 		err = bt_sock_recvmsg(iocb, sock, msg, len, flags);
 
-	if (err >= 0)
-		l2cap_ertm_recv_done(sk);
+	if (pi->chan->mode != L2CAP_MODE_ERTM)
+		return err;
+
+	/* Attempt to put pending rx data in the socket buffer */
+
+	lock_sock(sk);
+
+	if (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))
+		goto done;
+
+	if (pi->rx_busy_skb) {
+		if (!sock_queue_rcv_skb(sk, pi->rx_busy_skb))
+			pi->rx_busy_skb = NULL;
+		else
+			goto done;
+	}
+
+	/* Restore data flow when half of the receive buffer is
+	 * available.  This avoids resending large numbers of
+	 * frames.
+	 */
+	if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)
+		l2cap_chan_busy(pi->chan, 0);
 
+done:
+	release_sock(sk);
 	return err;
 }
 
 /* Kill socket (only if zapped and orphan)
  * Must be called on unlocked socket.
  */
-void l2cap_sock_kill(struct sock *sk)
+static void l2cap_sock_kill(struct sock *sk)
 {
 	if (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)
 		return;
 
-	BT_DBG("sk %p state %d", sk, sk->sk_state);
+	BT_DBG("sk %p state %s", sk, state_to_string(sk->sk_state));
 
 	/* Kill poor orphan */
-	bt_sock_unlink(&l2cap_sk_list, sk);
+
+	l2cap_chan_destroy(l2cap_pi(sk)->chan);
 	sock_set_flag(sk, SOCK_DEAD);
 	sock_put(sk);
 }
 
-/* Must be called on unlocked socket. */
-static void l2cap_sock_close(struct sock *sk)
-{
-	l2cap_sock_clear_timer(sk);
-	lock_sock(sk);
-	__l2cap_sock_close(sk, ECONNRESET);
-	release_sock(sk);
-	l2cap_sock_kill(sk);
-}
-
-static void l2cap_sock_cleanup_listen(struct sock *parent)
-{
-	struct sock *sk;
-
-	BT_DBG("parent %p", parent);
-
-	/* Close not yet accepted channels */
-	while ((sk = bt_accept_dequeue(parent, NULL)))
-		l2cap_sock_close(sk);
-
-	parent->sk_state = BT_CLOSED;
-	sock_set_flag(parent, SOCK_ZAPPED);
-}
-
-void __l2cap_sock_close(struct sock *sk, int reason)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-
-	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
-
-	switch (sk->sk_state) {
-	case BT_LISTEN:
-		l2cap_sock_cleanup_listen(sk);
-		break;
-
-	case BT_CONNECTED:
-	case BT_CONFIG:
-		if ((sk->sk_type == SOCK_SEQPACKET ||
-					sk->sk_type == SOCK_STREAM) &&
-					conn->hcon->type == ACL_LINK) {
-			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-			l2cap_send_disconn_req(conn, sk, reason);
-		} else
-			l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT2:
-		if ((sk->sk_type == SOCK_SEQPACKET ||
-					sk->sk_type == SOCK_STREAM) &&
-					conn->hcon->type == ACL_LINK) {
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
-
-			if (bt_sk(sk)->defer_setup)
-				result = L2CAP_CR_SEC_BLOCK;
-			else
-				result = L2CAP_CR_BAD_PSM;
-			sk->sk_state = BT_DISCONN;
-
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-		}
-
-		l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT:
-	case BT_DISCONN:
-		l2cap_chan_del(sk, reason);
-		break;
-
-	default:
-		sock_set_flag(sk, SOCK_ZAPPED);
-		break;
-	}
-}
-
 static int l2cap_sock_shutdown(struct socket *sock, int how)
 {
 	struct sock *sk = sock->sk;
+	struct l2cap_chan *chan;
+	struct l2cap_conn *conn;
 	int err = 0;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -1162,17 +812,24 @@
 	if (!sk)
 		return 0;
 
+	chan = l2cap_pi(sk)->chan;
+	conn = chan->conn;
+
+	if (conn)
+		mutex_lock(&conn->chan_lock);
+
+	l2cap_chan_lock(chan);
 	lock_sock(sk);
-	if (!sk->sk_shutdown) {
 
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
+	if (!sk->sk_shutdown) {
+		if (chan->mode == L2CAP_MODE_ERTM)
 			err = __l2cap_wait_ack(sk);
-			l2cap_ertm_shutdown(sk);
-		}
 
 		sk->sk_shutdown = SHUTDOWN_MASK;
-		l2cap_sock_clear_timer(sk);
-		__l2cap_sock_close(sk, 0);
+
+		release_sock(sk);
+		l2cap_chan_close(chan, 0);
+		lock_sock(sk);
 
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
@@ -1183,13 +840,17 @@
 		err = -sk->sk_err;
 
 	release_sock(sk);
+	l2cap_chan_unlock(chan);
+
+	if (conn)
+		mutex_unlock(&conn->chan_lock);
+
 	return err;
 }
 
 static int l2cap_sock_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
-	struct sock *sk2 = NULL;
 	int err;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -1197,17 +858,6 @@
 	if (!sk)
 		return 0;
 
-	/* If this is an ATT socket, find it's matching server/client */
-	if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA)
-		sk2 = l2cap_find_sock_by_fixed_cid_and_dir(L2CAP_CID_LE_DATA,
-					&bt_sk(sk)->src, &bt_sk(sk)->dst,
-					l2cap_pi(sk)->incoming ? 0 : 1);
-
-	/* If matching socket found, request tear down */
-	BT_DBG("sock:%p companion:%p", sk, sk2);
-	if (sk2)
-		l2cap_sock_set_timer(sk2, 1);
-
 	err = l2cap_sock_shutdown(sock, 2);
 
 	sock_orphan(sk);
@@ -1215,87 +865,166 @@
 	return err;
 }
 
-static void l2cap_sock_destruct(struct sock *sk)
+static struct l2cap_chan *l2cap_sock_new_connection_cb(void *data)
 {
-	BT_DBG("sk %p", sk);
+	struct sock *sk, *parent = data;
 
-	skb_queue_purge(&sk->sk_receive_queue);
-	skb_queue_purge(&sk->sk_write_queue);
+	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
+								GFP_ATOMIC);
+	if (!sk)
+		return NULL;
+
+	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);
+
+	l2cap_sock_init(sk, parent);
+
+	return l2cap_pi(sk)->chan;
+}
+
+static int l2cap_sock_recv_cb(void *data, struct sk_buff *skb)
+{
+	int err;
+	struct sock *sk = data;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+
+	lock_sock(sk);
+
+	if (pi->rx_busy_skb) {
+		err = -ENOMEM;
+		goto done;
+	}
+
+	err = sock_queue_rcv_skb(sk, skb);
+
+	/* For ERTM, handle one skb that doesn't fit into the recv
+	 * buffer.  This is important to do because the data frames
+	 * have already been acked, so the skb cannot be discarded.
+	 *
+	 * Notify the l2cap core that the buffer is full, so the
+	 * LOCAL_BUSY state is entered and no more frames are
+	 * acked and reassembled until there is buffer space
+	 * available.
+	 */
+	if (err < 0 && pi->chan->mode == L2CAP_MODE_ERTM) {
+		pi->rx_busy_skb = skb;
+		l2cap_chan_busy(pi->chan, 1);
+		err = 0;
+	}
+
+done:
+	release_sock(sk);
+
+	return err;
+}
+
+static void l2cap_sock_close_cb(void *data)
+{
+	struct sock *sk = data;
+
+	l2cap_sock_kill(sk);
+}
+
+static void l2cap_sock_state_change_cb(void *data, int state)
+{
+	struct sock *sk = data;
 
-	l2cap_ertm_destruct(sk);
+	sk->sk_state = state;
 }
 
-static void set_default_config(struct l2cap_conf_prm *conf_prm)
+static struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,
+					       unsigned long len, int nb,
+					       int *err)
+{
+	struct sock *sk = chan->sk;
+
+	return bt_skb_send_alloc(sk, len, nb, err);
+}
+
+static struct l2cap_ops l2cap_chan_ops = {
+	.name		= "L2CAP Socket Interface",
+	.new_connection	= l2cap_sock_new_connection_cb,
+	.recv		= l2cap_sock_recv_cb,
+	.close		= l2cap_sock_close_cb,
+	.state_change	= l2cap_sock_state_change_cb,
+	.alloc_skb	= l2cap_sock_alloc_skb_cb,
+};
+
+static void l2cap_sock_destruct(struct sock *sk)
 {
-	conf_prm->fcs = L2CAP_FCS_CRC16;
-	conf_prm->flush_to = L2CAP_DEFAULT_FLUSH_TO;
+	BT_DBG("sk %p", sk);
+
+	if (l2cap_pi(sk)->rx_busy_skb) {
+		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
+		l2cap_pi(sk)->rx_busy_skb = NULL;
+	}
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	skb_queue_purge(&sk->sk_write_queue);
 }
 
-void l2cap_sock_init(struct sock *sk, struct sock *parent)
+static void l2cap_sock_init(struct sock *sk, struct sock *parent)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_chan *chan = pi->chan;
 
-	BT_DBG("sk %p parent %p", sk, parent);
+	BT_DBG("sk %p", sk);
 
 	if (parent) {
+		struct l2cap_chan *pchan = l2cap_pi(parent)->chan;
+
 		sk->sk_type = parent->sk_type;
-		sk->sk_rcvbuf = parent->sk_rcvbuf;
-		sk->sk_sndbuf = parent->sk_sndbuf;
 		bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;
 
-		pi->imtu = l2cap_pi(parent)->imtu;
-		pi->omtu = l2cap_pi(parent)->omtu;
-		pi->conf_state = l2cap_pi(parent)->conf_state;
-		pi->mode = l2cap_pi(parent)->mode;
-		pi->fcs  = l2cap_pi(parent)->fcs;
-		pi->max_tx = l2cap_pi(parent)->max_tx;
-		pi->tx_win = l2cap_pi(parent)->tx_win;
-		pi->sec_level = l2cap_pi(parent)->sec_level;
-		pi->role_switch = l2cap_pi(parent)->role_switch;
-		pi->force_reliable = l2cap_pi(parent)->force_reliable;
-		pi->flushable = l2cap_pi(parent)->flushable;
-		pi->force_active = l2cap_pi(parent)->force_active;
-		pi->amp_pref = l2cap_pi(parent)->amp_pref;
+		chan->chan_type = pchan->chan_type;
+		chan->imtu = pchan->imtu;
+		chan->omtu = pchan->omtu;
+		chan->conf_state = pchan->conf_state;
+		chan->mode = pchan->mode;
+		chan->fcs  = pchan->fcs;
+		chan->max_tx = pchan->max_tx;
+		chan->tx_win = pchan->tx_win;
+		chan->tx_win_max = pchan->tx_win_max;
+		chan->sec_level = pchan->sec_level;
+		chan->flags = pchan->flags;
+
+		security_sk_clone(parent, sk);
 	} else {
-		pi->imtu = L2CAP_DEFAULT_MTU;
-		pi->omtu = 0;
+
+		switch (sk->sk_type) {
+		case SOCK_RAW:
+			chan->chan_type = L2CAP_CHAN_RAW;
+			break;
+		case SOCK_DGRAM:
+			chan->chan_type = L2CAP_CHAN_CONN_LESS;
+			break;
+		case SOCK_SEQPACKET:
+		case SOCK_STREAM:
+			chan->chan_type = L2CAP_CHAN_CONN_ORIENTED;
+			break;
+		}
+
+		chan->imtu = L2CAP_DEFAULT_MTU;
+		chan->omtu = 0;
 		if (!disable_ertm && sk->sk_type == SOCK_STREAM) {
-			pi->mode = L2CAP_MODE_ERTM;
-			pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
+			chan->mode = L2CAP_MODE_ERTM;
+			set_bit(CONF_STATE2_DEVICE, &chan->conf_state);
 		} else {
-			pi->mode = L2CAP_MODE_BASIC;
+			chan->mode = L2CAP_MODE_BASIC;
 		}
-		pi->reconf_state = L2CAP_RECONF_NONE;
-		pi->max_tx = L2CAP_DEFAULT_MAX_TX;
-		pi->fcs = L2CAP_FCS_CRC16;
-		pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;
-		pi->sec_level = BT_SECURITY_LOW;
-		pi->role_switch = 0;
-		pi->force_reliable = 0;
-		pi->flushable = 0;
-		pi->force_active = 1;
-		pi->amp_pref = BT_AMP_POLICY_REQUIRE_BR_EDR;
+		chan->max_tx = L2CAP_DEFAULT_MAX_TX;
+		chan->fcs  = L2CAP_FCS_CRC16;
+		chan->tx_win = L2CAP_DEFAULT_TX_WINDOW;
+		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
+		chan->sec_level = BT_SECURITY_LOW;
+		chan->flags = 0;
+		set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 	}
 
 	/* Default config options */
-	sk->sk_backlog_rcv = l2cap_data_channel;
-	pi->ampcon = NULL;
-	pi->ampchan = NULL;
-	pi->conf_len = 0;
-	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
-	pi->scid = 0;
-	pi->dcid = 0;
-	pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
-	pi->ack_win = pi->tx_win;
-	pi->extended_control = 0;
+	chan->flush_to = L2CAP_DEFAULT_FLUSH_TO;
 
-	pi->local_conf.fcs = pi->fcs;
-	pi->local_conf.flush_to = pi->flush_to;
-
-	set_default_config(&pi->remote_conf);
-
-	skb_queue_head_init(TX_QUEUE(sk));
-	skb_queue_head_init(SREJ_QUEUE(sk));
+	chan->data = sk;
+	chan->ops = &l2cap_chan_ops;
 }
 
 static struct proto l2cap_proto = {
@@ -1304,9 +1033,10 @@
 	.obj_size	= sizeof(struct l2cap_pinfo)
 };
 
-struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
+static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct sock *sk;
+	struct l2cap_chan *chan;
 
 	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);
 	if (!sk)
@@ -1316,16 +1046,21 @@
 	INIT_LIST_HEAD(&bt_sk(sk)->accept_q);
 
 	sk->sk_destruct = l2cap_sock_destruct;
-	sk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);
+	sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;
 
 	sock_reset_flag(sk, SOCK_ZAPPED);
 
 	sk->sk_protocol = proto;
 	sk->sk_state = BT_OPEN;
 
-	setup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);
+	chan = l2cap_chan_create(sk);
+	if (!chan) {
+		l2cap_sock_kill(sk);
+		return NULL;
+	}
+
+	l2cap_pi(sk)->chan = chan;
 
-	bt_sock_link(&l2cap_sk_list, sk);
 	return sk;
 }
 
@@ -1355,7 +1090,7 @@
 	return 0;
 }
 
-const struct proto_ops l2cap_sock_ops = {
+static const struct proto_ops l2cap_sock_ops = {
 	.family		= PF_BLUETOOTH,
 	.owner		= THIS_MODULE,
 	.release	= l2cap_sock_release,
diff -urN flo-ElementalX-5.00/net/bluetooth/lib.c flo-ElementalX-5.00-patched/net/bluetooth/lib.c
--- flo-ElementalX-5.00/net/bluetooth/lib.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/lib.c	2016-06-02 00:28:55.000000000 +0000
@@ -24,6 +24,8 @@
 
 /* Bluetooth kernel library. */
 
+#define pr_fmt(fmt) "Bluetooth: " fmt
+
 #include <linux/module.h>
 
 #include <linux/kernel.h>
@@ -59,7 +61,7 @@
 EXPORT_SYMBOL(batostr);
 
 /* Bluetooth error codes to Unix errno mapping */
-int bt_err(__u16 code)
+int bt_to_errno(__u16 code)
 {
 	switch (code) {
 	case 0:
@@ -149,4 +151,42 @@
 		return ENOSYS;
 	}
 }
+EXPORT_SYMBOL(bt_to_errno);
+
+int bt_info(const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	r = pr_info("%pV", &vaf);
+
+	va_end(args);
+
+	return r;
+}
+EXPORT_SYMBOL(bt_info);
+
+int bt_err(const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	r = pr_err("%pV", &vaf);
+
+	va_end(args);
+
+	return r;
+}
 EXPORT_SYMBOL(bt_err);
diff -urN flo-ElementalX-5.00/net/bluetooth/mgmt.c flo-ElementalX-5.00-patched/net/bluetooth/mgmt.c
--- flo-ElementalX-5.00/net/bluetooth/mgmt.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/mgmt.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
+
    Copyright (C) 2010  Nokia Corporation
-   Copyright (c) 2011-2012 The Linux Foundation.  All rights reserved.
+   Copyright (C) 2011-2012 Intel Corporation
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -23,45 +24,191 @@
 
 /* Bluetooth HCI Management interface */
 
+#include <linux/kernel.h>
 #include <linux/uaccess.h>
-#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 
-#define MGMT_VERSION	0
-#define MGMT_REVISION	1
+bool enable_hs;
+bool enable_le;
+
+#define MGMT_VERSION	1
+#define MGMT_REVISION	0
+
+static const u16 mgmt_commands[] = {
+	MGMT_OP_READ_INDEX_LIST,
+	MGMT_OP_READ_INFO,
+	MGMT_OP_SET_POWERED,
+	MGMT_OP_SET_DISCOVERABLE,
+	MGMT_OP_SET_CONNECTABLE,
+	MGMT_OP_SET_FAST_CONNECTABLE,
+	MGMT_OP_SET_PAIRABLE,
+	MGMT_OP_SET_LINK_SECURITY,
+	MGMT_OP_SET_SSP,
+	MGMT_OP_SET_HS,
+	MGMT_OP_SET_LE,
+	MGMT_OP_SET_DEV_CLASS,
+	MGMT_OP_SET_LOCAL_NAME,
+	MGMT_OP_ADD_UUID,
+	MGMT_OP_REMOVE_UUID,
+	MGMT_OP_LOAD_LINK_KEYS,
+	MGMT_OP_LOAD_LONG_TERM_KEYS,
+	MGMT_OP_DISCONNECT,
+	MGMT_OP_GET_CONNECTIONS,
+	MGMT_OP_PIN_CODE_REPLY,
+	MGMT_OP_PIN_CODE_NEG_REPLY,
+	MGMT_OP_SET_IO_CAPABILITY,
+	MGMT_OP_PAIR_DEVICE,
+	MGMT_OP_CANCEL_PAIR_DEVICE,
+	MGMT_OP_UNPAIR_DEVICE,
+	MGMT_OP_USER_CONFIRM_REPLY,
+	MGMT_OP_USER_CONFIRM_NEG_REPLY,
+	MGMT_OP_USER_PASSKEY_REPLY,
+	MGMT_OP_USER_PASSKEY_NEG_REPLY,
+	MGMT_OP_READ_LOCAL_OOB_DATA,
+	MGMT_OP_ADD_REMOTE_OOB_DATA,
+	MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+	MGMT_OP_START_DISCOVERY,
+	MGMT_OP_STOP_DISCOVERY,
+	MGMT_OP_CONFIRM_NAME,
+	MGMT_OP_BLOCK_DEVICE,
+	MGMT_OP_UNBLOCK_DEVICE,
+};
+
+static const u16 mgmt_events[] = {
+	MGMT_EV_CONTROLLER_ERROR,
+	MGMT_EV_INDEX_ADDED,
+	MGMT_EV_INDEX_REMOVED,
+	MGMT_EV_NEW_SETTINGS,
+	MGMT_EV_CLASS_OF_DEV_CHANGED,
+	MGMT_EV_LOCAL_NAME_CHANGED,
+	MGMT_EV_NEW_LINK_KEY,
+	MGMT_EV_NEW_LONG_TERM_KEY,
+	MGMT_EV_DEVICE_CONNECTED,
+	MGMT_EV_DEVICE_DISCONNECTED,
+	MGMT_EV_CONNECT_FAILED,
+	MGMT_EV_PIN_CODE_REQUEST,
+	MGMT_EV_USER_CONFIRM_REQUEST,
+	MGMT_EV_USER_PASSKEY_REQUEST,
+	MGMT_EV_AUTH_FAILED,
+	MGMT_EV_DEVICE_FOUND,
+	MGMT_EV_DISCOVERING,
+	MGMT_EV_DEVICE_BLOCKED,
+	MGMT_EV_DEVICE_UNBLOCKED,
+	MGMT_EV_DEVICE_UNPAIRED,
+};
+
+/*
+ * These LE scan and inquiry parameters were chosen according to LE General
+ * Discovery Procedure specification.
+ */
+#define LE_SCAN_TYPE			0x01
+#define LE_SCAN_WIN			0x12
+#define LE_SCAN_INT			0x12
+#define LE_SCAN_TIMEOUT_LE_ONLY		10240	/* TGAP(gen_disc_scan_min) */
+#define LE_SCAN_TIMEOUT_BREDR_LE	5120	/* TGAP(100)/2 */
+
+#define INQUIRY_LEN_BREDR		0x08	/* TGAP(100) */
+#define INQUIRY_LEN_BREDR_LE		0x04	/* TGAP(100)/2 */
+
+#define CACHE_TIMEOUT	msecs_to_jiffies(2 * 1000)
 
-#define SCAN_IDLE	0x00
-#define SCAN_LE		0x01
-#define SCAN_BR		0x02
+#define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
+				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
 
 struct pending_cmd {
 	struct list_head list;
-	__u16 opcode;
+	u16 opcode;
 	int index;
 	void *param;
 	struct sock *sk;
 	void *user_data;
 };
 
-struct mgmt_pending_free_work {
-	struct work_struct work;
-	struct sock *sk;
+/* HCI to MGMT error code conversion table */
+static u8 mgmt_status_table[] = {
+	MGMT_STATUS_SUCCESS,
+	MGMT_STATUS_UNKNOWN_COMMAND,	/* Unknown Command */
+	MGMT_STATUS_NOT_CONNECTED,	/* No Connection */
+	MGMT_STATUS_FAILED,		/* Hardware Failure */
+	MGMT_STATUS_CONNECT_FAILED,	/* Page Timeout */
+	MGMT_STATUS_AUTH_FAILED,	/* Authentication Failed */
+	MGMT_STATUS_NOT_PAIRED,		/* PIN or Key Missing */
+	MGMT_STATUS_NO_RESOURCES,	/* Memory Full */
+	MGMT_STATUS_TIMEOUT,		/* Connection Timeout */
+	MGMT_STATUS_NO_RESOURCES,	/* Max Number of Connections */
+	MGMT_STATUS_NO_RESOURCES,	/* Max Number of SCO Connections */
+	MGMT_STATUS_ALREADY_CONNECTED,	/* ACL Connection Exists */
+	MGMT_STATUS_BUSY,		/* Command Disallowed */
+	MGMT_STATUS_NO_RESOURCES,	/* Rejected Limited Resources */
+	MGMT_STATUS_REJECTED,		/* Rejected Security */
+	MGMT_STATUS_REJECTED,		/* Rejected Personal */
+	MGMT_STATUS_TIMEOUT,		/* Host Timeout */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Feature */
+	MGMT_STATUS_INVALID_PARAMS,	/* Invalid Parameters */
+	MGMT_STATUS_DISCONNECTED,	/* OE User Ended Connection */
+	MGMT_STATUS_NO_RESOURCES,	/* OE Low Resources */
+	MGMT_STATUS_DISCONNECTED,	/* OE Power Off */
+	MGMT_STATUS_DISCONNECTED,	/* Connection Terminated */
+	MGMT_STATUS_BUSY,		/* Repeated Attempts */
+	MGMT_STATUS_REJECTED,		/* Pairing Not Allowed */
+	MGMT_STATUS_FAILED,		/* Unknown LMP PDU */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Remote Feature */
+	MGMT_STATUS_REJECTED,		/* SCO Offset Rejected */
+	MGMT_STATUS_REJECTED,		/* SCO Interval Rejected */
+	MGMT_STATUS_REJECTED,		/* Air Mode Rejected */
+	MGMT_STATUS_INVALID_PARAMS,	/* Invalid LMP Parameters */
+	MGMT_STATUS_FAILED,		/* Unspecified Error */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported LMP Parameter Value */
+	MGMT_STATUS_FAILED,		/* Role Change Not Allowed */
+	MGMT_STATUS_TIMEOUT,		/* LMP Response Timeout */
+	MGMT_STATUS_FAILED,		/* LMP Error Transaction Collision */
+	MGMT_STATUS_FAILED,		/* LMP PDU Not Allowed */
+	MGMT_STATUS_REJECTED,		/* Encryption Mode Not Accepted */
+	MGMT_STATUS_FAILED,		/* Unit Link Key Used */
+	MGMT_STATUS_NOT_SUPPORTED,	/* QoS Not Supported */
+	MGMT_STATUS_TIMEOUT,		/* Instant Passed */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Pairing Not Supported */
+	MGMT_STATUS_FAILED,		/* Transaction Collision */
+	MGMT_STATUS_INVALID_PARAMS,	/* Unacceptable Parameter */
+	MGMT_STATUS_REJECTED,		/* QoS Rejected */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Classification Not Supported */
+	MGMT_STATUS_REJECTED,		/* Insufficient Security */
+	MGMT_STATUS_INVALID_PARAMS,	/* Parameter Out Of Range */
+	MGMT_STATUS_BUSY,		/* Role Switch Pending */
+	MGMT_STATUS_FAILED,		/* Slot Violation */
+	MGMT_STATUS_FAILED,		/* Role Switch Failed */
+	MGMT_STATUS_INVALID_PARAMS,	/* EIR Too Large */
+	MGMT_STATUS_NOT_SUPPORTED,	/* Simple Pairing Not Supported */
+	MGMT_STATUS_BUSY,		/* Host Busy Pairing */
+	MGMT_STATUS_REJECTED,		/* Rejected, No Suitable Channel */
+	MGMT_STATUS_BUSY,		/* Controller Busy */
+	MGMT_STATUS_INVALID_PARAMS,	/* Unsuitable Connection Interval */
+	MGMT_STATUS_TIMEOUT,		/* Directed Advertising Timeout */
+	MGMT_STATUS_AUTH_FAILED,	/* Terminated Due to MIC Failure */
+	MGMT_STATUS_CONNECT_FAILED,	/* Connection Establishment Failed */
+	MGMT_STATUS_CONNECT_FAILED,	/* MAC Connection Failed */
 };
 
-LIST_HEAD(cmd_list);
+static u8 mgmt_status(u8 hci_status)
+{
+	if (hci_status < ARRAY_SIZE(mgmt_status_table))
+		return mgmt_status_table[hci_status];
+
+	return MGMT_STATUS_FAILED;
+}
 
 static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_status *ev;
+	int err;
 
 	BT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);
 
@@ -79,18 +226,20 @@
 	ev->status = status;
 	put_unaligned_le16(cmd, &ev->opcode);
 
-	if (sock_queue_rcv_skb(sk, skb) < 0)
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0)
 		kfree_skb(skb);
 
-	return 0;
+	return err;
 }
 
-static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
-								size_t rp_len)
+static int cmd_complete(struct sock *sk, u16 index, u16 cmd, u8 status,
+			void *rp, size_t rp_len)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_complete *ev;
+	int err;
 
 	BT_DBG("sock %p", sk);
 
@@ -106,17 +255,20 @@
 
 	ev = (void *) skb_put(skb, sizeof(*ev) + rp_len);
 	put_unaligned_le16(cmd, &ev->opcode);
+	ev->status = status;
 
 	if (rp)
 		memcpy(ev->data, rp, rp_len);
 
-	if (sock_queue_rcv_skb(sk, skb) < 0)
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0)
 		kfree_skb(skb);
 
-	return 0;
+	return err;
 }
 
-static int read_version(struct sock *sk)
+static int read_version(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 data_len)
 {
 	struct mgmt_rp_read_version rp;
 
@@ -125,14 +277,50 @@
 	rp.version = MGMT_VERSION;
 	put_unaligned_le16(MGMT_REVISION, &rp.revision);
 
-	return cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, &rp,
-								sizeof(rp));
+	return cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0, &rp,
+			    sizeof(rp));
+}
+
+static int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 data_len)
+{
+	struct mgmt_rp_read_commands *rp;
+	u16 num_commands = ARRAY_SIZE(mgmt_commands);
+	u16 num_events = ARRAY_SIZE(mgmt_events);
+	u16 *opcode;
+	size_t rp_size;
+	int i, err;
+
+	BT_DBG("sock %p", sk);
+
+	rp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));
+
+	rp = kmalloc(rp_size, GFP_KERNEL);
+	if (!rp)
+		return -ENOMEM;
+
+	put_unaligned_le16(num_commands, &rp->num_commands);
+	put_unaligned_le16(num_events, &rp->num_events);
+
+	for (i = 0, opcode = rp->opcodes; i < num_commands; i++, opcode++)
+		put_unaligned_le16(mgmt_commands[i], opcode);
+
+	for (i = 0; i < num_events; i++, opcode++)
+		put_unaligned_le16(mgmt_events[i], opcode);
+
+	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0, rp,
+			   rp_size);
+	kfree(rp);
+
+	return err;
 }
 
-static int read_index_list(struct sock *sk)
+static int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 data_len)
 {
 	struct mgmt_rp_read_index_list *rp;
 	struct list_head *p;
+	struct hci_dev *d;
 	size_t rp_len;
 	u16 count;
 	int i, err;
@@ -143,9 +331,6 @@
 
 	count = 0;
 	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-		if (d->dev_type != HCI_BREDR)
-			continue;
 		count++;
 	}
 
@@ -156,268 +341,231 @@
 		return -ENOMEM;
 	}
 
-	put_unaligned_le16(0, &rp->num_controllers);
+	put_unaligned_le16(count, &rp->num_controllers);
 
 	i = 0;
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-
-		hci_del_off_timer(d);
-
-		if (d->dev_type != HCI_BREDR)
-			continue;
-
-		set_bit(HCI_MGMT, &d->flags);
-
-		if (test_bit(HCI_SETUP, &d->flags))
+	list_for_each_entry(d, &hci_dev_list, list) {
+		if (test_bit(HCI_SETUP, &d->dev_flags))
 			continue;
 
 		put_unaligned_le16(d->id, &rp->index[i++]);
-		put_unaligned_le16((u16)i, &rp->num_controllers);
 		BT_DBG("Added hci%u", d->id);
 	}
 
 	read_unlock(&hci_dev_list_lock);
 
-	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST, rp,
-									rp_len);
+	err = cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST, 0, rp,
+			   rp_len);
 
 	kfree(rp);
 
 	return err;
 }
 
-static int read_controller_info(struct sock *sk, u16 index)
+static u32 get_supported_settings(struct hci_dev *hdev)
 {
-	struct mgmt_rp_read_info rp;
-	struct hci_dev *hdev;
+	u32 settings = 0;
 
-	BT_DBG("sock %p hci%u", sk, index);
+	settings |= MGMT_SETTING_POWERED;
+	settings |= MGMT_SETTING_CONNECTABLE;
+	settings |= MGMT_SETTING_FAST_CONNECTABLE;
+	settings |= MGMT_SETTING_DISCOVERABLE;
+	settings |= MGMT_SETTING_PAIRABLE;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_INFO, ENODEV);
+	if (hdev->features[6] & LMP_SIMPLE_PAIR)
+		settings |= MGMT_SETTING_SSP;
 
-	hci_del_off_timer(hdev);
-
-	hci_dev_lock_bh(hdev);
-
-	set_bit(HCI_MGMT, &hdev->flags);
-
-	memset(&rp, 0, sizeof(rp));
-
-	rp.type = hdev->dev_type;
+	if (!(hdev->features[4] & LMP_NO_BREDR)) {
+		settings |= MGMT_SETTING_BREDR;
+		settings |= MGMT_SETTING_LINK_SECURITY;
+	}
 
-	rp.powered = test_bit(HCI_UP, &hdev->flags);
-	rp.connectable = test_bit(HCI_PSCAN, &hdev->flags);
-	rp.discoverable = test_bit(HCI_ISCAN, &hdev->flags);
-	rp.pairable = test_bit(HCI_PSCAN, &hdev->flags);
-
-	if (test_bit(HCI_AUTH, &hdev->flags))
-		rp.sec_mode = 3;
-	else if (hdev->ssp_mode > 0)
-		rp.sec_mode = 4;
-	else
-		rp.sec_mode = 2;
+	if (enable_hs)
+		settings |= MGMT_SETTING_HS;
 
-	bacpy(&rp.bdaddr, &hdev->bdaddr);
-	memcpy(rp.features, hdev->features, 8);
-	memcpy(rp.dev_class, hdev->dev_class, 3);
-	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
-	rp.hci_ver = hdev->hci_ver;
-	put_unaligned_le16(hdev->hci_rev, &rp.hci_rev);
+	if (enable_le) {
+		if (hdev->features[4] & LMP_LE)
+			settings |= MGMT_SETTING_LE;
+	}
 
-	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
+	return settings;
+}
 
-	rp.le_white_list_size = hdev->le_white_list_size;
+static u32 get_current_settings(struct hci_dev *hdev)
+{
+	u32 settings = 0;
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (hdev_is_powered(hdev))
+		settings |= MGMT_SETTING_POWERED;
 
-	return cmd_complete(sk, index, MGMT_OP_READ_INFO, &rp, sizeof(rp));
-}
+	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_CONNECTABLE;
 
-static void mgmt_pending_free_worker(struct work_struct *work)
-{
-	struct mgmt_pending_free_work *free_work =
-		container_of(work, struct mgmt_pending_free_work, work);
+	if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_DISCOVERABLE;
 
-	BT_DBG("sk %p", free_work->sk);
+	if (test_bit(HCI_PAIRABLE, &hdev->dev_flags))
+		settings |= MGMT_SETTING_PAIRABLE;
 
-	sock_put(free_work->sk);
-	kfree(free_work);
-}
+	if (!(hdev->features[4] & LMP_NO_BREDR))
+		settings |= MGMT_SETTING_BREDR;
 
-static void mgmt_pending_free(struct pending_cmd *cmd)
-{
-	struct mgmt_pending_free_work *free_work;
-	struct sock *sk = cmd->sk;
+	if (test_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_LE;
 
-	BT_DBG("opcode %d, sk %p", cmd->opcode, sk);
+	if (test_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+		settings |= MGMT_SETTING_LINK_SECURITY;
 
-	kfree(cmd->param);
-	kfree(cmd);
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_SSP;
 
-	free_work = kzalloc(sizeof(*free_work), GFP_ATOMIC);
-	if (free_work) {
-		INIT_WORK(&free_work->work, mgmt_pending_free_worker);
-		free_work->sk = sk;
+	if (test_bit(HCI_HS_ENABLED, &hdev->dev_flags))
+		settings |= MGMT_SETTING_HS;
 
-		if (!schedule_work(&free_work->work))
-			kfree(free_work);
-	}
+	return settings;
 }
 
-static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
-						u16 index, void *data, u16 len)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG("%d", opcode);
+#define PNP_INFO_SVCLASS_ID		0x1200
 
-	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
-	if (!cmd)
-		return NULL;
+static u8 bluetooth_base_uuid[] = {
+			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
+			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
 
-	cmd->opcode = opcode;
-	cmd->index = index;
+static u16 get_uuid16(u8 *uuid128)
+{
+	u32 val;
+	int i;
 
-	cmd->param = kmalloc(len, GFP_ATOMIC);
-	if (!cmd->param) {
-		kfree(cmd);
-		return NULL;
+	for (i = 0; i < 12; i++) {
+		if (bluetooth_base_uuid[i] != uuid128[i])
+			return 0;
 	}
 
-	if (data)
-		memcpy(cmd->param, data, len);
-
-	cmd->sk = sk;
-	sock_hold(sk);
+	memcpy(&val, &uuid128[12], 4);
 
-	list_add(&cmd->list, &cmd_list);
+	val = le32_to_cpu(val);
+	if (val > 0xffff)
+		return 0;
 
-	return cmd;
+	return (u16) val;
 }
 
-static void mgmt_pending_foreach(u16 opcode, int index,
-				void (*cb)(struct pending_cmd *cmd, void *data),
-				void *data)
+static void create_eir(struct hci_dev *hdev, u8 *data)
 {
-	struct list_head *p, *n;
-
-	BT_DBG(" %d", opcode);
+	u8 *ptr = data;
+	u16 eir_len = 0;
+	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
+	int i, truncated = 0;
+	struct bt_uuid *uuid;
+	size_t name_len;
 
-	list_for_each_safe(p, n, &cmd_list) {
-		struct pending_cmd *cmd;
+	name_len = strlen(hdev->dev_name);
 
-		cmd = list_entry(p, struct pending_cmd, list);
+	if (name_len > 0) {
+		/* EIR Data type */
+		if (name_len > 48) {
+			name_len = 48;
+			ptr[1] = EIR_NAME_SHORT;
+		} else
+			ptr[1] = EIR_NAME_COMPLETE;
 
-		if (opcode > 0 && cmd->opcode != opcode)
-			continue;
+		/* EIR Data length */
+		ptr[0] = name_len + 1;
 
-		if (index >= 0 && cmd->index != index)
-			continue;
+		memcpy(ptr + 2, hdev->dev_name, name_len);
 
-		cb(cmd, data);
+		eir_len += (name_len + 2);
+		ptr += (name_len + 2);
 	}
-}
-
-static struct pending_cmd *mgmt_pending_find(u16 opcode, int index)
-{
-	struct list_head *p;
 
-	BT_DBG(" %d", opcode);
+	memset(uuid16_list, 0, sizeof(uuid16_list));
 
-	list_for_each(p, &cmd_list) {
-		struct pending_cmd *cmd;
+	/* Group all UUID16 types */
+	list_for_each_entry(uuid, &hdev->uuids, list) {
+		u16 uuid16;
 
-		cmd = list_entry(p, struct pending_cmd, list);
+		uuid16 = get_uuid16(uuid->uuid);
+		if (uuid16 == 0)
+			return;
 
-		if (cmd->opcode != opcode)
+		if (uuid16 < 0x1100)
 			continue;
 
-		if (index >= 0 && cmd->index != index)
+		if (uuid16 == PNP_INFO_SVCLASS_ID)
 			continue;
 
-		return cmd;
-	}
+		/* Stop if not enough space to put next UUID */
+		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
+			truncated = 1;
+			break;
+		}
 
-	return NULL;
-}
+		/* Check for duplicates */
+		for (i = 0; uuid16_list[i] != 0; i++)
+			if (uuid16_list[i] == uuid16)
+				break;
 
-static void mgmt_pending_remove(struct pending_cmd *cmd)
-{
-	BT_DBG(" %d", cmd->opcode);
+		if (uuid16_list[i] == 0) {
+			uuid16_list[i] = uuid16;
+			eir_len += sizeof(u16);
+		}
+	}
 
-	list_del(&cmd->list);
-	mgmt_pending_free(cmd);
-}
+	if (uuid16_list[0] != 0) {
+		u8 *length = ptr;
 
-static int set_powered(struct sock *sk, u16 index, unsigned char *data, u16 len)
-{
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	int err, up;
+		/* EIR Data type */
+		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
 
-	cp = (void *) data;
+		ptr += 2;
+		eir_len += 2;
 
-	BT_DBG("request for hci%u", index);
+		for (i = 0; uuid16_list[i] != 0; i++) {
+			*ptr++ = (uuid16_list[i] & 0x00ff);
+			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
+		}
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED, EINVAL);
+		/* EIR Data length */
+		*length = (i * sizeof(u16)) + 1;
+	}
+}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED, ENODEV);
+static int update_eir(struct hci_dev *hdev)
+{
+	struct hci_cp_write_eir cp;
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev))
+		return 0;
 
-	up = test_bit(HCI_UP, &hdev->flags);
-	if ((cp->val && up) || (!cp->val && !up)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EALREADY);
-		goto failed;
-	}
+	if (!(hdev->features[6] & LMP_EXT_INQ))
+		return 0;
 
-	if (mgmt_pending_find(MGMT_OP_SET_POWERED, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EBUSY);
-		goto failed;
-	}
+	if (!test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		return 0;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, index, data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
+	if (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		return 0;
 
-	hci_dev_unlock_bh(hdev);
+	memset(&cp, 0, sizeof(cp));
 
-	if (cp->val)
-		queue_work(hdev->workqueue, &hdev->power_on);
-	else
-		queue_work(hdev->workqueue, &hdev->power_off);
+	create_eir(hdev, cp.data);
 
-	err = 0;
-	hci_dev_put(hdev);
+	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
+		return 0;
 
-	return err;
+	memcpy(hdev->eir, cp.data, sizeof(cp.data));
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-	return err;
+	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
 }
 
 static u8 get_service_classes(struct hci_dev *hdev)
 {
-	struct list_head *p;
+	struct bt_uuid *uuid;
 	u8 val = 0;
 
-	list_for_each(p, &hdev->uuids) {
-		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
-
+	list_for_each_entry(uuid, &hdev->uuids, list)
 		val |= uuid->svc_hint;
-	}
 
 	return val;
 }
@@ -425,11 +573,14 @@
 static int update_class(struct hci_dev *hdev)
 {
 	u8 cod[3];
-	int err = 0;
+	int err;
 
 	BT_DBG("%s", hdev->name);
 
-	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
+	if (!hdev_is_powered(hdev))
+		return 0;
+
+	if (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
 		return 0;
 
 	cod[0] = hdev->minor_class;
@@ -439,139 +590,317 @@
 	if (memcmp(cod, hdev->dev_class, 3) == 0)
 		return 0;
 
-	err =  hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
-
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
 	if (err == 0)
-		memcpy(hdev->dev_class, cod, 3);
+		set_bit(HCI_PENDING_CLASS, &hdev->dev_flags);
 
 	return err;
 }
 
-static int set_limited_discoverable(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+static void service_cache_off(struct work_struct *work)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	struct hci_cp_write_current_iac_lap dcp;
-	int update_cod;
-	int err = 0;
-	/* General Inquiry LAP: 0x9E8B33, Limited Inquiry LAP: 0x9E8B00 */
-	u8 lap[] = { 0x33, 0x8b, 0x9e, 0x00, 0x8b, 0x9e };
+	struct hci_dev *hdev = container_of(work, struct hci_dev,
+					    service_cache.work);
 
-	cp = (void *) data;
+	if (!test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
+		return;
 
-	BT_DBG("hci%u discoverable: %d", index, cp->val);
+	hci_dev_lock(hdev);
 
-	if (!cp || len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									EINVAL);
+	update_eir(hdev);
+	update_class(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									ENODEV);
+	hci_dev_unlock(hdev);
+}
 
-	hci_dev_lock_bh(hdev);
+static void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)
+{
+	if (test_and_set_bit(HCI_MGMT, &hdev->dev_flags))
+		return;
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-								ENETDOWN);
-		goto failed;
-	}
+	INIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);
 
-	if (mgmt_pending_find(MGMT_OP_SET_LIMIT_DISCOVERABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-									EBUSY);
-		goto failed;
-	}
+	/* Non-mgmt controlled devices get this bit set
+	 * implicitly so that pairing works for them, however
+	 * for mgmt we require user-space to explicitly enable
+	 * it
+	 */
+	clear_bit(HCI_PAIRABLE, &hdev->dev_flags);
+}
 
-	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
-					test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
-								EALREADY);
-		goto failed;
-	}
+static int read_controller_info(struct sock *sk, struct hci_dev *hdev,
+				void *data, u16 data_len)
+{
+	struct mgmt_rp_read_info rp;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LIMIT_DISCOVERABLE, index, data,
-									len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
+	BT_DBG("sock %p %s", sk, hdev->name);
 
-	memset(&dcp, 0, sizeof(dcp));
-	dcp.num_current_iac = cp->val ? 2 : 1;
-	memcpy(&dcp.lap, lap, dcp.num_current_iac * 3);
-	update_cod = 1;
+	hci_dev_lock(hdev);
 
-	if (cp->val) {
-		if (hdev->major_class & MGMT_MAJOR_CLASS_LIMITED)
-			update_cod = 0;
-		hdev->major_class |= MGMT_MAJOR_CLASS_LIMITED;
-	} else {
-		if (!(hdev->major_class & MGMT_MAJOR_CLASS_LIMITED))
-			update_cod = 0;
-		hdev->major_class &= ~MGMT_MAJOR_CLASS_LIMITED;
-	}
+	memset(&rp, 0, sizeof(rp));
 
-	if (update_cod)
-		err = update_class(hdev);
+	bacpy(&rp.bdaddr, &hdev->bdaddr);
 
-	if (err >= 0)
-		err = hci_send_cmd(hdev, HCI_OP_WRITE_CURRENT_IAC_LAP,
-							sizeof(dcp), &dcp);
+	rp.version = hdev->hci_ver;
 
-	if (err < 0)
-		mgmt_pending_remove(cmd);
+	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	rp.supported_settings = cpu_to_le32(get_supported_settings(hdev));
+	rp.current_settings = cpu_to_le32(get_current_settings(hdev));
 
-	return err;
-}
+	memcpy(rp.dev_class, hdev->dev_class, 3);
+
+	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
+	memcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));
+
+	hci_dev_unlock(hdev);
+
+	return cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,
+			    sizeof(rp));
+}
+
+static void mgmt_pending_free(struct pending_cmd *cmd)
+{
+	sock_put(cmd->sk);
+	kfree(cmd->param);
+	kfree(cmd);
+}
 
-static int set_discoverable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
+					    struct hci_dev *hdev, void *data,
+					    u16 len)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
+
+	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
+	if (!cmd)
+		return NULL;
+
+	cmd->opcode = opcode;
+	cmd->index = hdev->id;
+
+	cmd->param = kmalloc(len, GFP_ATOMIC);
+	if (!cmd->param) {
+		kfree(cmd);
+		return NULL;
+	}
+
+	if (data)
+		memcpy(cmd->param, data, len);
+
+	cmd->sk = sk;
+	sock_hold(sk);
+
+	list_add(&cmd->list, &hdev->mgmt_pending);
+
+	return cmd;
+}
+
+static void mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,
+				 void (*cb)(struct pending_cmd *cmd, void *data),
+				 void *data)
+{
+	struct list_head *p, *n;
+
+	list_for_each_safe(p, n, &hdev->mgmt_pending) {
+		struct pending_cmd *cmd;
+
+		cmd = list_entry(p, struct pending_cmd, list);
+
+		if (opcode > 0 && cmd->opcode != opcode)
+			continue;
+
+		cb(cmd, data);
+	}
+}
+
+static struct pending_cmd *mgmt_pending_find(u16 opcode, struct hci_dev *hdev)
+{
+	struct pending_cmd *cmd;
+
+	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
+		if (cmd->opcode == opcode)
+			return cmd;
+	}
+
+	return NULL;
+}
+
+static void mgmt_pending_remove(struct pending_cmd *cmd)
+{
+	list_del(&cmd->list);
+	mgmt_pending_free(cmd);
+}
+
+static int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)
+{
+	__le32 settings = cpu_to_le32(get_current_settings(hdev));
+
+	return cmd_complete(sk, hdev->id, opcode, 0, &settings,
+			    sizeof(settings));
+}
+
+static int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,
+		       u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	int err;
+
+	BT_DBG("request for %s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->dev_flags)) {
+		cancel_delayed_work(&hdev->power_off);
+
+		if (cp->val) {
+			err = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);
+			mgmt_powered(hdev, 1);
+			goto failed;
+		}
+	}
+
+	if (!!cp->val == hdev_is_powered(hdev)) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);
+		goto failed;
+	}
+
+	if (mgmt_pending_find(MGMT_OP_SET_POWERED, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	if (cp->val)
+		schedule_work(&hdev->power_on);
+	else
+		schedule_work(&hdev->power_off.work);
+
+	err = 0;
+
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
+
+static int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 data_len,
+		      struct sock *skip_sk)
+{
+	struct sk_buff *skb;
+	struct mgmt_hdr *hdr;
+
+	skb = alloc_skb(sizeof(*hdr) + data_len, GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+
+	hdr = (void *) skb_put(skb, sizeof(*hdr));
+	hdr->opcode = cpu_to_le16(event);
+	if (hdev)
+		hdr->index = cpu_to_le16(hdev->id);
+	else
+		hdr->index = cpu_to_le16(MGMT_INDEX_NONE);
+	hdr->len = cpu_to_le16(data_len);
+
+	if (data)
+		memcpy(skb_put(skb, data_len), data, data_len);
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	hci_send_to_control(skb, skip_sk);
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static int new_settings(struct hci_dev *hdev, struct sock *skip)
+{
+	__le32 ev;
+
+	ev = cpu_to_le32(get_current_settings(hdev));
+
+	return mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev), skip);
+}
+
+static int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,
+			    u16 len)
+{
+	struct mgmt_cp_set_discoverable *cp = data;
+	struct pending_cmd *cmd;
+	u16 timeout;
 	u8 scan;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	timeout = get_unaligned_le16(&cp->timeout);
+	if (!cp->val && timeout > 0)
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				  MGMT_STATUS_INVALID_PARAMS);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENODEV);
+	if (!hdev_is_powered(hdev) && timeout > 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto failed;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENETDOWN);
+	if (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,
+				 MGMT_STATUS_REJECTED);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EBUSY);
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
+
+		if (!!cp->val != test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {
+			change_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+			changed = true;
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);
+		if (err < 0)
+			goto failed;
+
+		if (changed)
+			err = new_settings(hdev, sk);
+
 		goto failed;
 	}
 
-	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
-					test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EALREADY);
+	if (!!cp->val == test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) {
+		if (hdev->discov_timeout > 0) {
+			cancel_delayed_work(&hdev->discov_off);
+			hdev->discov_timeout = 0;
+		}
+
+		if (cp->val && timeout > 0) {
+			hdev->discov_timeout = timeout;
+			queue_delayed_work(hdev->workqueue, &hdev->discov_off,
+				msecs_to_jiffies(hdev->discov_timeout * 1000));
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -581,318 +910,349 @@
 
 	if (cp->val)
 		scan |= SCAN_INQUIRY;
+	else
+		cancel_delayed_work(&hdev->discov_off);
 
 	err = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (cp->val)
+		hdev->discov_timeout = timeout;
 
+failed:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_connectable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 len)
 {
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
+	struct mgmt_mode *cp = data;
 	struct pending_cmd *cmd;
 	u8 scan;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EINVAL);
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENODEV);
+		if (!!cp->val != test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
 
-	hci_dev_lock_bh(hdev);
+		if (cp->val) {
+			set_bit(HCI_CONNECTABLE, &hdev->dev_flags);
+		} else {
+			clear_bit(HCI_CONNECTABLE, &hdev->dev_flags);
+			clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags);
+		}
+
+		err = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);
+		if (err < 0)
+			goto failed;
+
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENETDOWN);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EBUSY);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	if (cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EALREADY);
+	if (!!cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	if (cp->val)
+	if (cp->val) {
 		scan = SCAN_PAGE;
-	else
+	} else {
 		scan = 0;
 
+		if (test_bit(HCI_ISCAN, &hdev->flags) &&
+						hdev->discov_timeout > 0)
+			cancel_delayed_work(&hdev->discov_off);
+	}
+
 	err = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int mgmt_event(u16 event, u16 index, void *data, u16 data_len,
-							struct sock *skip_sk)
+static int set_pairable(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
 {
-	struct sk_buff *skb;
-	struct mgmt_hdr *hdr;
-
-	BT_DBG("hci%d %d", index, event);
+	struct mgmt_mode *cp = data;
+	int err;
 
-	skb = alloc_skb(sizeof(*hdr) + data_len, GFP_ATOMIC);
-	if (!skb)
-		return -ENOMEM;
+	BT_DBG("request for %s", hdev->name);
 
-	bt_cb(skb)->channel = HCI_CHANNEL_CONTROL;
+	hci_dev_lock(hdev);
 
-	hdr = (void *) skb_put(skb, sizeof(*hdr));
-	hdr->opcode = cpu_to_le16(event);
-	hdr->index = cpu_to_le16(index);
-	hdr->len = cpu_to_le16(data_len);
+	if (cp->val)
+		set_bit(HCI_PAIRABLE, &hdev->dev_flags);
+	else
+		clear_bit(HCI_PAIRABLE, &hdev->dev_flags);
 
-	if (data)
-		memcpy(skb_put(skb, data_len), data, data_len);
+	err = send_settings_rsp(sk, MGMT_OP_SET_PAIRABLE, hdev);
+	if (err < 0)
+		goto failed;
 
-	hci_send_to_sock(NULL, skb, skip_sk);
-	kfree_skb(skb);
+	err = new_settings(hdev, sk);
 
-	return 0;
+failed:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int send_mode_rsp(struct sock *sk, u16 opcode, u16 index, u8 val)
+static int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,
+			     u16 len)
 {
-	struct mgmt_mode rp;
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	u8 val;
+	int err;
 
-	rp.val = val;
+	BT_DBG("request for %s", hdev->name);
 
-	return cmd_complete(sk, index, opcode, &rp, sizeof(rp));
-}
+	hci_dev_lock(hdev);
 
-static int set_pairable(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct mgmt_mode *cp, ev;
-	struct hci_dev *hdev;
-	int err;
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	cp = (void *) data;
+		if (!!cp->val != test_bit(HCI_LINK_SECURITY,
+							&hdev->dev_flags)) {
+			change_bit(HCI_LINK_SECURITY, &hdev->dev_flags);
+			changed = true;
+		}
 
-	BT_DBG("request for hci%u", index);
+		err = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);
+		if (err < 0)
+			goto failed;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, EINVAL);
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, ENODEV);
+		goto failed;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-	if (cp->val)
-		set_bit(HCI_PAIRABLE, &hdev->flags);
-	else
-		clear_bit(HCI_PAIRABLE, &hdev->flags);
+	val = !!cp->val;
 
-	err = send_mode_rsp(sk, MGMT_OP_SET_PAIRABLE, index, cp->val);
-	if (err < 0)
+	if (test_bit(HCI_AUTH, &hdev->flags) == val) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);
 		goto failed;
+	}
 
-	ev.val = cp->val;
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
 
-	err = mgmt_event(MGMT_EV_PAIRABLE, index, &ev, sizeof(ev), sk);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto failed;
+	}
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-#define EIR_FLAGS		0x01 /* flags */
-#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
-#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
-#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
-#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
-#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
-#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
-#define EIR_NAME_SHORT		0x08 /* shortened local name */
-#define EIR_NAME_COMPLETE	0x09 /* complete local name */
-#define EIR_TX_POWER		0x0A /* transmit power level */
-#define EIR_DEVICE_ID		0x10 /* device ID */
-
-#define PNP_INFO_SVCLASS_ID		0x1200
+static int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct pending_cmd *cmd;
+	u8 val;
+	int err;
 
-static u8 bluetooth_base_uuid[] = {
-			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
-			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
+	BT_DBG("request for %s", hdev->name);
 
-static u16 get_uuid16(u8 *uuid128)
-{
-	u32 val;
-	int i;
+	hci_dev_lock(hdev);
 
-	for (i = 0; i < 12; i++) {
-		if (bluetooth_base_uuid[i] != uuid128[i])
-			return 0;
+	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto failed;
 	}
 
-	memcpy(&val, &uuid128[12], 4);
+	val = !!cp->val;
 
-	val = le32_to_cpu(val);
-	if (val > 0xffff)
-		return 0;
+	if (!hdev_is_powered(hdev)) {
+		bool changed = false;
 
-	return (u16) val;
-}
+		if (val != test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			change_bit(HCI_SSP_ENABLED, &hdev->dev_flags);
+			changed = true;
+		}
 
-static void create_eir(struct hci_dev *hdev, u8 *data)
-{
-	u8 *ptr = data;
-	u16 eir_len = 0;
-	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
-	int i, truncated = 0;
-	struct list_head *p;
-	size_t name_len;
+		err = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);
+		if (err < 0)
+			goto failed;
 
-	name_len = strnlen(hdev->dev_name, HCI_MAX_EIR_LENGTH);
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (name_len > 0) {
-		/* EIR Data type */
-		if (name_len > 48) {
-			name_len = 48;
-			ptr[1] = EIR_NAME_SHORT;
-		} else
-			ptr[1] = EIR_NAME_COMPLETE;
+		goto failed;
+	}
 
-		/* EIR Data length */
-		ptr[0] = name_len + 1;
+	if (mgmt_pending_find(MGMT_OP_SET_SSP, hdev)) {
+	     err = cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,
+			      MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
-		memcpy(ptr + 2, hdev->dev_name, name_len);
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) == val) {
+		err = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);
+		goto failed;
+	}
 
-		eir_len += (name_len + 2);
-		ptr += (name_len + 2);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
 	}
 
-	memset(uuid16_list, 0, sizeof(uuid16_list));
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, sizeof(val), &val);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto failed;
+	}
 
-	/* Group all UUID16 types */
-	list_for_each(p, &hdev->uuids) {
-		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
-		u16 uuid16;
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
 
-		uuid16 = get_uuid16(uuid->uuid);
-		if (uuid16 == 0)
-			return;
+static int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
 
-		if (uuid16 < 0x1100)
-			continue;
+	BT_DBG("request for %s", hdev->name);
 
-		if (uuid16 == PNP_INFO_SVCLASS_ID)
-			continue;
+	if (!enable_hs)
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_HS,
+				  MGMT_STATUS_NOT_SUPPORTED);
 
-		/* Stop if not enough space to put next UUID */
-		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
-			truncated = 1;
-			break;
-		}
+	if (cp->val)
+		set_bit(HCI_HS_ENABLED, &hdev->dev_flags);
+	else
+		clear_bit(HCI_HS_ENABLED, &hdev->dev_flags);
 
-		/* Check for duplicates */
-		for (i = 0; uuid16_list[i] != 0; i++)
-			if (uuid16_list[i] == uuid16)
-				break;
+	return send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);
+}
 
-		if (uuid16_list[i] == 0) {
-			uuid16_list[i] = uuid16;
-			eir_len += sizeof(u16);
-		}
-	}
+static int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
+{
+	struct mgmt_mode *cp = data;
+	struct hci_cp_write_le_host_supported hci_cp;
+	struct pending_cmd *cmd;
+	int err;
+	u8 val, enabled;
 
-	if (uuid16_list[0] != 0) {
-		u8 *length = ptr;
+	BT_DBG("request for %s", hdev->name);
 
-		/* EIR Data type */
-		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
+	hci_dev_lock(hdev);
 
-		ptr += 2;
-		eir_len += 2;
+	if (!enable_le || !(hdev->features[4] & LMP_LE)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LE,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto unlock;
+	}
 
-		for (i = 0; uuid16_list[i] != 0; i++) {
-			*ptr++ = (uuid16_list[i] & 0x00ff);
-			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
-		}
+	val = !!cp->val;
+	enabled = !!(hdev->host_features[0] & LMP_HOST_LE);
 
-		/* EIR Data length */
-		*length = (i * sizeof(u16)) + 1;
-	}
-}
+	if (!hdev_is_powered(hdev) || val == enabled) {
+		bool changed = false;
 
-static int update_eir(struct hci_dev *hdev)
-{
-	struct hci_cp_write_eir cp;
+		if (val != test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+			change_bit(HCI_LE_ENABLED, &hdev->dev_flags);
+			changed = true;
+		}
 
-	if (!(hdev->features[6] & LMP_EXT_INQ))
-		return 0;
+		err = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);
+		if (err < 0)
+			goto unlock;
 
-	if (hdev->ssp_mode == 0)
-		return 0;
+		if (changed)
+			err = new_settings(hdev, sk);
 
-	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		return 0;
+		goto unlock;
+	}
 
-	memset(&cp, 0, sizeof(cp));
+	if (mgmt_pending_find(MGMT_OP_SET_LE, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_LE,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	create_eir(hdev, cp.data);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
-	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
-		return 0;
+	memset(&hci_cp, 0, sizeof(hci_cp));
 
-	memcpy(hdev->eir, cp.data, sizeof(cp.data));
+	if (val) {
+		hci_cp.le = val;
+		hci_cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+	}
 
-	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(hci_cp),
+			   &hci_cp);
+	if (err < 0) {
+		mgmt_pending_remove(cmd);
+		goto unlock;
+	}
+
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int add_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)
 {
-	struct mgmt_cp_add_uuid *cp;
-	struct hci_dev *hdev;
+	struct mgmt_cp_add_uuid *cp = data;
+	struct pending_cmd *cmd;
 	struct bt_uuid *uuid;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,
+				 MGMT_STATUS_BUSY);
+		goto failed;
+	}
 
 	uuid = kmalloc(sizeof(*uuid), GFP_ATOMIC);
 	if (!uuid) {
@@ -905,51 +1265,73 @@
 
 	list_add(&uuid->list, &hdev->uuids);
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
+	err = update_class(hdev);
+	if (err < 0)
+		goto failed;
 
-		err = update_class(hdev);
-		if (err < 0)
-			goto failed;
+	err = update_eir(hdev);
+	if (err < 0)
+		goto failed;
 
-		err = update_eir(hdev);
-		if (err < 0)
-			goto failed;
-	} else
-		err = 0;
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_UUID, 0,
+				   hdev->dev_class, 3);
+		goto failed;
+	}
 
-	err = cmd_complete(sk, index, MGMT_OP_ADD_UUID, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_ADD_UUID, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int remove_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static bool enable_service_cache(struct hci_dev *hdev)
+{
+	if (!hdev_is_powered(hdev))
+		return false;
+
+	if (!test_and_set_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {
+		schedule_delayed_work(&hdev->service_cache, CACHE_TIMEOUT);
+		return true;
+	}
+
+	return false;
+}
+
+static int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,
+								u16 len)
 {
+	struct mgmt_cp_remove_uuid *cp = data;
+	struct pending_cmd *cmd;
 	struct list_head *p, *n;
-	struct mgmt_cp_remove_uuid *cp;
-	struct hci_dev *hdev;
 	u8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	int err, found;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	BT_DBG("request for hci%u", index);
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
 	if (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {
 		err = hci_uuids_clear(hdev);
-		goto unlock;
+
+		if (enable_service_cache(hdev)) {
+			err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+					   0, hdev->dev_class, 3);
+			goto unlock;
+		}
+
+		goto update_class;
 	}
 
 	found = 0;
@@ -965,232 +1347,222 @@
 	}
 
 	if (found == 0) {
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENOENT);
+		err = cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,
+				 MGMT_STATUS_INVALID_PARAMS);
 		goto unlock;
 	}
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		err = update_class(hdev);
-		if (err < 0)
-			goto unlock;
-
-		err = update_eir(hdev);
-		if (err < 0)
-			goto unlock;
-	} else
-		err = 0;
-
-	err = cmd_complete(sk, index, MGMT_OP_REMOVE_UUID, NULL, 0);
-
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int set_dev_class(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_dev_class *cp;
-	int err;
-
-	cp = (void *) data;
-
-	BT_DBG("request for hci%u", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+update_class:
+	err = update_class(hdev);
+	if (err < 0)
+		goto unlock;
 
-	hdev->major_class &= ~MGMT_MAJOR_CLASS_MASK;
-	hdev->major_class |= cp->major & MGMT_MAJOR_CLASS_MASK;
-	hdev->minor_class = cp->minor;
+	err = update_eir(hdev);
+	if (err < 0)
+		goto unlock;
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		err = update_class(hdev);
-		if (err == 0)
-			err = cmd_complete(sk, index,
-		MGMT_OP_SET_DEV_CLASS, hdev->dev_class, sizeof(u8)*3);
-	} else
-		err = cmd_complete(sk, index, MGMT_OP_SET_DEV_CLASS, NULL, 0);
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_service_cache(struct sock *sk, u16 index,  unsigned char *data,
-									u16 len)
+static int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_service_cache *cp;
+	struct mgmt_cp_set_dev_class *cp = data;
+	struct pending_cmd *cmd;
 	int err;
 
-	cp = (void *) data;
+	BT_DBG("request for %s", hdev->name);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, ENODEV);
+	if (test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	hdev->major_class = cp->major;
+	hdev->minor_class = cp->minor;
 
-	BT_DBG("hci%u enable %d", index, cp->enable);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	if (cp->enable) {
-		set_bit(HCI_SERVICE_CACHE, &hdev->flags);
-		err = 0;
-	} else {
-		clear_bit(HCI_SERVICE_CACHE, &hdev->flags);
-		if (test_bit(HCI_UP, &hdev->flags)) {
-			err = update_class(hdev);
-			if (err == 0)
-				err = update_eir(hdev);
-		} else
-			err = 0;
+	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->dev_flags)) {
+		hci_dev_unlock(hdev);
+		cancel_delayed_work_sync(&hdev->service_cache);
+		hci_dev_lock(hdev);
+		update_eir(hdev);
 	}
 
-	if (err == 0)
-		err = cmd_complete(sk, index, MGMT_OP_SET_SERVICE_CACHE, NULL,
-									0);
+	err = update_class(hdev);
+	if (err < 0)
+		goto unlock;
+
+	if (!test_bit(HCI_PENDING_CLASS, &hdev->dev_flags)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,
+				   hdev->dev_class, 3);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int load_keys(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,
+								u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_load_keys *cp;
+	struct mgmt_cp_load_link_keys *cp = data;
 	u16 key_count, expected_len;
-	int i, err;
-
-	cp = (void *) data;
-
-	if (len < sizeof(*cp))
-		return -EINVAL;
+	int i;
 
 	key_count = get_unaligned_le16(&cp->key_count);
 
-	expected_len = sizeof(*cp) + key_count * sizeof(struct mgmt_key_info);
-	if (expected_len > len) {
-		BT_ERR("load_keys: expected at least %u bytes, got %u bytes",
-							expected_len, len);
-		return -EINVAL;
+	expected_len = sizeof(*cp) + key_count *
+					sizeof(struct mgmt_link_key_info);
+	if (expected_len != len) {
+		BT_ERR("load_link_keys: expected %u bytes, got %u bytes",
+							len, expected_len);
+		return cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,
+				  MGMT_STATUS_INVALID_PARAMS);
 	}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LOAD_KEYS, ENODEV);
-
-	BT_DBG("hci%u debug_keys %u key_count %u", index, cp->debug_keys,
+	BT_DBG("%s debug_keys %u key_count %u", hdev->name, cp->debug_keys,
 								key_count);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	hci_link_keys_clear(hdev);
 
-	set_bit(HCI_LINK_KEYS, &hdev->flags);
+	set_bit(HCI_LINK_KEYS, &hdev->dev_flags);
 
 	if (cp->debug_keys)
-		set_bit(HCI_DEBUG_KEYS, &hdev->flags);
+		set_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);
 	else
-		clear_bit(HCI_DEBUG_KEYS, &hdev->flags);
-
-	len -= sizeof(*cp);
-	i = 0;
-
-	while (i < len) {
-		struct mgmt_key_info *key = (void *) cp->keys + i;
+		clear_bit(HCI_DEBUG_KEYS, &hdev->dev_flags);
 
-		i += sizeof(*key);
+	for (i = 0; i < key_count; i++) {
+		struct mgmt_link_key_info *key = &cp->keys[i];
 
-		if (key->key_type == KEY_TYPE_LTK) {
-			struct key_master_id *id = (void *) key->data;
-
-			if (key->dlen != sizeof(struct key_master_id))
-				continue;
+		hci_add_link_key(hdev, NULL, 0, &key->addr.bdaddr, key->val,
+				 key->type, key->pin_len);
+	}
 
-			hci_add_ltk(hdev, 0, &key->bdaddr, key->addr_type,
-					key->pin_len, key->auth, id->ediv,
-					id->rand, key->val);
+	cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);
 
-			continue;
-		}
+	hci_dev_unlock(hdev);
 
-		hci_add_link_key(hdev, 0, &key->bdaddr, key->val, key->key_type,
-								key->pin_len);
-	}
+	return 0;
+}
 
-	err = cmd_complete(sk, index, MGMT_OP_LOAD_KEYS, NULL, 0);
+static int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 addr_type, struct sock *skip_sk)
+{
+	struct mgmt_ev_device_unpaired ev;
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = addr_type;
 
-	return err;
+	return mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),
+			  skip_sk);
 }
 
-static int remove_key(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			 u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_remove_key *cp;
+	struct mgmt_cp_unpair_device *cp = data;
+	struct mgmt_rp_unpair_device rp;
+	struct hci_cp_disconnect dc;
+	struct pending_cmd *cmd;
 	struct hci_conn *conn;
 	int err;
 
-	cp = (void *) data;
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, EINVAL);
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, ENODEV);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,
+				   MGMT_STATUS_NOT_POWERED, &rp, sizeof(rp));
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		err = hci_remove_link_key(hdev, &cp->addr.bdaddr);
+	else
+		err = hci_remove_ltk(hdev, &cp->addr.bdaddr);
 
-	err = hci_remove_link_key(hdev, &cp->bdaddr);
 	if (err < 0) {
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_KEY, -err);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,
+				   MGMT_STATUS_NOT_PAIRED, &rp, sizeof(rp));
 		goto unlock;
 	}
 
-	err = 0;
+	if (cp->disconnect) {
+		if (cp->addr.type == MGMT_ADDR_BREDR)
+			conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+							&cp->addr.bdaddr);
+		else
+			conn = hci_conn_hash_lookup_ba(hdev, LE_LINK,
+							&cp->addr.bdaddr);
+	} else {
+		conn = NULL;
+	}
 
-	if (!test_bit(HCI_UP, &hdev->flags) || !cp->disconnect)
+	if (!conn) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,
+				   &rp, sizeof(rp));
+		device_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);
 		goto unlock;
+	}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (conn) {
-		struct hci_cp_disconnect dc;
-
-		put_unaligned_le16(conn->handle, &dc.handle);
-		dc.reason = 0x13; /* Remote User Terminated Connection */
-		err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, 0, NULL);
+	cmd = mgmt_pending_add(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,
+			       sizeof(*cp));
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
 	}
 
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	put_unaligned_le16(conn->handle, &dc.handle);
+	dc.reason = 0x13; /* Remote User Terminated Connection */
+	err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int disconnect(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,
+		      u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_disconnect *cp;
+	struct mgmt_cp_disconnect *cp = data;
 	struct hci_cp_disconnect dc;
 	struct pending_cmd *cmd;
 	struct hci_conn *conn;
@@ -1198,38 +1570,32 @@
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, ENETDOWN);
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_DISCONNECT, index)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, EBUSY);
+	if (mgmt_pending_find(MGMT_OP_DISCONNECT, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);
+	else
+		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);
+
 	if (!conn) {
-		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-		if (!conn) {
-			err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
-							ENOTCONN);
-			goto failed;
-		}
+		err = cmd_status(sk, hdev->id, MGMT_OP_DISCONNECT,
+				 MGMT_STATUS_NOT_CONNECTED);
+		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1243,445 +1609,218 @@
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int get_connections(struct sock *sk, u16 index)
+static u8 link_to_mgmt(u8 link_type, u8 addr_type)
+{
+	switch (link_type) {
+	case LE_LINK:
+		switch (addr_type) {
+		case ADDR_LE_DEV_PUBLIC:
+			return MGMT_ADDR_LE_PUBLIC;
+		case ADDR_LE_DEV_RANDOM:
+			return MGMT_ADDR_LE_RANDOM;
+		default:
+			return MGMT_ADDR_INVALID;
+		}
+	case ACL_LINK:
+		return MGMT_ADDR_BREDR;
+	default:
+		return MGMT_ADDR_INVALID;
+	}
+}
+
+static int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,
+			   u16 data_len)
 {
 	struct mgmt_rp_get_connections *rp;
-	struct hci_dev *hdev;
-	struct list_head *p;
+	struct hci_conn *c;
 	size_t rp_len;
-	u16 count;
-	int i, err;
+	int err;
+	u16 i;
 
 	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_GET_CONNECTIONS, ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
 
-	count = 0;
-	list_for_each(p, &hdev->conn_hash.list) {
-		count++;
+	i = 0;
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
+		if (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))
+			i++;
 	}
 
-	rp_len = sizeof(*rp) + (count * sizeof(bdaddr_t));
+	rp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));
 	rp = kmalloc(rp_len, GFP_ATOMIC);
 	if (!rp) {
 		err = -ENOMEM;
 		goto unlock;
 	}
 
-	put_unaligned_le16(count, &rp->conn_count);
-
-	read_lock(&hci_dev_list_lock);
-
 	i = 0;
-	list_for_each(p, &hdev->conn_hash.list) {
-		struct hci_conn *c = list_entry(p, struct hci_conn, list);
-
-		bacpy(&rp->conn[i++], &c->dst);
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
+		if (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))
+			continue;
+		bacpy(&rp->addr[i].bdaddr, &c->dst);
+		rp->addr[i].type = link_to_mgmt(c->type, c->dst_type);
+		if (rp->addr[i].type == MGMT_ADDR_INVALID)
+			continue;
+		i++;
 	}
 
-	read_unlock(&hci_dev_list_lock);
+	put_unaligned_le16(i, &rp->conn_count);
 
-	err = cmd_complete(sk, index, MGMT_OP_GET_CONNECTIONS, rp, rp_len);
+	/* Recalculate length in case of filtered SCO connections, etc */
+	rp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,
+			   rp_len);
 
-unlock:
 	kfree(rp);
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int pin_code_reply(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				   struct mgmt_cp_pin_code_neg_reply *cp)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_pin_code_reply *cp;
-	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENETDOWN);
-		goto failed;
-	}
-
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, index, data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
-
-	bacpy(&reply.bdaddr, &cp->bdaddr);
-	reply.pin_len = cp->pin_len;
-	memcpy(reply.pin_code, cp->pin_code, 16);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,
+			       sizeof(*cp));
+	if (!cmd)
+		return -ENOMEM;
 
-	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);
+	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,
+			   sizeof(cp->addr.bdaddr), &cp->addr.bdaddr);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
 	return err;
 }
 
-static int encrypt_link(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_encrypt_link *cp;
-	struct hci_cp_set_conn_encrypt enc;
 	struct hci_conn *conn;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENETDOWN);
-		goto done;
-	}
-
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENOTCONN);
-		goto done;
-	}
-
-	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINPROGRESS);
-		goto done;
-	}
-
-	if (conn->link_mode & HCI_LM_AUTH) {
-		enc.handle = cpu_to_le16(conn->handle);
-		enc.encrypt = cp->enable;
-		err = hci_send_cmd(hdev,
-				HCI_OP_SET_CONN_ENCRYPT, sizeof(enc), &enc);
-	} else {
-		conn->auth_initiator = 1;
-		if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
-			struct hci_cp_auth_requested cp;
-			cp.handle = cpu_to_le16(conn->handle);
-			err = hci_send_cmd(conn->hdev,
-				HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
-		}
-	}
-
-done:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-
-static int pin_code_neg_reply(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_pin_code_neg_reply *cp;
+	struct mgmt_cp_pin_code_reply *cp = data;
+	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-								ENETDOWN);
-		goto failed;
-	}
-
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, index,
-								data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
-	}
-
-	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
-								&cp->bdaddr);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_add_dev_white_list(struct sock *sk, u16 index,
-					unsigned char *data, u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_le_add_dev_white_list *cp;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
-								ENETDOWN);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	hci_le_add_dev_white_list(hdev, &cp->bdaddr);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_remove_dev_white_list(struct sock *sk, u16 index,
-					unsigned char *data, u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_cp_le_remove_dev_white_list *cp;
-	int err = 0;
-
-	BT_DBG("");
-
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
-								ENETDOWN);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);
+	if (!conn) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+				 MGMT_STATUS_NOT_CONNECTED);
 		goto failed;
 	}
 
-	hci_le_remove_dev_white_list(hdev, &cp->bdaddr);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_create_conn_white_list(struct sock *sk, u16 index)
-{
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	u8 sec_level, auth_type;
-	struct pending_cmd *cmd;
-	bdaddr_t bdaddr;
-	int err = 0;
+	if (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {
+		struct mgmt_cp_pin_code_neg_reply ncp;
 
-	BT_DBG("");
+		memcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
-									ENODEV);
+		BT_ERR("PIN code is not 16 bytes long");
 
-	hci_dev_lock_bh(hdev);
+		err = send_pin_code_neg_reply(sk, hdev, &ncp);
+		if (err >= 0)
+			err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+					 MGMT_STATUS_INVALID_PARAMS);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
-								ENETDOWN);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index,
-								NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	sec_level = BT_SECURITY_MEDIUM;
-	auth_type = HCI_AT_GENERAL_BONDING;
-	memset(&bdaddr, 0, sizeof(bdaddr));
-	conn = hci_le_connect(hdev, 0, BDADDR_ANY, sec_level, auth_type, NULL);
-	if (IS_ERR(conn)) {
-		err = PTR_ERR(conn);
-		mgmt_pending_remove(cmd);
-	}
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_cancel_create_conn_white_list(struct sock *sk, u16 index)
-{
-	struct hci_dev *hdev;
-	int err = 0;
-
-	BT_DBG("");
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index,
-			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index,
-			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENETDOWN);
-		goto failed;
-	}
+	bacpy(&reply.bdaddr, &cp->addr.bdaddr);
+	reply.pin_len = cp->pin_len;
+	memcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));
 
-	hci_le_cancel_create_connect(hdev, BDADDR_ANY);
+	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int le_clear_white_list(struct sock *sk, u16 index)
+static int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,
+			      void *data, u16 len)
 {
-	struct hci_dev *hdev;
+	struct mgmt_cp_pin_code_neg_reply *cp = data;
 	int err;
 
 	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index,
-			MGMT_OP_LE_CLEAR_WHITE_LIST, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index,
-			MGMT_OP_LE_CLEAR_WHITE_LIST, ENETDOWN);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY,
+				 MGMT_STATUS_NOT_POWERED);
 		goto failed;
 	}
 
-	err = hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
+	err = send_pin_code_neg_reply(sk, hdev, cp);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int set_io_capability(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,
+			     u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_set_io_capability *cp;
+	struct mgmt_cp_set_io_capability *cp = data;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
 	hdev->io_capability = cp->io_capability;
 
 	BT_DBG("%s IO capability set to 0x%02x", hdev->name,
 							hdev->io_capability);
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
-	return cmd_complete(sk, index, MGMT_OP_SET_IO_CAPABILITY, NULL, 0);
+	return cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0, NULL,
+			    0);
 }
 
 static inline struct pending_cmd *find_pairing(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	struct list_head *p;
-
-	list_for_each(p, &cmd_list) {
-		struct pending_cmd *cmd;
-
-		cmd = list_entry(p, struct pending_cmd, list);
+	struct pending_cmd *cmd;
 
+	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
 		if (cmd->opcode != MGMT_OP_PAIR_DEVICE)
 			continue;
 
-		if (cmd->index != hdev->id)
-			continue;
-
 		if (cmd->user_data != conn)
 			continue;
 
@@ -1696,18 +1835,19 @@
 	struct mgmt_rp_pair_device rp;
 	struct hci_conn *conn = cmd->user_data;
 
-	BT_DBG(" %u", status);
-
-	bacpy(&rp.bdaddr, &conn->dst);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, &conn->dst);
+	rp.addr.type = link_to_mgmt(conn->type, conn->dst_type);
 
-	cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, &rp, sizeof(rp));
+	cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, status,
+		     &rp, sizeof(rp));
 
 	/* So we don't get further callbacks for this connection */
 	conn->connect_cfm_cb = NULL;
 	conn->security_cfm_cb = NULL;
 	conn->disconn_cfm_cb = NULL;
 
+	hci_conn_put(conn);
+
 	mgmt_pending_remove(cmd);
 }
 
@@ -1715,141 +1855,80 @@
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG(" %u", status);
-
-	cmd = find_pairing(conn);
-	if (!cmd) {
-		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	pairing_complete(cmd, status);
-	hci_conn_put(conn);
-}
-
-static void pairing_security_complete_cb(struct hci_conn *conn, u8 status)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG(" %u", status);
+	BT_DBG("status %u", status);
 
 	cmd = find_pairing(conn);
-	if (!cmd) {
+	if (!cmd)
 		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	if (conn->type == LE_LINK)
-		smp_link_encrypt_cmplt(conn->l2cap_data, status,
-				status ? 0 : 1);
 	else
-		pairing_complete(cmd, status);
-}
-
-static void pairing_connect_complete_cb(struct hci_conn *conn, u8 status)
-{
-	struct pending_cmd *cmd;
-
-	BT_DBG("conn: %p %u", conn, status);
-
-	cmd = find_pairing(conn);
-	if (!cmd) {
-		BT_DBG("Unable to find a pending command");
-		return;
-	}
-
-	if (status || conn->pending_sec_level < BT_SECURITY_MEDIUM)
-		pairing_complete(cmd, status);
-
-	hci_conn_put(conn);
-}
-
-static void discovery_terminated(struct pending_cmd *cmd, void *data)
-{
-	struct hci_dev *hdev;
-	struct mgmt_mode ev = {0};
-
-	BT_DBG("");
-	hdev = hci_dev_get(cmd->index);
-	if (!hdev)
-		goto not_found;
-
-	del_timer(&hdev->disco_le_timer);
-	del_timer(&hdev->disco_timer);
-	hci_dev_put(hdev);
-
-not_found:
-	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
-
-	list_del(&cmd->list);
-
-	mgmt_pending_free(cmd);
+		pairing_complete(cmd, mgmt_status(status));
 }
 
-static int pair_device(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+		       u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_pair_device *cp;
+	struct mgmt_cp_pair_device *cp = data;
+	struct mgmt_rp_pair_device rp;
 	struct pending_cmd *cmd;
-	u8 sec_level, auth_type, io_cap;
+	u8 sec_level, auth_type;
 	struct hci_conn *conn;
-	struct adv_entry *entry;
 	int err;
 
 	BT_DBG("");
 
-	cp = (void *) data;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EINVAL);
-
-	hdev = hci_dev_get(index);
-
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
-
-	io_cap = cp->io_cap;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
 
 	sec_level = BT_SECURITY_MEDIUM;
-	auth_type = HCI_AT_DEDICATED_BONDING;
+	if (cp->io_cap == 0x03)
+		auth_type = HCI_AT_DEDICATED_BONDING;
+	else
+		auth_type = HCI_AT_DEDICATED_BONDING_MITM;
 
-	entry = hci_find_adv_entry(hdev, &cp->bdaddr);
-	if (entry && entry->flags & 0x04) {
-		conn = hci_le_connect(hdev, 0, &cp->bdaddr, sec_level,
-							auth_type, NULL);
-	} else {
-		/* ACL-SSP does not support io_cap 0x04 (KeyboadDisplay) */
-		if (io_cap == 0x04)
-			io_cap = 0x01;
-		conn = hci_connect(hdev, ACL_LINK, 0, &cp->bdaddr, sec_level,
-								auth_type);
-		conn->auth_initiator = 1;
-	}
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn = hci_connect(hdev, ACL_LINK, &cp->addr.bdaddr, sec_level,
+				   auth_type);
+	else
+		conn = hci_connect(hdev, LE_LINK, &cp->addr.bdaddr, sec_level,
+				   auth_type);
+
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
 	if (IS_ERR(conn)) {
-		err = PTR_ERR(conn);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				   MGMT_STATUS_CONNECT_FAILED, &rp,
+				   sizeof(rp));
 		goto unlock;
 	}
 
 	if (conn->connect_cfm_cb) {
 		hci_conn_put(conn);
-		err = cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EBUSY);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,
+				   MGMT_STATUS_BUSY, &rp, sizeof(rp));
 		goto unlock;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		hci_conn_put(conn);
 		goto unlock;
 	}
 
-	conn->connect_cfm_cb = pairing_connect_complete_cb;
-	conn->security_cfm_cb = pairing_security_complete_cb;
+	/* For LE, just connecting isn't a proof that the pairing finished */
+	if (cp->addr.type == MGMT_ADDR_BREDR)
+		conn->connect_cfm_cb = pairing_complete_cb;
+
+	conn->security_cfm_cb = pairing_complete_cb;
 	conn->disconn_cfm_cb = pairing_complete_cb;
-	conn->io_capability = io_cap;
+	conn->io_capability = cp->io_cap;
 	cmd->user_data = conn;
 
 	if (conn->state == BT_CONNECTED &&
@@ -1859,742 +1938,726 @@
 	err = 0;
 
 unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int user_confirm_reply(struct sock *sk, u16 index, unsigned char *data,
-							u16 len, u16 opcode)
+static int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_user_confirm_reply *cp = (void *) data;
-	u16 mgmt_op = opcode, hci_op;
+	struct mgmt_addr_info *addr = data;
 	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
-	struct hci_conn *le_conn;
+	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("%d", mgmt_op);
-
-	if (mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY)
-		hci_op = HCI_OP_USER_CONFIRM_NEG_REPLY;
-	else
-		hci_op = HCI_OP_USER_CONFIRM_REPLY;
-
-	if (len < sizeof(*cp))
-		return cmd_status(sk, index, mgmt_op, EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, mgmt_op, ENODEV);
-
-	hci_dev_lock_bh(hdev);
+	BT_DBG("");
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, mgmt_op, ENETDOWN);
-		goto done;
-	}
+	hci_dev_lock(hdev);
 
-	le_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-	if (le_conn) {
-		err = le_user_confirm_reply(le_conn, mgmt_op, (void *) cp);
-		goto done;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
 	}
-	BT_DBG("BR/EDR: %s", mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY ?
-							"Reject" : "Accept");
 
-	cmd = mgmt_pending_add(sk, mgmt_op, index, data, len);
+	cmd = mgmt_pending_find(MGMT_OP_PAIR_DEVICE, hdev);
 	if (!cmd) {
-		err = -ENOMEM;
-		goto done;
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto unlock;
 	}
 
-	err = hci_send_cmd(hdev, hci_op, sizeof(cp->bdaddr), &cp->bdaddr);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
+	conn = cmd->user_data;
 
-done:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (bacmp(&addr->bdaddr, &conn->dst) != 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto unlock;
+	}
 
+	pairing_complete(cmd, MGMT_STATUS_CANCELLED);
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,
+			   addr, sizeof(*addr));
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int resolve_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,
+			     bdaddr_t *bdaddr, u8 type, u16 mgmt_op,
+			     u16 hci_op, __le32 passkey)
 {
-	struct mgmt_cp_resolve_name *mgmt_cp = (void *) data;
-	struct hci_cp_remote_name_req hci_cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
+	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("");
+	hci_dev_lock(hdev);
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, EINVAL);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, mgmt_op,
+				 MGMT_STATUS_NOT_POWERED);
+		goto done;
+	}
+
+	if (type == MGMT_ADDR_BREDR)
+		conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+	else
+		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, bdaddr);
+
+	if (!conn) {
+		err = cmd_status(sk, hdev->id, mgmt_op,
+				 MGMT_STATUS_NOT_CONNECTED);
+		goto done;
+	}
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, ENODEV);
+	if (type == MGMT_ADDR_LE_PUBLIC || type == MGMT_ADDR_LE_RANDOM) {
+		/* Continue with pairing via SMP */
+		err = smp_user_confirm_reply(conn, mgmt_op, passkey);
+
+		if (!err)
+			err = cmd_status(sk, hdev->id, mgmt_op,
+					 MGMT_STATUS_SUCCESS);
+		else
+			err = cmd_status(sk, hdev->id, mgmt_op,
+					 MGMT_STATUS_FAILED);
 
-	hci_dev_lock_bh(hdev);
+		goto done;
+	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_RESOLVE_NAME, index, data, len);
+	cmd = mgmt_pending_add(sk, mgmt_op, hdev, bdaddr, sizeof(*bdaddr));
 	if (!cmd) {
 		err = -ENOMEM;
-		goto failed;
+		goto done;
 	}
 
-	memset(&hci_cp, 0, sizeof(hci_cp));
-	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
-	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(hci_cp),
-								&hci_cp);
+	/* Continue with pairing via HCI */
+	if (hci_op == HCI_OP_USER_PASSKEY_REPLY) {
+		struct hci_cp_user_passkey_reply cp;
+
+		bacpy(&cp.bdaddr, bdaddr);
+		cp.passkey = passkey;
+		err = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);
+	} else
+		err = hci_send_cmd(hdev, hci_op, sizeof(*bdaddr), bdaddr);
+
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+done:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int cancel_resolve_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_cancel_resolve_name *mgmt_cp = (void *) data;
-	struct hci_cp_remote_name_req_cancel hci_cp;
-	struct hci_dev *hdev;
-	int err;
+	struct mgmt_cp_user_confirm_reply *cp = data;
 
 	BT_DBG("");
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
-								EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
-								ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	memset(&hci_cp, 0, sizeof(hci_cp));
-	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
-	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(hci_cp),
-								&hci_cp);
-
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	if (len != sizeof(*cp))
+		return cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,
+				  MGMT_STATUS_INVALID_PARAMS);
 
-	return err;
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_CONFIRM_REPLY,
+				 HCI_OP_USER_CONFIRM_REPLY, 0);
 }
 
-static int set_connection_params(struct sock *sk, u16 index,
-				unsigned char *data, u16 len)
+static int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				  void *data, u16 len)
 {
-	struct mgmt_cp_set_connection_params *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err;
+	struct mgmt_cp_user_confirm_neg_reply *cp = data;
 
 	BT_DBG("");
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-									ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
-								ENOTCONN);
-		goto failed;
-	}
-
-	hci_le_conn_update(conn, le16_to_cpu(cp->interval_min),
-				le16_to_cpu(cp->interval_max),
-				le16_to_cpu(cp->slave_latency),
-				le16_to_cpu(cp->timeout_multiplier));
-
-	err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS, 0);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_CONFIRM_NEG_REPLY,
+				 HCI_OP_USER_CONFIRM_NEG_REPLY, 0);
 }
 
-static int set_rssi_reporter(struct sock *sk, u16 index,
-				unsigned char *data, u16 len)
+static int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,
+			      u16 len)
 {
-	struct mgmt_cp_set_rssi_reporter *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err = 0;
+	struct mgmt_cp_user_passkey_reply *cp = data;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-								EINVAL);
+	BT_DBG("");
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-							ENODEV);
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_PASSKEY_REPLY,
+				 HCI_OP_USER_PASSKEY_REPLY, cp->passkey);
+}
 
-	hci_dev_lock_bh(hdev);
+static int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,
+				  void *data, u16 len)
+{
+	struct mgmt_cp_user_passkey_neg_reply *cp = data;
 
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+	BT_DBG("");
 
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
-						ENOTCONN);
-		goto failed;
-	}
+	return user_pairing_resp(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
+				 MGMT_OP_USER_PASSKEY_NEG_REPLY,
+				 HCI_OP_USER_PASSKEY_NEG_REPLY, 0);
+}
 
-	BT_DBG("updateOnThreshExceed %d ", cp->updateOnThreshExceed);
-	hci_conn_set_rssi_reporter(conn, cp->rssi_threshold,
-			__le16_to_cpu(cp->interval), cp->updateOnThreshExceed);
+static int update_name(struct hci_dev *hdev, const char *name)
+{
+	struct hci_cp_write_local_name cp;
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	memcpy(cp.name, name, sizeof(cp.name));
 
-	return err;
+	return hci_send_cmd(hdev, HCI_OP_WRITE_LOCAL_NAME, sizeof(cp), &cp);
 }
 
-static int unset_rssi_reporter(struct sock *sk, u16 index,
-			unsigned char *data, u16 len)
+static int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct mgmt_cp_unset_rssi_reporter *cp = (void *) data;
-	struct hci_dev *hdev;
-	struct hci_conn *conn;
-	int err = 0;
+	struct mgmt_cp_set_local_name *cp = data;
+	struct pending_cmd *cmd;
+	int err;
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					EINVAL);
+	BT_DBG("");
 
-	hdev = hci_dev_get(index);
+	hci_dev_lock(hdev);
 
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					ENODEV);
+	memcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));
 
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		memcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));
+
+		err = cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,
+				   data, len);
+		if (err < 0)
+			goto failed;
 
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+		err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, data, len,
+				 sk);
 
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
-					ENOTCONN);
 		goto failed;
 	}
 
-	hci_conn_unset_rssi_reporter(conn);
-
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int le_cancel_create_conn(struct sock *sk, u16 index,
-	unsigned char *data, u16 len)
-{
-	struct mgmt_cp_le_cancel_create_conn *cp = (void *) data;
-	struct hci_dev *hdev;
-	int err = 0;
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-							EINVAL);
-
-	hdev = hci_dev_get(index);
-
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-							ENODEV);
-
-	hci_dev_lock_bh(hdev);
-
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
-						ENETDOWN);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
 		goto failed;
 	}
 
-	hci_le_cancel_create_connect(hdev, &cp->bdaddr);
+	err = update_name(hdev, cp->name);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
-return err;
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int set_local_name(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,
+			       void *data, u16 data_len)
 {
-	struct mgmt_cp_set_local_name *mgmt_cp = (void *) data;
-	struct hci_cp_write_local_name hci_cp;
-	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, EINVAL);
+	hci_dev_lock(hdev);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, ENODEV);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_NOT_POWERED);
+		goto unlock;
+	}
+
+	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_NOT_SUPPORTED);
+		goto unlock;
+	}
 
-	hci_dev_lock_bh(hdev);
+	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 MGMT_STATUS_BUSY);
+		goto unlock;
+	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, index, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
-		goto failed;
+		goto unlock;
 	}
 
-	memcpy(hci_cp.name, mgmt_cp->name, sizeof(hci_cp.name));
-	err = hci_send_cmd(hdev, HCI_OP_WRITE_LOCAL_NAME, sizeof(hci_cp),
-								&hci_cp);
+	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-
+unlock:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static void discovery_rsp(struct pending_cmd *cmd, void *data)
-{
-	struct mgmt_mode ev;
-
-	BT_DBG("");
-	if (cmd->opcode == MGMT_OP_START_DISCOVERY) {
-		ev.val = 1;
-		cmd_status(cmd->sk, cmd->index, MGMT_OP_START_DISCOVERY, 0);
-	} else {
-		ev.val = 0;
-		cmd_complete(cmd->sk, cmd->index, MGMT_OP_STOP_DISCOVERY,
-								NULL, 0);
-		if (cmd->opcode == MGMT_OP_STOP_DISCOVERY) {
-			struct hci_dev *hdev = hci_dev_get(cmd->index);
-			if (hdev) {
-				del_timer(&hdev->disco_le_timer);
-				del_timer(&hdev->disco_timer);
-				hci_dev_put(hdev);
-			}
-		}
-	}
-
-	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
-
-	list_del(&cmd->list);
-
-	mgmt_pending_free(cmd);
-}
-
-void mgmt_inquiry_started(u16 index)
-{
-	BT_DBG("");
-	mgmt_pending_foreach(MGMT_OP_START_DISCOVERY, index,
-						discovery_rsp, NULL);
-}
-
-void mgmt_inquiry_complete_evt(u16 index, u8 status)
+static int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
+			       void *data, u16 len)
 {
-	struct hci_dev *hdev;
-	struct hci_cp_le_set_scan_enable le_cp = {1, 0};
-	struct mgmt_mode cp = {0};
-	int err = -1;
-
-	hdev = hci_dev_get(index);
-
-	if (hdev)
-		BT_DBG("disco_state: %d", hdev->disco_state);
-
-	if (!hdev || !lmp_le_capable(hdev)) {
-
-		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
-
-		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
+	struct mgmt_cp_add_remote_oob_data *cp = data;
+	u8 status;
+	int err;
 
-		hdev->disco_state = SCAN_IDLE;
+	BT_DBG("%s ", hdev->name);
 
-		if (hdev)
-			goto done;
-		else
-			return;
-	}
+	hci_dev_lock(hdev);
 
-	if (hdev->disco_state != SCAN_IDLE) {
-		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-						sizeof(le_cp), &le_cp);
-		if (err >= 0) {
-			mod_timer(&hdev->disco_le_timer, jiffies +
-				msecs_to_jiffies(hdev->disco_int_phase * 1000));
-			hdev->disco_state = SCAN_LE;
-		} else
-			hdev->disco_state = SCAN_IDLE;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA,
+				   MGMT_STATUS_NOT_POWERED, &cp->addr,
+				   sizeof(cp->addr));
+		goto unlock;
 	}
 
-	if (hdev->disco_state == SCAN_IDLE)
-		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
-
+	err = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr, cp->hash,
+				      cp->randomizer);
 	if (err < 0)
-		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
+		status = MGMT_STATUS_FAILED;
+	else
+		status = 0;
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA, status,
+			   &cp->addr, sizeof(cp->addr));
 
-done:
-	hci_dev_put(hdev);
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-void mgmt_disco_timeout(unsigned long data)
+static int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,
+						void *data, u16 len)
 {
-	struct hci_dev *hdev = (void *) data;
-	struct pending_cmd *cmd;
-	struct mgmt_mode cp = {0};
-
-	BT_DBG("hci%d", hdev->id);
-
-	hdev = hci_dev_get(hdev->id);
-
-	if (!hdev)
-		return;
+	struct mgmt_cp_remove_remote_oob_data *cp = data;
+	u8 status;
+	int err;
 
-	hci_dev_lock_bh(hdev);
-	del_timer(&hdev->disco_le_timer);
+	BT_DBG("%s", hdev->name);
 
-	if (hdev->disco_state != SCAN_IDLE) {
-		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
+	hci_dev_lock(hdev);
 
-		if (test_bit(HCI_UP, &hdev->flags)) {
-			if (hdev->disco_state == SCAN_LE)
-				hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-							sizeof(le_cp), &le_cp);
-			else
-				hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0,
-									 NULL);
-		}
-		hdev->disco_state = SCAN_IDLE;
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_complete(sk, hdev->id,
+				   MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+				   MGMT_STATUS_NOT_POWERED, &cp->addr,
+				   sizeof(cp->addr));
+		goto unlock;
 	}
 
-	mgmt_event(MGMT_EV_DISCOVERING, hdev->id, &cp, sizeof(cp), NULL);
+	err = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr);
+	if (err < 0)
+		status = MGMT_STATUS_INVALID_PARAMS;
+	else
+		status = 0;
 
-	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev->id);
-	if (cmd)
-		mgmt_pending_remove(cmd);
+	err = cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+			   status, &cp->addr, sizeof(cp->addr));
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-void mgmt_disco_le_timeout(unsigned long data)
+int mgmt_interleaved_discovery(struct hci_dev *hdev)
 {
-	struct hci_dev *hdev = (void *)data;
-	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-
-	BT_DBG("hci%d", hdev->id);
+	int err;
 
-	hdev = hci_dev_get(hdev->id);
+	BT_DBG("%s", hdev->name);
 
-	if (!hdev)
-		return;
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	err = hci_do_inquiry(hdev, INQUIRY_LEN_BREDR_LE);
+	if (err < 0)
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
 
-	if (test_bit(HCI_UP, &hdev->flags)) {
-		if (hdev->disco_state == SCAN_LE)
-			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-					sizeof(le_cp), &le_cp);
-
-	/* re-start BR scan */
-		if (hdev->disco_state != SCAN_IDLE) {
-			struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
-			hdev->disco_int_phase *= 2;
-			hdev->disco_int_count = 0;
-			cp.num_rsp = (u8) hdev->disco_int_phase;
-			hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
-			hdev->disco_state = SCAN_BR;
-		}
-	}
+	hci_dev_unlock(hdev);
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	return err;
 }
 
-static int start_discovery(struct sock *sk, u16 index)
+static int start_discovery(struct sock *sk, struct hci_dev *hdev,
+			   void *data, u16 len)
 {
-	struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 8, 0};
-	struct hci_dev *hdev;
+	struct mgmt_cp_start_discovery *cp = data;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, ENODEV);
+	hci_dev_lock(hdev);
 
-	BT_DBG("disco_state: %d", hdev->disco_state);
-	hci_dev_lock_bh(hdev);
+	if (!hdev_is_powered(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,
+				 MGMT_STATUS_NOT_POWERED);
+		goto failed;
+	}
 
-	if (hdev->disco_state && timer_pending(&hdev->disco_timer)) {
-		err = -EBUSY;
+	if (hdev->discovery.state != DISCOVERY_STOPPED) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_START_DISCOVERY,
+				 MGMT_STATUS_BUSY);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, index, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, hdev, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	/* If LE Capable, we will alternate between BR/EDR and LE */
-	if (lmp_le_capable(hdev)) {
-		struct hci_cp_le_set_scan_parameters le_cp;
-
-		/* Shorten BR scan params */
-		cp.num_rsp = 1;
-		cp.length /= 2;
-
-		/* Setup LE scan params */
-		memset(&le_cp, 0, sizeof(le_cp));
-		le_cp.type = 0x01;		/* Active scanning */
-		/* The recommended value for scan interval and window is
-		 * 11.25 msec. It is calculated by: time = n * 0.625 msec */
-		le_cp.interval = cpu_to_le16(0x0012);
-		le_cp.window = cpu_to_le16(0x0012);
-		le_cp.own_bdaddr_type = 0;	/* Public address */
-		le_cp.filter = 0;		/* Accept all adv packets */
+	hdev->discovery.type = cp->type;
 
-		hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_PARAMETERS,
-						sizeof(le_cp), &le_cp);
-	}
+	switch (hdev->discovery.type) {
+	case DISCOV_TYPE_BREDR:
+		if (lmp_bredr_capable(hdev))
+			err = hci_do_inquiry(hdev, INQUIRY_LEN_BREDR);
+		else
+			err = -ENOTSUPP;
+		break;
 
-	err = hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+	case DISCOV_TYPE_LE:
+		if (lmp_host_le_capable(hdev))
+			err = hci_le_scan(hdev, LE_SCAN_TYPE, LE_SCAN_INT,
+					  LE_SCAN_WIN, LE_SCAN_TIMEOUT_LE_ONLY);
+		else
+			err = -ENOTSUPP;
+		break;
 
-	if (err < 0) {
-		mgmt_pending_remove(cmd);
-		hdev->disco_state = SCAN_IDLE;
-	} else if (lmp_le_capable(hdev)) {
-		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
-		if (!cmd)
-			mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, index,
-								NULL, 0);
-		hdev->disco_int_phase = 1;
-		hdev->disco_int_count = 0;
-		hdev->disco_state = SCAN_BR;
-		del_timer(&hdev->disco_le_timer);
-		del_timer(&hdev->disco_timer);
-		mod_timer(&hdev->disco_timer,
-				jiffies + msecs_to_jiffies(20000));
-	} else
-		hdev->disco_state = SCAN_BR;
+	case DISCOV_TYPE_INTERLEAVED:
+		if (lmp_host_le_capable(hdev) && lmp_bredr_capable(hdev))
+			err = hci_le_scan(hdev, LE_SCAN_TYPE, LE_SCAN_INT,
+					  LE_SCAN_WIN,
+					  LE_SCAN_TIMEOUT_BREDR_LE);
+		else
+			err = -ENOTSUPP;
+		break;
 
-failed:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	default:
+		err = -EINVAL;
+	}
 
 	if (err < 0)
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, -err);
+		mgmt_pending_remove(cmd);
+	else
+		hci_discovery_set_state(hdev, DISCOVERY_STARTING);
 
+failed:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
-static int stop_discovery(struct sock *sk, u16 index)
+static int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-	struct mgmt_mode mode_cp = {0};
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd = NULL;
-	int err = -EPERM;
-	u8 state;
+	struct mgmt_cp_stop_discovery *mgmt_cp = data;
+	struct pending_cmd *cmd;
+	struct hci_cp_remote_name_req_cancel cp;
+	struct inquiry_entry *e;
+	int err;
 
-	BT_DBG("");
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, ENODEV);
-
-	BT_DBG("disco_state: %d", hdev->disco_state);
-
-	hci_dev_lock_bh(hdev);
-
-	state = hdev->disco_state;
-	hdev->disco_state = SCAN_IDLE;
-	del_timer(&hdev->disco_le_timer);
-	del_timer(&hdev->disco_timer);
-
-	if (state == SCAN_LE) {
-		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-							sizeof(le_cp), &le_cp);
-		if (err >= 0) {
-			mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
-						discovery_terminated, NULL);
+	hci_dev_lock(hdev);
 
-			err = cmd_complete(sk, index, MGMT_OP_STOP_DISCOVERY,
-								NULL, 0);
-		}
-	} else if (state == SCAN_BR)
-		err = hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
+	if (!hci_discovery_active(hdev)) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,
+				   MGMT_STATUS_REJECTED, &mgmt_cp->type,
+				   sizeof(mgmt_cp->type));
+		goto unlock;
+	}
 
-	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
-	if (err < 0 && cmd)
-		mgmt_pending_remove(cmd);
+	if (hdev->discovery.type != mgmt_cp->type) {
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,
+				   MGMT_STATUS_INVALID_PARAMS, &mgmt_cp->type,
+				   sizeof(mgmt_cp->type));
+		goto unlock;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, NULL, 0);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto unlock;
+	}
 
-	mgmt_event(MGMT_EV_DISCOVERING, index, &mode_cp, sizeof(mode_cp), NULL);
+	if (hdev->discovery.state == DISCOVERY_FINDING) {
+		err = hci_cancel_inquiry(hdev);
+		if (err < 0)
+			mgmt_pending_remove(cmd);
+		else
+			hci_discovery_set_state(hdev, DISCOVERY_STOPPING);
+		goto unlock;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	e = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_PENDING);
+	if (!e) {
+		mgmt_pending_remove(cmd);
+		err = cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY, 0,
+				   &mgmt_cp->type, sizeof(mgmt_cp->type));
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+		goto unlock;
+	}
 
+	bacpy(&cp.bdaddr, &e->data.bdaddr);
+	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(cp),
+			   &cp);
 	if (err < 0)
-		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, -err);
+		mgmt_pending_remove(cmd);
 	else
-		return err;
+		hci_discovery_set_state(hdev, DISCOVERY_STOPPING);
+
+unlock:
+	hci_dev_unlock(hdev);
+	return err;
 }
 
-static int read_local_oob_data(struct sock *sk, u16 index)
+static int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
 {
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
+	struct mgmt_cp_confirm_name *cp = data;
+	struct inquiry_entry *e;
 	int err;
 
-	BT_DBG("hci%u", index);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-									ENODEV);
+	BT_DBG("%s", hdev->name);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-								ENETDOWN);
-		goto unlock;
+	if (!hci_discovery_active(hdev)) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,
+				 MGMT_STATUS_FAILED);
+		goto failed;
 	}
 
-	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-								EOPNOTSUPP);
-		goto unlock;
+	e = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);
+	if (!e) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_CONFIRM_NAME,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA, EBUSY);
-		goto unlock;
+	if (cp->name_known) {
+		e->name_state = NAME_KNOWN;
+		list_del(&e->list);
+	} else {
+		e->name_state = NAME_NEEDED;
+		hci_inquiry_cache_update_resolve(hdev, e);
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, index, NULL, 0);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto unlock;
-	}
+	err = 0;
 
-	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
+failed:
+	hci_dev_unlock(hdev);
+	return err;
+}
+
+static int block_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			u16 len)
+{
+	struct mgmt_cp_block_device *cp = data;
+	u8 status;
+	int err;
+
+	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	err = hci_blacklist_add(hdev, &cp->addr.bdaddr, cp->addr.type);
 	if (err < 0)
-		mgmt_pending_remove(cmd);
+		status = MGMT_STATUS_FAILED;
+	else
+		status = 0;
 
-unlock:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	err = cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,
+			   &cp->addr, sizeof(cp->addr));
+
+	hci_dev_unlock(hdev);
 
 	return err;
 }
 
-static int add_remote_oob_data(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+static int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,
+			  u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_add_remote_oob_data *cp = (void *) data;
+	struct mgmt_cp_unblock_device *cp = data;
+	u8 status;
 	int err;
 
-	BT_DBG("hci%u ", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-									EINVAL);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-									ENODEV);
+	BT_DBG("%s", hdev->name);
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	err = hci_add_remote_oob_data(hdev, &cp->bdaddr, cp->hash,
-								cp->randomizer);
+	err = hci_blacklist_del(hdev, &cp->addr.bdaddr, cp->addr.type);
 	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, -err);
+		status = MGMT_STATUS_INVALID_PARAMS;
 	else
-		err = cmd_complete(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, NULL,
-									0);
+		status = 0;
+
+	err = cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,
+			   &cp->addr, sizeof(cp->addr));
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	hci_dev_unlock(hdev);
 
 	return err;
 }
 
-static int remove_remote_oob_data(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+static int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,
+				void *data, u16 len)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_remove_remote_oob_data *cp = (void *) data;
+	struct mgmt_mode *cp = data;
+	struct hci_cp_write_page_scan_activity acp;
+	u8 type;
 	int err;
 
-	BT_DBG("hci%u ", index);
+	BT_DBG("%s", hdev->name);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									EINVAL);
+	if (!hdev_is_powered(hdev))
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				  MGMT_STATUS_NOT_POWERED);
+
+	if (!test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+		return cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				  MGMT_STATUS_REJECTED);
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									ENODEV);
+	hci_dev_lock(hdev);
 
-	hci_dev_lock_bh(hdev);
+	if (cp->val) {
+		type = PAGE_SCAN_TYPE_INTERLACED;
 
-	err = hci_remove_remote_oob_data(hdev, &cp->bdaddr);
-	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-									-err);
-	else
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-								NULL, 0);
+		/* 22.5 msec page scan interval */
+		acp.interval = __constant_cpu_to_le16(0x0024);
+	} else {
+		type = PAGE_SCAN_TYPE_STANDARD;	/* default */
+
+		/* default 1.28 sec page scan */
+		acp.interval = __constant_cpu_to_le16(0x0800);
+	}
+
+	/* default 11.25 msec page scan window */
+	acp.window = __constant_cpu_to_le16(0x0012);
+
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY, sizeof(acp),
+			   &acp);
+	if (err < 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				 MGMT_STATUS_FAILED);
+		goto done;
+	}
 
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
+	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_TYPE, 1, &type);
+	if (err < 0) {
+		err = cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,
+				 MGMT_STATUS_FAILED);
+		goto done;
+	}
 
+	err = cmd_complete(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE, 0,
+			   NULL, 0);
+done:
+	hci_dev_unlock(hdev);
 	return err;
 }
 
+static int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,
+			       void *cp_data, u16 len)
+{
+	struct mgmt_cp_load_long_term_keys *cp = cp_data;
+	u16 key_count, expected_len;
+	int i;
+
+	key_count = get_unaligned_le16(&cp->key_count);
+
+	expected_len = sizeof(*cp) + key_count *
+					sizeof(struct mgmt_ltk_info);
+	if (expected_len != len) {
+		BT_ERR("load_keys: expected %u bytes, got %u bytes",
+							len, expected_len);
+		return cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,
+				  EINVAL);
+	}
+
+	BT_DBG("%s key_count %u", hdev->name, key_count);
+
+	hci_dev_lock(hdev);
+
+	hci_smp_ltks_clear(hdev);
+
+	for (i = 0; i < key_count; i++) {
+		struct mgmt_ltk_info *key = &cp->keys[i];
+		u8 type;
+
+		if (key->master)
+			type = HCI_SMP_LTK;
+		else
+			type = HCI_SMP_LTK_SLAVE;
+
+		hci_add_ltk(hdev, &key->addr.bdaddr, key->addr.type,
+			    type, 0, key->authenticated, key->val,
+			    key->enc_size, key->ediv, key->rand);
+	}
+
+	hci_dev_unlock(hdev);
+
+	return 0;
+}
+
+struct mgmt_handler {
+	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
+		     u16 data_len);
+	bool var_len;
+	size_t data_len;
+} mgmt_handlers[] = {
+	{ NULL }, /* 0x0000 (no command) */
+	{ read_version,           false, MGMT_READ_VERSION_SIZE },
+	{ read_commands,          false, MGMT_READ_COMMANDS_SIZE },
+	{ read_index_list,        false, MGMT_READ_INDEX_LIST_SIZE },
+	{ read_controller_info,   false, MGMT_READ_INFO_SIZE },
+	{ set_powered,            false, MGMT_SETTING_SIZE },
+	{ set_discoverable,       false, MGMT_SET_DISCOVERABLE_SIZE },
+	{ set_connectable,        false, MGMT_SETTING_SIZE },
+	{ set_fast_connectable,   false, MGMT_SETTING_SIZE },
+	{ set_pairable,           false, MGMT_SETTING_SIZE },
+	{ set_link_security,      false, MGMT_SETTING_SIZE },
+	{ set_ssp,                false, MGMT_SETTING_SIZE },
+	{ set_hs,                 false, MGMT_SETTING_SIZE },
+	{ set_le,                 false, MGMT_SETTING_SIZE },
+	{ set_dev_class,          false, MGMT_SET_DEV_CLASS_SIZE },
+	{ set_local_name,         false, MGMT_SET_LOCAL_NAME_SIZE },
+	{ add_uuid,               false, MGMT_ADD_UUID_SIZE },
+	{ remove_uuid,            false, MGMT_REMOVE_UUID_SIZE },
+	{ load_link_keys,         true,  MGMT_LOAD_LINK_KEYS_SIZE },
+	{ load_long_term_keys,    true,  MGMT_LOAD_LONG_TERM_KEYS_SIZE },
+	{ disconnect,             false, MGMT_DISCONNECT_SIZE },
+	{ get_connections,        false, MGMT_GET_CONNECTIONS_SIZE },
+	{ pin_code_reply,         false, MGMT_PIN_CODE_REPLY_SIZE },
+	{ pin_code_neg_reply,     false, MGMT_PIN_CODE_NEG_REPLY_SIZE },
+	{ set_io_capability,      false, MGMT_SET_IO_CAPABILITY_SIZE },
+	{ pair_device,            false, MGMT_PAIR_DEVICE_SIZE },
+	{ cancel_pair_device,     false, MGMT_CANCEL_PAIR_DEVICE_SIZE },
+	{ unpair_device,          false, MGMT_UNPAIR_DEVICE_SIZE },
+	{ user_confirm_reply,     false, MGMT_USER_CONFIRM_REPLY_SIZE },
+	{ user_confirm_neg_reply, false, MGMT_USER_CONFIRM_NEG_REPLY_SIZE },
+	{ user_passkey_reply,     false, MGMT_USER_PASSKEY_REPLY_SIZE },
+	{ user_passkey_neg_reply, false, MGMT_USER_PASSKEY_NEG_REPLY_SIZE },
+	{ read_local_oob_data,    false, MGMT_READ_LOCAL_OOB_DATA_SIZE },
+	{ add_remote_oob_data,    false, MGMT_ADD_REMOTE_OOB_DATA_SIZE },
+	{ remove_remote_oob_data, false, MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },
+	{ start_discovery,        false, MGMT_START_DISCOVERY_SIZE },
+	{ stop_discovery,         false, MGMT_STOP_DISCOVERY_SIZE },
+	{ confirm_name,           false, MGMT_CONFIRM_NAME_SIZE },
+	{ block_device,           false, MGMT_BLOCK_DEVICE_SIZE },
+	{ unblock_device,         false, MGMT_UNBLOCK_DEVICE_SIZE },
+};
+
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 {
-	unsigned char *buf;
+	void *buf;
+	u8 *cp;
 	struct mgmt_hdr *hdr;
 	u16 opcode, index, len;
+	struct hci_dev *hdev = NULL;
+	struct mgmt_handler *handler;
 	int err;
 
 	BT_DBG("got %zu bytes", msglen);
@@ -2611,7 +2674,7 @@
 		goto done;
 	}
 
-	hdr = (struct mgmt_hdr *) buf;
+	hdr = buf;
 	opcode = get_unaligned_le16(&hdr->opcode);
 	index = get_unaligned_le16(&hdr->index);
 	len = get_unaligned_le16(&hdr->len);
@@ -2621,144 +2684,54 @@
 		goto done;
 	}
 
-	BT_DBG("got opcode %x", opcode);
-	switch (opcode) {
-	case MGMT_OP_READ_VERSION:
-		err = read_version(sk);
-		break;
-	case MGMT_OP_READ_INDEX_LIST:
-		err = read_index_list(sk);
-		break;
-	case MGMT_OP_READ_INFO:
-		err = read_controller_info(sk, index);
-		break;
-	case MGMT_OP_SET_POWERED:
-		err = set_powered(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_DISCOVERABLE:
-		err = set_discoverable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_LIMIT_DISCOVERABLE:
-		err = set_limited_discoverable(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_SET_CONNECTABLE:
-		err = set_connectable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_PAIRABLE:
-		err = set_pairable(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_ADD_UUID:
-		err = add_uuid(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_UUID:
-		err = remove_uuid(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_DEV_CLASS:
-		err = set_dev_class(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_SERVICE_CACHE:
-		err = set_service_cache(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_LOAD_KEYS:
-		err = load_keys(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_KEY:
-		err = remove_key(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_DISCONNECT:
-		err = disconnect(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_GET_CONNECTIONS:
-		err = get_connections(sk, index);
-		break;
-	case MGMT_OP_PIN_CODE_REPLY:
-		err = pin_code_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_PIN_CODE_NEG_REPLY:
-		err = pin_code_neg_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_IO_CAPABILITY:
-		err = set_io_capability(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_PAIR_DEVICE:
-		err = pair_device(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_USER_CONFIRM_REPLY:
-	case MGMT_OP_USER_PASSKEY_REPLY:
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		err = user_confirm_reply(sk, index, buf + sizeof(*hdr),
-								len, opcode);
-		break;
-	case MGMT_OP_SET_LOCAL_NAME:
-		err = set_local_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_START_DISCOVERY:
-		err = start_discovery(sk, index);
-		break;
-	case MGMT_OP_STOP_DISCOVERY:
-		err = stop_discovery(sk, index);
-		break;
-	case MGMT_OP_RESOLVE_NAME:
-		err = resolve_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_CANCEL_RESOLVE_NAME:
-		err = cancel_resolve_name(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_CONNECTION_PARAMS:
-		err = set_connection_params(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_SET_RSSI_REPORTER:
-		err = set_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_UNSET_RSSI_REPORTER:
-		err = unset_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_READ_LOCAL_OOB_DATA:
-		err = read_local_oob_data(sk, index);
-		break;
-	case MGMT_OP_ADD_REMOTE_OOB_DATA:
-		err = add_remote_oob_data(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_REMOVE_REMOTE_OOB_DATA:
-		err = remove_remote_oob_data(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_ENCRYPT_LINK:
-		err = encrypt_link(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_LE_ADD_DEV_WHITE_LIST:
-		err = le_add_dev_white_list(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_LE_REMOVE_DEV_WHITE_LIST:
-		err = le_remove_dev_white_list(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
-	case MGMT_OP_LE_CLEAR_WHITE_LIST:
-		err = le_clear_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CREATE_CONN_WHITE_LIST:
-		err = le_create_conn_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST:
-		err = le_cancel_create_conn_white_list(sk, index);
-		break;
-	case MGMT_OP_LE_CANCEL_CREATE_CONN:
-		err = le_cancel_create_conn(sk, index, buf + sizeof(*hdr), len);
-		break;
-	default:
+	if (index != MGMT_INDEX_NONE) {
+		hdev = hci_dev_get(index);
+		if (!hdev) {
+			err = cmd_status(sk, index, opcode,
+					 MGMT_STATUS_INVALID_INDEX);
+			goto done;
+		}
+	}
+
+	if (opcode >= ARRAY_SIZE(mgmt_handlers) ||
+					mgmt_handlers[opcode].func == NULL) {
 		BT_DBG("Unknown op %u", opcode);
-		err = cmd_status(sk, index, opcode, 0x01);
-		break;
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_UNKNOWN_COMMAND);
+		goto done;
+	}
+
+	if ((hdev && opcode < MGMT_OP_READ_INFO) ||
+			(!hdev && opcode >= MGMT_OP_READ_INFO)) {
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_INVALID_INDEX);
+		goto done;
+	}
+
+	handler = &mgmt_handlers[opcode];
+
+	if ((handler->var_len && len < handler->data_len) ||
+			(!handler->var_len && len != handler->data_len)) {
+		err = cmd_status(sk, index, opcode,
+				 MGMT_STATUS_INVALID_PARAMS);
+		goto done;
 	}
 
+	if (hdev)
+		mgmt_init_hdev(sk, hdev);
+
+	cp = buf + sizeof(*hdr);
+
+	err = handler->func(sk, hdev, cp, len);
 	if (err < 0)
 		goto done;
 
 	err = msglen;
 
 done:
+	if (hdev)
+		hci_dev_put(hdev);
+
 	kfree(buf);
 	return err;
 }
@@ -2771,175 +2744,247 @@
 	mgmt_pending_remove(cmd);
 }
 
-int mgmt_index_added(u16 index)
+int mgmt_index_added(struct hci_dev *hdev)
+{
+	return mgmt_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0, NULL);
+}
+
+int mgmt_index_removed(struct hci_dev *hdev)
+{
+	u8 status = MGMT_STATUS_INVALID_INDEX;
+
+	mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+
+	return mgmt_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0, NULL);
+}
+
+struct cmd_lookup {
+	struct sock *sk;
+	struct hci_dev *hdev;
+	u8 mgmt_status;
+};
+
+static void settings_rsp(struct pending_cmd *cmd, void *data)
 {
-	BT_DBG("%d", index);
-	return mgmt_event(MGMT_EV_INDEX_ADDED, index, NULL, 0, NULL);
+	struct cmd_lookup *match = data;
+
+	send_settings_rsp(cmd->sk, cmd->opcode, match->hdev);
+
+	list_del(&cmd->list);
+
+	if (match->sk == NULL) {
+		match->sk = cmd->sk;
+		sock_hold(match->sk);
+	}
+
+	mgmt_pending_free(cmd);
 }
 
-int mgmt_index_removed(u16 index)
+int mgmt_powered(struct hci_dev *hdev, u8 powered)
 {
-	u8 status = ENODEV;
+	struct cmd_lookup match = { NULL, hdev };
+	int err;
+
+	if (!test_bit(HCI_MGMT, &hdev->dev_flags))
+		return 0;
+
+	mgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);
+
+	if (powered) {
+		u8 scan = 0;
+
+		if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			scan |= SCAN_PAGE;
+		if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			scan |= SCAN_INQUIRY;
+
+		if (scan)
+			hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
+
+		if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags)) {
+			u8 ssp = 1;
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, 1, &ssp);
+		}
+
+		if (test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+			struct hci_cp_write_le_host_supported cp;
+
+			cp.le = 1;
+			cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
+
+			hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED,
+				     sizeof(cp), &cp);
+		}
+
+		update_class(hdev);
+		update_name(hdev, hdev->dev_name);
+		update_eir(hdev);
+	} else {
+		u8 status = MGMT_STATUS_NOT_POWERED;
+		mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+	}
 
-	BT_DBG("%d", index);
+	err = new_settings(hdev, match.sk);
 
-	mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
+	if (match.sk)
+		sock_put(match.sk);
 
-	return mgmt_event(MGMT_EV_INDEX_REMOVED, index, NULL, 0, NULL);
+	return err;
 }
 
-struct cmd_lookup {
-	u8 val;
-	struct sock *sk;
-};
-
-static void mode_rsp(struct pending_cmd *cmd, void *data)
+int mgmt_set_powered_failed(struct hci_dev *hdev, int err)
 {
-	struct mgmt_mode *cp = cmd->param;
-	struct cmd_lookup *match = data;
+	struct pending_cmd *cmd;
+	u8 status;
 
-	if (cp->val != match->val)
-		return;
+	cmd = mgmt_pending_find(MGMT_OP_SET_POWERED, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	send_mode_rsp(cmd->sk, cmd->opcode, cmd->index, cp->val);
+	if (err == -ERFKILL)
+		status = MGMT_STATUS_RFKILLED;
+	else
+		status = MGMT_STATUS_FAILED;
 
-	list_del(&cmd->list);
+	err = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);
 
-	if (match->sk == NULL) {
-		match->sk = cmd->sk;
-		sock_hold(match->sk);
-	}
+	mgmt_pending_remove(cmd);
 
-	mgmt_pending_free(cmd);
+	return err;
 }
 
-int mgmt_powered(u16 index, u8 powered)
+int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { powered, NULL };
-	int ret;
-
-	BT_DBG("hci%u %d", index, powered);
-
-	mgmt_pending_foreach(MGMT_OP_SET_POWERED, index, mode_rsp, &match);
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	if (!powered) {
-		u8 status = ENETDOWN;
-		mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
+	if (discoverable) {
+		if (!test_and_set_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_DISCOVERABLE, &hdev->dev_flags))
+			changed = true;
 	}
 
-	ev.val = powered;
+	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev, settings_rsp,
+			     &match);
 
-	ret = mgmt_event(MGMT_EV_POWERED, index, &ev, sizeof(ev), match.sk);
+	if (changed)
+		err = new_settings(hdev, match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
 
-	return ret;
+	return err;
 }
 
-int mgmt_discoverable(u16 index, u8 discoverable)
+int mgmt_connectable(struct hci_dev *hdev, u8 connectable)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { discoverable, NULL };
-	int ret;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, index, mode_rsp, &match);
+	if (connectable) {
+		if (!test_and_set_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_CONNECTABLE, &hdev->dev_flags))
+			changed = true;
+	}
 
-	ev.val = discoverable;
+	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev, settings_rsp,
+			     &match);
 
-	ret = mgmt_event(MGMT_EV_DISCOVERABLE, index, &ev, sizeof(ev),
-								match.sk);
+	if (changed)
+		err = new_settings(hdev, match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
 
-	return ret;
+	return err;
 }
 
-int mgmt_connectable(u16 index, u8 connectable)
+int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status)
 {
-	struct mgmt_mode ev;
-	struct cmd_lookup match = { connectable, NULL };
-	int ret;
-
-	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, index, mode_rsp, &match);
+	u8 mgmt_err = mgmt_status(status);
 
-	ev.val = connectable;
+	if (scan & SCAN_PAGE)
+		mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	ret = mgmt_event(MGMT_EV_CONNECTABLE, index, &ev, sizeof(ev), match.sk);
+	if (scan & SCAN_INQUIRY)
+		mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	if (match.sk)
-		sock_put(match.sk);
-
-	return ret;
+	return 0;
 }
 
-int mgmt_new_key(u16 index, struct link_key *key, u8 bonded)
+int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key, bool persistent)
 {
-	struct mgmt_ev_new_key *ev;
-	int err, total;
-
-	total = sizeof(struct mgmt_ev_new_key) + key->dlen;
-	ev = kzalloc(total, GFP_ATOMIC);
-	if (!ev)
-		return -ENOMEM;
-
-	bacpy(&ev->key.bdaddr, &key->bdaddr);
-	ev->key.addr_type = key->addr_type;
-	ev->key.key_type = key->key_type;
-	memcpy(ev->key.val, key->val, 16);
-	ev->key.pin_len = key->pin_len;
-	ev->key.auth = key->auth;
-	ev->store_hint = bonded;
-	ev->key.dlen = key->dlen;
-
-	memcpy(ev->key.data, key->data, key->dlen);
+	struct mgmt_ev_new_link_key ev;
 
-	err = mgmt_event(MGMT_EV_NEW_KEY, index, ev, total, NULL);
+	memset(&ev, 0, sizeof(ev));
 
-	kfree(ev);
+	ev.store_hint = persistent;
+	bacpy(&ev.key.addr.bdaddr, &key->bdaddr);
+	ev.key.addr.type = MGMT_ADDR_BREDR;
+	ev.key.type = key->type;
+	memcpy(ev.key.val, key->val, 16);
+	ev.key.pin_len = key->pin_len;
 
-	return err;
+	return mgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le)
+int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent)
 {
-	struct mgmt_ev_connected ev;
-	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
+	struct mgmt_ev_new_long_term_key ev;
 
-	BT_DBG("hci%u", index);
-
-	hdev = hci_dev_get(index);
+	memset(&ev, 0, sizeof(ev));
 
-	if (!hdev)
-		return -ENODEV;
+	ev.store_hint = persistent;
+	bacpy(&ev.key.addr.bdaddr, &key->bdaddr);
+	ev.key.addr.type = key->bdaddr_type;
+	ev.key.authenticated = key->authenticated;
+	ev.key.enc_size = key->enc_size;
+	ev.key.ediv = key->ediv;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.le = le;
+	if (key->type == HCI_SMP_LTK)
+		ev.key.master = 1;
 
-	cmd = mgmt_pending_find(MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index);
-	if (cmd) {
-		BT_ERR("mgmt_connected remove mgmt pending white_list");
-		mgmt_pending_remove(cmd);
-	}
+	memcpy(ev.key.rand, key->rand, sizeof(key->rand));
+	memcpy(ev.key.val, key->val, sizeof(key->val));
 
-	return mgmt_event(MGMT_EV_CONNECTED, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev),
+			  NULL);
 }
 
-int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
-						u16 latency, u16 timeout)
+int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			  u8 *dev_class)
 {
-	struct mgmt_ev_le_conn_params ev;
+	char buf[512];
+	struct mgmt_ev_device_connected *ev = (void *) buf;
+	u16 eir_len = 0;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.interval = interval;
-	ev.latency = latency;
-	ev.timeout = timeout;
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+
+	ev->flags = __cpu_to_le32(flags);
 
-	return mgmt_event(MGMT_EV_LE_CONN_PARAMS, index, &ev, sizeof(ev),
-									NULL);
+	if (name_len > 0)
+		eir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE,
+					  name, name_len);
+
+	if (dev_class && memcmp(dev_class, "\0\0\0", 3) != 0)
+		eir_len = eir_append_data(ev->eir, eir_len,
+					  EIR_CLASS_OF_DEV, dev_class, 3);
+
+	put_unaligned_le16(eir_len, &ev->eir_len);
+
+	return mgmt_event(MGMT_EV_DEVICE_CONNECTED, hdev, buf,
+			  sizeof(*ev) + eir_len, NULL);
 }
 
 static void disconnect_rsp(struct pending_cmd *cmd, void *data)
@@ -2948,9 +2993,11 @@
 	struct sock **sk = data;
 	struct mgmt_rp_disconnect rp;
 
-	bacpy(&rp.bdaddr, &cp->bdaddr);
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
 
-	cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, &rp, sizeof(rp));
+	cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, 0, &rp,
+		     sizeof(rp));
 
 	*sk = cmd->sk;
 	sock_hold(*sk);
@@ -2958,250 +3005,402 @@
 	mgmt_pending_remove(cmd);
 }
 
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason)
+static void unpair_device_rsp(struct pending_cmd *cmd, void *data)
+{
+	struct hci_dev *hdev = data;
+	struct mgmt_cp_unpair_device *cp = cmd->param;
+	struct mgmt_rp_unpair_device rp;
+
+	memset(&rp, 0, sizeof(rp));
+	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+	rp.addr.type = cp->addr.type;
+
+	device_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);
+
+	cmd_complete(cmd->sk, cmd->index, cmd->opcode, 0, &rp, sizeof(rp));
+
+	mgmt_pending_remove(cmd);
+}
+
+int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 link_type, u8 addr_type)
 {
-	struct mgmt_ev_disconnected ev;
+	struct mgmt_addr_info ev;
 	struct sock *sk = NULL;
 	int err;
 
+	mgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);
+
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.reason = reason;
+	ev.type = link_to_mgmt(link_type, addr_type);
 
-	err = mgmt_event(MGMT_EV_DISCONNECTED, index, &ev, sizeof(ev), sk);
+	err = mgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev),
+			 sk);
 
 	if (sk)
-		sock_put(sk);
+	  sock_put(sk);
 
-	mgmt_pending_foreach(MGMT_OP_DISCONNECT, index, disconnect_rsp, &sk);
+	mgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,
+			     hdev);
 
 	return err;
 }
 
-int mgmt_disconnect_failed(u16 index)
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			   u8 link_type, u8 addr_type, u8 status)
 {
+	struct mgmt_rp_disconnect rp;
 	struct pending_cmd *cmd;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, index);
+	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	err = cmd_status(cmd->sk, index, MGMT_OP_DISCONNECT, EIO);
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = link_to_mgmt(link_type, addr_type);
+
+	err = cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
+	mgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,
+									hdev);
 	return err;
 }
 
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			u8 addr_type, u8 status)
 {
 	struct mgmt_ev_connect_failed ev;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.status = mgmt_status(status);
 
-	return mgmt_event(MGMT_EV_CONNECT_FAILED, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr)
+int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)
 {
 	struct mgmt_ev_pin_code_request ev;
 
-	BT_DBG("hci%u", index);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = MGMT_ADDR_BREDR;
+	ev.secure = secure;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.secure = 0;
-
-	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
 }
 
-int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				 u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, index);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = MGMT_ADDR_BREDR;
 
-	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_REPLY, &rp,
-								sizeof(rp));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, index);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);
 	if (!cmd)
 		return -ENOENT;
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = MGMT_ADDR_BREDR;
 
-	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_NEG_REPLY, &rp,
-								sizeof(rp));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY,
+			   mgmt_status(status), &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_user_confirm_request(u16 index, u8 event,
-					bdaddr_t *bdaddr, __le32 value)
+int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 confirm_hint)
 {
 	struct mgmt_ev_user_confirm_request ev;
-	struct hci_conn *conn = NULL;
-	struct hci_dev *hdev;
-	u8 loc_cap, rem_cap, loc_mitm, rem_mitm;
 
-	BT_DBG("hci%u", index);
+	BT_DBG("%s", hdev->name);
 
-	hdev = hci_dev_get(index);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.confirm_hint = confirm_hint;
+	put_unaligned_le32(value, &ev.value);
 
-	if (!hdev)
-		return -ENODEV;
+	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
+}
 
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+						u8 link_type, u8 addr_type)
+{
+	struct mgmt_ev_user_passkey_request ev;
 
-	ev.auto_confirm = 0;
+	BT_DBG("%s", hdev->name);
 
-	if (!conn || event != HCI_EV_USER_CONFIRM_REQUEST)
-		goto no_auto_confirm;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
 
-	loc_cap = (conn->io_capability == 0x04) ? 0x01 : conn->io_capability;
-	rem_cap = conn->remote_cap;
-	loc_mitm = conn->auth_type & 0x01;
-	rem_mitm = conn->remote_auth & 0x01;
+	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),
+			  NULL);
+}
 
-	if ((conn->auth_type & HCI_AT_DEDICATED_BONDING) &&
-			conn->auth_initiator && rem_cap == 0x03)
-		ev.auto_confirm = 1;
-	else if (loc_cap == 0x01 && (rem_cap == 0x00 || rem_cap == 0x03)) {
-		if (!loc_mitm && !rem_mitm)
-			value = 0;
-		goto no_auto_confirm;
-	}
+static int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					u8 link_type, u8 addr_type, u8 status,
+					u8 opcode)
+{
+	struct pending_cmd *cmd;
+	struct mgmt_rp_user_confirm_reply rp;
+	int err;
 
-	/* Show bonding dialog if neither side requires no bonding */
-	if ((conn->auth_type > 0x01) && (conn->remote_auth > 0x01)) {
-		if (!loc_mitm && !rem_mitm)
-			value = 0;
-		goto no_auto_confirm;
-	}
+	cmd = mgmt_pending_find(opcode, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	if ((!loc_mitm || rem_cap == 0x03) && (!rem_mitm || loc_cap == 0x03))
-		ev.auto_confirm = 1;
+	bacpy(&rp.addr.bdaddr, bdaddr);
+	rp.addr.type = link_to_mgmt(link_type, addr_type);
+	err = cmd_complete(cmd->sk, hdev->id, opcode, mgmt_status(status),
+			   &rp, sizeof(rp));
 
-no_auto_confirm:
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.event = event;
-	put_unaligned_le32(value, &ev.value);
+	mgmt_pending_remove(cmd);
+
+	return err;
+}
 
-	hci_dev_put(hdev);
+int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_CONFIRM_REPLY);
+}
 
-	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_CONFIRM_NEG_REPLY);
 }
 
-int mgmt_user_passkey_request(u16 index, bdaddr_t *bdaddr)
+int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 link_type, u8 addr_type, u8 status)
 {
-	struct mgmt_ev_user_passkey_request ev;
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_PASSKEY_REPLY);
+}
 
-	BT_DBG("hci%u", index);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					 u8 link_type, u8 addr_type, u8 status)
+{
+	return user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,
+					  status, MGMT_OP_USER_PASSKEY_NEG_REPLY);
+}
 
-	bacpy(&ev.bdaddr, bdaddr);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, u8 status)
+{
+	struct mgmt_ev_auth_failed ev;
 
-	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, index, &ev, sizeof(ev),
-									NULL);
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	ev.status = mgmt_status(status);
+
+	return mgmt_event(MGMT_EV_AUTH_FAILED, hdev, &ev, sizeof(ev), NULL);
 }
 
-static int confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status,
-								u8 opcode)
+int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)
 {
-	struct pending_cmd *cmd;
-	struct mgmt_rp_user_confirm_reply rp;
-	int err;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	cmd = mgmt_pending_find(opcode, index);
-	if (!cmd)
-		return -ENOENT;
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
+		mgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,
+				     cmd_status_rsp, &mgmt_err);
+		return 0;
+	}
 
-	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = status;
-	err = cmd_complete(cmd->sk, index, opcode, &rp, sizeof(rp));
+	if (test_bit(HCI_AUTH, &hdev->flags)) {
+		if (!test_and_set_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_LINK_SECURITY, &hdev->dev_flags))
+			changed = true;
+	}
 
-	mgmt_pending_remove(cmd);
+	mgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,
+			     &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
 
 	return err;
 }
 
-int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+static int clear_eir(struct hci_dev *hdev)
+{
+	struct hci_cp_write_eir cp;
+
+	if (!(hdev->features[6] & LMP_EXT_INQ))
+		return 0;
+
+	memset(hdev->eir, 0, sizeof(hdev->eir));
+
+	memset(&cp, 0, sizeof(cp));
+
+	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+}
+
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 {
-	return confirm_reply_complete(index, bdaddr, status,
-						MGMT_OP_USER_CONFIRM_REPLY);
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
+
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
+
+		if (enable && test_and_clear_bit(HCI_SSP_ENABLED,
+						 &hdev->dev_flags))
+			err = new_settings(hdev, NULL);
+
+		mgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,
+				     &mgmt_err);
+
+		return err;
+	}
+
+	if (enable) {
+		if (!test_and_set_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+			changed = true;
+	} else {
+		if (test_and_clear_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+			changed = true;
+	}
+
+	mgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
+
+	if (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags))
+		update_eir(hdev);
+	else
+		clear_eir(hdev);
+
+	return err;
 }
 
-int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
+static void class_rsp(struct pending_cmd *cmd, void *data)
 {
-	return confirm_reply_complete(index, bdaddr, status,
-					MGMT_OP_USER_CONFIRM_NEG_REPLY);
+	struct cmd_lookup *match = data;
+
+	cmd_complete(cmd->sk, cmd->index, cmd->opcode, match->mgmt_status,
+		     match->hdev->dev_class, 3);
+
+	list_del(&cmd->list);
+
+	if (match->sk == NULL) {
+		match->sk = cmd->sk;
+		sock_hold(match->sk);
+	}
+
+	mgmt_pending_free(cmd);
 }
 
-int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+				   u8 status)
 {
-	struct mgmt_ev_auth_failed ev;
+	struct cmd_lookup match = { NULL, hdev, mgmt_status(status) };
+	int err = 0;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	clear_bit(HCI_PENDING_CLASS, &hdev->dev_flags);
+
+	mgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, class_rsp, &match);
+	mgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, class_rsp, &match);
+	mgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, class_rsp, &match);
+
+	if (!status)
+		err = mgmt_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev, dev_class,
+				 3, NULL);
+
+	if (match.sk)
+		sock_put(match.sk);
 
-	return mgmt_event(MGMT_EV_AUTH_FAILED, index, &ev, sizeof(ev), NULL);
+	return err;
 }
 
-int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status)
+int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)
 {
 	struct pending_cmd *cmd;
-	struct hci_dev *hdev;
 	struct mgmt_cp_set_local_name ev;
-	int err;
+	bool changed = false;
+	int err = 0;
+
+	if (memcmp(name, hdev->dev_name, sizeof(hdev->dev_name)) != 0) {
+		memcpy(hdev->dev_name, name, sizeof(hdev->dev_name));
+		changed = true;
+	}
 
 	memset(&ev, 0, sizeof(ev));
 	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
+	memcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);
 
-	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, index);
+	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);
 	if (!cmd)
 		goto send_event;
 
+	/* Always assume that either the short or the complete name has
+	 * changed if there was a pending mgmt command */
+	changed = true;
+
 	if (status) {
-		err = cmd_status(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, EIO);
+		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,
+				 mgmt_status(status));
 		goto failed;
 	}
 
-	hdev = hci_dev_get(index);
-	if (hdev) {
-		update_eir(hdev);
-		hci_dev_put(hdev);
-	}
-
-	err = cmd_complete(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, &ev,
-								sizeof(ev));
+	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0, &ev,
+			   sizeof(ev));
 	if (err < 0)
 		goto failed;
 
 send_event:
-	err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, index, &ev, sizeof(ev),
-							cmd ? cmd->sk : NULL);
+	if (changed)
+		err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev,
+				 sizeof(ev), cmd ? cmd->sk : NULL);
+
+	update_eir(hdev);
 
 failed:
 	if (cmd)
@@ -3209,29 +3408,30 @@
 	return err;
 }
 
-int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
-								u8 status)
+int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+					    u8 *randomizer, u8 status)
 {
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("hci%u status %u", index, status);
+	BT_DBG("%s status %u", hdev->name, status);
 
-	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index);
+	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 	if (!cmd)
 		return -ENOENT;
 
 	if (status) {
-		err = cmd_status(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-									EIO);
+		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
+				 mgmt_status(status));
 	} else {
 		struct mgmt_rp_read_local_oob_data rp;
 
 		memcpy(rp.hash, hash, sizeof(rp.hash));
 		memcpy(rp.randomizer, randomizer, sizeof(rp.randomizer));
 
-		err = cmd_complete(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-							&rp, sizeof(rp));
+		err = cmd_complete(cmd->sk, hdev->id,
+				   MGMT_OP_READ_LOCAL_OOB_DATA, 0, &rp,
+				   sizeof(rp));
 	}
 
 	mgmt_pending_remove(cmd);
@@ -3239,182 +3439,198 @@
 	return err;
 }
 
-void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
-		u16 handle, u8 status)
+int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 {
-	struct mgmt_ev_rssi_update ev;
-	struct hci_conn *conn;
-	struct hci_dev *hdev;
+	struct cmd_lookup match = { NULL, hdev };
+	bool changed = false;
+	int err = 0;
 
-	if (status)
-		return;
+	if (status) {
+		u8 mgmt_err = mgmt_status(status);
 
-	hdev = hci_dev_get(index);
-	conn = hci_conn_hash_lookup_handle(hdev, handle);
+		if (enable && test_and_clear_bit(HCI_LE_ENABLED,
+						 &hdev->dev_flags))
+		  err = new_settings(hdev, NULL);
 
-	if (!conn)
-		return;
+		mgmt_pending_foreach(MGMT_OP_SET_LE, hdev,
+				     cmd_status_rsp, &mgmt_err);
 
-	BT_DBG("rssi_update_thresh_exceed : %d ",
-		   conn->rssi_update_thresh_exceed);
-	BT_DBG("RSSI Threshold : %d , recvd RSSI : %d ",
-			conn->rssi_threshold, rssi);
-
-	if (conn->rssi_update_thresh_exceed == 1) {
-		BT_DBG("rssi_update_thresh_exceed == 1");
-		if (rssi > conn->rssi_threshold) {
-			memset(&ev, 0, sizeof(ev));
-			bacpy(&ev.bdaddr, bdaddr);
-			ev.rssi = rssi;
-			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
-				sizeof(ev), NULL);
-		} else {
-			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
-				conn->rssi_update_interval,
-				conn->rssi_update_thresh_exceed);
-		}
+		return err;
+	}
+
+	if (enable) {
+		if (!test_and_set_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+			changed = true;
 	} else {
-		BT_DBG("rssi_update_thresh_exceed == 0");
-		if (rssi < conn->rssi_threshold) {
-			memset(&ev, 0, sizeof(ev));
-			bacpy(&ev.bdaddr, bdaddr);
-			ev.rssi = rssi;
-			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
-				sizeof(ev), NULL);
-		} else {
-			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
-				conn->rssi_update_interval,
-				conn->rssi_update_thresh_exceed);
-		}
+		if (test_and_clear_bit(HCI_LE_ENABLED, &hdev->dev_flags))
+			changed = true;
 	}
+
+	mgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);
+
+	if (changed)
+		err = new_settings(hdev, match.sk);
+
+	if (match.sk)
+		sock_put(match.sk);
+
+	return err;
 }
 
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name, u8
+		      ssp, u8 *eir, u16 eir_len)
+{
+	char buf[512];
+	struct mgmt_ev_device_found *ev = (void *) buf;
+	size_t ev_size;
 
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
-			u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir)
-{
-	struct mgmt_ev_device_found ev;
-	struct hci_dev *hdev;
-	int err;
+	/* Leave 5 bytes for a potential CoD field */
+	if (sizeof(*ev) + eir_len + 5 > sizeof(buf))
+		return -EINVAL;
 
-	BT_DBG("le: %d", le);
+	memset(buf, 0, sizeof(buf));
 
-	memset(&ev, 0, sizeof(ev));
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+	ev->rssi = rssi;
+	if (cfm_name)
+		ev->flags[0] |= MGMT_DEV_FOUND_CONFIRM_NAME;
+	if (!ssp)
+		ev->flags[0] |= MGMT_DEV_FOUND_LEGACY_PAIRING;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.rssi = rssi;
-	ev.type = type;
-	ev.le = le;
+	if (eir_len > 0)
+		memcpy(ev->eir, eir, eir_len);
 
-	if (dev_class)
-		memcpy(ev.dev_class, dev_class, sizeof(ev.dev_class));
+	if (dev_class && !eir_has_data_type(ev->eir, eir_len, EIR_CLASS_OF_DEV))
+		eir_len = eir_append_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,
+					  dev_class, 3);
 
-	if (eir && eir_len)
-		memcpy(ev.eir, eir, eir_len);
+	put_unaligned_le16(eir_len, &ev->eir_len);
 
-	err = mgmt_event(MGMT_EV_DEVICE_FOUND, index, &ev, sizeof(ev), NULL);
+	ev_size = sizeof(*ev) + eir_len;
 
-	if (err < 0)
-		return err;
+	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, ev_size, NULL);
+}
 
-	hdev = hci_dev_get(index);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		     u8 addr_type, s8 rssi, u8 *name, u8 name_len)
+{
+	struct mgmt_ev_device_found *ev;
+	char buf[sizeof(*ev) + HCI_MAX_NAME_LENGTH + 2];
+	u16 eir_len;
 
-	if (!hdev)
-		return 0;
+	ev = (struct mgmt_ev_device_found *) buf;
 
-	if (hdev->disco_state == SCAN_IDLE)
-		goto done;
+	memset(buf, 0, sizeof(buf));
 
-	hdev->disco_int_count++;
+	bacpy(&ev->addr.bdaddr, bdaddr);
+	ev->addr.type = link_to_mgmt(link_type, addr_type);
+	ev->rssi = rssi;
 
-	if (hdev->disco_int_count >= hdev->disco_int_phase) {
-		/* Inquiry scan for General Discovery LAP */
-		struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
-		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
-
-		hdev->disco_int_phase *= 2;
-		hdev->disco_int_count = 0;
-		if (hdev->disco_state == SCAN_LE) {
-			/* cancel LE scan */
-			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
-					sizeof(le_cp), &le_cp);
-			/* start BR scan */
-			cp.num_rsp = (u8) hdev->disco_int_phase;
-			hci_send_cmd(hdev, HCI_OP_INQUIRY,
-					sizeof(cp), &cp);
-			hdev->disco_state = SCAN_BR;
-			del_timer_sync(&hdev->disco_le_timer);
-		}
-	}
+	eir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,
+				  name_len);
 
-done:
-	hci_dev_put(hdev);
-	return 0;
-}
+	put_unaligned_le16(eir_len, &ev->eir_len);
 
+	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev,
+			  sizeof(*ev) + eir_len, NULL);
+}
 
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name)
+int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status)
 {
-	struct mgmt_ev_remote_name ev;
+	struct pending_cmd *cmd;
+	u8 type;
+	int err;
 
-	memset(&ev, 0, sizeof(ev));
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
-	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
+	cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
+	if (!cmd)
+		return -ENOENT;
+
+	type = hdev->discovery.type;
 
-	return mgmt_event(MGMT_EV_REMOTE_NAME, index, &ev, sizeof(ev), NULL);
+	err = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),
+			   &type, sizeof(type));
+	mgmt_pending_remove(cmd);
+
+	return err;
 }
 
-int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status)
+int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status)
 {
-	struct mgmt_ev_encrypt_change ev;
+	struct pending_cmd *cmd;
+	int err;
 
-	BT_DBG("hci%u", index);
+	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
+	if (!cmd)
+		return -ENOENT;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = status;
+	err = cmd_complete(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status),
+			   &hdev->discovery.type, sizeof(hdev->discovery.type));
+	mgmt_pending_remove(cmd);
 
-	return mgmt_event(MGMT_EV_ENCRYPT_CHANGE, index, &ev, sizeof(ev),
-									NULL);
+	return err;
 }
 
-int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3])
+int mgmt_discovering(struct hci_dev *hdev, u8 discovering)
 {
-	struct mgmt_ev_remote_class ev;
+	struct mgmt_ev_discovering ev;
+	struct pending_cmd *cmd;
 
-	memset(&ev, 0, sizeof(ev));
+	BT_DBG("%s discovering %u", hdev->name, discovering);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	memcpy(ev.dev_class, dev_class, 3);
+	if (discovering)
+		cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
+	else
+		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
+
+	if (cmd != NULL) {
+		u8 type = hdev->discovery.type;
+
+		cmd_complete(cmd->sk, hdev->id, cmd->opcode, 0, &type,
+			     sizeof(type));
+		mgmt_pending_remove(cmd);
+	}
+
+	memset(&ev, 0, sizeof(ev));
+	ev.type = hdev->discovery.type;
+	ev.discovering = discovering;
 
-	return mgmt_event(MGMT_EV_REMOTE_CLASS, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
-							u16 sub_ver)
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct mgmt_ev_remote_version ev;
+	struct pending_cmd *cmd;
+	struct mgmt_ev_device_blocked ev;
 
-	memset(&ev, 0, sizeof(ev));
+	cmd = mgmt_pending_find(MGMT_OP_BLOCK_DEVICE, hdev);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	ev.lmp_ver = ver;
-	ev.manufacturer = mnf;
-	ev.lmp_subver = sub_ver;
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = type;
 
-	return mgmt_event(MGMT_EV_REMOTE_VERSION, index, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &ev, sizeof(ev),
+			  cmd ? cmd->sk : NULL);
 }
 
-int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8])
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
-	struct mgmt_ev_remote_features ev;
+	struct pending_cmd *cmd;
+	struct mgmt_ev_device_unblocked ev;
 
-	memset(&ev, 0, sizeof(ev));
+	cmd = mgmt_pending_find(MGMT_OP_UNBLOCK_DEVICE, hdev);
 
-	bacpy(&ev.bdaddr, bdaddr);
-	memcpy(ev.features, features, sizeof(ev.features));
+	bacpy(&ev.addr.bdaddr, bdaddr);
+	ev.addr.type = type;
 
-	return mgmt_event(MGMT_EV_REMOTE_FEATURES, index, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &ev, sizeof(ev),
+			  cmd ? cmd->sk : NULL);
 }
+
+module_param(enable_hs, bool, 0644);
+MODULE_PARM_DESC(enable_hs, "Enable High Speed support");
+
+module_param(enable_le, bool, 0644);
+MODULE_PARM_DESC(enable_le, "Enable Low Energy support");
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/core.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/core.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/core.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/core.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    RFCOMM implementation for Linux Bluetooth stack (BlueZ).
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>
    Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>
 
@@ -40,7 +39,6 @@
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
-#include <linux/interrupt.h>
 
 #include <net/sock.h>
 #include <linux/uaccess.h>
@@ -52,9 +50,6 @@
 #include <net/bluetooth/rfcomm.h>
 
 #define VERSION "1.11"
-/* 1 Byte DLCI, 1 Byte Control filed, 2 Bytes Length, 1 Byte for Credits,
- * 1 Byte FCS */
-#define RFCOMM_HDR_SIZE 6
 
 static bool disable_cfc;
 static bool l2cap_ertm;
@@ -67,7 +62,6 @@
 #define rfcomm_lock()	mutex_lock(&rfcomm_mutex)
 #define rfcomm_unlock()	mutex_unlock(&rfcomm_mutex)
 
-static unsigned long rfcomm_event;
 
 static LIST_HEAD(session_list);
 
@@ -87,9 +81,7 @@
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err,
-							u8 channel,
-							struct rfcomm_dlc *d);
+							int *err);
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst);
 static void rfcomm_session_del(struct rfcomm_session *s);
 
@@ -123,37 +115,15 @@
 #define __get_rpn_stop_bits(line) (((line) >> 2) & 0x1)
 #define __get_rpn_parity(line)    (((line) >> 3) & 0x7)
 
-struct rfcomm_sock_release_work {
-	struct work_struct work;
-	struct socket *sock;
-	int state;
-};
-
 static inline void rfcomm_schedule(void)
 {
 	if (!rfcomm_thread)
 		return;
-	set_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 	wake_up_process(rfcomm_thread);
 }
 
 static inline void rfcomm_session_put(struct rfcomm_session *s)
 {
-	bool match = false;
-	struct rfcomm_session *sess;
-	struct list_head *p, *n;
-	list_for_each_safe(p, n, &session_list) {
-		sess = list_entry(p, struct rfcomm_session, list);
-		if (s == sess) {
-			match = true;
-			break;
-		}
-	}
-	if (!match) {
-		BT_ERR("session already freed previously");
-		dump_stack();
-		return;
-	}
 	if (atomic_dec_and_test(&s->refcnt))
 		rfcomm_session_del(s);
 }
@@ -260,10 +230,11 @@
 static inline int rfcomm_check_security(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
+
 	__u8 auth_type;
 
 	switch (d->sec_level) {
-	case BT_SECURITY_VERY_HIGH:
 	case BT_SECURITY_HIGH:
 		auth_type = HCI_AT_GENERAL_BONDING_MITM;
 		break;
@@ -275,8 +246,7 @@
 		break;
 	}
 
-	return hci_conn_security(l2cap_pi(sk)->conn->hcon, d->sec_level,
-								auth_type);
+	return hci_conn_security(conn->hcon, d->sec_level, auth_type);
 }
 
 static void rfcomm_session_timeout(unsigned long arg)
@@ -407,13 +377,11 @@
 static struct rfcomm_dlc *rfcomm_dlc_get(struct rfcomm_session *s, u8 dlci)
 {
 	struct rfcomm_dlc *d;
-	struct list_head *p;
 
-	list_for_each(p, &s->dlcs) {
-		d = list_entry(p, struct rfcomm_dlc, list);
+	list_for_each_entry(d, &s->dlcs, list)
 		if (d->dlci == dlci)
 			return d;
-	}
+
 	return NULL;
 }
 
@@ -434,31 +402,31 @@
 
 	s = rfcomm_session_get(src, dst);
 	if (!s) {
-		s = rfcomm_session_create(src, dst,
-						d->sec_level, &err, channel, d);
+		s = rfcomm_session_create(src, dst, d->sec_level, &err);
 		if (!s)
 			return err;
-	} else {
-		dlci = __dlci(!s->initiator, channel);
+	}
 
-		/* Check if DLCI already exists */
-		if (rfcomm_dlc_get(s, dlci))
-			return -EBUSY;
+	dlci = __dlci(!s->initiator, channel);
 
-		rfcomm_dlc_clear_state(d);
+	/* Check if DLCI already exists */
+	if (rfcomm_dlc_get(s, dlci))
+		return -EBUSY;
 
-		d->dlci     = dlci;
-		d->addr     = __addr(s->initiator, dlci);
-		d->priority = 7;
+	rfcomm_dlc_clear_state(d);
 
-		d->state = BT_CONFIG;
-		rfcomm_dlc_link(s, d);
+	d->dlci     = dlci;
+	d->addr     = __addr(s->initiator, dlci);
+	d->priority = 7;
+
+	d->state = BT_CONFIG;
+	rfcomm_dlc_link(s, d);
 
-		d->out = 1;
+	d->out = 1;
+
+	d->mtu = s->mtu;
+	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 
-		d->mtu = s->mtu;
-		d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
-	}
 	if (s->state == BT_CONNECTED) {
 		if (rfcomm_check_security(d))
 			rfcomm_send_pn(s, 1, d);
@@ -494,6 +462,7 @@
 
 	switch (d->state) {
 	case BT_CONNECT:
+	case BT_CONFIG:
 		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
 			rfcomm_schedule();
@@ -654,25 +623,9 @@
 	return s;
 }
 
-static void rfcomm_sock_release_worker(struct work_struct *work)
-{
-	struct rfcomm_sock_release_work *release_work =
-		container_of(work, struct rfcomm_sock_release_work, work);
-
-	BT_DBG("sock %p", release_work->sock);
-
-	sock_release(release_work->sock);
-	if (release_work->state != BT_LISTEN)
-		module_put(THIS_MODULE);
-
-	kfree(release_work);
-}
-
 static void rfcomm_session_del(struct rfcomm_session *s)
 {
 	int state = s->state;
-	struct socket *sock = s->sock;
-	struct rfcomm_sock_release_work *release_work;
 
 	BT_DBG("session %p state %ld", s, s->state);
 
@@ -682,19 +635,11 @@
 		rfcomm_send_disc(s, 0);
 
 	rfcomm_session_clear_timer(s);
-
+	sock_release(s->sock);
 	kfree(s);
 
-	release_work = kzalloc(sizeof(*release_work), GFP_ATOMIC);
-	if (release_work) {
-		INIT_WORK(&release_work->work, rfcomm_sock_release_worker);
-		release_work->sock = sock;
-		release_work->state = state;
-
-		if (!schedule_work(&release_work->work))
-			kfree(release_work);
-	}
-
+	if (state != BT_LISTEN)
+		module_put(THIS_MODULE);
 }
 
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst)
@@ -738,15 +683,12 @@
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err,
-							u8 channel,
-							struct rfcomm_dlc *d)
+							int *err)
 {
 	struct rfcomm_session *s = NULL;
 	struct sockaddr_l2 addr;
 	struct socket *sock;
 	struct sock *sk;
-	u8 dlci;
 
 	BT_DBG("%s %s", batostr(src), batostr(dst));
 
@@ -765,10 +707,10 @@
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->imtu = l2cap_mtu;
-	l2cap_pi(sk)->sec_level = sec_level;
+	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
+	l2cap_pi(sk)->chan->sec_level = sec_level;
 	if (l2cap_ertm)
-		l2cap_pi(sk)->mode = L2CAP_MODE_ERTM;
+		l2cap_pi(sk)->chan->mode = L2CAP_MODE_ERTM;
 	release_sock(sk);
 
 	s = rfcomm_session_add(sock, BT_BOUND);
@@ -783,30 +725,11 @@
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = cpu_to_le16(RFCOMM_PSM);
 	addr.l2_cid    = 0;
-	dlci = __dlci(!s->initiator, channel);
-
-	/* Check if DLCI already exists */
-	if (rfcomm_dlc_get(s, dlci))
-		return NULL;
-
-	rfcomm_dlc_clear_state(d);
-
-	d->dlci     = dlci;
-	d->addr     = __addr(s->initiator, dlci);
-	d->priority = 7;
-
-	d->state = BT_CONFIG;
-	rfcomm_dlc_link(s, d);
-
-	d->out = 1;
-
-	d->mtu = s->mtu;
-	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 	*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
 	if (*err == 0 || *err == -EINPROGRESS)
 		return s;
-	BT_ERR("error ret is %d, going to delete session", *err);
-	rfcomm_dlc_unlink(d);
+
+	rfcomm_session_del(s);
 	return NULL;
 
 failed:
@@ -826,7 +749,6 @@
 /* ---- RFCOMM frame sending ---- */
 static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 {
-	struct socket *sock = s->sock;
 	struct kvec iv = { data, len };
 	struct msghdr msg;
 
@@ -834,7 +756,14 @@
 
 	memset(&msg, 0, sizeof(msg));
 
-	return kernel_sendmsg(sock, &msg, &iv, 1, len);
+	return kernel_sendmsg(s->sock, &msg, &iv, 1, len);
+}
+
+static int rfcomm_send_cmd(struct rfcomm_session *s, struct rfcomm_cmd *cmd)
+{
+	BT_DBG("%p cmd %u", s, cmd->ctrl);
+
+	return rfcomm_send_frame(s, (void *) cmd, sizeof(*cmd));
 }
 
 static int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci)
@@ -848,7 +777,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_ua(struct rfcomm_session *s, u8 dlci)
@@ -862,7 +791,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci)
@@ -876,7 +805,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_queue_disc(struct rfcomm_dlc *d)
@@ -912,7 +841,7 @@
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
+	return rfcomm_send_cmd(s, &cmd);
 }
 
 static int rfcomm_send_nsc(struct rfcomm_session *s, int cr, u8 type)
@@ -1235,12 +1164,18 @@
 			break;
 
 		case BT_DISCONN:
-			/* When socket is closed and we are not RFCOMM
-			 * initiator rfcomm_process_rx already calls
-			 * rfcomm_session_put() */
-			if (s->sock->sk->sk_state != BT_CLOSED)
-				if (list_empty(&s->dlcs))
-					rfcomm_session_put(s);
+			/* rfcomm_session_put is called later so don't do
+			 * anything here otherwise we will mess up the session
+			 * reference counter:
+			 *
+			 * (a) when we are the initiator dlc_unlink will drive
+			 * the reference counter to 0 (there is no initial put
+			 * after session_add)
+			 *
+			 * (b) when we are not the initiator rfcomm_rx_process
+			 * will explicitly call put to balance the initial hold
+			 * done after session add.
+			 */
 			break;
 		}
 	}
@@ -1316,6 +1251,7 @@
 void rfcomm_dlc_accept(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 
 	BT_DBG("dlc %p", d);
 
@@ -1329,7 +1265,7 @@
 	rfcomm_dlc_unlock(d);
 
 	if (d->role_switch)
-		hci_conn_switch_role(l2cap_pi(sk)->conn->hcon, 0x00);
+		hci_conn_switch_role(conn->hcon, 0x00);
 
 	rfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);
 }
@@ -1877,6 +1813,11 @@
 			continue;
 		}
 
+		if (test_bit(RFCOMM_ENC_DROP, &d->flags)) {
+			__rfcomm_dlc_close(d, ECONNREFUSED);
+			continue;
+		}
+
 		if (test_and_clear_bit(RFCOMM_AUTH_ACCEPT, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (d->out) {
@@ -1967,10 +1908,9 @@
 		rfcomm_session_hold(s);
 
 		/* We should adjust MTU on incoming sessions.
-		 * L2CAP MTU minus UIH header and FCS.
-		 * Need to accomodate 1 Byte credits information */
-		s->mtu = min(l2cap_pi(nsock->sk)->omtu,
-				l2cap_pi(nsock->sk)->imtu) - RFCOMM_HDR_SIZE;
+		 * L2CAP MTU minus UIH header and FCS. */
+		s->mtu = min(l2cap_pi(nsock->sk)->chan->omtu,
+				l2cap_pi(nsock->sk)->chan->imtu) - 5;
 
 		rfcomm_schedule();
 	} else
@@ -1988,9 +1928,8 @@
 		s->state = BT_CONNECT;
 
 		/* We can adjust MTU on outgoing sessions.
-		 * L2CAP MTU minus UIH header, Credits and FCS. */
-		s->mtu = min(l2cap_pi(sk)->omtu, l2cap_pi(sk)->imtu) -
-						RFCOMM_HDR_SIZE;
+		 * L2CAP MTU minus UIH header and FCS. */
+		s->mtu = min(l2cap_pi(sk)->chan->omtu, l2cap_pi(sk)->chan->imtu) - 5;
 
 		rfcomm_send_sabm(s, 0);
 		break;
@@ -2073,7 +2012,7 @@
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->imtu = l2cap_mtu;
+	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
 	release_sock(sk);
 
 	/* Start listening on the socket */
@@ -2116,19 +2055,18 @@
 
 	rfcomm_add_listener(BDADDR_ANY);
 
-	while (!kthread_should_stop()) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
-			/* No pending events. Let's sleep.
-			 * Incoming connections and data will wake us up. */
-			schedule();
-		}
-		set_current_state(TASK_RUNNING);
+
+		if (kthread_should_stop())
+			break;
 
 		/* Process stuff */
-		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 		rfcomm_process_sessions();
+
+		schedule();
 	}
+	__set_current_state(TASK_RUNNING);
 
 	rfcomm_kill_listener();
 
@@ -2155,7 +2093,7 @@
 		if (test_and_clear_bit(RFCOMM_SEC_PENDING, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (status || encrypt == 0x00) {
-				__rfcomm_dlc_close(d, ECONNREFUSED);
+				set_bit(RFCOMM_ENC_DROP, &d->flags);
 				continue;
 			}
 		}
@@ -2165,9 +2103,8 @@
 				set_bit(RFCOMM_SEC_PENDING, &d->flags);
 				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
 				continue;
-			} else if (d->sec_level == BT_SECURITY_HIGH ||
-				d->sec_level == BT_SECURITY_VERY_HIGH) {
-				__rfcomm_dlc_close(d, ECONNREFUSED);
+			} else if (d->sec_level == BT_SECURITY_HIGH) {
+				set_bit(RFCOMM_ENC_DROP, &d->flags);
 				continue;
 			}
 		}
@@ -2175,7 +2112,7 @@
 		if (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))
 			continue;
 
-		if (!status)
+		if (!status && hci_conn_check_secure(conn, d->sec_level))
 			set_bit(RFCOMM_AUTH_ACCEPT, &d->flags);
 		else
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
@@ -2194,15 +2131,13 @@
 static int rfcomm_dlc_debugfs_show(struct seq_file *f, void *x)
 {
 	struct rfcomm_session *s;
-	struct list_head *pp, *p;
 
 	rfcomm_lock();
 
-	list_for_each(p, &session_list) {
-		s = list_entry(p, struct rfcomm_session, list);
-		list_for_each(pp, &s->dlcs) {
+	list_for_each_entry(s, &session_list, list) {
+		struct rfcomm_dlc *d;
+		list_for_each_entry(d, &s->dlcs, list) {
 			struct sock *sk = s->sock->sk;
-			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);
 
 			seq_printf(f, "%s %s %ld %d %d %d %d\n",
 						batostr(&bt_sk(sk)->src),
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/sock.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/sock.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/sock.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/sock.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    RFCOMM implementation for Linux Bluetooth stack (BlueZ).
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>
    Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>
 
@@ -43,9 +42,9 @@
 #include <linux/device.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/security.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -265,6 +264,8 @@
 
 		pi->sec_level = rfcomm_pi(parent)->sec_level;
 		pi->role_switch = rfcomm_pi(parent)->role_switch;
+
+		security_sk_clone(parent, sk);
 	} else {
 		pi->dlc->defer_setup = 0;
 
@@ -368,7 +369,7 @@
 		goto done;
 	}
 
-	write_lock_bh(&rfcomm_sk_list.lock);
+	write_lock(&rfcomm_sk_list.lock);
 
 	if (sa->rc_channel && __rfcomm_get_sock_by_addr(sa->rc_channel, &sa->rc_bdaddr)) {
 		err = -EADDRINUSE;
@@ -379,7 +380,7 @@
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock_bh(&rfcomm_sk_list.lock);
+	write_unlock(&rfcomm_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -453,7 +454,7 @@
 
 		err = -EINVAL;
 
-		write_lock_bh(&rfcomm_sk_list.lock);
+		write_lock(&rfcomm_sk_list.lock);
 
 		for (channel = 1; channel < 31; channel++)
 			if (!__rfcomm_get_sock_by_addr(channel, src)) {
@@ -462,7 +463,7 @@
 				break;
 			}
 
-		write_unlock_bh(&rfcomm_sk_list.lock);
+		write_unlock(&rfcomm_sk_list.lock);
 
 		if (err < 0)
 			goto done;
@@ -484,12 +485,7 @@
 	long timeo;
 	int err = 0;
 
-	lock_sock(sk);
-
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
+	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
 	if (sk->sk_type != SOCK_STREAM) {
 		err = -EINVAL;
@@ -502,19 +498,20 @@
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
+		nsk = bt_accept_dequeue(sk, newsock);
+		if (nsk)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -522,8 +519,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -545,6 +546,7 @@
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
+	memset(sa, 0, sizeof(*sa));
 	sa->rc_family  = AF_BLUETOOTH;
 	sa->rc_channel = rfcomm_pi(sk)->channel;
 	if (peer)
@@ -598,6 +600,8 @@
 			break;
 		}
 
+		skb->priority = sk->sk_priority;
+
 		err = rfcomm_dlc_send(d, skb);
 		if (err < 0) {
 			kfree_skb(skb);
@@ -680,7 +684,8 @@
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
-	int len, err = 0;
+	int err = 0;
+	size_t len;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
@@ -708,13 +713,12 @@
 			break;
 		}
 
-		if (sec.level > BT_SECURITY_VERY_HIGH) {
+		if (sec.level > BT_SECURITY_HIGH) {
 			err = -EINVAL;
 			break;
 		}
 
 		rfcomm_pi(sk)->sec_level = sec.level;
-		BT_DBG("set to %d", sec.level);
 		break;
 
 	case BT_DEFER_SETUP:
@@ -743,8 +747,8 @@
 static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
-	struct sock *l2cap_sk;
 	struct rfcomm_conninfo cinfo;
+	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 	int len, err = 0;
 	u32 opt;
 
@@ -765,7 +769,6 @@
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
 			break;
 		case BT_SECURITY_HIGH:
-		case BT_SECURITY_VERY_HIGH:
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |
 							RFCOMM_LM_SECURE;
 			break;
@@ -788,10 +791,9 @@
 			break;
 		}
 
-		l2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;
-
-		cinfo.hci_handle = l2cap_pi(l2cap_sk)->conn->hcon->handle;
-		memcpy(cinfo.dev_class, l2cap_pi(l2cap_sk)->conn->hcon->dev_class, 3);
+		memset(&cinfo, 0, sizeof(cinfo));
+		cinfo.hci_handle = conn->hcon->handle;
+		memcpy(cinfo.dev_class, conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -835,6 +837,7 @@
 		}
 
 		sec.level = rfcomm_pi(sk)->sec_level;
+		sec.key_size = 0;
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))
@@ -954,6 +957,8 @@
 	if (!sk)
 		goto done;
 
+	bt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);
+
 	rfcomm_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, &src);
 	bacpy(&bt_sk(sk)->dst, &dst);
@@ -980,7 +985,7 @@
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock_bh(&rfcomm_sk_list.lock);
+	read_lock(&rfcomm_sk_list.lock);
 
 	sk_for_each(sk, node, &rfcomm_sk_list.head) {
 		seq_printf(f, "%s %s %d %d\n",
@@ -989,7 +994,7 @@
 				sk->sk_state, rfcomm_pi(sk)->channel);
 	}
 
-	read_unlock_bh(&rfcomm_sk_list.lock);
+	read_unlock(&rfcomm_sk_list.lock);
 
 	return 0;
 }
diff -urN flo-ElementalX-5.00/net/bluetooth/rfcomm/tty.c flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/tty.c
--- flo-ElementalX-5.00/net/bluetooth/rfcomm/tty.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/rfcomm/tty.c	2016-06-02 00:28:55.000000000 +0000
@@ -26,7 +26,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/interrupt.h>
 
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
@@ -35,6 +34,7 @@
 #include <linux/capability.h>
 #include <linux/slab.h>
 #include <linux/skbuff.h>
+#include <linux/workqueue.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -66,7 +66,7 @@
 	struct rfcomm_dlc	*dlc;
 	struct tty_struct	*tty;
 	wait_queue_head_t       wait;
-	struct tasklet_struct   wakeup_task;
+	struct work_struct	wakeup_task;
 
 	struct device		*tty_dev;
 
@@ -76,13 +76,13 @@
 };
 
 static LIST_HEAD(rfcomm_dev_list);
-static DEFINE_RWLOCK(rfcomm_dev_lock);
+static DEFINE_SPINLOCK(rfcomm_dev_lock);
 
 static void rfcomm_dev_data_ready(struct rfcomm_dlc *dlc, struct sk_buff *skb);
 static void rfcomm_dev_state_change(struct rfcomm_dlc *dlc, int err);
 static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig);
 
-static void rfcomm_tty_wakeup(unsigned long arg);
+static void rfcomm_tty_wakeup(struct work_struct *work);
 
 /* ---- Device functions ---- */
 static void rfcomm_dev_destruct(struct rfcomm_dev *dev)
@@ -134,13 +134,10 @@
 static struct rfcomm_dev *__rfcomm_dev_get(int id)
 {
 	struct rfcomm_dev *dev;
-	struct list_head  *p;
 
-	list_for_each(p, &rfcomm_dev_list) {
-		dev = list_entry(p, struct rfcomm_dev, list);
+	list_for_each_entry(dev, &rfcomm_dev_list, list)
 		if (dev->id == id)
 			return dev;
-	}
 
 	return NULL;
 }
@@ -149,7 +146,7 @@
 {
 	struct rfcomm_dev *dev;
 
-	read_lock(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
 	dev = __rfcomm_dev_get(id);
 
@@ -160,7 +157,7 @@
 			rfcomm_dev_hold(dev);
 	}
 
-	read_unlock(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	return dev;
 }
@@ -198,8 +195,8 @@
 
 static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 {
-	struct rfcomm_dev *dev;
-	struct list_head *head = &rfcomm_dev_list, *p;
+	struct rfcomm_dev *dev, *entry;
+	struct list_head *head = &rfcomm_dev_list;
 	int err = 0;
 
 	BT_DBG("id %d channel %d", req->dev_id, req->channel);
@@ -208,24 +205,22 @@
 	if (!dev)
 		return -ENOMEM;
 
-	write_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
 	if (req->dev_id < 0) {
 		dev->id = 0;
 
-		list_for_each(p, &rfcomm_dev_list) {
-			if (list_entry(p, struct rfcomm_dev, list)->id != dev->id)
+		list_for_each_entry(entry, &rfcomm_dev_list, list) {
+			if (entry->id != dev->id)
 				break;
 
 			dev->id++;
-			head = p;
+			head = &entry->list;
 		}
 	} else {
 		dev->id = req->dev_id;
 
-		list_for_each(p, &rfcomm_dev_list) {
-			struct rfcomm_dev *entry = list_entry(p, struct rfcomm_dev, list);
-
+		list_for_each_entry(entry, &rfcomm_dev_list, list) {
 			if (entry->id == dev->id) {
 				err = -EADDRINUSE;
 				goto out;
@@ -234,7 +229,7 @@
 			if (entry->id > dev->id - 1)
 				break;
 
-			head = p;
+			head = &entry->list;
 		}
 	}
 
@@ -258,7 +253,7 @@
 	atomic_set(&dev->opened, 0);
 
 	init_waitqueue_head(&dev->wait);
-	tasklet_init(&dev->wakeup_task, rfcomm_tty_wakeup, (unsigned long) dev);
+	INIT_WORK(&dev->wakeup_task, rfcomm_tty_wakeup);
 
 	skb_queue_head_init(&dev->pending);
 
@@ -295,7 +290,7 @@
 	__module_get(THIS_MODULE);
 
 out:
-	write_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	if (err < 0)
 		goto free;
@@ -332,9 +327,9 @@
 	if (atomic_read(&dev->opened) > 0)
 		return;
 
-	write_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 	list_del_init(&dev->list);
-	write_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	rfcomm_dev_put(dev);
 }
@@ -352,7 +347,7 @@
 	struct rfcomm_dev *dev = (void *) skb->sk;
 	atomic_sub(skb->truesize, &dev->wmem_alloc);
 	if (test_bit(RFCOMM_TTY_ATTACHED, &dev->flags))
-		tasklet_schedule(&dev->wakeup_task);
+		queue_work(system_nrt_wq, &dev->wakeup_task);
 	rfcomm_dev_put(dev);
 }
 
@@ -456,9 +451,9 @@
 
 static int rfcomm_get_dev_list(void __user *arg)
 {
+	struct rfcomm_dev *dev;
 	struct rfcomm_dev_list_req *dl;
 	struct rfcomm_dev_info *di;
-	struct list_head *p;
 	int n = 0, size, err;
 	u16 dev_num;
 
@@ -472,16 +467,15 @@
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
-	dl = kmalloc(size, GFP_KERNEL);
+	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
 	di = dl->dev_info;
 
-	read_lock_bh(&rfcomm_dev_lock);
+	spin_lock(&rfcomm_dev_lock);
 
-	list_for_each(p, &rfcomm_dev_list) {
-		struct rfcomm_dev *dev = list_entry(p, struct rfcomm_dev, list);
+	list_for_each_entry(dev, &rfcomm_dev_list, list) {
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
 			continue;
 		(di + n)->id      = dev->id;
@@ -494,7 +488,7 @@
 			break;
 	}
 
-	read_unlock_bh(&rfcomm_dev_lock);
+	spin_unlock(&rfcomm_dev_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*di);
@@ -636,9 +630,10 @@
 }
 
 /* ---- TTY functions ---- */
-static void rfcomm_tty_wakeup(unsigned long arg)
+static void rfcomm_tty_wakeup(struct work_struct *work)
 {
-	struct rfcomm_dev *dev = (void *) arg;
+	struct rfcomm_dev *dev = container_of(work, struct rfcomm_dev,
+								wakeup_task);
 	struct tty_struct *tty = dev->tty;
 	if (!tty)
 		return;
@@ -763,7 +758,7 @@
 		rfcomm_dlc_close(dev->dlc, 0);
 
 		clear_bit(RFCOMM_TTY_ATTACHED, &dev->flags);
-		tasklet_kill(&dev->wakeup_task);
+		cancel_work_sync(&dev->wakeup_task);
 
 		rfcomm_dlc_lock(dev->dlc);
 		tty->driver_data = NULL;
@@ -771,9 +766,9 @@
 		rfcomm_dlc_unlock(dev->dlc);
 
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags)) {
-			write_lock_bh(&rfcomm_dev_lock);
+			spin_lock(&rfcomm_dev_lock);
 			list_del_init(&dev->list);
-			write_unlock_bh(&rfcomm_dev_lock);
+			spin_unlock(&rfcomm_dev_lock);
 
 			rfcomm_dev_put(dev);
 		}
@@ -1156,11 +1151,12 @@
 
 int __init rfcomm_init_ttys(void)
 {
+	int error;
+
 	rfcomm_tty_driver = alloc_tty_driver(RFCOMM_TTY_PORTS);
 	if (!rfcomm_tty_driver)
-		return -1;
+		return -ENOMEM;
 
-	rfcomm_tty_driver->owner	= THIS_MODULE;
 	rfcomm_tty_driver->driver_name	= "rfcomm";
 	rfcomm_tty_driver->name		= "rfcomm";
 	rfcomm_tty_driver->major	= RFCOMM_TTY_MAJOR;
@@ -1173,10 +1169,11 @@
 	rfcomm_tty_driver->init_termios.c_lflag &= ~ICANON;
 	tty_set_operations(rfcomm_tty_driver, &rfcomm_ops);
 
-	if (tty_register_driver(rfcomm_tty_driver)) {
+	error = tty_register_driver(rfcomm_tty_driver);
+	if (error) {
 		BT_ERR("Can't register RFCOMM TTY driver");
 		put_tty_driver(rfcomm_tty_driver);
-		return -1;
+		return error;
 	}
 
 	BT_INFO("RFCOMM TTY layer initialized");
diff -urN flo-ElementalX-5.00/net/bluetooth/sco.c flo-ElementalX-5.00-patched/net/bluetooth/sco.c
--- flo-ElementalX-5.00/net/bluetooth/sco.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/sco.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,7 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,7 +24,6 @@
 
 /* Bluetooth SCO sockets. */
 
-#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <linux/types.h>
@@ -43,9 +41,9 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/list.h>
+#include <linux/security.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -63,7 +61,7 @@
 static void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent);
 static void sco_chan_del(struct sock *sk, int err);
 
-static int  sco_conn_del(struct hci_conn *conn, int err, u8 is_process);
+static int  sco_conn_del(struct hci_conn *conn, int err);
 
 static void sco_sock_close(struct sock *sk);
 static void sco_sock_kill(struct sock *sk);
@@ -136,7 +134,7 @@
 	return sk;
 }
 
-static int sco_conn_del(struct hci_conn *hcon, int err, u8 is_process)
+static int sco_conn_del(struct hci_conn *hcon, int err)
 {
 	struct sco_conn *conn = hcon->sco_data;
 	struct sock *sk;
@@ -149,16 +147,10 @@
 	/* Kill socket */
 	sk = sco_chan_get(conn);
 	if (sk) {
-		if (is_process)
-			lock_sock(sk);
-		else
-			bh_lock_sock(sk);
+		bh_lock_sock(sk);
 		sco_sock_clear_timer(sk);
 		sco_chan_del(sk, err);
-		if (is_process)
-			release_sock(sk);
-		else
-			bh_unlock_sock(sk);
+		bh_unlock_sock(sk);
 		sco_sock_kill(sk);
 	}
 
@@ -181,11 +173,10 @@
 	return err;
 }
 
-static int sco_connect(struct sock *sk, __s8 is_wbs)
+static int sco_connect(struct sock *sk)
 {
 	bdaddr_t *src = &bt_sk(sk)->src;
 	bdaddr_t *dst = &bt_sk(sk)->dst;
-	__u16 pkt_type = sco_pi(sk)->pkt_type;
 	struct sco_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev  *hdev;
@@ -197,35 +188,19 @@
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 
-	hdev->is_wbs = is_wbs;
-
-	if (lmp_esco_capable(hdev) && !disable_esco) {
+	if (lmp_esco_capable(hdev) && !disable_esco)
 		type = ESCO_LINK;
-	} else if (is_wbs) {
-		return -ENAVAIL;
-	} else {
+	else
 		type = SCO_LINK;
-		pkt_type &= SCO_ESCO_MASK;
-	}
-
-	BT_DBG("type: %d, pkt_type: 0x%x", type, pkt_type);
 
-	hcon = hci_connect(hdev, type, pkt_type, dst,
-					BT_SECURITY_LOW, HCI_AT_NO_BONDING);
+	hcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (IS_ERR(hcon)) {
 		err = PTR_ERR(hcon);
 		goto done;
 	}
 
-	if (is_wbs && (hcon->type != ESCO_LINK)) {
-		BT_ERR("WBS [ hcon->type: 0x%x, hcon->pkt_type: 0x%x ]",
-				hcon->type, hcon->pkt_type);
-		err = -EREMOTEIO;
-		goto done;
-	}
-
 	conn = sco_conn_add(hcon, 0);
 	if (!conn) {
 		hci_conn_put(hcon);
@@ -249,7 +224,7 @@
 	}
 
 done:
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
@@ -397,14 +372,13 @@
 		if (sco_pi(sk)->conn) {
 			sk->sk_state = BT_DISCONN;
 			sco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);
-			if (sco_pi(sk)->conn->hcon != NULL) {
-				hci_conn_put(sco_pi(sk)->conn->hcon);
-				sco_pi(sk)->conn->hcon = NULL;
-			}
+			hci_conn_put(sco_pi(sk)->conn->hcon);
+			sco_pi(sk)->conn->hcon = NULL;
 		} else
 			sco_chan_del(sk, ECONNRESET);
 		break;
 
+	case BT_CONNECT2:
 	case BT_CONNECT:
 	case BT_DISCONN:
 		sco_chan_del(sk, ECONNRESET);
@@ -430,8 +404,10 @@
 {
 	BT_DBG("sk %p", sk);
 
-	if (parent)
+	if (parent) {
 		sk->sk_type = parent->sk_type;
+		security_sk_clone(parent, sk);
+	}
 }
 
 static struct proto sco_proto = {
@@ -487,22 +463,18 @@
 	return 0;
 }
 
-static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
+static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
-	struct sockaddr_sco sa;
+	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	bdaddr_t *src = &sa.sco_bdaddr;
-	int len, err = 0;
+	bdaddr_t *src = &sa->sco_bdaddr;
+	int err = 0;
 
-	BT_DBG("sk %p %s", sk, batostr(&sa.sco_bdaddr));
+	BT_DBG("sk %p %s", sk, batostr(&sa->sco_bdaddr));
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
-	len = min_t(unsigned int, sizeof(sa), alen);
-	memcpy(&sa, addr, len);
-
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -510,18 +482,17 @@
 		goto done;
 	}
 
-	write_lock_bh(&sco_sk_list.lock);
+	write_lock(&sco_sk_list.lock);
 
 	if (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &sa.sco_bdaddr);
-		sco_pi(sk)->pkt_type = sa.sco_pkt_type;
+		bacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock_bh(&sco_sk_list.lock);
+	write_unlock(&sco_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -530,36 +501,29 @@
 
 static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
+	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	struct sockaddr_sco sa;
-	int len, err = 0;
+	int err = 0;
+
 
 	BT_DBG("sk %p", sk);
 
-	if (!addr || addr->sa_family != AF_BLUETOOTH)
+	if (alen < sizeof(struct sockaddr_sco) ||
+	    addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	memset(&sa, 0, sizeof(sa));
-	len = min_t(unsigned int, sizeof(sa), alen);
-	memcpy(&sa, addr, len);
-
-	lock_sock(sk);
+	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)
+		return -EBADFD;
 
-	if (sk->sk_type != SOCK_SEQPACKET) {
-		err = -EINVAL;
-		goto done;
-	}
+	if (sk->sk_type != SOCK_SEQPACKET)
+		return -EINVAL;
 
-	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {
-		err = -EBADFD;
-		goto done;
-	}
+	lock_sock(sk);
 
 	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
-	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
+	bacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);
 
-	err = sco_connect(sk, sa.is_wbs);
+	err = sco_connect(sk);
 	if (err)
 		goto done;
 
@@ -603,30 +567,26 @@
 
 	lock_sock(sk);
 
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(ch = bt_accept_dequeue(sk, newsock))) {
+	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
+
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
+		ch = bt_accept_dequeue(sk, newsock);
+		if (ch)
+			break;
 
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
@@ -634,8 +594,12 @@
 			err = sock_intr_errno(timeo);
 			break;
 		}
+
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock(sk);
 	}
-	set_current_state(TASK_RUNNING);
+	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -664,7 +628,6 @@
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);
 	else
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);
-	sa->sco_pkt_type = sco_pi(sk)->pkt_type;
 
 	return 0;
 }
@@ -814,9 +777,6 @@
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
 							sk->sk_lingertime);
-		else
-			err = bt_sock_wait_state(sk, BT_CLOSED,
-							SCO_DISCONN_TIMEOUT);
 	}
 	release_sock(sk);
 	return err;
@@ -838,11 +798,6 @@
 		lock_sock(sk);
 		err = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);
 		release_sock(sk);
-	} else {
-		lock_sock(sk);
-		err = bt_sock_wait_state(sk, BT_CLOSED,
-							SCO_DISCONN_TIMEOUT);
-		release_sock(sk);
 	}
 
 	sock_orphan(sk);
@@ -938,15 +893,12 @@
 }
 
 /* ----- SCO interface with lower layer (HCI) ----- */
-static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	register struct sock *sk;
 	struct hlist_node *node;
 	int lm = 0;
 
-	if (type != SCO_LINK && type != ESCO_LINK)
-		return 0;
-
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets */
@@ -966,13 +918,9 @@
 	return lm;
 }
 
-static int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
+int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
 {
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
-
-	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
-		return -EINVAL;
-
 	if (!status) {
 		struct sco_conn *conn;
 
@@ -980,24 +928,20 @@
 		if (conn)
 			sco_conn_ready(conn);
 	} else
-		sco_conn_del(hcon, bt_err(status), 0);
+		sco_conn_del(hcon, bt_to_errno(status));
 
 	return 0;
 }
 
-static int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason, __u8 is_process)
+int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
-		return -EINVAL;
-
-	sco_conn_del(hcon, bt_err(reason), is_process);
-
+	sco_conn_del(hcon, bt_to_errno(reason));
 	return 0;
 }
 
-static int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
+int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
 {
 	struct sco_conn *conn = hcon->sco_data;
 
@@ -1021,14 +965,14 @@
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock_bh(&sco_sk_list.lock);
+	read_lock(&sco_sk_list.lock);
 
 	sk_for_each(sk, node, &sco_sk_list.head) {
 		seq_printf(f, "%s %s %d\n", batostr(&bt_sk(sk)->src),
 				batostr(&bt_sk(sk)->dst), sk->sk_state);
 	}
 
-	read_unlock_bh(&sco_sk_list.lock);
+	read_unlock(&sco_sk_list.lock);
 
 	return 0;
 }
@@ -1073,15 +1017,6 @@
 	.create	= sco_sock_create,
 };
 
-static struct hci_proto sco_hci_proto = {
-	.name		= "SCO",
-	.id		= HCI_PROTO_SCO,
-	.connect_ind	= sco_connect_ind,
-	.connect_cfm	= sco_connect_cfm,
-	.disconn_cfm	= sco_disconn_cfm,
-	.recv_scodata	= sco_recv_scodata
-};
-
 int __init sco_init(void)
 {
 	int err;
@@ -1096,13 +1031,6 @@
 		goto error;
 	}
 
-	err = hci_register_proto(&sco_hci_proto);
-	if (err < 0) {
-		BT_ERR("SCO protocol registration failed");
-		bt_sock_unregister(BTPROTO_SCO);
-		goto error;
-	}
-
 	if (bt_debugfs) {
 		sco_debugfs = debugfs_create_file("sco", 0444,
 					bt_debugfs, NULL, &sco_debugfs_fops);
@@ -1126,9 +1054,6 @@
 	if (bt_sock_unregister(BTPROTO_SCO) < 0)
 		BT_ERR("SCO socket unregistration failed");
 
-	if (hci_unregister_proto(&sco_hci_proto) < 0)
-		BT_ERR("SCO protocol unregistration failed");
-
 	proto_unregister(&sco_proto);
 }
 
diff -urN flo-ElementalX-5.00/net/bluetooth/smp.c flo-ElementalX-5.00-patched/net/bluetooth/smp.c
--- flo-ElementalX-5.00/net/bluetooth/smp.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/net/bluetooth/smp.c	2016-06-02 00:28:55.000000000 +0000
@@ -1,6 +1,5 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2013 The Linux Foundation.  All rights reserved.
    Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
 
    This program is free software; you can redistribute it and/or modify
@@ -21,31 +20,18 @@
    SOFTWARE IS DISCLAIMED.
 */
 
-#include <linux/interrupt.h>
-#include <linux/module.h>
-
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 #include <linux/crypto.h>
+#include <linux/scatterlist.h>
 #include <crypto/b128ops.h>
-#include <asm/unaligned.h>
-
-#define SMP_TIMEOUT 30000 /* 30 seconds */
-
-#define SMP_MIN_CONN_INTERVAL	40	/* 50ms (40 * 1.25ms) */
-#define SMP_MAX_CONN_INTERVAL	56	/* 70ms (56 * 1.25ms) */
-#define SMP_MAX_CONN_LATENCY	0	/* 0ms (0 * 1.25ms) */
-#define SMP_SUPERVISION_TIMEOUT	500	/* 5 seconds (500 * 10ms) */
 
-#ifndef FALSE
-#define FALSE 0
-#define TRUE (!FALSE)
-#endif
+#define SMP_TIMEOUT	msecs_to_jiffies(30000)
 
-static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+#define AUTH_REQ_MASK   0x07
 
 static inline void swap128(u8 src[16], u8 dst[16])
 {
@@ -163,7 +149,7 @@
 }
 
 static struct sk_buff *smp_build_cmd(struct l2cap_conn *conn, u8 code,
-		u16 dlen, void *data)
+						u16 dlen, void *data)
 {
 	struct sk_buff *skb;
 	struct l2cap_hdr *lh;
@@ -198,26 +184,28 @@
 	if (!skb)
 		return;
 
-	hci_send_acl(conn->hcon, NULL, skb, 0);
+	skb->priority = HCI_PRIO_MAX;
+	hci_send_acl(conn->hchan, skb, 0);
+
+	cancel_delayed_work_sync(&conn->security_timer);
+	schedule_delayed_work(&conn->security_timer, SMP_TIMEOUT);
 }
 
 static __u8 authreq_to_seclevel(__u8 authreq)
 {
 	if (authreq & SMP_AUTH_MITM)
 		return BT_SECURITY_HIGH;
-	else if (authreq & SMP_AUTH_BONDING)
-		return BT_SECURITY_MEDIUM;
 	else
-		return BT_SECURITY_LOW;
+		return BT_SECURITY_MEDIUM;
 }
 
-static __u8 seclevel_to_authreq(__u8 level)
+static __u8 seclevel_to_authreq(__u8 sec_level)
 {
-	switch (level) {
-	case BT_SECURITY_VERY_HIGH:
+	switch (sec_level) {
 	case BT_SECURITY_HIGH:
 		return SMP_AUTH_MITM | SMP_AUTH_BONDING;
-
+	case BT_SECURITY_MEDIUM:
+		return SMP_AUTH_BONDING;
 	default:
 		return SMP_AUTH_NONE;
 	}
@@ -228,562 +216,583 @@
 				struct smp_cmd_pairing *rsp,
 				__u8 authreq)
 {
-	struct hci_conn *hcon = conn->hcon;
-	u8 all_keys = 0;
 	u8 dist_keys = 0;
 
-	dist_keys = SMP_DIST_ENC_KEY;
-	authreq |= SMP_AUTH_BONDING;
-
-	BT_DBG("conn->hcon->io_capability:%d", conn->hcon->io_capability);
+	if (test_bit(HCI_PAIRABLE, &conn->hcon->hdev->dev_flags)) {
+		dist_keys = SMP_DIST_ENC_KEY;
+		authreq |= SMP_AUTH_BONDING;
+	} else {
+		authreq &= ~SMP_AUTH_BONDING;
+	}
 
 	if (rsp == NULL) {
 		req->io_capability = conn->hcon->io_capability;
-		req->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
-							SMP_OOB_NOT_PRESENT;
+		req->oob_flag = SMP_OOB_NOT_PRESENT;
 		req->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-		req->init_key_dist = all_keys;
+		req->init_key_dist = 0;
 		req->resp_key_dist = dist_keys;
-		req->auth_req = authreq;
-		BT_DBG("SMP_CMD_PAIRING_REQ %d %d %d %d %2.2x %2.2x",
-				req->io_capability, req->oob_flag,
-				req->auth_req, req->max_key_size,
-				req->init_key_dist, req->resp_key_dist);
+		req->auth_req = (authreq & AUTH_REQ_MASK);
 		return;
 	}
 
-	/* Only request OOB if remote AND we support it */
-	if (req->oob_flag)
-		rsp->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
-						SMP_OOB_NOT_PRESENT;
-	else
-		rsp->oob_flag = SMP_OOB_NOT_PRESENT;
-
 	rsp->io_capability = conn->hcon->io_capability;
+	rsp->oob_flag = SMP_OOB_NOT_PRESENT;
 	rsp->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-	rsp->init_key_dist = req->init_key_dist & all_keys;
+	rsp->init_key_dist = 0;
 	rsp->resp_key_dist = req->resp_key_dist & dist_keys;
-	rsp->auth_req = authreq;
-	BT_DBG("SMP_CMD_PAIRING_RSP %d %d %d %d %2.2x %2.2x",
-			req->io_capability, req->oob_flag, req->auth_req,
-			req->max_key_size, req->init_key_dist,
-			req->resp_key_dist);
+	rsp->auth_req = (authreq & AUTH_REQ_MASK);
 }
 
 static u8 check_enc_key_size(struct l2cap_conn *conn, __u8 max_key_size)
 {
-	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp = conn->smp_chan;
 
 	if ((max_key_size > SMP_MAX_ENC_KEY_SIZE) ||
 			(max_key_size < SMP_MIN_ENC_KEY_SIZE))
 		return SMP_ENC_KEY_SIZE;
 
-	hcon->smp_key_size = max_key_size;
+	smp->enc_key_size = max_key_size;
 
 	return 0;
 }
 
-#define JUST_WORKS	SMP_JUST_WORKS
-#define REQ_PASSKEY	SMP_REQ_PASSKEY
-#define CFM_PASSKEY	SMP_CFM_PASSKEY
-#define JUST_CFM	SMP_JUST_CFM
-#define OVERLAP		SMP_OVERLAP
-static const u8	gen_method[5][5] = {
-	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
-	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
-	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY},
-	{JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM},
-	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP}
+static void smp_failure(struct l2cap_conn *conn, u8 reason, u8 send)
+{
+	struct hci_conn *hcon = conn->hcon;
+
+	if (send)
+		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
+								&reason);
+
+	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->flags);
+	mgmt_auth_failed(conn->hcon->hdev, conn->dst, hcon->type,
+			 hcon->dst_type, reason);
+
+	cancel_delayed_work_sync(&conn->security_timer);
+
+	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		smp_chan_destroy(conn);
+}
+
+#define JUST_WORKS	0x00
+#define JUST_CFM	0x01
+#define REQ_PASSKEY	0x02
+#define CFM_PASSKEY	0x03
+#define REQ_OOB		0x04
+#define OVERLAP		0xFF
+
+static const u8 gen_method[5][5] = {
+	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
+	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
+	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },
+	{ JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM    },
+	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP     },
 };
 
 static int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,
 						u8 local_io, u8 remote_io)
 {
 	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp = conn->smp_chan;
 	u8 method;
 	u32 passkey = 0;
 	int ret = 0;
 
-	/* Initialize key to JUST WORKS */
-	memset(hcon->tk, 0, sizeof(hcon->tk));
-	hcon->tk_valid = FALSE;
-	hcon->auth = auth;
-
-	/* By definition, OOB data will be used if both sides have it available
-	 */
-	if (remote_oob && hcon->oob) {
-		method = SMP_REQ_OOB;
-		goto agent_request;
-	}
+	/* Initialize key for JUST WORKS */
+	memset(smp->tk, 0, sizeof(smp->tk));
+	clear_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 
 	BT_DBG("tk_request: auth:%d lcl:%d rem:%d", auth, local_io, remote_io);
 
 	/* If neither side wants MITM, use JUST WORKS */
-	/* If either side has unknown io_caps, use JUST_WORKS */
+	/* If either side has unknown io_caps, use JUST WORKS */
+	/* Otherwise, look up method from the table */
 	if (!(auth & SMP_AUTH_MITM) ||
 			local_io > SMP_IO_KEYBOARD_DISPLAY ||
-			remote_io > SMP_IO_KEYBOARD_DISPLAY) {
-		hcon->auth &= ~SMP_AUTH_MITM;
-		hcon->tk_valid = TRUE;
+			remote_io > SMP_IO_KEYBOARD_DISPLAY)
+		method = JUST_WORKS;
+	else
+		method = gen_method[remote_io][local_io];
+
+	/* If not bonding, don't ask user to confirm a Zero TK */
+	if (!(auth & SMP_AUTH_BONDING) && method == JUST_CFM)
+		method = JUST_WORKS;
+
+	/* If Just Works, Continue with Zero TK */
+	if (method == JUST_WORKS) {
+		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 		return 0;
 	}
 
-	/* MITM is now officially requested, but not required */
-	/* Determine what we need (if anything) from the agent */
-	method = gen_method[local_io][remote_io];
-
-	BT_DBG("tk_method: %d", method);
-
-	if (method == SMP_JUST_WORKS || method == SMP_JUST_CFM)
-		hcon->auth &= ~SMP_AUTH_MITM;
-
-	/* Don't bother confirming unbonded JUST_WORKS */
-	if (!(auth & SMP_AUTH_BONDING) && method == SMP_JUST_CFM) {
-		hcon->tk_valid = TRUE;
-		return 0;
-	} else if (method == SMP_JUST_WORKS) {
-		hcon->tk_valid = TRUE;
-		return 0;
-	} else if (method == SMP_OVERLAP) {
+	/* Not Just Works/Confirm results in MITM Authentication */
+	if (method != JUST_CFM)
+		set_bit(SMP_FLAG_MITM_AUTH, &smp->smp_flags);
+
+	/* If both devices have Keyoard-Display I/O, the master
+	 * Confirms and the slave Enters the passkey.
+	 */
+	if (method == OVERLAP) {
 		if (hcon->link_mode & HCI_LM_MASTER)
-			method = SMP_CFM_PASSKEY;
+			method = CFM_PASSKEY;
 		else
-			method = SMP_REQ_PASSKEY;
+			method = REQ_PASSKEY;
 	}
 
-	BT_DBG("tk_method-2: %d", method);
-
-	if (method == SMP_CFM_PASSKEY) {
+	/* Generate random passkey. Not valid until confirmed. */
+	if (method == CFM_PASSKEY) {
 		u8 key[16];
-		/* Generate a passkey for display. It is not valid until
-		 * confirmed.
-		 */
+
 		memset(key, 0, sizeof(key));
 		get_random_bytes(&passkey, sizeof(passkey));
 		passkey %= 1000000;
 		put_unaligned_le32(passkey, key);
-		swap128(key, hcon->tk);
+		swap128(key, smp->tk);
 		BT_DBG("PassKey: %d", passkey);
 	}
 
-agent_request:
 	hci_dev_lock(hcon->hdev);
 
-	switch (method) {
-	case SMP_REQ_PASSKEY:
-		ret = mgmt_user_confirm_request(hcon->hdev->id,
-				HCI_EV_USER_PASSKEY_REQUEST, conn->dst, 0);
-		break;
-	case SMP_CFM_PASSKEY:
-	default:
-		ret = mgmt_user_confirm_request(hcon->hdev->id,
-			HCI_EV_USER_CONFIRM_REQUEST, conn->dst, passkey);
-		break;
-	}
+	if (method == REQ_PASSKEY)
+		ret = mgmt_user_passkey_request(hcon->hdev, conn->dst,
+						hcon->type, hcon->dst_type);
+	else
+		ret = mgmt_user_confirm_request(hcon->hdev, conn->dst,
+						hcon->type, hcon->dst_type,
+						cpu_to_le32(passkey), 0);
 
 	hci_dev_unlock(hcon->hdev);
 
 	return ret;
 }
 
-static int send_pairing_confirm(struct l2cap_conn *conn)
+static void confirm_work(struct work_struct *work)
 {
-	struct hci_conn *hcon = conn->hcon;
-	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
+	struct smp_chan *smp = container_of(work, struct smp_chan, confirm);
+	struct l2cap_conn *conn = smp->conn;
+	struct crypto_blkcipher *tfm;
 	struct smp_cmd_pairing_confirm cp;
 	int ret;
-	u8 res[16];
+	u8 res[16], reason;
+
+	BT_DBG("conn %p", conn);
+
+	tfm = crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	smp->tfm = tfm;
 
 	if (conn->hcon->out)
-		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
-				0, conn->src, hcon->dst_type, conn->dst, res);
+		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp, 0,
+			     conn->src, conn->hcon->dst_type, conn->dst, res);
 	else
-		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
-				hcon->dst_type, conn->dst, 0, conn->src, res);
+		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp,
+			     conn->hcon->dst_type, conn->dst, 0, conn->src,
+			     res);
+	if (ret) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
 
-	if (ret)
-		return SMP_CONFIRM_FAILED;
+	clear_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
 
 	swap128(res, cp.confirm_val);
+	smp_send_cmd(smp->conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
 
-	hcon->cfm_pending = FALSE;
+	return;
 
-	smp_send_cmd(conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
+error:
+	smp_failure(conn, reason, 1);
+}
 
-	return 0;
+static void random_work(struct work_struct *work)
+{
+	struct smp_chan *smp = container_of(work, struct smp_chan, random);
+	struct l2cap_conn *conn = smp->conn;
+	struct hci_conn *hcon = conn->hcon;
+	struct crypto_blkcipher *tfm = smp->tfm;
+	u8 reason, confirm[16], res[16], key[16];
+	int ret;
+
+	if (IS_ERR_OR_NULL(tfm)) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
+
+	if (hcon->out)
+		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp, 0,
+			     conn->src, hcon->dst_type, conn->dst, res);
+	else
+		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp,
+			     hcon->dst_type, conn->dst, 0, conn->src, res);
+	if (ret) {
+		reason = SMP_UNSPECIFIED;
+		goto error;
+	}
+
+	swap128(res, confirm);
+
+	if (memcmp(smp->pcnf, confirm, sizeof(smp->pcnf)) != 0) {
+		BT_ERR("Pairing failed (confirmation values mismatch)");
+		reason = SMP_CONFIRM_FAILED;
+		goto error;
+	}
+
+	if (hcon->out) {
+		u8 stk[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		smp_s1(tfm, smp->tk, smp->rrnd, smp->prnd, key);
+		swap128(key, stk);
+
+		memset(stk + smp->enc_key_size, 0,
+		       SMP_MAX_ENC_KEY_SIZE - smp->enc_key_size);
+
+		if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags)) {
+			reason = SMP_UNSPECIFIED;
+			goto error;
+		}
+
+		hci_le_start_enc(hcon, ediv, rand, stk);
+		hcon->enc_key_size = smp->enc_key_size;
+	} else {
+		u8 stk[16], r[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		swap128(smp->prnd, r);
+		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
+
+		smp_s1(tfm, smp->tk, smp->prnd, smp->rrnd, key);
+		swap128(key, stk);
+
+		memset(stk + smp->enc_key_size, 0,
+				SMP_MAX_ENC_KEY_SIZE - smp->enc_key_size);
+
+		hci_add_ltk(hcon->hdev, conn->dst, hcon->dst_type,
+			    HCI_SMP_STK_SLAVE, 0, 0, stk, smp->enc_key_size,
+			    ediv, rand);
+	}
+
+	return;
+
+error:
+	smp_failure(conn, reason, 1);
 }
 
-int le_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, void *cp)
+static struct smp_chan *smp_chan_create(struct l2cap_conn *conn)
+{
+	struct smp_chan *smp;
+
+	smp = kzalloc(sizeof(struct smp_chan), GFP_ATOMIC);
+	if (!smp)
+		return NULL;
+
+	INIT_WORK(&smp->confirm, confirm_work);
+	INIT_WORK(&smp->random, random_work);
+
+	smp->conn = conn;
+	conn->smp_chan = smp;
+	conn->hcon->smp_conn = conn;
+
+	hci_conn_hold(conn->hcon);
+
+	return smp;
+}
+
+void smp_chan_destroy(struct l2cap_conn *conn)
+{
+	struct smp_chan *smp = conn->smp_chan;
+
+	BUG_ON(!smp);
+
+	if (smp->tfm)
+		crypto_free_blkcipher(smp->tfm);
+
+	kfree(smp);
+	conn->smp_chan = NULL;
+	conn->hcon->smp_conn = NULL;
+	hci_conn_put(conn->hcon);
+}
+
+int smp_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, __le32 passkey)
 {
-	struct mgmt_cp_user_passkey_reply *psk_reply = cp;
 	struct l2cap_conn *conn = hcon->smp_conn;
+	struct smp_chan *smp;
+	u32 value;
 	u8 key[16];
-	u8 reason = 0;
-	int ret = 0;
 
 	BT_DBG("");
 
-	hcon->tk_valid = TRUE;
+	if (!conn)
+		return -ENOTCONN;
+
+	smp = conn->smp_chan;
 
 	switch (mgmt_op) {
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		reason = SMP_CONFIRM_FAILED;
-		break;
-	case MGMT_OP_USER_CONFIRM_REPLY:
-		break;
 	case MGMT_OP_USER_PASSKEY_REPLY:
+		value = le32_to_cpu(passkey);
 		memset(key, 0, sizeof(key));
-		BT_DBG("PassKey: %d", psk_reply->passkey);
-		put_unaligned_le32(psk_reply->passkey, key);
-		swap128(key, hcon->tk);
+		BT_DBG("PassKey: %d", value);
+		put_unaligned_le32(value, key);
+		swap128(key, smp->tk);
+		/* Fall Through */
+	case MGMT_OP_USER_CONFIRM_REPLY:
+		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
 		break;
+	case MGMT_OP_USER_PASSKEY_NEG_REPLY:
+	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
+		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
+		return 0;
 	default:
-		reason = SMP_CONFIRM_FAILED;
-		ret = -EOPNOTSUPP;
-		break;
+		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
+		return -EOPNOTSUPP;
 	}
 
-	if (reason) {
-		BT_DBG("smp_send_cmd: SMP_CMD_PAIRING_FAIL");
-		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
-								&reason);
-		del_timer(&hcon->smp_timer);
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
-		hci_conn_put(hcon);
-	} else if (hcon->cfm_pending) {
-		BT_DBG("send_pairing_confirm");
-		ret = send_pairing_confirm(conn);
-	}
+	/* If it is our turn to send Pairing Confirm, do so now */
+	if (test_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags))
+		queue_work(hcon->hdev->workqueue, &smp->confirm);
 
-	return ret;
+	return 0;
 }
 
 static u8 smp_cmd_pairing_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing rsp, *req = (void *) skb->data;
+	struct smp_chan *smp;
 	u8 key_size;
 	u8 auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
-	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&hcon->preq[1], req, sizeof(*req));
+	if (conn->hcon->link_mode & HCI_LM_MASTER)
+		return SMP_CMD_NOTSUPP;
+
+	if (!test_and_set_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		smp = smp_chan_create(conn);
+
+	smp = conn->smp_chan;
+
+	smp->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&smp->preq[1], req, sizeof(*req));
 	skb_pull(skb, sizeof(*req));
 
-	if (req->oob_flag && hcon->oob) {
-		/* By definition, OOB data pairing will have MITM protection */
-		auth = req->auth_req | SMP_AUTH_MITM;
-	} else if (req->auth_req & SMP_AUTH_BONDING) {
-		/* We will attempt MITM for all Bonding attempts */
-		auth = SMP_AUTH_BONDING | SMP_AUTH_MITM;
-	}
+	/* We didn't start the pairing, so match remote */
+	if (req->auth_req & SMP_AUTH_BONDING)
+		auth = req->auth_req;
+
+	conn->hcon->pending_sec_level = authreq_to_seclevel(auth);
 
-	/* We didn't start the pairing, so no requirements */
 	build_pairing_cmd(conn, req, &rsp, auth);
 
 	key_size = min(req->max_key_size, rsp.max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	ret = smp_rand(hcon->prnd);
+	ret = smp_rand(smp->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	/* Request setup of TK */
-	ret = tk_request(conn, req->oob_flag, auth, rsp.io_capability,
-							req->io_capability);
-	if (ret)
-		return SMP_UNSPECIFIED;
-
-	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&hcon->prsp[1], &rsp, sizeof(rsp));
+	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&smp->prsp[1], &rsp, sizeof(rsp));
 
 	smp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);
 
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+	/* Request setup of TK */
+	ret = tk_request(conn, 0, auth, rsp.io_capability, req->io_capability);
+	if (ret)
+		return SMP_UNSPECIFIED;
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_rsp(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp = (void *) skb->data;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 	u8 key_size, auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
+	if (!(conn->hcon->link_mode & HCI_LM_MASTER))
+		return SMP_CMD_NOTSUPP;
+
 	skb_pull(skb, sizeof(*rsp));
 
-	req = (void *) &hcon->preq[1];
+	req = (void *) &smp->preq[1];
 
 	key_size = min(req->max_key_size, rsp->max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&hcon->prsp[1], rsp, sizeof(*rsp));
-
-	ret = smp_rand(hcon->prnd);
+	ret = smp_rand(smp->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
+	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&smp->prsp[1], rsp, sizeof(*rsp));
+
 	if ((req->auth_req & SMP_AUTH_BONDING) &&
 			(rsp->auth_req & SMP_AUTH_BONDING))
 		auth = SMP_AUTH_BONDING;
 
 	auth |= (req->auth_req | rsp->auth_req) & SMP_AUTH_MITM;
 
-	ret = tk_request(conn, req->oob_flag, auth, rsp->io_capability,
-							req->io_capability);
+	ret = tk_request(conn, 0, auth, rsp->io_capability, req->io_capability);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	hcon->cfm_pending = TRUE;
+	set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
 
 	/* Can't compose response until we have been confirmed */
-	if (!hcon->tk_valid)
+	if (!test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags))
 		return 0;
 
-	ret = send_pairing_confirm(conn);
-	if (ret)
-		return SMP_CONFIRM_FAILED;
+	queue_work(hdev->workqueue, &smp->confirm);
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_confirm(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
-	int ret;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 
 	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
 
-	memcpy(hcon->pcnf, skb->data, sizeof(hcon->pcnf));
-	skb_pull(skb, sizeof(hcon->pcnf));
+	memcpy(smp->pcnf, skb->data, sizeof(smp->pcnf));
+	skb_pull(skb, sizeof(smp->pcnf));
 
 	if (conn->hcon->out) {
 		u8 random[16];
 
-		swap128(hcon->prnd, random);
+		swap128(smp->prnd, random);
 		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(random),
 								random);
-	} else if (hcon->tk_valid) {
-		ret = send_pairing_confirm(conn);
-
-		if (ret)
-			return SMP_CONFIRM_FAILED;
-	} else
-		hcon->cfm_pending = TRUE;
-
-
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+	} else if (test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags)) {
+		queue_work(hdev->workqueue, &smp->confirm);
+	} else {
+		set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
+	}
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
-	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
-	int ret;
-	u8 key[16], res[16], random[16], confirm[16];
-
-	swap128(skb->data, random);
-	skb_pull(skb, sizeof(random));
-
-	if (conn->hcon->out)
-		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp, 0,
-				conn->src, hcon->dst_type, conn->dst,
-				res);
-	else
-		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp,
-				hcon->dst_type, conn->dst, 0, conn->src,
-				res);
-	if (ret)
-		return SMP_UNSPECIFIED;
-
-	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
-
-	swap128(res, confirm);
-
-	if (memcmp(hcon->pcnf, confirm, sizeof(hcon->pcnf)) != 0) {
-		BT_ERR("Pairing failed (confirmation values mismatch)");
-		return SMP_CONFIRM_FAILED;
-	}
-
-	if (conn->hcon->out) {
-		u8 stk[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		smp_s1(tfm, hcon->tk, random, hcon->prnd, key);
-		swap128(key, stk);
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
 
-		memset(stk + hcon->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
-
-		hci_le_start_enc(hcon, ediv, rand, stk);
-		hcon->enc_key_size = hcon->smp_key_size;
-	} else {
-		u8 stk[16], r[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		swap128(hcon->prnd, r);
-		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
-
-		smp_s1(tfm, hcon->tk, hcon->prnd, random, key);
-		swap128(key, stk);
+	BT_DBG("conn %p", conn);
 
-		memset(stk + hcon->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
+	swap128(skb->data, smp->rrnd);
+	skb_pull(skb, sizeof(smp->rrnd));
 
-		hci_add_ltk(conn->hcon->hdev, 0, conn->dst, hcon->dst_type,
-			hcon->smp_key_size, hcon->auth, ediv, rand, stk);
-	}
+	queue_work(hdev->workqueue, &smp->random);
 
 	return 0;
 }
 
-static int smp_encrypt_link(struct hci_conn *hcon, struct link_key *key)
+static u8 smp_ltk_encrypt(struct l2cap_conn *conn)
 {
-	struct key_master_id *master;
-	u8 sec_level;
-	u8 zerobuf[8];
-
-	if (!hcon || !key || !key->data)
-		return -EINVAL;
-
-	memset(zerobuf, 0, sizeof(zerobuf));
-
-	master = (void *) key->data;
-
-	if (!master->ediv && !memcmp(master->rand, zerobuf, sizeof(zerobuf)))
-		return -EINVAL;
-
-	hcon->enc_key_size = key->pin_len;
-	hcon->sec_req = TRUE;
-	sec_level = authreq_to_seclevel(key->auth);
-
-	BT_DBG("cur %d, req: %d", hcon->sec_level, sec_level);
+	struct smp_ltk *key;
+	struct hci_conn *hcon = conn->hcon;
 
-	if (sec_level > hcon->sec_level)
-		hcon->pending_sec_level = sec_level;
+	key = hci_find_ltk_by_addr(hcon->hdev, conn->dst, hcon->dst_type);
+	if (!key)
+		return 0;
 
+	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->flags))
+		return 1;
 
-	if (!(hcon->link_mode & HCI_LM_ENCRYPT))
-		hci_conn_hold(hcon);
+	hci_le_start_enc(hcon, key->ediv, key->rand, key->val);
+	hcon->enc_key_size = key->enc_size;
 
-	hci_le_start_enc(hcon, master->ediv, master->rand, key->val);
+	return 1;
 
-	return 0;
 }
-
 static u8 smp_cmd_security_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_security_req *rp = (void *) skb->data;
 	struct smp_cmd_pairing cp;
-	struct link_key *key;
+	struct hci_conn *hcon = conn->hcon;
+	struct smp_chan *smp;
 
 	BT_DBG("conn %p", conn);
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
-		return 0;
-
-	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
-	if (key && ((key->auth & SMP_AUTH_MITM) ||
-					!(rp->auth_req & SMP_AUTH_MITM))) {
+	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
 
-		if (smp_encrypt_link(hcon, key) < 0)
-			goto invalid_key;
+	if (smp_ltk_encrypt(conn))
+		return 0;
 
+	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags))
 		return 0;
-	}
 
-invalid_key:
-	hcon->sec_req = FALSE;
+	smp = smp_chan_create(conn);
 
 	skb_pull(skb, sizeof(*rp));
 
 	memset(&cp, 0, sizeof(cp));
 	build_pairing_cmd(conn, &cp, NULL, rp->auth_req);
 
-	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
-	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&hcon->preq[1], &cp, sizeof(cp));
+	smp->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&smp->preq[1], &cp, sizeof(cp));
 
 	smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
 
-	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
-
-	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-
-	hci_conn_hold(hcon);
-
 	return 0;
 }
 
-int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level)
+int smp_conn_security(struct hci_conn *hcon, __u8 sec_level)
 {
-	struct hci_conn *hcon = conn->hcon;
+	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct smp_chan *smp = conn->smp_chan;
 	__u8 authreq;
 
-	BT_DBG("conn %p hcon %p %d req: %d",
-			conn, hcon, hcon->sec_level, sec_level);
+	BT_DBG("conn %p hcon %p level 0x%2.2x", conn, hcon, sec_level);
 
-	if (IS_ERR(hcon->hdev->tfm))
+	if (!lmp_host_le_capable(hcon->hdev))
 		return 1;
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
-		return -EINPROGRESS;
-
 	if (sec_level == BT_SECURITY_LOW)
 		return 1;
 
-
 	if (hcon->sec_level >= sec_level)
 		return 1;
 
-	authreq = seclevel_to_authreq(sec_level);
-
-	hcon->smp_conn = conn;
-	hcon->pending_sec_level = sec_level;
-	if (hcon->link_mode & HCI_LM_MASTER) {
-		struct link_key *key;
+	if (hcon->link_mode & HCI_LM_MASTER)
+		if (smp_ltk_encrypt(conn))
+			goto done;
 
-		key = hci_find_link_key_type(hcon->hdev, conn->dst,
-							KEY_TYPE_LTK);
+	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->flags))
+		return 0;
 
-		if (smp_encrypt_link(hcon, key) == 0)
-			goto done;
-	}
+	smp = smp_chan_create(conn);
+	if (!smp)
+		return 1;
 
-	hcon->sec_req = FALSE;
+	authreq = seclevel_to_authreq(sec_level);
 
 	if (hcon->link_mode & HCI_LM_MASTER) {
 		struct smp_cmd_pairing cp;
 
 		build_pairing_cmd(conn, &cp, NULL, authreq);
-		hcon->preq[0] = SMP_CMD_PAIRING_REQ;
-		memcpy(&hcon->preq[1], &cp, sizeof(cp));
-
-		mod_timer(&hcon->smp_timer, jiffies +
-					msecs_to_jiffies(SMP_TIMEOUT));
+		smp->preq[0] = SMP_CMD_PAIRING_REQ;
+		memcpy(&smp->preq[1], &cp, sizeof(cp));
 
 		smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
-		hci_conn_hold(hcon);
 	} else {
 		struct smp_cmd_security_req cp;
 		cp.auth_req = authreq;
@@ -791,95 +800,80 @@
 	}
 
 done:
-	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+	hcon->pending_sec_level = sec_level;
 
 	return 0;
 }
 
 static int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_encrypt_info *rp = (void *) skb->data;
-	u8 rand[8];
-	int err;
+	struct smp_chan *smp = conn->smp_chan;
 
 	skb_pull(skb, sizeof(*rp));
 
-	BT_DBG("conn %p", conn);
-
-	memset(rand, 0, sizeof(rand));
-
-	err = hci_add_ltk(hcon->hdev, 0, conn->dst, hcon->dst_type,
-						0, 0, 0, rand, rp->ltk);
-	if (err)
-		return SMP_UNSPECIFIED;
+	memcpy(smp->tk, rp->ltk, sizeof(smp->tk));
 
 	return 0;
 }
 
 static int smp_cmd_master_ident(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_master_ident *rp = (void *) skb->data;
-	struct smp_cmd_pairing *paircmd = (void *) &hcon->prsp[1];
-	struct link_key *key;
-	u8 *keydist;
+	struct smp_chan *smp = conn->smp_chan;
+	struct hci_dev *hdev = conn->hcon->hdev;
+	struct hci_conn *hcon = conn->hcon;
+	u8 authenticated;
 
 	skb_pull(skb, sizeof(*rp));
 
-	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
-	if (key == NULL)
-		return SMP_UNSPECIFIED;
-
-	if (hcon->out)
-		keydist = &paircmd->resp_key_dist;
-	else
-		keydist = &paircmd->init_key_dist;
-
-	BT_DBG("keydist 0x%x", *keydist);
-
-	hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
-			hcon->smp_key_size, hcon->auth, rp->ediv,
-			rp->rand, key->val);
-
-	*keydist &= ~SMP_DIST_ENC_KEY;
-	if (hcon->out) {
-		if (!(*keydist))
-			smp_distribute_keys(conn, 1);
-	}
+	hci_dev_lock(hdev);
+	authenticated = (conn->hcon->sec_level == BT_SECURITY_HIGH);
+	hci_add_ltk(conn->hcon->hdev, conn->dst, hcon->dst_type,
+		    HCI_SMP_LTK, 1, authenticated, smp->tk, smp->enc_key_size,
+		    rp->ediv, rp->rand);
+	smp_distribute_keys(conn, 1);
+	hci_dev_unlock(hdev);
 
 	return 0;
 }
 
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct hci_conn *hcon = conn->hcon;
 	__u8 code = skb->data[0];
 	__u8 reason;
 	int err = 0;
 
-	if (IS_ERR(hcon->hdev->tfm)) {
-		err = PTR_ERR(hcon->hdev->tfm);
+	if (!lmp_host_le_capable(conn->hcon->hdev)) {
+		err = -ENOTSUPP;
 		reason = SMP_PAIRING_NOTSUPP;
-		BT_ERR("SMP_PAIRING_NOTSUPP %p", hcon->hdev->tfm);
 		goto done;
 	}
 
-	hcon->smp_conn = conn;
 	skb_pull(skb, sizeof(code));
 
+	/*
+	 * The SMP context must be initialized for all other PDUs except
+	 * pairing and security requests. If we get any other PDU when
+	 * not initialized simply disconnect (done if this function
+	 * returns an error).
+	 */
+	if (code != SMP_CMD_PAIRING_REQ && code != SMP_CMD_SECURITY_REQ &&
+	    !conn->smp_chan) {
+		BT_ERR("Unexpected SMP command 0x%02x. Disconnecting.", code);
+		kfree_skb(skb);
+		return -ENOTSUPP;
+	}
+
 	switch (code) {
 	case SMP_CMD_PAIRING_REQ:
 		reason = smp_cmd_pairing_req(conn, skb);
 		break;
 
 	case SMP_CMD_PAIRING_FAIL:
+		smp_failure(conn, skb->data[0], 0);
 		reason = 0;
 		err = -EPERM;
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, skb->data[0]);
-		hci_conn_put(hcon);
 		break;
 
 	case SMP_CMD_PAIRING_RSP:
@@ -922,40 +916,33 @@
 	}
 
 done:
-	if (reason) {
-		BT_ERR("SMP_CMD_PAIRING_FAIL: %d", reason);
-		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
-								&reason);
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
-		hci_conn_put(hcon);
-	}
+	if (reason)
+		smp_failure(conn, reason, 1);
 
 	kfree_skb(skb);
 	return err;
 }
 
-static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
+int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 {
-	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp;
+	struct smp_chan *smp = conn->smp_chan;
 	__u8 *keydist;
 
 	BT_DBG("conn %p force %d", conn, force);
 
-	if (IS_ERR(hcon->hdev->tfm))
-		return PTR_ERR(hcon->hdev->tfm);
+	if (!test_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags))
+		return 0;
 
-	rsp = (void *) &hcon->prsp[1];
+	rsp = (void *) &smp->prsp[1];
 
 	/* The responder sends its keys first */
-	if (!force && hcon->out && (rsp->resp_key_dist & 0x07))
+	if (!force && conn->hcon->out && (rsp->resp_key_dist & 0x07))
 		return 0;
 
-	req = (void *) &hcon->preq[1];
+	req = (void *) &smp->preq[1];
 
-	if (hcon->out) {
+	if (conn->hcon->out) {
 		keydist = &rsp->init_key_dist;
 		*keydist &= req->init_key_dist;
 	} else {
@@ -969,6 +956,8 @@
 	if (*keydist & SMP_DIST_ENC_KEY) {
 		struct smp_cmd_encrypt_info enc;
 		struct smp_cmd_master_ident ident;
+		struct hci_conn *hcon = conn->hcon;
+		u8 authenticated;
 		__le16 ediv;
 
 		get_random_bytes(enc.ltk, sizeof(enc.ltk));
@@ -977,9 +966,10 @@
 
 		smp_send_cmd(conn, SMP_CMD_ENCRYPT_INFO, sizeof(enc), &enc);
 
-		hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
-				hcon->smp_key_size, hcon->auth, ediv,
-				ident.rand, enc.ltk);
+		authenticated = hcon->sec_level == BT_SECURITY_HIGH;
+		hci_add_ltk(conn->hcon->hdev, conn->dst, hcon->dst_type,
+			    HCI_SMP_LTK_SLAVE, 1, authenticated,
+			    enc.ltk, smp->enc_key_size, ediv, ident.rand);
 
 		ident.ediv = cpu_to_le16(ediv);
 
@@ -1018,55 +1008,11 @@
 		*keydist &= ~SMP_DIST_SIGN;
 	}
 
-	if (hcon->out) {
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, 0);
-		del_timer(&hcon->smp_timer);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		hci_conn_put(hcon);
-	} else if (rsp->resp_key_dist) {
-		if (hcon->disconn_cfm_cb)
-			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
-		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-		mgmt_auth_failed(hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
-		hci_conn_put(hcon);
+	if (conn->hcon->out || force) {
+		clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags);
+		cancel_delayed_work_sync(&conn->security_timer);
+		smp_chan_destroy(conn);
 	}
 
 	return 0;
 }
-
-int smp_link_encrypt_cmplt(struct l2cap_conn *conn, u8 status, u8 encrypt)
-{
-	struct hci_conn *hcon = conn->hcon;
-
-	BT_DBG("smp: %d %d %d", status, encrypt, hcon->sec_req);
-
-	clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
-
-	if (!status && encrypt && hcon->sec_level < hcon->pending_sec_level)
-		hcon->sec_level = hcon->pending_sec_level;
-
-	if (!status && encrypt && !hcon->sec_req)
-		return smp_distribute_keys(conn, 0);
-
-	/* Fall back to Pairing request if failed a Link Security request */
-	else if (hcon->sec_req  && (status || !encrypt))
-		smp_conn_security(conn, hcon->pending_sec_level);
-
-	hci_conn_put(hcon);
-
-	return 0;
-}
-
-void smp_timeout(unsigned long arg)
-{
-	struct l2cap_conn *conn = (void *) arg;
-	u8 reason = SMP_UNSPECIFIED;
-
-	BT_DBG("%p", conn);
-
-	smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason), &reason);
-	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->pend);
-	mgmt_auth_failed(conn->hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
-	hci_conn_put(conn->hcon);
-}

diff -urN flo-ElementalX-5.00/drivers/power/bq27541_battery.c flo-ElementalX-5.00-patched/drivers/power/bq27541_battery.c
--- flo-ElementalX-5.00/drivers/power/bq27541_battery.c	2016-06-07 02:01:10.000000000 +0000
+++ flo-ElementalX-5.00-patched/drivers/power/bq27541_battery.c 2016-06-08 15:57:23.000000000 +0000
@@ -188,13 +188,8 @@
 	        usb_on = 0;
 	}
 	else if(bq27541_battery_cable_status  == USB_Cable) {
-		if (force_fast_charge == 1) {
-			ac_on = 1;
-			usb_on = 0;
-		} else {
 			usb_on = 1;
 			ac_on = 0;
-		}
 	}
 	else {
 		ac_on = 0;
